@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f crackers_joins
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Cracker Joins 


@+ Interface


@- Type expansion

@= TypeSwitch_1
@:@1(int,simple,,int)@
@

@- Header file

@h
#ifndef _CRACKERS_JOINS_H_
#define _CRACKERS_JOINS_H_
/* Exported signatures */
@:TypeSwitch_1(JoinFunctions_decl1)@
crackers_export str CRKbatCount(lng *count, int *bid);
crackers_export str CRKmaterializeH(int *res, int *bid);

/* #define DEBUG_CRACKERS_JOIN 		to enable debug trace */
 #define TIMER_CRACKERS_JOIN 		to enable timing pieces 
#endif /* _CRACKERS_JOINS_H */
@

@- Exported signatures

@= JoinFunctions_decl1
crackers_export str CRKsimpleJoin_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKcrackJoin_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKcrackHashJoin_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKcacheConsciousCrackHashJoin_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold);
crackers_export str CRKactiveCacheConsciousCrackHashJoin_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold, @1 *minLeft, @1 *maxLeft, @1 *minRight, @1 *maxRight, int *mode);
crackers_export str CRKcacheConsciousCrackHashJoinAlignOnly_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold);
crackers_export str CRKFullAlignment_@1(int *res, int *bidL, int *bidR1, int *bidR2);
crackers_export str CRKAlreadyAlignedJoin_@1(int *res, int *bidL, int *bidR1, int *bidR2);
crackers_export str CRKAlignJoin_@1(int *res, int *bidL, int *bidR1, int *bidR2);
crackers_export str CRKOnePassJoin_@1(int *res, int *bidL, int *bidR1, int *bidR2);
crackers_export str CRKbandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKsortBandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh);
@


@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"
#include "bat5.h"

/* Local support functions and macros */

@= hashjoin
	{
                BUN yy;

                BATloop(l, p, q) {
                        v = BUN@3(li, p);
                        if (@1_EQ(v, nil, @2)) {
                                continue; /* skip nil */
                        }
                        HASHloop_@2(ri, r->H->hash, yy, v) {
                                bunfastins(bn, BUNhead(li, p), BUNtail(ri, yy));
                        }
                }
                /* set sorted flags by hand, because we used BUNfastins() */
                bn->hsorted = BAThordered(l);
                bn->tsorted = FALSE;
                break;
	}

@c

lng
CRKjoin(BAT *bn, BAT *l, BAT *r) {
	ptr v, nil = ATOMnilptr(r->htype);
	BUN p, q;
	int any;
	lng T1=GDKusec(), T2;
	BATiter li = bat_iterator(l);
        BATiter ri = bat_iterator(r);

	BATmmap_pin(r);
	if (BATprepareHash(r)){
		T2=GDKusec();
		return T2-T1;
	}
	switch (any = ATOMstorage(l->ttype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:hashjoin(simple,chr,tloc)@
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:hashjoin(simple,bte,tloc)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:hashjoin(simple,sht,tloc)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
	case TYPE_int:
	case TYPE_flt:
		@:hashjoin(simple,int,tloc)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
	case TYPE_dbl:
	case TYPE_lng:
		@:hashjoin(simple,lng,tloc)@
#endif
	default:
		@:hashjoin(atom,any,tail)@
	}

      bunins_failed: /* blindly assume bunins does NOT fail*/
	BATmmap_unpin(r);
	T2=GDKusec();
	return T2-T1;
}

/* Exported functions */
@:TypeSwitch_1(JoinFunctions_impl_1)@

str CRKbatCount(lng *count, int *bid){
	BAT *b=BATdescriptor(*bid);
	*count = BATcount(b);
	BBPunfix(b->batCacheid);	
	return MAL_SUCCEED;
}

str CRKmaterializeH(int *res, int *bid){
	BAT *b=BATdescriptor(*bid);
	b=BATmaterializeh(b);
	BBPunfix(b->batCacheid);	
	(void)res;
	return MAL_SUCCEED;
}
@


@- Exported functions

@= JoinTwoPieces
	joinsDone++;
	viewHeadLeft = VIEWhead_(mapLeft,  BAT_READ);
	viewHeadRight = VIEWhead_(mapRight,  BAT_READ);

	viewLeft  = BATslice(viewHeadLeft, prevPosLeft,  curPosLeft +1);
        BBPunfix(viewHeadLeft->batCacheid);

        viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
        BBPunfix(viewHeadRight->batCacheid);

	markedViewLeft  = (BAT*)BATmark(viewLeft,prevPosLeft);
        BBPunfix(viewLeft->batCacheid);

        markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
        BBPunfix(viewRight->batCacheid);

	if (curPosLeft - prevPosLeft +1> 0 && curPosRight - prevPosRight+1 > 0) {
		if ( curPosLeft - prevPosLeft+1 < curPosRight - prevPosRight+1 ){ 
			TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
		}
		else{ 
			TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
		}
	}
/*
printf("Join %lld, Cost %lld, Left "OIDFMT" Right "OIDFMT"\n",joinsDone, TJtotal-temp, curPosLeft - prevPosLeft +1, curPosRight - prevPosRight +1);
*/
	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(markedViewLeft->batCacheid);
@

@= dumpIndex
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n @1 \n");
	printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, baseLeft);
	printf("\n Index Right \n");
	printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight);
#endif

@= JoinTwoSuperPiecesReuseHashTables
#ifdef TIMER_CRACKERS_JOIN
		joinsDone++;
#endif
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	invalidateHash=FALSE;
	if (prevNodeLeft != NULL){
		if (prevNodeLeft->slice != -1){
			temp = prevNodeLeft;
			existsHashTableLeft = TRUE;
			while (temp->indexPosition != curPosLeft){
				if (temp->slice != prevNodeLeft->slice){
					invalidateHash=TRUE;
					break;
				}
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		}else
			invalidateHash=TRUE;
	}
	if (invalidateHash == TRUE){
		int lastHash=-1;
		existsHashTableLeft = FALSE;
		temp = prevNodeLeft;
		while (temp->indexPosition != curPosLeft){
			if (temp->slice!=-1){
				lastHash=temp->slice;
				BBPdecref(temp->slice,TRUE);
				while (temp->slice==lastHash){
					temp->slice=-1;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
				continue;
			}
			if (temp->nextValue==NULL)
				break;
			temp=temp->nextValue;
		}
	}
	if (existsHashTableLeft == FALSE){
		viewHeadLeft = VIEWhead_(mapLeft,  BAT_READ);
		viewLeft  = BATslice(viewHeadLeft, prevPosLeft,  curPosLeft +1);
	        BBPunfix(viewHeadLeft->batCacheid);
		markedViewLeft  = (BAT*)BATmark(viewLeft,prevPosLeft);
	        BBPunfix(viewLeft->batCacheid);
	}
	else {
		if ((markedViewLeft = BATdescriptor(prevNodeLeft->slice)) == NULL)
		        	throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
	}

	invalidateHash=FALSE;
	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice){
					invalidateHash=TRUE;
					break;
				}
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		}else
			invalidateHash=TRUE;
	}
	if (invalidateHash == TRUE){
		int lastHash=-1;
		existsHashTableRight = FALSE;
		temp = prevNodeRight;
		while (temp->indexPosition != curPosRight){
			if (temp->slice!=-1){
				lastHash=temp->slice;
				BBPdecref(temp->slice,TRUE);
				while (temp->slice==lastHash){
					temp->slice=-1;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
				continue;
			}
			if (temp->nextValue==NULL)
				break;
			temp=temp->nextValue;
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	        viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	        BBPunfix(viewHeadRight->batCacheid);
        	markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
	        BBPunfix(viewRight->batCacheid);
	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(markedViewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif
	sizeLeft = curPosLeft - prevPosLeft + 1;
	sizeRight = curPosRight - prevPosRight + 1;
	if (sizeLeft > 0 && sizeRight > 0) {
	(void) joinThreshold;
		if (existsHashTableLeft == FALSE && existsHashTableRight == TRUE){
			/* If the size with the hash table does not fit in cache while the other does, then build new hash table on the smaller size */
			if (sizeLeft < sizeRight){
				if (sizeLeft <  (oid)*joinThreshold){
					if  (sizeRight >  (oid)*joinThreshold){
						reversingJoinOrder++;
						TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
					}
				}
			}else{	
				TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
			}
		}else 
		if (existsHashTableLeft == TRUE && existsHashTableRight == FALSE){
			if (sizeRight < sizeLeft){
				if (sizeRight < (oid)*joinThreshold){
					if  (sizeLeft >  (oid)*joinThreshold){
						reversingJoinOrder++;
						TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
					}
				}
			}else{	
				TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
			}
		}else{
			if  (sizeLeft < sizeRight){ 
				TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
				if (prevNodeLeft != NULL && existsHashTableLeft == FALSE){
					temp = prevNodeLeft;
					while (temp->indexPosition != curPosLeft){

						temp->slice = markedViewLeft->batCacheid;
						if (temp->nextValue==NULL)
							break;
						temp=temp->nextValue;
					}
					BBPincref(markedViewLeft->batCacheid,TRUE);
				}				
			}else{ 
				TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
				if (prevNodeRight != NULL && existsHashTableRight == FALSE){
					temp = prevNodeRight;
					while (temp->indexPosition != curPosRight){
						temp->slice = markedViewRight->batCacheid;
						if (temp->nextValue==NULL)
							break;
						temp=temp->nextValue;
					}
					BBPincref(markedViewRight->batCacheid,TRUE);
				}
				
			}

		}
		BBPunfix(markedViewRight->batCacheid);
		BBPunfix(markedViewLeft->batCacheid);
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@
@= JoinTwoPiecesReuseHashTables
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	joinsDone++;
	if (prevNodeLeft != NULL){
		if (prevNodeLeft->slice != -1){
			if ((markedViewLeft = BATdescriptor(prevNodeLeft->slice)) == NULL)
		        	throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
			else
				existsHashTableLeft = TRUE;
		}
	}
	if (existsHashTableLeft == FALSE){
		viewHeadLeft = VIEWhead_(mapLeft,  BAT_READ);
		viewLeft  = BATslice(viewHeadLeft, prevPosLeft,  curPosLeft +1);
	        BBPunfix(viewHeadLeft->batCacheid);
		markedViewLeft  = (BAT*)BATmark(viewLeft,prevPosLeft);
	        BBPunfix(viewLeft->batCacheid);
	}

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
                        if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
                        	throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
			else
				existsHashTableRight = TRUE;
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	        viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	        BBPunfix(viewHeadRight->batCacheid);
        	markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
	        BBPunfix(viewRight->batCacheid);
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(markedViewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif

	if (curPosLeft - prevPosLeft +1> 0 && curPosRight - prevPosRight +1> 0) {
		if (existsHashTableLeft == FALSE && existsHashTableRight == TRUE){
			TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
		}else 
		if (existsHashTableLeft == TRUE && existsHashTableRight == FALSE){
			TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
		}else{
			if  (curPosLeft - prevPosLeft+1 < curPosRight - prevPosRight+1){ 
				TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
				if (prevNodeLeft != NULL && existsHashTableLeft == FALSE){
					prevNodeLeft->slice = markedViewLeft->batCacheid;
					BBPincref(markedViewLeft->batCacheid,TRUE);
				}				
			}else{ 
				TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
				if (prevNodeRight != NULL && existsHashTableRight == FALSE){
					prevNodeRight->slice = markedViewRight->batCacheid;
					BBPincref(markedViewRight->batCacheid,TRUE);
				}
				
			}
		}
		BBPunfix(markedViewRight->batCacheid);
		BBPunfix(markedViewLeft->batCacheid);
	}
#ifdef DEBUG_CRACKERS_JOIN
	printf("Join %lld, Cost %lld, Left "OIDFMT" Right "OIDFMT" ReuseHash: %d \n",joinsDone, TJtotal-temp, curPosLeft - prevPosLeft +1, curPosRight - prevPosRight +1, (existsHashTableLeft == FALSE && existsHashTableRight == TRUE)?1:0);
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= SinglePassJoin
	existsHashTableRight = FALSE;

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	       	viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	       	BBPunfix(viewHeadRight->batCacheid);
		markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
		BBPunfix(viewRight->batCacheid);


	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif

	if (BATcount(markedViewRight) <= BATcount(partitionLeft)){
		CRKjoin(res, partitionLeft, markedViewRight);
		if (existsHashTableRight == FALSE){
			if (prevNodeRight != NULL){
				BBPincref(markedViewRight->batCacheid,TRUE);
			
				temp = prevNodeRight;
				while (temp->indexPosition != curPosRight){
					temp->slice = markedViewRight->batCacheid;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
			}
		}
	}else
		CRKjoin(BATmirror(res), BATmirror(markedViewRight), BATmirror(partitionLeft));

	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(partitionLeft->batCacheid);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= AlignJoin
	existsHashTableRight = FALSE;
	viewLeft  = BATslice(mapLeft, prevPosLeft,  curPosLeft +1);

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	       	viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	       	BBPunfix(viewHeadRight->batCacheid);
		markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
		BBPunfix(viewRight->batCacheid);


	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif

	if (BATcount(viewLeft)> 0 && BATcount(markedViewRight) > 0){ 
		if (BATcount(markedViewRight) <= BATcount(viewLeft)){
			CRKjoin(res, viewLeft, markedViewRight);
			if (existsHashTableRight == FALSE){
				if (prevNodeRight != NULL){
					BBPincref(markedViewRight->batCacheid,TRUE);
				
					temp = prevNodeRight;
					while (temp->indexPosition != curPosRight){
						temp->slice = markedViewRight->batCacheid;
						if (temp->nextValue==NULL)
							break;
						temp=temp->nextValue;
					}
				}
			}
		}else
			CRKjoin(BATmirror(res), BATmirror(markedViewRight), BATmirror(viewLeft));
	}
	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(viewLeft->batCacheid);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= JoinTwoPiecesReuseHashTablesRight
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	viewLeft  = BATslice(mapLeft, prevPosLeft+1,  curPosLeft +1);

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	       	viewRight = BATslice(viewHeadRight, prevPosRight+1, curPosRight+1);
	       	BBPunfix(viewHeadRight->batCacheid);
		markedViewRight = (BAT*)BATmark(viewRight,prevPosRight+1);
		BBPunfix(viewRight->batCacheid);


	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif
	TJ1=GDKusec();

	if (curPosLeft - prevPosLeft > 0 && curPosRight - prevPosRight > 0){ 
		CRKjoin(res, viewLeft, markedViewRight);
		if (existsHashTableRight == FALSE){
			if (prevNodeRight != NULL){
				BBPincref(markedViewRight->batCacheid,TRUE);
			
				temp = prevNodeRight;
				while (temp->indexPosition != curPosRight){
					temp->slice = markedViewRight->batCacheid;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
			}
		}
	}

	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(viewLeft->batCacheid);

	TJ2=GDKusec();
	TJtotal += TJ2 - TJ1;
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= MoveToNextPiece
#ifdef DEBUG_CRACKERS_JOIN
	printf("Move @2 \n"); 
#endif
	prevPos@2 = curPos@2;
	curNode@2 = findNextPiece(curNode@2);
	if (curNode@2 != NULL){
		curTuple@2 = base@2 + curNode@2->position;
		curValue@2 =  *(@1 *)Tloc(index@2, curTuple@2);
		curPos@2   =  *(oid*)Hloc(index@2, curTuple@2);
	}
@


@= addPartialResult
	curViewTupleHead = (oid*)Hloc(b,BUNfirst(b)+vl);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n adding tuples "OIDFMT" to "OIDFMT" \n",vl,vh);
	BATprint(b);
#endif

	for (j=vl;j<vh+1;j++){
		*currentResTupleHead = *currentTupleLeftHead;	
		*currentResTupleTail = *curViewTupleHead;	

		curViewTupleHead ++;
		currentResTupleHead ++;
		currentResTupleTail ++;
	}


	resCount += (vh-vl) + 1;
@

@= sortInsertPartialResult
	*currentResTupleHead = *currentTupleLeftHead;
	*currentResTupleTail = *(oid*)Hloc(BATRight, currentTupleRight);
	
	currentTupleRight   ++;
        currentResTupleHead ++;
        currentResTupleTail ++;
	resCount++;

        if (currentTupleRight == BUNlast(BATRight))
		goto next;
@

@= crackDoubleSidedBound
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LE_RE_@1(b,low,hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LE_RO_@1(b,low,hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LO_RE_@1(b,low,hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LO_RO_@1(b,low,hgh, @2, @3, &vl, &vh);
				
	/*if (vl != -1 && vh != -1){*/
		if (vl>0) _vl=vl-1; else _vl=vl;		
		addCrackerIndex_@1(m,&low,*inclusiveLow,_vl,c);
		addCrackerIndex_@1(m,&hgh,HBound,vh,c);
	
@

@= crackSingleSidedBoundLeft
	if (*inclusiveLow == TRUE)
		CRKcrackUnorderedZero_RE_@1(b,low, cl1, ch1,&vl);
	else
		CRKcrackUnorderedZero_LE_@1(b,low, cl1, ch1,&vl);
	if (vl < cl1){
		gapL = -1;
	}
	if (vl > ch1){
		vl--;
		gapL = -1;
	}
	vl++; 
@

@= crackSingleSidedBoundRight
	if (*inclusiveHgh == TRUE)
		CRKcrackUnorderedZero_LE_@1(b,hgh, cl2, ch2,&vh);
	else
		CRKcrackUnorderedZero_RE_@1(b,hgh, cl2, ch2,&vh);

	if (vh < cl2)
		gapH = -1;
	if (vh > ch2){
		gapH = -1;
		vh--;
	}
@

@= CreateCrackerMap
		BAT *bo, *bp, *b, *c;
                oid sizeM;
                @2 *ptail, *ntail;
		@1 *nhead, *ctail;
		oid j;
		int m;

		TC1=GDKusec();	
                if ((bo = BATdescriptor(@3)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access descriptor of map head BAT");
                if ((bp = BATdescriptor(@4)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access pdescriptor of map tail BAT");

                sizeM = BATcount(bo);
		b = BATnew(bo->ttype, bp->ttype, sizeM);
		nhead = (@1*)Hloc(b,  BUNfirst(b));
		ctail = (@1*)Tloc(bo, BUNfirst(bo));
		for(j=0;j<sizeM;j++){
			*nhead = *ctail;
			nhead++;
			ctail++;
		}

		/*TODO string support should be done here as in crackeres.sideways*/
		ntail = (@2*)Tloc(b,  BUNfirst(b));
		ptail = (@2*)Tloc(bp, BUNfirst(bp));
		for(j=0;j<sizeM;j++){
			*ntail = *ptail;
			ntail++;
			ptail++;
		}

                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;

                /*BATkey(b,TRUE);*/

                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);
	
        	BATsetcount(b, sizeM);

		c = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */

                m = newCrackerIndexSideways_@1(@3, b->batCacheid, @4, c->batCacheid);
		CrackerIndex[m].creationTimestamp = GDKusec();
		CrackerIndex[m].accesses = 1;
		CrackerIndex[m].dropped = 0;
		CrackerIndex[m].tuples = sizeM;

		/* storage management should be here as in crackers.sideways*/

                BBPunfix(bo->batCacheid);
                BBPunfix(bp->batCacheid);
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);

		TC2=GDKusec();	
		TCtotal+=TC2-TC1;
@

@= activeCrackInitialize
	if (*mode==4){
		struct Node * temp = curNode@1;
		oid maxPieceSize = 0, prevPos = 0, curSize;
		
		while (1){
			curSize = temp==NULL ? BATcount(map@1) - prevPos + 1 : temp->indexPosition - prevPos + 1;
			if (maxPieceSize < curSize){
				maxPieceSize = curSize;
				positionOfPieceToCrack@1 = prevPos;
			}
			if (temp == NULL) break;
			prevPos = temp->indexPosition;
			temp = temp->nextValue;
		}

		if (positionOfPieceToCrack@1 >0 ) positionOfPieceToCrack@1 ++;
	}	
@

@= activeCrack
		
	/*Mode 1. Every piece we see on the way we crack it if bigger than the threshold*/
	/*Mode 2. Crack every piece all the way to the threshold*/
	/*Mode 3. Same as Mode 2 but use double sided cracking*/
	/*Mode 4. Perform a single crack operation on the biggest piece of each join input*/

	if (*mode==1 || *mode==2 || (*mode==3 && (size@3 < (oid)(3 * (*pieceSize)))) || (*mode==4 && positionOfPieceToCrack@3 == cprevPos@3) ){
		if (size@3 > (oid)*pieceSize){
			@1 oldmid;
			bit activeCrack = TRUE;
			low=prevNode@3==NULL?*min@3:(*(@1 *)Tloc(index@3, base@3 + prevNode@3->position));
			hgh=curNode@3 ==NULL?*max@3:(*(@1 *)Tloc(index@3, base@3 + curNode@3->position ));
			mid = (hgh - low)/2 +low;
			oldmid = mid - 1;
			while (1){
				if (oldmid == mid || mid == *min@3 || mid == *max@3){
					activeCrack = FALSE;
					break;
				}
				TC1=GDKusec();	
				CRKcrackUnorderedZeroSideways_RE_@1_@2(map@3, mid, cprevPos@3, curPos@3, &newPosition);
				TC2=GDKusec();	
				TCtotal+=TC2-TC1;

				/*if we get an empty piece adjust the range in half and retry*/
				if (newPosition > cprevPos@3 && newPosition < curPos@3) break;
				else if (newPosition < cprevPos@3) 
					low = mid;
				else 
					hgh = mid;
				oldmid = mid;		
				mid    = (hgh - low)/2 +low;
			}
			if (activeCrack){	
				curNode@3 = addCrackerIndex_@1(mapPos@3, &mid, TRUE, newPosition, index@3);
				AddToTape_@1(mapPos@3, @1_nil, mid, TRUE, TRUE);
				curPos@3 = newPosition;
				
				/*if the current piece is still over the threshold, then start again*/
				if (*mode==2 || *mode==3){
					size@3=curPos@3-prevPos@3+1;
					if (size@3 > (oid)*pieceSize)
						continue;
				}
			}
		}
	}else 
	if (*mode==3){
		if (size@3 >= (oid)(3 * (*pieceSize))){
			low=prevNode@3==NULL?*min@3:(*(@1 *)Tloc(index@3, base@3 + prevNode@3->position));
			hgh=curNode@3 ==NULL?*max@3:(*(@1 *)Tloc(index@3, base@3 + curNode@3->position ));
			step = (hgh - low)/3;
			mid1 = low  + step;
			mid2 = mid1 + step;

			TC1=GDKusec();	
			CRKcrackUnorderedThreeSideways_LE_RE_@1_@2(map@3,mid1,mid2, cprevPos@3, curPos@3, &newPosition, &newPosition2);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition>0) newPosition-=1;
			curNode@3 = addCrackerIndex_@1(mapPos@3, &mid1, TRUE, newPosition, index@3);
				    addCrackerIndex_@1(mapPos@3, &mid2, TRUE, newPosition2, index@3);
			AddToTape_@1(mapPos@3, @1_nil, mid1, TRUE, TRUE);
			AddToTape_@1(mapPos@3, @1_nil, mid2, TRUE, TRUE);
			curPos@3 = newPosition;
			
			/*if the current piece is still over the threshold, then start again*/
			size@3=curPos@3-prevPos@3+1;
			if (size@3 > (oid)*pieceSize)
				continue;
		}
	}
@

@= JoinFunctions_impl_1
str CRKsimpleJoin_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){
	lng TJtotal = 0, T1=GDKusec(), T2, TCtotal=0;
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN curTupleLeft, baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN curTupleRight, baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;

	lng joinsDone=0;

	BAT *res;

	/* Get the cracker tape for the set of the left 
	   map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or 
		create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapLeft));

	prevPosLeft = prevPosRight = 0;
	if (curNodeLeft == NULL || curNodeRight == NULL){
		curPosLeft  = BATcount(mapLeft ) -1;
		curPosRight = BATcount(mapRight) -1;
		@:JoinTwoPieces()@
		goto done;
	}

	curTupleLeft = baseLeft + curNodeLeft->position;
        curValueLeft =  *(@1*)Tloc(indexLeft, curTupleLeft);
        curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);

        curTupleRight = baseRight + curNodeRight->position;
        curValueRight =  *(@1*)Tloc(indexRight, curTupleRight);
        curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);

	@:JoinTwoPieces()@
	
	while (1){

		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){
			@:MoveToNextPiece(@1,Left)@
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			@:MoveToNextPiece(@1,Right)@
		}
		else if ((curValueLeft == curValueRight) && (curNodeLeft->inclusive == curNodeRight->inclusive)){
			@:MoveToNextPiece(@1,Left)@
			@:MoveToNextPiece(@1,Right)@
		}

		if (curNodeLeft == NULL || curNodeRight == NULL){
			curPosLeft  = BATcount(mapLeft ) -1;
			curPosRight = BATcount(mapRight) -1;
			@:JoinTwoPieces()@
			break;
		}

		@:JoinTwoPieces()@

	}
	

	done:;

        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  %lld Join %lld Rest  %lld Joins %lld Crack %lld Pieces %lld \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );

	return MAL_SUCCEED;
}	

str CRKcrackJoin_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){
	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN curTupleLeft, baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;
	bit crackedLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN curTupleRight, baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;
	bit crackedRight;

	BAT *res;
	oid newPosition=0;

	lng crackedOperationsLeft = 0 , crackedOperationsRight = 0, joinsDone = 0;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

#ifdef DEBUG_CRACKERS_JOIN
	printf("maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapLeft));
	
	prevPosLeft = prevPosRight = 0;

	while (curNodeLeft != NULL && curNodeRight != NULL){

#ifdef DEBUG_CRACKERS_JOIN
	printf(" new loop maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif
		crackedLeft = crackedRight = FALSE;


		curTupleLeft = baseLeft + curNodeLeft->position;
       		curValueLeft =  *(@1 *)Tloc(indexLeft, curTupleLeft);
        	curPosLeft   =  *(oid*)Hloc(indexLeft, curTupleLeft);

        	curTupleRight = baseRight + curNodeRight->position;
        	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);

		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 

#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft %lld curPosLeft %lld \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight %lld curPosRight %lld \n", prevPosRight,curPosRight);
#endif

		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

			crackedOperationsRight++;

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < prevPosRight || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosLeft   = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}
			if (newPosition < curPosRight){
				addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){

			crackedOperationsLeft++;

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < prevPosLeft || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosRight   = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}
			if (newPosition < curPosLeft){
				addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
		}

		@:JoinTwoPieces()@

		prevPosLeft = curPosLeft+1;
		if (crackedLeft == FALSE)
			curNodeLeft = curNodeLeft->nextValue;
				
		prevPosRight = curPosRight+1;
		if (crackedRight == FALSE)
        		curNodeRight = curNodeRight->nextValue;
	}

	while(1){
		crackedLeft = crackedRight = FALSE;

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
			curTupleLeft = baseLeft + curNodeLeft->position;
        	        curValueLeft = *(@1 *)Tloc(indexLeft, curTupleLeft);
	                curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
			curTupleRight = baseRight + curNodeRight->position;
   	             	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	        curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);	
		}
		
#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft %lld curPosLeft %lld \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight %lld curPosRight %lld \n", prevPosRight,curPosRight);
#endif

		if (curNodeLeft != NULL && curNodeRight == NULL){	
			crackedOperationsRight++;

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < prevPosRight || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosLeft   = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}
			if (newPosition < curPosRight){
				addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */
				@:JoinTwoPieces()@
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			crackedOperationsLeft++;

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < prevPosLeft || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosRight   = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}
			if (newPosition < curPosLeft){
				addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
			else {
				@:JoinTwoPieces()@
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight == NULL){
			@:JoinTwoPieces()@
			break;
		}			

		@:JoinTwoPieces()@

		prevPosLeft = curPosLeft+1;
		if (crackedLeft == FALSE && curNodeLeft != NULL)
			curNodeLeft = curNodeLeft->nextValue;
				
		prevPosRight = curPosRight+1;
		if (crackedRight == FALSE && curNodeRight != NULL)
        		curNodeRight = curNodeRight->nextValue;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  %lld Join %lld Rest  %lld Joins %lld Crack %lld Pieces %lld \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );

	return MAL_SUCCEED;
}	

str CRKcacheConsciousCrackHashJoinAlignOnly_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold){
	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft, *prevNodeLeft; 
	BAT *indexLeft, *mapLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft, cprevPosLeft;
	@1  curValueLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight;
	BUN baseRight;
	oid curPosRight, prevPosRight, cprevPosRight;
        @1  curValueRight;

	BAT *res;
	oid newPosition=0;

	oid sizeLeft, sizeRight;
	oid iterations = 0;

	lng joinsDone = 0;

	(void)joinThreshold;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapLeft));
	
	prevPosLeft   = prevPosRight   = 0;
	prevNodeLeft  = prevNodeRight  = NULL;
	while (curNodeLeft != NULL && curNodeRight != NULL){
	
		iterations++;
		cprevPosRight = prevPosRight;
		cprevPosLeft  = prevPosLeft;

       		curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition; 

        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		
		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 


		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;
		
		if (sizeLeft < (oid)*pieceSize) {
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
			while (sizeLeft < (oid)*pieceSize){

				if (curNodeLeft->nextValue == NULL) goto cont;
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
					if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft)
						goto checkRight;
				}
 				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
				sizeLeft  = curPosLeft - prevPosLeft+1;
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
				
			}
		}
		checkRight:;
		if (sizeRight < (oid)*pieceSize){
			while (curValueRight > curValueLeft ||
				((curValueLeft == curValueRight) && 
					(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){ 
				if (curNodeLeft->nextValue == NULL) goto cont;
				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
			}
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) goto cont;
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
					if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight)
						goto cont;
				}
				cprevPosRight = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;
				curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				curPosRight   = curNodeRight->indexPosition;
				sizeRight  = curPosRight - prevPosRight+1;
				while (curValueRight > curValueLeft ||
                			((curValueLeft == curValueRight) && 
						(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))) { 
					if (curNodeLeft->nextValue == NULL) goto cont;
					cprevPosLeft = curPosLeft+1;
					curNodeLeft = curNodeLeft->nextValue;
					curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
					curPosLeft   = curNodeLeft->indexPosition; 
				}
			}
		}
		
		cont:;
		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
					TC2=GDKusec();	
					TCtotal+=TC2-TC1;

			if (newPosition < cprevPosRight){
				if (cprevPosRight == prevPosRight){
					prevNodeLeft = curNodeLeft;
					curNodeLeft  = curNodeLeft->nextValue;
					continue;
				}
				curPosRight = cprevPosRight - 1;
				curNodeRight = findPreviousPieceWalkingBack(curNodeRight);
			}else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosLeft){
				if (cprevPosLeft == prevPosLeft){
					prevNodeRight = curNodeRight;
					curNodeRight  = curNodeRight->nextValue;
					continue;
				}
				curPosLeft = cprevPosLeft - 1;
				curNodeLeft = findPreviousPieceWalkingBack(curNodeLeft);
			}else if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
		}


		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;

		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;

		prevPosLeft  = prevNodeLeft->indexPosition  + 1;
		prevPosRight = prevNodeRight->indexPosition + 1;
	}

	while(1){
		iterations++;
		
		prevPosLeft   = prevNodeLeft ==NULL?0:(prevNodeLeft->indexPosition==0?0:prevNodeLeft->indexPosition + 1);
		prevPosRight  = prevNodeRight==NULL?0:(prevNodeRight->indexPosition==0?0:prevNodeRight->indexPosition + 1);

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
        	        curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
	                curPosLeft   = curNodeLeft->indexPosition;
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
   	             	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	        curPosRight   = curNodeRight->indexPosition;
		}

		
		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

		if (sizeLeft < (oid)*pieceSize && curNodeLeft != NULL) {
			while (sizeLeft < (oid)*pieceSize){
				if (curNodeLeft->nextValue == NULL)  {
					if ( (BATcount(mapLeft)-1)- prevPosLeft <(oid)*pieceSize){
						curPosLeft  = BATcount(mapLeft)-1;
						curNodeLeft = NULL;
					}
					break;
				}
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
					if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft)
						goto checkRight2;
				}
				curNodeLeft = curNodeLeft->nextValue;
				curPosLeft   = curNodeLeft->indexPosition; 
        	        	curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				sizeLeft  = curPosLeft - prevPosLeft + 1;
			}
		}
		checkRight2:;
		if (sizeRight < (oid)*pieceSize && curNodeRight != NULL){
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) {
					if ( (BATcount(mapRight)-1)- prevPosRight <(oid)*pieceSize){
						curPosRight  = BATcount(mapRight)-1;
						curNodeRight = NULL;
					}
					break;
				}
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
					if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight)
						goto cont2;
				}
				curNodeRight = curNodeRight->nextValue;
				curPosRight   = curNodeRight->indexPosition;
   	             		curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				sizeRight  = curPosRight - prevPosRight + 1;
			}
		}
		cont2:;	
		if (curNodeLeft != NULL && curNodeRight == NULL){	
			
			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)

		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosRight){
				prevNodeLeft = curNodeLeft;
				curNodeLeft  = curNodeLeft->nextValue;	
				continue;
			}
			else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */


				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosLeft){
				prevNodeRight = curNodeRight;
				curNodeRight  = curNodeRight->nextValue;	
				continue;
			}else
			if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
			else {
				break;
			}
		}

		if (curNodeLeft == NULL && curNodeRight == NULL)
			break;

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;
	
		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  %lld Join %lld Rest  %lld Joins %lld Crack %lld Pieces %lld \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );
	return MAL_SUCCEED;

}	

str CRKcacheConsciousCrackHashJoin_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold){

	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft, *prevNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft, cprevPosLeft;
	@1  curValueLeft;
	bit existsHashTableLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN baseRight;
	oid curPosRight, prevPosRight, cprevPosRight;
        @1  curValueRight;
	bit existsHashTableRight;

	bit invalidateHash;
	
	BAT *res;
	oid newPosition=0;

	oid sizeLeft, sizeRight;
	oid iterations = 0;

	lng joinsDone = 0;
	lng reversingJoinOrder = 0;

	struct Node *temp;
	

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,BATcount(mapLeft));
	
	prevPosLeft   = prevPosRight   = 0;
	prevNodeLeft  = prevNodeRight  = NULL;
	while (curNodeLeft != NULL && curNodeRight != NULL){
	
		iterations++;
		cprevPosRight = prevPosRight;
		cprevPosLeft  = prevPosLeft;


		existsHashTableLeft = existsHashTableRight = FALSE;

       		curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition; 

        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		
		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 


		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;
		
		if (sizeLeft < (oid)*pieceSize) {
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
			while (sizeLeft < (oid)*pieceSize){

				if (curNodeLeft->nextValue == NULL) goto cont;
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
				/*	if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft)  */
						goto checkRight;
				}
 				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
				sizeLeft  = curPosLeft - prevPosLeft+1;
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
				
			}
		}
		checkRight:;
		if (sizeRight < (oid)*pieceSize){
			while (curValueRight > curValueLeft ||
				((curValueLeft == curValueRight) && 
					(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){ 
				if (curNodeLeft->nextValue == NULL) goto cont;
				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
			}
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) goto cont;
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
				/*	if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight) */
						goto cont;
				}
				cprevPosRight = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;
				curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				curPosRight   = curNodeRight->indexPosition;
				sizeRight  = curPosRight - prevPosRight+1;
				while (curValueRight > curValueLeft ||
                			((curValueLeft == curValueRight) && 
						(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))) { 
					if (curNodeLeft->nextValue == NULL) goto cont;
					cprevPosLeft = curPosLeft+1;
					curNodeLeft = curNodeLeft->nextValue;
					curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
					curPosLeft   = curNodeLeft->indexPosition; 
				}
			}
		}
		
		cont:;
		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosRight){
				if (cprevPosRight == prevPosRight){
					prevNodeLeft = curNodeLeft;
					curNodeLeft  = curNodeLeft->nextValue;
					continue;
				}
				curPosRight = cprevPosRight - 1;
				curNodeRight = findPreviousPieceWalkingBack(curNodeRight);
			}else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosLeft){
				if (cprevPosLeft == prevPosLeft){
					prevNodeRight = curNodeRight;
					curNodeRight  = curNodeRight->nextValue;
					continue;
				}
				curPosLeft = cprevPosLeft - 1;
				curNodeLeft = findPreviousPieceWalkingBack(curNodeLeft);
			}else if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
		}

		@:JoinTwoSuperPiecesReuseHashTables()@

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;

		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;

		prevPosLeft  = prevNodeLeft->indexPosition  + 1;
		prevPosRight = prevNodeRight->indexPosition + 1;
	}

	while(1){
		iterations++;
		existsHashTableLeft = existsHashTableRight = FALSE;
		
		prevPosLeft   = prevNodeLeft ==NULL?0:(prevNodeLeft->indexPosition==0?0:prevNodeLeft->indexPosition + 1);
		prevPosRight  = prevNodeRight==NULL?0:(prevNodeRight->indexPosition==0?0:prevNodeRight->indexPosition + 1);

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
        	        curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
	                curPosLeft   = curNodeLeft->indexPosition;
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
   	             	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	        curPosRight   = curNodeRight->indexPosition;
		}

		
		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

		if (sizeLeft < (oid)*pieceSize && curNodeLeft != NULL) {
			while (sizeLeft < (oid)*pieceSize){
				if (curNodeLeft->nextValue == NULL)  {
					if ( (BATcount(mapLeft)-1)- prevPosLeft <(oid)*pieceSize){
						curPosLeft  = BATcount(mapLeft)-1;
						curNodeLeft = NULL;
					}
					break;
				}
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
				/*	if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft) */
						goto checkRight2;
				}
				curNodeLeft = curNodeLeft->nextValue;
				curPosLeft   = curNodeLeft->indexPosition; 
        	        	curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				sizeLeft  = curPosLeft - prevPosLeft + 1;
			}
		}
		checkRight2:;
		if (sizeRight < (oid)*pieceSize && curNodeRight != NULL){
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) {
					if ( (BATcount(mapRight)-1)- prevPosRight <(oid)*pieceSize){
						curPosRight  = BATcount(mapRight)-1;
						curNodeRight = NULL;
					}
					break;
				}
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
				/*	if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight) */
						goto cont2;
				}
				curNodeRight = curNodeRight->nextValue;
				curPosRight   = curNodeRight->indexPosition;
   	             		curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				sizeRight  = curPosRight - prevPosRight + 1;
			}
		}

		cont2:;	
		if (curNodeLeft != NULL && curNodeRight == NULL){	
			
			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)

		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosRight){
				prevNodeLeft = curNodeLeft;
				curNodeLeft  = curNodeLeft->nextValue;	
				continue;
			}
			else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */

				@:JoinTwoSuperPiecesReuseHashTables()@

				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosLeft){
				prevNodeRight = curNodeRight;
				curNodeRight  = curNodeRight->nextValue;	
				continue;
			}else
			if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
			else {
				@:JoinTwoSuperPiecesReuseHashTables()@
				break;
			}
		}

		@:JoinTwoSuperPiecesReuseHashTables()@
		if (curNodeLeft == NULL && curNodeRight == NULL)
			break;

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;
	
		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  %lld Join %lld Rest  %lld Joins %lld Crack %lld Pieces %lld \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );
	return MAL_SUCCEED;

}	

str CRKactiveCacheConsciousCrackHashJoin_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold, @1 *minLeft, @1 *maxLeft, @1 *minRight, @1 *maxRight,int *mode){

	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	
	int tapeLpos, mapPosLeft;
	struct Node *curNodeLeft, *prevNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft, cprevPosLeft;
	@1  curValueLeft;
	bit existsHashTableLeft;

	int tapeRpos, mapPosRight;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN baseRight;
	oid curPosRight, prevPosRight, cprevPosRight;
        @1  curValueRight;
	bit existsHashTableRight;

	bit invalidateHash;
	
	BAT *res;
	oid newPosition=0, newPosition2=0;
	oid positionOfPieceToCrackLeft=0, positionOfPieceToCrackRight=0;

	oid sizeLeft, sizeRight;
	oid iterations = 0;

	lng joinsDone = 0;
	lng reversingJoinOrder = 0;

	struct Node *temp;
	
	@1 mid, low, hgh;
	@1 step, mid1, mid2;

	bit true = TRUE;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapPosLeft = existsCrackerIndexSideways(*bidL1, *bidL2);
	if (mapPosLeft == -1){
		@:CreateCrackerMap(@1,@1,*bidL1, *bidL2)@		
		mapPosLeft = m;
	}

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapPosLeft);

	selectMergeInsertionsPart_@1_@1_Sideways(minLeft, &true, maxLeft, &true, mapPosLeft);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapPosLeft].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapPosLeft].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapPosLeft].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapPosRight = existsCrackerIndexSideways(*bidR1, *bidR2);
	if (mapPosRight == -1){
		@:CreateCrackerMap(@1,@1,*bidR1,*bidR2)@		
		mapPosRight = m;
	}

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapPosRight);

	selectMergeInsertionsPart_@1_@1_Sideways(minRight, &true, maxRight, &true, mapPosRight);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapPosRight].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapPosRight].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapPosRight].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,BATcount(mapLeft));
	
	prevPosLeft   = prevPosRight   = 0;
	prevNodeLeft  = prevNodeRight  = NULL;

	@:activeCrackInitialize(Left)@
	@:activeCrackInitialize(Right)@

	while (curNodeLeft != NULL && curNodeRight != NULL){
		iterations++;
		cprevPosRight = prevPosRight;
		cprevPosLeft  = prevPosLeft;


		existsHashTableLeft = existsHashTableRight = FALSE;

       		curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition; 

        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		
		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 


		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

#ifdef DEBUG_CRACKERS_JOIN
		printf("\n itteration "OIDFMT" Index Left 1st \n", iterations);
		printAVLTree(CrackerIndex[mapPosLeft].Tree, indexLeft, baseLeft);
		printf("\n Index Right \n");
		printAVLTree(CrackerIndex[mapPosRight].Tree, indexRight, baseRight);
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif

		/* crack if the piece is too big */
		@:activeCrack(@1,@1,Left,Right)@
		@:activeCrack(@1,@1,Right,Left)@
			
		mainloop:;
		/*initialize variables again as pieces might have changed*/
       		curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition; 
        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;
		
		/* collect super pieces if piece is too small */
		if (sizeLeft < (oid)*pieceSize) {
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
			while (sizeLeft < (oid)*pieceSize){

				if (curNodeLeft->nextValue == NULL) goto cont;
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
				/*	if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft)  */
						goto checkRight;
				}
 				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
				sizeLeft  = curPosLeft - prevPosLeft+1;
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
				
			}
		}
		checkRight:;
		if (sizeRight < (oid)*pieceSize){
			while (curValueRight > curValueLeft ||
				((curValueLeft == curValueRight) && 
					(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){ 
				if (curNodeLeft->nextValue == NULL) goto cont;
				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
			}
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) goto cont;
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
				/*	if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight) */
						goto cont;
				}
				cprevPosRight = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;
				curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				curPosRight   = curNodeRight->indexPosition;
				sizeRight  = curPosRight - prevPosRight+1;
				while (curValueRight > curValueLeft ||
                			((curValueLeft == curValueRight) && 
						(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))) { 
					if (curNodeLeft->nextValue == NULL) goto cont;
					cprevPosLeft = curPosLeft+1;
					curNodeLeft = curNodeLeft->nextValue;
					curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
					curPosLeft   = curNodeLeft->indexPosition; 
				}
			}
		}
		
		cont:;
		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosRight){
				if (cprevPosRight == prevPosRight){
					prevNodeLeft = curNodeLeft;
					curNodeLeft  = curNodeLeft->nextValue;
					continue;
				}
				curPosRight = cprevPosRight - 1;
				curNodeRight = findPreviousPieceWalkingBack(curNodeRight);
			}else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapPosRight, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapPosRight, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosLeft){
				if (cprevPosLeft == prevPosLeft){
					prevNodeRight = curNodeRight;
					curNodeRight  = curNodeRight->nextValue;
					continue;
				}
				curPosLeft = cprevPosLeft - 1;
				curNodeLeft = findPreviousPieceWalkingBack(curNodeLeft);
			}else if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapPosLeft, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapPosLeft, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
		}

		@:JoinTwoSuperPiecesReuseHashTables()@

		if (curNodeLeft == NULL || curNodeRight == NULL)
			goto finished;

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;

		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;

		prevPosLeft  = prevNodeLeft->indexPosition  + 1;
		prevPosRight = prevNodeRight->indexPosition + 1;
	}

	while(1){
		iterations++;
		existsHashTableLeft = existsHashTableRight = FALSE;
		
		cprevPosLeft  = prevPosLeft   = prevNodeLeft ==NULL?0:(prevNodeLeft->indexPosition==0?0:prevNodeLeft->indexPosition + 1);
		cprevPosRight = prevPosRight  = prevNodeRight==NULL?0:(prevNodeRight->indexPosition==0?0:prevNodeRight->indexPosition + 1);

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
        	        curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
	                curPosLeft   = curNodeLeft->indexPosition;
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
   	             	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	        curPosRight   = curNodeRight->indexPosition;
		}

		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

#ifdef DEBUG_CRACKERS_JOIN
		printf("\n itteration "OIDFMT" Index Left 1st \n", iterations);
		printAVLTree(CrackerIndex[mapPosLeft].Tree, indexLeft, baseLeft);
		printf("\n Index Right \n");
		printAVLTree(CrackerIndex[mapPosRight].Tree, indexRight, baseRight);
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif


		@:activeCrack(@1,@1,Left,Right)@
		@:activeCrack(@1,@1,Right,Left)@

		if (curNodeLeft!=NULL && curNodeRight!=NULL) 
			goto mainloop;

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
        	        curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
	                curPosLeft   = curNodeLeft->indexPosition;
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
   	             	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	        curPosRight   = curNodeRight->indexPosition;
		}
		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

		if (sizeLeft < (oid)*pieceSize && curNodeLeft != NULL) {
			while (sizeLeft < (oid)*pieceSize){
				if (curNodeLeft->nextValue == NULL)  {
					if ( (BATcount(mapLeft)-1)- prevPosLeft <(oid)*pieceSize){
						curPosLeft  = BATcount(mapLeft)-1;
						curNodeLeft = NULL;
					}
					break;
				}
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
				/*	if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft) */
						goto checkRight2;
				}
				curNodeLeft = curNodeLeft->nextValue;
				curPosLeft   = curNodeLeft->indexPosition; 
        	        	curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				sizeLeft  = curPosLeft - prevPosLeft + 1;
			}
		}
		checkRight2:;
		if (sizeRight < (oid)*pieceSize && curNodeRight != NULL){
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) {
					if ( (BATcount(mapRight)-1)- prevPosRight <(oid)*pieceSize){
						curPosRight  = BATcount(mapRight)-1;
						curNodeRight = NULL;
					}
					break;
				}
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
				/*	if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight) */
						goto cont2;
				}
				curNodeRight = curNodeRight->nextValue;
				curPosRight   = curNodeRight->indexPosition;
   	             		curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				sizeRight  = curPosRight - prevPosRight + 1;
			}
		}

		cont2:;	
		if (curNodeLeft != NULL && curNodeRight == NULL){	
			
			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)

		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosRight){
				prevNodeLeft = curNodeLeft;
				curNodeLeft  = curNodeLeft->nextValue;	
				continue;
			}
			else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapPosRight, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapPosRight, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */

				@:JoinTwoSuperPiecesReuseHashTables()@

				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosLeft){
				prevNodeRight = curNodeRight;
				curNodeRight  = curNodeRight->nextValue;	
				continue;
			}else
			if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapPosLeft, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapPosLeft, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
			else {
				@:JoinTwoSuperPiecesReuseHashTables()@
				break;
			}
		}

		@:JoinTwoSuperPiecesReuseHashTables()@
		if (curNodeLeft == NULL && curNodeRight == NULL)
			break;

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;
	
		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;
	}

	finished:;
#ifdef DEBUG_CRACKERS_JOIN
		printf("\n itteration "OIDFMT" Index Left 1st \n", iterations);
		printAVLTree(CrackerIndex[mapPosLeft].Tree, indexLeft, baseLeft);
		printf("\n Index Right \n");
		printAVLTree(CrackerIndex[mapPosRight].Tree, indexRight, baseRight);
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif

        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  %lld Join %lld Rest  %lld Joins %lld Crack %lld Pieces %lld \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapPosLeft].pieces + CrackerIndex[mapPosRight].pieces );
	return MAL_SUCCEED;

}	

str CRKcrackHashJoin_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){
#ifdef TIMER_CRACKERS_JOIN
	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	lng crackedOperationsLeft = 0 , crackedOperationsRight = 0, joinsDone = 0;
#endif
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft, *prevNodeLeft, *newprevNodeLeft = NULL; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN curTupleLeft, baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;
	bit crackedLeft, existsHashTableLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight, *newprevNodeRight = NULL; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN curTupleRight, baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;
	bit crackedRight, existsHashTableRight;


	BAT *res;
	oid newPosition=0;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
#ifdef DEBUG_CRACKERS_JOIN
	printf("maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif
	

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapLeft));
	
	prevPosLeft   = prevPosRight   = 0;
	prevNodeLeft  = prevNodeRight  = NULL;

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n New Join Index Left \n");
	@:dumpIndex(Index Left)@
#endif
	while (curNodeLeft != NULL && curNodeRight != NULL){

#ifdef DEBUG_CRACKERS_JOIN
	printf(" new loop maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif

		crackedLeft = crackedRight = FALSE;
		existsHashTableLeft = existsHashTableRight = FALSE;


		curTupleLeft = baseLeft + curNodeLeft->position;
       		curValueLeft = *(@1 *)Tloc(indexLeft, curTupleLeft);
        	curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);


        	curTupleRight = baseRight + curNodeRight->position;
        	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n New Join Index Left \n");
	@:dumpIndex(Index Left)@
#endif
#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif
		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 

		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsRight++;
			TC1=GDKusec();	
#endif
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

#ifdef TIMER_CRACKERS_JOIN
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < prevPosRight || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosLeft   = curPosLeft+1;
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}
			if (newPosition < curPosRight){
				newprevNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){


#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsLeft++;
			TC1=GDKusec();	
#endif
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);

#ifdef TIMER_CRACKERS_JOIN
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < prevPosLeft || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosRight   = curPosRight+1;
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}
			if (newPosition < curPosLeft){
				newprevNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
		}

		@:JoinTwoPiecesReuseHashTables()@

		prevPosLeft   = curPosLeft+1;
		if (crackedLeft == FALSE){
			prevNodeLeft  = curNodeLeft;
			curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
		} else prevNodeLeft = newprevNodeLeft;

		prevPosRight   = curPosRight+1;
		if (crackedRight == FALSE){
			prevNodeRight  = curNodeRight;
        		curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
		} else prevNodeRight = newprevNodeRight;
	}

	while(1){

		crackedLeft = crackedRight = FALSE;
		existsHashTableLeft = existsHashTableRight = FALSE;

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
			curTupleLeft = baseLeft + curNodeLeft->position;
        	        curValueLeft = *(@1 *)Tloc(indexLeft, curTupleLeft);
	                curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
			curTupleRight = baseRight + curNodeRight->position;
   	             	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	        curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);	
		}
		
#ifdef DEBUG_CRACKERS_JOIN
		printf("\n Index Left \n");
		printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, baseLeft);
		printf("\n Index Right \n");
		printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight);
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif

		if (curNodeLeft != NULL && curNodeRight == NULL){	
#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsRight++;
			TC1=GDKusec();	
#endif
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

#ifdef TIMER_CRACKERS_JOIN

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < prevPosRight || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosLeft   = curPosLeft+1;
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}
			if (newPosition < curPosRight){
				newprevNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */
				@:JoinTwoPiecesReuseHashTables()@
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){
#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsLeft++;
			TC1=GDKusec();	
#endif
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
#ifdef TIMER_CRACKERS_JOIN
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < prevPosLeft || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosRight   = curPosRight+1;
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}
			if (newPosition < curPosLeft){
				newprevNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
			else {
				@:JoinTwoPiecesReuseHashTables()@
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight == NULL){
			@:JoinTwoPiecesReuseHashTables()@
			break;
		}			

		@:JoinTwoPiecesReuseHashTables()@

		prevPosLeft   = curPosLeft+1;
		if (crackedLeft == FALSE){
			prevNodeLeft  = curNodeLeft;
			curNodeLeft = curNodeLeft->nextValue;
		}else prevNodeLeft = newprevNodeLeft; 

		prevPosRight   = curPosRight+1;
		if (crackedRight == FALSE){
			prevNodeRight  = curNodeRight;
        		curNodeRight = curNodeRight->nextValue;
		} else prevNodeRight = newprevNodeRight;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

#ifdef TIMER_CRACKERS_JOIN
	T2=GDKusec();
	printf("Total  %lld Join %lld Rest  %lld Joins %lld Crack %lld Pieces %lld \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );
#endif

	return MAL_SUCCEED;

}	

str cacheConsciousAlignJoinStep(BAT *mapLeft, BAT *mapRight, struct Node *curNodeRight, oid startPos, oid endPos, BAT *indexRight, BUN baseRight, BAT * indexLeft, int mapLpos, oid cacheThreshold, struct Node *firstNodeRight, struct Node *lastNodeRight, BAT *res){
	oid newPosition=0;
	struct Node *temp, *prevNodeRight;
	BAT * viewHeadRight=NULL, *viewRight=NULL, *viewLeft=NULL, *markedViewRight=NULL;
	bit existsHashTableRight;

	oid prevPosRight, curPosRight, prevPosLeft, curPosLeft;

	@1 bound = *(@1*)Tloc(indexRight, baseRight + curNodeRight->position);

/*	
printf("\nalign Join\n");
printf("\n fL "OIDFMT" lL "OIDFMT" ",startPos, endPos);
if (firstNodeRight==NULL) printf(" fR  0 ");
else printf(" fR  "OIDFMT" ", firstNodeRight->indexPosition);
if (lastNodeRight==NULL) printf(" lR  End ");
else printf(" lR  "OIDFMT" ", lastNodeRight->indexPosition);
printf(" cur  "OIDFMT"  \n", curNodeRight->indexPosition);
*/

	if (curNodeRight->inclusive == TRUE)
	
		CRKcrackUnorderedZero_RE_@1(mapLeft, bound, startPos, endPos, &newPosition);
        else
		CRKcrackUnorderedZero_LE_@1(mapLeft, bound, startPos, endPos, &newPosition);
	
	if (newPosition != (startPos==0?0:startPos-1) && newPosition != endPos){

		addCrackerIndex_@1(mapLpos, &bound, curNodeRight->inclusive, newPosition, indexLeft);

		if (newPosition != (startPos==0?0:startPos-1)){
			 
			prevNodeRight = firstNodeRight; 
			prevPosRight = (prevNodeRight==NULL)?0:prevNodeRight->indexPosition+1;
			curPosRight  = curNodeRight->indexPosition;
			prevPosLeft  = startPos;
			curPosLeft   = newPosition;
			if (curPosRight - (prevPosRight+1) < cacheThreshold ||
				curPosLeft - (prevPosLeft+1) < cacheThreshold || 
				curNodeRight->left == NULL){

				@:AlignJoin()@
			}else{
				cacheConsciousAlignJoinStep(mapLeft, mapRight, curNodeRight->left, startPos, newPosition, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, prevNodeRight, curNodeRight, res);
			}
		}
		if (newPosition != endPos){

			prevNodeRight = curNodeRight; 
			prevPosRight = curNodeRight->indexPosition+1;
			curPosRight  = (lastNodeRight ==NULL)?BATcount(mapRight)-1: lastNodeRight->indexPosition;
			prevPosLeft  = newPosition+1;
			curPosLeft   = endPos;

			if (curPosRight - (prevPosRight+1) < cacheThreshold ||
				curPosLeft - (prevPosLeft+1) < cacheThreshold || 
				curNodeRight->right == NULL){

				@:AlignJoin()@
			}else{
				cacheConsciousAlignJoinStep(mapLeft, mapRight, curNodeRight->right, newPosition+1, endPos, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, curNodeRight, lastNodeRight, res);
			}
		}
	}
	return MAL_SUCCEED;
}

str CRKAlignJoin_@1(int *resid, int *bidL,  int *bidR1, int *bidR2){
	int mapLpos;
	BAT *indexLeft, *mapLeft;

	int tapeRpos, mapRpos;
	BAT *indexRight, *mapRight;
	BUN baseRight;

	oid cacheThreshold = 65536;

	BAT *res;

	/*TODO if left is an intermediate result, use this as a map and create an index */
	/* Get the cracker tape for the set of the left map or create one if it does not exist */

        /* Get the left map */
        mapLpos = newCrackerIndex_@1(*bidL, *bidL);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index left");


        /* Take the map */
        if ((mapLeft = BATdescriptor(*bidL)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map left");

	mapLeft->batRestricted= BAT_READ;

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map right");

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));

	cacheConsciousAlignJoinStep(mapLeft, mapRight, CrackerIndex[mapRpos].Tree, 0, BATcount(mapLeft)-1, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, NULL,NULL,res);

        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	/* Remove map created for the intermediate result */
	BBPdecref(CrackerIndex[mapLpos].cid,TRUE);
	CrackerIndex[mapLpos].cid=-1;
	CrackerIndex[mapLpos].cbid=-1;
	CrackerIndex[mapLpos].bid=-1;

	return MAL_SUCCEED;
}	

str SinglePassJoinPutTuple_@1(@1 *value, oid *id, struct Node *current, BUN baseLeft, BAT * indexLeft, BAT *firstPieceBAT, struct Node *prevNode){

	@1 *bound;  
	if (current == NULL){
		if (prevNode == NULL)
			BUNins(firstPieceBAT, id, value, FALSE);
		else		
			BUNins(prevNode->partition, id, value, FALSE);

		return MAL_SUCCEED;
	}

	bound = (@1*)Tloc(indexLeft, baseLeft + current->position);

	if (@2_GT(value,bound,@1) ||
		(@2_EQ(value,bound,@1) && current->inclusive==TRUE))

		SinglePassJoinPutTuple_@1(value, id, current->right, baseLeft, indexLeft, firstPieceBAT, current);
	else
		SinglePassJoinPutTuple_@1(value, id, current->left,  baseLeft, indexLeft, firstPieceBAT, prevNode);
		
	return MAL_SUCCEED;
}

str CRKOnePassJoin_@1(int *resid, int *bidL,  int *bidR1, int *bidR2){
	int mapLpos;
	BAT *indexLeft, *mapLeft;

	int tapeRpos, mapRpos;
	BAT *indexRight, *mapRight;
	BUN baseRight, baseLeft;

	BAT *res, *newBAT, *firstPieceBAT=NULL, *partitionLeft, *viewRight, *markedViewRight, *viewHeadRight;

	bit existsHashTableRight;

	struct Node *temp, *prevNodeRight, *newEntry, *curNodeRight, *prevNodeLeft;
	oid prevPosRight, nextPosRight, curPosRight;

	oid cacheThreshold = 65536;

	@1  *curLeftValue;
	oid *curLeftId;
	oid i;

	lng t1,t2;

	/*TODO if left is an intermediate result, use this as a map and create an index */
	/* Get the cracker tape for the set of the left map or create one if it does not exist */

        /* Get the left map */
        mapLpos = newCrackerIndex_@1(*bidL, *bidL);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index left");

        /* Take the map */
        if ((mapLeft = BATdescriptor(*bidL)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map left");

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map right");

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));

	/*First go through the right index and identify the pieces to be used for partitioning the left input */
	temp = getFirstNode(CrackerIndex[mapRpos].Tree); 
	prevPosRight=0;
	prevNodeRight = NULL;
	t1=GDKusec();
	while (temp!=NULL){
		nextPosRight = (temp->nextValue==NULL)?BATcount(mapRight)-1:temp->nextValue->indexPosition;
		if (nextPosRight - prevPosRight > cacheThreshold){
			newBAT = BATnew(TYPE_oid,TYPE_@1,temp->indexPosition-prevPosRight);
			BATsetcount(newBAT,0);
			if (prevPosRight == 0)
				firstPieceBAT = newBAT; 
			else{
				newEntry = addCrackerIndex_@1(mapLpos, (@1*)Tloc(indexRight, baseRight + prevNodeRight->position), prevNodeRight->inclusive, 0, indexLeft);
				newEntry->partition = newBAT;	
			}
			prevNodeRight = temp;
			prevPosRight=temp->indexPosition;
		}

		temp=temp->nextValue;
	}
	/*insert last piece*/
	newEntry = addCrackerIndex_@1(mapLpos, (@1*)Tloc(indexRight, baseRight + prevNodeRight->position), prevNodeRight->inclusive, 0, indexLeft);
	newEntry->partition = BATnew(TYPE_oid,TYPE_@1,BATcount(mapRight)-1-prevPosRight);
	t2=GDKusec();

	printf("\n preparing the index %lld \n", t2-t1);
/*
	printf("\n Left \n");
	printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, BUNfirst(indexLeft));
	printf("\n Right \n");
	printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight);

*/

	t1=GDKusec();
	/* now we go through the left input and put every tuple in the proper partition */
	curLeftValue = (@1 *)Tloc(mapLeft,BUNfirst(mapLeft));
	curLeftId    = (oid*)Hloc(mapLeft,BUNfirst(mapLeft));
        baseLeft     = BUNfirst(indexLeft);
	for(i=0;i<BATcount(mapLeft);i++){
		SinglePassJoinPutTuple_@1(curLeftValue, curLeftId, CrackerIndex[mapLpos].Tree,  baseLeft, indexLeft, firstPieceBAT, NULL);
		curLeftValue++;
		curLeftId++;
	}	

	t2=GDKusec();
	printf("\n filling in the partitions %lld \n", t2-t1);

/*
	i=0;
	temp  = getFirstNode(CrackerIndex[mapLpos].Tree); 
	if (BATcount(firstPieceBAT) > 0){
		printf("\nBAT "OIDFMT" size "OIDFMT "\n",i, BATcount(firstPieceBAT));
				
	}
	i=1;
	while(temp!=NULL){
		printf("\nBAT "OIDFMT" size  "OIDFMT" \n",i,BATcount(temp->partition));
		temp=temp->nextValue;
		i++;
	}

*/

	t1=GDKusec();
	/* The final step is to go through all pieces and perform the joins */
	prevNodeRight 	= NULL;
	prevNodeLeft 	= NULL;
	curNodeRight  	= getFirstNode(CrackerIndex[mapRpos].Tree); 
	temp  		= getFirstNode(CrackerIndex[mapLpos].Tree); 

	while(temp!=NULL){
		curLeftValue = (@1 *)Tloc(indexLeft, baseLeft + temp->position);
		while(@2_GT(curLeftValue,(@1*)Tloc(indexRight, baseRight + curNodeRight->position),@1)){
			if (curNodeRight->nextValue == NULL) break;
			curNodeRight = curNodeRight->nextValue;
		}

		partitionLeft = (prevNodeLeft == NULL)?firstPieceBAT:prevNodeLeft->partition;
		if (BATcount(partitionLeft) > 0){
			prevPosRight = (prevNodeRight == NULL)?0:prevNodeRight->indexPosition;
			curPosRight  = (curNodeRight==NULL)?BATcount(mapRight)-1:curNodeRight->indexPosition;			
			@:SinglePassJoin()@
		}else
			BBPunfix(partitionLeft->batCacheid);

		prevNodeRight = curNodeRight;
		curNodeRight = curNodeRight->nextValue;
		prevNodeLeft = temp;
		temp=temp->nextValue;
	}

	partitionLeft = (prevNodeLeft == NULL)?firstPieceBAT:prevNodeLeft->partition;
	if (BATcount(partitionLeft) > 0){
		prevPosRight = (prevNodeRight == NULL)?0:prevNodeRight->indexPosition;
		curPosRight  = BATcount(mapRight)-1;			
		@:SinglePassJoin()@
	}else
		BBPunfix(partitionLeft->batCacheid);

	t2=GDKusec();
	printf("\n doing the join  %lld \n", t2-t1);

        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	/* Remove map created for the intermediate result */
	BBPdecref(CrackerIndex[mapLpos].cid,TRUE);
	CrackerIndex[mapLpos].cid=-1;
	CrackerIndex[mapLpos].cbid=-1;
	CrackerIndex[mapLpos].bid=-1;

	return MAL_SUCCEED;
}	

str CRKAlreadyAlignedJoin_@1(int *resid, int *bidL1,  int *bidR1, int *bidR2){
	lng T1=GDKusec(), TJtotal = 0, TJ1, TJ2, T2;
	int  mapLpos;
	struct Node *curNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight=NULL, *viewHeadRight;
	BUN baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;

	bit existsHashTableRight=FALSE;
	BAT *res;
	lng joinsDone = 0;

	struct Node *temp;

        /* Get the left map */
        mapLpos = existsCrackerIndex(*bidL1);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.Join", "Cannot access crack index left");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.Join", "Cannot access crack map left");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.Join", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.Join", "Cannot access crack map right");
	
#ifdef DEBUG_CRACKERS_JOIN
	printf("maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));
	
	prevPosLeft   = prevPosRight   = -1;
	prevNodeRight  = NULL;

	@:dumpIndex(New Join Index Left)@
	/* the left has no index and it all falls into the first piece of the right */
	if (curNodeLeft == NULL){
        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;

		curValueLeft =  *(@1*)Hloc(mapLeft,BUNfirst(mapLeft));
		if (curValueRight > curValueLeft ||
                	((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE))){
			curPosLeft   = BATcount(mapLeft)-1;
			@:JoinTwoPiecesReuseHashTablesRight()@
			joinsDone++;
			goto done;
		}
	}

	while (curNodeLeft != NULL && curNodeRight != NULL){

		existsHashTableRight = FALSE;

       		curValueLeft = *(@1 *)Tloc(indexLeft,baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition;

        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		
#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft %lld curPosLeft %lld \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight %lld curPosRight %lld \n", prevPosRight,curPosRight);
#endif

		while (curValueRight < curValueLeft){
			if (curNodeRight->nextValue == NULL){
				curPosRight  = BATcount(mapRight)-1;
				goto last;
			}
        		curNodeRight = curNodeRight->nextValue;

        		curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        		curPosRight   = curNodeRight->indexPosition;
		}

		@:JoinTwoPiecesReuseHashTablesRight()@
		joinsDone++;

		prevPosLeft   = curPosLeft;
		curNodeLeft = curNodeLeft->nextValue;

		prevPosRight   = curPosRight;
		prevNodeRight  = curNodeRight;
        	curNodeRight = curNodeRight->nextValue;
	}

	/* handle last pieces or the case where the left has no index and it all falls to the last piece of the right */
	curPosLeft   = BATcount(mapLeft)-1;
	curPosRight  = BATcount(mapRight)-1;

	last:;
	@:JoinTwoPiecesReuseHashTablesRight()@
	joinsDone++;

	done:;
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	/* Remove map created for the intermediate result */
	BBPdecref(CrackerIndex[mapLpos].cid,TRUE);
	BBPdecref(CrackerIndex[mapLpos].cbid,TRUE);
	CrackerIndex[mapLpos].cid=-1;
	CrackerIndex[mapLpos].cbid=-1;
	CrackerIndex[mapLpos].bid=-1;

	T2=GDKusec();
	printf("Total  %lld Join %lld Rest  %lld Joins %lld \n", 
			T2-T1, TJtotal, (T2-T1)-TJtotal,joinsDone);

	return MAL_SUCCEED;
}	

str CRKbandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh){
	BAT *BATLeft, *b, *c, *res;
	int m;
	@1 currentValue;
	BUN currentTupleLeft; 
	oid *currentResTupleHead, *currentResTupleTail, *curViewTupleHead, *currentTupleLeftHead;
	oid numberOfTuplesLeft;
	bit HBound;	
	@1 low, hgh;
	oid vl=0, vh=0, posl, posh, _vl;
	oid cl1=0, ch1=0, cl2=0, ch2=0;
	int foundLow, foundHgh;
	oid resCount=0;
	int gapL=0,gapH=0;
	oid i,j;
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	if ((BATLeft = BATdescriptor(*bidL)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	if ((b = BATdescriptor(*bidR)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	m = newCrackerIndex_@1(*bidR,b->batCacheid);

        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access cracker index");

	res = BATnew(TYPE_oid,TYPE_oid,5*(*c1+*c2)*BATcount(b));
	currentResTupleHead = (oid*)Hloc(res,BUNfirst(res));
	currentResTupleTail = (oid*)Tloc(res,BUNfirst(res));

	numberOfTuplesLeft = BATcount(BATLeft);
	currentTupleLeft   = BUNfirst(BATLeft);

	currentValue = *(@1*)Tloc(BATLeft, currentTupleLeft);
	currentTupleLeftHead = (oid*)Hloc(BATLeft, currentTupleLeft);
	low  = currentValue - *c1;			
	hgh  = currentValue + *c2;			

	posl = BUNfirst(b);
	posh = BUNlast(b)-1;

	@:crackDoubleSidedBound(@1,posl,posh)@
	@:addPartialResult()@
	currentTupleLeft ++;

	for(i=1;i<numberOfTuplesLeft;i++){
		currentValue = *(@1*)Tloc(BATLeft, currentTupleLeft);
		currentTupleLeftHead = (oid*)Hloc(BATLeft, currentTupleLeft);
		low  = currentValue - *c1;			
		hgh  = currentValue + *c2;			


		foundLow = GetLow_@1(low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), 
					&cl1, &ch1, 0, BUNlast(b)-1);

		foundHgh = GetHgh_@1(hgh, *inclusiveHgh, CrackerIndex[m].Tree, c,  BUNfirst(c), 
					&cl2, &ch2, 0, BUNlast(b)-1);

		if (cl1 != 0) cl1++;
		if (cl2 != 0) cl2++;

		if (foundLow == 0 || foundHgh == 0){
			if (foundLow == 0 && foundHgh == 0){
				if (cl1 == cl2){
					@:crackDoubleSidedBound(@1,cl1,ch2)@
				} else {
					@:crackSingleSidedBoundLeft(@1)@
					@:crackSingleSidedBoundRight(@1)@
					if (vl>0) _vl=vl-1; else _vl=vl;		
					if (gapL>0) addCrackerIndex_@1(m,&low,*inclusiveLow,_vl,c);
					if (gapH>0) addCrackerIndex_@1(m,&hgh,HBound,vh,c);
				}
			} else
			if (foundLow == 0){
				@:crackSingleSidedBoundLeft(@1)@
				if (vl>0) _vl=vl-1; else _vl=vl;		
				if (gapL>0) addCrackerIndex_@1(m,&low,*inclusiveLow,_vl,c);
				vh = ch2;
			} else
			if (foundHgh == 0){
				@:crackSingleSidedBoundRight(@1)@
				if (gapH>0) addCrackerIndex_@1(m,&hgh,HBound,vh,c);
				vl = cl1;
			}	 	
		} else {
			vl = cl1;
			vh = ch2;
		}

		@:addPartialResult()@
		currentTupleLeft ++;
	}

	BATsetcount(res,resCount);
        *resid = res->batCacheid;
        BBPkeepref(*resid);
        BBPunfix(b->batCacheid);
        BBPunfix(c->batCacheid);
        BBPunfix(BATLeft->batCacheid);
	return MAL_SUCCEED;
}
	
str CRKsortBandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh){
	BAT *BATLeft, *BATRight, *res;
	@1 currentValue;
	BUN currentTupleLeft, currentTupleRight; 
	oid *currentResTupleHead, *currentResTupleTail, *currentTupleLeftHead;
	oid numberOfTuplesLeft;
	@1 low, hgh;
	oid resCount=0;
	oid i;

	if ((BATLeft = BATdescriptor(*bidL)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	if ((BATRight = BATdescriptor(*bidR)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	res = BATnew(TYPE_oid,TYPE_oid,5*(*c1+*c2)*BATcount(BATRight));
	currentResTupleHead = (oid*)Hloc(res,BUNfirst(res));
	currentResTupleTail = (oid*)Tloc(res,BUNfirst(res));

	numberOfTuplesLeft = BATcount(BATLeft);
	currentTupleLeft   = BUNfirst(BATLeft);

	/* sort in place the right bat */
        if (BATRight->tsorted == FALSE){
                BATRight->batRestricted = BAT_WRITE;
                BATmirror(BATorder(BATmirror(BATRight)));
        }

	for(i=0;i<numberOfTuplesLeft;i++){
		currentValue = *(@1*)Tloc(BATLeft, currentTupleLeft);
		currentTupleLeftHead = (oid*)Hloc(BATLeft, currentTupleLeft);
		low  = currentValue - *c1;			
		hgh  = currentValue + *c2;			
		
		currentTupleRight = SORTfndfirst_@1(BATRight,&low);
		if (currentTupleRight == BUNlast(BATRight))
			goto next;
	
		if ((*(@1*)Tloc(BATRight, currentTupleRight) == low)&&(*inclusiveLow == TRUE)){
			@:sortInsertPartialResult()@
			while (*(@1*)Tloc(BATRight, currentTupleRight) == low){
				@:sortInsertPartialResult()@
			}
		}

		while (*(@1*)Tloc(BATRight, currentTupleRight) < hgh){
			@:sortInsertPartialResult()@
                }
	
		if (*inclusiveHgh == TRUE){
			while (*(@1*)Tloc(BATRight, currentTupleRight) == hgh){
				@:sortInsertPartialResult()@
                	}
		}

		next:;
		currentTupleLeft ++;
	}

	BATsetcount(res,resCount);
        *resid = res->batCacheid;
        BBPkeepref(*resid);
        BBPunfix(BATRight->batCacheid);
        BBPunfix(BATLeft->batCacheid);
	return MAL_SUCCEED;
}

void cacheConsciousAlignStep(BAT *mapLeft, struct Node *curNodeRight, oid startPos, oid endPos, BAT *indexRight, BUN baseRight, BAT * indexLeft, int mapLpos, oid cacheThreshold, oid RightStartPos, oid RightEndPos){
	oid newPosition=0;
	@1 bound = *(@1*)Tloc(indexRight, baseRight + curNodeRight->position);
	
	if (curNodeRight->inclusive == TRUE)
		CRKcrackUnorderedZero_RE_@1(mapLeft, bound, startPos, endPos, &newPosition);
        else
		CRKcrackUnorderedZero_LE_@1(mapLeft, bound, startPos, endPos, &newPosition);

	if (newPosition != (startPos==0?0:startPos-1) && newPosition != endPos){
		addCrackerIndex_@1(mapLpos, &bound, curNodeRight->inclusive, newPosition, indexLeft);
		if (newPosition != (startPos==0?0:startPos-1) && curNodeRight->left != NULL 
				&&  curNodeRight->indexPosition - RightStartPos >cacheThreshold)
			cacheConsciousAlignStep(mapLeft, curNodeRight->left, startPos, newPosition, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, RightStartPos, curNodeRight->indexPosition);

		if (newPosition != endPos && curNodeRight->right != NULL
				&&  RightEndPos - curNodeRight->indexPosition-1 >cacheThreshold)
			cacheConsciousAlignStep(mapLeft, curNodeRight->right, newPosition+1, endPos, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, curNodeRight->indexPosition+1, RightEndPos);
	}
}

void alignStep(BAT *mapLeft, struct Node *curNodeRight, oid startPos, oid endPos, BAT *indexRight, BUN baseRight, BAT * indexLeft, int mapLpos){
	oid newPosition=0;
	@1 bound = *(@1*)Tloc(indexRight, baseRight + curNodeRight->position);
	
	if (curNodeRight->inclusive == TRUE)
		CRKcrackUnorderedZero_RE_@1(mapLeft, bound, startPos, endPos, &newPosition);
        else
		CRKcrackUnorderedZero_LE_@1(mapLeft, bound, startPos, endPos, &newPosition);

	if (newPosition != (startPos==0?0:startPos-1) && newPosition != endPos){
		addCrackerIndex_@1(mapLpos, &bound, curNodeRight->inclusive, newPosition, indexLeft);
		if (newPosition != (startPos==0?0:startPos-1) && curNodeRight->left != NULL)
			alignStep(mapLeft, curNodeRight->left, startPos, newPosition, indexRight, baseRight, indexLeft, mapLpos);
		if (newPosition != endPos && curNodeRight->right != NULL)
			alignStep(mapLeft, curNodeRight->right, newPosition+1, endPos, indexRight, baseRight, indexLeft, mapLpos);
	}
}

str CRKFullAlignment_@1(int *res, int *bidL, int *bidR1, int *bidR2){
	int mapLpos;
	BAT *indexLeft, *mapLeft;

	int tapeRpos, mapRpos;
	BAT *indexRight, *mapRight;
	BUN baseRight;

	oid cacheThreshold = 65536;
	
	(void)res;

	/*TODO if left is an intermediate result, use this as a map and create an index */
	/* Get the cracker tape for the set of the left map or create one if it does not exist */

        /* Get the left map */
        mapLpos = newCrackerIndex_@1(*bidL, *bidL);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index left");


        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map left");

	mapLeft->batRestricted= BAT_READ;

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map right");

        baseRight      = BUNfirst(indexRight);

#ifdef DEBUG_CRACKERS_JOIN
	if (CrackerIndex[mapRpos].Tree == NULL) 
		printf("\n head is null \n");
#endif

	cacheConsciousAlignStep(mapLeft, CrackerIndex[mapRpos].Tree, 0, BATcount(mapLeft)-1, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, 0, BATcount(mapRight)-1);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, BUNfirst(indexLeft));
	printf("\n Right \n");
	printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight);
#endif

	BBPunfix(indexLeft->batCacheid);
	BBPkeepref(mapLeft->batCacheid);
	BBPunfix(indexRight->batCacheid);
	BBPunfix(mapRight->batCacheid);
        return MAL_SUCCEED;

}
@


@}



