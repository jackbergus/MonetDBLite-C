@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f crackers
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Cracker index

Database cracking aims at enhancing query processing by adapting the way 
data is stored to the query workload. Adaptation happens through physical 
reorganization of data. Each query reorganized the data in such a way that 
future queries can be answered faster.

For each BAT b, the system creates on demand a cracker column c, i.e., 
the first time a select operator is fired on b. From there on all queries that 
perform a select operator on b will physically reorganize (i.e., crack) the cracker column c 
such that the result set is in a consecutive area in c. 
The result of the select operator is a non materialized view on c.

For each cracker column c, there exists a cracker index, that maintains knowledge 
on the various pieces created while cracking c. The cracker index is an AVLt-tree
data structure. Each select operator uses the appropriate cracker index to determine 
which pieces it should crack, and updates the index afterwards.

The more queries are fired on a bat b the more the cracker column c of b is cracked.
This way the cracker index on c, is continuously enriched with information that helps speed up 
future queries. This way query processing improves as more queries are answered by adapting to 
the query and data workload.

Initial performance shows an exptected gain of at least on order of magnitude, 
due to analysing less data during the select operator and also due to non materializing 
the select operator result set.

The cracker index can be created for the time being on
tail columns of type {int,lng,dbl,flt,time,date,sht}. The head
is always of type @sc{oid}.

In addition, the cracker index can be used to feed a generator
for pieces satisfying a range constraint.
A cracker partition is indicated by the index in the cidx
table. It can be used to initialize a BATview to represent
the partition during processing.

Updates support for cracker columns happens again in a self-organizing way.
Incoming updates (inserts,deletes or updates) are kept in separate columns for 
each BAT as pending updates. While processing queries, if the crackers select 
operator detects that some of the pending updates should be taken into account,
then updates are "merged" into the cracker column on the fly by also updating the 
cracker index accordingly.

Since the cracker columns are physically reorganized the result of a select operator is not 
ordered in the same way as the rest of the bats of the same relation. This has side-effects 
during projection operations. We cannot use ordered fetch joins anymore. 
This decrades performance significantly
when multiple projections exist in a query plan.

This problem is solved by the second generation cracing, i.e., 
sideways cracking that uses cracker maps instead of cracker columns.
A cracker map contains the values of two attributes of the same relation. 
These are attributes used together in query plans. The main idea is that 
cracking based on one of these attributes (the head of the map) is forwarded on the tail. 
This way projections can be performed by performing simple cracking operations on maps.
Multiple maps can exist for each attribute A as head consisting the map set of A. All maps in the same 
map set S are aligned before used in a query plan. Aligment happens by keeping a history of all cracking 
operations in maps of S and ensuring that the same cracks have been applied to all necessary maps 
and in the same order. Sideways cracking maintains the advantage of cracking even 
in the presence of multiple projection operations.

Ongoing work.
Multitable cracking.

The cracker module should be prepared to deal with any of the base types.
For strings this becomes an issue.

The current implementation uses an unprotected cracker
index. This limits the interface at slightly more overhead
of searching the cracker index upon each call.

Currently crakcer structures are in memory. They need to be stored in disk and become persistent.

Repeated cracking leads to an ever growing index. This process
can be stopped by setting the granule size,
i.e.  the minimum number of tuples in each piece,
or the maximum number of pieces.

The implementation is geared at early experimentation
without all the details to make the code robust and
ultra fast.


@+ Interface


@- Type expansion

@= TypeSwitch_temp2
@:@1(@2,int)@
@:@1(@2,date)@
@

@= TypeSwitch_1
@:@1(@2,chr)@
@:@1(@2,sht)@
@:@1(@2,int)@
@:@1(@2,lng)@
@:@1(@2,flt)@
@:@1(@2,dbl)@
@:@1(@2,date)@
@

@= TypeSwitch_2
@:TypeSwitch_temp2(@1,int)@
@:TypeSwitch_temp2(@1,date)@
@:@1(date,lng)@
@:@1(date,dbl)@
@:@1(date,str)@
@:@1(int,str)@
@:@1(dbl,str)@
@:@1(dbl,int)@
@:@1(dbl,dbl)@
@

@= TypeSwitch_temp
@:@1(@2,int)@
@

@- MAL file

@mal
module crackers;

@:TypeSwitch_1(Select)@
@:TypeSwitch_1(JoinSelect)@
@:TypeSwitch_1(Updates)@
@:TypeSwitch_1(Index)@
@:TypeSwitch_1(CoreUnordered)@
@:TypeSwitch_1(CoreOrdered)@
@:TypeSwitch_1(Validate)@
@:TypeSwitch_1(AVLindex)@
@:TypeSwitch_temp(Joins)@
@:TypeSwitch_2(Sideways)@

command mapCount(b:bat[:oid,:oid]) :lng
address CRKbatCount
comment "Retrieve the size of the map";

command getTotalStorage( ):void
address CRKgetTotalStorage
comment "Get the number of total tuples stored in sideways maps";

command setStorageThreshold(threshold:lng):void
address CRKsetStorageThreshold
comment "set the maximum number of total tuples that can be stored in sideways maps";

command fmclearReferences():void
address CRKclearReferencesFullMaps
comment "clear all references ";

command fmremoveMap():void
address CRKremoveFullMap
comment "clear all debugging map ";

@

@= Select
command select(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:oid]
address CRKuselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2):bat[:any_1,:oid]
address CRKuselectValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_1,:oid]
address CRKuselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";
 
command select2(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBounds2_@2
comment "Similar to select but always make sure that we do not create a large piece 
	 i.e., bigger than half the size of the cracked piece";

@

@= JoinSelect
command joinuselect( right:bat[:oid,:@2], l:@2, h:@2, li:bit, hi:bit, left:bat[:oid,:oid] ):bat[:oid,:oid]
address CRKjoinSelectDefault_@2
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	The result is a new [:oid,:void] BAT.";

command joinuselect( right:bat[:oid,:@2], l:@2, h:@2, li:bit, hi:bit, left:bat[:oid,:oid], inPlace:bit , isForeignKey:bit):bat[:oid,:oid]
address CRKjoinSelectBounds_@2
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	If inPlace is TRUE (and left has an OID head and is not a BAT-view), we operate in-place,
	overwriting left and returning it as result. Otherwise, the result is a new [:oid,:void] BAT.
	If isForeignKey is TRUE, we assume that each tuple from left finds a match in right,
	and hence skip the respective check.
	(NOTE: This may lead to CRASHES, if isForeignKey is incorrectly passed as TRUE!)";

command joinselect( b:bat[:oid,:@2],l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";


@

@= Updates
command insertionsPartiallyForget(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertions_PartiallyForget_@2
comment "Append c to the cracked BAT of b and partially forget 
         the cracker index, i.e., forget only what is affected";

command insertionsBForce(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_Force_@2
comment "Merge the insertions BAT with the cracker bat and update the cracker index";


command printCrackerInsertions(b:bat[:any_1,:@2]):void
address CRKprintCrackerInsertions
comment "Print the pending insertions of the cracker BAT of b";

command printCrackerDeletions(b:bat[:any_1,:@2]):void
address CRKprintCrackerDeletions
comment "Print the pending deletions of the cracker BAT of b";

command sizeCrackerInsertions(b:bat[:any_1,:@2]):void
address CRKsizeCrackerInsertions
comment "Get the size of the pending insertions of the cracker BAT of b";

command sizeCrackerDeletions(b:bat[:any_1,:@2]):void
address CRKsizeCrackerDeletions
comment "Get the size of the pending deletions of the cracker BAT of b";

command insertionsForget(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertions_Forget
comment "Append c to the cracked BAT of b and completelly forget the cracker index";

command insertionsBOnNeed(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_OnNeed
comment "Keep the insertions BAT separatelly and do a complete merge 
         only if a relevant query arrives in the future";

command insertionsBOnNeedGradually(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_OnNeedGradually
comment "Keep the insertions BAT separatelly and merge only what is 
         needed if a relevant query arrives in the future";

command insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_OnNeedGraduallyRipple
comment "Keep the insertions BAT separatelly and merge only what is needed 
         using the ripple strategy if a relevant query arrives in the future";

command deletionsOnNeed(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeDeletions_OnNeed
comment "Keep the deletions BAT separatelly and do a complete merge only 
         if a relevant query arrives in the future";

command deletionsOnNeedGradually(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeDeletions_OnNeedGradually
comment "Keep the deletions BAT separatelly and merge only what is 
         needed if a relevant query arrives in the future";

command deletionsOnNeedGraduallyRipple(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeDeletions_OnNeedGraduallyRipple
comment "Keep the deletions BAT separatelly and merge only what is 
         needed using ripple if a relevant query arrives in the future";

command extendCrackerBAT(b:bat[:any_1,:@2], P:lng):void
address CRKextendCrackerBAT
comment "Extend the cracker column by P positions";
@

@= Index
command printCrackerIndexBATpart(b:bat[:any_1,:@2]):void
address CRKprintCrackerIndexBATpart
comment "Print the cracker index of b";

command printCrackerBAT(b:bat[:any_1,:@2]):void
address CRKprintCrackerBAT
comment "Print the cracker BAT of b";

command getCrackerBAT(b:bat[:oid,:@2]):bat[:oid,:@2]
address CRKgetCrackerBAT
comment "Get the cracker BAT of b";

command printAVLTree_int(b:bat[:any_1,:@2]):void
address CRKprintAVLTree_int
comment "Print the AVL Tree of the cracker index (for debugging purposes)";
@

@= CoreOrdered
command zcrackOrdered (b:bat[:oid,:@2], mid:@2) :bat[:oid,:@2]
address CRKcrackOrderedZero_@2
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered (b:bat[:oid,:@2], mid:@2) :bat[:oid,:@2]
address CRKcrackOrderedOne_@2
comment "Break a BAT into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered (b:bat[:oid,:@2], low:@2, hgh:@2) :bat[:oid,:@2]
address CRKcrackOrderedThree_@2
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";
@

@= CoreUnordered
command zcrackUnordered (b:bat[:oid,:@2], mid:@2) :bat[:oid,:@2]
address CRKcrackUnorderedZero_@2
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered (b:bat[:oid,:@2], low:@2, hgh:@2) :bat[:oid,:@2]
address CRKcrackUnorderedThree_@2
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@

@= Validate
@:crack_validate(@2,Ordered,; maintaining the head-oid order within each piece)@
@:crack_validate(@2,Unordered,)@

command verifyCrackerIndex(b:bat[:any_1,:@2]):void
address CRKverifyCrackerIndex_@2
comment "Check the cracker index and column, whether each value is in the correct chunk";
@

@= crack_validate
command zcrack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2Zero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2One_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Two_validate_@1
comment "Validate whether a BAT is correctly broken into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively@3.";

command zcrack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Three_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively@3.";
@

@= Sideways
command getMap( b:bat[:oid,:@1], bp:bat[:oid,:@2] ):bat[:@1,:@2]
address getCrackerMap
comment "Get a certain map";

command DeleteMap( b:bat[:oid,:@1], bp:bat[:oid,:@2] ):void
address DeleteCrackerMap
comment "Throw away a certain map"; 

command insert( b:bat[:oid,:@1], bp:bat[:oid,:@2], c:bat[:@1,:@2]):void
address CRKinsert
comment "Keep the insertions BAT separatelly and merge in the future on demand with the Ripple";

command printPendingInsertions( b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKprintPendingInsertions
comment "Print the pending insertions";

command extendCrackerMap(b:bat[:oid,:@1], bp:bat[:oid,:@2], P:lng):void
address CRKextendCrackerMap
comment "Extend the cracker map by P positions";

command sizePendingInsertions(b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKsizePendingInsertions
comment "Get the size of the pending insertions for this map";



command hselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKhselectBoundsSideways_@1_@2
comment "Retrieve the subset head using a cracker
        index producing preferably a BATview.";

command tselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKtselectBoundsSideways_@1_@2
comment "Retrieve the subset tail using a cracker
        index producing preferably a BATview.";

command dselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit,l2:@2,h2:@2,li2:bit,hi2:bit):bat[:oid,:bit]
address CRKdselectBoundsSideways_@1_@2
comment "Crack based on @1 and evaluate the @2 disjunctive predicate outside the cracked area. Return a bit vector.";


command joinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command djoinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKdjoinSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 0, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If yes mark the pivot BUN as 1.";


command project( b:bat[:oid,:@1],bp:bat[:oid,:@2], l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectCrack_@1_@2
comment "Sync and project the tail of the cpair";

command project( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProject_@1_@2
comment "Sync the cracking pair and project the tail";

command positionproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],PositionPivot:bat[:oid,:oid],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKPositionProject_@1_@2
comment "Sync the cracking pair and project the tail. The pivot holds the positions to be projected";

command markedproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKMarkedProject_@1_@2
comment "Sync the cracking pair and project the tail. The result bat has a marked head";

command dproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit]):bat[:oid,:@2]
address CRKdProject_@1_@2
comment "Sync the cracking pair and project the tail. Use for disjunctive queries that require a larger bit vector";

command projectH( b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKProjectH_@1_@2
comment "Sync the cracking pair and project the head";

command pmselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit,l2:@2,h2:@2,li2:bit,hi2:bit):bat[:oid,:bit]
address CRKselectBoundsIncrementalSideways_@1_@2
comment "Crack based on @1 and evaluate the @2 conjunctive predicate. Return a bit vector.";

command pmtselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBoundsTailIncrementalSideways_@1_@2
comment "Crack based on @1 and project the @2 tail .";

command pmjoinselect(b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectIncrementalSideways_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair(collection of pieces) satisfies the range restriction. If not mark the pivot BUN as 0.";

command pmproject(b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectIncrementalSideways_@1_@2
comment "Sync the map and project the tail based on the pivot";

command pmmaxTail(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKMaxTailIncrementalSideways_@1_@2
comment "Sync/crack the map and get the max of the tail";

command pmaddReference(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKaddReference
comment "add bp reference to map set of b";

command pmclearReferences(b:bat[:oid,:@1]):void
address CRKclearReferences
comment "clear all references to b";

command fmaddReference(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKaddReferenceFullMaps
comment "add bp reference to map set of b";

command fmcreateMap(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKcreateFullMap_@1_@2
comment "make new map for debugging";
@

@= AVLindex
command buildAVLIndex(b:bat[:any_1,:@2]):void
address CRKmakeAVLIndex_@2
comment "Create an AVL tree index for this BAT";

command InsertAVLIndex(b:bat[:any_1,:@2], u:bat[:any_1,:@2]):void
address CRKInsertAVLIndex_@2
comment "Insert u in the AVL tree index of BAT b";

command selectAVL(b:bat[:any_1,:@2],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_6,:@2]
address CRKAVLIndexSelectBounds_@2
comment "Retrieve the subset using the AVL index";

command deleteAVL(b:bat[:any_1,:@2],u:bat[:any_2,:@2]):void
address CRKdeleteFromAVL_@2
comment "Delete a collection of values from the index";
@

@= Joins
command simpleJoin(b1:bat[:oid,:@2],b2:bat[:oid,:@2],b3:bat[:oid,:@2],b4:bat[:oid,:@2]):bat[:oid,:oid]
address CRKsimpleJoin_@2
comment "Join two maps based on head values by exploiting the already existing partitioning information";

command crackJoin(b1:bat[:oid,:@2],b2:bat[:oid,:@2],b3:bat[:oid,:@2],b4:bat[:oid,:@2]):bat[:oid,:oid]
address CRKcrackJoin_@2
comment "Join two maps based on head values. Align the maps to avoid overlapping pieces";

command cacheConsciousCrackHashJoin(b1:bat[:oid,:@2],b2:bat[:oid,:@2],b3:bat[:oid,:@2],b4:bat[:oid,:@2],pieceSize:lng,joinThreshold:lng):bat[:oid,:oid]
address CRKcacheConsciousCrackHashJoin_@2
comment "Join two maps based on head values. Align the maps to avoid overlapping pieces. Reuse hash tables";

command cacheConsciousCrackHashJoinAlignOnly(b1:bat[:oid,:@2],b2:bat[:oid,:@2],b3:bat[:oid,:@2],b4:bat[:oid,:@2],pieceSize:lng,joinThreshold:lng):bat[:oid,:oid]
address CRKcacheConsciousCrackHashJoinAlignOnly_@2
comment "Join two maps based on head values. Align the maps to avoid overlapping pieces. Reuse hash tables";

command crackHashJoin(b1:bat[:oid,:@2],b2:bat[:oid,:@2],b3:bat[:oid,:@2],b4:bat[:oid,:@2]):bat[:oid,:oid]
address CRKcrackHashJoin_@2
comment "Join two maps based on head values. Align the maps to avoid overlapping pieces. Reuse hash tables";

command fullAlignment(b1:bat[:oid,:@2],b2:bat[:oid,:@2],b3:bat[:oid,:@2]):void
address CRKFullAlignment_@2
comment "Align a bat with the cracks on a map";

command singlePassJoin(b1:bat[:oid,:@2],b2:bat[:oid,:@2],b3:bat[:oid,:@2]):bat[:oid,:oid]
address CRKOnePassJoin_@2
comment "First partition on separate pieces the left input based on the right index. Then join matching pieces";

command alignJoin(b1:bat[:oid,:@2],b2:bat[:oid,:@2],b3:bat[:oid,:@2]):bat[:oid,:oid]
address CRKAlignJoin_@2
comment "Join and on the fly align a map with an intermediate result bat, i.e., not cracked";

command alignedJoin(b1:bat[:oid,:@2],b2:bat[:oid,:@2],b3:bat[:oid,:@2]):bat[:oid,:oid]
address CRKAlreadyAlignedJoin_@2
comment "Join an aligned cracker bat with a map";

command bandJoin(b1:bat[:oid,:@2],b2:bat[:oid,:@2],c1:@2,c2:@2,inclusiveLow:bit,inclusiveHgh:bit):bat[:oid,:oid]
address CRKbandJoin_@2
comment "Band Join two maps based on head values. 
	Continuously crack the right BAT for each tuple of the left one";

command sortBandJoin(b1:bat[:oid,:@2],b2:bat[:oid,:@2],c1:@2,c2:@2,inclusiveLow:bit,inclusiveHgh:bit):bat[:oid,:oid]
address CRKsortBandJoin_@2
comment "Band Join two maps based on head values. 
	First sort the right BAT and then continuously binary search the right BAT for each tuple of the left one";

command materializeHead(b:bat[:oid,:@2]) :void
address CRKmaterializeH
comment "Materialize the head of BAT b";

@

@- Header file

@h
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/
/*#define DEBUG_CRACKERS_INSERTIONS*/

#ifdef WIN32
#ifndef LIBCRACKERS
#define crackers_export extern __declspec(dllimport)
#else
#define crackers_export extern __declspec(dllexport)
#endif
#else
#define crackers_export extern
#endif

#include "mtime.h"
#include "crackers_index.h"
#include "crackers_select_ops.h"
#include "crackers_joinselect_ops.h"
#include "crackers_sideways.h"
#include "crackers_updates.h"
#include "crackers_validation.h"
#include "crackers_core_unordered.h"
#include "crackers_core_ordered.h"
#include "crackers_AVL_tree.h"
#include "crackers_AVL_index.h"
#include "crackers_joins.h"

#ifdef LIBCRACKERS 
extern int maxCrackMap;
extern CrackerIndexNode *CrackerIndex;
extern int IndexEntries;
extern int IndexSize;
extern int IndexStop;
extern struct storageManagement *StorageInfo;
#endif

#endif /* _CRACKERS_H */


@{
@+ Implementation

@- C file
   
@c
#include "mal_config.h"
#include "crackers.h"

int maxCrackMap = 0;

CrackerIndexNode *CrackerIndex;

struct storageManagement *StorageInfo = NULL;

int IndexEntries = 4000000; /* Initial size used for the bat that stores index values */

/* Temp variables used to test the effect of stop updating the index, they operate only on one cracker bat */
int IndexSize = 0;
int IndexStop = 10000000;
@

@}
