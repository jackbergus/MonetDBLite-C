@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f crackers_sortmerge
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Select Operators for Incrmental sort merge


@+ Interface


@- Type expansion

@= TypeSwitch
@:@1(chr,simple,,chr)@
@:@1(sht,simple,,sht)@
@:@1(int,simple,,int)@
@:@1(lng,simple,,lng)@
@:@1(flt,simple,,flt)@
@:@1(dbl,simple,,dbl)@
@:@1(date,atom,TYPE_,loc)@
@


@- Header file

@h
#ifndef _CRACKERS_SORTMERGE_H_
#define _CRACKERS_SORTMERGE_H_

/* Exported signatures */
@:TypeSwitch(SelectFunctions_decl)@

#endif /* _CRACKERS_SORTMERGE_H */
@


@- Exported signatures

@= SelectFunctions_decl
crackers_export str CRKselectSortMerge_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
@


@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:TypeSwitch(SortMergeOperations)@

/* Exported functions */
@:TypeSwitch(SelectFunctions_impl)@
@


@- Exported functions

@= SelectFunctions_impl
str
CRKselectSortMerge_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){		
	if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
		throw(MAL,"selectsm","only double bounded selectsare currently supported");
	else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		throw(MAL,"selectsm","only double bounded selectsare currently supported");
	else
		return SelectSortMergeBounds_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh);
}
@


@- Local support functions and macros


@= CreateResult
createView:
	view = BATslice(b, vl, vh+1);

	if (!tail)
		view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
	
	*vid = view->batCacheid;
	BBPkeepref(*vid);

	BBPunfix(b->batCacheid);
	BBPunfix(c->batCacheid);
@

@= RangeSelectBody
	BAT *b,*c,*bo,*br;
	int  m;
	oid sliceSize;
	struct sortMergeNode *current;
	
	(void) vid;
	(void) inclusiveHgh;
	(void) inclusiveLow;
	
	if (@2_GT(low,hgh,@3@1))
		throw(MAL, "crackers.sortmerge", "illegal range");
	
	m = existsCrackerIndex(*bid);

	/* if this is the first time we select something from this bat,
	   we have to create the crack column, slice it and sort the slices. 
           We also create the result column where the result values are merged */
	if (m == -1){
		oid endSlice,startSlice;
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.sortmerge", "Cannot access descriptor");
		b = bo;/*BATcopy(bo, bo->htype, bo->ttype, TRUE);*/
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b);
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		BATkey(BATmirror(b),FALSE);
		BATmode(b,PERSISTENT);
		b->batRestricted= BAT_WRITE;

		br=BATnew(bo->htype, bo->ttype,BATcount(bo));

		m = newCrackerIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.sortmerge", "Cannot access crack index");

		/*slicing*/
		/*This is assuming 4 byte ints + 8 byte oids per value and a cache of 4MB*/
		sliceSize=350000;

		/*sort the slices*/
		current=NULL;
		startSlice=0;
		endSlice=sliceSize;
		while (endSlice<=BATcount(b)){
			struct sortMergeNode *smNode;
			BAT *slice=BATslice(b, startSlice, endSlice);
			slice->batRestricted= BAT_WRITE;
			BATmirror(BATorder(BATmirror(slice)));

			smNode=(struct sortMergeNode *)GDKmalloc(sizeof(struct sortMergeNode));
			smNode->batId=slice->batCacheid;
			smNode->next=NULL;
			
			if (CrackerIndex[m].smNode==NULL){
				CrackerIndex[m].smNode=smNode;
				current=CrackerIndex[m].smNode;
			}
			else	
				current->next = smNode;
			
			BBPkeepref(slice->batCacheid);
			startSlice=endSlice;
			endSlice=endSlice+sliceSize>BATcount(b)?BATcount(b):endSlice+sliceSize;
		}
		
	/*	current=CrackerIndex[m].smNode;
		while(current!=NULL){
			BAT *slice=BATdescriptor(current->batId);
			if (slice==NULL)
				throw(MAL, "crackers.sortmerge", "Cannot access slice");

			BATprint(slice);
			BBPunfix(slice->batCacheid);
			current=current->next;
		}
	*/	
		BBPkeepref(br->batCacheid);
		BBPunfix(bo->batCacheid);
		return MAL_SUCCEED;
	}
		printf("already sliced and sorted\n");
	
	return MAL_SUCCEED;
@

@= SortMergeOperations
static str
SelectSortMergeBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){	
	@:RangeSelectBody(@1,@2,@3,@4,)@
}

@

@}

