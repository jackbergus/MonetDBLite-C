@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f crackers_sortmerge
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Select Operators for Incrmental sort merge


@+ Interface


@- Type expansion

@= TypeSwitch
@:@1(chr,simple,,chr)@
@:@1(sht,simple,,sht)@
@:@1(int,simple,,int)@
@:@1(lng,simple,,lng)@
@:@1(flt,simple,,flt)@
@:@1(dbl,simple,,dbl)@
@:@1(date,atom,TYPE_,loc)@
@


@- Header file

@h
#ifndef _CRACKERS_SORTMERGE_H_
#define _CRACKERS_SORTMERGE_H_

/* Exported signatures */
@:TypeSwitch(SelectFunctions_decl)@

#endif /* _CRACKERS_SORTMERGE_H */
@


@- Exported signatures

@= SelectFunctions_decl
crackers_export str CRKselectSortMerge_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
@


@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:TypeSwitch(SortMergeOperations)@

/* Exported functions */
@:TypeSwitch(SelectFunctions_impl)@
@


@- Exported functions

@= SelectFunctions_impl
str
CRKselectSortMerge_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){		
	if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
		throw(MAL,"selectsm","only double bounded selectsare currently supported");
	else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		throw(MAL,"selectsm","only double bounded selectsare currently supported");
	else
		return SelectSortMergeBounds_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh);
}
@


@- Local support functions and macros

@= NwayMerge
	current=CrackerIndex[m].smNode;
	totalTuples=totalLowerTuples=totalHigherTuples=0;
	while(current!=NULL){
		/* binary search to find the position of the lowest requested value in the current slice */
		l  = SORTfndfirst_@4(current->slice,@5);
		lt = (@1*)Tloc(current->slice,l);
		t0 = (@1*)Tloc(current->slice,BUNfirst(current->slice));
		lastValue = (@1*)Tloc(current->slice, BUNlast(current->slice));

		/* no qualifying values */
		if (lt == lastValue){
			current->tuples=0;
			totalLowerTuples+=BATcount(current->slice);
			current=current->next;
			continue;
		}

		if (@2_EQ(lt,@5,@3@1) && *inclusiveLow == FALSE){
			while (lt < lastValue && @2_EQ(lt,@5,@3@1))
				lt ++;
		} 
				
		if (lt == lastValue){
			current->tuples=0;
			totalLowerTuples+=BATcount(current->slice);
			current=current->next;
			continue;
		}

		if ( @2_GT(lt,@6,@3@1) || (@2_EQ(lt,@6,@3@1) && *inclusiveHgh==FALSE) ){
			current->tuples=0;
			totalLowerTuples+=(oid) (lt-t0);
			totalHigherTuples+=BATcount(current->slice)-((oid) (lt-t0));
			current=current->next;
			continue;
		}

		current->start= (oid) (lt-t0);	
		
		/* binary search to find the position of the highest requested value */
		l = SORTfndfirst_@4(current->slice, @6);
		lt = (@1*)Tloc(current->slice,l);
		if (lt < lastValue){
			if (@2_EQ(lt,@6,@3@1) && *inclusiveHgh == TRUE){	
				while (lt < lastValue && @2_EQ(lt,@6,@3@1))
					lt ++;
				lt--;
			} else
			if (@2_EQ(lt,@6,@3@1) && *inclusiveHgh == FALSE)
				lt --;
			else
			if ( @2_GT(lt,@6,@3@1) )
				lt --;
		}

		if (lt == lastValue) lt--;
		current->tuples = (((oid) (lt-t0))-current->start)+1;
		totalTuples+=current->tuples;
		totalLowerTuples+=current->start;
		totalHigherTuples+=BATcount(current->slice)-(current->start+current->tuples);
		current=current->next;
	}

	/*N-way merge*/
	rh = (oid*)Hloc(br,BUNfirst(br)+totalLowerTuples);
	rt = (@1 *)Tloc(br,BUNfirst(br)+totalLowerTuples);
	for(i=0;i<totalTuples;i++){
		merge=NULL;	
	
		current=CrackerIndex[m].smNode;
		while(current!=NULL){
			if (current->tuples>0){
				tt=(@1 *)Tloc(current->slice,BUNfirst(current->slice)+current->start);			
				if (merge==NULL)
					merge=current;
				else{
					@1 *small=(@1 *)Tloc(merge->slice,BUNfirst(merge->slice)+merge->start);
					if (@2_LT(tt,small,@3@1))
						merge=current;
				}
			}
			current=current->next;
		}

		if (merge==NULL)
			throw(MAL,"crackers sort merge","Unexpected error while merging");

		*rh=*(oid *)Hloc(merge->slice,BUNfirst(merge->slice)+merge->start);
		*rt=*(@1  *)Tloc(merge->slice,BUNfirst(merge->slice)+merge->start);
		rh++;rt++;
		merge->start++;
		merge->tuples--;
	}
@

@= RangeSelectBody
	BAT *b,*bo,*br,*c,*view;
	int  m;
	oid sliceSize,i;
	struct sortMergeNode *current,*merge;
	bit HBound, foundLow=0, foundHgh=0;
	@1 *lt, *lastValue, *t0;
	BUN l;
	oid totalTuples,totalLowerTuples,totalHigherTuples;
	@1  *rt,*tt;
	oid *rh;
	
	(void) vid;
	(void)foundLow;
	(void)foundHgh;
	
	if (@2_GT(low,hgh,@3@1))
		throw(MAL, "crackers.sortmerge", "illegal range");
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsCrackerIndex(*bid);

	/* if this is the first time we select something from this bat,
	   we have to create the crack column, slice it and sort the slices. 
           We also create the result column where the result values are merged */
	if (m == -1){
		oid endSlice,startSlice;
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.sortmerge", "Cannot access descriptor");

		br=BATnew(TYPE_oid, bo->ttype,BATcount(bo));
		BATsetcount(br,BATcount(bo));

		m = newCrackerIndex_@1(*bid,br->batCacheid);

		/*slicing*/
		/*This is assuming 4 byte ints + 8 byte oids per value and a cache of 4MB*/
		sliceSize=300000;

		/*sort the slices*/
		current=NULL;
		startSlice=0;
		endSlice=sliceSize>BATcount(bo)?BATcount(bo):sliceSize;
		while (1){
			struct sortMergeNode *smNode;
			BAT *slice=BATslice(bo, startSlice, endSlice);
			b = BATcopy(slice, bo->htype, bo->ttype, TRUE);
			if ( bo->htype == TYPE_void)
				b = BATmaterializeh(b);
			b->hsorted = FALSE;
			b->tsorted = FALSE;
			b->hdense = FALSE;
			b->tdense = FALSE;
			BATkey(BATmirror(b),FALSE);
			BATmode(b,PERSISTENT);
			b->batRestricted= BAT_WRITE;
			BATmirror(BATorder(BATmirror(b)));

			smNode=(struct sortMergeNode *)GDKmalloc(sizeof(struct sortMergeNode));
			smNode->batId=b->batCacheid;
			smNode->next=NULL;
			
			if (CrackerIndex[m].smNode==NULL){
				CrackerIndex[m].smNode=smNode;
				current=CrackerIndex[m].smNode;
			}
			else{	
				current->next = smNode;
				current=smNode;
			}
			
			BBPkeepref(b->batCacheid);
			BBPunfix(slice->batCacheid);

			if (endSlice==BATcount(bo))
				break;
			startSlice=endSlice;
			endSlice=endSlice+sliceSize>BATcount(bo)?BATcount(bo):endSlice+sliceSize;
		}
		
		BBPincref(br->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
	}

	/* Take the tree of the result bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.sortmerge", "Cannot access crack index");

	/* Take the result bat */
	if ((br = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.sortmerge", "Cannot access crack index");

	/* Take the slices */
	current=CrackerIndex[m].smNode;
	while(current!=NULL){
		BAT *slice=BATdescriptor(current->batId);
		if (slice==NULL)
			throw(MAL, "crackers.sortmerge", "Cannot access slice");
		current->slice=slice;
		current=current->next;
	}

	@:NwayMerge(@1,@2,@3,@4,low,hgh)@

	printf("found "SZFMT" tuples, all tuples : "SZFMT" \n",totalTuples, totalLowerTuples+totalHigherTuples+totalTuples);

	view = BATslice(br, totalLowerTuples, totalLowerTuples+totalTuples);
	printf("result size is "SZFMT" \n",BATcount(view));

	*vid = view->batCacheid;
	BBPkeepref(*vid);

	/*unfix all slices*/
	current=CrackerIndex[m].smNode;
	while(current!=NULL){
		BBPunfix(current->slice->batCacheid);
		current=current->next;
	}
	BBPunfix(br->batCacheid);
	BBPunfix(c->batCacheid);
	return MAL_SUCCEED;
@

@= SortMergeOperations
static str
SelectSortMergeBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){	
	@:RangeSelectBody(@1,@2,@3,@4,)@
}

@

@}

