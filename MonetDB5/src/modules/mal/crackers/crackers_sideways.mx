
/* BEGIN -------------------------------------- Sideways Cracking -------------------------------------------------------------------*/

@= crackAlgebraSideways
command hselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKhselectBoundsSideways_@1_@2
comment "Retrieve the subset head using a cracker
        index producing preferably a BATview.";

command tselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKtselectBoundsSideways_@1_@2
comment "Retrieve the subset tail using a cracker
        index producing preferably a BATview.";

command dselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit,l2:@2,h2:@2,li2:bit,hi2:bit):bat[:oid,:bit]
address CRKdselectBoundsSideways_@1_@2
comment "Crack based on @1 and evaluate the @2 disjunctive predicate outside the cracked area. Return a bit vector.";

command joinselect( b:bat[:oid,:@2],l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";

command joinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command djoinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKdjoinSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 0, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If yes mark the pivot BUN as 1.";

command project( b:bat[:oid,:@1],bp:bat[:oid,:@2], l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectCrack_@1_@2
comment "Sync and project the tail of the cpair";

command project( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProject_@1_@2
comment "Sync the cracking pair and project the tail";

command dproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit]):bat[:oid,:@2]
address CRKdProject_@1_@2
comment "Sync the cracking pair and project the tail. Use for disjunctive queries that require a larger bit vector";

command projectH( b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKProjectH_@1_@2
comment "Sync the cracking pair and project the head";

command DeleteMap( b:bat[:oid,:@1], bp:bat[:oid,:@2] ):void
address DeleteCrackerMap
comment "Throw away a certain map"; 

command insert( b:bat[:oid,:@1], bp:bat[:oid,:@2], c:bat[:@1,:@2]):void
address CRKinsert
comment "Keep the insertions BAT separatelly and merge in the future on demand with the Ripple";

command printPendingInsertions( b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKprintPendingInsertions
comment "Print the pending insertions";

command extendCrackerMap(b:bat[:oid,:@1], bp:bat[:oid,:@2], P:lng):void
address CRKextendCrackerMap
comment "Extend the cracker map by P positions";

command sizePendingInsertions(b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKsizePendingInsertions
comment "Get the size of the pending insertions for this map";

@

@mal
@:crackAlgebraSideways(int,chr)@
@:crackAlgebraSideways(int,sht)@
@:crackAlgebraSideways(int,int)@
@:crackAlgebraSideways(int,lng)@
@:crackAlgebraSideways(int,flt)@
@:crackAlgebraSideways(int,dbl)@
@:crackAlgebraSideways(int,date)@
@:crackAlgebraSideways(date,chr)@
@:crackAlgebraSideways(date,sht)@
@:crackAlgebraSideways(date,int)@
@:crackAlgebraSideways(date,lng)@
@:crackAlgebraSideways(date,flt)@
@:crackAlgebraSideways(date,dbl)@
@:crackAlgebraSideways(date,date)@

@= shuffleSideways
	hdummy = *(@1*) @3;
	*(@1*) @3= *(@1*) @4;
        *(@1*) @4= hdummy;

	tdummy= *(@2*) @5;
        *(@2*) @5= *(@2*) @6;
        *(@2*) @6 = tdummy;
@

@= crackInTwoUnorderedPiecesSideways
crackers_export str CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, lng first, lng last, lng *pos);
str
CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, lng first, lng last, lng *pos){
        BUN vm, vl;
        BUN vmt, vlt;
        int xx;
        @1 hdummy;
        @2 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNhloc(b, BUNptr(b,first));
        vl= BUNhloc(b,BUNptr(b,last));
        vmt = BUNtloc(b, BUNptr(b,first));
        vlt= BUNtloc(b,BUNptr(b,last));

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  += xx; 
			vmt += xx;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  -= xx; 
				vlt -= xx;
			}
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        vl  -= xx;
			vlt -= xx;
                        vm  += xx;
			vmt += xx;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = BUNindex(b,vl - xx); /*works for empty left piece also*/
		else{
			*pos = BUNindex(b,vl);
			if (BUNindex(b,vl)==(size_t)last) /*empty right piece*/
				*pos = *pos+1;
		}
	}
	else
		*pos = BUNindex(b,vl);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPiecesSideways

crackers_export str CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh);
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh){
        BUN vm, vl, hmax;
        BUN vmt, vlt, hmaxt;
        int xx;
        @1 hdummy;
        @2 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNhloc(b, BUNptr(b,first));
        hmax = BUNhloc(b,BUNptr(b,last));
        vmt = BUNtloc(b, BUNptr(b,first));
        hmaxt = BUNtloc(b,BUNptr(b,last));
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm)
                hmax-= xx; hmaxt-= xx;

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = BUNindex(b,hmax);
		else{
			*posl = BUNindex(b, hmax + xx);
			*posh = BUNindex(b,hmax);
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax-=xx;hmaxt-=xx;
                }
                vl-= xx; vlt-= xx;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
			*posl = BUNindex(b,vl);
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = BUNindex(b,vl);
		else
			*posl = BUNindex(b,vl + xx);
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm += xx; vmt += xx;
                } else {
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                                        hmax-=xx; hmaxt-=xx;
                                }
                                vl -= xx; vlt -= xx;
                        }
                }
        }
	if (vm ==  BUNhloc(b,BUNptr(b,last+1))){ /* Right and middle are empty */
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = BUNindex(b,vl + xx);
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
	*posl = BUNindex(b,vm);
	*posh = BUNindex(b,hmax);

	return MAL_SUCCEED;
}
@

@= operationsSideways
@:crackInTwoUnorderedPiecesSideways(@1,@2,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways(@1,@2,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways(@1,@2,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways(@1,@2,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways(@1,@2,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways(@1,@2,LE,RO,LT,GE,LT,GE,@3,@4)@
@

@c
@:operationsSideways(int,int,simple,)@
@:operationsSideways(int,sht,simple,)@
@:operationsSideways(int,chr,simple,)@
@:operationsSideways(int,lng,simple,)@
@:operationsSideways(int,flt,simple,)@
@:operationsSideways(int,dbl,simple,)@
@:operationsSideways(int,date,simple,)@  /* TODO: add the rest of the type combinations once code is stable */
@:operationsSideways(date,int,atom,TYPE_)@
@:operationsSideways(date,sht,atom,TYPE_)@
@:operationsSideways(date,chr,atom,TYPE_)@
@:operationsSideways(date,lng,atom,TYPE_)@
@:operationsSideways(date,flt,atom,TYPE_)@
@:operationsSideways(date,dbl,atom,TYPE_)@
@:operationsSideways(date,date,atom,TYPE_)@  /* TODO: add the rest of the type combinations once code is stable */

int
existsCrackerIndexSideways(int bid, int pbid){
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == bid && CrackerIndex[i].pbid == pbid)
			return i;
	return -1;
}

crackers_export str CRKsizePendingInsertions(int *k, int *bid, int *pbid);
str
CRKsizePendingInsertions(int *k, int *bid, int *pbid){
        BAT *u;
	int i;
	(void)k;

        i=existsCrackerIndexSideways(*bid,*pbid);
        if (i == -1)
                fprintf(stderr, " the crack index does not exist \n");
        if (CrackerIndex[i].iid > 0){
                u = BATdescriptor(CrackerIndex[i].iid);
                printf("\n pending insertions size: "SZFMT" \n",BATcount(u));
                BBPunfix(u->batCacheid);
        }
        else
                printf("\n pending insertions size: 0 \n");

	 return MAL_SUCCEED;
}


crackers_export str CRKextendCrackerMap(int *k, int *bid, int *pbid, lng positions);
str
CRKextendCrackerMap(int *k, int *bid, int *pbid, lng positions){
        BAT *b;
        int position = existsCrackerIndexSideways(*bid,*pbid);
        (void) k;

        if (position == -1)
                throw(MAL, "crackers.CRKextendCrackermap", "Cannot find cracker index");
        if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "crackers.CRKextendCrackerMap", "Cannot access cracker Map");

        if (BATextend(b, positions) == NULL)
                throw(MAL, "crackers.CRKextendCrackerMap", "Failed to extend the cracker Map");

        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

crackers_export str CRKprintPendingInsertions(int *k, int *bid, int  *pbid);
str
CRKprintPendingInsertions(int *k, int *bid, int *pbid){
        int i = existsCrackerIndexSideways(*bid,*pbid);
	(void) k;

        if (i == -1)
		 throw(MAL, "crackers.CRKprintPendingInsertions", "Cannot find cracker map");

        if (CrackerIndex[i].iid > 0)
                BATprint(BATdescriptor(CrackerIndex[i].iid));

	return MAL_SUCCEED;
}


crackers_export str CRKinsert(int *k, int *bid, int *pbid, int *insertions);
str
CRKinsert(int *k, int *bid, int *pbid, int *insertions){
        int position = existsCrackerIndexSideways(*bid,*pbid);
        (void) k;

        if (position == -1)
                throw(MAL, "crackers.CRKinsert", "Cannot find cracker map");

        appendInsertions(insertions,position);

        return MAL_SUCCEED;
}


crackers_export str DeleteCrackerMap(int *k, int *bid, int *pbid);
str
DeleteCrackerMap(int *k, int *bid, int *pbid){
	int i;
	(void)k;
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == *bid && CrackerIndex[i].pbid == *pbid){
			CrackerIndex[i].bid  = -2;
			CrackerIndex[i].pbid = -2;
		}
	return MAL_SUCCEED;
}

@= NewIndexSidewaysCracking
int
newCrackerIndexHistorySideways_@1(int bid, int chid, int hiid){
        int i, freemap = -1, units = 1024;

        for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == -1)
                        freemap = i;

        if (freemap != -1) {
                CrackerIndex[freemap].bid = bid;
                CrackerIndex[freemap].chid = chid;
                CrackerIndex[freemap].hiid = hiid;
                return freemap;
        }

        if (i == maxCrackMap) {
                CrackerIndexNode *x;

                if (maxCrackMap > 0)
                        units = (int) (1.2 * maxCrackMap);
                x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
                memset(x, 0, sizeof(CrackerIndexNode) * units);
                if (CrackerIndex) {
                        fprintf(stderr, "reallocate index \n");
                        memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
                        GDKfree(CrackerIndex);
                }
                CrackerIndex = x;
                maxCrackMap = units;
        }

        CrackerIndex[i].chid = chid;
        CrackerIndex[i].hiid = hiid;
        CrackerIndex[i].pbid = -1;
        CrackerIndex[i].bid = bid;
        CrackerIndex[i].cbid = -1;
        CrackerIndex[i].cid = -1;
        CrackerIndex[i].iid = -1;
        CrackerIndex[i].did = -1;
        CrackerIndex[i].mergeInsertions = -1;
        CrackerIndex[i].reCreate = 0;
        CrackerIndex[i].Tree = NULL;
        CrackerIndex[i].deleteNodes = FALSE;
        CrackerIndex[i].mergeDeletions = -1;
        return i;
}

int
newCrackerIndexSideways_@1(int bid, int cbid, int pbid){
	int i, freemap = -1, units = 1024;
	BAT *b;
	
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		CrackerIndex[freemap].bid = bid;
		CrackerIndex[i].pbid = pbid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackerIndexNode *x;

		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
		memset(x, 0, sizeof(CrackerIndexNode) * units);
		if (CrackerIndex) {
			fprintf(stderr, "reallocate index \n");
			memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
			GDKfree(CrackerIndex);
		}
		CrackerIndex = x;
		maxCrackMap = units;
	}

	CrackerIndex[i].nextCrack = 0;
	CrackerIndex[i].chid = -1;
	CrackerIndex[i].hiid = -1;
	CrackerIndex[i].pbid = pbid;  /* this line is the only addittion compared to the non projections function */
	CrackerIndex[i].bid = bid;
	CrackerIndex[i].cbid = cbid;
	b = BATnew(TYPE_lng, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	CrackerIndex[i].cid = b->batCacheid;
	CrackerIndex[i].iid = -1;
	CrackerIndex[i].did = -1;
	CrackerIndex[i].mergeInsertions = -1;
	CrackerIndex[i].reCreate = 0;
	CrackerIndex[i].Tree = NULL;
	CrackerIndex[i].deleteNodes = FALSE;
	CrackerIndex[i].mergeDeletions = -1;
	return i;
}
@

@c
@:NewIndexSidewaysCracking(chr)@
@:NewIndexSidewaysCracking(sht)@
@:NewIndexSidewaysCracking(int)@
@:NewIndexSidewaysCracking(lng)@
@:NewIndexSidewaysCracking(flt)@
@:NewIndexSidewaysCracking(dbl)@
@:NewIndexSidewaysCracking(date)@

/* function "reCreateMap" is used as is in selections cracking */

@= crkTwoRTreeSideways
        /*CRACK in two pieces cl2-ch2 using <incHgh bound*/
        if (*inclusiveHgh == TRUE)
                CRKcrackUnorderedZeroSideways_LE_@1_@2(b,*hgh, cl2, ch2,&vh);
        else
                CRKcrackUnorderedZeroSideways_RE_@1_@2(b,*hgh, cl2, ch2,&vh);

        /*check for gaps*/
        if (vh < cl2)
                /*then the left piece is empty*/
                gapH = -1;
        if (vh > ch2){
                /*then the right piece is empty*/
                gapH = -1;
                vh--;
        }

@= crkTwoLTreeSideways
        /*CRACK in two pieces cl1-ch1 using >incLow bound*/
        if (*inclusiveLow == TRUE)
                CRKcrackUnorderedZeroSideways_RE_@1_@2(b,*low, cl1, ch1,&vl);
        else
                CRKcrackUnorderedZeroSideways_LE_@1_@2(b,*low, cl1, ch1,&vl);
        if (vl < cl1){
                /*then the left piece is empty*/
                gapL = -1;
        }
        if (vl > ch1){
                /*then the right piece is empty*/
                vl--;
                gapL = -1;
        }
        vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
                Instead we want the first bun of the right piece*/
@

@= crkThreeTreeSideways
        if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeSideways_LE_RE_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeSideways_LE_RO_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeSideways_LO_RE_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeSideways_LO_RO_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);

        if (vl != -1 && vh != -1){
                if (vl>0) _vl=vl-1; else _vl=vl;
                addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
                addCrackerIndex_@1(m,hgh,HBound,vh,c);
        }
@

@= SyncOperation
str
Sync_@1_@2(int m, int h){
	BAT *h1,*h2,*b, *c;
	BUN h1head,h1tail,h2head,h2tail;
	int h1size, h2size, zz;
	lng syncs;
	lng size;

        lng vl=-1, vh=-1;
        lng cl1, ch1, cl2, ch2;
        int _vl;
        bit HBound, foundLow=0, foundHgh=0;
        int gapL = 1;
        int gapH = 1;
	bit *inclusiveHgh,*inclusiveLow;
	@1 *low, *hgh;
	lng j;

        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

	 /* Take the index of the bat */
        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");


        if ((h1 = BATdescriptor(CrackerIndex[h].chid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");

        if ((h2 = BATdescriptor(CrackerIndex[h].hiid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");

	/* check if the current pair is already synced */	
	size = BATcount(h1);
	if (CrackerIndex[m].nextCrack == size)
		goto done;

	syncs = size - CrackerIndex[m].nextCrack;
	h1size = BUNsize(h1);
	h2size = BUNsize(h2);

	h1head = BUNhloc(h1, BUNfirst(h1)+h1size*CrackerIndex[m].nextCrack);
	h1tail = BUNtloc(h1, BUNfirst(h1)+h1size*CrackerIndex[m].nextCrack);
	h2head = BUNhloc(h2, BUNfirst(h2)+h2size*CrackerIndex[m].nextCrack);
	h2tail = BUNtloc(h2, BUNfirst(h2)+h2size*CrackerIndex[m].nextCrack);
        zz = BUNsize(c);

	if (CrackerIndex[m].nextCrack == 0){
		low = (@1*)h1head;
                hgh = (@1*)h1tail;
                inclusiveLow = (bit*)h2head;
                inclusiveHgh = (bit*)h2tail;
                if (*inclusiveHgh == TRUE) HBound = FALSE;
                else HBound = TRUE;

		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
			lng posl = BUNindex(b,BUNfirst(b));
        	        lng posh = BUNindex(b,BUNlast(b)-BUNsize(b));
	
                	@:crkThreeTreeSideways(@1,@2,posl,posh)@
		}

		h1head += h1size;
                h1tail += h1size; 
                h2head += h2size;
                h2tail += h2size;
	}	

	for (j=0; j<syncs; j++){
		low = (@1*)h1head; 
		hgh = (@1*)h1tail; 
		inclusiveLow = (bit*)h2head; 
		inclusiveHgh = (bit*)h2tail; 
		if (*inclusiveHgh == TRUE) HBound = FALSE;
		else HBound = TRUE;

		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
        
       		 	/* find out where in the index the low   falls */
               	 	foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
        
        		/* find out where in the index the high falls */        
			foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
                
			/*need to increase one position for the low bound only since we always store the previous position in the index*/
        		if (cl1 != 0) cl1++;
        		if (cl2 != 0) cl2++;
        
       			 /* If one or both of the result view bounds were not found using the
        		index then we have to crack */
        		if (foundLow == 0 || foundHgh == 0){
                		if (foundLow == 0 && foundHgh == 0){                         
					/* If ch2 is right after cl1 in the index then we split this piece in three pieces*/   
                        		if (cl1 == cl2){
                                		@:crkThreeTreeSideways(@1,@2,cl1,ch2)@
                        		} else {
                                		/* Else we have to do two cracks separatelly */
                                
                                		/* For the cl bound and the next one in the index*/
                                		@:crkTwoLTreeSideways(@1,@2)@
                                
                                		/* For the ch bound and the previous one in the index*/
                                		@:crkTwoRTreeSideways(@1,@2)@
                                
						if (vl>0) _vl=vl-1; 
						else      _vl=vl;
                                        	if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);                                
                                        	if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
                        		}
                		} else
                		if (foundLow == 0){
                        		@:crkTwoLTreeSideways(@1,@2)@
                                	if (vl>0) _vl=vl-1; else _vl=vl;
					if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
                        		vh = ch2;
                		} else
                		if (foundHgh == 0){
                        		@:crkTwoRTreeSideways(@1,@2)@
                                	if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
                       		 	vl = cl1;
                		}
        		} else {
                		vl = cl1;
                		vh = ch2;
        		}
		}	

/* TODO fill in the rest of the cases */
/*		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && ((@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
		}
		if ( ((@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
		}
*/	
		h1head += h1size;
		h1tail += h1size;
		h2head += h2size;
		h2tail += h2size;
	}		
	
	CrackerIndex[m].nextCrack = size;

	done:;
	BBPunfix(h1->batCacheid);
	BBPunfix(h2->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(c->batCacheid);
	return MAL_SUCCEED;
}
@

@= TapeOperations
int
CreateTape_@1(int bid){
	BAT *h1,*h2;
	lng tape_size= 200000;

	h1 = BATnew(TYPE_@1,TYPE_@1,tape_size);		
	h2 = BATnew(TYPE_bit,TYPE_bit,tape_size);		

	h1->batBuns->free =  BUNfirst(h1) - h1->batBuns->base;
        BATsetcount(h1, 0);
	h2->batBuns->free =  BUNfirst(h2) - h2->batBuns->base;
        BATsetcount(h2, 0);

	BBPkeepref(h1->batCacheid);
	BBPkeepref(h2->batCacheid);

	return newCrackerIndexHistorySideways_@1(bid, h1->batCacheid, h2->batCacheid);				
}

str
AddToTape_@1(int h, @1 low, @1 hgh, bit li, bit hi){
	BAT *h1,*h2;
	lng size;	

	if ((h1 = BATdescriptor(CrackerIndex[h].chid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");
                                                
        if ((h2 = BATdescriptor(CrackerIndex[h].hiid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");
                                                
        size = BATcount(h1);

        *(@1*)BUNhloc(h1, BUNlast(h1)) = low;
        *(@1*)BUNtloc(h1, BUNlast(h1)) = hgh;
        *(bit*)BUNhloc(h2, BUNlast(h2)) = li;
        *(bit*)BUNtloc(h2, BUNlast(h2)) = hi;

	h1->batBuns->free =  (BUNlast(h1)+BUNsize(h1)) - h1->batBuns->base;
        BATsetcount(h1, size+1);
	h2->batBuns->free =  (BUNlast(h2)+BUNsize(h2)) - h2->batBuns->base;
        BATsetcount(h2, size+1);
	
	BBPunfix(h1->batCacheid);
        BBPunfix(h2->batCacheid);
        return MAL_SUCCEED;
}
@

@c
@:SyncOperation(int,chr,simple,)@
@:SyncOperation(int,sht,simple,)@
@:SyncOperation(int,int,simple,)@
@:SyncOperation(int,lng,simple,)@
@:SyncOperation(int,flt,simple,)@
@:SyncOperation(int,dbl,simple,)@
@:SyncOperation(int,date,simple,)@
@:SyncOperation(date,chr,atom,TYPE_)@
@:SyncOperation(date,sht,atom,TYPE_)@
@:SyncOperation(date,int,atom,TYPE_)@
@:SyncOperation(date,lng,atom,TYPE_)@
@:SyncOperation(date,flt,atom,TYPE_)@
@:SyncOperation(date,dbl,atom,TYPE_)@
@:SyncOperation(date,date,atom,TYPE_)@

@:TapeOperations(chr)@
@:TapeOperations(sht)@
@:TapeOperations(int)@
@:TapeOperations(lng)@
@:TapeOperations(flt)@
@:TapeOperations(dbl)@
@:TapeOperations(date)@

@= CreateResultSideways
createView:
        view = BATslice(b, vl, vh+1);

	if (tail)
                view = BATslice(BATmirror(VIEWhead_(BATmirror(b), BAT_READ)), vl, vh+1);
	else 
                view = BATslice(BATmirror(VIEWhead_(b, BAT_READ)), vl, vh+1);

        *vid = view->batCacheid;
        BBPkeepref(*vid);

        BBPunfix(b->batCacheid);
@

@= CreateCrackerMap
		BAT *bo, *bp;
                lng size;
                BUN ptail, ctail, nhead, ntail, nlast;
                int csize, psize, nsize;
		lng j;
		printf("create new map\n");
                if ((bo = BATdescriptor(*bid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access descriptor");
                if ((bp = BATdescriptor(*pbid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access pdescriptor");

                size = BATcount(bo);
		b = BATnew(bo->ttype, bp->ttype, size);

                nsize = BUNsize(b);
                csize = BUNsize(bo);
                psize = BUNsize(bp);
                nhead = BUNhloc(b,  BUNfirst(b));
                ntail = BUNtloc(b,  BUNfirst(b));
                ctail = BUNtloc(bo, BUNfirst(bo));
                ptail = BUNtloc(bp, BUNfirst(bp));
                for(j=0;j<size;j++){
                        *(@1*)nhead = *(@1*)ctail;
                        *(@2*)ntail = *(@2*)ptail;
                        nhead+=nsize;
                        ntail+=nsize;
                        ctail+=csize;
                        ptail+=psize;
                }

                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;
                /*BATkey(b,TRUE);*/
                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);
	
		nlast = BUNfirst(b) + nsize*size;
        	b->batBuns->free =  nlast - b->batBuns->base;
        	BATsetcount(b, size);

                m = newCrackerIndexSideways_@1(*bid, b->batCacheid, *pbid);

                bo->batRestricted= BAT_READ;
                BBPunfix(bo->batCacheid);
                BBPunfix(bp->batCacheid);
@

@= updatesSideways
str
selectMergeInsertionsPart_@1Sideways( @1 *low, bit *inclusiveLow, @1 *hgh, bit *inclusiveHgh, int position){
	BAT *u,*b;
	lng updates, updatesStart, updatesEnd;
	BUN l, lt, updLast;
	int xx;
	 if (CrackerIndex[position].iid == -1) return NULL;
	if ((u = BATdescriptor(CrackerIndex[position].iid)) == NULL)
		return "Cannot access insertions BAT";			

	updates = BATcount(u);
	if (updates == 0){
        	BBPunfix(u->batCacheid);
                return NULL; /* no qualifying values in the insertions */
        }

	BATmirror(u);

	/* if necessary, sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	/* binary search to find the position of the lowest requested value in the insertions */
	l = SORTfndfirst_@5(u,low);
	lt = BUNtloc(u,l);
	updLast = BUNtloc(u, BUNlast(u));
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	xx = BUNsize(u);
	if (@3_EQ(lt,low,@4@1) && *inclusiveLow == FALSE){
		while (lt < updLast && @3_EQ(lt,low,@4@1))
			lt +=xx;
	} 			
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	if ( @3_GT(lt,hgh,@4@1) || (@3_EQ(lt,hgh,@4@1) && *inclusiveHgh==FALSE) ){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */ 	
	}
	updatesStart = BUNindex(u,lt);	
	
	/* binary search to find the position of the highest requested value in the insertions */
        l = SORTfndfirst_@5(u, hgh);
	lt = BUNtloc(u,l);
	if (lt < updLast){
		if (@3_EQ(lt,hgh,@4@1) && *inclusiveHgh == TRUE){	
			while (lt < updLast && @3_EQ(lt,hgh,@4@1))
                            	lt +=xx;
			lt-=xx;
		} else
		if (@3_EQ(lt,hgh,@4@1) && *inclusiveHgh == FALSE)
                        lt -=xx;
		else
		if ( @3_GT(lt,hgh,@4@1) )
                        lt -=xx;
	}

	if (lt == updLast) lt-=xx;
	updatesEnd = BUNindex(u,lt);

	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "crackers.crackRangeInsertionPart", "Cannot access cracker map");
	BATmirror(b);

	mergeInsertionsBRipple_@1(b, u, updatesStart, updatesEnd, hgh, *inclusiveHgh, position);	

	BATmirror(u);
	BBPunfix(u->batCacheid);
	BATmirror(b);
	BBPunfix(b->batCacheid);

	return NULL;
}
@

@c
@:updatesSideways(chr,,simple,,chr)@
@:updatesSideways(sht,,simple,,sht)@
@:updatesSideways(int,,simple,,int)@
@:updatesSideways(lng,,simple,,lng)@
@:updatesSideways(flt,,simple,,flt)@
@:updatesSideways(dbl,,simple,,dbl)@
@:updatesSideways(date,,atom,TYPE_,loc)@

@= analyzeTailDisjunction
 
        for (j = 0; j<vl; j++){
                if (@2_@4(pairt,low2,@3@1) && @2_@5(pairt,hgh2,@3@1))
                        *(bit*)pivott = (bit)TRUE;
                else
                        *(bit*)pivott = (bit)FALSE;

                pairt  += bsize;
                pivott += psize;
        }
	
        for (j = vl; j<=vh; j++){
                *(bit*)pivott = (bit)TRUE;

                pairt  += bsize;
                pivott += psize;
        }

	for (j = vh+1; j<size; j++){
                if (@2_@4(pairt,low2,@3@1) && @2_@5(pairt,hgh2,@3@1))
                        *(bit*)pivott = (bit)TRUE;
                else
                        *(bit*)pivott = (bit)FALSE;

                pairt  += bsize;
                pivott += psize;
        }
@

@= CreateDisjunctiveResultSideways
createView:
{
        BAT *p;     
        BUN pairt, pivott, pivotlast;        
	lng size;
	int bsize, psize;
	lng j;

	size = BATcount(b);
        p = BATnew(TYPE_void,TYPE_bit,size);

        pairt = BUNtloc(b, BUNfirst(b));
        pivott = BUNtloc(p, BUNfirst(p));
        bsize = BUNsize(b);
        psize = BUNsize(p);

	if (*inclusiveLow2==TRUE && *inclusiveHgh2==TRUE){
		@:analyzeTailDisjunction(@2,@3,@4,GE,LE)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==TRUE){
		@:analyzeTailDisjunction(@2,@3,@4,GT,LE)@	
	}
	if (*inclusiveLow2==TRUE && *inclusiveHgh2==FALSE){
		@:analyzeTailDisjunction(@2,@3,@4,GE,LT)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==FALSE){
		@:analyzeTailDisjunction(@2,@3,@4,GT,LT)@	
	}

        pivotlast = BUNfirst(p) + psize*size;
        p->batBuns->free =  pivotlast - p->batBuns->base;
        BATsetcount(p, size);

        p->hsorted = FALSE;
        p->tsorted = FALSE;
        p->hdense = FALSE;
        p->tdense = FALSE;

        BBPkeepref(p->batCacheid);
        BBPunfix(b->batCacheid);
        *vid = p->batCacheid;
}
@

	for (j = vh+1; j<size; j++){
                if (@2_@4(low2,pairt,@3@1) && @2_@5(hgh2,pairt,@3@1))
                        *(bit*)pivott = (bit)TRUE;
                else
                        *(bit*)pivott = (bit)FALSE;

                pairt  += bsize;
                pivott += psize;
        }
@

@= CreateDisjunctiveResultSideways
createView:
{
        BAT *p;     
        BUN pairt, pivott, pivotlast;        
	lng size;
	int bsize, psize;
	lng j;

	size = BATcount(b);
        p = BATnew(TYPE_void,TYPE_bit,size);

        pairt = BUNtloc(b, BUNfirst(b));
        pivott = BUNtloc(p, BUNfirst(p));
        bsize = BUNsize(b);
        psize = BUNsize(p);

	if (*inclusiveLow2==TRUE && *inclusiveHgh2==TRUE){
		@:analyzeTailDisjunction(@2,@3,@4,GE,LE)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==TRUE){
		@:analyzeTailDisjunction(@2,@3,@4,GT,LE)@	
	}
	if (*inclusiveLow2==TRUE && *inclusiveHgh2==FALSE){
		@:analyzeTailDisjunction(@2,@3,@4,GE,LT)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==FALSE){
		@:analyzeTailDisjunction(@2,@3,@4,GT,LT)@	
	}

        pivotlast = BUNfirst(p) + psize*size;
        p->batBuns->free =  pivotlast - p->batBuns->base;
        BATsetcount(p, size);

        p->hsorted = FALSE;
        p->tsorted = FALSE;
        p->hdense = FALSE;
        p->tdense = FALSE;

        BBPkeepref(p->batCacheid);
        BBPunfix(b->batCacheid);
        *vid = p->batCacheid;
}
@

@= RangeSelectBody
        BAT *b, *c, *view=NULL;
        int  m, h;
        lng vl=-1, vh=-1, posl, posh, cl1, ch1, cl2, ch2;
        int zz,_vl;
        int gapL = 1, gapH = 1;
        bit HBound, foundLow=0, foundHgh=0;

        if (@3_GT(low,hgh,@4@1))
                throw(MAL, "crackers.crack", "illegal range");

        if (*inclusiveHgh == TRUE) HBound = FALSE;
        else    HBound = TRUE;

	/* get the cracker tape for this set or create one if it does not exist */
        h = existsCrackerIndexSideways(*bid, -1);
	if (h == -1)
		h = CreateTape_@1(*bid); 

	/* get the map */
        m = existsCrackerIndexSideways(*bid, *pbid);

        /* create the map if it does not exist and perform the fist crack 
	   without searching the index (it is empty at this point) */
        if (m == -1){
		@:CreateCrackerMap(@1,@2)@		

                if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* crack the whole map based on the current restriction */
                posl = BUNindex(b,BUNfirst(b));
                posh = BUNindex(b,BUNlast(b)-BUNsize(b));
                @:crkThreeTreeSideways(@1,@2,posl,posh)@

                BBPincref(b->batCacheid,TRUE);
		
		/* update the cracker tape and the cursor of the map */
		AddToTape_@1(h, *low, *hgh, *inclusiveLow, *inclusiveHgh );
		CrackerIndex[m].nextCrack+=1;

                goto createView;
        }

        /*  Check if this map was previously cracked but the map is not there anymore.
            This may happen if we chose to forget the index because of updates, so now we          
            have to create a new one and crack in three pieces anyway. */

        if (CrackerIndex[m].reCreate == 1){
                
                reCreateMap_@1(m);
                
                /* Take the index of the bat */
                if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)                        
			throw(MAL, "crackers.crackRange", "Cannot access cracker index");
                
                /* Take the copy of the bat for which we maintain the index */
                if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access cracker BAT");
                
                posl = BUNindex(b,BUNfirst(b));
                posh = BUNindex(b,BUNlast(b)-BUNsize(b));
                
                @:crkThreeTreeSideways(@1,@2,posl,posh)@

                goto createView;
        }

	 /* If a map exists for this bat (so it has been cracked before)
            we search its index to find where our range falls.
            If we have a match on the low range vl will hold the
            index value, otherwise it will be -1. The same for hgh and vh.
            If there is no match for low, then cl will hold a position on the map that
            from there on we have to crack. The same from hgh and ch.
            
            In the case of the low range we always have to increment
            by one this position since we want the tuples that are after this position
            (because of the way the crack index maintains information).
            
            After the search l and h point to the low and hgh positions
            (in the cracker index) found either as a match or to crack.
            This is used later on to determine which pieces we have to crack. */
        
	/* Align the map based on the position of its cursor in the cracker tape */
	Sync_@1_@2(m,h);        
        
        /* Take the index of the map */
        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");
        
        /* Take the map */
        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        zz = BUNsize(c);
	
	selectMergeInsertionsPart_@1Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
        
        /* find out where in the index the low falls */
        foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
        
        /* find out where in the index the high falls */        
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
                
	/* need to increase one position for the low bound only since we always store the previous position in the index */
        if (cl1 != 0) cl1++;
        if (cl2 != 0) cl2++;
        
        /* If one or both of the selection bounds were not found, then we have to crack */
        if (foundLow == 0 || foundHgh == 0){
                if (foundLow == 0 && foundHgh == 0){                         
			/* If ch2 is right after cl1 in the index then we split this piece in three pieces */   
                        if (cl1 == cl2){
                                @:crkThreeTreeSideways(@1,@2,cl1,ch2)@
                        } else {
                                /* Else we have to do two cracks separatelly */
                                
                                /* For the cl bound and the next one in the index */
                                @:crkTwoLTreeSideways(@1,@2)@
                                
                                /* For the ch bound and the previous one in the index */
                                @:crkTwoRTreeSideways(@1,@2)@
                                
                                if (IndexSize <IndexStop){                                        
					if (vl>0) 
						_vl=vl-1; 
					else 
						_vl=vl;
                                        if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);                                
                                        if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
                                }
                        }
                } else
                if (foundLow == 0){
                        @:crkTwoLTreeSideways(@1,@2)@
                        if (IndexSize <IndexStop){
                                if (vl>0) _vl=vl-1; else _vl=vl;
				if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
                        }
                        vh = ch2;
                } else
                if (foundHgh == 0){
                        @:crkTwoRTreeSideways(@1,@2)@
                        if (IndexSize <IndexStop)
                                if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
                        vl = cl1;
                }
        } else {
                vl = cl1;
                vh = ch2;
        }

	/* Update the cracker tape and the cursor */
	AddToTape_@1(h, *low, *hgh, *inclusiveLow, *inclusiveHgh );
	CrackerIndex[m].nextCrack+=1;
@

@= crackOperationsSideways
str
CRKRangeSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail){
	@:RangeSelectBody(@1,@2,@3,@4)@

	/* Define resulting view: a contiguous area on the map */	
        @:CreateResultSideways()@

        return MAL_SUCCEED;
}

str
CRKdRangeSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2){
	@:RangeSelectBody(@1,@2,@3,@4)@

	(void)view;
	/* Define resulting view: a contiguous area on the map */	
        @:CreateDisjunctiveResultSideways(@1,@2,@3,@4)@

        return MAL_SUCCEED;
}
@

@c
@:crackOperationsSideways(int,chr,simple,)@
@:crackOperationsSideways(int,sht,simple,)@
@:crackOperationsSideways(int,int,simple,)@
@:crackOperationsSideways(int,lng,simple,)@
@:crackOperationsSideways(int,flt,simple,)@
@:crackOperationsSideways(int,dbl,simple,)@
@:crackOperationsSideways(int,date,simple,)@
@:crackOperationsSideways(date,chr,atom,TYPE_)@
@:crackOperationsSideways(date,sht,atom,TYPE_)@
@:crackOperationsSideways(date,int,atom,TYPE_)@
@:crackOperationsSideways(date,lng,atom,TYPE_)@
@:crackOperationsSideways(date,flt,atom,TYPE_)@
@:crackOperationsSideways(date,dbl,atom,TYPE_)@
@:crackOperationsSideways(date,date,atom,TYPE_)@

@= SelectFunctionsSideways
crackers_export str CRKhselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKhselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKhselectBoundsSideways_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKhselectBoundsSideways_@1_@2", "case not handled");
	else
		return CRKRangeSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);

        throw(MAL, "crackers.CRKhselectBoundsSideways_@1_@2", "case not handled");
}

crackers_export str CRKtselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKtselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKtselectBoundsSideways_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKtselectBoundsSideways_@1_@2", "case not handled");
	else
		return CRKRangeSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);

        throw(MAL, "crackers.CRKtselectBoundsSideways_@1_@2", "case not handled");
}

crackers_export str CRKdselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2);
str
CRKdselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKdselectBoundsSideways_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKdselectBoundsSideways_@1_@2", "case not handled");
	else
		return CRKdRangeSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, low2, hgh2, inclusiveLow2, inclusiveHgh2);

        throw(MAL, "crackers.CRKdselectBoundsSideways_@1_@2", "case not handled");
}
@

@c
@:SelectFunctionsSideways(int,chr,simple,)@
@:SelectFunctionsSideways(int,sht,simple,)@
@:SelectFunctionsSideways(int,int,simple,)@
@:SelectFunctionsSideways(int,lng,simple,)@
@:SelectFunctionsSideways(int,flt,simple,)@
@:SelectFunctionsSideways(int,dbl,simple,)@
@:SelectFunctionsSideways(int,date,simple,)@
@:SelectFunctionsSideways(date,chr,atom,TYPE_)@
@:SelectFunctionsSideways(date,sht,atom,TYPE_)@
@:SelectFunctionsSideways(date,int,atom,TYPE_)@
@:SelectFunctionsSideways(date,lng,atom,TYPE_)@
@:SelectFunctionsSideways(date,flt,atom,TYPE_)@
@:SelectFunctionsSideways(date,dbl,atom,TYPE_)@
@:SelectFunctionsSideways(date,date,atom,TYPE_)@

@= JoinSelectBodySideways
        BAT *b, *p;     
        BUN pairt, pivott, pivotlast;        
	lng size;
	int bsize, psize;
	lng j;

        if ((b = BATdescriptor(*cpair)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
        }  

	size = BATcount(b);
	p = BATnew(TYPE_void,TYPE_bit,size);

	pairt = BUNtloc(b, BUNfirst(b));
	pivott = BUNtloc(p, BUNfirst(p));
	bsize = BUNsize(b);
	psize = BUNsize(p);
	for (j = 0; j<size; j++){
		if (@3)	
			*(bit*)pivott = (bit)TRUE;
		else 
			*(bit*)pivott = (bit)FALSE;

		pairt  += bsize;
		pivott += psize;	
	}

	pivotlast = BUNfirst(p) + psize*size;
        p->batBuns->free =  pivotlast - p->batBuns->base;
        BATsetcount(p, size);	
	
	p->hsorted = FALSE;
        p->tsorted = FALSE;
        p->hdense = FALSE;
        p->tdense = FALSE;

	BBPkeepref(p->batCacheid);
	BBPunfix(b->batCacheid);
	*res = p->batCacheid;

	return MAL_SUCCEED;
@

@= JoinSelectBodySidewaysWithPivot
        BAT *b, *p, *c, *pair;     
        BUN pairt, pivott;        
	lng size;
	int bsize, psize;
	lng skip;
	int m;
	lng cl1,cl2,ch1,ch2;
	lng j;

	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	if ((pair = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");

        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        GetLow_@1(*low1, *inclusiveLow1, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

        GetHgh_@1(*hgh1, *inclusiveHgh1, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

	if (cl1 != 0) cl1++;

        b = BATslice(pair, cl1, ch2+1);

        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
	
	size = BATcount(p);
	pairt = BUNtloc(b, BUNfirst(b));
	pivott = BUNtloc(p, BUNfirst(p));
	bsize = BUNsize(b);
	psize = BUNsize(p);
	skip = 0;
	for (j = 0; j<size; j++){
		if (*(bit*)pivott == TRUE){
	        	pairt += skip*bsize;	
			if (!(@3))	
				*(bit*)pivott = FALSE;
			skip = 0;
		}
		pivott += psize;	
		skip++;
	}

	BBPunfix(pair->batCacheid);
	BBPkeepref(p->batCacheid);
	*res = p->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
@

@= dJoinSelectBodySidewaysWithPivot
        BAT *b, *p;     
        BUN pairt, pivott;        
	lng size;
	int bsize, psize;
	lng skip;
	int m;
	lng j;

	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.dJoinSelectSideways", "Cannot access map");


        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
	
	size = BATcount(p);
	pairt = BUNtloc(b, BUNfirst(b));
	pivott = BUNtloc(p, BUNfirst(p));
	bsize = BUNsize(b);
	psize = BUNsize(p);
	skip = 0;
	for (j = 0; j<size; j++){
		if (*(bit*)pivott == FALSE){
	        	pairt += skip*bsize;	
			if ((@3))	
				*(bit*)pivott = TRUE;
			skip = 0;
		}
		pivott += psize;	
		skip++;
	}

	BBPkeepref(p->batCacheid);
	*res = p->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
@

@= JoinSelectRSidewaysWithoutPivot
str
JoinSelectRangeSideways_@3_@4_@2(int *res, int *cpair, @2 *low, @2 *hgh){
        @:JoinSelectBodySideways(,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}

@= JoinSelectRSideways
str
JoinSelectRangeSideways_P_@3_@4_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1){
        @:JoinSelectBodySidewaysWithPivot(@1,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}

str
dJoinSelectRangeSideways_P_@3_@4_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh){
        @:dJoinSelectBodySidewaysWithPivot(@1,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}
@

@= JoinSelectSidewaysWithoutPivot
str
JoinSelectSingleSideways_@3_@2(int *res, int *cpair, @2 *mid){
        @:JoinSelectBodySideways(,@2,@5_@4(pairt,mid,@6@2))@
}

@= JoinSelectSideways
str
JoinSelectSingleSideways_P_@3_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *mid, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1){
        @:JoinSelectBodySidewaysWithPivot(@1,@2,@5_@4(pairt,mid,@6@2))@
}
@

@= JoinSelectOperationsSideways
@:JoinSelectRSideways(@1,@2,LO,RE,GT,LE,@3,@4)@
@:JoinSelectRSideways(@1,@2,LE,RE,GE,LE,@3,@4)@
@:JoinSelectRSideways(@1,@2,LO,RO,GT,LT,@3,@4)@
@:JoinSelectRSideways(@1,@2,LE,RO,GE,LT,@3,@4)@
@:JoinSelectSideways(@1,@2,RO,LT,@3,@4)@
@:JoinSelectSideways(@1,@2,RE,LE,@3,@4)@
@:JoinSelectSideways(@1,@2,LO,GT,@3,@4)@
@:JoinSelectSideways(@1,@2,LE,GE,@3,@4)@
@

@= JoinSelectOperationsSidewaysWithoutPivot
@:JoinSelectRSidewaysWithoutPivot(,@2,LO,RE,GT,LE,@3,@4)@
@:JoinSelectRSidewaysWithoutPivot(,@2,LE,RE,GE,LE,@3,@4)@
@:JoinSelectRSidewaysWithoutPivot(,@2,LO,RO,GT,LT,@3,@4)@
@:JoinSelectRSidewaysWithoutPivot(,@2,LE,RO,GE,LT,@3,@4)@
@:JoinSelectSidewaysWithoutPivot(,@2,RO,LT,@3,@4)@
@:JoinSelectSidewaysWithoutPivot(,@2,RE,LE,@3,@4)@
@:JoinSelectSidewaysWithoutPivot(,@2,LO,GT,@3,@4)@
@:JoinSelectSidewaysWithoutPivot(,@2,LE,GE,@3,@4)@
@

@= JoinSelectFunctionsSidewaysWithoutPivot
crackers_export str CRKjoinSelectSideways_@2(int *res, int *cpair, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str                     
CRKjoinSelectSideways_@2(int *res, int *cpair, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh){               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingleSideways_RE_@2(res, cpair, hgh);
		else
                	return JoinSelectSingleSideways_RO_@2(res, cpair, hgh);
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingleSideways_LE_@2(res, cpair, low);
		else
                	return JoinSelectSingleSideways_LO_@2(res, cpair, low);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_LE_RE_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_LE_RO_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_LO_RO_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_LO_RE_@2(res, cpair, low, hgh);
	}
        throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
}

@= JoinSelectFunctionsSideways
crackers_export str CRKjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str                     
CRKjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh){               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingleSideways_P_RE_@1_@2(res, bid, pbid, pivot, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
                	return JoinSelectSingleSideways_P_RO_@1_@2(res, bid, pbid, pivot, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingleSideways_P_LE_@1_@2(res, bid, pbid, pivot, low, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
                	return JoinSelectSingleSideways_P_LO_@1_@2(res, bid, pbid, pivot, low, low1, hgh1, inclusiveLow1, inclusiveHgh1);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_P_LE_RE_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_P_LE_RO_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_P_LO_RO_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_P_LO_RE_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
	}
        throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
}

crackers_export str CRKdjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str                     
CRKdjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh){               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
        		throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
		else
        		throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
        		throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
		else
        		throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return dJoinSelectRangeSideways_P_LE_RE_@1_@2(res, bid, pbid, pivot, low, hgh);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return dJoinSelectRangeSideways_P_LE_RO_@1_@2(res, bid, pbid, pivot, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return dJoinSelectRangeSideways_P_LO_RO_@1_@2(res, bid, pbid, pivot, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==TRUE))
                	return dJoinSelectRangeSideways_P_LO_RE_@1_@2(res, bid, pbid, pivot, low, hgh);
	}
        throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
}
@

@c
@:JoinSelectOperationsSidewaysWithoutPivot(,chr,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,sht,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,int,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,lng,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,flt,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,dbl,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,date,atom,TYPE_)@

@:JoinSelectOperationsSideways(int,chr,simple,)@
@:JoinSelectOperationsSideways(int,sht,simple,)@
@:JoinSelectOperationsSideways(int,int,simple,)@
@:JoinSelectOperationsSideways(int,lng,simple,)@
@:JoinSelectOperationsSideways(int,flt,simple,)@
@:JoinSelectOperationsSideways(int,dbl,simple,)@
@:JoinSelectOperationsSideways(int,date,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,chr,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,sht,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,int,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,lng,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,flt,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,dbl,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,date,atom,TYPE_)@

@:JoinSelectFunctionsSidewaysWithoutPivot(,chr,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,sht,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,int,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,lng,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,flt,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,dbl,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,date,atom,TYPE_)@

@:JoinSelectFunctionsSideways(int,chr,simple,)@
@:JoinSelectFunctionsSideways(int,sht,simple,)@
@:JoinSelectFunctionsSideways(int,int,simple,)@
@:JoinSelectFunctionsSideways(int,lng,simple,)@
@:JoinSelectFunctionsSideways(int,flt,simple,)@
@:JoinSelectFunctionsSideways(int,dbl,simple,)@
@:JoinSelectFunctionsSideways(int,date,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,chr,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,sht,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,int,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,lng,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,flt,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,dbl,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,date,atom,TYPE_)@

@= Project
crackers_export str CRKProjectCrack_@1(int *res, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKProjectCrack_@1_@2(int *res, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *c, *view;
	int m;
	lng cl1,cl2,ch1,ch2;

	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	selectMergeInsertionsPart_@1Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");

        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");
                
        GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
                
        GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	if (cl1 != 0) cl1++;

        view = BATslice(BATmirror(VIEWhead_(BATmirror(b), BAT_READ)), cl1, ch2+1);

        *res = view->batCacheid;
        BBPkeepref(*res);

        BBPunfix(b->batCacheid);
        BBPunfix(c->batCacheid);
        return MAL_SUCCEED;
}

crackers_export str CRKProjectH_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKProjectH_@1_@2(int *res, int *bid, int *pbid,int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *p, *r, *c, *pair;
        BUN pairh, pivott, rest, reslast;
        lng size, fsize;
        int bsize, psize, rsize;
        lng skip;
	int m;
	lng cl1,cl2,ch1,ch2;
	lng j;

	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	selectMergeInsertionsPart_@1Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

        if ((pair = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");

	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

        GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

	if (cl1 != 0) cl1++;

        b = BATslice(pair, cl1, ch2+1);
	
        if ((p = BATdescriptor(*pivot)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
        }

        size = BATcount(p);
 	r = BATnew(TYPE_void,b->htype,size);

        pairh  = BUNhloc(b, BUNfirst(b));
        pivott = BUNtloc(p, BUNfirst(p));
        rest   = BUNtloc(r, BUNfirst(r));
        bsize = BUNsize(b);
        psize = BUNsize(p);
        rsize = BUNsize(r);
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*(bit*)pivott == TRUE){
                        pairh += skip*bsize;
			*(@1*)rest = *(@1*)pairh; 
			rest += rsize;
                        skip = 0;
			fsize++;
                }
                pivott += psize;
                skip++;
        }

        reslast = BUNfirst(r) + rsize*fsize;
        r->batBuns->free =  reslast - r->batBuns->base;
        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);
        BBPunfix(pair->batCacheid);
        *res = r->batCacheid;

        return MAL_SUCCEED;
}

crackers_export str CRKProject_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKProject_@1_@2(int *res, int *bid, int *pbid,int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *p, *r, *c, *pair;
        BUN pairt, pivott, rest, reslast;
        lng size, fsize;
        int bsize, psize, rsize;
        lng skip;
	int m;
	lng cl1,cl2,ch1,ch2;
	lng j;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	/* Align the map based on the cracker tape of this set */
	selectMergeInsertionsPart_@1Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	/* Get the map */
        if ((pair = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.CRKProject", "Cannot access crack index");

	/* Get the result area on the map
           Note. We know that this search leads to an exact match sice a project call always 
           follows a select call with the same restriction in the same query. 
           Then this restriction is on the cracker tape. */
        GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

        GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

	if (cl1 != 0) cl1++;

        b = BATslice(pair, cl1, ch2+1);
	
        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

        size = BATcount(p);
 	r = BATnew(TYPE_void,b->ttype,size);

        pairt  = BUNtloc(b, BUNfirst(b));
        pivott = BUNtloc(p, BUNfirst(p));
        rest   = BUNtloc(r, BUNfirst(r));
        bsize = BUNsize(b);
        psize = BUNsize(p);
        rsize = BUNsize(r);
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*(bit*)pivott == TRUE){
                        pairt += skip*bsize;
			*(@2*)rest = *(@2*)pairt; 
			rest += rsize;
                        skip = 0;
			fsize++;
                }
                pivott += psize;
                skip++;
        }

        reslast = BUNfirst(r) + rsize*fsize;
        r->batBuns->free =  reslast - r->batBuns->base;
        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);
        BBPunfix(pair->batCacheid);

        return MAL_SUCCEED;
}

crackers_export str CRKdProject_@1_@2(int *res, int *bid, int *pbid, int *pivot);
str
CRKdProject_@1_@2(int *res, int *bid, int *pbid,int *pivot){
        BAT *b, *p, *r;
        BUN pairt, pivott, rest, reslast;
        lng size, fsize;
        int bsize, psize, rsize;
        lng skip;
	int m;
	lng j;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	/* Align the map based on the cracker tape of this set */
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	/* Get the map */
        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");
	
        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

        size = BATcount(p);
 	r = BATnew(TYPE_void,b->ttype,size);

        pairt  = BUNtloc(b, BUNfirst(b));
        pivott = BUNtloc(p, BUNfirst(p));
        rest   = BUNtloc(r, BUNfirst(r));
        bsize = BUNsize(b);
        psize = BUNsize(p);
        rsize = BUNsize(r);
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*(bit*)pivott == TRUE){
                        pairt += skip*bsize;
			*(@2*)rest = *(@2*)pairt; 
			rest += rsize;
                        skip = 0;
			fsize++;
                }
                pivott += psize;
                skip++;
        }

        reslast = BUNfirst(r) + rsize*fsize;
        r->batBuns->free =  reslast - r->batBuns->base;
        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}
@

@c
@:Project(int,chr)@
@:Project(int,sht)@
@:Project(int,int)@
@:Project(int,lng)@
@:Project(int,flt)@
@:Project(int,dbl)@
@:Project(int,date)@
@:Project(date,chr,atom,TYPE_)@
@:Project(date,sht,atom,TYPE_)@
@:Project(date,int,atom,TYPE_)@
@:Project(date,lng,atom,TYPE_)@
@:Project(date,flt,atom,TYPE_)@
@:Project(date,dbl,atom,TYPE_)@
@:Project(date,date,atom,TYPE_)@

/* END -------------------------------------Sideways cracking-----------------------------------------------------------------*/
