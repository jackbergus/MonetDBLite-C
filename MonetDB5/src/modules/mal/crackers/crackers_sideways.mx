@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f crackers_sideways
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2008
@* Sideways Cracking


@+ Interface


@- Type expansion

@= TypeSwitch_1
@:@1(,int,simple,,int,@2)@
@:@1(,lng,simple,,int,@2)@
@:@1(,dbl,simple,,dbl,@2)@
@:@1(,chr,simple,,dbl,@2)@
@:@1(,flt,simple,,dbl,@2)@
@:@1(,sht,simple,,dbl,@2)@
@:@1(,date,atom,TYPE_,loc,@2)@
@

@= TypeSwitch_2
@:@1(int,,simple,,int,@2)@
@:@1(dbl,,simple,,dbl,@2)@
@:@1(date,,atom,TYPE_,loc,@2)@
@

@= TypeSwitch_3
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,int,simple,,int,@2)@
@:@1(int,str,simple,,int,@2)@
@:@1(int,date,simple,,int,@2)@
@:@1(dbl,date,simple,,dbl,@2)@
@:@1(dbl,str,simple,,dbl,@2)@
@:@1(dbl,int,simple,,dbl,@2)@
@:@1(dbl,dbl,simple,,dbl,@2)@
@:@1(int,oid,simple,,int,@2)@

@:@1(date,int,atom,TYPE_,loc,@2)@
@:@1(date,str,atom,TYPE_,loc,@2)@
@:@1(date,lng,atom,TYPE_,loc,@2)@
@:@1(date,dbl,atom,TYPE_,loc,@2)@
@:@1(date,date,atom,TYPE_,loc,@2)@
@

@= TypeSwitch_4
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,int,simple,,,@2)@
@:@1(int,date,simple,,,@2)@
@:@1(dbl,date,simple,,,@2)@
@:@1(dbl,int,simple,,,@2)@
@:@1(dbl,dbl,simple,,,@2)@

@:@1(date,int,atom,TYPE_,,@2)@
@:@1(date,lng,atom,TYPE_,,@2)@
@:@1(date,dbl,atom,TYPE_,,@2)@
@:@1(date,date,atom,TYPE_,,@2)@
@

@- Header file
 
@h
#ifndef _CRACKERS_SIDEWAYS_H_
#define _CRACKERS_SIDEWAYS_H_


#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:SidewaysSharedFunctions_decl_0@
@:TypeSwitch_2(SidewaysSharedFunctions_decl_2)@
@:TypeSwitch_3(SidewaysSharedFunctions_decl_3)@
#endif

/* Exported signatures */
@:SidewaysFunctions_decl_0@
@:TypeSwitch_1(SidewaysFunctions_decl_1)@
@:TypeSwitch_3(SidewaysFunctions_decl_3)@

#endif /* _CRACKERS_SIDEWAYS_H */
@

@- Signatures shared within the crackers module/library

@= SidewaysSharedFunctions_decl_0
int existsCrackerIndexSideways(int bid, int pbid);
@

@= SidewaysSharedFunctions_decl_2
int CreateTape_@1(int bid);
str AddToTape_@1(int h, @1 low, @1 hgh, bit li, bit hi);
int newCrackerIndexSideways_@1(int bid, int cbid, int pbid, int cid);
@

@= SidewaysSharedFunctions_decl_3
str Sync_@1_@2(int m, int h);
str selectMergeInsertionsPart_@1_@2_Sideways( @1 *low, bit *inclusiveLow, @1 *hgh, bit *inclusiveHgh, int position);
@

@- Exported signatures
 
@= SidewaysFunctions_decl_0
crackers_export str CRKsizePendingInsertions(int *k, int *bid, int *pbid);
crackers_export str CRKextendCrackerMap(int *k, int *bid, int *pbid, lng *positions);
crackers_export str CRKprintPendingInsertions(int *k, int *bid, int  *pbid);
crackers_export str CRKinsert(int *k, int *bid, int *pbid, int *insertions);
crackers_export str DeleteCrackerMap(int *k, int *bid, int *pbid);
crackers_export str getCrackerMap(int *k, int *bid, int *pbid);
crackers_export str CRKgetTotalStorage(int *k);
crackers_export str CRKsetStorageThreshold(int *k, oid * threshold);
crackers_export str CRKaddReferenceFullMaps(int* res, int *bid, int *pbid);
crackers_export str CRKclearReferencesFullMaps(int* res);
crackers_export str CRKremoveFullMap(int* res);
@

@= SidewaysFunctions_decl_1
/* JoinSelectFunctionsSidewaysWithoutPivot */
crackers_export str CRKjoinSelectSideways_@2(int *res, int *cpair, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKjointhetaSelectSideways_@2(int *res, int *cpair, @2 *val, str *OP);
@

@= SidewaysFunctions_decl_3
/* SelectFunctionsSideways */
crackers_export str CRKcreateFullMap_@1_@2(int* res, int *bid, int *pbid);
crackers_export str CRKhselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKtselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKdselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2);
/* JoinSelectFunctionsSideways with pivot */
crackers_export str CRKjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKjointhetaSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *val2, str *OP2);
crackers_export str CRKdjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
/* Project */
crackers_export str CRKProjectCrack_@1_@2(int *res, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKMarkedProjectCrack_@1_@2(int *res, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKProjectH_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKProject_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKMarkedProject_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKPositionProject_@1_@2(int *res, int *bid, int *pbid, int *PositionPivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKdProject_@1_@2(int *res, int *bid, int *pbid, int *pivot);
crackers_export str CRKdProjectH_@1_@2(int *res, int *bid, int *pbid, int *pivot);
crackers_export str CRKdPositionProject_@1_@2(int *res, int *bid, int *pbid, int *pivot);
@

@{
@+ Implementation
 
@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:basicFunctions@
@:NewIndexSidewaysCracking_0@
@:TypeSwitch_2(NewIndexSidewaysCracking_2,)@
@:TypeSwitch_3(SyncOperation,)@
@:TypeSwitch_3(crackOperationsSideways,)@
@:TypeSwitch_1(JoinSelectOperationsSideways,WithoutPivot)@
@:TypeSwitch_3(JoinSelectOperationsSideways,)@

/* Functions shared within the crackers module/library */
@:TypeSwitch_2(TapeOperations,)@
@:TypeSwitch_3(updatesSideways,)@

/* Exported functions */
@:SidewaysFunctions_impl_0@
@:TypeSwitch_1(SidewaysFunctions_impl_1)@
@:TypeSwitch_3(SidewaysFunctions_impl_3)@
@

@- Exported functions

@= SidewaysFunctions_impl_0
str
CRKsizePendingInsertions(int *k, int *bid, int *pbid){
        BAT *u;
	int i;
	(void)k;

        i=existsCrackerIndexSideways(*bid,*pbid);
        if (i == -1)
                fprintf(stderr, " the crack index does not exist \n");
        if (CrackerIndex[i].iid > 0){
                u = BATdescriptor(CrackerIndex[i].iid);
		if (u == NULL)
                	throw(MAL, "crack insertions", "Failed to access pending insertions.");
                printf("\n pending insertions size: "BUNFMT" \n",BATcount(u));
                BBPunfix(u->batCacheid);
        }
        else
                printf("\n pending insertions size: 0 \n");

	 return MAL_SUCCEED;
}

str
CRKextendCrackerMap(int *k, int *bid, int *pbid, lng *positions){
        BAT *b;
        int position = existsCrackerIndexSideways(*bid,*pbid);
        (void) k;

        if (position == -1)
                throw(MAL, "crackers.CRKextendCrackermap", "Cannot find cracker index");
        if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "crackers.CRKextendCrackerMap", "Cannot access cracker Map");

	if ( (oid)*positions > BATcapacity(b) - BATcount(b) ){
		BUN ncap;
		BUN grows;
		oid needed = (oid)*positions - (BATcapacity(b) - BATcount(b));
                ncap = BATcapacity(b) + needed;
                grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                throw(MAL, "crackers.CRKextendCrackerMap", "Failed to extend the cracker Map");
        }

        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
CRKprintPendingInsertions(int *k, int *bid, int *pbid){
        int i = existsCrackerIndexSideways(*bid,*pbid);
	(void) k;

        if (i == -1)
		 throw(MAL, "crackers.CRKprintPendingInsertions", "Cannot find cracker map");

        if (CrackerIndex[i].iid > 0)
                BATprint(BATdescriptor(CrackerIndex[i].iid));

	return MAL_SUCCEED;
}

str
CRKinsert(int *k, int *bid, int *pbid, int *insertions){
        int position = existsCrackerIndexSideways(*bid,*pbid);
        (void) k;

        if (position == -1)
                throw(MAL, "crackers.CRKinsert", "Cannot find cracker map");

        appendInsertions(insertions,position);

        return MAL_SUCCEED;
}

str
DeleteCrackerMap(int *k, int *bid, int *pbid){
	int i;
	(void)k;
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == *bid && CrackerIndex[i].pbid == *pbid){
			CrackerIndex[i].bid  = -2;
			CrackerIndex[i].pbid = -2;
		}
	return MAL_SUCCEED;
}

str
getCrackerMap(int *k, int *bid, int *pbid){
        int i;
        (void)k;
        for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid && CrackerIndex[i].pbid == *pbid){
                        if (CrackerIndex[i].cbid > 0)
                                *k = CrackerIndex[i].cbid;
                        else
                                *k = -1;
                }
        return MAL_SUCCEED;
}

str
CRKgetTotalStorage(int *k){
        (void) k;

	printf("\n\nTotal Storage: "OIDFMT" tuples  \n\n", StorageInfo->totalTuples);

        return MAL_SUCCEED;
}

str
CRKsetStorageThreshold(int *k, oid *threshold){
        (void) k;

	if (StorageInfo == NULL){
        	StorageInfo = (struct storageManagement *)GDKmalloc(sizeof(struct storageManagement));
                StorageInfo->nextMapSet = NULL;
                StorageInfo->totalTuples = 0;
                StorageInfo->references  = NULL;
        }

	StorageInfo->threshold = *threshold;	
	StorageInfo->setThreshold = TRUE;

        return MAL_SUCCEED;
}
@


@= SidewaysFunctions_impl_1
/* JoinSelectFunctionsSidewaysWithoutPivot */
str                     
CRKjoinSelectSideways_@2(int *res, int *cpair, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh){               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingleSideways_RE_@2(res, cpair, hgh);
		else
                	return JoinSelectSingleSideways_RO_@2(res, cpair, hgh);
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingleSideways_LE_@2(res, cpair, low);
		else
                	return JoinSelectSingleSideways_LO_@2(res, cpair, low);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_LE_RE_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_LE_RO_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_LO_RO_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_LO_RE_@2(res, cpair, low, hgh);
	}
        throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
}

str
CRKjointhetaSelectSideways_@2(int *vid, int *bid, @2 *val, str *OP){
	ptr nilptr = ATOMnilptr(TYPE_@2); 
	char *op = *OP; 
	bit lin = TRUE, rin = TRUE;
	@2 *low = nilptr, *high = nilptr;

	if (op[0] == '=') {
		low = val; 
	} else if (op[0] == '<') {
		high = val;
		rin = (op[1] == '=');
	} else if (op[0] == '>') {
		low = val;
		lin = (op[1] == '=');
	} else {
		throw(MAL, "crackers.thetajoinselect", "unknown operator");
	}

	return CRKjoinSelectSideways_@2(vid, bid, low, high, &lin, &rin);
}

@

@= SidewaysFunctions_impl_3
/* SelectFunctionsSideways */

/* take the head of this map as a view */
str
CRKhselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
		return CRKRangeSidewaysLeftNull_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
		return CRKRangeSidewaysRightNull_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);
	else
		return CRKRangeSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);
}

/* take the tail as a view */
str
CRKtselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
		return CRKRangeSidewaysLeftNull_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
		return CRKRangeSidewaysRightNull_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);
	else
		return CRKRangeSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);
}

str
CRKdselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKdselectBoundsSideways_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKdselectBoundsSideways_@1_@2", "case not handled");
	else
		return CRKdRangeSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, low2, hgh2, inclusiveLow2, inclusiveHgh2);
}

/* JoinSelectFunctionsSideways */
str                     
CRKjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh){               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingleSideways_P_RE_@1_@2(res, bid, pbid, pivot, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
                	return JoinSelectSingleSideways_P_RO_@1_@2(res, bid, pbid, pivot, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingleSideways_P_LE_@1_@2(res, bid, pbid, pivot, low, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
                	return JoinSelectSingleSideways_P_LO_@1_@2(res, bid, pbid, pivot, low, low1, hgh1, inclusiveLow1, inclusiveHgh1);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_P_LE_RE_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_P_LE_RO_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_P_LO_RO_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_P_LO_RE_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
	}
        throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
}

str
CRKjointhetaSelectSideways_P_@1_@2(int *vid, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *val, str *OP){
	ptr nilptr = ATOMnilptr(TYPE_@2); 
	char *op = *OP; 
	bit lin = TRUE, rin = TRUE;
	@2 *low = nilptr, *high = nilptr;

	if (op[0] == '=') {
		low = val; 
	} else if (op[0] == '<') {
		high = val;
		rin = (op[1] == '=');
	} else if (op[0] == '>') {
		low = val;
		lin = (op[1] == '=');
	} else {
		throw(MAL, "crackers.thetajoinselect", "unknown operator");
	}

	return CRKjoinSelectSideways_P_@1_@2(vid, bid, pbid, pivot, low1, hgh1, inclusiveLow1, inclusiveHgh1, low, high, &lin, &rin);
}

str                     
CRKdjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh){               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
        		throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
		else
        		throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
        		throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
		else
        		throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return dJoinSelectRangeSideways_P_LE_RE_@1_@2(res, bid, pbid, pivot, low, hgh);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return dJoinSelectRangeSideways_P_LE_RO_@1_@2(res, bid, pbid, pivot, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return dJoinSelectRangeSideways_P_LO_RO_@1_@2(res, bid, pbid, pivot, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==TRUE))
                	return dJoinSelectRangeSideways_P_LO_RE_@1_@2(res, bid, pbid, pivot, low, hgh);
	}
        throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
}

/* Project */
str
CRKProjectCrack_@1_@2(int *res, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *c, *view, *vhead, *vslice;
	int m;
	oid cl1,cl2,ch1,ch2;
	bit newMap = FALSE;
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		newMap = TRUE;
	}else{
        	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                	throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");

	        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	        throw(MAL, "crackers.crackRange", "Cannot access crack index");
                
        	CrackerIndex[m].accesses += 1;
	}
	selectMergeInsertionsPart_@1_@2_Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));
		
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1)) 
		cl1=0;
	else
        	GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1);
                
	if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1)) 
		ch2=BATcount(b)-1;
	else
        	GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);

	if (cl1 != 0) cl1++;

	vhead = VIEWhead_(BATmirror(b), BAT_READ);
        vslice = BATslice(BATmirror(vhead), cl1, ch2+1);
	view = BATmirror(BATmark(BATmirror(vslice),cl1));

	view->hsorted = TRUE;
	view->tsorted = FALSE;
	view->hdense = TRUE;
	view->tdense = FALSE;
        *res = view->batCacheid;
        BBPkeepref(*res);

	BBPunfix(vhead->batCacheid);
	BBPunfix(vslice->batCacheid);
	if (newMap){
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);
        }else{
                BBPunfix(b->batCacheid);
                BBPunfix(c->batCacheid);
        }
	

        return MAL_SUCCEED;
}

str
CRKPositionProject_@1_@2(int *res, int *bid, int *pbid,int *PositionPivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *p, *r, *c;
        @2 *pairt, *rest;
	oid *pivott, *resh;
        oid size;
	int m;
	oid cl1=0,cl2=0,ch1=0,ch2=0;
	oid j;
	bit newMap = TRUE;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		newMap = TRUE;
	}else{	
		/* Get the map */
        	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                	throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	        throw(MAL, "crackers.CRKProject", "Cannot access crack index");
        	CrackerIndex[m].accesses += 1;
	}

	/* Align the map based on the cracker tape of this set */
	selectMergeInsertionsPart_@1_@2_Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));


	/* Get the result area on the map
           Note. We know that this search leads to an exact match sice a project call always 
           follows a select call with the same restriction in the same query. 
           Then this restriction is on the cracker tape. */

	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1)) 
		cl1=0;
	else
        	GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1);
                
	if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1)) 
		ch2=BATcount(b)-1;
	else
        	GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);
	if (cl1 != 0) cl1++;

	
        if ((p = BATdescriptor(*PositionPivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

        size = BATcount(p);
 	r = BATnew(TYPE_oid,b->ttype,size);

        /*slice = BATslice(b, cl1, ch2+1);*/

        pairt  = (@2 *)Tloc(b, BUNfirst(b));
        pivott = (oid*)Tloc(p, BUNfirst(p));
        rest   = (@2 *)Tloc(r, BUNfirst(r));
        resh   = (oid *)Hloc(r, BUNfirst(r));

	if (p->ttype==TYPE_void){
		printf("\n void tail in positions \n");
		for (j = 0; j<size; j++){
			*rest = *(pairt + j); 
			rest ++;
			pivott ++;
		}
	}else{
		for (j = 0; j<size; j++){
			*rest = *(pairt + *pivott); 
			rest ++;
			pivott ++;
		}
        	pivott = (oid*)Tloc(p, BUNfirst(p));
		for (j = 0; j<size; j++){
			*resh = *pivott; 
			pivott ++;
			resh++;
		}
	}

        BATsetcount(r, size);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);

        BBPunfix(p->batCacheid);
	
	if (newMap){
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);
        }else{
                BBPunfix(b->batCacheid);
                BBPunfix(c->batCacheid);
        }


        return MAL_SUCCEED;
}

str
CRKProject_@1_@2(int *res, int *bid, int *pbid,int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *p, *r, *c, *slice;
        @2 *pairt, *rest;
	bit *pivott;
        oid size, fsize;
        oid skip;
	int m;
	oid cl1=0,cl2=0,ch1=0,ch2=0;
	oid j;
	bit newMap = TRUE;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		newMap = TRUE;
	}else{	
		/* Get the map */
        	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                	throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	        throw(MAL, "crackers.CRKProject", "Cannot access crack index");
        	CrackerIndex[m].accesses += 1;
	}

	/* Align the map based on the cracker tape of this set */
	selectMergeInsertionsPart_@1_@2_Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));


	/* Get the result area on the map
           Note. We know that this search leads to an exact match sice a project call always 
           follows a select call with the same restriction in the same query. 
           Then this restriction is on the cracker tape. */
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1)) 
		cl1=0;
	else
        	GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1);
                
	if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1)) 
		ch2=BATcount(b)-1;
	else
        	GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);

	if (cl1 != 0) cl1++;

        slice = BATslice(b, cl1, ch2+1);
	
        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

        size = BATcount(p);
 	r = BATnew(TYPE_void,slice->ttype,size);

        pairt  = (@2 *)Tloc(slice, BUNfirst(slice));
        pivott = (bit*)Tloc(p, BUNfirst(p));
        rest   = (@2 *)Tloc(r, BUNfirst(r));
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*pivott == TRUE){
                        pairt += skip;
			*rest = *pairt; 
			rest ++;
                        skip = 0;
			fsize++;
                }
                pivott ++;
                skip++;
        }

        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);

        BBPunfix(p->batCacheid);
        BBPunfix(slice->batCacheid);
	
	if (newMap){
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);
        }else{
                BBPunfix(b->batCacheid);
                BBPunfix(c->batCacheid);
        }


        return MAL_SUCCEED;
}

str
CRKProjectH_@1_@2(int *res, int *bid, int *pbid,int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *p, *r, *c, *slice;
        @1 *pairt, *rest;
	bit *pivott;
        oid size, fsize;
        oid skip;
	int m;
	oid cl1=0,cl2=0,ch1=0,ch2=0;
	oid j;
	bit newMap = TRUE;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		newMap = TRUE;
	}else{	
		/* Get the map */
        	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                	throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	        throw(MAL, "crackers.CRKProject", "Cannot access crack index");
        	CrackerIndex[m].accesses += 1;
	}

	/* Align the map based on the cracker tape of this set */
	selectMergeInsertionsPart_@1_@2_Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));


	/* Get the result area on the map
           Note. We know that this search leads to an exact match sice a project call always 
           follows a select call with the same restriction in the same query. 
           Then this restriction is on the cracker tape. */
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1)) 
		cl1=0;
	else
        	GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1);
                
	if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1)) 
		ch2=BATcount(b)-1;
	else
        	GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);

	if (cl1 != 0) cl1++;

        slice = BATslice(b, cl1, ch2+1);
	
        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

        size = BATcount(p);
 	r = BATnew(TYPE_void,slice->htype,size);

        pairt  = (@1 *)Hloc(slice, BUNfirst(slice));
        pivott = (bit*)Tloc(p, BUNfirst(p));
        rest   = (@1 *)Tloc(r, BUNfirst(r));
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*pivott == TRUE){
                        pairt += skip;
			*rest = *pairt; 
			rest ++;
                        skip = 0;
			fsize++;
                }
                pivott ++;
                skip++;
        }

        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);

        BBPunfix(p->batCacheid);
        BBPunfix(slice->batCacheid);
	
	if (newMap){
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);
        }else{
                BBPunfix(b->batCacheid);
                BBPunfix(c->batCacheid);
        }


        return MAL_SUCCEED;
}

str
CRKMarkedProject_@1_@2(int *res, int *bid, int *pbid,int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *p, *r, *c, *slice;
        @2 *pairt, *rest;
	oid *resh;
	bit *pivott;
        oid size, fsize;
        oid skip;
	int m;
	oid cl1=0,cl2=0,ch1=0,ch2=0;
	oid j;
	bit newMap = TRUE;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		newMap = TRUE;
	}else{	
		/* Get the map */
        	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                	throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	        throw(MAL, "crackers.CRKProject", "Cannot access crack index");
        	CrackerIndex[m].accesses += 1;
	}

	/* Align the map based on the cracker tape of this set */
	selectMergeInsertionsPart_@1_@2_Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));


	/* Get the result area on the map
           Note. We know that this search leads to an exact match sice a project call always 
           follows a select call with the same restriction in the same query. 
           Then this restriction is on the cracker tape. */
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1)) 
		cl1=0;
	else
        	GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1);
                
	if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1)) 
		ch2=BATcount(b)-1;
	else
        	GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);
	if (cl1 != 0) cl1++;

        slice = BATslice(b, cl1, ch2+1);
	
        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

	/*If all is true then we can simply return a slice*/
	if (p->tdense==TRUE){		
		BAT *view=BATmirror(BATmark(BATmirror(slice),cl1));
        	*res = view->batCacheid;
        	BBPkeepref(view->batCacheid);
		BBPunfix(p->batCacheid);
		BBPunfix(slice->batCacheid);
		if (newMap){
			BBPkeepref(b->batCacheid);
			BBPkeepref(c->batCacheid);
		}else{
			BBPunfix(b->batCacheid);
			BBPunfix(c->batCacheid);
		}
        	return MAL_SUCCEED;
	}

        size = BATcount(p);
 	r = BATnew(TYPE_oid,slice->ttype,size);

        pairt  = (@2 *)Tloc(slice, BUNfirst(slice));
        pivott = (bit*)Tloc(p, BUNfirst(p));
        rest   = (@2 *)Tloc(r, BUNfirst(r));
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*pivott == TRUE){
                        pairt += skip;
			*rest = *pairt; 
			rest ++;
                        skip = 0;
			fsize++;
                }
                pivott ++;
                skip++;
        }

	/*now pass over the head to mark the proper positions*/
        pivott = (bit*)Tloc(p, BUNfirst(p));
        resh   = (oid *)Hloc(r, BUNfirst(r));
        skip = 0;
        for (j = 0; j<size; j++){
                if (*pivott == TRUE){
			*resh = j; 
			resh ++;
                        skip = 0;
                }
                pivott ++;
                skip++;
        }


        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);

        BBPunfix(p->batCacheid);
        BBPunfix(slice->batCacheid);
	
	if (newMap){
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);
        }else{
                BBPunfix(b->batCacheid);
                BBPunfix(c->batCacheid);
        }


        return MAL_SUCCEED;
}

str
CRKdProject_@1_@2(int *res, int *bid, int *pbid,int *pivot){
        BAT *b, *p, *r, *c;
        @2 *pairt, *rest;
	bit *pivott;
        oid size, fsize;
        oid skip;
	int m;
	oid j;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPkeepref(b->batCacheid);
		BBPkeepref(c->batCacheid);
	}	

	/* Align the map based on the cracker tape of this set */
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	/* Get the map */
        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");
	
        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");


        size = BATcount(p);
 	r = BATnew(TYPE_void,b->ttype,size);

        pairt  = (@2 *)Tloc(b, BUNfirst(b));
        pivott = (bit*)Tloc(p, BUNfirst(p));
        rest   = (@2 *)Tloc(r, BUNfirst(r));
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*pivott == TRUE){
                        pairt += skip;
			*rest = *pairt; 
			rest ++;
                        skip = 0;
			fsize++;
                }
                pivott ++;
                skip++;
        }

        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
CRKdProjectH_@1_@2(int *res, int *bid, int *pbid,int *pivot){
        BAT *b, *p, *r, *c;
        @1 *pairt, *rest;
	bit *pivott;
        oid size, fsize;
        oid skip;
	int m;
	oid j;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPkeepref(b->batCacheid);
		BBPkeepref(c->batCacheid);
	}	

	/* Align the map based on the cracker tape of this set */
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	/* Get the map */
        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");
	
        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");


        size = BATcount(p);
 	r = BATnew(TYPE_void,b->htype,size);

        pairt  = (@1 *)Hloc(b, BUNfirst(b));
        pivott = (bit*)Tloc(p, BUNfirst(p));
        rest   = (@1 *)Tloc(r, BUNfirst(r));
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*pivott == TRUE){
                        pairt += skip;
			*rest = *pairt; 
			rest ++;
                        skip = 0;
			fsize++;
                }
                pivott ++;
                skip++;
        }

        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}


str
CRKdPositionProject_@1_@2(int *res, int *bid, int *pbid,int *pivot){
        BAT *b, *p, *r, *c;
        @2 *pairt, *rest;
	oid *pivott;
        oid size;
	int m;
	oid j;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPkeepref(b->batCacheid);
		BBPkeepref(c->batCacheid);
	}	

	/* Align the map based on the cracker tape of this set */
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	/* Get the map */
        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");
	
        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

        size = BATcount(p);
 	r = BATnew(TYPE_void,b->ttype,size);

        pairt  = (@2 *)Tloc(b, BUNfirst(b));
        pivott = (oid*)Tloc(p, BUNfirst(p));
        rest   = (@2 *)Tloc(r, BUNfirst(r));

	for (j = 0; j<size; j++){
		*rest = *(pairt + *pivott); 
		rest ++;
		pivott ++;
	}

	BATmark(BATmirror(p),0);

        BATsetcount(r, size);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}
@

@- Local support functions and macros

@= JoinSelectOperationsSideways
@:JoinSelectRSideways@6(@1,@2,LO,RE,GT,LE,@3,@4)@
@:JoinSelectRSideways@6(@1,@2,LE,RE,GE,LE,@3,@4)@
@:JoinSelectRSideways@6(@1,@2,LO,RO,GT,LT,@3,@4)@
@:JoinSelectRSideways@6(@1,@2,LE,RO,GE,LT,@3,@4)@
@:JoinSelectSideways@6(@1,@2,RO,LT,@3,@4)@
@:JoinSelectSideways@6(@1,@2,RE,LE,@3,@4)@
@:JoinSelectSideways@6(@1,@2,LO,GT,@3,@4)@
@:JoinSelectSideways@6(@1,@2,LE,GE,@3,@4)@
@

@= basicFunctions
int
existsCrackerIndexSideways(int bid, int pbid){
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == bid && CrackerIndex[i].pbid == pbid)
			return i;
	return -1;
}

str
CRKremoveFullMap(int* res){
	BBPdecref(CrackerIndex[0].cbid, TRUE);
	BBPdecref(CrackerIndex[0].cid, TRUE);
	CrackerIndex[0].bid = -1;
	CrackerIndex[0].pbid =-1;
	(void)res;
	return MAL_SUCCEED;
}

str
CRKaddReferenceFullMaps(int* res, int *bid, int *pbid){
	
	struct referencesNodeFM *newNode, *cur;
	(void)res;

        newNode = (struct referencesNodeFM*) GDKmalloc(sizeof(struct referencesNodeFM));
        newNode->batId = *bid;
        newNode->tailBatId = *pbid;
        newNode->next = NULL;

        if (StorageInfo == NULL){
	        StorageInfo = (struct storageManagement *)GDKmalloc(sizeof(struct storageManagement));
                StorageInfo->nextMapSet  = NULL;
                StorageInfo->totalTuples = 0;
                StorageInfo->threshold   = 0;
                StorageInfo->setThreshold   = FALSE;
                StorageInfo->references  = NULL;
	}

        if (StorageInfo->references == NULL){
                StorageInfo->references = newNode;
        }else{
                cur = StorageInfo->references;
                while (cur->next != NULL){
                        cur = cur->next;
                }
                cur->next = newNode;
        }

	return MAL_SUCCEED;
}

str
CRKclearReferencesFullMaps(int* res){
	struct referencesNodeFM *cur,*nodeToFree;
	(void)res;

	if (StorageInfo != NULL){
		if (StorageInfo->references == NULL)
			return MAL_SUCCEED;	
		cur = StorageInfo->references;
		while (cur->next != NULL){
			nodeToFree = cur;
			cur = cur->next;
			GDKfree(nodeToFree);
		}
		GDKfree(cur);
		StorageInfo->references = NULL;
	}

	return MAL_SUCCEED;
}

bit
isThisFullMapUsedInTheCurrentQuery(int batId, int tailBatId){
	struct referencesNodeFM *cur;
	if (StorageInfo == NULL)
		return FALSE;

	if (StorageInfo->references == NULL)
		return FALSE;
	cur = StorageInfo->references;
	while (cur != NULL){
		if (cur->batId == batId && cur->tailBatId == tailBatId)
			return TRUE;
		cur = cur->next;
	}
	
	return FALSE;
}
	
int 
getLeastUsedMap(){
	int i;
	lng accesses = 0;
	int res = -1;
        for (i = 0; i < maxCrackMap; i++){
		if (CrackerIndex[i].bid == -1 || CrackerIndex[i].pbid == -1)
			continue;
                if (!(isThisFullMapUsedInTheCurrentQuery(CrackerIndex[i].bid,CrackerIndex[i].pbid))){
                        
			if (res == -1){
				accesses = CrackerIndex[i].accesses;
				res = i;
			}else
			if ( (CrackerIndex[i].accesses < accesses) || 
			     (CrackerIndex[i].accesses == accesses && 
					CrackerIndex[i].creationTimestamp < CrackerIndex[res].creationTimestamp) ){
				accesses = CrackerIndex[i].accesses;
				res = i;
			}

		}
	}
	return res;
}	

str removeFullMap(int MapToDropIndex){
	int i, TapeIndex = -1;
	bit moreMaps = FALSE;
	BAT *cbat,*cindex;

	/* remove the BATs holding the map and the cracker index */
	if ((cbat = BATdescriptor(CrackerIndex[MapToDropIndex].cbid)) == NULL)
                throw(MAL, "crackers.sync", "Cannot access descriptor");
	if ((cindex = BATdescriptor(CrackerIndex[MapToDropIndex].cid)) == NULL)
                throw(MAL, "crackers.sync", "Cannot access descriptor");
	BATmode(cbat, TRANSIENT);
	BATmode(cindex, TRANSIENT);	
	BBPunfix( cbat->batCacheid);
	BBPunfix( cindex->batCacheid);
	
	BBPdecref(CrackerIndex[MapToDropIndex].cbid, TRUE);
	BBPdecref(CrackerIndex[MapToDropIndex].cid, TRUE);

	/* todo free avl tree */
	FreeAVLTree(CrackerIndex[MapToDropIndex].Tree);
	CrackerIndex[MapToDropIndex].Tree = NULL;

	/* If there is no map left in this map set, then we also remove the tape */
	for(i=0; i < maxCrackMap; i++){
		if (i == MapToDropIndex) 
			continue;
		if (CrackerIndex[i].bid == CrackerIndex[MapToDropIndex].bid){
			if (CrackerIndex[i].pbid == -1 )
				TapeIndex = i;
			else
				moreMaps = TRUE;
		}
	}

	CrackerIndex[MapToDropIndex].bid  = -1;
	CrackerIndex[MapToDropIndex].pbid = -1;

	if (moreMaps == FALSE){
		BBPdecref(CrackerIndex[TapeIndex].chid, TRUE);
		BBPdecref(CrackerIndex[TapeIndex].hiid, TRUE);

		CrackerIndex[TapeIndex].bid  = -1;
		CrackerIndex[TapeIndex].chid = -1;
		CrackerIndex[TapeIndex].hiid = -1;
	}

	StorageInfo->totalTuples -= CrackerIndex[MapToDropIndex].tuples;
	return MAL_SUCCEED;
}


static int
heapcopy(Heap *dst, Heap *src, int *remap)
{
        if (*remap && src->storage == STORE_MMAP) {
                /* use copy-on-write mmap for isolatable copy */
                *dst = *src;
                dst->base = (char *) -1;
                dst->filename = GDKstrdup(src->filename);
                if (dst->filename) {
                        char path[PATHLENGTH];

                        GDKfilepath(path, BATDIR, dst->filename, NULL);
                        dst->base = GDKmmap(path, MMAP_READ | MMAP_SEQUENTIAL | MMAP_COPY, 0, dst->maxsize);
                        if (dst->base != (char *) -1) {
                                dst->copied = 1;
                                dst->storage = STORE_PRIV;
                                return 0;
                        }
                        GDKfree(dst->filename);
                        dst->filename = NULL;
                }
        }
        *remap = 0;
        return HEAPcopy(dst, src);
}

static void
heapfree(Heap *src, Heap *dst)
{
        if (dst->filename == NULL) {
                dst->filename = src->filename;
                src->filename = NULL;
        }
        HEAPfree(src);
        *src = *dst;
}


@


@= NewIndexSidewaysCracking_0
int
newCrackerIndexHistorySideways(int bid, int chid, int hiid){
        int i, j, freemap = -1, units = 100;

        for (i = 0; i < maxCrackMap; i++){
                if (CrackerIndex[i].bid == -1){
                        freemap = i;
			break;
		}
	}
	if (freemap == -1){ 
		if (i == maxCrackMap) {
			CrackerIndexNode *x;

			if (maxCrackMap > 0)
				units = (int) (1.2 * maxCrackMap);
			x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
			memset(x, 0, sizeof(CrackerIndexNode) * units);
			if (CrackerIndex) {
				fprintf(stderr, "reallocate index \n");
				memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
				GDKfree(CrackerIndex);
			}
			CrackerIndex = x;
		
			/* mark the new slots as empty */
			for(j=maxCrackMap; j<units;j++){
				CrackerIndex[j].bid = -1;
			}
			maxCrackMap = units;
		}
	}

        CrackerIndex[i].chid = chid;
        CrackerIndex[i].hiid = hiid;
        CrackerIndex[i].pbid = -1;
        CrackerIndex[i].bid = bid;
        CrackerIndex[i].cbid = -1;
        CrackerIndex[i].cid = -1;
        CrackerIndex[i].iid = -1;
        CrackerIndex[i].did = -1;
        CrackerIndex[i].mergeInsertions = -1;
        CrackerIndex[i].reCreate = 0;
        CrackerIndex[i].Tree = NULL;
        CrackerIndex[i].deleteNodes = FALSE;
        CrackerIndex[i].mergeDeletions = -1;
        return i;
}
@

@= NewIndexSidewaysCracking_2
int
newCrackerIndexSideways_@1(int bid, int cbid, int pbid, int cid){
	int i, j, freemap = -1, units = 100;
	
	for (i = 0; i < maxCrackMap; i++){
		if (CrackerIndex[i].bid == -1){
			freemap = i;
			break;
		}
	}

	if (freemap == -1){ 
		if (i == maxCrackMap) {
			CrackerIndexNode *x;

			if (maxCrackMap > 0)
				units = (int) (1.2 * maxCrackMap);
			x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
			memset(x, 0, sizeof(CrackerIndexNode) * units);
			if (CrackerIndex) {
				fprintf(stderr, "reallocate index \n");
				memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
				GDKfree(CrackerIndex);
			}
			CrackerIndex = x;
		
			/* mark the new slots as empty */
			for(j=maxCrackMap; j<units;j++){
				CrackerIndex[j].bid = -1;
			}
			maxCrackMap = units;
		}
	}

	CrackerIndex[i].nextCrack = 0;
	CrackerIndex[i].chid = -1;
	CrackerIndex[i].hiid = -1;
	CrackerIndex[i].pbid = pbid;  /* this line is the only addittion compared to the non projections function */
	CrackerIndex[i].bid = bid;
	CrackerIndex[i].cbid = cbid;
	CrackerIndex[i].cid = cid;
	CrackerIndex[i].iid = -1;
	CrackerIndex[i].did = -1;
	CrackerIndex[i].mergeInsertions = -1;
	CrackerIndex[i].reCreate = 0;
	CrackerIndex[i].Tree = NULL;
	CrackerIndex[i].references = NULL;
	CrackerIndex[i].deleteNodes = FALSE;
	CrackerIndex[i].mergeDeletions = -1;
	return i;
}
@

@= crkTwoRTreeSideways
        /*CRACK in two pieces cl2-ch2 using <incHgh bound*/
        if (*inclusiveHgh == TRUE)
                CRKcrackUnorderedZeroSideways_LE_@1_@2(b,*hgh, cl2, ch2,&vh);
        else
                CRKcrackUnorderedZeroSideways_RE_@1_@2(b,*hgh, cl2, ch2,&vh);

        /*check for gaps*/
        if (vh < cl2)
                /*then the left piece is empty*/
                gapH = -1;
        if (vh >= ch2){
                /*then the right piece is empty*/
                gapH = -1;
                vh--;
        }
@

@= crkTwoLTreeSideways
        /*CRACK in two pieces cl1-ch1 using >incLow bound*/
        if (*inclusiveLow == TRUE)
                CRKcrackUnorderedZeroSideways_RE_@1_@2(b,*low, cl1, ch1,&vl);
        else
                CRKcrackUnorderedZeroSideways_LE_@1_@2(b,*low, cl1, ch1,&vl);
        if (vl < cl1){
                /*then the left piece is empty*/
                gapL = -1;
        }
        if (vl > ch1){
                /*then the right piece is empty*/
                vl--;
                gapL = -1;
        }
        vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
                Instead we want the first bun of the right piece*/
@

@= crkThreeTreeSideways
        if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeSideways_LE_RE_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeSideways_LE_RO_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeSideways_LO_RE_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeSideways_LO_RO_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (vl != (oid)-1 && vh != (oid)-1 && vl <= vh){
		CrackerIndex[m].pieces++; /* add one more piece since we are making 
						at least 2 new pieces */
                if (vl>0) _vl=vl-1; else _vl=vl;
                addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
                if (vh<@4) addCrackerIndex_@1(m,hgh,HBound,vh,c);
        }
@

@= printMacro

/* @1: the type; e.g., chr bte sht int oid wrd flt dbl lng str */
{
        str MyBuf = NULL;
        int MyBufLen = 0;
        (void)(*BATatoms[TYPE_@1].atomToStr) (&MyBuf, &MyBufLen, (ptr)(&@3));
        printf("\n @2 %s \n", MyBuf);
        GDKfree(MyBuf);
}
@


@= SyncOperation
str
Sync_@1_@2(int m, int h){
	BAT *h1,*h2,*b, *c;
	@1  *h1head, *h1tail;
	bit *h2head, *h2tail;
	oid syncs;
	oid size;

        oid vl=0, vh=0;
        oid cl1=0, ch1=0, cl2=0, ch2=0;
        oid _vl;
        bit HBound, foundLow=0, foundHgh=0;
        int gapL = 1;
        int gapH = 1;
	bit *inclusiveHgh,*inclusiveLow;
	@1 *low, *hgh;
	oid j;
	bit crkTwoL, crkTwoR;

        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

	 /* Take the index of the bat */
        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");


        if ((h1 = BATdescriptor(CrackerIndex[h].chid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");

        if ((h2 = BATdescriptor(CrackerIndex[h].hiid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");

	/* check if the current pair is already synced */	
	size = BATcount(h1);
	if (CrackerIndex[m].nextCrack == size)
		goto done;

	syncs = size - CrackerIndex[m].nextCrack;

	h1head = (@1 *)Hloc(h1, BUNfirst(h1)+CrackerIndex[m].nextCrack);
	h1tail = (@1 *)Tloc(h1, BUNfirst(h1)+CrackerIndex[m].nextCrack);
	h2head = (bit*)Hloc(h2, BUNfirst(h2)+CrackerIndex[m].nextCrack);
	h2tail = (bit*)Tloc(h2, BUNfirst(h2)+CrackerIndex[m].nextCrack);

	/* These values are used when cursor is 0 */
	cl1 = BUNfirst(b);
	ch1 = BUNlast(b)-1;
	cl2 = BUNfirst(b);
	ch2 = BUNlast(b)-1;

	for (j=0; j<syncs; j++){
		low = h1head; 
		hgh = h1tail; 
		inclusiveLow = h2head; 
		inclusiveHgh = h2tail; 
		crkTwoL = crkTwoR = FALSE;
		if (*inclusiveHgh == TRUE) HBound = FALSE;
		else HBound = TRUE;

		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
       		 	/* find out where in the index the low and hgh fall */
			if (CrackerIndex[m].nextCrack != 0){
				foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1);
				foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);
			
				if (cl1 != 0) cl1++;
				if (cl2 != 0) cl2++;
       			} 
       			 /* If one or both of the result view bounds were not found using the
        		index then we have to crack */
                	if (foundLow == 0 && foundHgh == 0){                         
				/* If ch2 is right after cl1 in the index then we split this piece in three pieces*/   
                        	if (cl1 == cl2){
                               		@:crkThreeTreeSideways(@1,@2,cl1,ch2)@
                        	} else {
                               		/* Else we have to do two cracks separatelly */
                               
                               		/* For the cl bound and the next one in the index*/
                               		crkTwoL=TRUE;
                               
                               		/* For the ch bound and the previous one in the index*/
                               		crkTwoR=TRUE;
                        	}
                	} else
                	if (foundLow == 0)
                               	crkTwoL=TRUE;
                	else
                	if (foundHgh == 0)
                               	crkTwoR=TRUE;
		}
	
	 	if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && ((@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
                        /* find out where in the index the low   falls */
			if (CrackerIndex[m].nextCrack != 0){
                       		foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1);      
                        	if (cl1 != 0) cl1++;
			}
                        if (foundLow == 0)
                               	crkTwoL=TRUE;
                }
                if ( ((@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
                        /* find out where in the index the high falls */
			if (CrackerIndex[m].nextCrack != 0){
                        	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);
                        	if (cl2 != 0) cl2++;
			}
                        if (foundHgh == 0)
                               	crkTwoR=TRUE;
                }

		if (crkTwoR){
			@:crkTwoRTreeSideways(@1,@2)@
			if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
			
		}
		if (crkTwoL){
			@:crkTwoLTreeSideways(@1,@2)@
			if (vl>0) _vl=vl-1; else _vl=vl;
			if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
		}		
		h1head ++;
		h1tail ++;
		h2head ++;
		h2tail ++;
		CrackerIndex[m].nextCrack++;
	}		
	
	CrackerIndex[m].nextCrack = size;

	done:;
	BBPunfix(h1->batCacheid);
	BBPunfix(h2->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(c->batCacheid);
	return MAL_SUCCEED;
}

str
CRKcreateFullMap_@1_@2(int* res, int *bid, int *pbid){
        BAT *b, *c;
        int m=-1;
        @:CreateCrackerMap(@1,@2)@
        StorageInfo->temp = b->batCacheid;
        BBPkeepref( b->batCacheid);
        BBPkeepref( c->batCacheid);
        (void)res;
        return MAL_SUCCEED;
}
@

@= TapeOperations
int
CreateTape_@1(int bid){
	BAT *h1,*h2;
	oid tape_size= IndexEntries;

	h1 = BATnew(TYPE_@1,TYPE_@1,tape_size);		
	h2 = BATnew(TYPE_bit,TYPE_bit,tape_size);		

        BATsetcount(h1, 0);
        BATsetcount(h2, 0);

	BBPkeepref(h1->batCacheid);
	BBPkeepref(h2->batCacheid);

	return newCrackerIndexHistorySideways(bid, h1->batCacheid, h2->batCacheid);				
}

str
AddToTape_@1(int h, @1 low, @1 hgh, bit li, bit hi){
	BAT *h1,*h2,*h1new,*h2new;

	if ((h1 = BATdescriptor(CrackerIndex[h].chid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");
                                                
        if ((h2 = BATdescriptor(CrackerIndex[h].hiid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");
                                                
	h1new = BATnew(TYPE_@1,TYPE_@1,1); 
        *(@1*)Hloc(h1new, BUNfirst(h1new)) = low;
        *(@1*)Tloc(h1new, BUNfirst(h1new)) = hgh;
	BATsetcount(h1new, 1);

	h2new = BATnew(TYPE_bit,TYPE_bit,1); 
        *(bit*)Hloc(h2new, BUNfirst(h2new)) = li;
        *(bit*)Tloc(h2new, BUNfirst(h2new)) = hi;
	BATsetcount(h2new, 1);

	BATins(h1,h1new,TRUE);
	BATins(h2,h2new,TRUE);
	
	BBPunfix(h1->batCacheid);
        BBPunfix(h2->batCacheid);
	BBPunfix(h1new->batCacheid);
        BBPunfix(h2new->batCacheid);
        return MAL_SUCCEED;
}
@


@= CreateResultSideways
createView:
	if (tail){
		BAT *vslice;
		viewHead = VIEWhead_(BATmirror(b), BAT_READ);
                vslice = BATslice(BATmirror(viewHead), vl, vh+1);
		view=BATmirror(BATmark(BATmirror(vslice),vl));
		BBPunfix(vslice->batCacheid);
	}
	else {
		BAT *vslice;
		viewHead = VIEWhead_(b, BAT_READ);
                vslice = BATslice(BATmirror(viewHead), vl, vh+1);
		view=BATmirror(BATmark(BATmirror(vslice),vl));
		BBPunfix(vslice->batCacheid);
	}

	if (newCrackerMAP){
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);
	}
	else{
	        BBPunfix(b->batCacheid);
        	BBPunfix(c->batCacheid);
	}

	view->hsorted = TRUE;
	view->tsorted = FALSE;
	view->hdense = TRUE;
	view->tdense = FALSE;
	BBPunfix(viewHead->batCacheid);

        *vid = view->batCacheid;
        BBPkeepref(*vid);
@

@= CreateCrackerMap
		BAT *bo, *bp;
                oid sizeM;
                @2 *ptail, *ntail;
		@1 *nhead, *ctail;
		oid j;

                if ((bo = BATdescriptor(*bid)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access descriptor of map head BAT");
                if ((bp = BATdescriptor(*pbid)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access pdescriptor of map tail BAT");

                sizeM = BATcount(bo);
		b = BATnew(bo->ttype, bp->ttype, sizeM);
		nhead = (@1*)Hloc(b,  BUNfirst(b));
		ctail = (@1*)Tloc(bo, BUNfirst(bo));
		for(j=0;j<sizeM;j++){
			*nhead = *ctail;
			nhead++;
			ctail++;
		}
		if (bp->ttype==TYPE_str){
			assert(b->T->width <= bp->T->width);
			if (bp->T->width != b->T->width)
				GDKupgradevarheap(b->T, sizeM, (var_t) 1 << (bp->T->width - 1), 0);
			memcpy(Tloc(b,  BUNfirst(b)), Tloc(bp, BUNfirst(bp)), sizeM << bp->T->width);

			{
				/* Copy the heap of the tail. I have to check this with niels */
				int tt=TYPE_str;
				int remap = 0;
				int tremap = remap && BATtrestricted(bp) != BAT_WRITE && tt != TYPE_void;
				int tvremap = tremap && ATOMstorage(tt) == TYPE_str && !GDK_ELIMDOUBLES(bp->T->vheap);
				BUN  tcap = 0;
				Heap bthp, thp;
				memset(&bthp, 0, sizeof(Heap));
				memset(&thp, 0, sizeof(Heap));

				if( 
				    (bp->ttype && heapcopy(&bthp, &bp->T->heap, &tremap) < 0)||
				    
				    (b->T->vheap && heapcopy(&thp, bp->T->vheap, &tvremap) < 0)) {
					HEAPfree(&thp);
					HEAPfree(&bthp);
					return NULL;
				}
				/* succeeded; replace dummy small heaps by the real ones */
				heapfree(&b->T->heap, &bthp);
				if (b->T->vheap)
					heapfree(b->T->vheap, &thp);

				/* make sure we use the correct capacity */
				tcap = (BUN) (b->ttype?b->T->heap.size>>b->T->shift:0);
				b->batCapacity = tcap;


				/* first/inserted must point equally far into the heap as in the source */
				b->batFirst = bp->batFirst;
				b->batInserted = bp->batInserted;

				/* if we have copy-on-write heaps, bn is a logical view on b to ensure the heaps stay stable */
				if (tremap || tvremap) {
					b->P->lview = TRUE;
					BBPshare(b->T->heap.parentid = -bp->batCacheid);
				}
			}
		}else{
                	ntail = (@2*)Tloc(b,  BUNfirst(b));
                	ptail = (@2*)Tloc(bp, BUNfirst(bp));
			for(j=0;j<sizeM;j++){
				*ntail = *ptail;
				ntail++;
				ptail++;
			}
		}
                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;

                /*BATkey(b,TRUE);*/

                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);
	
        	BATsetcount(b, sizeM);

		c = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */

                m = newCrackerIndexSideways_@1(*bid, b->batCacheid, *pbid, c->batCacheid);
		CrackerIndex[m].creationTimestamp = GDKusec();
		CrackerIndex[m].accesses = 1;
		CrackerIndex[m].dropped = 0;
		CrackerIndex[m].tuples = sizeM;

		if (StorageInfo == NULL){
			StorageInfo = (struct storageManagement *)GDKmalloc(sizeof(struct storageManagement));
			StorageInfo->nextMapSet  = NULL;
			StorageInfo->totalTuples = 0;
			StorageInfo->threshold   = 0;
			StorageInfo->setThreshold   = FALSE;
			StorageInfo->references  = NULL;
		}else{
			int MapToDropIndex = -1;
			if (StorageInfo->setThreshold == TRUE){
				if (StorageInfo->totalTuples + sizeM > StorageInfo->threshold){
					MapToDropIndex = getLeastUsedMap();	
					if (MapToDropIndex >=0)
						removeFullMap(MapToDropIndex);
				}
			}
		}

		StorageInfo->totalTuples += sizeM;

                BBPunfix(bo->batCacheid);
                BBPunfix(bp->batCacheid);
@

@= updatesSideways
str
selectMergeInsertionsPart_@1_@2_Sideways( @1 *low, bit *inclusiveLow, @1 *hgh, bit *inclusiveHgh, int position){
	BAT *u,*b;
	oid updates, updatesStart, updatesEnd;
	BUN l;
	@1 *lt, *updLast, *t0;
	 if (CrackerIndex[position].iid == -1) return NULL;
	if ((u = BATdescriptor(CrackerIndex[position].iid)) == NULL)
		return "Cannot access insertions BAT";			

	updates = BATcount(u);
	if (updates == 0){
        	BBPunfix(u->batCacheid);
                return NULL; /* no qualifying values in the insertions */
        }

	BATmirror(u);

	/* if necessary, sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	/* binary search to find the position of the lowest requested value in the insertions */
	l = SORTfndfirst_@5(u,low);
	lt = (@1*)Tloc(u,l);
	t0 = (@1*)Tloc(u,BUNfirst(u));
	updLast = (@1*)Tloc(u, BUNlast(u));
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	if (@3_EQ(lt,low,@4@1) && *inclusiveLow == FALSE){
		while (lt < updLast && @3_EQ(lt,low,@4@1))
			lt ++;
	} 			
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	if ( @3_GT(lt,hgh,@4@1) || (@3_EQ(lt,hgh,@4@1) && *inclusiveHgh==FALSE) ){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */ 	
	}
	updatesStart = (oid) (lt - t0);	
	
	/* binary search to find the position of the highest requested value in the insertions */
        l = SORTfndfirst_@5(u, hgh);
	lt = (@1*)Tloc(u,l);
	if (lt < updLast){
		if (@3_EQ(lt,hgh,@4@1) && *inclusiveHgh == TRUE){	
			while (lt < updLast && @3_EQ(lt,hgh,@4@1))
                            	lt ++;
			lt--;
		} else
		if (@3_EQ(lt,hgh,@4@1) && *inclusiveHgh == FALSE)
                        lt --;
		else
		if ( @3_GT(lt,hgh,@4@1) )
                        lt --;
	}

	if (lt == updLast) lt--;
	updatesEnd = (oid) (lt - t0);

	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "crackers.crackRangeInsertionPart", "Cannot access cracker map");
	BATmirror(b);

	mergeInsertionsBRipple_@1_@2(b, u, updatesStart, updatesEnd, hgh, *inclusiveHgh, position);	

	BATmirror(u);
	BBPunfix(u->batCacheid);
	BATmirror(b);
	BBPunfix(b->batCacheid);

	return NULL;
}
@

@= analyzeTailDisjunction
        for (j = 0; j<vl; j++){
                if (@2_@4(pairt,low2,@3@1) && @2_@5(pairt,hgh2,@3@1))
                        *pivott = (bit)TRUE;
                else
                        *pivott = (bit)FALSE;
                pairt  ++;
                pivott ++;
        }
	
        for (j = vl; j<=vh; j++){
                *pivott = (bit)TRUE;
                pairt  ++;
                pivott ++;
        }

	for (j = vh+1; j<size; j++){
                if (@2_@4(pairt,low2,@3@1) && @2_@5(pairt,hgh2,@3@1))
                        *pivott = (bit)TRUE;
                else
                        *pivott = (bit)FALSE;
                pairt  ++;
                pivott ++;
        }
@

@= CreateDisjunctiveResultSideways
createView:
{
        BAT *p;     
        @2 *pairt;
	bit *pivott;        
	oid size;
	oid j;

	size = BATcount(b);
        p = BATnew(TYPE_void,TYPE_bit,size);

        pairt  = (@2 *)Tloc(b, BUNfirst(b));
        pivott = (bit*)Tloc(p, BUNfirst(p));

	if (*inclusiveLow2==TRUE && *inclusiveHgh2==TRUE){
		@:analyzeTailDisjunction(@2,@3,@4,GE,LE)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==TRUE){
		@:analyzeTailDisjunction(@2,@3,@4,GT,LE)@	
	}
	if (*inclusiveLow2==TRUE && *inclusiveHgh2==FALSE){
		@:analyzeTailDisjunction(@2,@3,@4,GE,LT)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==FALSE){
		@:analyzeTailDisjunction(@2,@3,@4,GT,LT)@	
	}

        BATsetcount(p, size);

        p->hsorted = FALSE;
        p->tsorted = FALSE;
        p->hdense = FALSE;
        p->tdense = FALSE;

        BBPkeepref(p->batCacheid);
        BBPunfix(b->batCacheid);
        *vid = p->batCacheid;
}
@

@= RangeSelectBody
	BAT *viewHead = NULL;
        BAT *b, *c, *view=NULL;
        int  m, h;
        oid vl=0, vh=0, posl, posh, cl1=0, ch1=0, cl2=0, ch2=0;
        oid _vl;
        int gapL = 1, gapH = 1;
        bit HBound, foundLow=0, foundHgh=0;
	bit newCrackerMAP = FALSE;
	bit newTape = FALSE;
	bit crkTwoR, crkTwoL;

        if (@3_GT(low,hgh,@4@1))
                throw(MAL, "crackers.crack", "illegal range");

        if (*inclusiveHgh == TRUE) HBound = FALSE;
        else    HBound = TRUE;


	/* get the cracker tape for this set or create one if it does not exist */
        h = existsCrackerIndexSideways(*bid, -1);
	if (h==-1){
		h = CreateTape_@1(*bid); 
		newTape = TRUE;
	}

	/* get the map */
        m = existsCrackerIndexSideways(*bid, *pbid);

        /* create the map if it does not exist */
	if (m == -1){
		@:CreateCrackerMap(@1,@2)@		
		newCrackerMAP = TRUE;
        }else{
        	/* Take the index of the map */
	        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	        throw(MAL, "crackers.crackRange", "Cannot access cracker index");
        
	        /* Take the map */
        	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                	throw(MAL, "crackers.crackRange", "Cannot access crack map");

        	CrackerIndex[m].accesses += 1;
	}

	/* if Also take this branch if there is an index but is empty, i.e., there were gaps in the previous selections */
        if ( newTape == TRUE || CrackerIndex[m].Tree == NULL){
		/* crack the whole map based on the current restriction */
                posl = BUNfirst(b);
                posh = BUNlast(b)-(oid)1;
                @:crkThreeTreeSideways(@1,@2,posl,posh)@
		
		/* update the cracker tape and the cursor of the map */
		AddToTape_@1(h, *low, *hgh, *inclusiveLow, *inclusiveHgh );
		CrackerIndex[m].nextCrack++;
                goto createView;
	}

	 /* If a map exists for this bat (so it has been cracked before)
            we search its index to find where our range falls.
            If we have a match on the low range vl will hold the
            index value, otherwise it will be -1. The same for hgh and vh.
            If there is no match for low, then cl will hold a position on the map that
            from there on we have to crack. The same from hgh and ch.
            
            In the case of the low range we always have to increment
            by one this position since we want the tuples that are after this position
            (because of the way the crack index maintains information).
            
            After the search l and h point to the low and hgh positions
            (in the cracker index) found either as a match or to crack.
            This is used later on to determine which pieces we have to crack. */
        
	/* Align the map based on the position of its cursor in the cracker tape */
	Sync_@1_@2(m,h);        
        
	selectMergeInsertionsPart_@1_@2_Sideways(low, inclusiveLow, hgh, inclusiveHgh, m);
        
        /* find out where in the index the low falls */
        foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1);
        
        /* find out where in the index the high falls */        
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);
                
	/* need to increase one position for the low bound only since we always store the previous position in the index */
        if (cl1 != 0) cl1++;
        if (cl2 != 0) cl2++;
        
        /* If one or both of the selection bounds were not found, then we have to crack */
	crkTwoR = crkTwoL = FALSE;
        if (foundLow == 0 || foundHgh == 0){
                if (foundLow == 0 && foundHgh == 0){                         
			/* If ch2 is right after cl1 in the index then we split this piece in three pieces */   
                        if (cl1 == cl2){
                                @:crkThreeTreeSideways(@1,@2,cl1,ch2)@
                        } else {
                                /* Else we have to do two cracks separatelly */
                                
                                /* For the cl bound and the next one in the index */
                        	crkTwoL = TRUE;
                                
                                /* For the ch bound and the previous one in the index */
                        	crkTwoR = TRUE;
                        }
                } else
                if (foundLow == 0){
                        crkTwoL = TRUE;
                        vh = ch2;
                } else
                if (foundHgh == 0){
                        crkTwoR = TRUE;
                        vl = cl1;
                }

		if (crkTwoL){
                        @:crkTwoLTreeSideways(@1,@2)@
			if (vl>0) _vl=vl-1; else _vl=vl;
			if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
		}
		if (crkTwoR){
                        @:crkTwoRTreeSideways(@1,@2)@
                        if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
		}		
        } else {
                vl = cl1;
                vh = ch2;
        }

	/* Update the cracker tape and the cursor */
	AddToTape_@1(h, *low, *hgh, *inclusiveLow, *inclusiveHgh );
	CrackerIndex[m].nextCrack+=1;
@

@= RangeSelectBodyLeftNull
	BAT *viewHead = NULL;
        BAT *b, *c, *view=NULL;
        int  m, h;
        oid vl=0, vh=0, cl2=0, ch2=0;
        int gapH = 1;
        bit HBound,foundHgh=0;
	bit newCrackerMAP = FALSE;
	bit newTape = FALSE;

        if (*inclusiveHgh == TRUE) HBound = FALSE;
        else    HBound = TRUE;

	/* get the cracker tape for this set or create one if it does not exist */
        h = existsCrackerIndexSideways(*bid, -1);
	if (h==-1){
		h = CreateTape_@1(*bid); 
		newTape = TRUE;
	}

	/* get the map */
        m = existsCrackerIndexSideways(*bid, *pbid);

        /* create the map if it does not exist */
	if (m == -1){
		@:CreateCrackerMap(@1,@2)@		
		newCrackerMAP = TRUE;
        }else{
        	/* Take the index of the map */
	        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	        throw(MAL, "crackers.crackRange", "Cannot access cracker index");
        
	        /* Take the map */
        	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                	throw(MAL, "crackers.crackRange", "Cannot access crack map");

        	CrackerIndex[m].accesses += 1;
	}

	/* if Also take this branch if there is an index but is empty, i.e., there were gaps in the previous selections */
        if ( newTape == TRUE || CrackerIndex[m].Tree == NULL){
                cl2 = BUNfirst(b);
                ch2 = BUNlast(b)-(oid)1;

		@:crkTwoRTreeSideways(@1,@2)@
		
		if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
		
		/* update the cracker tape and the cursor of the map */
		AddToTape_@1(h, *(@1*)ATOMnilptr(TYPE_@1), *hgh, *inclusiveLow, *inclusiveHgh );
		CrackerIndex[m].nextCrack+=1;
                goto createView;
	}

	 /* If a map exists for this bat (so it has been cracked before)
            we search its index to find where our range falls.
            If we have a match on the low range vl will hold the
            index value, otherwise it will be -1. The same for hgh and vh.
            If there is no match for low, then cl will hold a position on the map that
            from there on we have to crack. The same from hgh and ch.
            
            In the case of the low range we always have to increment
            by one this position since we want the tuples that are after this position
            (because of the way the crack index maintains information).
            
            After the search l and h point to the low and hgh positions
            (in the cracker index) found either as a match or to crack.
            This is used later on to determine which pieces we have to crack. */
        
	/* Align the map based on the position of its cursor in the cracker tape */
	Sync_@1_@2(m,h);        
        
	/*handle updates TODO*/
        
        /* find out where in the index the high falls */        
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);
                
	/* need to increase one position for the low bound only since we always store the previous position in the index */
        if (cl2 != 0) cl2++;
        /* If one or both of the selection bounds were not found, then we have to crack */
        if (foundHgh == 0){
                        @:crkTwoRTreeSideways(@1,@2)@
                        if (IndexSize <IndexStop)
                                if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
                
        } else 
                vh = ch2;

	/* Update the cracker tape and the cursor */
	AddToTape_@1(h, *(@1*)ATOMnilptr(TYPE_@1), *hgh, *inclusiveLow, *inclusiveHgh );
	CrackerIndex[m].nextCrack+=1;
@

@= RangeSelectBodyRightNull
	BAT *viewHead = NULL;
        BAT *b, *c, *view=NULL;
        int  m, h;
        oid vl=0, vh=0, cl1=0, ch1=0;
        int gapL = 1;
        bit foundLow=0;
	bit newCrackerMAP = FALSE;
	bit newTape = FALSE;

	/* get the cracker tape for this set or create one if it does not exist */
        h = existsCrackerIndexSideways(*bid, -1);
	if (h==-1){
		h = CreateTape_@1(*bid); 
		newTape = TRUE;
	}

	/* get the map */
        m = existsCrackerIndexSideways(*bid, *pbid);

	if (m == -1){
		@:CreateCrackerMap(@1,@2)@		
		newCrackerMAP = TRUE;
        }else{
        	/* Take the index of the map */
	        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	        throw(MAL, "crackers.crackRange", "Cannot access cracker index");
        
	        /* Take the map */
        	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                	throw(MAL, "crackers.crackRange", "Cannot access crack map");

        	CrackerIndex[m].accesses += 1;
	}

	/* if Also take this branch if there is an index but is empty, i.e., there were gaps in the previous selections */
        if ( newTape == TRUE || CrackerIndex[m].Tree == NULL){
                cl1 = BUNfirst(b);
                ch1 = BUNlast(b)-(oid)1;
       		vh=BUNlast(b)-(oid)1; 

		@:crkTwoLTreeSideways(@1,@2)@
		if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
		
		/* update the cracker tape and the cursor of the map */
		AddToTape_@1(h, *low, *(@1*)ATOMnilptr(TYPE_@1), *inclusiveLow, *inclusiveHgh );
		CrackerIndex[m].nextCrack+=1;
                goto createView;
	}

	 /* If a map exists for this bat (so it has been cracked before)
            we search its index to find where our range falls.
            If we have a match on the low range vl will hold the
            index value, otherwise it will be -1. The same for hgh and vh.
            If there is no match for low, then cl will hold a position on the map that
            from there on we have to crack. The same from hgh and ch.
            
            In the case of the low range we always have to increment
            by one this position since we want the tuples that are after this position
            (because of the way the crack index maintains information).
            
            After the search l and h point to the low and hgh positions
            (in the cracker index) found either as a match or to crack.
            This is used later on to determine which pieces we have to crack. */
        
	/* Align the map based on the position of its cursor in the cracker tape */
	Sync_@1_@2(m,h);        
        
	/*handle updates TODO*/
        
        /* find out where in the index the high falls */        
	foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1);
                
	/* need to increase one position for the low bound only since we always store the previous position in the index */
        if (cl1 != 0) cl1++;
       	vh=BUNlast(b)-(oid)1; 
        /* If one or both of the selection bounds were not found, then we have to crack */
        if (foundLow == 0){
                        @:crkTwoLTreeSideways(@1,@2)@
                        if (IndexSize <IndexStop)
                                if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
                
        } else 
                vl = cl1;

	/* Update the cracker tape and the cursor */
	AddToTape_@1(h, *low, *(@1*)ATOMnilptr(TYPE_@1), *inclusiveLow, *inclusiveHgh );
	CrackerIndex[m].nextCrack+=1;
@


@= crackOperationsSideways
static str
CRKRangeSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail){
	@:RangeSelectBody(@1,@2,@3,@4)@

	/* Define resulting view: a contiguous area on the map */	
        @:CreateResultSideways()@

        return MAL_SUCCEED;
}

static str
CRKRangeSidewaysLeftNull_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail){
	@:RangeSelectBodyLeftNull(@1,@2,@3,@4)@

	/* Define resulting view: a contiguous area on the map */	
        @:CreateResultSideways()@

	(void)low;
        return MAL_SUCCEED;
}

static str
CRKRangeSidewaysRightNull_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail){
	@:RangeSelectBodyRightNull(@1,@2,@3,@4)@

	/* Define resulting view: a contiguous area on the map */	
        @:CreateResultSideways()@

	(void)hgh;
        return MAL_SUCCEED;
}

static str
CRKdRangeSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2){
	@:RangeSelectBody(@1,@2,@3,@4)@
	(void)viewHead;
	(void)view;
	(void)newCrackerMAP;
	/* Define resulting view: a contiguous area on the map */	
        @:CreateDisjunctiveResultSideways(@1,@2,@3,@4)@

        return MAL_SUCCEED;
}
@

@= JoinSelectBodySideways
        BAT *b, *p;     
        @2 *pairt;
	bit *pivott;        
	oid size;
	oid j;
        bit dense=TRUE;

        if ((b = BATdescriptor(*cpair)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
        }  
        
	size = BATcount(b);
	p = BATnew(TYPE_void,TYPE_bit,size);

	pairt  = (@2*)Tloc(b, BUNfirst(b));
	pivott = (bit*)Tloc(p, BUNfirst(p));
	for (j = 0; j<size; j++){
		if (@3)	
			*pivott = (bit)TRUE;
		else {
			*pivott = (bit)FALSE;
                        dense=FALSE;
                }
		pairt  ++;
		pivott ++;	
	}

        BATsetcount(p, size);	
	
	p->hsorted = FALSE;
        p->hdense = FALSE;

        if (dense){
        	p->tdense = TRUE;
        	p->tsorted = TRUE;
	}else{
        	p->tdense =FALSE; 
        	p->tsorted = FALSE;
	}

	BBPkeepref(p->batCacheid);
	BBPunfix(b->batCacheid);
	*res = p->batCacheid;

	return MAL_SUCCEED;
@

@= JoinSelectBodySidewaysWithPivot
        BAT *b, *p, *c, *slice;     
        @2 *pairt;
	bit *pivott;        
	oid size;
	oid skip;
	int m;
	oid cl1=0,cl2=0,ch1=0,ch2=0;
	oid j;
	bit newMap = FALSE;
        bit dense=TRUE;

	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		newMap = TRUE;
	}else{	
        	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                	throw(MAL, "crackers.crackRange", "Cannot access crack index");

		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
        	        throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");

        	CrackerIndex[m].accesses += 1;
	}

	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));


        GetLow_@1(*low1, *inclusiveLow1, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-1);

        GetHgh_@1(*hgh1, *inclusiveHgh1, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-1);

	if (cl1 != 0) cl1++;

        slice = BATslice(b, cl1, ch2+1);

        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
	
	size = BATcount(p);
	pairt = (@2*)Tloc(slice, BUNfirst(slice));
	pivott = (bit*)Tloc(p, BUNfirst(p));
	skip = 0;
	for (j = 0; j<size; j++){
		if (*pivott == TRUE){
	        	pairt += skip;	
			if (!(@3)){	
				*pivott = FALSE;
				dense = FALSE;
			}
			skip = 0;
		}
		pivott ++;	
		skip++;
	}

        if (dense){
        	p->tdense = TRUE;
        	p->tsorted = TRUE;
	}else{
        	p->tdense =FALSE; 
        	p->tsorted = FALSE;
	}

	if (newMap){
		BBPkeepref(b->batCacheid);
		BBPkeepref(c->batCacheid);
	}else{
		BBPunfix(b->batCacheid);
		BBPunfix(c->batCacheid);
	}
	BBPkeepref(p->batCacheid);
	*res = p->batCacheid;
	BBPunfix(slice->batCacheid);
	return MAL_SUCCEED;
@

@= dJoinSelectBodySidewaysWithPivot
        BAT *b, *p, *c;     
        @2 *pairt;
	bit *pivott;        
	oid size;
	oid skip;
	int m;
	oid j;

	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPkeepref(b->batCacheid);
		BBPkeepref(c->batCacheid);
	}	

	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.dJoinSelectSideways", "Cannot access map");


        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
	
	size = BATcount(p);
	pairt  = (@2 *)Tloc(b, BUNfirst(b));
	pivott = (bit*)Tloc(p, BUNfirst(p));
	skip = 0;
	for (j = 0; j<size; j++){
		if (*pivott == FALSE){
	        	pairt += skip;	
			if ((@3))	
				*pivott = TRUE;
			skip = 0;
		}
		pivott ++;	
		skip++;
	}

	BBPkeepref(p->batCacheid);
	*res = p->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
@

@= JoinSelectRSidewaysWithoutPivot
static str
JoinSelectRangeSideways_@3_@4_@2(int *res, int *cpair, @2 *low, @2 *hgh){
        @:JoinSelectBodySideways(,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}
@

@= JoinSelectRSideways
static str
JoinSelectRangeSideways_P_@3_@4_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1){
        @:JoinSelectBodySidewaysWithPivot(@1,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}

static str
dJoinSelectRangeSideways_P_@3_@4_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh){
        @:dJoinSelectBodySidewaysWithPivot(@1,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}
@

@= JoinSelectSidewaysWithoutPivot
static str
JoinSelectSingleSideways_@3_@2(int *res, int *cpair, @2 *mid){
        @:JoinSelectBodySideways(,@2,@5_@4(pairt,mid,@6@2))@
}
@

@= JoinSelectSideways
static str
JoinSelectSingleSideways_P_@3_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *mid, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1){
        @:JoinSelectBodySidewaysWithPivot(@1,@2,@5_@4(pairt,mid,@6@2))@
}
@

@}
