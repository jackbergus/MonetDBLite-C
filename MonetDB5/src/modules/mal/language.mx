@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f language
@a Martin Kersten
@v 1.0
@+ Language Extensions
Iterators over scalar ranges are often needed, also at the MAL level.
The barrier and control primitives are sufficient to mimic them directly.

The modules located in the kernel directory should not
rely on the MAL datastructures. That's why we have to deal with
some bat operations here and delegate the signature to the
proper module upon loading.

Running a script is typically used to initialize a context. 
Therefore we need access to the runtime context. 
For the call variants we have
to determine an easy way to exchange the parameter/return values.

@mal
module language;

command newRange(v:oid)(:bit,:oid) 
address RNGnewRange_oid; 
command newRange(v:sht)(:bit,:sht) 
address RNGnewRange_sht; 
command newRange(v:int)(:bit,:int) 
address RNGnewRange_int; 
command newRange(v:lng)(:bit,:lng) 
address RNGnewRange_lng; 
command newRange(v:flt)(:bit,:flt) 
address RNGnewRange_flt; 
command newRange(v:dbl)(:bit,:dbl)
address RNGnewRange_dbl 
comment "This routine introduces an iterator
	over a scalar domain.";

command nextElement(step:oid,last:oid)(:bit,:oid)
address RNGnextElement_oid; 
command nextElement(step:sht,last:sht)(:bit,:sht)
address RNGnextElement_sht; 
command nextElement(step:int,last:int)(:bit,:int)
address RNGnextElement_int; 
command nextElement(step:lng,last:lng)(:bit,:lng)
address RNGnextElement_lng; 
command nextElement(step:flt,last:flt)(:bit,:flt)
address RNGnextElement_flt; 
command nextElement(step:dbl,last:dbl)(:bit,:dbl)
address RNGnextElement_dbl 
comment "Advances the iterator with a fixed value
	until it becomes >= last.";

command raise(msg:str) :str 
address CMDraise
comment "Raise an exception labeled 
	with a specific message.";
command assert(v:bit,term:str):void
address MALassertBit;
command assert(v:sht,term:str):void
address MALassertSht;
command assert(v:int,term:str):void
address MALassertInt;
command assert(v:lng,term:str):void
address MALassertLng;
command assert(v:str,term:str):void
address MALassertStr;
command assert(v:oid,term:str):void
address MALassertOid;
pattern assert(v:any_1,pname:str,oper:str,val:any_2):void
address MALassertTriple
comment "Assertion test.";

pattern assertSpace(depth:int)
address MALsafeguardStack
comment "Ensures that the current call does not consume
more then depth*vtop elements on the stack.";

pattern dataflow():int
address MALstartDataflow
comment "The current guarded block is executed using
dataflow control. It returns the number of threads assigned for the job, which can be used testing.";

pattern register(m:str,f:str,code:str,help:str):void
address CMDregisterFunction
comment"Compile the code string and register it as a MAL function.";

pattern setMemoryTrace(flg:bit):void
address CMDsetMemoryTrace
comment "Set the flag to trace the memory footprint";
pattern setThreadTrace(flg:bit):void
address CMDsetThreadTrace
comment "Set the flag to trace the interpreter threads";
pattern setTimerTrace(flg:bit):void
address CMDsetTimerTrace
comment "Set the flag to trace the execution time";
pattern setIOTrace(flg:bit):void
address CMDsetIOTrace
comment "Set the flag to trace the IO";

pattern call(s:str):void
address CMDcallString
comment "Evaluate a MAL string program.";
pattern call(s:bat[:oid,:str]):void
address CMDcallBAT
comment "Evaluate a program stored in a BAT.";
pattern source(f:str):void
address CMDevalFile
comment "Merge the instructions stored in the 
	file with the current program.";

@{
@+ Dummy code 
@h
#ifndef _LANGUAGE_H
#define _LANGUAGE_H
#include "mal.h"
#include "mal_module.h"
#include "mal_session.h"
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_interpreter.h"

#ifdef WIN32
#ifndef LIBLANGUAGE
#define language_export extern __declspec(dllimport)
#else
#define language_export extern __declspec(dllexport)
#endif
#else
#define language_export extern
#endif

language_export str CMDraise(str *ret, str *msg);
language_export str MALassertBit(int *ret, bit *val, str *msg);
language_export str MALassertStr(int *ret, str *val, str *msg);
language_export str MALassertOid(int *ret, oid *val, str *msg);
language_export str MALassertSht(int *ret, sht *val, str *msg);
language_export str MALassertInt(int *ret, int *val, str *msg);
language_export str MALassertLng(int *ret, lng *val, str *msg);
language_export str MALstartDataflow( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDregisterFunction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDsetMemoryTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDsetThreadTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDsetIOTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDsetTimerTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDcallString(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDevalFile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDcallBAT(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDincludeFile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
language_export str CMDdebug(int *ret, int *flg);
language_export str MALassertTriple(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
language_export str MALsafeguardStack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
#endif /* _LANGUAGE_H */
@c

#include "mal_config.h"
#include "language.h"

str
CMDraise(str *ret, str *msg)
{
	*ret = GDKstrdup(*msg);
	return GDKstrdup(*msg);
}

str
MALassertBit(int *ret, bit *val, str *msg){
	(void) ret;
	if( *val == 0 || *val == bit_nil)
		throw(MAL, "mal.assert",*msg);
	return MAL_SUCCEED;
}
str
MALassertInt(int *ret, int *val, str *msg){
	(void) ret;
	if( *val == 0 || *val == int_nil)
		throw(MAL, "mal.assert",*msg);
	return MAL_SUCCEED;
}
str
MALassertLng(int *ret, lng *val, str *msg){
	(void) ret;
	if( *val == 0 || *val == lng_nil)
		throw(MAL, "mal.assert",*msg);
	return MAL_SUCCEED;
}
str
MALassertSht(int *ret, sht *val, str *msg){
	(void) ret;
	if( *val == 0 || *val == sht_nil)
		throw(MAL, "mal.assert",*msg);
	return MAL_SUCCEED;
}
str
MALassertOid(int *ret, oid *val, str *msg){
	(void) ret;
	if( *val == oid_nil)
		throw(MAL, "mal.assert",*msg);
	return MAL_SUCCEED;
}
str
MALassertStr(int *ret, str *val, str *msg){
	(void) ret;
	if( *val == str_nil)
		throw(MAL, "mal.assert",*msg);
	return MAL_SUCCEED;
}

str
MALassertTriple(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL, "mal.assert","Command not yet available");
}

str 
MALsafeguardStack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	return safeguardStack(mb, stk, p);
}


@+ Printing
The print commands are implemented as single instruction rules,
because they need access to the calling context.
At a later stage we can look into the issues related to
parsing the format string as part of the initialization phase.
The old method in V4 essentially causes a lot of overhead
because you have to prepare for the worst (e.g. mismatch format
identifier and argument value)

@- Input redirectionrs
@c
str
CMDcallString(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *s;

	(void) mb;		/* fool compiler */
	s = (str *) getArgReference(stk, pci, 1);
	if (strlen(*s) == 0)
		return MAL_SUCCEED;
	callString(cntxt, *s, FALSE);
	return MAL_SUCCEED;
}

str
MALstartDataflow( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str msg= MAL_SUCCEED;
	int *ret = (int*) getArgReference(stk,pci,0);

	(void) cntxt;
	if (pci == NULL || stk == NULL || stk->cmd) {
		*ret = 1; /* ignore dataflow request */
		return MAL_SUCCEED;
	}
	msg = runMALdataflow(cntxt, mb, getPC(mb,pci), pci->jump, stk, 0, pci);
	if (msg == MAL_SUCCEED)
		*ret = -1;
	return msg;
}


str 
CMDregisterFunction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Symbol sym= NULL;
	int *ret = (int *) getArgReference(stk,pci,0);
	str *mod = (str *) getArgReference(stk,pci,1);
	str *fcn = (str *) getArgReference(stk,pci,2);
	str *code = (str *) getArgReference(stk,pci,3);
	str *help = (str *) getArgReference(stk,pci,4);
	InstrPtr sig;
	str msg;

	msg= compileString(&sym, cntxt,*code);
	if( sym) {
		stream_printf(cntxt->fdout,"REGISTER FUNCTIOn %s.%s\n",
			getModuleId(sym->def->stmt[0]), getFunctionId(sym->def->stmt[0]));
		mb= sym->def;
		if( help)
			mb->help= GDKstrdup(*help);
		printFunction(cntxt->fdout, mb,stk,0);
		sig= getSignature(sym);
		renameFunction( getModuleId(sig), getFunctionId(sig), 
			putName(*mod, strlen(*mod)), putName(*fcn,strlen(*fcn)));
	}
	*ret = 0;
	return msg;
}
str
CMDevalFile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str s = *(str *) getArgReference(stk,pci,1);
	char *msg = NULL;
	(void) mb;

	if (s == 0) 
		throw(MAL, "mal.evalFile", "File name missing\n");

	if (*s != '/') {
		char *buf = GDKmalloc(strlen(monet_cwd) + strlen(s) + 2);

		strcpy(buf, monet_cwd);
		strcat(buf, "/");
		strcat(buf, s);
		msg = evalFile(cntxt, buf, 0);
		GDKfree(buf);
	} else 
		msg = evalFile(cntxt, s, 0);
	return msg;
}
@-
Calling a BAT is simply translated into a concatenation of
all the unquoted strings and then passing it to the callEval.
@c
str
CMDcallBAT(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	throw(MAL, "mal.call", "Not yet implemented");
}

str
CMDincludeFile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	throw(MAL, "mal.include", "Not yet implemented");
}

str
CMDdebug(int *ret, int *flg)
{
	*ret = GDKdebug;
	if (*flg)
		GDKdebug = *flg;
	return MAL_SUCCEED;
}

@+ MAL iterator code
This module contains the framework for the construction of iterators.
Iterators enumerate elements in a collection defined by a few parameters,
e.g. a lower/upper bound.

Iterators appear as ordinary function calls in the MAL code and
always return a boolean, to indicate that an element is available for
consumption. Initialization of the iterator representation depends
on its kind.

The most common class of iterators encountered in a programming
environment is the for-loop. It contains a for-loop variable,
a starting point and a limit. Changing the for-loop variable
within the for-loop body is considered bad code and should be avoided
to simplify data-flow analysis.

We assume that the range boundaries comply with the underlying domain.
@= newRange
language_export str RNGnewRange_@1(bit *res, @1 *i, @1 *first);
str RNGnewRange_@1(bit *res, @1 *i, @1 *first){
	*res = TRUE;
	*i= *first;
	return MAL_SUCCEED;
}

@= nextElement
language_export str RNGnextElement_@1(bit *res, @1 *i, @1 *step, @1 *last);
str RNGnextElement_@1(bit *res, @1 *i, @1 *step, @1 *last){
	@1 v = *i;
	v = v + *step;
	*i = v;
	*res = v < *last;
	return MAL_SUCCEED;
}
@c

@:newRange(oid)@
@:newRange(lng)@
@:newRange(int)@
@:newRange(sht)@
@:newRange(flt)@
@:newRange(dbl)@

@:nextElement(oid)@
@:nextElement(lng)@
@:nextElement(int)@
@:nextElement(sht)@
@:nextElement(flt)@
@:nextElement(dbl)@

@-
There are a few more atom-airy storage types we have to introduce here:
OID, str, void, bit, ptr
@c
str
CMDsetMemoryTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
    bit *flag= (bit*) getArgReference(stk,pci,1);

    (void) mb;
    if( *flag) {
		cntxt->flags |= bigfootFlag;
        MCdefault |= bigfootFlag;
    } else {
		cntxt->flags &= bigfootFlag;
        MCdefault &= ~bigfootFlag;
	}
    return MAL_SUCCEED;
}

str
CMDsetTimerTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
    bit *flag= (bit*) getArgReference(stk,pci,1);

    (void) mb;
    if( *flag) {
		cntxt->flags |= timerFlag;
        MCdefault |= timerFlag;
    } else {
		cntxt->flags &= timerFlag;
        MCdefault &= ~timerFlag;
	}
    return MAL_SUCCEED;
}

str
CMDsetThreadTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
    bit *flag= (bit*) getArgReference(stk,pci,1);

    (void) mb;
    if( *flag){
		cntxt->flags |= threadFlag;
        MCdefault |= threadFlag;
    }else{
		cntxt->flags &= threadFlag;
        MCdefault &= ~threadFlag;
	}
    return MAL_SUCCEED;
}


str
CMDsetIOTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
    bit *flag= (bit*) getArgReference(stk,pci,1);

    (void) mb;
    if( *flag){
		cntxt->flags |= ioFlag;
        MCdefault |= ioFlag;
    }else{
		cntxt->flags &= ioFlag;
        MCdefault &= ~ioFlag;
	}
    return MAL_SUCCEED;
}

@}
