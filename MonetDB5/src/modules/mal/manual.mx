@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f manual
@a Martin Kersten
@v 1
@+ Manual Inspection
This module introduces a series of commands that provide access
to the help information stored in the runtime environment.

The manual bulk operations ease offline inspection of all function definitions.
It includes an XML organized file, because we expect external
tools to massage it further for presentation. 
@mal
module manual;

pattern help(text:str)
address MANUALhelp
comment "Produces a list of all <module>.<function> that match 
	the text pattern. The wildcard '*' can be used for <module> 
and <function>. Using the '(' asks for signature information and
using ')' asks for the complete help record.";
pattern search(text:str)
address MANUALsearch
comment "Search the manual for command descriptions that match the 
regular expression 'text'";

pattern createXML(mod:str):void
address MANUALcreate1
comment "Generate a synopsis of a module";
pattern createXML():void
address MANUALcreate0
comment "Produces a XML-formatted manual over all modules loaded.";

pattern section(mod:str):void
address MANUALcreateSection
comment "Generate a synopsis of a module for the reference manual";
pattern index():void
address MANUALcreateIndex
comment "Produces an overview of all names grouped by module.";
command summary():void
address MANUALcreateSummary
comment "Produces a manual with help lines grouped by module.";

pattern completion(pat:str):bat[:int,:str]
address MANUALcompletion
comment "Produces the wordcompletion table.";
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _MANUAL_H
#endif /* _MANUAL_H */
@c
#include "mal_config.h"
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#ifdef WIN32
#ifndef LIBMANUAL
#define manual_export extern __declspec(dllimport)
#else
#define manual_export extern __declspec(dllexport)
#endif
#else
#define manual_export extern
#endif

manual_export str MANUALcreateSection(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
manual_export str MANUALcreate1(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
manual_export str MANUALcreate0(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
manual_export str MANUALsearch(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
manual_export str MANUALhelp(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
manual_export str MANUALcreateIndex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
manual_export str MANUALcreateSummary(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
manual_export str MANUALcompletion(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@+ Symbol table 
Mal symbol table and environment analysis.
@c

str
MANUALcreateSection(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *mod = (str*) getArgReference(stk,pci,1);
	Client cntxt= MCgetClient();

	(void) mb;
	dumpManualSection(cntxt->fdout, findModule(cntxt->nspace, putName(*mod, strlen(*mod))));
	return MAL_SUCCEED;
}

str
MANUALcreate1(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client cntxt= MCgetClient();
	str *mod = (str*) getArgReference(stk,pci,1);
	(void) mb;		/* fool compiler */
	dumpManualHeader(cntxt->fdout);
	dumpManual(cntxt->fdout, findModule(cntxt->nspace, putName(*mod, strlen(*mod))), 0);
	dumpManualFooter(cntxt->fdout);
	return MAL_SUCCEED;
}

str
MANUALcreate0(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client cntxt= MCgetClient();
	(void) mb;
	(void) stk;
	(void) pci;
	dumpManualHeader(cntxt->fdout);
	dumpManual(cntxt->fdout, cntxt->nspace, 1);
	dumpManualFooter(cntxt->fdout);
	return MAL_SUCCEED;
}
str
MANUALcreateIndex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client cntxt= MCgetClient();
	(void) mb;
	(void) stk;
	(void) pci;
	dumpManualOverview(cntxt->fdout, cntxt->nspace, 1);
	return MAL_SUCCEED;
}
str
MANUALcreateSummary(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client cntxt= MCgetClient();
	(void) mb;
	(void) stk;
	(void) pci;
	dumpManualHelp(cntxt->fdout, MCgetClient()->nspace, 1);
	return MAL_SUCCEED;
}
str
MANUALcompletion(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client cntxt= MCgetClient();
	str *text= (str*) getArgReference(stk,pci,1);
	(void) mb;		/* fool compiler */
	dumpHelpTable(cntxt->fdout, cntxt->nspace, *text,1);
	return MAL_SUCCEED;
}

str
MANUALhelp(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	char **msg;
	int i;
	Client cntxt= MCgetClient();
	str *text= (str*) getArgReference(stk,pci,1);
	(void) mb;		/* fool compiler */

	msg= getHelp(cntxt->nspace,*text,1);
	if( msg && msg[0] ){
		for(i=0; msg[i];i++){
			mal_unquote(msg[i]);
			stream_printf(cntxt->fdout,"%s\n",msg[i]);
			GDKfree(msg[i]);
		}
	}
	if( msg) 
		GDKfree(msg);
	return MAL_SUCCEED;
}

str
MANUALsearch(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	char **msg;
	int i;
	Client cntxt= MCgetClient();
	str *pat= (str*) getArgReference(stk,pci,1);
	(void) mb;		/* fool compiler */

	msg= getHelpMatch(*pat);
	if( msg && msg[0] ){
		for(i=0; msg[i];i++){
			mal_unquote(msg[i]);
			stream_printf(cntxt->fdout,"%s\n",msg[i]+1);
			GDKfree(msg[i]);
		}
	}
	if( msg) 
		GDKfree(msg);
	return MAL_SUCCEED;
}

@}
