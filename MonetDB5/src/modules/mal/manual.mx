@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f manual
@a Martin Kersten
@v 1
@+ Manual Inspection
This module introduces a series of commands that provide access
to the help information stored in the runtime environment.

The manual bulk operations ease offline inspection of all function definitions.
It includes an XML organized file, because we expect external
tools to massage it further for presentation. 
@mal
module manual;

command help(text:str)
address MANUALhelp
comment "Produces a list of all <module>.<function> that match 
	the text pattern. The wildcard '*' can be used for <module> 
and <function>. Using the '(' asks for signature information and
using ')' asks for the complete help record.";
command search(text:str)
address MANUALsearch
comment "Search the manual for command descriptions that match the 
regular expression 'text'";

command createXML(mod:str):void
address MANUALcreate1
comment "Generate a synopsis of a module";
command createXML():void
address MANUALcreate0
comment "Produces a XML-formatted manual over all modules loaded.";

command section(mod:str):void
address MANUALcreateSection1
comment "Generate a synopsis of a module for the reference manual";
command index():void
address MANUALcreateIndex
comment "Produces an overview of all names grouped by module.";
command summary():void
address MANUALcreateSummary
comment "Produces a manual with help lines grouped by module.";
@-
#command completion(text:str)
#address MANUALcompletion
#comment "Produces the wordcompletion table.";
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _MANUAL_H
#endif /* _MANUAL_H */
@c
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#ifdef WIN32
#ifndef LIBMANUAL
#define manual_export extern __declspec(dllimport)
#else
#define manual_export extern __declspec(dllexport)
#endif
#else
#define manual_export extern
#endif

manual_export str MANUALcreate(int *ret, str *fname, str *mod, int *recursive);
manual_export str MANUALcreateSection1(int *ret, str *mod);
manual_export str MANUALcreate2(int *ret, str *fname, str *mod, int *recursive);
manual_export str MANUALcreate1(int *ret, str *mod);
manual_export str MANUALcreate0(int *ret);
manual_export str MANUALsearch(int *ret, str *mod);
manual_export str MANUALcompletion(int *ret, str *text);
manual_export str MANUALhelp(int *ret, str *text);
manual_export str MANUALcreateIndex(int *ret);
manual_export str MANUALcreateSummary(int *ret);

@+ Symbol table 
Mal symbol table and environment analysis.
@c

str
MANUALcreateSection1(int *ret, str *mod)
{

	(void) ret;		/* fool compiler */
	dumpManualSection(GDKout, findModule(MCgetClient()->nspace, putName(*mod, strlen(*mod))));
	return MAL_SUCCEED;
}

str
MANUALcreate(int *ret, str *fname, str *mod, int *recursive)
{
	stream *fs;

	(void) ret;		/* fool compiler */
	fs = open_wastream(*fname);
	if (fs == NULL)
		throw(MAL, "manual.create", "Could not open file\n");
	dumpManualHeader(fs);
	dumpManual(fs, findModule(MCgetClient()->nspace, putName(*mod, strlen(*mod))), *recursive);
	dumpManualFooter(fs);
	stream_close(fs);
	return MAL_SUCCEED;
}

str
MANUALcreate2(int *ret, str *fname, str *mod, int *recursive)
{
	int r = 0;

	(void) recursive;	/* fool compiler */
	return MANUALcreate(ret, fname, mod, &r);
}

str
MANUALcreate1(int *ret, str *mod)
{
	(void) ret;		/* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, findModule(MCgetClient()->nspace, putName(*mod, strlen(*mod))), 0);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}

str
MANUALcreate0(int *ret)
{
	(void) ret;		/* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, MCgetClient()->nspace, 1);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str
MANUALcreateIndex(int *ret)
{
	(void) ret;		/* fool compiler */
	dumpManualOverview(GDKout, MCgetClient()->nspace, 1);
	return MAL_SUCCEED;
}
str
MANUALcreateSummary(int *ret)
{
	(void) ret;		/* fool compiler */
	dumpManualHelp(GDKout, MCgetClient()->nspace, 1);
	return MAL_SUCCEED;
}
str
MANUALcreateTags(int *ret)
{
	(void) ret;		/* fool compiler */
	dumpHelpTable(GDKout, MCgetClient()->nspace, 0,0);
	return MAL_SUCCEED;
}

str
MANUALcompletion(int *ret, str *text)
{
	(void) ret;		/* fool compiler */
	dumpHelpTable(GDKout, MCgetClient()->nspace, *text,1);
	return MAL_SUCCEED;
}

str
MANUALhelp(int *ret, str *text)
{
	char **msg;
	int i;

	(void) ret;		/* fool compiler */
	msg= getHelp(MCgetClient()->nspace,*text,1);
	if( msg && msg[0] ){
		for(i=0; msg[i];i++){
			mal_unquote(msg[i]);
			stream_printf(GDKout,"%s\n",msg[i]);
			GDKfree(msg[i]);
		}
	}
	if( msg) 
		GDKfree(msg);
	return MAL_SUCCEED;
}

str
MANUALsearch(int *ret, str *pat)
{
	char **msg;
	int i;
	(void) ret;
	msg= getHelpMatch(*pat);
	if( msg && msg[0] ){
		for(i=0; msg[i];i++){
			mal_unquote(msg[i]);
			stream_printf(GDKout,"%s\n",msg[i]+1);
			GDKfree(msg[i]);
		}
	}
	if( msg) 
		GDKfree(msg);
	return MAL_SUCCEED;
}

@}
