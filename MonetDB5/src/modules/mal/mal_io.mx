@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f mal_io
@a N.J. Nes, M.L. Kersten
@d 01/07/1996, 31/01/2002

@+ Input/Output module
The IO module provides simple @sc{ascii-io} rendering options.
It is modeled after the tuple formats, but does not
attempt to outline the results. Instead, it is geared at speed,
which also means that some functionality regarding the built-in
types is duplicated from the atoms definitions.

A functional limited form of formatted printf is also provided.
It accepts at most one variable.
A more complete approach is the tablet module.

The commands to load and save a BAT from/to an ASCII dump
are efficient, but work only for binary tables. 

@mal
module io;
pattern stdin():bstream
address io_stdin
comment "return the input stream to the database client";
pattern stderr():streams
address io_stderr
comment "return the error stream for the database console";
pattern stdout():streams
address io_stdout
comment "return the output stream for the database client";

pattern print(val:any_1,lst:any...):void 
address IOprint_val
comment "Print a MAL value tuple .";

pattern print(b1:bat[:any_1,:any]...):void 
address IOtable
comment "BATs are printed with '#' for legend 
	lines, and the BUNs on seperate lines 
	between brackets, containing each to 
	comma separated values (head and tail). 
	If multiple BATs are passed for printing, 
	print() performs an implicit natural 
	join, producing a multi attribute table.";

pattern ftable( filep:streams, b1:bat[:any_1,:any], b:bat[:any_1,:any]... ):void
address IOftable 
comment "Print an n-ary table to a file.";

pattern print(order:int,b:bat[:any_1,:any], b2:bat[:any_1,:any]...):void
address IOotable
comment "The same as normal table print, but 
	enforces to use the order of BAT 
	number [1..argc] to do the printing.";

pattern table(b1:bat[:any_1,:any], b2:bat[:any_1,:any]...):void 
address IOttable
comment "Print an n-ary table. Like print, but does not print oid column";

pattern table(order:int, b1:bat[:any_1,:any], b2:bat[:any_1,:any]...):void 
address IOtotable
comment "Print an n-ary table.";
pattern ftable(fp:streams, order:int, b1:bat[:any_1,:any], b:bat[:any_1,:any]...):void
address IOfotable 
comment "Print an n-ary table to a file.";

pattern print(val:any_1):void 
address IOprint_val
comment "Print a MAL value tuple .";
pattern print(val:bat[:any_1,:any_2]):void 
address IOprint_val
comment "Print a MAL value tuple .";

pattern prompt(val:any_1):void 
address IOprompt_val
comment "Print a MAL value without brackets.";
pattern printft(val:any_1):void 
address IOprint_ft
comment "Select default format ";

pattern printf(format:str,val:bit):void
address IOprint_formatted_bit;
pattern printf(format:str,val:chr):void
address IOprint_formatted_chr;
pattern printf(format:str,val:sht):void
address IOprint_formatted_sht;
pattern printf(format:str,val:int):void
address IOprint_formatted_int;
pattern printf(format:str,val:wrd):void
address IOprint_formatted_wrd;
pattern printf(format:str,val:oid):void
address IOprint_oid;
pattern printf(format:str,val:lng):void
address IOprint_formatted_lng;
pattern printf(format:str,val:flt):void
address IOprint_formatted_flt;
pattern printf(format:str,val:dbl):void
address IOprint_formatted_dbl;
pattern printf(format:str,val:str):void
address IOprint_formatted_str;
pattern printf(val:str):void
address IOprint_str;

command data(fname:str):str
address IOdatafile
comment "Signals receipt of tuples in a file fname.
It returns the name of the file, if it still exists.";

command export(b:bat[:any_1,:any_2], filepath:str):bit  
address IOexport
comment "Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it
 is put into the .../dbfarm/$DB directory. Success of failure is indicated.";

command import(b:bat[:any_1,:any_2], filepath:str) :bat[:any_1,:any_2] 
address IOimport
comment "Import a BAT from an ASCII dump. The new tuples are *inserted* into the
 parameter BAT. You have to create it! Its signature must match the dump,
 else parsing errors will occur and FALSE is returned.";

@-
@{
@* Implementation Code

The polymorphic print commands are collected here.
Watch out, the order of definitions is crucial, because the most
specific should be introduced last.
@h
#ifndef _PRINT_H_
#define _PRINT_H_

#include <mal.h>
#include <mal_instruction.h>
#include <mal_interpreter.h>

typedef struct {
	int up, down;
} bipipe;

typedef FILE *fstream;

#define fileCheck(fp) if (!fp) \
	throw(MAL,  "io.@1","Incorrect file pointer");

#ifdef WIN32
#ifndef LIBMAL_IO
#define io_export extern __declspec(dllimport)
#else
#define io_export extern __declspec(dllexport)
#endif
#else
#define io_export extern
#endif

io_export str IOprint_tables(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
io_export str IOtableAll(stream *f, Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,
int i, int order, int printhead, int printorderby);
io_export str IOprintBoth(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int indx,
str hd, str tl, int nobat);
io_export str IOprintBoth(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int indx,
str hd, str tl, int nobat);
io_export str IOprint_val(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
io_export str IOprint_tables(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
io_export str IOprompt_val(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOprint_ft(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOtableAll(stream *f, Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,
int i, int order, int printhead, int printorder);
io_export str IOotable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOtable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOfotable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOftable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOttable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOtotable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOprint_str(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@= PrintFormatted
io_export str IOprint_formatted_@1(Client cntxt, MalBlkPtr mb, MalStkPtr st, InstrPtr pci);
@h
@:PrintFormatted(bit)@
@:PrintFormatted(chr)@
@:PrintFormatted(sht)@
@:PrintFormatted(int)@
@:PrintFormatted(wrd)@
@:PrintFormatted(lng)@
@:PrintFormatted(flt)@
@:PrintFormatted(dbl)@
@:PrintFormatted(str)@
io_export str IOprint_oid(Client cntxt, MalBlkPtr mb, MalStkPtr st, InstrPtr pci);
io_export str IOexport(bit *ret, int *bid, str *fnme);
io_export str IOdatafile(str *ret, str *fnme);
io_export str IOimport(int *ret, int *bid, str *fnme);
io_export str io_stdin(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str io_stdout(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str io_stderr(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* _PRINT_H_ */

@+ Printing
The print commands are implemented as single instruction rules,
because they need access to the calling context.
At a later stage we can look into the issues related to
parsing the format string as part of the initialization phase.
The old method in V4 essentially causes a lot of overhead
because you have to prepare for the worst (e.g. mismatch format
identifier and argument value)
Beware, the types of the objects to be printed should be
obtained from the stack, because the symbol table may actually
allow for any type to be assigned.
@c
#include "mal_config.h"
#include "mal_io.h"

#define MAXFORMAT 64*1024

str
io_stdin(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bstream **ret= (bstream**) getArgReference(stk,pci,0);
	(void) mb;
	*ret = cntxt->fdin;
	return MAL_SUCCEED;
}

str
io_stdout(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream **ret= (stream**) getArgReference(stk,pci,0);
	(void) mb;
	*ret = cntxt->fdout;
	return MAL_SUCCEED;
}

str
io_stderr(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream **ret= (stream**) getArgReference(stk,pci,0);
	(void) cntxt;
	(void) mb;
	*ret = GDKerr;
	return MAL_SUCCEED;
}

str
IOprintBoth(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int indx, str hd, str tl, int nobat)
{
	int tpe = getArgType(mb, pci, indx);
	ptr val = (ptr) getArgReference(stk, pci, indx);
	stream *fp = cntxt->fdout;

	(void) mb;

	if (tpe == TYPE_any)
		tpe = stk->stk[pci->argv[indx]].vtype;
	if (val == NULL || tpe == TYPE_void) {
		if (hd)
			stream_printf(fp, "%s", hd);
		stream_printf(fp, "nil");
		if (tl)
			stream_printf(fp, "%s", tl);
		return MAL_SUCCEED;
	}
	if (isaBatType(tpe) ) {
		BAT *b;

		if (*(int *) val == 0) {
			if (hd)
				stream_printf(fp, "%s", hd);
			stream_printf(fp,"nil");
			if (tl)
				stream_printf(fp, "%s", tl);
			return MAL_SUCCEED;
		}
		b = BATdescriptor(*(int *) val);
		if (b == NULL) {
			throw(MAL, "io.print", "Could not access descriptor");
		}
		if (nobat) {
			if (hd)
				stream_printf(fp, "%s", hd);
			stream_printf(fp, "<%s>", BBPname(b->batCacheid));
			if (tl)
				stream_printf(fp, "%s", tl);
		} else
			BATmultiprintf(cntxt->fdout, 2, &b, TRUE, 0, TRUE);
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	if (hd)
		stream_printf(fp, "%s", hd);

	if (ATOMvarsized(tpe))
		ATOMprint(tpe, *(str *) val, fp);
	else
		ATOMprint(tpe, val, fp);

	if (tl)
		stream_printf(fp, "%s", tl);
	return MAL_SUCCEED;
}

str
IOprint_val(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i;

	(void) cntxt;
	if (p->argc == 2)
		IOprintBoth(cntxt, mb, stk, p, 1, "[ ", " ]\n", 0);
	else {
		IOprintBoth(cntxt, mb, stk, p, 1, "[ ", 0, 1);
		for (i = 2; i < p->argc - 1; i++)
			IOprintBoth(cntxt,mb, stk, p, i, ", ", 0, 1);
		IOprintBoth(cntxt,mb, stk, p, i, ", ", "]\n", 1);
	}
	return MAL_SUCCEED;

}

str
IOprint_tables(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	IOtableAll(cntxt->fdout, cntxt, mb, stk, p, 1, 0, FALSE, TRUE);
	return MAL_SUCCEED;
}

str
IOprompt_val(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return IOprintBoth(cntxt, mb, stk, pci, 1, 0, 0, 1);
}

str
IOprint_ft(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb, pci, 1);
	ptr val = (ptr) getArgReference(stk, pci, 1);

	if (val == NULL) {
		ATOMprint(TYPE_str, "nil", cntxt->fdout);
		return MAL_SUCCEED;
	}
	if (tpe == TYPE_str)
		ATOMprint(TYPE_str, *(str *) val, cntxt->fdout);
	else
		ATOMprint(tpe, val, cntxt->fdout);
	return MAL_SUCCEED;
}

@-
The table printing routine implementations rely on the multiprintf.
They merely differ in destination and order prerequisite
@c
str
IOtableAll(stream *f, Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int i, int order, int printhead, int printorder)
{
	BAT *piv[MAXPARAMS], *b;
	int nbats = 0;
	int tpe, k = i;
	ptr val;

	(void) cntxt;
	for (; i < pci->argc; i++) {
		tpe = getArgType(mb, pci, i);
		val = (ptr) getArgReference(stk, pci, i);
		if (!isaBatType(tpe))
			throw(MAL, "io.table", "BAT expected");
		b = BATdescriptor(*(int *) val);
		if (b == NULL) {
			for (k = 0; k < nbats; k++)
				BBPunfix(piv[k]->batCacheid);
			throw(MAL, "io.table", "Could not access descriptor");
		}
		piv[nbats++] = b;
	}
	/*if(printhead) */ nbats++;
	BATmultiprintf(f, nbats, piv, printhead, order, printorder);
	for (k = 0; k < nbats - 1; k++)
		BBPunfix(piv[k]->batCacheid);
	return MAL_SUCCEED;
}

str
IOotable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int order;
	order = *(int *) getArgReference(stk, pci, 1);
	return IOtableAll(cntxt->fdout, cntxt, mb, stk, pci, 2, order, TRUE, TRUE);
}

str
IOtable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return IOtableAll(cntxt->fdout, cntxt, mb, stk, pci, 1, 0, TRUE, TRUE);
}

str
IOfotable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream *fp;
	int order;

	fp = *(stream **) getArgReference(stk, pci, 1);
	order = *(int *) getArgReference(stk, pci, 2);
	(void) order;		/* fool compiler */
	return IOtableAll(fp, cntxt, mb, stk, pci, 3, 1, TRUE, TRUE);
}

str
IOftable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream *fp;

	fp = *(stream **) getArgReference(stk, pci, 1);
	return IOtableAll(fp, cntxt, mb, stk, pci, 2, 0, TRUE, TRUE);
}

str
IOttable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return IOtableAll(cntxt->fdout, cntxt, mb, stk, pci, 1, 0, FALSE, TRUE);
}

str
IOtotable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int order;
	order = *(int *) getArgReference(stk, pci, 1);
	(void) order;		/* fool compiler */
	return IOtableAll(cntxt->fdout, cntxt, mb, stk, pci, 2, order, FALSE, TRUE);
}

@- Formatter print
The format string is scrutinized using VALsprintf in the GDK library
to avoid that passing a wrong argument (e.g. NULL pointer) kills the server.
The generic printf function is rather expensive. Ideally it should be
replaced by a squeezer into a type-specific function calls.
@-
Formatted print statements are to be broken down into its constituents.
This avoids repeated type checking in most cases.

@= escaped
	switch(*c){
	case 'n': stream_printf(fd,"\n");break;
	case 't': stream_printf(fd,"\t");break;
	case 'r': stream_printf(fd,"\r");break;
	case '\\': stream_printf(fd,"\\");break;
	default : stream_printf(fd,"\\");stream_printf(fd,"%c",*c);
	}
@c
str
IOprint_str(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream *fd = cntxt->fdout;
	str *s= (str*) getArgReference(stk,pci,1);
	str c;
	(void) mb;

	if (strNil(*s))
		stream_printf(fd, "nil");
	else {
		for (c = *s; *c; c++) {
			if (*c == '\\') {
				c++;
				@:escaped@
			} else
				stream_printf(fd, "%c", *c);
		}
	}
	return MAL_SUCCEED;
}

int
formatMarker(str format,str m)
{
	int i = 0;
	str t = format;

	while ((t = strchr(t, '%')) != NULL) {
		t++;
		while ( t && !isalpha((int) *t) ) t++;
		/* gcc 4.0.0 on MacOS X 10.4 (Darwin 8.11.0) *
		 * does not like "strlen(m+1)" in case m=="" */
		if (*m && strncmp(t, m+1, strlen(m) - 1) )
			i++; /* indicate error */
		i++;
	}
	return i;
}

@-
Printing format values is limited to a single element each.
This to simplify error handling
@= formatConversion
	for(c= format;*c; c++){
		if( *c=='\\'){
			c++;
			@:escaped@
			continue;
		} 
		if( *c!= '%'){
			stream_printf(fd,"%c",*c);
			continue;
		}
		if(*(c+1)=='%'){ 
			stream_printf(fd,"%c",*c);
			c++; continue;
		}
		if (strncmp(@2,c,strlen(@2)))
			throw(MAL, "io.print", "Format limitation," @2" expected");
		stream_printf(fd,@2,@1);
		c+= strlen(@2)-1;
	}
@-
String nil testing is slightly different.
@c
static str
IOprint_formatted_nil(stream *fd, str format)
{
	str c,s,f;
	str new= (str) alloca(strlen(format)+1);

	strcpy(new,format);
	for (c = new; *c; c++) {
		if (*c == '\\') {
			c++;
			@:escaped@
			continue;
		} 
		if (*c != '%') {
			stream_printf(fd, "%c", *c);
			continue;
		}
		if (*(c + 1) == '%') {
			stream_printf(fd, "%c", *c);
			c++;
			continue;
		}
		f=c+1;
		if (*f== '+' || *f== '-') f++;
		while (isdigit((int) *f) ) f++;
		s= f;
		if (*f =='.' ) f++;
		while (isdigit((int) *f) ) f++;
		while (*f =='l' ) f++;
		if (*f =='d' || *f == 'f' || *f =='s' || *f == 'c'){
			*s++='s';
			while (*++f ) *s++ = *f;
			*s = 0;
			stream_printf(fd,c,"nil");
			break;
		} else throw(MAL, "io.print", "Format limitation");
	}
	return MAL_SUCCEED;
}
@= printFormatted
str IOprint_formatted_@1(Client cntxt, MalBlkPtr mv, MalStkPtr stk, InstrPtr pci)
{
	str *fmt = (str *) getArgReference(stk,pci,1);
	@1 *val = (@1 *) getArgReference(stk,pci,2);
	stream *fd = cntxt->fdout;
	char *format;
	char buf[MAXFORMAT];

	(void) cntxt;
	(void) mv;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL || format== str_nil) 
		throw(MAL, "io.print", "Format missing");
	if( formatMarker(format,@2)!=1) 
		throw(MAL, "io.print", "Format error, expected %%%s\n",@2);

	if( *val == @1_nil) 
		return IOprint_formatted_nil(fd,* (str*) fmt);
	if (snprintf(buf, MAXFORMAT, *fmt,*val) < 0){
		throw(MAL, "io.print", "Format error, %%%s expected and < 64K", @2);
	} else
		stream_printf(fd,*fmt, (@1)*val);
	return MAL_SUCCEED;
}
@c
@:printFormatted(chr,"%c")@
@:printFormatted(sht,"%d")@
@:printFormatted(int,"%d")@
@:printFormatted(wrd,"%d")@
@:printFormatted(flt,"%f")@
@:printFormatted(dbl,"%f")@
#ifdef WIN32
@:printFormatted(lng,"%I64d")@	
#else
@:printFormatted(lng,LLFMT)@	
#endif


str
IOprint_formatted_str(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream *fd = cntxt->fdout;
	ptr fmt = (ptr) getArgReference(stk,pci,1);
	str *val = (str *) getArgReference(stk,pci,2);
	char *format;
	char buf[MAXFORMAT];
	
	(void) cntxt;
	(void) mb;

	/* TODO: check format properly !!! including sizes */
	format = *(str *) fmt;
	if (format == NULL)
		throw(MAL, "io.print", "Format missing");
	if (formatMarker(format,"%s") != 1)
		throw(MAL, "io.print", "Format error");

	if (strNil(*val))
		return IOprint_formatted_nil(fd, *(str *) fmt);
	if (snprintf(buf, MAXFORMAT, format,*val) < 0){
		throw(MAL, "io.print", "Format error, %s expected");
	} else
		stream_printf(fd,format,*val);
	return MAL_SUCCEED;
}

str
IOprint_oid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream *fd = cntxt->fdout;
	int *ret= (int*) getArgReference(stk,pci,0);
	ptr fmt = (ptr) getArgReference(stk,pci,1);
	oid *s = (oid*) getArgReference(stk,pci,2);
	char *format;
	str msg, c;
	int len = 50;

	(void) mb;
	format = *(str *) fmt;

	if (format == NULL)
		throw(MAL, "io.print", "Format missing");
	if (formatMarker(format,"%d") != 1)
		throw(MAL, "io.print", "Format error");

	if (*s == oid_nil)
		msg = GDKstrdup("nil");
	else {
		msg = (str) GDKmalloc(len);
		OIDtoStr(&msg, &len, s);
	}
	@:formatConversion(msg,"%s")@
	GDKfree(msg);
	if (*ret == EOF)
		throw(MAL, "io.print", "End-of-file encountered");
	return MAL_SUCCEED;
}

str
IOprint_formatted_bit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret= (ptr) getArgReference(stk,pci,0);
	ptr fmt= (ptr) getArgReference(stk,pci,1);
	bit *s= (bit*) getArgReference(stk,pci,2);
	stream *fd = cntxt->fdout;
	char *format;
	str msg;
	char buf[MAXFORMAT];

	(void) cntxt;
	(void) mb;
	/* TODO: check format properly !!! including sizes */
	format = *(str *) fmt;
	if (format == NULL)
		throw(MAL, "io.print", "Format missing");
	if (formatMarker(format,"%s") != 1)
		throw(MAL, "io.print", "Format error");

	if (*s == bit_nil)
		return IOprint_formatted_nil(fd, *(str *) fmt);
	if (*s)
		msg = "true";
	else
		msg = "false";
	if (snprintf(buf, MAXFORMAT, format,msg) < 0){
		throw(MAL, "io.print", "Format error, %s expected");
	} else
		stream_printf(fd,format,msg);
	if (*ret == EOF)
		throw(MAL, "io.print", "End-of-file encountered");
	return MAL_SUCCEED;
}

@-
@+ Bulk export/loading
To simplify conversion between versions and to interface with other
applications, we use a simple import/export operation.

The conversion routine assumes space in the buffer for storing the result.
@{
@include prelude.mx
@-
A BAT can be saved in Monet format using the export command.
It is of particular use in preparing an ASCII version for migration.
The exported file is saved in the context of the directory
where the server was started unless an absolute file name was
presented.
@c
str
IOdatafile(str *ret, str *fnme){
	stream *s = open_rstream(*fnme);
	if (s == NULL || stream_errnr(s)) {
		*ret = 0;
		throw(MAL, "io.export", "Could not open file");
	}
	*ret= GDKstrdup(*fnme);
	stream_close(s);
	stream_destroy(s);
	return MAL_SUCCEED;
}

str
IOexport(bit *ret, int *bid, str *fnme)
{
	BAT *b;
	stream *s = open_wastream(*fnme);

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "io.export", "Cannot access descriptor");
	}
	if (s == NULL || stream_errnr(s)) {
		*ret = FALSE;
		throw(MAL, "io.export", "Could not open file");
	}
	BATprintf(s, b);
	stream_close(s);
	stream_destroy(s);
	*ret = TRUE;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@-
The import command reads a single BAT from an ASCII file. It assumes
a layout compatible with that produced by print or export.
@c
#define COMMA ','
str
IOimport(int *ret, int *bid, str *fnme)
{
	BAT *b;
	int (*hconvert) (str, int *, ptr *), (*tconvert) (str, int *, ptr *);
	size_t bufsize = 2048;	/* NIELS:tmp change used to be 1024 */
	char *base, *cur, *end;
	char *buf = (char *) GDKmalloc(bufsize);
	ptr h = 0, t = 0;
	int lh = 0, lt = 0;
	FILE *fp = fopen(*fnme, "r");

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "io.import", "Cannot access descriptor");
	}
	hconvert = BATatoms[BAThtype(b)].atomFromStr;
	tconvert = BATatoms[BATttype(b)].atomFromStr;
@-
Open the file. Memory map it to minimize buffering problems.
@c
	if (fp == NULL) {
		BBPunfix(b->batCacheid);
		throw(MAL, "io.import", "Could not open file");
	} else {
		int fn;
		struct stat st;

		if ((fn = fileno(fp)) <= 0) {
			BBPunfix(b->batCacheid);
			throw(MAL, "io.import", "Fileno fails");
		}
		if (fstat(fn, &st) != 0) {
			BBPunfix(b->batCacheid);
			throw(MAL, "io.imports", "Fstat fails");
		}

		(void) fclose(fp);
		if (st.st_size <= 0) {
			BBPunfix(b->batCacheid);
			throw(MAL, "io.imports", "File is empty or fstat broken");
		}
		base = cur = (char *) MT_mmap(*fnme, MMAP_SEQUENTIAL, 0, st.st_size);
		end = cur + st.st_size;
		if (cur == (char *) -1) {
			BBPunfix(b->batCacheid);
			throw(MAL, "io.mport", "MT_mmap failed");
		}

	}
@-
Parse a line. Copy it into a buffer. Concat broken lines with a slash.
@c
	while (cur < end) {
		str dst = buf, src = cur, p = strchr(cur, '\n');
		size_t l = p - cur;

		if (!p) {
			p = end;
		} else
			while (src[l - 1] == '\\') {
				@:memcpy@
				dst += l - 1;
				src += l + 1;
				if ((p = strchr(src, '\n')) == 0) {
					p = end;
					break;
				}
				l = p - src;
			}
		@:memcpy@
@-
@= memcpy
		if (buf+bufsize < dst+l) {
			size_t len = dst - buf;
			size_t inc = (size_t) ((dst+l) - buf);
			buf = (char*) GDKrealloc((void*) buf, bufsize = MAX(inc,bufsize)*2);
			dst = buf + len;
		}
		memcpy(dst, src, l-1);
@c
		dst[l] = 0;
		cur = p + 1;
@-
Parse the line, and insert a BUN.
@c
		for (p = buf; *p && GDKisspace(*p); p++)
			;
		if (*p == '#')
			continue;
@-
@= parsevalue
		for (;*p && *p != @2; p++);
		if (*p) for (p++; *p && GDKisspace(*p); p++);
		if (*p == 0) {
			char msg[BUFSIZ];
			BBPunfix(*ret=b->batCacheid);
			snprintf(msg,BUFSIZ,"error in input %s",buf);
			throw(MAL,  "io.import", msg);
		}
		p += @1(p, @3, @4);
@c
		@:parsevalue(hconvert,'[',&lh,(ptr *) &h)@
		@:parsevalue(tconvert,COMMA,&lt,(ptr *) &t)@
		BUNins(b, h, t, FALSE);

@-
Unmap already parsed memory, to keep the memory usage low.
@c
#ifndef WIN32
#define MAXBUF 40*MT_pagesize()
		if ((unsigned) (cur - base) > MAXBUF) {
			MT_munmap(base, MAXBUF);
			base += MAXBUF;
		}
#endif
	}
@-
Cleanup and exit. Return the filled BAT.
@c
	if (h)
		GDKfree(h);
	if (t)
		GDKfree(t);
	GDKfree(buf);
	MT_munmap(base, end - base);
	BBPkeepref(*ret= b->batCacheid);
	return MAL_SUCCEED;
}

@}
