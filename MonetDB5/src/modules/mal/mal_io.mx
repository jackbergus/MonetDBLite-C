@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_io
@a N.J. Nes, M.L. Kersten
@d 01/07/1996, 31/01/2002

@+ Input/Output module
The IO module provides simple ASCII-io rendering options.
It is modeled after the tuple formats, but does not
attempt to outline the results. Instead, it is geared at speed,
which also means that some functionality regarding the built-in
types is duplicated from the atoms definitions.

A functional limited form of formatted printf is also provided.
It accepts at most one variable.
A more complete approach is the tablet module.

The commands to load and save a BAT from/to an ASCII dump
are efficient, but work only for binary tables. 

@mal
module io;
command stdin():bstream
address io_stdin
comment "return the input stream to the database client";
command stderr():streams
address io_stderr
comment "return the error stream for the database console";
command stdout():streams
address io_stdout
comment "return the output stream for the database client";

pattern print{unsafe}(val:any_1,lst:any...):int 
address IOprint_val
comment "Print a MAL value tuple .";

pattern print{unsafe}(b1:bat[:any_1,:any]...):int 
address IOtable
comment "BATs are printed with '#' for legend 
	lines, and the BUNs on seperate lines 
	between brackets, containing each to 
	comma separated values (head and tail). 
	If multiple BATs are passed for printing, 
	print() performs an implicit natural 
	join, producing a multi attribute table.";

pattern ftable{unsafe}( filep:streams, b1:bat[:any_1,:any], b:bat[:any_1,:any]... ):int
address IOftable 
comment "Print an n-ary table to a file.";

pattern print{unsafe}(order:int,b:bat[:any_1,:any], b2:bat[:any_1,:any]...):int
address IOotable
comment "The same as normal table print, but 
	enforces to use the order of BAT 
	number [1..argc] to do the printing.";

pattern table{unsafe}(b1:bat[:any_1,:any], b2:bat[:any_1,:any]...):int 
address IOttable
comment "Print an n-ary table. Like print, but does not print oid column";

pattern table{unsafe}(order:int, b1:bat[:any_1,:any], b2:bat[:any_1,:any]...):int 
address IOtotable
comment "Print an n-ary table.";
pattern ftable{unsafe}(fp:streams, order:int, b1:bat[:any_1,:any], b:bat[:any_1,:any]...)
address IOfotable 
comment "Print an n-ary table to a file.";

pattern print{unsafe}(val:any_1):int 
address IOprint_val
comment "Print a MAL value tuple .";
pattern print{unsafe}(val:bat[:any_1,:any_2]):int 
address IOprint_val
comment "Print a MAL value tuple .";

pattern prompt{unsafe}(val:any_1):int 
address IOprompt_val
comment "Print a MAL value without brackets.";
pattern printft{unsafe}(val:any_1):int 
address IOprint_ft
comment "Select default format ";

command printf{unsafe}(format:str,val:bit):int
address IOprint_formatted_bit;
command printf{unsafe}(format:str,val:chr):int
address IOprint_formatted_chr;
command printf{unsafe}(format:str,val:int):int
address IOprint_formatted_int;
command printf{unsafe}(format:str,val:sht):int
address IOprint_formatted_sht;
command printf{unsafe}(format:str,val:oid):int
address IOprint_oid;
command printf{unsafe}(format:str,val:lng):int
address IOprint_formatted_lng;
command printf{unsafe}(format:str,val:flt):int
address IOprint_formatted_flt;
command printf{unsafe}(format:str,val:dbl):int
address IOprint_formatted_dbl;
command printf{unsafe}(val:str):int
address IOprint_str;
command printf{unsafe}(format:str,val:str):int
address IOprint_formatted_str;

command export{unsafe}(b:bat[:any_1,:any_2], filepath:str):bit  
address IOexport
comment "Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it
 is put into the .../dbfarm/$DB directory. Success of failure is indicated.";

command import{unsafe}(b:bat[:any_1,:any_2], filepath:str) :bit 
address IOimport
comment "Import a BAT from an ASCII dump. The new tuples are *inserted* into the
 parameter BAT. You have to create it! Its signature must match the dump,
 else parsing errors will occur and FALSE is returned.";

@-
@{
@* Implementation Code

The polymorphic print commands are collected here.
Watch out, the order of definitions is crucial, because the most
specific should be introduced last.
@h
#ifndef _PRINT_H_
#define _PRINT_H_

#include <mal.h>
#include <mal_interpreter.h>
#include <blob.h>

typedef struct {
	int up, down;
} bipipe;

typedef FILE *fstream;

#define fileCheck(fp) if (!fp) \
	return throwMessage( "io.@1","Incorrect file pointer");

#ifdef WIN32
#ifndef LIBIO
#define io_export extern __declspec(dllimport)
#else
#define io_export extern __declspec(dllexport)
#endif
#else
#define io_export extern
#endif

io_export str IOprint_tables(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
io_export str IOtableAll(stream *f, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,
int i, int order, int printhead, int printorderby);
io_export str IOprintBoth(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int indx,
str hd, str tl, int nobat);
io_export str IOprint_formatted_nil(stream *fd, str format, char last);
io_export str IOprintBoth(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int indx,
str hd, str tl, int nobat);
io_export str IOprint_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
io_export str IOprint_tables(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
io_export str IOprompt_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOprint_ft(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOtableAll(stream *f, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci,
int i, int order, int printhead, int printorder);
io_export str IOotable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOtable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOfotable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOftable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOttable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOtotable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
io_export str IOprint_str(int *ret, str *s);
io_export str IOprint_formatted_nil(stream *fd, str format, char last);
io_export str IOprint_formatted_lng(int *ret, str *format, lng *val);
io_export str IOprint_formatted_str(int *ret, ptr fmt, str *s);
io_export str IOprint_oid(int *ret, ptr fmt, oid *s);
io_export str IOprint_formatted_bit(int *ret, ptr fmt, bit *s);
io_export str IOexport(int *ret, int *bid, str *fnme);
io_export str IOimport(int *ret, int *bid, str *fnme);
io_export str io_stdin(bstream **ret);
io_export str io_stdout(stream **ret);
io_export str io_stderr(stream **ret);

#endif /* _PRINT_H_ */

@+ Printing
The print commands are implemented as single instruction rules,
because they need access to the calling context.
At a later stage we can look into the issues related to
parsing the format string as part of the initialization phase.
The old method in V4 essentially causes a lot of overhead
because you have to prepare for the worst (e.g. mismatch format
identifier and argument value)
Beware, the types of the objects to be printed should be
obtained from the stack, because the symbol table may actually
allow for any type to be assigned.
@c
#include "mal_io.h"

str
io_stdin(bstream **ret)
{
	*ret = (bstream*)GDKin;
	return MAL_SUCCEED;
}

str
io_stdout(stream **ret)
{
	*ret = GDKout;
	return MAL_SUCCEED;
}

str
io_stderr(stream **ret)
{
	*ret = GDKerr;
	return MAL_SUCCEED;
}

str
IOprintBoth(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int indx, str hd, str tl, int nobat)
{
	int tpe = getArgType(mb, pci, indx);
	ptr val = (ptr) getArgReference(stk, pci, indx);
	stream *fp = GDKout;

	(void) mb;

	if (tpe == TYPE_any)
		tpe = stk->stk[pci->argv[indx]].vtype;
	if (val == NULL || tpe == TYPE_void) {
		if (hd)
			stream_printf(fp, "%s", hd);
		stream_printf(fp, "nil");
		if (tl)
			stream_printf(fp, "%s", tl);
		return MAL_SUCCEED;
	}
	if (isaBatType(tpe) ) {
		BAT *b;

		if (*(int *) val == 0) {
			if (hd)
				stream_printf(fp, "%s", hd);
			stream_printf(fp,"nil");
			if (tl)
				stream_printf(fp, "%s", tl);
			return MAL_SUCCEED;
		}
		b = BATdescriptor(*(int *) val);
		if (b == NULL) {
			return throwMessage("io.print", "Could not access descriptor");
		}
		if (nobat) {
			if (hd)
				stream_printf(fp, "%s", hd);
			stream_printf(fp, "<%s>", BBPname(b->batCacheid));
			if (tl)
				stream_printf(fp, "%s", tl);
		} else
			BATmultiprintf(GDKout, 2, &b, TRUE, 0, TRUE);
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	if (isaColType(tpe)) {
		stream_printf(fp, "should call column pring\n");
		return MAL_SUCCEED;
	}
	if (hd)
		stream_printf(fp, "%s", hd);

	if (ATOMstorage(tpe) == TYPE_str || ATOMstorage(tpe) > TYPE_str)
		ATOMprint(tpe, *(str *) val, fp);
	else
		ATOMprint(tpe, val, fp);

	if (tl)
		stream_printf(fp, "%s", tl);
	return MAL_SUCCEED;
}

str
IOprint_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i;

	if (p->argc == 2)
		IOprintBoth(mb, stk, p, 1, "[ ", " ]\n", 0);
	else {
		IOprintBoth(mb, stk, p, 1, "[ ", 0, 1);
		for (i = 2; i < p->argc - 1; i++)
			IOprintBoth(mb, stk, p, i, ", ", 0, 1);
		IOprintBoth(mb, stk, p, i, ", ", "]\n", 1);
	}
	return MAL_SUCCEED;

}

str
IOprint_tables(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	IOtableAll(GDKout, mb, stk, p, 1, 0, FALSE, TRUE);
	return MAL_SUCCEED;
}

str
IOprompt_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return IOprintBoth(mb, stk, pci, 1, 0, 0, 1);
}

str
IOprint_ft(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb, pci, 1);
	ptr val = (ptr) getArgReference(stk, pci, 1);

	if (val == NULL) {
		ATOMprint(TYPE_str, "nil", GDKout);
		return MAL_SUCCEED;
	}
	if (tpe == TYPE_str)
		ATOMprint(TYPE_str, *(str *) val, GDKout);
	else
		ATOMprint(tpe, val, GDKout);
	return MAL_SUCCEED;
}

@-
The table printing routine implementations rely on the multiprintf.
They merely differ in destination and order prerequisite
@c
str
IOtableAll(stream *f, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int i, int order, int printhead, int printorder)
{
	BAT *piv[MAXPARAMS], *b;
	int nbats = 0;
	int tpe, k = i;
	ptr val;

	for (; i < pci->argc; i++) {
		tpe = getArgType(mb, pci, i);
		val = (ptr) getArgReference(stk, pci, i);
		if (!isaBatType(tpe))
			return throwMessage("io.table", "BAT expected");
		b = BATdescriptor(*(int *) val);
		if (b == NULL) {
			for (k = 0; k < nbats; k++)
				BBPunfix(piv[k]->batCacheid);
			return throwMessage("io.table", "Could not access descriptor");
		}
		piv[nbats++] = b;
	}
	/*if(printhead) */ nbats++;
	BATmultiprintf(f, nbats, piv, printhead, order, printorder);
	for (k = 0; k < nbats - 1; k++)
		BBPunfix(piv[k]->batCacheid);
	return MAL_SUCCEED;
}

str
IOotable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int order;

	order = *(int *) getArgReference(stk, pci, 1);
	return IOtableAll(GDKout, mb, stk, pci, 2, order, TRUE, TRUE);
}

str
IOtable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return IOtableAll(GDKout, mb, stk, pci, 1, 0, TRUE, TRUE);
}

str
IOfotable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream *fp;
	int order;

	fp = *(stream **) getArgReference(stk, pci, 1);
	order = *(int *) getArgReference(stk, pci, 2);
	(void) order;		/* fool compiler */
	return IOtableAll(fp, mb, stk, pci, 3, 1, TRUE, TRUE);
}

str
IOftable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream *fp;

	fp = *(stream **) getArgReference(stk, pci, 1);
	return IOtableAll(fp, mb, stk, pci, 2, 0, TRUE, TRUE);
}

str
IOttable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return IOtableAll(GDKout, mb, stk, pci, 1, 0, FALSE, TRUE);
}

str
IOtotable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int order;

	order = *(int *) getArgReference(stk, pci, 1);
	(void) order;		/* fool compiler */
	return IOtableAll(GDKout, mb, stk, pci, 2, order, FALSE, TRUE);
}

@- Formatter print
The format string is scrutinized using VALsprintf in the GDK library
to avoid that passing a wrong argument (e.g. NULL pointer) kills the server.
The generic printf function is rather expensive. Ideally it should be
replaced by a squeezer into a type-specific function calls.
@-
Formatted print statements are to be broken down into its constituents.
This avoids repeated type checking in most cases.

@= escaped
	switch(*c){
	case 'n': stream_printf(fd,"\n");break;
	case 't': stream_printf(fd,"\t");break;
	case 'r': stream_printf(fd,"\r");break;
	case '\\': stream_printf(fd,"\\");break;
	default : stream_printf(fd,"\\");stream_printf(fd,"%c",*c);
	}
@c
str
IOprint_str(int *ret, str *s)
{
	stream *fd = GDKout;
	str c;
	(void) ret;

	if (strNil(*s))
		stream_printf(fd, "nil");
	else {
		for (c = *s; *c; c++) {
			if (*c == '\\') {
				c++;
				@:escaped@
			} else
				stream_printf(fd, "%c", *c);
		}
	}
	return MAL_SUCCEED;
}

int
formatMarker(str format)
{
	int i = 0;
	str t = format;

	while ((t = strchr(t, '%')) != NULL) {
		t++;
		i++;
	}
	return i;
}

@-
Printing format values is limited to a single element each.
This to simplify error handling
@= formatConversion
	for(c= format;*c; c++){
		if( *c=='\\'){
			c++;
			@:escaped@
		} else 
		if( *c== '%'){
			char newformat[1024];
			int i=0;

			if(*(c+1)=='%'){ 
				stream_printf(fd,"%c",*c);
				c++; continue;
			}
			while(*c != '@1' && *c && i<1024)
				 newformat[i++]= *c++;
			newformat[i++]='@1';
			newformat[i]=0;
			if(*c!= '@1') 
			return throwMessage("io.print", "Format limitation");
			else  stream_printf(fd,newformat,@2);
		} else stream_printf(fd,"%c",*c);
	}
@-

@= printFormatted
io_export str IOprint_formatted_@1(int *ret, ptr fmt, @1 *s);
str IOprint_formatted_@1(int *ret, ptr fmt, @1 *s){
	stream *fd = MCgetClient()->fdout;
	char *format;
	str c;
	(void) ret;
	/* TODO: check format properly !!! including sizes */
	format= *(str *)fmt;
	if( format== NULL || format== str_nil) 
		return throwMessage("io.print", "Format missing");
	if( formatMarker(format)!=1) 
		return throwMessage("io.print", "Too many %%");

	if( *s == @1_nil) 
		return IOprint_formatted_nil(fd,* (str*) fmt, '@2');
	@:formatConversion(@2,*s)@
	return MAL_SUCCEED;
}
@c
@:printFormatted(chr,c)@
@:printFormatted(sht,d)@
@:printFormatted(int,d)@
@:printFormatted(flt,f)@
@:printFormatted(dbl,f)@

@-
String nil testing is slightly different.
@c
str
IOprint_formatted_nil(stream *fd, str format, char last)
{
	str c;

	for (c = format; *c; c++) {
		if (*c == '\\') {
			c++;
			@:escaped@
		} else if (*c == '%') {
			char newformat[1024];
			int i = 0;

			if (*(c + 1) == '%') {
				stream_printf(fd, "%c", *c);
				c++;
				continue;
			}
			while (!isalpha((int) *c) && *c && *c != last && i < 1024)
				newformat[i++] = *c++;
			newformat[i++] = 's';
			newformat[i] = 0;
			stream_printf(fd, newformat, "nil");
		} else
			stream_printf(fd, "%c", *c);
	}
	return MAL_SUCCEED;
}
str
IOprint_formatted_lng(int *ret, str *format, lng *val)
{
	str c;
	stream *fd= MCgetClient()->fdout;
	(void) ret;

	for (c = *format; *c; c++) {
		if (*c == '\\') {
			c++;
			@:escaped@
		} else if (*c == '%') {
			char newformat[1024];
			int i = 0;

			if (*(c + 1) == '%') {
				stream_printf(fd, "%c", *c);
				c++;
				continue;
			}
			while (!isalpha((int) *c) && *c && i < 1024)
			if( *c =='d' ) {
				break;
			} else
			if( *c=='l' && c[1]=='d') {
				c++;
				break;
			} else
				newformat[i++] = *c++;

			if( *val == lng_nil){
				newformat[i++] = 's';
				newformat[i] = 0;
				stream_printf(fd, newformat, "nil");
			} else {
				char *f= LLFMT;
				strcpy(newformat+i,f+1);
				stream_printf(fd, newformat, *val);
			}
		} else
			stream_printf(fd, "%c", *c);
	}
	return MAL_SUCCEED;
}

str
IOprint_formatted_str(int *ret, ptr fmt, str *s)
{
	stream *fd = MCgetClient()->fdout;
	char *format;
	str c;
	(void) ret;

	/* TODO: check format properly !!! including sizes */
	format = *(str *) fmt;
	if (format == NULL)
		return throwMessage("io.print", "Format missing");
	if (formatMarker(format) != 1)
		return throwMessage("io.print", "Too many %%");

	if (strNil(*s))
		return IOprint_formatted_nil(fd, *(str *) fmt, 's');
	@:formatConversion(s,*s)@
	return MAL_SUCCEED;
}

str
IOprint_oid(int *ret, ptr fmt, oid *s)
{
	stream *fd = MCgetClient()->fdout;
	char *format;
	str msg, c;
	int len = 50;

	format = *(str *) fmt;

	if (format == NULL)
		return throwMessage("io.print", "Format missing");
	if (formatMarker(format) != 1)
		return throwMessage("io.print", "Too many %%");

	if (*s == oid_nil)
		msg = GDKstrdup("nil");
	else {
		msg = (str) GDKmalloc(len);
		OIDtoStr(&msg, &len, s);
	}
	@:formatConversion(s,msg)@
	GDKfree(msg);
	if (*ret == EOF)
		return throwMessage("io.print", "End-of-file encountered");
	return MAL_SUCCEED;
}

str
IOprint_formatted_bit(int *ret, ptr fmt, bit *s)
{
	stream *fd = MCgetClient()->fdout;
	char *format;
	str msg;
	str c;

	/* TODO: check format properly !!! including sizes */
	format = *(str *) fmt;
	if (format == NULL)
		return throwMessage("io.print", "Format missing");
	if (formatMarker(format) != 1)
		return throwMessage("io.print", "Too many %%");

	if (*s == bit_nil)
		return IOprint_formatted_nil(fd, *(str *) fmt, 's');
	if (*s)
		msg = "true";
	else
		msg = "false";
	@:formatConversion(s,msg)@
	if (*ret == EOF)
		return throwMessage("io.print", "End-of-file encountered");
	return MAL_SUCCEED;
}

@-
@+ Bulk export/loading
To simplify conversion between versions and to interface with other
applications, we use a simple import/export operation.

The conversion routine assumes space in the buffer for storing the result.
@{
@include prelude.mx
@-
A BAT can be saved in Monet format using the export command.
It is of particular use in preparing an ASCII version for migration.
The exported file is saved in the context of the directory
where the server was started unless an absolute file name was
presented.
@c
str
IOexport(int *ret, int *bid, str *fnme)
{
	BAT *b;
	stream *s = open_wastream(*fnme);

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("io.export", "Cannot access descriptor");
	}
	if (s == NULL || stream_errnr(s)) {
		*ret = FALSE;
		return throwMessage("io.export", "Could not open file");
	}
	BATprintf(s, b);
	stream_close(s);
	stream_destroy(s);
	*ret = TRUE;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@-
The import command reads a single BAT from an ASCII file. It assumes
a layout compatible with that produced by print or export.
@c
#define COMMA ','
str
IOimport(int *ret, int *bid, str *fnme)
{
	BAT *b;
	int (*hconvert) (str, int *, ptr *), (*tconvert) (str, int *, ptr *);
	size_t bufsize = 2048;	/* NIELS:tmp change used to be 1024 */
	char *base, *cur, *end;
	char *buf = (char *) GDKmalloc(bufsize);
	ptr h = 0, t = 0;
	int lh = 0, lt = 0;
	FILE *fp = fopen(*fnme, "r");

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("io.import", "Cannot access descriptor");
	}
	hconvert = BATatoms[BAThtype(b)].atomFromStr;
	tconvert = BATatoms[BATttype(b)].atomFromStr;
@-
Open the file. Memory map it to minimize buffering problems.
@c
	if (fp == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("io.import", "Could not open file");
	} else {
		int fn;
		struct stat st;

		if ((fn = fileno(fp)) <= 0) {
			BBPunfix(b->batCacheid);
			return throwMessage("io.import", "Fileno fails");
		}
		if (fstat(fn, &st) != 0) {
			BBPunfix(b->batCacheid);
			return throwMessage("io.imports", "Fstat fails");
		}

		(void) fclose(fp);
		if (st.st_size <= 0) {
			BBPunfix(b->batCacheid);
			return throwMessage("io.imports", "File is empty or fstat broken");
		}
		base = cur = (char *) MT_mmap(*fnme, MMAP_SEQUENTIAL, 0, st.st_size, NULL);
		end = cur + st.st_size;
		if (cur == (char *) -1) {
			BBPunfix(b->batCacheid);
			return throwMessage("io.mport", "MT_mmap failed");
		}

	}
@-
Parse a line. Copy it into a buffer. Concat broken lines with a slash.
@c
	while (cur < end) {
		str dst = buf, src = cur, p = strchr(cur, '\n');
		size_t l = p - cur;

		if (!p) {
			p = end;
		} else
			while (src[l - 1] == '\\') {
				@:memcpy@
				dst += l - 1;
				src += l + 1;
				if ((p = strchr(src, '\n')) == 0) {
					p = end;
					break;
				}
				l = p - src;
			}
		@:memcpy@
@-
@= memcpy
		if (buf+bufsize < dst+l) {
			int len = dst - buf;
			size_t inc = (size_t) ((dst+l) - buf);
			buf = (char*) GDKrealloc((void*) buf, bufsize = MAX(inc,bufsize)*2);
			dst = buf + len;
		}
		memcpy(dst, src, l-1);
@c
		dst[l] = 0;
		cur = p + 1;
@-
Parse the line, and insert a BUN.
@c
		for (p = buf; *p && GDKisspace(*p); p++)
			;
		if (*p == '#')
			continue;
@-
@= parsevalue
		for (;*p && *p != @2; p++);
		if (*p) for (p++; *p && GDKisspace(*p); p++);
		if (*p == 0) {
			char msg[BUFSIZ];
			*ret = FALSE;
			BBPunfix(b->batCacheid);
			snprintf(msg,BUFSIZ,"error in input %s",buf);
			return throwMessage( "io.import", msg);
		}
		p += @1(p, @3, @4);
@c
		@:parsevalue(hconvert,'[',&lh,(ptr *) &h)@
		@:parsevalue(tconvert,COMMA,&lt,(ptr *) &t)@
		BUNins(b, h, t, FALSE);

@-
Unmap already parsed memory, to keep the memory usage low.
@c
#ifndef WIN32
#define MAXBUF 40*MT_pagesize()
		if ((unsigned) (cur - base) > MAXBUF) {
			MT_munmap(base, MAXBUF);
			base += MAXBUF;
		}
#endif
	}
@-
Cleanup and exit. Return the filled BAT.
@c
	if (h)
		GDKfree(h);
	if (t)
		GDKfree(t);
	GDKfree(buf);
	MT_munmap(base, end - base);
	*ret = TRUE;
	BBPkeepref(b->batCacheid);
	return MAL_SUCCEED;
}

@}
