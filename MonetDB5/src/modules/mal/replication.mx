@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f replication
@a Martin Kersten
@v 1.0
@+ Database replication
MonetDB supports a simple database replication scheme using a master-slave
protocol. A master node keeps a log of all SQL updates for replay.
Upon explicit request from a slave, the master establishes
a MAL-client connection to the slave and starts pumping the tail of this
MAL-based update log. The master does not take any control over
the integrity of a slave. It may, however, decide to suspend
forwarding updates to prepare for e.g. administration or shutdown.

It is the slave's responsibility to be resilient against duplicate 
transmission of the MAL-update log. A transaction id
can be given to catch up from transactions already replayed.

The replication scheme does not support SQL scheme modifications.
Instead, the slaves should be initialized with a complete copy
of the master schema and the database.

Turning an existing database into a master and creation of a single
slave works as follows.

step 1) Turn the database into a replication master by setting its
"master" property to true using monetdb(1).  This property is translated
by merovingian(1) into the database variable "replication_master" and is
set upon database (re)start.  Note that this setting can not be added to a
running database.

step 2) Create a dump of the master database using the msqldump(1) tool.  

step 3) To initiate a slave, simply load the master snapshot.

step 4) Run monetdb(1) to turn the database into a slave by setting its "slave" property to the URI of the master. 
The precise URI can be obtained issuing the command
'mclient -lmal -d master -s "master.getURI();"' .
The slave property is translated by merovingian(1) into the database variable "replication_slave" 
and is set upon database (re)start.  Note that this setting can not be added to a running database. 

The slave starts synchronizing with the master automatically upon each restart.
It can be manually controlled using the functions:
@verbatim
CREATE PROCEDURE startSync() EXTERNAL NAME slave."sync";
CREATE PROCEDURE startSync(tag bigint) EXTERNAL NAME slave."sync";
CREATE PROCEDURE stopSync(uri string) EXTERNAL NAME slave."stop";

CREATE FUNCTION master() RETURNS string EXTERNAL NAME master."getURI";
@end verbatim

The replication scheme allows a slave to be cloned e.g. by copying the
dbfarm of the slave to another database without problems.  Important
here is that the new slave is also initialised as slave of the correct
master, by setting the "slave" property using monetdb(1).

It is possible to make a slave database also a master for descendants.
In such situation the database carries both a master and slave property.
Creating such scheme allows to employ hierarchical replication, or to
have additional tables available in the replication stream.  Note that
at this point replication from multiple masters to e.g. combine a full
set from a set of partitioned masters is not yet possible.

Beware, turning off the "master" property leads to automatic removal of all
left-over log files.  This renders the master database unusable for
replication.  To restore replication in such case, both master and
slaves have to be reinitialised using the afore described steps.

A slave property can be set to a list of masters, which turns the
the slave into a serving multiple sources. [tobedone]

@- Behind the scene
When the replication_master environment is set, an optimizer
becomes active to look after updates on SQL tables and to prepare
for producing the log files. The snippet below illustrates the
modifications made to a query plan.

@verbatim
function query():void
  master:= "mapi:monetdb://gio.ins.cwi.nl:50000/dbmaster";
  fcnid:= master.open();
  ...
  sql.append("schema","table","col",b:[:oid,:int]);
  master.append("schema","table","col",b,tag);
  ...
  t := mtime.current_timestamp();
  master.close(fcnid,t);
end query;
@end verbatim

At runtime this leads to buffers being filled with the statements
required for the slaves to catch up. 
Each query block is stored in its own buffer and sent at
the end of the query block. This separates the concurrent 
actions on the database at the master and leads to a serial
execution of the replication operations within the slave.

The log records are stored in a file "dbfarm/db/master/log%05d-%05d" with the 
following structure:
@verbatim
function slave.tag1(transactionid:int,stamp:timestamp):str;
  master:= "mapi:monetdb://gio.ins.cwi.nl:50000/dbmaster";
  slave.open(transactionid);
  tag1_b := bat.new(:oid,:int);
  ...
  bat.insert(tag1_b,3:oid,232:int); #example update
  ...
  sql.append("schema","table","col",tag1_b,tag);
  slave.close(transactionid,stamp);
  sql.commit();
  return tag1:= "tag1";
end tag1;
fcn:= slave.tag_1(1,"2009-09-03 15:49:45.000":timestamp);
slave.drop(fcn);
@end verbatim

The master identity is passed along to differentiate masters later.
The slave.open() simply checks the replica log administration table
and issues an assertion if necessary.

The operations are executed in the serial order as on the master,
which should lead to the same optimistic transactional behavior.
All queries are considered running in auto-commit mode, because
the SQL frontend does not provide the hook (yet) for better transaction
boundary control.
The transaction identifier is part of the call to the function
with the transaction update details.

@- Interaction protocol
The master node simply waits for a slave to request the
transmission of the missing log files.
The request includes the URI of the slave and the user
credentials needed to establish a connection.
The last property is the restart tag.
The master forks a thread to start flushing the log files.

Grouping the operations within temporary functions
makes it easy to skip its execution when we detect
that it has been executed before. 

@- Log file management
The log records are grouped into chunks, each represented by a file. 
Those files are the units for re-submission and the scheme
is set up to be idempotent. 
The log files will ultimately pollute your database and have to
be (re)moved. This is considered a responsibility for the DBA,
for it involves making a checkpoint or securely storing the logs
into an archive.

Archiving requires inspection of the slaves and the status
of their replay log table.

A slave starts replicating off the
master starting from the tag maintained by the master for each slave.
The master can be optionally forced to start at a particular tag.
@{
@mal
module master;

command open():int
address MASTERopen
comment "Create a replication record";

command close(tag:int):void
address MASTERclose
comment "Close the replication record";

pattern append(s:str, t:str, c:str, :any_1, tag:int):void
address MASTERappendValue
comment "Dump the scalar on the MAL log");

pattern append(s:str, t:str, c:str, b:bat[:oid,:any_1], tag:int):void
address MASTERappend
comment "Dump the BAT on the MAL log");

pattern delete(s:str, t:str, b:bat[:oid,:any_1], tag:int):void
address MASTERdelete
comment "Dump the BAT with deletions on the MAL log");

pattern replay(uri:str, usr:str, pw:str, tag:int):void
address MASTERreplay
comment "Slave calls the master to restart sending the missing transactions
from a certain point as a named user.";

command sync(uri:str, usr:str, pw:str, tag:int):void
address MASTERsync
comment "Login to slave with credentials to initiate submission of the log records";

pattern getURI():str
address MASTERgetURI
comment "Display the URI for the master";

command prelude():void
address MASTERprelude
comment "Prepare the server for the master role. Or remove any leftover log files.";

module slave;

command sync():void
address SLAVEsyncDefault
comment "Login to master with environment credentials to initiate submission of the log records";
command sync(uri:str):void
address SLAVEsyncURI
comment "Login to master with admin credentials to initiate submission of the log records";
command sync(uri:str, usr:str, pw:str, tag:int):void
address SLAVEsync
comment "Login to master uri with admin credentials to initiate submission of the log records";

command stop(uri:str):void
address SLAVEstop
comment "Slave suspends synchronisation with master";

command open(tag:oid)
address SLAVEopen
comment "Marks the start of a replication record. It checks the slave log
table for existence of the tag. If so, it aborts the attempt to reapply.";

command close(tag:oid,stamp:timestamp)
address SLAVEclose
comment "End of replication record. Add the time stamp op completion
to the slave log.";

command drop{unsafe}(fcnname:str)
address SLAVEdrop
comment "Remove the replica function from the module";

command prelude():void
address SLAVEprelude
comment "Prepare the server for the slave role.";

master.prelude();
slave.prelude();
@-
@+ Implementation code 
@h
#ifndef _REPLICATOR_H
#define _REPLICATOR_H

#include "mal.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"
#include <mapilib/Mapi.h>
#include "mtime.h"

/* #define _DEBUG_REPLICATION_ */

#ifdef WIN32
#ifndef LIBREPLICATION
#define replication_export extern __declspec(dllimport)
#else
#define replication_export extern __declspec(dllexport)
#endif
#else
#define replication_export extern
#endif

replication_export int MASTERroleEnabled(void);
replication_export str MASTERopen(int *ret);
replication_export str MASTERclose(int *ret, int *tag);
replication_export str MASTERstart(int *ret);
replication_export str MASTERstartTag(int *ret, int *tag);
replication_export str MASTERreplay(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str SLAVEsyncDefault(int  *ret);
replication_export str SLAVEsyncURI(int  *ret, str *conn);
replication_export str SLAVEsync(int  *ret, str *uri, str *usr, str *pw, int *tag);
replication_export str MASTERsync(int  *ret, str *uri, str *usr, str *pw, int *tag);
replication_export str SLAVEstop(int *ret);
replication_export str MASTERprelude(int *ret);
replication_export str MASTERgetURI(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

replication_export str SLAVEopen(int *ret, oid *tag);
replication_export str SLAVEclose(int *ret, oid *tag, timestamp *stamp);
replication_export str SLAVEdrop(int *ret, str *tag);
replication_export str SLAVEprelude(int *ret);
replication_export BAT *SLAVEtable(void);
#endif /* _REPLICATOR_H */
@c
#include "mal_config.h"
#include "replication.h"
#include "sabaoth.h"
#include "mal_client.h"
#include <mal_sabaoth.h>
#include <mapilib/Mapi.h>
#include <mtime.h>

@-
The start of the query is marked with a replica tag.
It also designates the local buffer to collect the update
requests before they are shipped to the log.
The tag is returned for marking all related updates.
The final code should contain a loop to determine the last replication tag.
@c
#define MASTER "master/"
#define REPLICA "log%05d-%05d"
#define REPLICABLOCK 100
#define REPLICADELAY 5000

static struct MASTERRECORD {
	char *buf;	/* assembled update function */
	int limit;
	int top;
	int tag;	/* transaction identifier */
	int fcn;	/* identifier to differentiate function */
} *master;
static int mtop = 0;
static int mlimit = 0;

static MT_Lock repLck;	

/* Master log file properties */
static int startTag = 0;	/* current transaction file bounds */
static int endTag = 0;		/* last transaction identifier given */
static int fcnTag = 0;		/* unique labeling of the functions */
static char logFile[PATHLENGTH]; 
static stream *repFile;

static int 
MASTERfindLogFile(char logFile[PATHLENGTH], int transactionid){
	int btag, etag;
	DIR *dirp;
	struct dirent *dent;

#ifdef _DEBUG_REPLICATION_
	stream_printf(GDKout,"#find the log file containing %d\n", transactionid);
#endif
	if (repFile)
		stream_close(repFile);
	dirp= opendir(MASTER);
	if (dirp == NULL)
		return  -1 ;
	while ((dent = readdir(dirp)) != NULL) 
		if ( sscanf(dent->d_name,"log%d-%d",&btag,&etag) == 2 && btag <= transactionid && transactionid<etag  ){
			snprintf(logFile, PATHLENGTH,"%s%s",MASTER, dent->d_name);
			slash_2_dir_sep(logFile);
			return etag;
		}
	return -1;
}

/* The replication log file contains a number of log functions.
 * When the limit is reached, we switch to a new file
*/
static int
MASTERincrement()
{
	char buf[PATHLENGTH];

	endTag++;	/* assign a new transaction identifier */
	snprintf(buf, PATHLENGTH, MASTER REPLICA, startTag, endTag);
	slash_2_dir_sep(buf);
	if (strcmp(logFile,buf) )
		rename(logFile,buf);
	strcpy(logFile,buf);
	/* once in a while we take a new log file */
	if ( endTag - startTag >= REPLICABLOCK){
		if ( repFile) 
			stream_close(repFile);
		repFile = NULL;
	}
	if ( repFile == NULL)
		repFile = open_wastream(buf);
	return repFile == NULL;
}

str
MASTERprelude(int *ret){
	int master, tag, etag;
	DIR *dirp;
	struct dirent *dent;

	(void) ret;
	MT_lock_init(&repLck, "replication");	/* we always need this */
	master = GDKgetenv_istrue("replication_master") &&
			 GDKgetenv("replication_slave") == NULL;
#ifdef _DEBUG_REPLICATION_
	stream_printf(GDKout,"#Initialize the master role?%s\n", master?"yes":"no");
#endif
	mal_set_lock(repLck, "replication");
	if( !master ){
		/* drop all remaining log files if master mode is switched off */
		GDKremovedir(MASTER);
		mal_unset_lock(repLck, "replication");
		return MAL_SUCCEED;
	}
	mkdir(MASTER, 0755); /* ensure existance of the replica pool */
	stream_printf(GDKout,"#Replication mode enabled\n");
	
	/* find the bounds for the last replication log file */
	/* assume directory is sorted */
	dirp= opendir(MASTER);
	if (dirp == NULL) {
		mal_unset_lock(repLck, "replication");
		return MAL_SUCCEED;
	}
	while ((dent = readdir(dirp)) != NULL) {
		if ( sscanf(dent->d_name,"log%d-%d",&tag,&etag) == 2 && tag >= startTag ){
			startTag= tag;
			endTag= etag;
			strcpy(logFile,dent->d_name);
		}
    }
#ifdef _DEBUG_REPLICATION_
	stream_printf(GDKout,"#last log file log%05d-%05d\n", startTag,endTag);
#endif
	startTag = endTag;
	mal_unset_lock(repLck, "replication");
	return MAL_SUCCEED;
}
	

str
MASTERgetURI(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str mero;

	(void) mb;
	(void) stk;
	(void) pci;
	mero = GDKgetenv("merovingian_uri");
	if ( ! mero)
		throw(MAL,"master.getURI","Database is not reachable");
	stream_printf(cntxt->fdout,"%s\n",mero);
	return MAL_SUCCEED;
}

int
MASTERroleEnabled(void)
{
	return startTag > 0;
}

static int MASTERgetBuffer(int tag)
{
	int i;

	for (i = 0; i < mtop; i++)
		if (master[i].tag == tag)
			return i;
	for (i = 0; i < mlimit; i++)
		if (master[i].tag == 0)
			break;
	if (i == 0) {
		master = GDKzalloc(sizeof(struct MASTERRECORD) * (mlimit + 32));
		mlimit = 32;
	} else
	if (i == mlimit) {
		master = GDKrealloc(master, sizeof(struct MASTERRECORD) * (mlimit + 32));
		mlimit += 32;
	}
	mtop = i >= mtop ? i + 1 : mtop;
	if (master[i].buf == 0) {
		master[i].buf = (char*)GDKzalloc(2 * 1024);
		master[i].limit = 2 * 1024;
		master[i].top = 0;
	}
	master[i].tag = tag;
	return i;
}
@-
For the time being, we assume that all chunks are kept in the
master directory. A better scheme is to find the last chunk
by reading the directory itself.
@c
str MASTERopen(int *ret)
{
	int i, l, len;

	mal_set_lock(repLck, "replication");
	/* get a replica buffer */

	i = MASTERgetBuffer(fcnTag);
	/* prepare the MAL redo record */
	len = master[i].limit - master[i].top - 1;
	master[i].fcn = fcnTag;
	while ((l = snprintf(master[i].buf + master[i].top, len,
			     "function slave.tag_%d{unsafe}(tag:oid,stamp:timestamp);\n"
			     "sql.transaction();\n"
			     "slave.open(tag);\n",fcnTag)) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.open", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	mal_unset_lock(repLck, RUNTIME_STREAM_FAILED);

	*ret = fcnTag++;
	return MAL_SUCCEED;
}

/*
 * Upon closure of the transaction, we assign the transaction identifier
 * and reflect it in the log file name as well.
*/
str MASTERclose(int *ret, int *tag)
{
	timestamp stamp = *timestamp_nil;
	str val = NULL;
	int i, l, len;
	char buf[BUFSIZ];

	(void)ret;
	i = MASTERgetBuffer(*tag);
	mal_set_lock(repLck, "replication");
	MTIMEepoch(&stamp);
	ATOMformat(TYPE_timestamp, (ptr) & stamp, &val);
	snprintf(buf,BUFSIZ,"tag_%d", *tag);

	/* the function name is returned by the slave to built
	   a flow dependency. Otherwise the function could be
	   destroyed while execution it.
	*/
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len,
			     "sql.commit();\n"
			     "slave.close(tag,stamp);\n"
			     "end %s;\n"
			     "slave.%s(%d:oid,\"%s\":timestamp);\n"
			     "slave.drop(\"%s\");\n",
			      buf,buf, endTag, val,buf)) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL){
			mal_unset_lock(repLck, "replication");
			throw(MAL, "replication.close", MAL_MALLOC_FAIL);
		}
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(val);

	MASTERincrement();
	if (repFile == NULL ){
		mal_unset_lock(repLck, "replication");
		throw(MAL, "master.close", RUNTIME_FILE_NOT_FOUND);
	}
	stream_printf(repFile, "%s", master[i].buf);
	stream_flush(repFile);
	master[i].buf[0] = 0;
	master[i].top = 0;
	master[i].tag = 0;
	if (stream_errnr(repFile)) {
		mal_unset_lock(repLck, "replication");
		throw(MAL, "replication.close", RUNTIME_STREAM_FAILED);
	}
	mal_unset_lock(repLck, "replication");
	return MAL_SUCCEED;
}

static str
MASTERdump(BAT *b, str buf, int type, int tag)
{
	BATiter bi;
	BUN p, q;
	char *headv = 0, *tailv = 0;
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;

	i = MASTERgetBuffer(tag);
	bi = bat_iterator(b);
	BATloop(b, p, q)
	{
		ATOMformat(getHeadType(type), BUNhead(bi, p), &headv);
		ATOMformat(getTailType(type), BUNtail(bi, p), &tailv);
		len = master[i].limit - master[i].top - 1;
		if (getTailType(type) <= TYPE_str &&
		    getHeadType(type) <= TYPE_str) {
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, %s:%s, %s:%s);\n",
					     buf, headv, head, tailv, tail)) >= len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		} else
		if (getTailType(type) > TYPE_str &&
		    getHeadType(type) > TYPE_str) {
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, \"%s\":%s, \"%s\":%s);\n",
					     buf, headv, head, tailv, tail)) >= len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		} else
		if (getTailType(type) > TYPE_str) {
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, %s:%s, \"%s\":%s);\n",
					     buf, headv, head, tailv, tail)) == len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		} else{
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, \"%s\":%s, %s:%s);\n",
					     buf, headv, head, tailv, tail)) == len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		}
		master[i].top += l;
		master[i].buf[master[i].top] = 0;
	}
	GDKfree(tail);
	GDKfree(head);
	return MAL_SUCCEED;
}

str
MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tag = *(int*)getArgReference(stk, pci, 5);
	InstrPtr q;
	str val = NULL;
	int i, len;

	(void)cntxt;
	i = MASTERgetBuffer(tag);
	q = copyInstruction(pci);
	q->argc--;
	setModuleId(q, putName("sql", 3));

	val = instruction2str(mb, stk, q, LIST_MAL_CALL);
	freeInstruction(q);

	len = master[i].limit - master[i].top - 1;
	while (snprintf(master[i].buf + master[i].top, len, "%s\n", val) >= len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.append", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += (int)(strlen(val) + 1);
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	return MAL_SUCCEED;
}

str
MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *schema = (str*)getArgReference(stk, pci, 1);
	str *table = (str*)getArgReference(stk, pci, 2);
	str *col = (str*)getArgReference(stk, pci, 3);
	int *bid = (int*)getArgReference(stk, pci, 4);
	int tag = *(int*)getArgReference(stk, pci, 5);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 4);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;
	str msg;

	(void)cntxt;
	b = BATdescriptor(*bid);
	if (b == NULL)
		throw(MAL, "replication.append", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "tag_%d_%s:=bat.new(:%s,:%s);\n",
			     tag, getArgName(mb, pci, 4), head, tail)) >= len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.append", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf, BUFSIZ, "tag_%d_%s", tag, getArgName(mb, pci, 4));
	msg = MASTERdump(b, buf, type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "sql.append(\"%s\",\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
			     *schema, *table, *col, buf, tag, getArgName(mb, pci, 4))) >= len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.append", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

str
MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *schema = (str*)getArgReference(stk, pci, 1);
	str *table = (str*)getArgReference(stk, pci, 2);
	int *bid = (int*)getArgReference(stk, pci, 3);
	int tag = *(int*)getArgReference(stk, pci, 4);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 3);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	str msg;
	int i, l, len;

	(void)cntxt;
	b = BATdescriptor(*bid);
	if (b == NULL)
		throw(MAL, "replication.delete", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "tag_%d_%s:=bat.new(:%s,:%s);\n",
			     tag, getArgName(mb, pci, 3), head, tail)) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.delete", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf, BUFSIZ, "tag_%d_%s", tag, getArgName(mb, pci, 3));
	msg = MASTERdump(b, buf, type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "sql.delete(\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
			     *schema, *table, buf, tag, getArgName(mb, pci, 4))) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.delete", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

@-
Replaying the MAL logs is straightforward.  Each slave is represented 
by a thread in the master, which looks for the pending updates and 
issues it as a MAL program.
The last log file may be sent multiple times.
[todo:force a new file when it happens too often.]
@c
static struct MASTERrecord {
	str uri;
	int tag;        /* next one to sent */
	Mapi m;
	time_t last_connect;
	time_t last_disconnect;
} masterstatus[MAL_MAXCLIENTS];

static void
MASTERsend(void *arg)
{
	int idx = * (int*) arg;
	int tag = masterstatus[idx].tag;
	int nxt, master;
	int etag, et, resent=0;
	stream *s;
	bstream *bs;
	MapiHdl hdl;
	char logFile[PATHLENGTH];

#ifdef _DEBUG_REPLICATION_
	stream_printf(GDKout,"#send the log file starting at transaction id %d\n", tag);
#endif
	/* find the last replication log file */
	master = GDKgetenv_istrue("replication_master") &&
			 GDKgetenv("replication_slave") == NULL;
	if ( !master)
		return;

	/* re-initialize the sql environment */
	hdl = mapi_query(masterstatus[idx].m, "include sql;sql.init();");
	if ( hdl == NULL)
		return;

	while ( (nxt = MASTERfindLogFile(logFile,tag)) >= 0){
#ifdef _DEBUG_REPLICATION_
		stream_printf(GDKout,"#sent log file %s\n",logFile);
#endif

		s = open_rastream(logFile);
		if (s == NULL || stream_errnr(s) ) {
			if (s )
				stream_destroy(s);
#ifdef _DEBUG_REPLICATION_
			stream_printf(GDKout,"#could not open log file %s\n",logFile);
#endif
			continue;
		}

		mal_set_lock(repLck, "replication");
		/* read the complete file [now trimmed to 64KB]*/
		bs = bstream_create(s, 128 * BLOCK);
		if (bstream_next(bs) < 0) {
			bstream_destroy(bs);
			break;
		}
		hdl = mapi_query(masterstatus[idx].m, bs->buf);
		mal_unset_lock(repLck, "replication");
		close_stream(s);
		if (hdl == NULL || mapi_error(masterstatus[idx].m) != MOK) 
			break;
		tag = nxt;
@-
Upon succesful transmission we wait for new stuff
@c
		if ( tag == startTag) {
			/* we have the last file */
			while( et == endTag ) 
				MT_sleep_ms(REPLICADELAY);
			resent++;
			if ( resent > REPLICABLOCK){
			}
			tag= et;
		} else 
			tag= etag;
	} 

#ifdef _DEBUG_REPLICATION_
	printf("#replay thread finished \n");
#endif
	GDKfree( masterstatus[idx].uri );
	masterstatus[idx].uri= NULL;
	masterstatus[idx].m = NULL;
	masterstatus[idx].tag= 0;
}
@-
The slave process sents a remote master.sync request with all
the information needed for the master to set up and start a log forwarding thread.
@c
str MASTERsync(int *ret, str *uri, str *usr, str *pw, int *tag)
{
	Mapi mapi;
	MT_Id tid;
	int i;

	(void)ret;

#ifdef _DEBUG_REPLICATION_
	stream_printf(GDKout, "#replay the log from  %s %s %s %d\n",
			*uri, *usr, *pw, *tag);
#endif

	/* master makes a connection with the slave */
	mapi = mapi_mapiuri(*uri, *usr, *pw, "mal");
	if (mapi_error(mapi))
		throw(MAL, "master.sync", "unable to connect to '%s': %s",
				*uri, mapi_error_str(mapi));

	if (mapi_reconnect(mapi) != MOK)
		throw(IO, "master.sync", "failed to connect to '%s': %s",
				*uri, mapi_error_str(mapi));

	for ( i = 0; i < MAL_MAXCLIENTS; i++)
		if ( masterstatus[i].uri == NULL)
			break;
	if ( i == MAL_MAXCLIENTS)
		throw(MAL,"master.sync","Too many slave connections");

	masterstatus[i].uri= GDKstrdup(*uri);
	masterstatus[i].tag= *tag;
	masterstatus[i].m= mapi;
	if (MT_create_thread(&tid, MASTERsend, (void *) &i) < 0) 
		throw(MAL, "master.sync", "cannot fork new client");
	
#ifdef _DEBUG_REPLICATION_
	stream_printf(GDKout, "#awaiting replay of the log \n");
#endif
	return MAL_SUCCEED;
}

@-
Prepare the remote call to the master
@c
str SLAVEsync(int *ret, str *uri, str *usr, str *pw, int *tag)
{
	Mapi mapi;
	MapiHdl hdl;
	str luri;
	char buf[BUFSIZ];

	(void)ret;

#ifdef _DEBUG_REPLICATION_
	stream_printf(GDKout, "#request replay the log from  %s %s %s %d\n",
			*uri, *usr, *pw, *tag);
#endif

	mapi = mapi_mapiuri(*uri, *usr, *pw, "mal");
	if (mapi_error(mapi))
		throw(MAL, "slave.sync", "unable to connect to '%s': %s",
				*uri, mapi_error_str(mapi));

	if (mapi_reconnect(mapi) != MOK)
		throw(IO, "slave.sync", "failed to connect to '%s': %s",
				*uri, mapi_error_str(mapi));

	SABgetLocalConnectionURI(&luri);
	if (luri == NULL)
		throw(MAL, "slave.sync", OPERATION_FAILED ": URI not found");

	snprintf(buf,BUFSIZ,"master.sync(\"%s\",\"%s\",\"%s\",%d);", luri, *usr, *pw, *tag);
	GDKfree(luri);
	hdl = mapi_query(mapi,buf);
	if (hdl == NULL){
		if (mapi_error(mapi) != MOK) 
            throw(IO, "slave.sync", OPERATION_FAILED ": an error occurred on connection: %s",
                    mapi_error_str(mapi));
        else 
            throw(MAL, "slave.sync", OPERATION_FAILED ": remote function invocation didn't return a result");
	}
	if ( mapi_result_error(hdl) ){
		str err = createException(
                    getExceptionType(mapi_result_error(hdl)),
                    "slave.sync",
                    "%s", getExceptionMessage(mapi_result_error(hdl)));
		mapi_close_handle(hdl);
		return err;
	}
#ifdef _DEBUG_REPLICATION_
	stream_printf(GDKout, "#slave awaiting replay of the log \n");
	stream_printf(GDKout,"%s\n",buf);
#endif
	return MAL_SUCCEED;
}

str SLAVEsyncURI(int *ret, str *uri)
{
	int tag = 0;
	str usr = "monetdb";
	str pw = "monetdb";
	(void)ret;
	if ( GDKgetenv("replication_slave") == NULL)
		throw(MAL, "master.sync", "Slave property not set");
	return SLAVEsync(ret, uri, &usr, &pw, &tag);
}

str SLAVEsyncDefault(int *ret)
{
	str uri;
	uri = GDKgetenv("replication_slave");
	if (uri == NULL)
		throw(MAL, "master.sync", "Slave property not set");
	return SLAVEsyncURI(ret, &uri);
}

@-
The master thread is stopped at the slave side by closing
its client record. 
@c
str SLAVEstop(int *ret)
{
	str uri;
	(void)ret;
	uri = GDKgetenv("replication_slave");
	if (uri == NULL)
		throw(MAL, "slave.stop", "Slave property not set");
	/* find the master client record and close it */
	/* TODO */
	return MAL_SUCCEED;
}
@-
To keep track of the transactions being replayed
we use two BATs with timestamps of their completion
in the master and the slave.
A null indicates a failure to replay and indicates a
incorrect database state.
The error BAT can be used to keep messages for offline
inspection.
The transaction identifier is used as an oid into this table.
@c
static BAT *slavecommit;
static BAT *slavevalid;
static BAT *slaveerror;

@= createBAT
    @1 = BATdescriptor(BBPindex("@1"));
    if (@1 == NULL){
		@1 = BATnew(TYPE_void, @2, 1024);
		if (@1 == NULL)
			return ;

		BATseqbase(@1,0); /* essential */
		BBPrename(@1->batCacheid, "@1");
		BATmode(@1, PERSISTENT);
#ifdef _DEBUG_REPLICATION_
		printf("#created @1\n");
#endif
	}
@c

static void
SLAVEinitLog(){
	@:createBAT(slavecommit,TYPE_timestamp)@
	@:createBAT(slavevalid,TYPE_timestamp)@
	@:createBAT(slaveerror,TYPE_str)@
}

str SLAVEopen(int *ret, oid *tag)
{
	(void)ret;
	(void)tag;
	mal_set_lock(repLck, "replication");
	if ( slavecommit == NULL)
		SLAVEinitLog();
	if ( slavecommit == NULL){
		mal_unset_lock(repLck, "replication");
		throw(MAL, "slave.open", OPERATION_FAILED);
	}
	/* cheap check if we have seen it before */
	if ( BATcount(slavecommit) < (BUN) *tag) {
		mal_unset_lock(repLck, "replication");
		throw(MAL, "slave.open", OPERATION_FAILED);
	}
	mal_unset_lock(repLck, "replication");
	return MAL_SUCCEED;
}

str SLAVEclose(int *ret, oid *tag, timestamp *valid)
{
	timestamp stamp;
	str err="";

	(void)ret;
	mal_set_lock(repLck, "replication");
	if ( slavecommit == NULL)
		SLAVEinitLog();
	if ( slavecommit == NULL){
		/* abort the transaction */
		mal_unset_lock(repLck, "replication");
		throw(MAL, "slave.clase", OPERATION_FAILED);
	}
	if ( BATcount(slavecommit) != (BUN) *tag) {
		mal_unset_lock(repLck, "replication");
		throw(MAL, "slave.close", "Out of order execution");
	}
	MTIMEepoch(&stamp);
	BUNappend(slavecommit, &stamp, FALSE);
	BUNappend(slavevalid, valid, FALSE);
	BUNappend(slaveerror, &err, FALSE);
	mal_unset_lock(repLck, "replication");
	return MAL_SUCCEED;
}
@-
The slave status can be made visible through an SQL
table producing function.
@verbatim
create function slavelog () 
	returns table ("commit" timestamp, "valid" timestamp, "error" string)
	external name sql.dump_slave;
@end verbatim

@c
BAT *
SLAVEtable(void){
	BAT *t;
	t = BATnew(TYPE_str,TYPE_bat,4);
	if ( t == NULL)
		return NULL;
	if ( slavecommit == NULL ||
		 slavevalid == NULL ||
		 slaveerror == NULL)
		return t;
	BUNins(t,"commit",&slavecommit->batCacheid,FALSE);
	BUNins(t,"valid",&slavevalid->batCacheid,FALSE);
	BUNins(t,"error",&slaveerror->batCacheid,FALSE);
	return t;
}

str
SLAVEdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	/*
	str *schema = (str*)getArgReference(stk, pci, 1);
	str *table = (str*)getArgReference(stk, pci, 2);
	int *bid = (int*)getArgReference(stk, pci, 3);
	int tag = *(int*)getArgReference(stk, pci, 4);
	*/

	(void)cntxt;
	(void)mb;
	(void)stk;
	(void)pci;
	/*
	(void)schema;
	(void)table;
	(void)bid;
	(void)tag;
	*/
	mal_set_lock(repLck, "replication");
	if ( slavecommit == NULL)
		SLAVEinitLog();
	mal_unset_lock(repLck, "replication");
	return MAL_SUCCEED;
}

str
SLAVEdrop(int *ret, str *tag)
{
	Symbol prg;
	Module mod;
	prg = findSymbol(NULL, getName("slave", 5), *tag);
	mod = findModule(NULL, getName("slave", 5));
	if (prg == NULL || mod == NULL)
		throw(MAL, "slave.drop", "Symbol not found");
	deleteSymbol(mod, prg);
	(void)ret;
	return MAL_SUCCEED;
}

str
SLAVEprelude(int *ret)
{
#ifdef _DEBUG_REPLICATION_
	stream_printf(GDKout, "#initialize slave\n");
#endif
	/* to be called after MASTERprelude 
	if ( GDKgetenv("replication_slave") != NULL) {
		mal_set_lock(repLck, "replication");
		SLAVEinitLog();
		mal_unset_lock(repLck, "replication");
		SLAVEsyncDefault(ret);
	}
*/
	(void)ret;
	return MAL_SUCCEED;
}
@}
