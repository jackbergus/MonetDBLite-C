@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f replication
@a Martin Kersten
@v 1.0
@+ Database replication
The replication module supports distribution of updates over SQL
databases at multiple sites using a simple master-slave protocol using a
MAL-based update log.  Note that the current replication approach does
not support replication of schema changes, such as addition of tables or
columns.  Setup the full catalogue before transitioning a database to a
replication master and make a backup.

Turning an existing database into a master and creation of a single
slave works as follows.

step 1) Turn the database into a replication master by setting
its "replication_master" property to true using monetdb(1).  
This property is translated by merovingian(1) into the database variable
replication_master being set upon system restart.
Monetdb(1) will automatically restart the database server to initialize its new role,
unless it was taken out for maintenance.

step 2) Create a dump of the master database using the msqldump(1) tool.  
Alternatively, the DBA can make a safe copy from the corresponding dbfarm
directory.

step 3) To initiate a slave, simply load the master snapshot.

step 4) Turn the database into a slave by setting its
"replication_slave" property to the uri of the master using monetdb(1).
This property is translated by merovingian(1) into the 
databasevariable replication_slave setting upon system restart.
Monetdb(1) will automatically restart the database server to initialize its new role,
unless it was taken out for maintenance.

The slave starts synchronizing with the master automatically upon each session restart.
The synchronization can be manually controlled with the SQL functions
CALL 'startSynchronization();' and CALL 'stopSynchronization();' .

The replication scheme allows a slave to be cloned e.g. by copying the
dbfarm of the slave to another database without problems.  
In this situation the database carries both a master and slave property.

Beware, turning off the replication_master property leads to removal of all
left-over log files. Slaves will detect this situation and call for a fresh
copy and continue processing queries on a possibly stale database.

@- Behind the scene
When the replication_master environment is set, an optimizer
becomes active to look after updates on SQL tables and to prepare
for producing the log files. The snippet below illustrates the
additions and modifications to a query plan.

@verbatim
function query():void
  tag:= master.open();
  ...
  sql.append("schema","table","col",b:[:oid,:int]);
  master.append("schema","table","col",b,tag);
  ...
  t := mtime.current_timestamp();
  master.close();
end query;
@end verbatim

At runtime this leads to buffers being filled with the statements
required for the slaves to catch up. 
Each query block is stored in its own buffer and sent at
the end of the query block. This separates the concurrent 
actions on the database at the master and leads to a serial
execution of the replication operations within the slave.

The log records are stored in a file "dbfarm/db/master/log_%d" with the 
following structure:
@verbatim
function slave.tag1(tag:int,stamp:timestamp);
  slave.open(tag,"2009-08-16 18:57:58.000":timestamp);
  tag1_b := bat.new(:oid,:int);
  ...
  bat.insert(tag1_b,3:oid,232:int); #example update
  ...
  sql.append("schema","table","col",tag1_b,tag);
  slave.close("mapi:monetdb://127.0.0.1:50000/demo",tag,stamp);
  sql.commit();
end tag1;
slave.tag_1(1,"2009-09-03 15:49:45.000":timestamp);
slave.drop("tag1");
@end verbatim

Grouping the operations within temporary functions
makes it easy to skip its execution when we detect
that it has been executed before. The slave.open()
simply checks the replica log administration table
and issues an assertion if necessary.

The operations are executed in the serial order as on the master,
which should lead to the same optimistic transactional behavior.
All queries are considered running in auto-commit mode, because
the SQL frontend does not provide the hook (yet) for better transaction
boundary control.

@- Log file management
The log records are grouped into chunks, each represented by a file. 
Those files are the units for re-submission and the scheme
is set up to be idempotent. 
The log files will ultimately pollute your database and have to
be (re)moved. This is considered a responsibility for the DBA,
for it involves making a checkpoint or securely storing the logs
into an archive. The master keeps a table of chunks sent completely.

Monetdb can inform the master about each slave being added.
Or the server can request the names of all slaves from Sabaoth.
This way we can garbage collect log files without DBA interference.

A slave starts replicating off the
master starting from the tag maintained by the master for each slave.
The master can be optionally forced to start at a particular tag.
@{
@mal
module master;

command open():int
address MASTERopen
comment "Create a replication record";

command close(tag:int):void
address MASTERclose
comment "Close the replication record";

pattern append(s:str, t:str, c:str, :any_1, tag:int):void
address MASTERappendValue
comment "Dump the scalar on the MAL log");

pattern append(s:str, t:str, c:str, b:bat[:oid,:any_1], tag:int):void
address MASTERappend
comment "Dump the BAT on the MAL log");

pattern delete(s:str, t:str, b:bat[:oid,:any_1], tag:int):void
address MASTERdelete
comment "Dump the BAT with deletions on the MAL log");

pattern replay():void
address MASTERreplay
comment "Slave calls the master to restart sending the missing transactions";
pattern replay(tag:int):void
address MASTERreplayTag
comment "Slave calls the master to restart sending the missing transactions
from a certain point";

command stop(uri:str):void
address MASTERstop
comment "Slave suspends synchronisation with master";

command getName():str
address MASTERgetName
comment "Return the name of the server if it is a master, otherwise
pick the first name from the replicas table";

command synchronize():void
address MASTERsynchronizeDefault
comment "Login to master with environment credentials to initiate submission of the log records";
command synchronize(uri:str):void
address MASTERsynchronizeURI
comment "Login to master with admin credentials to initiate submission of the log records";
command synchronize(uri:str, usr:str, pw:str, tag:int):void
address MASTERsynchronize
comment "Login to master with admin credentials to initiate submission of the log records";

module slave;

pattern init( uri:str)
address SLAVEinit
comment "The master announces the start of a roll forward of pending updates";

command open(tag:int,d:timestamp)
address SLAVEopen
comment "Marks the start of a replication record. It checks the replicas
table for existence of the tag. If so, it aborts the attempt to reapply.";

command close(uri:str, tag:int, d:timestamp)
address SLAVEclose
comment "End of replication record. Add the tag to the replicas table
using the SQL transaction semantics. To be extended with the reason for
failures.";

command drop(tag:str)
address SLAVEdrop
comment "Remove the replica function from the module";
@-
@+ Implementation code 
@h
#ifndef _REPLICATOR_H
#define _REPLICATOR_H

#include "mal.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"
#include <mapilib/Mapi.h>
#include "mtime.h"

/* #define _DEBUG_REPLICATOR_ */

#ifdef WIN32
#ifndef LIBREPLICATION
#define replication_export extern __declspec(dllimport)
#else
#define replication_export extern __declspec(dllexport)
#endif
#else
#define replication_export extern
#endif

replication_export int MASTERroleEnabled(void);
replication_export str MASTERopen(int *ret);
replication_export str MASTERstop(int *ret);
replication_export str MASTERclose(int *ret, int *tag);
replication_export str MASTERstart(int *ret);
replication_export str MASTERstartTag(int *ret, int *tag);
replication_export str MASTERreplayTag(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERreplay(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERsynchronizeDefault(int  *ret);
replication_export str MASTERsynchronizeURI(int  *ret, str *conn);
replication_export str MASTERsynchronize(int  *ret, str *uri, str *usr, str *pw, int *tag);
replication_export str MASTERgetName(str *ret);

replication_export str SLAVEinit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str SLAVEopen(int *ret, int *tag, timestamp *t);
replication_export str SLAVEclose(int *ret, str *str, int *tag, timestamp *t);
replication_export str SLAVEdrop(int *ret, str *tag);
#endif /* _REPLICATOR_H */
@c
#include "mal_config.h"
#include "replication.h"
#include "mal_client.h"
#include <mal_sabaoth.h> 
#include <mapilib/Mapi.h>

@-
The start of the query is marked with a replica tag.
It also designates the local buffer to collect the update
requests before they are shipped to the log.
The tag is returned for marking all related updates.
The final code should contain a loop to determine the last replication tag.
@c
#define MASTER "master"
#define REPLICA "/log_%d"
#define REPLICABLOCK 1000

static struct MASTERRECORD {
	char *buf;
	int limit;
	int top;
	int tag;
} *master;
static int mtop = 0;
static int mlimit = 0;
static MT_Lock repLck;
static int replicationTag = 0;
static stream *repFile;

int
MASTERroleEnabled(void)
{
	return replicationTag > 0;
}

static int MASTERgetBuffer(int tag){
	int i;

	for ( i = 0; i < mtop ; i++)
	if ( master[i].tag == tag)
		return i;
	for ( i = 0; i < mlimit ; i++)
	if ( master[i].tag == 0)
		break;
	if ( i == 0){
		master = GDKzalloc(sizeof(struct MASTERRECORD) * (mlimit +32));
		mlimit = 32;
	} else
	if ( i == mlimit){
		master = GDKrealloc(master, sizeof(struct MASTERRECORD) * (mlimit +32));
		mlimit += 32;
	}
	mtop = i >= mtop ? i+1: mtop;
	if ( master[i].buf == 0){
		master[i].buf = (char*) GDKzalloc(2*1024);
		master[i].limit = 2*1024;
		master[i].top = 0;
	}
	master[i].tag = tag;
	return i;
}
@-
For the time being, we assume that all chunks are kept in the
master directory. A better scheme is to find the last chunk
by reading the directory itself.
@c
str MASTERopen(int *ret){
	char buf[BUFSIZ];
	FILE *fp = 0;
	timestamp stamp = *timestamp_nil;
	str val=0;
	int i,l,len;
	
	if ( replicationTag == 0)
		MT_lock_init(&repLck,"replication");
	mal_set_lock(repLck,"replication");
	if ( repFile == NULL){
		mkdir(MASTER,0755); /* ensure existance of the replica pool */
		if ( replicationTag == 0){
			/* find the last one already in the pool, using the REPLICABLOCK */
			do {
				if (fp) {
					replicationTag += REPLICABLOCK;
					fclose(fp);
				}
				snprintf(buf, BUFSIZ, MASTER REPLICA, replicationTag);
				fp = fopen(buf,"r");
			} while (fp);
		}
		snprintf(buf, BUFSIZ, MASTER REPLICA, replicationTag);
		repFile = open_wastream(buf);
		if ( repFile == NULL || stream_errnr(repFile) ){
			mal_unset_lock(repLck,RUNTIME_STREAM_FAILED);
			throw(MAL,"master.start",RUNTIME_STREAM_FAILED);
		}
	}
	/* get a replica buffer */
	replicationTag++;
	i = MASTERgetBuffer(replicationTag);
	/* prepare the MAL redo record */
	MTIMEepoch(&stamp);
	ATOMformat(TYPE_timestamp, (ptr) &stamp, &val);
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len ,
			"function slave.tag_%d(tag:int,stamp:timestamp);\n"
			"sql.transaction();\nslave.open(tag,\"%s\":timestamp);\n",
				replicationTag, val)) == len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replication.open",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	mal_unset_lock(repLck,RUNTIME_STREAM_FAILED);

	*ret = replicationTag ;
	return MAL_SUCCEED;
}

str MASTERclose(int *ret, int *tag){
	timestamp stamp = *timestamp_nil;
	str val=0, con= 0;
	int i,l,len;
	char buf[BUFSIZ];

	(void) ret;
	i = MASTERgetBuffer(*tag);
	mal_set_lock(repLck,"replication");
	MTIMEepoch(&stamp);
	ATOMformat(TYPE_timestamp, (ptr) &stamp, &val);
	snprintf(buf,BUFSIZ,"tag_%d",*tag);
	SABAOTHgetLocalConnection(&con);

	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len, 
		"slave.close(\"%s\",tag,stamp);\nsql.commit();\n"
		"end tag_%d;\nslave.tag_%d(%d,\"%s\":timestamp);\nslave.drop(\"%s\");\n",
		con,*tag,*tag,*tag,val,buf)) == len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replication.close",MAL_MALLOC_FAIL);
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	GDKfree(con);
	stream_printf(repFile,"%s", master[i].buf);
	stream_flush(repFile);
	master[i].buf[0]=0;
	master[i].top = 0;
	master[i].top = 0;
	if ( stream_errnr(repFile) ){
		mal_unset_lock(repLck,"replication");
		throw(MAL,"replication.close",RUNTIME_STREAM_FAILED);
	}
	if ( replicationTag % REPLICABLOCK  == 0){
		close_stream(repFile);
		repFile = NULL;
	}
	mal_unset_lock(repLck,"replication");
	return MAL_SUCCEED;
}

static str
MASTERdump( BAT *b, str buf, int type, int tag){
	BATiter bi;
	BUN p,q;
	char *headv = 0, *tailv= 0;
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;
	
	i = MASTERgetBuffer(tag);
	bi = bat_iterator(b);
	BATloop(b,p,q){
		ATOMformat(getHeadType(type), BUNhead(bi, p), &headv);
		ATOMformat(getTailType(type), BUNtail(bi, p), &tailv);
		len = master[i].limit - master[i].top -1;
		if ( getTailType(type) <=TYPE_str &&
			getHeadType(type) <= TYPE_str) {
			while ( (l = snprintf(master[i].buf + master[i].top, len ,"bat.insert(%s, %s:%s, %s:%s);\n",
						buf, headv, head, tailv, tail)) >= len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replication.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		} else
		if ( getTailType(type) >TYPE_str  &&
			getHeadType(type) > TYPE_str) {
			while ( (l = snprintf(master[i].buf + master[i].top, len , "bat.insert(%s, \"%s\":%s, \"%s\":%s);\n",
						buf, headv, head, tailv, tail)) >= len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replication.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		} else
		if ( getTailType(type) >TYPE_str ) {
			while ( (l = snprintf(master[i].buf + master[i].top, len , "bat.insert(%s, %s:%s, \"%s\":%s);\n",
						buf, headv, head, tailv, tail)) == len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replication.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		} else{
			while ( (l = snprintf(master[i].buf + master[i].top, len , "bat.insert(%s, \"%s\":%s, %s:%s);\n",
						buf, headv, head, tailv, tail)) == len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replication.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		}
		master[i].top += l;
		master[i].buf[master[i].top] = 0;
	}
	GDKfree(tail);
	GDKfree(head);
	return MAL_SUCCEED;
}

str
MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tag = *(int*) getArgReference(stk,pci,5);
	InstrPtr q;
	str val= NULL;
	int i, len;

	(void) cntxt;
	if ( repFile == NULL)
		throw(MAL,"replication.append", RUNTIME_FILE_NOT_FOUND);

	i = MASTERgetBuffer(tag);
	q= copyInstruction(pci);
	q->argc--;
	setModuleId(q,putName("sql",3));
	
	val = instruction2str(mb,stk,q,LIST_MAL_CALL);
	freeInstruction(q);

	len = master[i].limit - master[i].top -1;
	while (snprintf(master[i].buf + master[i].top, len, "%s\n", val) >= len) {
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replication.append",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += (int)(strlen(val) + 1);
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	return MAL_SUCCEED;
}

str
MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	str *col = (str*) getArgReference(stk,pci,3);
	int *bid = (int*) getArgReference(stk,pci,4);
	int tag = *(int*) getArgReference(stk,pci,5);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 4);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;
	str msg;

	(void) cntxt;
	if ( repFile == NULL)
		throw(MAL,"replication.append", RUNTIME_FILE_NOT_FOUND);
	b = BATdescriptor(*bid);
	if ( b == NULL)
		throw(MAL,"replication.append", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "tag_%d_%s:=bat.new(:%s,:%s);\n",
				tag, getArgName(mb,pci,4), head, tail)) >= len ){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replication.append",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf,BUFSIZ,"tag_%d_%s", tag, getArgName(mb,pci,4));
	msg = MASTERdump(b,buf,type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "sql.append(\"%s\",\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
		*schema, *table, *col, buf,tag, getArgName(mb,pci,4)) ) >= len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replication.append",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

str
MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	int *bid = (int*) getArgReference(stk,pci,3);
	int tag = *(int*) getArgReference(stk,pci,4);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 3);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	str msg;
	int i, l, len;

	(void) cntxt;
	if ( repFile == NULL)
		throw(MAL,"replication.delete", RUNTIME_FILE_NOT_FOUND);
	b = BATdescriptor(*bid);
	if ( b == NULL)
		throw(MAL,"replication.delete", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "tag_%d_%s:=bat.new(:%s,:%s);\n",
				tag, getArgName(mb,pci,3), head, tail)) == len ){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replication.delete",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf,BUFSIZ,"tag_%d_%s", tag, getArgName(mb,pci,3));
	msg = MASTERdump(b,buf,type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "sql.delete(\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
			*schema, *table, buf, tag, getArgName(mb,pci,4))) == len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replication.delete",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

@-
Replaying the MAL logs is straightforward. The slave upon calling the
master switches to the role of client, receiving the redo transactions
upon arrival.

The master keeps a [persistent] structure with the status of all completed 
log files being sent to slaves.

The replay should be performed in an independent thread to enable
the slave to continue processing. Furthermore we assume that
all log files still exist (but may be zapped)

To ensure  we only sent completed log records the replication lock
is acquired. Currently for each file, but it is only needed for the
one still being extended.
@c
static struct MASTERrecord{
	str uri;
	int idx;	/* for its forced termination */
	time_t last_connect;
	time_t last_disconnect;
	int tag;	/* next one to sent */
	Mapi m;
} masterstatus[MAL_MAXCLIENTS];

#define _DEBUG_REPLICATOR_
static void
MASTERsend(Client cntxt, int tag)
{
	char buf[BUFSIZ+1] = "\ninclude sql;\nsql.init();\n";
	stream *s;
	size_t len;

	if ( stream_write(cntxt->fdout, buf, 1, strlen(buf)) != (unsigned) strlen(buf))
		stream_printf(GDKerr,"!failed to initialize slave session\n");

	if ( replicationTag == 0)
		MT_lock_init(&repLck,"replication");
	do {
		snprintf(buf, BUFSIZ, MASTER REPLICA, (tag / REPLICABLOCK) *REPLICABLOCK);
		s = open_rastream(buf);
		if (stream_errnr(s))
			break;
#ifdef _DEBUG_REPLICATOR_
		printf("#replay thread started %s\n",buf);
#endif
		mal_set_lock(repLck,"replication");
		while ( (len = stream_readline(s, buf, sizeof(buf) - 1)) > 0) {
			buf[len++]= '\n';
			buf[len] = '\0';
			if ( (size_t) stream_write(cntxt->fdout, buf, 1, len) != len){
				stream_printf(GDKerr,"!failed to sent log file\n");
				break;
				stream_flush(cntxt->fdout);
			}
		} 
		mal_unset_lock(repLck,"replication");
		close_stream(s);
#ifdef _DEBUG_REPLICATOR_
		printf("#next file\n");
#endif
@-
Upon succesful transmission we update the log file tag for the slave.
@c
		tag += REPLICABLOCK;
	} while (cntxt->mode <= FINISHING); /* stop when out of log files or closed by force */

#ifdef _DEBUG_REPLICATOR_
	printf("#replay thread finished \n");
#endif
	MCcloseClient(cntxt);
}

str
MASTERreplayTag(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	MASTERsend(cntxt, *(int*) getArgReference(stk,pci,1));
	return MAL_SUCCEED;
}

str
MASTERreplay(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tag = 0;
	(void) stk;
	(void) mb;
	(void) pci;
	MASTERsend(cntxt, tag);
	return MAL_SUCCEED;
}
@-
Contact the master and issue the master.start() command remotely.
Switch to a local client to consume the MAL stream it will sent.
@c
static void
MASTERmasterReceiver( void *x)
{
	Mapi mapi = (Mapi) x;
	char buf[BUFSIZ+1];
	MapiHdl hdl;
	Client c;
	MT_Id tid;
	stream *s;

#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout,"#call master to replay\n");
#endif
	snprintf(buf,BUFSIZ,"master.replay();");
	hdl = mapi_query(mapi, buf);
	if ( mapi_result_error(hdl))
		return;	/* terminate the synchronization */
	/* steal the output stream from the master connection */
	mapi_trace(mapi,1);
	s = mapi_get_from(mapi);
	c = MCinitClient(0, 0, 0);
	if ( c == NULL){
		stream_printf(GDKerr,"!Out of client slots\n");
		return;
	}
	if ( c->nspace == 0){
		c->nspace = newModule(NULL, putName("user",4));
		c->nspace->outer = mal_clients[0].nspace->outer;
	}
	(void) setScenario(c,"mal");
#ifdef _DEBUG_REPLICATOR_
	c->listing = LIST_MAL_ALL;
#endif
	MSinitClientPrg(c,"user","main");
	c->fdin = bstream_create(s, 0);
    if (MT_create_thread(&tid, MSserveClient, (void *) c) < 0) {
        showException(MAL,"initClient", "can not fork new client");
        return;
    }
#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout,"#slave started receiving \n");
#endif
}

str MASTERsynchronize(int  *ret, str *uri, str *usr, str *pw, int *tag)
{
	Mapi  mapi;
	MT_Id tid;

	(void) ret;

#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout,"#replay the log from  %s %s %s %d\n", *uri, *usr, *pw, *tag);
#endif
	
	mapi = mapi_mapiuri(*uri, *usr, *pw, "mal");
	if (mapi_error(mapi))
		throw(MAL, "master.replay", "unable to connect: %s", mapi_error_str(mapi));

	if (mapi_reconnect(mapi) != MOK) {
		throw(IO, "master.replay", OPERATION_FAILED 
				": an error occurred during connect to '%s': %s",
				*uri, mapi_error_str(mapi));
	}
	/* ready to initialize role change */
	MT_create_thread(&tid, MASTERmasterReceiver,(void*) mapi);
	return MAL_SUCCEED;
}

str MASTERsynchronizeURI(int  *ret, str *uri)
{
	int tag = 0;
	str usr = "monetdb";
	str pw = "monetdb";
	(void) ret;
	return MASTERsynchronize(ret,uri,&usr,&pw,&tag);
}

str MASTERsynchronizeDefault(int *ret)
{
	str uri;
	uri = GDKgetenv("replication_slave");
	if (uri == NULL)
		throw(MAL,"master.synchronize","Slave property not set");
	return MASTERsynchronizeURI(ret,&uri);
}

@-
The master thread is stopped at the slave side by closing
its client record. 
@c
str MASTERstop(int *ret){
	(void) ret;
	return MAL_SUCCEED;
}

str MASTERgetName(str *ret)
{
	struct MASTERrecord *mr;

	if (GDKgetenv_isyes("replication_master") ||
			GDKgetenv_istrue("replication_master"))
		return SABAOTHgetLocalConnection(ret);
		
	for (mr= masterstatus; mr->uri && mr < masterstatus+ MAL_MAXCLIENTS-1; mr++)
		*ret = GDKstrdup(mr->uri); /* FIXME: superleak and useless loop, thanks Stefan */

	throw(MAL, "master.getName", "no master name found");
}
@-
We should assure that only operations we haven't seen are
being executed. This is based on the tag assigned to each
replication block. 
The slave is initialized with the uri of the master
to locate its index in the client record.
@c
str SLAVEinit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	struct MASTERrecord *mr;
	str *uri = (str*) getArgReference(stk,pci,1);
	(void) mb;
	/* find the corresponding master record */
	for( mr= masterstatus; mr->uri && mr < masterstatus+ MAL_MAXCLIENTS-1; mr++)
	if ( strcmp(mr->uri, *uri) == 0){
		mr->idx= cntxt->idx;
#ifdef _DEBUG_REPLICATOR_
		stream_printf(GDKout,"#replay init %s\n",mr->uri);
#endif
		break;
	}
	return MAL_SUCCEED;
}

str SLAVEopen(int *ret, int *tag, timestamp *t){
	(void) ret;
	(void) t;
	(void) tag;
	throw(MAL,"slave.open","Operation ignored, defined in SQL context");
}

str SLAVEclose(int *ret, str *uri,  int *tag, timestamp *t){
	(void) ret;
	(void) uri;
	(void) tag;
	(void) t;
	throw(MAL,"slave.close","Operation ignored, defined in SQL context");
}

str
SLAVEdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	int *bid = (int*) getArgReference(stk,pci,3);
	int tag = *(int*) getArgReference(stk,pci,4);

	(void) cntxt;
	(void) mb;
	(void) schema;
	(void) table;
	(void) bid;
	(void) tag;
	return MAL_SUCCEED;
}

str
SLAVEdrop(int *ret, str *tag)
{
	Symbol prg;
	Module mod;
	prg = findSymbol(NULL, getName("slave",5), *tag);
	mod = findModule(NULL, getName("slave",5));
	if ( prg == NULL || mod == NULL)
		throw(MAL,"slave.drop","Symbol not found");
	deleteSymbol(mod,prg);
	(void) ret;
	return MAL_SUCCEED;
}

@}
