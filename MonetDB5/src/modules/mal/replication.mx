@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f replication
@a Martin Kersten
@v 1.0
@+ Database replication
MonetDB supports a simple database replication scheme using a master-slave
protocol. A master node keeps a log of all SQL updates for replay.
Once a slave starts the master establishes
a MAL-client connection to the slave and starts pumping the backlog
of committed transactions.
The master does not take any responsibility over the integrity of a slave.
The master may, however, decide to suspend
forwarding updates to prepare for e.g. administration or shutdown.

It is the slave's responsibility to be resilient against duplicate 
transmission of the MAL-update backlog. A transaction id
can be given to catch up from transactions already replayed.
Transaction ideas before the minimum available in the log
directory leads to freezing the slave. Then rebuilding from
scratch is required.

The replication scheme does not support SQL scheme modifications.
Instead, the slaves should be initialized with a complete copy
of the master schema and the database.

Turning an existing database into a master and creation of a single
slave works as follows.

step 1) Turn the database into a replication master by setting its
"master" property to true using monetdb(1).  This property is translated
by merovingian(1) into the database variable "replication_master" and is
set upon database (re)start.  Note that this setting can not be added to a
running database.

step 2) Create a dump of the master database using the msqldump(1) tool.  

step 3) To initiate a slave, simply load the master snapshot.

step 4) Run monetdb(1) to turn the database into a slave by setting its "slave" property to the URI of the master. 
The precise URI can be obtained issuing the command
'mclient -lmal -dmaster -s"u := master.getURI(); io.printf(\"%s\n\", u);"' on the master.
The slave property is translated by merovingian(1) into the database variable "replication_slave" 
and is set upon database (re)start.  Note that this setting can not be added to a running database. 

The slave starts synchronizing with the master automatically upon each session restart.
A few SQL wrapper procedures and functions can be used to control it manually.
For example, the slave can temporarily suspend receiving log replays using suspendSync()
and reactive it afterwards with resumeSync().
A resumeSync() is also needed if you create a relation already known by the master,
for it could have sent updates already. Due to unavailability of the target
table it closed the log stream.

The function freezeSlaves() removes the log files and makes sure that all
existing slaves won't be able to catch up other then by re-initializing the
database using e.g. a checkpoint.
@verbatim
CREATE PROCEDURE suspendSync() EXTERNAL NAME slave."stop";
CREATE PROCEDURE resumeSync() EXTERNAL NAME slave."sync";
CREATE FUNCTION synchronizing() RETURNS boolean EXTERNAL NAME slave."synchronizing";

CREATE PROCEDURE freezeSlaves() EXTERNAL NAME master."freeze";
CREATE PROCEDURE suspendSlaves() EXTERNAL NAME master."stop";
CREATE PROCEDURE resumeSlaves() EXTERNAL NAME master."start";
CREATE FUNCTION master() RETURNS string EXTERNAL NAME master."getURI";
CREATE FUNCTION cutOffTag() RETURNS string EXTERNAL NAME master."getCutOffTag";
@end verbatim

It is possible to make a slave database also a master for descendants.
In such situation the database carries both a master and slave property.
Creating such scheme allows to employ hierarchical replication, or to
have additional tables available in the replication stream.  Note that
at this point replication from multiple masters to e.g. combine a full
set from a set of partitioned masters is not yet possible.

Beware, turning off the "master" property leads to automatic removal of all
left-over log files.  This renders the master database unusable for replication.
The state of the slaves becomes frozen.
To restore replication in such case, both master and
slaves have to be reinitialised using the aforementioned steps.

@- Behind the scene
When the replication_master environment is set, an optimizer
becomes active to look after updates on SQL tables and to prepare
for producing the log files. The snippet below illustrates the
modifications made to a query plan.

@verbatim
function query():void
  master:= "mapi:monetdb://gio.ins.cwi.nl:50000/dbmaster";
  fcnid:= master.open();
  ...
  sql.append("schema","table","col",b:[:oid,:int]);
  master.append("schema","table","col",b,fcnid);
  ...
  t := mtime.current_timestamp();
  master.close(fcnid,t);
end query;
@end verbatim

At runtime this leads to buffers being filled with the statements
required for the slaves to catch up. 
Each query block is stored in its own buffer and sent at
the end of the query block. This separates the concurrent 
actions on the database at the master and leads to a serial
execution of the replication operations within the slave.

The log records are stored in a file "dbfarm/db/master/log%d-%d" with the 
following structure:
@verbatim
function slave.tag1(transactionid:int,stamp:timestamp);
  barrier doit:= slave.open(transactionid);
    sql.transaction();
    tag1_b := bat.new(:oid,:int);
    ...
    bat.insert(tag1_b,3:oid,232:int); #example update
    ...
    sql.append("schema","table","col",tag1_b,tag);
    slave.close(transactionid,stamp);
    sql.commit();
  exit doit;
end tag1;
slave.tag_1(1,"2009-09-03 15:49:45.000":timestamp);
slave.drop("tag1");
@end verbatim

The slave.open() simply checks the replica log administration table
and ignores duplicate attempts to roll the database forward.

The operations are executed in the serial order as on the master,
which should lead to the same optimistic transactional behavior.
All queries are considered running in auto-commit mode, because
the SQL frontend does not provide the hook (yet) for better transaction
boundary control.
The transaction identifier is part of the call to the function
with the transaction update details.
@- Interaction protocol
The master node simply waits for a slave to request the transmission of the missing log files.
The request includes the URI of the slave and the user credentials needed to establish a connection.
The last parameter is the last known transaction id successfully re-executed.
The master forks a thread to start flushing the blacklog files.

Grouping the operations in temporary MAL functions
makes it easy to skip its execution when we detect
that it has been executed before. 

@- Log file management
The log records are grouped into separate files. 
They are the units for re-submission and the scheme is set up to be idempotent. 
A slave always starts synchronizing using the maximal tag stored in the slave log.

The log files ultimately pollute your database and have to
be (re)moved. This is considered a responsibility for the DBA,
for it involves making a checkpoint or securely storing the logs
into an archive. It can be automated by asking all slaves
for their last transaction id and purge all obsolete files.

Any error recognized during the replay should freeze the slave,
because the synchronization integrity might become compromised.

Aside  from being limited to autocommit transactions, the current
implementation scheme has a hole. The log record is written just
before transaction commit, including the activation call.
The call and the flush of the commit record to the SQL
log should be one atomic action, which amounts to a commit
sequence of two 'databases'. It can only be handled when
the SQL commit becomes visible at the MAL layer.
[ Or, inject the transaction approval record into the log file
when the next query starts, checking for any transaction
errors first.]

COPY INTO commands cause the master to freeze the images of
all slaves. For capturing the input file and forwarding it to
the slaves seems overly complicated.

The slaves invalidation scheme is rather crude. The log directory
is emptied and a new log file is created. Subsequent attempts
by the slaves to access transactions ID before the invalidation
are flagged as errors.

@- Wishlist
After setting the slave property, it could initiate full synchronization
by asking for a catalog dump and replaying the logs. Provided, they
have been kept around since the start.
Alternatively, we can use the infrastructure for Octopus to pull the data from the master.
For both we need msqldump functionality in the SQL code base.

A slave property can be set to a list of masters, which turns the
the slave into a serving multiple sources. It calls for splitting
the slavelog.

The tables in the slave should be set read-only, otherwise we
have to double check integrity and bail out replication on violation.
One solution is to store the replicated database in its own
schema and grant read access to all users.
[show example how to set up ]

A validation script (or database diff) might be helpful to
asses the database content for possible integrity violations.
@{
@mal
module master;

command open():oid
address MASTERopen
comment "Create a replication record";

command close(tag:oid):void
address MASTERclose
comment "Close the replication record";

command start():void
address MASTERstart
comment "Restart synchronisation with the slaves";

command stop():void
address MASTERstop
comment "Stop synchronisation of the slaves";

command freeze():void
address MASTERfreeze
comment "Invalidate all copies maintained at slaves";

pattern append(mvc:ptr, s:str, t:str, c:str, :any_1, tag:oid):ptr
address MASTERappendValue
comment "Dump the scalar on the MAL log";

pattern append(mvc:ptr, s:str, t:str, c:str, b:bat[:oid,:any_1], tag:oid):ptr
address MASTERappend
comment "Dump the BAT on the MAL log";

pattern delete(s:str, t:str, b:bat[:oid,:any_1], tag:oid):void
address MASTERdelete
comment "Dump the BAT with deletions on the MAL log";

pattern copy(sname:str, tname:str, tsep:str, rsep:str, ssep:str, ns:str, fname:str, nr:lng, offset:lng, tag:oid):void
address MASTERcopy
comment "A copy command leads to invalidation of the slave's image. A dump restore will be required.";

pattern replay(uri:str, usr:str, pw:str, tag:oid):void
address MASTERreplay
comment "Slave calls the master to restart sending the missing transactions
from a certain point as a named user.";

command sync(uri:str, usr:str, pw:str, tag:oid):void
address MASTERsync
comment "Login to slave with credentials to initiate submission of the log records";

command getURI():str
address MASTERgetURI
comment "Return the URI for the master";

command getCutOffTag():oid
address MASTERgetCutOffTag
comment "Return the cutoff tag for transaction synchronization";

command prelude():void
address MASTERprelude
comment "Prepare the server for the master role. Or remove any leftover log files.";

module slave;

command sync():void
address SLAVEsyncDefault
comment "Login to master with environment credentials to initiate submission of the log records";
command sync(uri:str):void
address SLAVEsyncURI
comment "Login to master with admin credentials to initiate submission of the log records";
command sync(uri:str, usr:str, pw:str, tag:oid):void
address SLAVEsync
comment "Login to master uri with admin credentials to initiate submission of the log records";

command stop():void
address SLAVEstop
comment "Slave suspends synchronisation with master";

pattern open(tag:oid):int
address SLAVEopen
comment "Marks the start of a replication record. It checks the slave log table for existence of the tag. If so, or upon an error, it kills the log channel.";

command close(tag:oid,stamp:timestamp)
address SLAVEclose
comment "End of replication record. Add the time stamp op completion to the slave log.";

command drop{unsafe}(fcnname:str)
address SLAVEdrop
comment "Remove the replica function from the module";

command protect(schema:str, table:str)
address SLAVEprotect
comment "Mark a table for readonly";

command isprotected(schema:str, table:str):bit
address SLAVEisprotected
comment "Check protection state";

command synchronizing():int
address SLAVEsynchronizing
comment "Are we actively synchronizing with the master";

command prelude():void
address SLAVEprelude
comment "Prepare the server for the slave role.";

master.prelude();
slave.prelude();
@-
@+ Implementation code 
@h
#ifndef _REPLICATOR_H
#define _REPLICATOR_H

#include "mal.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"
#include <Mapi.h>
#include "mtime.h"

/*#define _DEBUG_REPLICATION_  */

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define replication_export extern __declspec(dllimport)
#else
#define replication_export extern __declspec(dllexport)
#endif
#else
#define replication_export extern
#endif

replication_export int MASTERroleEnabled(void);
replication_export str MASTERopen(oid *ret);
replication_export str MASTERclose(int *ret, oid *tag);
replication_export str MASTERstart(int *ret);
replication_export str MASTERstop(int *ret);
replication_export str MASTERfreeze(int *ret);
replication_export str MASTERreplay(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERcopy(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str SLAVEsyncDefault(int  *ret);
replication_export str SLAVEsyncURI(int  *ret, str *conn);
replication_export str SLAVEsync(int  *ret, str *uri, str *usr, str *pw, oid *tag);
replication_export str MASTERsync(int  *ret, str *uri, str *usr, str *pw, oid *tag);
replication_export str SLAVEstop(int *ret);
replication_export str MASTERprelude(int *ret);
replication_export str MASTERgetURI(str *ret);
replication_export str MASTERgetCutOffTag(int *ret);

replication_export str SLAVEopen(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str SLAVEclose(int *ret, oid *tag, timestamp *stamp);
replication_export str SLAVEdrop(int *ret, str *tag);
replication_export str SLAVEprotect(int *ret, str *schema, str *table);
replication_export str SLAVEisprotected(bit *ret, str *schema, str *table);
replication_export int SLAVEisprotectedInternal(str schema, str table);
replication_export str SLAVEprelude(int *ret);
replication_export str SLAVEsynchronizing(int *ret);
replication_export BAT *SLAVEtable(void);
#endif /* _REPLICATOR_H */
@c
#include "mal_config.h"
#include "replication.h"
#include <sys/types.h>
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#endif
#include "sabaoth.h"
#include "mal_client.h"
#include "algebra.h"
#include <mal_sabaoth.h>
#include <mtime.h>

@-
The start of the query is marked with a replica tag.
It also designates the local buffer to collect the update
requests before they are shipped to the log.
The tag is returned for marking all related updates.
The final code should contain a loop to determine the last replication tag.
@c
#define MASTER "master/"
#define REPLICA "log"OIDFMT"-"OIDFMT
#define REPLICABLOCK 20
#define REPLICADELAY 5000

static struct MASTERRECORD {
	char *buf;	/* assembled update function */
	int limit;
	int top;
	oid tag;	/* transaction identifier of next needed */
	int fcn;	/* identifier to differentiate function */
} *master;
static int mtop = 0;
static int mlimit = 0;

static MT_Lock repLck;	

/* Master log file properties */
static oid startTag = 0;	/* current transaction file bounds */
static oid endTag = 0;		/* last transaction identifier given */
static int fcnTag = 0;		/* unique labeling of the functions */
static oid cutoffTag = 0;	/* to signal out of date slaves */
static char logFile[PATHLENGTH]=""; 
static stream *repFile = 0;
static int sendLogs = FALSE;		/* permit forwarding of log records */

/* slave synchronisation status */
static BAT *slavetid = 0;
static BAT *slavecommit = 0;
static BAT *slavevalid = 0;
static BAT *slaveerror = 0;
static int acceptLogs = 0;

static void
SLAVEinitLog()
{
	if (slavecommit == NULL) {
		@:createBAT(slavetid,TYPE_oid)@
		@:createBAT(slavecommit,TYPE_timestamp)@
		@:createBAT(slavevalid,TYPE_timestamp)@
		@:createBAT(slaveerror,TYPE_str)@
	}
}

static int
MASTERfindLogFile(char logFile[PATHLENGTH], oid transactionid)
{
	oid btag, etag;
	DIR *dirp;
	struct dirent *dent;

#ifdef _DEBUG_REPLICATION_
	mnstr_printf(GDKout, "#find the log file containing %d\n", transactionid);
#endif
	if (repFile)
		mnstr_close(repFile);
	repFile = NULL;
	dirp = opendir(MASTER);
	if (dirp == NULL)
		return -1;
	while ((dent = readdir(dirp)) != NULL)
		if (sscanf(dent->d_name, "log" OIDFMT "-" OIDFMT, &btag, &etag) == 2 && btag <= transactionid && transactionid < etag) {
			snprintf(logFile, PATHLENGTH, "%s%s", MASTER, dent->d_name);
			slash_2_dir_sep(logFile);
			return (int)etag;
		}
	return -1;
}

/* The replication log file contains a number of log functions.
 * When the limit is reached, we switch to a new file */
static int
MASTERincrement()
{
	char buf[PATHLENGTH];

	endTag++;   /* assign a new transaction identifier */
	snprintf(buf, PATHLENGTH, MASTER REPLICA, startTag, endTag);
	slash_2_dir_sep(buf);
	if (strcmp(logFile, buf))
		rename(logFile, buf);
	strcpy(logFile, buf);
	/* once in a while we take a new log file */
	if (endTag - startTag >= REPLICABLOCK) {
		if (repFile)
			mnstr_close(repFile);
		repFile = NULL;
	}
	if (repFile == NULL)
		repFile = open_wastream(buf);
	return repFile == NULL;
}

str
MASTERprelude(int *ret)
{
	int master;
	oid tag, etag;
	DIR *dirp;
	struct dirent *dent;

	(void)ret;
	MT_lock_init(&repLck, "replication");   /* we always need this */
	master = GDKgetenv_istrue("replication_master") &&
			 GDKgetenv("replication_slave") == NULL;
#ifdef _DEBUG_REPLICATION_
	mnstr_printf(GDKout, "#Initialize the master role?%s\n", master ? "yes" : "no");
#endif
	mal_set_lock(repLck, "replication");
	if (!master) {
		/* drop all remaining log files if master mode is switched off */
		GDKremovedir(MASTER);
		mal_unset_lock(repLck, "replication");
		return MAL_SUCCEED;
	}
	mkdir(MASTER, 0755); /* ensure existance of the replica pool */
	mnstr_printf(GDKout, "# Replication mode enabled\n");

	/* find the bounds for the last replication log file */
	/* assume directory is sorted */
	dirp = opendir(MASTER);
	if (dirp == NULL) {
		mal_unset_lock(repLck, "replication");
		return MAL_SUCCEED;
	}
	cutoffTag = INT_MAX;
	while ((dent = readdir(dirp)) != NULL) {
		if (sscanf(dent->d_name, "log" OIDFMT "-" OIDFMT, &tag, &etag) == 2) {
			if (tag < cutoffTag)
				cutoffTag = tag;
			if (tag >= startTag) {
				startTag = tag;
				endTag = etag;
				strcpy(logFile, dent->d_name);
			}
		}
	}
	if (cutoffTag == INT_MAX)
		cutoffTag = 0;
#ifdef _DEBUG_REPLICATION_
	mnstr_printf(GDKout, "#last log file log%05d-%05d\n", startTag, endTag);
#endif
	startTag = endTag;
	sendLogs = TRUE;
	mal_unset_lock(repLck, "replication");
	return MAL_SUCCEED;
}

str
MASTERgetURI(str *ret)
{
	str mero = GDKgetenv("merovingian_uri");

	if (!mero)
		throw(MAL, "master.getURI",
				"this database is not running under merovingian");

	*ret = GDKstrdup(mero);
	return MAL_SUCCEED;
}

str
MASTERgetCutOffTag(int *ret)
{
	*ret = (int)cutoffTag;
	return MAL_SUCCEED;
}

int
MASTERroleEnabled(void)
{
	return startTag > 0;
}

static int
MASTERgetBuffer(oid tag)
{
	int i;

	for (i = 0; i < mtop; i++)
		if (master[i].tag == tag)
			return i;
	for (i = 0; i < mlimit; i++)
		if (master[i].tag == 0)
			break;
	if (i == 0) {
		master = GDKzalloc(sizeof(struct MASTERRECORD) * (mlimit + 32));
		mlimit = 32;
	} else if (i == mlimit) {
		master = GDKrealloc(master, sizeof(struct MASTERRECORD) * (mlimit + 32));
		mlimit += 32;
	}
	mtop = i >= mtop ? i + 1 : mtop;
	if (master[i].buf == 0) {
		master[i].buf = (char*)GDKzalloc(2 * 1024);
		master[i].limit = 2 * 1024;
		master[i].top = 0;
	}
	master[i].tag = tag;
	return i;
}

/*
For the time being, we assume that all chunks are kept in the
master directory. A better scheme is to find the last chunk
by reading the directory itself.
*/
str
MASTERopen(oid *ret)
{
	int i, l, len;

	mal_set_lock(repLck, "replication");
	/* get a replica buffer */

	i = MASTERgetBuffer(fcnTag);
	/* prepare the MAL redo record */
	len = master[i].limit - master[i].top - 1;
	master[i].fcn = fcnTag;
	while ((l = snprintf(master[i].buf + master[i].top, len,
				"function slave.tag_%d{unsafe}(tag:oid,stamp:timestamp);\n"
				"barrier doit:= slave.open(tag);\n"
				"sql.transaction();\n",
				fcnTag)) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL) {
			mal_unset_lock(repLck, "replication");
			throw(MAL, "replication.open", MAL_MALLOC_FAIL);
		}
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	mal_unset_lock(repLck, "replication");

	*ret = fcnTag++;
	return MAL_SUCCEED;
}

/* Upon closure of the transaction, we assign the transaction identifier
 * and reflect it in the log file name as well. */
str
MASTERclose(int *ret, oid *tag)
{
	timestamp stamp = *timestamp_nil;
	str val = NULL;
	int i, l, len;
	char buf[BUFSIZ];

	(void)ret;
	i = MASTERgetBuffer(*tag);
	mal_set_lock(repLck, "replication");
	MTIMEepoch(&stamp);
	ATOMformat(TYPE_timestamp, (ptr) & stamp, &val);
	snprintf(buf, BUFSIZ, "tag_" OIDFMT, *tag);

	/* the function name is returned by the slave to built
	   a flow dependency. Otherwise the function could be
	   destroyed while execution it. */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len,
				"sql.commit();\n"
				"slave.close(tag,stamp);\n"
				"exit doit;\n"
				"end %s;\n"
				"slave.%s(" OIDFMT ":oid,\"%s\":timestamp);\n"
								   "slave.drop(\"%s\");\n",
				buf, buf, endTag, val, buf)) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL) {
			mal_unset_lock(repLck, "replication");
			throw(MAL, "replication.close", MAL_MALLOC_FAIL);
		}
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(val);

	MASTERincrement();
	if (repFile == NULL) {
		mal_unset_lock(repLck, "replication");
		throw(MAL, "master.close", RUNTIME_FILE_NOT_FOUND);
	}
	mnstr_printf(repFile, "%s", master[i].buf);
	mnstr_flush(repFile);
	master[i].buf[0] = 0;
	master[i].top = 0;
	master[i].tag = 0;
	mal_unset_lock(repLck, "replication");
	if (mnstr_errnr(repFile))
		throw(MAL, "replication.close", RUNTIME_STREAM_FAILED);
	return MAL_SUCCEED;
}

static str
MASTERdump(BAT *b, str buf, int type, int tag)
{
	BATiter bi;
	BUN p, q;
	char *headv = 0, *tailv = 0;
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;

	i = MASTERgetBuffer(tag);
	bi = bat_iterator(b);
	BATaccessBegin(b, USE_HEAD | USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q)
	{
		ATOMformat(getHeadType(type), BUNhead(bi, p), &headv);
		ATOMformat(getTailType(type), BUNtail(bi, p), &tailv);
		len = master[i].limit - master[i].top - 1;
		if (getTailType(type) <= TYPE_str &&
			getHeadType(type) <= TYPE_str) {
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, %s:%s, %s:%s);\n",
						buf, headv, head, tailv, tail)) >= len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		} else if (getTailType(type) > TYPE_str &&
				   getHeadType(type) > TYPE_str) {
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, \"%s\":%s, \"%s\":%s);\n",
						buf, headv, head, tailv, tail)) >= len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		} else if (getTailType(type) > TYPE_str) {
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, %s:%s, \"%s\":%s);\n",
						buf, headv, head, tailv, tail)) == len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		} else{
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, \"%s\":%s, %s:%s);\n",
						buf, headv, head, tailv, tail)) == len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		}
		master[i].top += l;
		master[i].buf[master[i].top] = 0;
	}
	BATaccessEnd(b, USE_HEAD | USE_TAIL, MMAP_SEQUENTIAL);
	GDKfree(tail);
	GDKfree(head);
	return MAL_SUCCEED;
}

str
MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tag = *(int*)getArgReference(stk, pci, 6);
	ptr *res = (ptr*)getArgReference(stk, pci, 0);
	ptr *m = (ptr*)getArgReference(stk, pci, 1);
	InstrPtr q;
	str val = NULL;
	int i, len;

	(void)cntxt;
	i = MASTERgetBuffer(tag);
	q = copyInstruction(pci);
	q->argc--;
	setModuleId(q, putName("sql", 3));

	val = instruction2str(mb, stk, q, LIST_MAL_CALL);
	freeInstruction(q);

	*res = *m;

	len = master[i].limit - master[i].top - 1;
	while (snprintf(master[i].buf + master[i].top, len, "%s\n", val) >= len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.append", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += (int)(strlen(val) + 1);
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	return MAL_SUCCEED;
}

str
MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *schema = (str*)getArgReference(stk, pci, 1);
	str *table = (str*)getArgReference(stk, pci, 2);
	str *col = (str*)getArgReference(stk, pci, 3);
	int *bid = (int*)getArgReference(stk, pci, 4);
	int tag = *(int*)getArgReference(stk, pci, 5);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 4);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;
	str msg;

	(void)cntxt;
	b = BATdescriptor(*bid);
	if (b == NULL)
		throw(MAL, "replication.append", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "tag_%d_%s:=bat.new(:%s,:%s);\n",
				tag, getArgName(mb, pci, 4), head, tail)) >= len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.append", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf, BUFSIZ, "tag_%d_%s", tag, getArgName(mb, pci, 4));
	msg = MASTERdump(b, buf, type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "sql.append(\"%s\",\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
				*schema, *table, *col, buf, tag, getArgName(mb, pci, 4))) >= len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.append", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

str
MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *schema = (str*)getArgReference(stk, pci, 1);
	str *table = (str*)getArgReference(stk, pci, 2);
	int *bid = (int*)getArgReference(stk, pci, 3);
	int tag = *(int*)getArgReference(stk, pci, 4);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 3);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	str msg;
	int i, l, len;

	(void)cntxt;
	b = BATdescriptor(*bid);
	if (b == NULL)
		throw(MAL, "replication.delete", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "tag_%d_%s:=bat.new(:%s,:%s);\n",
				tag, getArgName(mb, pci, 3), head, tail)) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.delete", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf, BUFSIZ, "tag_%d_%s", tag, getArgName(mb, pci, 3));
	msg = MASTERdump(b, buf, type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "sql.delete(\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
				*schema, *table, buf, tag, getArgName(mb, pci, 4))) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.delete", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

/*
The input to the copy command comes from a stream, e.g. stdin. This makes
forwarding the updates to the slave cumbersome at this point.
Therefore, we simply freeze the version retained at the slave,
requesting it to resynchronize from start.
*/
str
MASTERcopy(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void)cntxt;
	(void)mb;
	(void)stk;
	(void)pci;
	throw(MAL, "master.copy", "Not yet implemented");
}

/*
Replaying the MAL logs is straightforward.  Each slave is represented 
by a thread in the master, which looks for the pending updates and 
issues it as a MAL program.
The last log file may be sent multiple times.

The master has to assume that the slave has initialized its SQL environment properly.

[todo:force a new file when it happens too often.]
*/
static struct MASTERrecord {
	str uri;
	oid tag;        /* next one to sent */
	Mapi m;
	time_t last_connect;
	time_t last_disconnect;
} masterstatus[MAL_MAXCLIENTS];

static void
MASTERsend(void *arg)
{
	int idx = *(int*)arg;
	int nxt, master;
	stream *s;
	bstream *bs;
	MapiHdl hdl;
	char logFile[PATHLENGTH];

#ifdef _DEBUG_REPLICATION_
	mnstr_printf(GDKout, "#send the log file starting at transaction id %d\n", masterstatus[idx].tag);
#endif
	/* find the last replication log file */
	master = GDKgetenv_istrue("replication_master") &&
			 GDKgetenv("replication_slave") == NULL;
	/* If the slave starts from scratch, it will sent the 0-tag.
	 * This can simply be replaced by the lowest number known.  But,
	 * then the slave should use the BATmax option instead of the
	 * BATcount to determine the tag. */
	if (masterstatus[idx].tag == 0)
		masterstatus[idx].tag = (oid)cutoffTag;
	if (master == 0 || masterstatus[idx].tag < (oid)cutoffTag) {
		GDKfree(masterstatus[idx].uri);
		masterstatus[idx].uri = NULL;
		masterstatus[idx].tag = 0;
		masterstatus[idx].m = 0;
		return;
	}
	/* Upon succesful transmission we wait for new stuff, this is
	 * recognized by checking the tags. It leads to re-sending the last
	 * log file. To avoid ever larger files to be resent, we should
	 * switch to a new log file once in a while.  */
	while (1) {
		nxt = MASTERfindLogFile(logFile, masterstatus[idx].tag);
		if (nxt < 0) {
			/* wait for log file to become available */
			MT_sleep_ms(REPLICADELAY);
			continue;
		}
		if (mapi_ping(masterstatus[idx].m) != MOK)
			break;  /* slave is gone */
		if (sendLogs == FALSE) {
			/* suspend sending */
			MT_sleep_ms(REPLICADELAY);
			continue;
		}
#ifdef _DEBUG_REPLICATION_
		mnstr_printf(GDKout, "#sent log file %s\n", logFile);
#endif
		s = open_rastream(logFile);
		if (s == NULL)
			continue;
		if (mnstr_errnr(s)) {
			mnstr_destroy(s);
			continue;
		}

		/* avoid concurrent addition of log records */
		/* but only on the last file */
		if (nxt == (int)endTag)
			mal_set_lock(repLck, "replication");
		if (repFile)
			mnstr_flush(repFile);
		/* The tricky part of the block wise read is to ensure we sent
		 * proper newline terminated commands.  Moreover, we would not
		 * like to block due to sending for old files.  */
		/* read the complete file [now trimmed to 64KB]*/
		/* need better sequence to deal with larger files */
		bs = bstream_create(s, 128 * BLOCK);
		if (bstream_next(bs) < 0) {
			bstream_destroy(bs);
			showException(MAL, "master.send", "read error");
			break;
		}
		hdl = mapi_query(masterstatus[idx].m, bs->buf);
		masterstatus[idx].tag = nxt;
		if (nxt == (int)endTag)
			mal_unset_lock(repLck, "replication");
		close_stream(s);
		if (mapi_result_error(hdl)) {
			showException(getExceptionType(mapi_result_error(hdl)),
				"master.send",
				"%s", getExceptionMessage(mapi_result_error(hdl)));
			break; /* all errors are fatal */
		}
		if (hdl)
			mapi_close_handle(hdl);
	}

	mal_unset_lock(repLck, "replication");
#ifdef _DEBUG_REPLICATION_
	printf("#replay thread finished \n");
#endif
	GDKfree(masterstatus[idx].uri);
	masterstatus[idx].uri = NULL;
	masterstatus[idx].m = NULL;
	masterstatus[idx].tag = 0;
}

/*
Stopping all slave synchronisation is needed before you perform
administrative updates.
*/
str
MASTERstop(int *ret)
{
	(void)ret;
	sendLogs = FALSE;
	return MAL_SUCCEED;
}

str
MASTERstart(int *ret)
{
	(void)ret;
	sendLogs = TRUE;
	return MAL_SUCCEED;
}

/*
The master may decide that all images held by the slaves have become invalid.
This should cause a rebuilt from scratch when a slave attempts to synchronize.
Invalidation of the snapshot has the side-effect of cleaning up the master
log directory. This means, we can not simply inject an invalidation message
in the log stream. Instead, we have to a snapshot marker somewhere, which
is returned by the slave upon re-connection.
*/
str
MASTERfreeze(int *ret)
{
	int i;

	(void)ret;
	mal_set_lock(repLck, "replication");
	for (i = 0; i < MAL_MAXCLIENTS; i++)
		if (masterstatus[i].uri)
			mal_clients[ i].mode = FINISHING;

	if (repFile)
		mnstr_close(repFile);
	repFile = NULL;

	sendLogs = FALSE;
	GDKremovedir(MASTER);
	mkdir(MASTER, 0755); /* ensure existance of the replica pool */
	cutoffTag = startTag = endTag; /* the next one to expect */
	MASTERincrement();
	mal_unset_lock(repLck, "replication");
	return MAL_SUCCEED;
}

/*
The slave process sents a remote master.sync request with all
the information needed for the master to set up and start a log forwarding thread.
*/
str
MASTERsync(int *ret, str *uri, str *usr, str *pw, oid *tag)
{
	Mapi mapi;
	MT_Id tid;
	int i, free = MAL_MAXCLIENTS, fnd = 0;
	oid t = *tag;

	(void)ret;

#ifdef _DEBUG_REPLICATION_
	mnstr_printf(GDKout, "#replay the log from  %s %s %s %d\n",
		*uri, *usr, *pw, *tag);
#endif
	if (t == 0)
		t = cutoffTag;
	else if (t < (oid)cutoffTag)
		throw(MAL, "master.sync", "Slave out of date");

	for (i = 0; i < MAL_MAXCLIENTS; i++)
		if (masterstatus[i].uri == NULL) {
			if (free == MAL_MAXCLIENTS)
				free = i;
		} else
			fnd |= strcmp(masterstatus[i].uri, *uri) == 0;

	if (fnd) {
		sendLogs = TRUE;    /* restart sending */
		return MAL_SUCCEED; /* slave already known */
	}
	if (free == MAL_MAXCLIENTS)
		throw(MAL, "master.sync", "Too many concurrent actions");

	/* master makes a connection with the slave */
	mapi = mapi_mapiuri(*uri, *usr, *pw, "msql");
	if (mapi_error(mapi))
		throw(MAL, "master.sync", "unable to connect to '%s': %s",
			*uri, mapi_error_str(mapi));

	if (mapi_reconnect(mapi) != MOK)
		throw(IO, "master.sync", "failed to connect to '%s': %s",
			*uri, mapi_error_str(mapi));

	masterstatus[free].uri = GDKstrdup(*uri);
	masterstatus[free].tag = t;
	masterstatus[free].m = mapi;
	if (MT_create_thread(&tid, MASTERsend, (void *)&free, MT_THR_DETACHED) != 0)
		throw(MAL, "master.sync", "cannot fork new client");

#ifdef _DEBUG_REPLICATION_
	mnstr_printf(GDKout, "#awaiting replay of the log \n");
#endif
	return MAL_SUCCEED;
}

/*
Prepare the remote call to the master
*/
str
SLAVEsync(int *ret, str *uri, str *usr, str *pw, oid *tag)
{
	Mapi mapi;
	MapiHdl hdl;
	str luri;
	char buf[BUFSIZ];

	(void)ret;

#ifdef _DEBUG_REPLICATION_
	mnstr_printf(GDKout, "#request replay the log from  %s %s %s %d\n",
		*uri, *usr, *pw, *tag);
#endif

	mapi = mapi_mapiuri(*uri, *usr, *pw, "mal");
	if (mapi_error(mapi))
		throw(MAL, "slave.sync", "unable to connect to '%s': %s",
			*uri, mapi_error_str(mapi));

	if (mapi_reconnect(mapi) != MOK)
		throw(IO, "slave.sync", "failed to connect to '%s': %s",
			*uri, mapi_error_str(mapi));

	SABgetLocalConnectionURI(&luri);
	if (luri == NULL)
		throw(MAL, "slave.sync", OPERATION_FAILED ": URI not found");

	snprintf(buf, BUFSIZ, "master.sync(\"%s\",\"%s\",\"%s\"," OIDFMT ":oid);", luri, *usr, *pw, *tag);
	GDKfree(luri);
	hdl = mapi_query(mapi, buf);
	if (hdl == NULL) {
		if (mapi_error(mapi) != MOK)
			throw(IO, "slave.sync", OPERATION_FAILED ": an error occurred on connection: %s",
				mapi_error_str(mapi));
		else
			throw(MAL, "slave.sync", OPERATION_FAILED ": remote function invocation didn't return a result");
	}
	if (mapi_result_error(hdl)) {
		str err = createException(
			getExceptionType(mapi_result_error(hdl)),
			"slave.sync",
			"%s", getExceptionMessage(mapi_result_error(hdl)));
		mapi_close_handle(hdl);
		return err;
	}
	acceptLogs = TRUE;
#ifdef _DEBUG_REPLICATION_
	mnstr_printf(GDKout, "#slave awaiting replay of the log \n");
	mnstr_printf(GDKout, "#%s\n", buf);
#endif
	return MAL_SUCCEED;
}

str
SLAVEsyncURI(int *ret, str *uri)
{
	oid tag = 0;
	str usr = "monetdb";
	str pw = "monetdb";

	(void)ret;
	if (GDKgetenv("replication_slave") == NULL)
		throw(MAL, "master.sync", "Slave property not set");

	/* get identity of next tag expected */
	mal_set_lock(repLck, "replication");
	SLAVEinitLog();
	if (slavecommit == NULL) {
		mal_unset_lock(repLck, "replication");
		throw(MAL, "slave.sync", OPERATION_FAILED);
	}
	if (BATcount(slavetid))
		BATmax(slavetid, &tag);
	mal_unset_lock(repLck, "replication");
	return SLAVEsync(ret, uri, &usr, &pw, &tag);
}

str
SLAVEsyncDefault(int *ret)
{
	str uri;
	uri = GDKgetenv("replication_slave");
	if (uri == NULL)
		throw(MAL, "master.sync", "Slave property not set");
	return SLAVEsyncURI(ret, &uri);
}

/*
The master thread is stopped at the slave side by closing
its client record. 
*/
str
SLAVEstop(int *ret)
{
	str uri;
	(void)ret;
	uri = GDKgetenv("replication_slave");
	if (uri == NULL)
		throw(MAL, "slave.stop", "Slave property not set");
	if (acceptLogs == 0)
		throw(MAL, "slave.stop", "Synchronisation not active");
	acceptLogs = 0;
	return MAL_SUCCEED;
}

/*
To keep track of the transactions being replayed
we use two BATs with timestamps of their completion
in the master and the slave.
A null indicates a failure to replay and indicates a
incorrect database state.
The error BAT can be used to keep messages for offline
inspection.
The transaction identifier is used as an oid into this table.
*/

@= createBAT
    @1 = BATdescriptor(BBPindex("@1"));
    if (@1 == NULL){
		@1 = BATnew(TYPE_void, @2, 1024);
		if (@1 == NULL)
			return ;

		BATseqbase(@1,0); /* essential */
		BBPrename(@1->batCacheid, "@1");
		BATmode(@1, PERSISTENT);
		BBPkeepref(@1->batCacheid);
#ifdef _DEBUG_REPLICATION_
		printf("#created @1\n");
#endif
	}
@c

str
SLAVEopen(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = (int*)getArgReference(stk, pci, 0);
	oid *tag = (oid*)getArgReference(stk, pci, 1);

	(void)mb;
	SLAVEinitLog();
	if (slavecommit == NULL)
		throw(MAL, "slave.open", OPERATION_FAILED);
	if (acceptLogs == 0) {
		/* close this connection, synchronize later */
		mal_clients[cntxt->idx].mode = FINISHING;
		throw(MAL, "slave.open", "No synchronisation allowed");
	}
	/* check if we have seen it before */
	*ret = BUNfnd(BATmirror(slavetid), tag) == BUN_NONE;
	return MAL_SUCCEED;
}

str
SLAVEclose(int *ret, oid *tag, timestamp *valid)
{
	timestamp stamp;
	str err = "";

	(void)ret;
	SLAVEinitLog();
	if (slavecommit == NULL)
		/* abort the transaction */
		throw(MAL, "slave.clase", OPERATION_FAILED);

	if (BUNfnd(BATmirror(slavetid), tag) != BUN_NONE)
		throw(MAL, "slave.close", "Out of order execution");

	mal_set_lock(repLck, "replication");
	MTIMEepoch(&stamp);
	BUNappend(slavetid, tag, FALSE);
	BUNappend(slavecommit, &stamp, FALSE);
	BUNappend(slavevalid, valid, FALSE);
	BUNappend(slaveerror, err, FALSE);
	mal_unset_lock(repLck, "replication");
	return MAL_SUCCEED;
}

@-
The slave status can be made visible through an SQL
table producing function.
@verbatim
create function slavelog () 
	returns table ("tid" int, "commit" timestamp, "valid" timestamp, "error" string)
	external name sql.dump_slave;
@end verbatim

@c
BAT *
SLAVEtable(void)
{
	BAT *t;
	t = BATnew(TYPE_str, TYPE_bat, 3);
	if (t == NULL)
		return NULL;
	if (slavecommit == NULL ||
		slavevalid == NULL ||
		slaveerror == NULL)
		return t;
	BUNins(t, "tid", &slavetid->batCacheid, FALSE);
	BUNins(t, "commit", &slavecommit->batCacheid, FALSE);
	BUNins(t, "valid", &slavevalid->batCacheid, FALSE);
	BUNins(t, "error", &slaveerror->batCacheid, FALSE);
	return t;
}

str
SLAVEdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	/*
	   str *schema = (str*)getArgReference(stk, pci, 1);
	   str *table = (str*)getArgReference(stk, pci, 2);
	   int *bid = (int*)getArgReference(stk, pci, 3);
	   int tag = *(int*)getArgReference(stk, pci, 4);
	 */

	(void)cntxt;
	(void)mb;
	(void)stk;
	(void)pci;
	/*
	   (void)schema;
	   (void)table;
	   (void)bid;
	   (void)tag;
	 */
	SLAVEinitLog();
	return MAL_SUCCEED;
}

str
SLAVEdrop(int *ret, str *tag)
{
	Symbol prg;
	Module mod;

	prg = findSymbol(NULL, getName("slave", 5), *tag);
	mod = findModule(NULL, getName("slave", 5));
	if (prg == NULL || mod == NULL)
		throw(MAL, "slave.drop", "Symbol not found");
	deleteSymbol(mod, prg);
	(void)ret;
	return MAL_SUCCEED;
}

/*
We keep a list of all tables updated by the replication scheme.
They become re-only accessible.
*/
static str *schemes;
static str *tables; 
static int top, limit;

str
SLAVEprotect(int *ret, str *schema, str *table)
{
	(void)ret;
	if (schemes == NULL) {
		limit = 1024;
		top = 0;
		schemes = GDKzalloc(limit * sizeof(str));
		if (schemes == NULL)
			throw(MAL, "slave.protect", MAL_MALLOC_FAIL);
		tables = GDKzalloc(limit * sizeof(str));
		if (tables == NULL)
			throw(MAL, "slave.protect", MAL_MALLOC_FAIL);
	}
	if (top == limit)
		throw(MAL, "slave.protect", "Out of table slots");
	schemes[top] = GDKstrdup(*schema);
	tables[top] = GDKstrdup(*table);
	top++;
	return MAL_SUCCEED;
}

int
SLAVEisprotectedInternal(str schema, str table)
{
	int i;

	if (schemes == NULL || tables == NULL)
		return FALSE;
	for (i = 0; i < top; i++)
		if (schemes[i] && strcmp(schemes[i], schema) == 0 &&
			tables[i] && strcmp(tables[i], table) == 0)
			return TRUE;
	return FALSE;
}

str
SLAVEisprotected(bit *ret, str *schema, str *table)
{
	*ret = SLAVEisprotectedInternal(*schema, *table);
	return MAL_SUCCEED;
}

str
SLAVEprelude(int *ret)
{
	/* to be called after MASTERprelude  */
	if (GDKgetenv("replication_slave") != NULL) {
#ifdef _DEBUG_REPLICATION_
		mnstr_printf(GDKout, "#initialize slave\n");
#endif
		mal_set_lock(repLck, "replication");
		SLAVEinitLog();
		acceptLogs = TRUE;
		mal_unset_lock(repLck, "replication");
		/*	SLAVEsyncDefault(ret);
		   can not work, because we are still in MAL initialization
		   and this would require a running SQL environment.
		   The replay must be started at the end of the SQL init */
	}
	(void)ret;
	return MAL_SUCCEED;
}

str
SLAVEsynchronizing(int *ret)
{
	*ret = acceptLogs != 0;
	return MAL_SUCCEED;
}
@}
