@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f crackers
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006
@* Cracker index


StM: This text is obsolete as of April 26, 2006, and needs to be updated!


A cracker index is a volatile datastructure which acts as
a non-dense index into a BAT. The index is incrementally built
based on the fragments needed by queries.
Each select operation results in a partial re-clustering of the tuples
such that the result set is a consecutive memory area in the BAT.
This set can be returned as a BAT view for further processing.

A cracker index is created with the command @sc{crackers.new}
and destroyed using @sc{crackers.destroy}.
Multiple calls to create/destroy the cracker index on the same
argument are ignored.

The cracker index can be created for the time being on
tail columns of type {int,lng,dbl,flt,time}. The head
is always of type @sc{oid}.

Once a cracker index exist, portions can be extracted
using @sc{crackers.select} and @sc{crackers.uselect},
which semantically behave as their algebraic counterparts.
Both operations may have to glue pieces from the cracked
bat to satisfy the BAT semantics.

Qst: are these operators overloaded to initiate a crack
operation first?

In addition, the cracker index can be used to feed a generator
for pieces satisfying a range constraint.
A cracker partition is indicated by the index in the cidx
table. It can be used to initialize a BATview to represent
the partition during processing.

Repeated cracking leads to an ever growing index. This process
can be stopped by setting the granule size,
i.e.  the minimum number of tuples in each piece,
or the maximum number of pieces.
The operations @sc{crackers.setGranule()} and @sc{crackers.setLimit()}
implement them. The default is to allow an arbitrary number pieces
with arbitrary sizes.

Pitfalls.
The policy in the kernel to take a copy of a BAT when there
is a need to write to it and there are also views around becomes
an issue. Instead, it should isolate the views, giving them a
private copy. This way the underlying base table becomes free to re-arrange.
This issue is postponed to the future.

The cracker module should be prepared to deal with any of the base types.
For strings this becomes an issue.

This module contains the experimental code to play with cracked tables.
It supports int-based bats for the time being only.

The current implementation uses an unprotected cracker
index. This limits the interface at slightly more overhead
of searching the cracker index upon each call.

Initial performance indicates around 70 ms processing
overhead on a 1M bat during the first crack operation.
(Athlon 1400, 1Gb)

@= crackfcn
command printCrackerIndex(b:bat[:any_1,:@1]):void
address CRKprintCrackerIndex
comment "Print the cracker index of b";

command printCrackerBAT(b:bat[:any_1,:@1]):void
address CRKprintCrackerBAT
comment "Print the cracker BAT of b";

command getCrackerBAT(b:bat[:any_1,:@1]):bat[:oid,:@1]
address CRKgetCrackerBAT
comment "Get the cracker BAT of b";

command printCrackerInsertions(b:bat[:any_1,:@1]):void
address CRKprintCrackerInsertions
comment "Print the pending insertions of the cracker BAT of b";

command printCrackerDeletions(b:bat[:any_1,:@1]):void
address CRKprintCrackerDeletions
comment "Print the pending deletions of the cracker BAT of b";

command sizeCrackerInsertions(b:bat[:any_1,:@1]):void
address CRKsizeCrackerInsertions
comment "Get the size of the pending insertions of the cracker BAT of b";

command sizeCrackerDeletions(b:bat[:any_1,:@1]):void
address CRKsizeCrackerDeletions
comment "Get the size of the pending deletions of the cracker BAT of b";

command insertionsForget(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertions_Forget
comment "Append c to the cracked bat of b and completelly forget the cracker index";

command insertionsPartiallyForget(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertions_PartiallyForget_@1
comment "Append c to the cracked bat of b and partially forget the cracker index, i.e., forget only what is affected";

command insertionsForce(b:bat[:any_1,:@1], c:bat[:any_1,:@1], deleteNodes:bit):void
address CRKmergeInsertions_Force_@1
comment "Merge the insertions bat with the cracker bat and update the cracker index";

command insertionsBForce(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_Force_@1
comment "Merge the insertions bat with the cracker bat and update the cracker index";

command insertionsOnNeed(b:bat[:any_1,:@1], c:bat[:any_1,:@1], deleteNodes:bit):void
address CRKmergeInsertions_OnNeed
comment "Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future";

command insertionsBOnNeed(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_OnNeed
comment "Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future";

command insertionsOnNeedGradually(b:bat[:any_1,:@1], c:bat[:any_1,:@1], deleteNodes:bit):void
address CRKmergeInsertions_OnNeedGradually
comment "Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future";

command insertionsBOnNeedGradually(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_OnNeedGradually
comment "Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future";

command insertionsOnNeedGraduallyRipple(b:bat[:any_1,:@1], c:bat[:any_1,:@1], deleteNodes:bit):void
address CRKmergeInsertions_OnNeedGraduallyRipple
comment "Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future";

command insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_OnNeedGraduallyRipple
comment "Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future";

command deletionsOnNeed(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeDeletions_OnNeed
comment "Keep the deletions bat separatelly and do a complete merge only if a relevant query arrives in the future";

command deletionsOnNeedGradually(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeDeletions_OnNeedGradually
comment "Keep the deletions bat separatelly and merge only what is needed if a relevant query arrives in the future";

command deletionsOnNeedGraduallyRipple(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeDeletions_OnNeedGraduallyRipple
comment "Keep the deletions bat separatelly and merge only what is needed using ripple if a relevant query arrives in the future";

command verifyCrackerIndex(b:bat[:any_1,:@1]):void
address CRKverifyCrackerIndex_@1
comment "Check the cracker index and column, whether each value is in the correct chunk";

command extendCrackerBAT(b:bat[:any_1,:@1], P:lng):void
address CRKextendCrackerBAT
comment "extend the cracker column by P positions";

command printAVLTree_int(b:bat[:any_1,:@1]):void
address CRKprintAVLTree_int
comment "print the AVL Tree";

command buildAVLIndex(b:bat[:any_1,:@1]):void
address CRKmakeAVLIndex_@1
comment "make an AVL tree index for this BAT";

command InsertAVLIndex(b:bat[:any_1,:@1], u:bat[:any_1,:@1]):void
address CRKInsertAVLIndex_@1
comment "Insert u in the AVL tree index of BAT b";

command selectAVL(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_6,:@1]
address CRKAVLIndexSelectBounds_@1
comment "Retrieve the subset using the AVL index";

command deleteAVL(b:bat[:any_1,:@1],u:bat[:any_2,:@1]):void
address CRKdeleteFromAVL_@1
comment "Delete a collection of values from the index";

@

@mal
module crackers;

@:crackfcn(chr)@
@:crackfcn(sht)@
@:crackfcn(int)@
@:crackfcn(lng)@
@:crackfcn(flt)@
@:crackfcn(dbl)@
@:crackfcn(date)@

@-

A limited set of relational operators is overloaded to deal with
cracked BATs. The relational select collects the pieces
into a single BAT. Preferably using a BATview, otherwise
the pieces are combined to form a new BAT.

@= crackAlgebra
command select(b:bat[:any_1,:@1],l:@1,h:@1):bat[:any_2,:@1]
address CRKselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:any_1,:@1],l:@1):bat[:any_2,:@1]
address CRKselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@1],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:@1,h:@1):bat[:any_1,:oid]
address CRKuselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:@1):bat[:any_1,:oid]
address CRKuselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_1,:oid]
address CRKuselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

@:joinuselect(@1)@
@
@= joinuselect
command joinuselect( right:bat[:oid,:@1], l:@1, h:@1, li:bit, hi:bit, left:bat[:oid,:oid] ):bat[:oid,:oid]
address CRKjoinSelectDefault_@1
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	The result is a new [:oid,:void] BAT.";

command joinuselect( right:bat[:oid,:@1], l:@1, h:@1, li:bit, hi:bit, left:bat[:oid,:oid], inPlace:bit , isForeignKey:bit):bat[:oid,:oid]
address CRKjoinSelectBounds_@1
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	If inPlace is TRUE (and left has an OID head and is not a BAT-view), we operate in-place,
	overwriting left and returning it as result. Otherwise, the result is a new [:oid,:void] BAT.
	If isForeignKey is TRUE, we assume that each tuple from left finds a match in right,
	and hence skip the respective check.
	(NOTE: This may lead to CRASHES, if isForeignKey is incorrectly passed as TRUE!)";
@

@= crackAlgebraProjections
command hselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKhselectBoundsProjections_@1_@2
comment "Retrieve the subset head using a cracker
        index producing preferably a BATview.";

command tselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKtselectBoundsProjections_@1_@2
comment "Retrieve the subset tail using a cracker
        index producing preferably a BATview.";

command joinselect( b:bat[:oid,:@2],l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectProjections_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";

command joinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectProjections_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command project( b:bat[:oid,:@1],bp:bat[:oid,:@2], l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectCrack_@1_@2
comment "Sync and project the tail of the cpair";

command project( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProject_@1_@2
comment "Sync the cracking pair and project the tail";

command projectH( b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKProjectH_@1_@2
comment "Sync the cracking pair and project the head";
@

@mal
@:crackAlgebra(chr)@
@:crackAlgebra(sht)@
@:crackAlgebra(int)@
@:crackAlgebra(lng)@
@:crackAlgebra(flt)@
@:crackAlgebra(dbl)@
@:crackAlgebra(date)@
@:crackAlgebraProjections(int,chr)@
@:crackAlgebraProjections(int,sht)@
@:crackAlgebraProjections(int,int)@
@:crackAlgebraProjections(int,lng)@
@:crackAlgebraProjections(int,flt)@
@:crackAlgebraProjections(int,dbl)@
@:crackAlgebraProjections(int,date)@
@:crackAlgebraProjections(date,chr)@
@:crackAlgebraProjections(date,sht)@
@:crackAlgebraProjections(date,int)@
@:crackAlgebraProjections(date,lng)@
@:crackAlgebraProjections(date,flt)@
@:crackAlgebraProjections(date,dbl)@
@:crackAlgebraProjections(date,date)@
@-
Direct access to the core cracking routines for cracking a complete BAT;
mainly for testing/debugging.
@
@= crackO
command zcrackOrdered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackOrderedZero_@1
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackOrderedOne_@1
comment "Break a BAT into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackOrderedTwo_@1
comment "Break a BAT into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackOrderedThree_@1
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

@
@= crack
command zcrackUnordered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackUnorderedZero_@1
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackUnorderedThree_@1
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@
@= crack_validate
command zcrackOrdered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackOrderedZero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackOrderedOne_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackOrderedTwo_validate_@1
comment "Validate whether a BAT is correctly broken into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackOrderedThree_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackUnordered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackUnorderedZero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackUnorderedThree_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@
@mal
@:crack(chr)@
@:crack(sht)@
@:crack(int)@
@:crack(lng)@
@:crack(flt)@
@:crack(dbl)@
@:crack(date)@
@:crackO(chr)@
@:crackO(sht)@
@:crackO(int)@
@:crackO(lng)@
@:crackO(flt)@
@:crackO(dbl)@
@:crack_validate(chr)@
@:crack_validate(sht)@
@:crack_validate(int)@
@:crack_validate(lng)@
@:crack_validate(flt)@
@:crack_validate(dbl)@
@-
@{
@- include prelude.mx
@* Implementation
The implementation is geared at early experimentation
without all the details to make the code robust and
ultra fast.

@h
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/
/*#define DEBUG_CRACKERS_INSERTIONS*/

#ifdef WIN32
#ifndef LIBCRACKERS
#define crackers_export extern __declspec(dllimport)
#else
#define crackers_export extern __declspec(dllexport)
#endif
#else
#define crackers_export extern
#endif

typedef struct {
	int bid;   /* the cracked bat */
	int cbid;  /* the copy on which we actually crack */
	int cid;   /* the index for this cracked bat */
} CrackIndex;

struct Node{
        lng	      position;
	bit 	      inclusive;	
        struct Node  *left;
        struct Node  *right;
        int	      height;
	bit	      head;
	bit	      deleted;
        struct Node  *previous;
	bit 	      isPreviousSmaller;	
	lng	      hols; /* indicates how many hols exist before this piece */
};

typedef struct {
	int 		bid;   		/* the stable bat */
	int 		cbid;   	/* the cracker bat, i.e., the copy on which we actually crack */
	int 		cid;   		/* the index for this cracked bat */
	int 		iid;   		/* pending insertions bat */
	int 		did;   		/* pending deletions bat */
	struct Node 	*Tree; 		/* the AVL tree */
	bit		reCreate;	/* indicates whether we need to recreate the index if we chose to forget it */
	sht		mergeInsertions;/* indicates wether there are insertions to merge -->  -1 no insertions,
												0 complete merge,
												1 gradually,
												2 ripple */
	bit 		deleteNodes;    /* if true, merging operations will delete nodes form the index if it makes things easier */
	bit 		mergeFromTheEnd;
	sht		mergeDeletions; /* indicates wether there are insertions to merge -->  -1 no insertions,
												0 complete merge,
												1 gradually,
												2 ripple */
			/* used only in the materialized projections scheme */
	int 		pbid; 		/* the project bat. Together with the bid, they uniquely identify a cracking pair 
					   when pid is -1 then chid stores the cracking history for all the cracking pairs where bid is head 
				           and hiid is a [bit,bit] that stores inclusive information for each bound stored in chid */
	lng 		nextCrack;	/* points in the next cracking operation that should be applied in thhis cracking pair so as to sync it */
	int 		chid;
	int 		hiid;
} CrackTreeIndex;

typedef struct {
	int		bid;
	struct Node 	*Tree;	
} AVLTreeIndex;

crackers_export str CRKselect(int *vid, int *bid, int *low, int *hgh);
crackers_export str CRKselectValue(int *vid, int *bid, int *value);
crackers_export str CRKuselect(int *vid, int *bid, int *low, int *hgh);
crackers_export str CRKuselectValue(int *vid, int *bid, int *value);

crackers_export str CRKprintCrackerIndex(int *k, int *bid);
crackers_export str CRKprintCrackerBAT(int *k, int *bid);
crackers_export str CRKgetCrackerBAT(int *vid, int *bid);
crackers_export str CRKsizeCrackerInsertions(int *k, int *bid);
crackers_export str CRKsizeCrackerDeletions(int *k, int *bid);
crackers_export str CRKprintCrackerInsertions(int *k, int *bid);
crackers_export str CRKprintCrackerDeletions(int *k, int *bid);
crackers_export str CRKmergeInsertions_Forget(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertions_OnNeed(int *k, int *bid, int *new, bit *deleteNodes);
crackers_export str CRKmergeInsertionsB_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertions_OnNeedGradually(int *k, int *bid, int *new, bit *deleteNodes);
crackers_export str CRKmergeInsertionsB_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertions_OnNeedGraduallyRipple(int *k, int *bid, int *new, bit *deleteNodes);
crackers_export str CRKmergeInsertionsB_OnNeedGraduallyRipple(int *k, int *bid, int *new);
crackers_export str CRKextendCrackerBAT(int *k, int *bid, lng positions);
crackers_export str CRKprintAVLTree_int(int *k, int *bid);
crackers_export str CRKmergeDeletions_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGraduallyRipple(int *k, int *bid, int *new);

#endif /* _CRACKERS_H */
   
@c
#include "mal_config.h"
#include "mal.h"
#include "mal_exception.h"
#include "crackers.h"
#include "mtime.h"
#include "bat5.h"

#define MAXPIECE 1024*100

static int maxCrackMap = 0;

static CrackIndex *Index;
static CrackTreeIndex *TreeIndex;
static AVLTreeIndex *AVLIndex;
bit IndexType = 1; /* 1 used for tree index, 0 used for bat index */
int IndexEntries = 220000; /* initial size used for the bat that stores index values*/
/* temp variables, used to test effect of stop updating the index, they operate only on one cracker bat */
int IndexSize = 0;
int IndexStop = 250000;

int
Height(struct Node * x){
        if( x == NULL )
                return -1;
        else
                return x->height;
}
/* for the comparison with an AVL Tree*/
struct Node *
SingleRotateLeftAVLIndex(int m, struct Node * node){
        struct Node * l, *lr;
	int nodeLh,nodeRh,lh;

        l = node->left;
	lr = l->right;
        node->left = l->right;
        l->right = node;

	if (node->previous == NULL)
		l->previous = NULL;
	else {
		l->previous = node->previous;
		l->isPreviousSmaller = node->isPreviousSmaller;
        }

	node->previous = l;
	node->isPreviousSmaller = TRUE;
	if (lr != NULL) {
		lr->previous = node;
		lr->isPreviousSmaller = FALSE;
	}
	if (node->head == TRUE){
		node->head = FALSE;
		l->head = TRUE;
		AVLIndex[m].Tree = l;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	lh = Height(l->left);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        l->height = (lh > node->height ? lh : node->height) + 1;

        return l;
}

struct Node *
SingleRotateRightAVLIndex(int m, struct Node * node){
        struct Node * r, *rl;
	int nodeLh,nodeRh,rh;

        r = node->right;
	rl =  r->left;

        node->right = r->left;
        r->left = node;

	if (node->previous == NULL)
		r->previous = NULL;
	else {
		r->previous = node->previous;
		r->isPreviousSmaller = node->isPreviousSmaller;
	}
	node->previous = r;
	node->isPreviousSmaller = FALSE;

	if (rl != NULL){
		rl->previous = node;
		rl->isPreviousSmaller = TRUE;
	}

	if (node->head == TRUE){
		node->head = FALSE;
		r->head = TRUE;
		AVLIndex[m].Tree = r;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	rh = Height(r->right);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        r->height = (rh > node->height ? rh : node->height) + 1;

        return r;
}

struct Node *
DoubleRotateLeftAVLIndex(int m, struct Node * node){
            node->left = SingleRotateRightAVLIndex(m, node->left);
            return SingleRotateLeftAVLIndex(m, node);
}

struct Node *
DoubleRotateRightAVLIndex(int m, struct Node * node){
            node->right = SingleRotateLeftAVLIndex(m, node->right);
            return SingleRotateRightAVLIndex(m, node);
}
/* end comparison with AVL tree*/

struct Node *
SingleRotateLeft(int m, struct Node * node){
        struct Node * l, *lr;
	int nodeLh,nodeRh,lh;

        l = node->left;
	lr = l->right;
        node->left = l->right;
        l->right = node;

	if (node->previous == NULL)
		l->previous = NULL;
	else {
		l->previous = node->previous;
		l->isPreviousSmaller = node->isPreviousSmaller;
        }

	node->previous = l;
	node->isPreviousSmaller = TRUE;
	if (lr != NULL) {
		lr->previous = node;
		lr->isPreviousSmaller = FALSE;
	}
	if (node->head == TRUE){
		node->head = FALSE;
		l->head = TRUE;
		TreeIndex[m].Tree = l;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	lh = Height(l->left);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        l->height = (lh > node->height ? lh : node->height) + 1;

        return l;
}

struct Node *
SingleRotateRight(int m, struct Node * node){
        struct Node * r, *rl;
	int nodeLh,nodeRh,rh;

        r = node->right;
	rl =  r->left;

        node->right = r->left;
        r->left = node;

	if (node->previous == NULL)
		r->previous = NULL;
	else {
		r->previous = node->previous;
		r->isPreviousSmaller = node->isPreviousSmaller;
	}
	node->previous = r;
	node->isPreviousSmaller = FALSE;

	if (rl != NULL){
		rl->previous = node;
		rl->isPreviousSmaller = TRUE;
	}

	if (node->head == TRUE){
		node->head = FALSE;
		r->head = TRUE;
		TreeIndex[m].Tree = r;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	rh = Height(r->right);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        r->height = (rh > node->height ? rh : node->height) + 1;

        return r;
}

struct Node *
DoubleRotateLeft(int m, struct Node * node){
            node->left = SingleRotateRight(m, node->left);
            return SingleRotateLeft(m, node);
}

struct Node *
DoubleRotateRight(int m, struct Node * node){
            node->right = SingleRotateLeft(m, node->right);
            return SingleRotateRight(m, node);
}


/* searching into the tree */

/* get the previous node in the index (in terms of value), the result can be any node, deleted or no */
struct Node *
getPreviousNodeAny(struct Node * current){

	struct Node *res = NULL;

	if (current->left !=NULL){
		res = current->left;
		while(res->right != NULL)
			res = res->right;
	}

	return res;	
}

/* get the next node in the index (in terms of value), the result can be any node, deleted or no */
struct Node *
getNextNodeAny(struct Node * current){

        struct Node *res = NULL;

        if (current->right !=NULL){
                res = current->right;
                while(res->left != NULL)
                        res = res->left;
        }

        return res;
}

struct Node *
getP(struct Node * current){

        struct Node *res = NULL;

	if (current->right != NULL)
		res = getP(current->right);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else
		if (current->left != NULL)
			res = getP(current->left);
	}
	return res;
}

struct Node *
getN(struct Node * current){

        struct Node *res = NULL;

	if (current->left != NULL)
		res = getN(current->left);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else
		if (current->right != NULL)
			res = getN(current->right);
	}
	return res;
}

/* get the previous node in the index (in terms of value), the result can be only a non deleted node */
struct Node *
getPreviousNode(struct Node * current, struct Node * previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return res;

}

/* get the next node in the index (in terms of value), the result can be only a non deleted node */
struct Node *
getNextNode(struct Node * current, struct Node * next){

        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return res;
}

lng
getPreviousPosition(struct Node * current, BAT *b, BUN base, int xx, lng previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return *(lng*)BUNhloc(b,base + ((res->position) * xx));

}

lng
getNextPosition(struct Node * current, BAT *b, BUN base, int xx, lng next){

        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return *(lng*)BUNhloc(b,base + ((res->position) * xx));
}

struct Node *
findPreviousPieceWalkingBack(struct Node * node){
	struct Node * res = NULL, *current = node;

	if (current->left != NULL)
                res= getP(current->left);
	if (res != NULL)
		return res;

	/* if nothing in the current branch we have to move back */
	while (res == NULL) {
		if (current->previous == NULL)
			return NULL;
		while  (current->isPreviousSmaller == FALSE){
			current = current->previous;
			if (current->previous == NULL)
                        	return NULL;
		}
		current = current->previous;

		if (current->deleted == FALSE)
			res = current;
		else if (current->left != NULL)
                	res= getP(current->left);
	}
	
	return res;
}

struct Node *
findNextPiece(struct Node * node){
	struct Node * res = NULL, *current = node;

	if (current->right != NULL)
                res= getN(current->right);
	if (res != NULL)
		return res;

	/* if nothing in the current branch we have to move back */
	while (res == NULL) {
		if (current->previous == NULL)
			return NULL;
		while  (current->isPreviousSmaller == TRUE){
			current = current->previous;
			if (current->previous == NULL)
                        	return NULL;
		}
		current = current->previous;

		if (current->deleted == FALSE)
			res = current;
		else if (current->right != NULL)
                	res= getN(current->right);
	}
	
	return res;
}
@= TreeOperations

bit
GetLow_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next){

	BUN cur, curValue;

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_LT(&x,curValue,@3@1) ){	
			if (current->left == NULL){
        	                *p1 = previous;
                	        *p2 = getNextPosition(current, b, base,  xx, next);
                       	 	return 0;
                	} else
                        	/* check for the left one */
                        	return GetLow_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, getNextPosition(current, b, base,  xx, next));
		}
		if (current->right == NULL){
               	 	*p1 = getPreviousPosition(current, b, base,  xx, previous);
			*p2 = next;
			return 0;
		} else 	
			return GetLow_@1(x, inclusive, current->right, b, base, xx, p1, p2, getPreviousPosition(current, b, base,  xx, previous), next);
	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) ){
		*p1 = *(lng*)BUNhloc(b, cur);	
		return 1;
	}	

       	if ( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL){
			/* crack from the begining of the bat */
                	*p1 = previous;
			*p2 = *(lng*)BUNhloc(b, cur);
			return 0;
		} else
			/* check for the left one */
      			return GetLow_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, *(lng*)BUNhloc(b, cur));
			
	}

	if (current->right == NULL){
		/* crack until the end of the bat */
                *p1 = *(lng*)BUNhloc(b, cur);
		*p2 = next;
		return 0;
	} else 	
		/* check for the right one */
		return GetLow_@1(x, inclusive, current->right, b, base, xx, p1, p2, *(lng*)BUNhloc(b, cur), next);
}

bit
GetHgh_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next){

        BUN cur, curValue;	

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_GT(&x,curValue,@3@1) ){
			 if (current->right == NULL){
                       	 	*p1 = getPreviousPosition(current, b, base,  xx, previous);
                        	*p2 = next;
                        	return 0;
                	} else
                        	return GetHgh_@1(x, inclusive, current->right, b, base, xx, p1, p2, getPreviousPosition(current, b, base,  xx, previous), next);
		}
		if (current->left == NULL){
               	 	*p1 = previous;
                	*p2 = getNextPosition(current, b, base,  xx, next);
               	 	return 0;
	        } else
                	return GetHgh_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, getNextPosition(current, b, base,  xx, next));

	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE))){
		*p2 = *(lng*)BUNhloc(b, cur);	
		return 1;
	}	

	if ( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL){
			/* crack until the end of the BAT if this was the last index entry but the needed value is still bigger */
			*p1 = *(lng*)BUNhloc(b, cur);
                	*p2 = next;
			return 0;
		} else
			/* check for the right one */
      			return GetHgh_@1(x, inclusive, current->right, b, base, xx, p1, p2, *(lng*)BUNhloc(b, cur), next);
	}

	/* then it is smaller than the current value */
	if (current->left == NULL){
		/* crack from the beginning of the bat until here */
		*p1 = previous;
               	*p2 = *(lng*)BUNhloc(b, cur);
		return 0;
	} else	
		/* check for the left one */	
		return GetHgh_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, *(lng*)BUNhloc(b, cur));	
}

struct Node *
InsertTree_@1(int m, int indexPosition, @1 value, bit inclusive, lng crackPosition, struct Node * current, BAT * b, BUN base, int xx){
	
	BUN cur, curValue, curPosition, Lchild, LchildValue, Rchild, RchildValue;
	int lh, rh;
	bit use;
	struct Node *temp;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
                current->position = indexPosition;
                current->inclusive = inclusive;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		current->hols = 0;
		goto end;
        }

	cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

	/* reuse if possible nodes that have been deleted with lazy deletion */
	use = FALSE;
	if (current->deleted == TRUE){
		if (current->left != NULL && current->right != NULL){
			Lchild = base + (((getPreviousNodeAny(current))->position) * xx);
                        LchildValue = BUNtloc(b, Lchild);
			Rchild = base + (((getNextNodeAny(current))->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);
			
			if ( ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && inclusive == TRUE && current->right->inclusive == FALSE))  &&
			     ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && inclusive == FALSE && current->left->inclusive == TRUE) ) )
				use = TRUE;
			
		} else
		if (current->left != NULL && current->right == NULL){
			Lchild = base + (((getPreviousNodeAny(current))->position) * xx);
                        LchildValue = BUNtloc(b, Lchild);

			if ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && inclusive == FALSE && current->left->inclusive == TRUE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right != NULL){
			Rchild = base + (((getNextNodeAny(current))->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);
			
			if ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && inclusive == TRUE && current->right->inclusive == FALSE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right == NULL)
				use = TRUE;

		if (use == TRUE){
        		curPosition = BUNhloc(b, cur);
			*(lng*)curPosition = crackPosition;
                        *(@1*)curValue = value;
			current->inclusive = inclusive;
                        current->deleted = FALSE;
                        return NULL;
		}
	}

        if ( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == TRUE && current->inclusive == FALSE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->left, b, base, xx)) == NULL )
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + ((current->left->position) * xx);
        		LchildValue = BUNtloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && inclusive == TRUE && current->left->inclusive == FALSE) )
                        	current = SingleRotateLeft(m, current);
                    	else
                        	current = DoubleRotateLeft(m, current);
		}
        } else
        if ( @2_GT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == FALSE && current->inclusive == TRUE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->right, b, base, xx)) == NULL )
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;


                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + ((current->right->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && inclusive == FALSE && current->right->inclusive == TRUE) )
                        	current = SingleRotateRight(m, current);
                    	else
                        	current = DoubleRotateRight(m, current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

struct Node *
findNodeH_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * next){

        BUN cur,curValue;	

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE)) )
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;

        if( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL)
			return next;
		else
      			return findNodeH_@1(x, inclusive, current->right, b, base, xx, next);
	}

	if (current->left == NULL)
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;
	else		
		return findNodeH_@1(x, inclusive, current->left, b, base, xx, (current->deleted == TRUE) ? getNextNode(current, next) : current);	
}

struct Node *
findNodeL_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * prev){

	BUN cur,curValue;

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) )
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;

        if( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL)
			return prev;
		else
			return findNodeL_@1(x, inclusive, current->left, b, base, xx, prev);
	}

	if (current->right == NULL)
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;
	else
		return findNodeL_@1(x, inclusive, current->right, b, base, xx, (current->deleted == TRUE) ? getPreviousNode(current, prev) : current);
}

void
PartiallyLazyFreeAVLTree_@1(struct Node * current, @1 value, BAT *b, BUN base, int xx){

	BUN cur,curValue;

        cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

	if (current->left != NULL)
		PartiallyLazyFreeAVLTree_@1(current->left, value, b, base, xx);

	if (current->right != NULL)
		PartiallyLazyFreeAVLTree_@1(current->right, value, b, base, xx);

	if( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && current->inclusive == FALSE) )
		current->deleted = TRUE;
	return;
}

struct Node *
InsertAVLIndex_@1(int m, int indexPosition, @1 value,  struct Node * current, BAT * b, BUN base, int xx){
	
	BUN cur, curValue, Lchild, LchildValue, Rchild, RchildValue;
	int lh, rh;
	struct Node *temp;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
                current->position = indexPosition;
                current->inclusive = TRUE;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		current->hols = 0;
		goto end;
        }

	cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);


        if ( @2_LT(&value,curValue,@3@1) || @2_EQ(&value,curValue,@3@1) ){

		if ( (temp = InsertAVLIndex_@1(m, indexPosition, value,  current->left, b, base, xx)) == NULL )
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + ((current->left->position) * xx);
        		LchildValue = BUNtloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || @2_EQ(&value,LchildValue,@3@1) )
                        	current = SingleRotateLeftAVLIndex(m, current);
                    	else
                        	current = DoubleRotateLeftAVLIndex(m, current);
		}
        } else {

		if ( (temp = InsertAVLIndex_@1(m, indexPosition, value, current->right, b, base, xx)) == NULL )
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;


                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + ((current->right->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) )
                        	current = SingleRotateRightAVLIndex(m, current);
                    	else
                        	current = DoubleRotateRightAVLIndex(m, current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}
@

@c
@:TreeOperations(chr,simple,)@
@:TreeOperations(sht,simple,)@
@:TreeOperations(int,simple,)@
@:TreeOperations(lng,simple,)@
@:TreeOperations(flt,simple,)@
@:TreeOperations(dbl,simple,)@
@:TreeOperations(date,atom,TYPE_)@




void
FreeAVLTree(struct Node * current){

	if (current->left != NULL)
		FreeAVLTree(current->left);

	if (current->right != NULL)
		FreeAVLTree(current->right);

	GDKfree(current);
		
	return;
}

int
existsIndex(int bid)
{
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (Index[i].bid == bid)
			return i;
	return -1;
}

int
existsAVLIndex(int bid)
{
        int i;

        for (i = 0; i < maxCrackMap; i++)
                if (AVLIndex[i].bid == bid)
                        return i;
        return -1;
}


int
existsTreeIndex(int bid)
{
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (TreeIndex[i].bid == bid)
			return i;
	return -1;
}

int
getIndexGivenACrackingPair(int cpair)
{
	int i;

        for (i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].cbid == cpair)
			return i;
	return -1;
}

int
existsTreeIndexProjections(int bid, int pbid)
{
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (TreeIndex[i].bid == bid && TreeIndex[i].pbid == pbid)
			return i;
	return -1;
}

void
printAVLTree(struct Node * current, BAT *b, BUN base, int xx){
	
	BUN cur;

	cur = base + ((current->position) * xx);
	if (current->deleted == FALSE) {
		printf("\n %lld, %d  Hols:%lld ", *(lng*)BUNhloc(b, cur), *(int*)BUNtloc(b, cur), current->hols );
	} else
		printf("\n DELETED %lld, %d  Hols:%lld ", *(lng*)BUNhloc(b, cur), *(int*)BUNtloc(b, cur), current->hols );
	
	if (current->left != NULL)
                printAVLTree(current->left, b, base, xx);

        if (current->right != NULL)
                printAVLTree(current->right, b, base, xx);

        return;

}

str
CRKprintAVLTree_int(int *k, int *bid){
	BAT *c;
	int zz, position;
	BUN idxFirst;

	(void) k;

	position = existsTreeIndex(*bid);
        if (position == -1)
                fprintf(stderr, " the crack index does not exist \n");

	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL)
                throw(MAL, "crackers.CRKprintAVLTree_int", "Cannot access cracker index");

        zz = BUNsize(c);
        idxFirst = BUNfirst(c);
	printAVLTree(TreeIndex[position].Tree, c, idxFirst, zz);

	BBPunfix(c->batCacheid);

	return MAL_SUCCEED;
}

@= CreateNewIndex

int
newTreeIndexHistoryProjections_@1(int bid, int chid, int hiid)
{
        int i, freemap = -1, units = 1024;

        for (i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == -1)
                        freemap = i;

        if (freemap != -1) {
                TreeIndex[freemap].bid = bid;
                TreeIndex[freemap].chid = chid;
                TreeIndex[freemap].hiid = hiid;
                return freemap;
        }

        if (i == maxCrackMap) {
                CrackTreeIndex *x;

                if (maxCrackMap > 0)
                        units = (int) (1.2 * maxCrackMap);
                x = (CrackTreeIndex *) GDKmalloc(sizeof(CrackTreeIndex) * units);
                memset(x, 0, sizeof(CrackTreeIndex) * units);
                if (TreeIndex) {
                        fprintf(stderr, "reallocate index \n");
                        memcpy(x, TreeIndex, sizeof(CrackTreeIndex) * i);
                        GDKfree(TreeIndex);
                }
                TreeIndex = x;
                maxCrackMap = units;
        }

        TreeIndex[i].chid = chid;
        TreeIndex[i].hiid = hiid;
        TreeIndex[i].pbid = -1;
        TreeIndex[i].bid = bid;
        TreeIndex[i].cbid = -1;
        TreeIndex[i].cid = -1;
        TreeIndex[i].iid = -1;
        TreeIndex[i].did = -1;
        TreeIndex[i].mergeInsertions = -1;
        TreeIndex[i].reCreate = 0;
        TreeIndex[i].Tree = NULL;
        TreeIndex[i].deleteNodes = FALSE;
        TreeIndex[i].mergeDeletions = -1;
        return i;
}


int
newTreeIndexProjections_@1(int bid, int cbid, int pbid)
{
	int i, freemap = -1, units = 1024;
	BAT *b;
	
	for (i = 0; i < maxCrackMap; i++)
		if (TreeIndex[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		TreeIndex[freemap].bid = bid;
		TreeIndex[i].pbid = pbid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackTreeIndex *x;

		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackTreeIndex *) GDKmalloc(sizeof(CrackTreeIndex) * units);
		memset(x, 0, sizeof(CrackTreeIndex) * units);
		if (TreeIndex) {
			fprintf(stderr, "reallocate index \n");
			memcpy(x, TreeIndex, sizeof(CrackTreeIndex) * i);
			GDKfree(TreeIndex);
		}
		TreeIndex = x;
		maxCrackMap = units;
	}

	TreeIndex[i].nextCrack = 0;
	TreeIndex[i].chid = -1;
	TreeIndex[i].hiid = -1;
	TreeIndex[i].pbid = pbid;  /* this line is the only addittion compared to the non projections function */
	TreeIndex[i].bid = bid;
	TreeIndex[i].cbid = cbid;
	b = BATnew(TYPE_lng, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	TreeIndex[i].cid = b->batCacheid;
	TreeIndex[i].iid = -1;
	TreeIndex[i].did = -1;
	TreeIndex[i].mergeInsertions = -1;
	TreeIndex[i].reCreate = 0;
	TreeIndex[i].Tree = NULL;
	TreeIndex[i].deleteNodes = FALSE;
	TreeIndex[i].mergeDeletions = -1;
	return i;
}

int
newTreeIndex_@1(int bid, int cbid)
{
	int i, freemap = -1, units = 1024;
	BAT *b;
	
	for (i = 0; i < maxCrackMap; i++)
		if (TreeIndex[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		TreeIndex[freemap].bid = bid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackTreeIndex *x;

		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackTreeIndex *) GDKmalloc(sizeof(CrackTreeIndex) * units);
		memset(x, 0, sizeof(CrackTreeIndex) * units);
		if (TreeIndex) {
			fprintf(stderr, "reallocate index \n");
			memcpy(x, TreeIndex, sizeof(CrackTreeIndex) * i);
			GDKfree(TreeIndex);
		}
		TreeIndex = x;
		maxCrackMap = units;
	}

	TreeIndex[i].chid = -1;
	TreeIndex[i].hiid = -1;
	TreeIndex[i].pbid = -1;
	TreeIndex[i].bid = bid;
	TreeIndex[i].cbid = cbid;
	b = BATnew(TYPE_lng, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	TreeIndex[i].cid = b->batCacheid;
	TreeIndex[i].iid = -1;
	TreeIndex[i].did = -1;
	TreeIndex[i].mergeInsertions = -1;
	TreeIndex[i].reCreate = 0;
	TreeIndex[i].Tree = NULL;
	TreeIndex[i].deleteNodes = FALSE;
	TreeIndex[i].mergeDeletions = -1;
	return i;
}

void
reCreateMap_@1(int position){
	BAT *b;

	b = BATnew(TYPE_lng, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	TreeIndex[position].cid = b->batCacheid;
	TreeIndex[position].reCreate = 0;
	
	return;
}

int
newIndex_@1(int bid, int cbid)
{
	int i, freemap = -1, units = 1024;
	BAT *b;
	
	for (i = 0; i < maxCrackMap; i++)
		if (Index[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		Index[freemap].bid = bid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackIndex *x;

		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackIndex *) GDKmalloc(sizeof(CrackIndex) * units);
		memset(x, 0, sizeof(CrackIndex) * units);
		if (Index) {
			fprintf(stderr, "reallocate index \n");
			memcpy(x, Index, sizeof(CrackIndex) * i);
			GDKfree(Index);
		}
		Index = x;
		maxCrackMap = units;
	}

	Index[i].bid = bid;
	Index[i].cbid = cbid;
	b = BATnew(TYPE_lng, TYPE_@1, 220000);	/*todo: size*/
	BBPkeepref(b->batCacheid);
	Index[i].cid = b->batCacheid;
	return i;
}

int
newAVLIndex_@1(int bid)
{
        int i, freemap = -1, units = 1024;

        for (i = 0; i < maxCrackMap; i++)
                if (AVLIndex[i].bid == -1)
                        freemap = i;

        if (freemap != -1) {
                AVLIndex[freemap].bid = bid;
                return freemap;
        }

        if (i == maxCrackMap) {
                AVLTreeIndex *x;

                if (maxCrackMap > 0)
                        units = (int) (1.2 * maxCrackMap);
                x = (AVLTreeIndex *) GDKmalloc(sizeof(AVLTreeIndex) * units);
                memset(x, 0, sizeof(AVLTreeIndex) * units);
                if (AVLIndex) {
                        fprintf(stderr, "reallocate index \n");
                        memcpy(x, AVLIndex, sizeof(AVLTreeIndex) * i);
                        GDKfree(AVLIndex);
                }
                AVLIndex = x;
                maxCrackMap = units;
        }

        AVLIndex[i].bid = bid;
        AVLIndex[i].Tree = NULL;
        return i;
}

@

@c
@:CreateNewIndex(chr)@
@:CreateNewIndex(sht)@
@:CreateNewIndex(int)@
@:CreateNewIndex(lng)@
@:CreateNewIndex(flt)@
@:CreateNewIndex(dbl)@
@:CreateNewIndex(date)@

void
printCrackerIndex(int bid)
{
	int i = existsTreeIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(TreeIndex[i].cid));
}

str
CRKprintCrackerIndex(int *k, int *bid)
{
	(void)k;
	printCrackerIndex(*bid);

	return MAL_SUCCEED;
}

void
printCrackerBAT(int bid)
{
	int i = existsTreeIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(TreeIndex[i].cbid));
}

void
printCrackerDeletions(int bid)
{
	int i = existsTreeIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (TreeIndex[i].did > 0)
		BATprint(BATdescriptor(TreeIndex[i].did));
}

void
printCrackerInsertions(int bid)
{
	int i = existsTreeIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (TreeIndex[i].iid > 0)
		BATprint(BATdescriptor(TreeIndex[i].iid));
}

str
CRKprintCrackerBAT(int *k, int *bid)
{
	(void)k;
	printCrackerBAT(*bid);

	return MAL_SUCCEED;
}

str
CRKgetCrackerBAT(int *vid, int *bid)
{
        int i = existsTreeIndex(*bid);
        if (i == -1)
                fprintf(stderr, " the cracker index does not exist \n");
        if (TreeIndex[i].cbid > 0)
		*vid = TreeIndex[i].cbid;
	else
		*vid = -1;

        return MAL_SUCCEED;
}


void
sizeCrackerDeletions(int bid)
{
        BAT *u;

        int i = existsTreeIndex(bid);
        if (i == -1)
                fprintf(stderr, " the crack index does not exist \n");
        if (TreeIndex[i].did > 0){
                u = BATdescriptor(TreeIndex[i].did);
                printf("\n pending deletions size: "SZFMT"\n",BATcount(u));
                BBPunfix(u->batCacheid);
        }
        else
                printf("\n pending deletions size: 0 \n");
}

str
CRKsizeCrackerDeletions(int *k, int *bid)
{
        (void)k;
        sizeCrackerDeletions(*bid);
        return MAL_SUCCEED;
}

void
sizeCrackerInsertions(int bid)
{
	BAT *u;

	int i = existsTreeIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (TreeIndex[i].iid > 0){
		u = BATdescriptor(TreeIndex[i].iid);
		printf("\n pending insertions size: "SZFMT" \n",BATcount(u));
		BBPunfix(u->batCacheid);
	}
	else
		printf("\n pending insertions size: 0 \n");
}

str
CRKsizeCrackerInsertions(int *k, int *bid)
{
	(void)k;
	sizeCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerDeletions(int *k, int *bid)
{
	(void)k;
	printCrackerDeletions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerInsertions(int *k, int *bid)
{
	(void)k;
	printCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

@= insertIndexElement
	*(lng*) @2 = @4;	
	*(@1 *) @3 = @5;	
	(b)->batBuns->free += xx;
        (b)->batCount ++;
@

@= InsertIndexElements
void
addTreeIndex_@1(int m, @1 *value, bit inclusive, lng index, BAT * b)
{
	BUN ph,pt,base;
        int xx = BUNsize(b);

	ph = BUNhloc(b, BUNlast(b));
	pt = BUNtloc(b, BUNlast(b));

        if (BATcount(b) == 0){

                @:insertIndexElement(@1, BUNhloc(b, BUNfirst(b)), BUNtloc(b, BUNfirst(b)), index, *value)@
		TreeIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                TreeIndex[m].Tree->position = 0;
                TreeIndex[m].Tree->inclusive = inclusive;
                TreeIndex[m].Tree->height = 0;
                TreeIndex[m].Tree->left = NULL;
                TreeIndex[m].Tree->right = NULL;		
                TreeIndex[m].Tree->head = TRUE;	
                TreeIndex[m].Tree->deleted = FALSE;	
                TreeIndex[m].Tree->previous = NULL;	
                TreeIndex[m].Tree->hols = 0;	

                return;
        }

	base = BUNhloc(b, BUNfirst(b));
        if ( (InsertTree_@1(m, BATcount(b), *value, inclusive, index, TreeIndex[m].Tree, b, base, xx)) != NULL ) {
		/* use a new BUN only if we cannot reuse a previously deleted one */
		@:insertIndexElement(@1, ph, pt, index, *value)@
	}
}

void
addOne_@1(int i, @1 *value, lng index, BUN p)
{
	BAT *b;
	int xx;
	BUN ph, pt, wh, wt, rh, rt;

	if ((b = BATdescriptor(Index[i].cid)) == NULL) {
		fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return;
	}

	xx = BUNsize(b);
	if (BATcount(b) == 0){
		@:insertIndexElement(@1,BUNhloc(b, BUNfirst(b)), BUNtloc(b, BUNfirst(b)), index, *value)@
		return; 		
	}
	/*todo: check BAT size*/

	ph = BUNhloc(b, p);
	pt = BUNtloc(b, p);
	
	if (p == BUNlast(b)){ /*Insert at the end if everything is smaller than the new value*/
		@:insertIndexElement(@1, ph, pt, index, *value)@
		return;
	}

	/*Else we have to sift some buns to put the new one to the right position*/
	wh = BUNhloc(b, BUNlast(b));
	wt = BUNtloc(b, BUNlast(b));
	rh = wh - xx, rt = wt - xx;
	if (@2_EQ(pt,value,@3@1) && index > 0){ /*negative index values inidicate non inclusive bounds so they should be always first*/
		ph += xx;
		pt += xx;
	}
	for (;rt>=pt;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
		*(lng*)wh = *(lng*)rh;
		*(@1 *)wt = *(@1 *)rt;
	}
	@:insertIndexElement(@1, ph, pt, index, *value)@
	BBPunfix(b->batCacheid);
}	

void
addTwo_@1(int i, @1 *valueA, lng indexA, BUN p2, @1 *valueB, lng indexB, BUN p)
{
	BAT *b;
	int xx;
	BUN ph, pt, wh, wt, rh, rt, p2h, p2t;

        if ((b = BATdescriptor(Index[i].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return;
        }

	/*todo: check BAT size*/
	xx = BUNsize(b);
	if (BATcount(b) == 0){
		BUN ph = BUNhloc(b, BUNfirst(b));
		BUN pt = BUNtloc(b, BUNfirst(b));
		@:insertIndexElement(@1, ph, pt, indexA, *valueA)@
		ph += xx;
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
		return; 		
	}

	ph = BUNhloc(b, p);
	pt = BUNtloc(b, p);
	wh = BUNhloc(b, BUNlast(b)+xx);
	wt = BUNtloc(b, BUNlast(b)+xx);
	rh = wh - 2*xx;
	rt = wt - 2*xx;
        p2h = BUNhloc(b, p2);
        p2t = BUNtloc(b, p2);
	if (p == BUNlast(b)){
		ph += xx; /* sift one more position to make room for pair A too*/
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
	}
	else{   /*Else we have to sift some buns to put the new one to the right position*/
		if (@2_EQ(pt,valueB,@3@1) && indexB > 0){
			ph += xx;
			pt += xx;
		}
		for (;rt>=pt;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
			*(lng*)wh = *(lng*)rh;
			*(@1 *)wt = *(@1 *)rt;
		}
		ph += xx; /* sift one more position to make room for pair A too*/
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
	}
        wh -= xx;
        wt -= xx;
        if (@2_EQ(p2t,valueA,@3@1) && indexA > 0){
                p2h += xx;
                p2t += xx;
        }
        for (;rt>=p2t;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
                *(lng*)wh = *(lng*)rh;
                *(@1 *)wt = *(@1 *)rt;
        }
        @:insertIndexElement(@1, p2h, p2t, indexA, *valueA)@
	BBPunfix(b->batCacheid);
}	

void
addAVLIndex_@1(int m,  lng position, BAT * b)
{
        BUN base;
        int xx = BUNsize(b);

        if (position == 0){

                AVLIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                AVLIndex[m].Tree->position = position;
                AVLIndex[m].Tree->inclusive = TRUE;
                AVLIndex[m].Tree->height = 0;
                AVLIndex[m].Tree->left = NULL;
                AVLIndex[m].Tree->right = NULL;
                AVLIndex[m].Tree->head = TRUE;
                AVLIndex[m].Tree->deleted = FALSE;
                AVLIndex[m].Tree->previous = NULL;

                return;
        }

        base = BUNhloc(b, BUNfirst(b));
        InsertAVLIndex_@1(m, position, *(@1*)BUNtloc(b,base+position*xx),  AVLIndex[m].Tree, b, base, xx);
}

crackers_export str CRKmakeAVLIndex_@1(int *k, int *bid);
str
CRKmakeAVLIndex_@1(int *k, int *bid)
{
	BUN last, cur;
	int indexPos;
	int xx;
	lng curPos;
	BAT *b;

	(void) k;
        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.make AVL index", "Cannot access descriptor");

	indexPos = newAVLIndex_@1(*bid);
	cur = BUNfirst(b);
	last = BUNlast(b);
	xx = BUNsize(b);
	curPos = 0;
	while (cur < last){
		addAVLIndex_@1(indexPos,curPos,b);
		cur+=xx;
		curPos++;
	}
	
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

crackers_export str CRKInsertAVLIndex_@1(int *k, int *bid, int *uid);
str
CRKInsertAVLIndex_@1(int *k, int *bid, int *uid)
{
	BUN last, cur;
	int indexPos;
	int xx;
	lng curPos;
	BAT *b, *u;

	(void) k;
	indexPos = existsAVLIndex(*bid);
	if (indexPos == -1)	
		throw(MAL, "crackers.insert AVL index", "No AVL index present for this BAT");

        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access descriptor");

        if ((u = BATdescriptor(*uid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access update descriptor");

	cur = BUNfirst(u);
	last = BUNlast(u);
	xx = BUNsize(b);
	curPos = BATcount(b)-BATcount(u);
	while (cur < last){
		addAVLIndex_@1(indexPos,curPos,b);
		cur+=xx;
		curPos++;
	}
	
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);
	return MAL_SUCCEED;
}

lng 
findQualifyingValuesAVLIndex_@1(@1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, lng resSize, BAT *b, BUN first, int xx, struct Node * cur, BUN resh, BUN rest, @1 prevL)
{
	BUN rh = resh, rt = rest;
	lng size = resSize;
	
	@1 value = *(@1*)BUNtloc(b,first+cur->position*xx);
	if (cur->deleted == FALSE){
		if ( (@2_GT(&value,low,@3@1) && @2_LT(&value,hgh,@3@1)) ||
		     (@2_EQ(&value,low,@3@1) && *inclusiveLow == TRUE) ||	
		     (@2_EQ(&value,hgh,@3@1) && *inclusiveHgh == TRUE) ){
			*(oid*)rh = (oid)cur->position;
       	         	*(@1 *)rt = *(@1*)BUNtloc(b,first+cur->position*xx);
	       	         rh+=xx; rt+=xx;
        	        size++;	
		}
	}

	if (cur->left != NULL &&  @2_GT(&value,low,@3@1) && @2_LT(&prevL,hgh,@3@1) )
		size = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, size, b, first, xx, cur->left, rh, rt, prevL);
	if (cur->right != NULL && (@2_LT(&value,hgh,@3@1) || (@2_EQ(&value,hgh,@3@1) && *inclusiveHgh == TRUE)))
		size = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, size, b, first, xx, cur->right, rh, rt, value);

	return size;
}

crackers_export str CRKAVLIndexSelectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKAVLIndexSelectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{
	BAT *b, *result;
	int indexPos;
	struct Node *cur;
	int xx;
	lng  resSize;
	BUN first, resLast, resh, rest;

	indexPos = existsAVLIndex(*bid);
        if (indexPos == -1)
                throw(MAL, "crackers.insert AVL index", "No AVL index present for this BAT");
	
        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access descriptor");

	result = BATnew(TYPE_oid, TYPE_@1, (*(@1*)hgh-*(@1*)low)*2);

	/* find the node that we should start searching from */
	cur = AVLIndex[indexPos].Tree;
	first = BUNfirst(b);
	xx = BUNsize(b);

	while( @2_LT(BUNtloc(b,first+cur->position*xx),low,@3@1) && cur != NULL )		
		cur = cur->right;

	resSize = 0;
	/*if NULL then result is empty */
	if (cur == NULL){
		resLast = BUNfirst(result);
		result->batBuns->free =  resLast - result->batBuns->base;
                BATsetcount(result, 0);
		BBPkeepref(result->batCacheid);
		*vid = result->batCacheid;
		BBPunfix(b->batCacheid);

		return MAL_SUCCEED;
	}

	resh = BUNhloc(result, BUNfirst(result));
	rest = BUNtloc(result, BUNfirst(result));
	if (@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && *inclusiveLow == TRUE){
		while (@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && cur != NULL){
			if (cur->deleted == FALSE){
				*(oid*)resh = (oid)cur->position;
				*(@1 *)rest = *(@1 *)BUNtloc(b,first+cur->position*xx);
				resh+=xx; rest+=xx;
				resSize++;
			}
			cur = cur->right;
		}
	} else
	if (@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && *inclusiveLow == FALSE){
		while(@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && cur != NULL)
			cur = cur->right;
	} 

	if (cur != NULL)       
		resSize = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, resSize, b, first, xx, cur, resh, rest, *(@1*)BUNtloc(b,first+cur->position));


	resLast = BUNfirst(result) + xx*resSize;
        result->batBuns->free =  resLast - result->batBuns->base;
        BATsetcount(result, resSize);
        BBPkeepref(result->batCacheid);
        *vid = result->batCacheid;
        BBPunfix(b->batCacheid);


	return MAL_SUCCEED;
}

/* Locate and mark as deleted a node in the AVL tree, starting from a given node */
struct Node *
LocateDelete_@1(struct Node *cur, oid id, @1 *value, BAT *b, BUN first, int xx){
	struct Node * current = cur;
	if ( @2_GT(BUNtloc(b, first + current->position*xx),value,@3@1) )
		return current->right != NULL ? LocateDelete_@1(current->right, id, value, b, first, xx): NULL;	
	else
	if ( @2_LT(BUNtloc(b, first + current->position*xx),value,@3@1) )
		return current->left != NULL ? LocateDelete_@1(current->left, id, value, b, first, xx): NULL;	
	else
	if ( @2_EQ(BUNtloc(b, first + current->position*xx),value,@3@1) ){
		if ( (oid)current->position ==  id ){
			current->deleted = TRUE;
			return current;
		}
		else {
			while(1){
				if (current->right != NULL)
					current= current->right;
				if ( @2_EQ(BUNtloc(b, first + current->position*xx),value,@3@1) ){
			                if ( (oid)current->position ==  id ){
						current->deleted = TRUE;
               		 		        return current;
					} else
						continue;
				} else {
					return current;
				}
			}
		}
	}

	return NULL;
}

crackers_export str CRKdeleteFromAVL_@1(int *k, int *bid, int *uid);
/* delete from the AVL tree a collection of values */
str
CRKdeleteFromAVL_@1(int *k, int *bid, int *uid){
	BAT *b, *u;
	lng indexPos;
	BUN delt, delh, delLast, first;
	int xx;
	
	(void)k;
	
	indexPos = existsAVLIndex(*bid);
        if (indexPos == -1)
                throw(MAL, "crackers.delete from AVL index", "No AVL index present for this BAT");

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.delete from AVL index", "Cannot access descriptor");


	if ((u = BATdescriptor(*uid)) == NULL)
                throw(MAL, "crackers.delete from AVL index", "Cannot access deletions BAT");

        if (BATcount(u) == 0){
                BBPunfix(u->batCacheid);
                return MAL_SUCCEED; /* no qualifying values in the insertions */
        }

        /* if necessary, sort in place the insertions bat */
        if (u->tsorted == FALSE){
                u->batRestricted = BAT_WRITE;
                BATmirror(BATorder(BATmirror(u)));
        }

	first = BUNfirst(b);
	xx = BUNsize(b);
	delt = BUNtloc(u, BUNfirst(u));
	delh = BUNhloc(u, BUNfirst(u));
	delLast = BUNtloc(u, BUNlast(u));
	while (delt < delLast){
		LocateDelete_@1(AVLIndex[indexPos].Tree, *(oid*)delh, (@1*)delt, b, first, xx);
		delt+=xx; delh+=xx;
	}
	
	BATmode(u, TRANSIENT);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);
	
	return MAL_SUCCEED;
}

@

@c
@:InsertIndexElements(chr,simple,)@
@:InsertIndexElements(sht,simple,)@
@:InsertIndexElements(int,simple,)@
@:InsertIndexElements(lng,simple,)@
@:InsertIndexElements(flt,simple,)@
@:InsertIndexElements(dbl,simple,)@
@:InsertIndexElements(date,atom,TYPE_)@

@-
The core cracking routines.

@= moveOrdered
	while (@1 @6 ){
		@2 @4= xx;
		@3 @4= xx;
		@5
	}
@

@= OThree
	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)ct @5){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
		
		}
		else{
			scr_h[mids] = *(oid*)tmph;
			scr_t[mids] = *(@1* )tmpt;				
			mids--;	
		}
		tmpt @2= xx;
		tmph @2= xx;
		while (tmpt @3 ht && *(@1*)tmpt @5){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	tmph = hh;
	tmpt = ht;
	ct @2= xx*((scrH-mids)+hil);
	for(; tmpt @7 ct; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
	}
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}
	i = mids + 1;
	for (; i <= scrH; i++){
		 if (*(@1*)tmpt @5){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
@

@= crackInThreeOrderedPieces
crackers_export str CRKcrackOrderedThree_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last);
str
CRKcrackOrderedThree_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last)
{
	BUN hh, ht, tmpt, tmph, ch, ct, t, s, fh, ft;
	oid *scr_h;
	@1  *scr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0, scrH, hil, mids, probe, j;
	int xx = BUNsize(b);
	int i;

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @4 low,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht<=tmpt)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	scrH = scr_size-1;	
	hil = 0; mids = scrH;
	ch = tmph; ct = tmpt;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 25;
	t = tmpt;
	s = tmpt+(2*probe*xx);
	j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;

	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OThree(@1,+,<=,@4 low,@7 hgh,-,>=)@
	}
	else{
		ch = hh; ct = ht;
		fh = tmph; ft = tmpt;
		tmph = hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OThree(@1,-,>=,@7 hgh,@4 low,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}

crackers_export str CRKcrackOrderedThreeL_@2_@3_@1(BAT *b, @1 low, @1 hgh, lng idx_first, lng idx_last, lng *posl, lng *posh);
str
CRKcrackOrderedThreeL_@2_@3_@1(BAT *b, @1 low, @1 hgh, lng idx_first, lng idx_last, lng *posl, lng *posh)
{
	BUN lh, lt, hh, ht, tmpt, tmph, t, s, fh, ft, mh, mt;
	oid *scr_h,*mscr_h;
	@1  *scr_t,*mscr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0, scrH, hp, hil, mids, mmids, j, probe;
	int xx = BUNsize(b);
	lng pos1, pos2;

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @4 low,lh,lt,+,lowShrinked++;,&& lt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht>=lt)@

	/*These are different cases. For now just make sure that the result will be empty.
		todo: when the index will learn from empty results return the appropriate information*/
	
	if (lowShrinked == scr_size) {
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == scr_size){
		*posl =  1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	/*Middle piece is empty and lt = ht + 1*/
	if (lowShrinked + hghShrinked == scr_size){
		*posl =  BUNindex(b,lt);
		*posh =  BUNindex(b,ht);
		return MAL_SUCCEED;
	}

	scrH = scr_size-1;	
	hp = 0; hil = 0; mids = scrH; mmids = 0;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	mscr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	mscr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 100;
	t = lt;
	s = lt+(2*probe*xx);
	j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;
	if (j > probe){
		tmph = lh;
		tmpt = lt;	
		@:OThreeLateCopying(@1,+,<=,@4 low,@7 hgh,-,>=,@5,@6)@
		*posl = pos1;
		*posh = pos2;
	}
	else{
		tmph = hh;
		tmpt = ht;	
		fh = lh; ft = lt;
		lh = hh; lt = ht;
		hh = fh; ht = ft;
		@:OThreeLateCopying(@1,-,>=,@7 hgh,@4 low,+,<=,@5,@6)@
		*posl = pos2;
		*posh = pos1;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@
@= OThreeLateCopying
{
	BUN tmp1, tmp2;
	int i;

	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	tmp1 = lt;
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)lt @5){
				scr_h[hil] = *(oid*)lh;
				scr_t[hil] = *(@1* )lt;				
				hil++;	
			}
			if (*(@1*)lt @8 low && *(@1*)lt @9 hgh){
				scr_h[mids] = *(oid*)lh;
				scr_t[mids] = *(@1* )lt;				
				mids--;	
			}
			*(oid*)lh = *(oid*)tmph;
			*(@1 *)lt = *(@1 *)tmpt;
			lh @2= xx;
			lt @2= xx;
		}
		hp++;
		tmpt @2= xx;
		tmph @2= xx;
		while (*(@1*)tmpt @5 && tmpt @3 ht){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	
	pos1 = BUNindex(b,lt);

	tmph = hh;
	tmpt = ht;
	tmp2 = lt;
	tmp1 @2= xx*(hp+hil);
	for(; tmpt @7 tmp1; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
	}
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}

	pos2 = BUNindex(b,tmpt);

	i = 0;
	for (; i < mmids; i++){
		 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = mscr_h[i];
		*(@1 *)tmpt = mscr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
	tmp2 @2= xx*(scrH-mids);
	/*todo check as in the zero case*/
	mh= tmph;
	mt = tmpt;
	for(; tmpt @7 tmp2; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			if (mt != tmpt){
				*(oid*)mh = *(oid*)tmph;
                        	*(@1 *)mt = *(@1 *)tmpt;
			}
                        mh @6= xx;
                        mt @6= xx;
		}
	}

        i = mids+1;
        for (; i <= scrH; i++){
                 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
                if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
	        	*(oid*)mh = *(oid*)tmph;
                        *(@1 *)mt = *(@1 *)tmpt;
                        mh @6= xx;
                        mt @6= xx;
                }
                *(oid*)tmph = scr_h[i];
                *(@1 *)tmpt = scr_t[i];
                tmph @6= xx;
                tmpt @6= xx;
        }
}
@
@= OrderedZero
		while (tmpt @3 ht){
			while (*(@1*)tmpt @4 mid){
				tmpt @2=xx;
				tmph @2=xx;
			}
			if (*(@1*)ct @4 mid){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
			
			tmpt @2= xx;
			tmph @2= xx;
		}
		tmph @5= 2*xx;
		tmpt @5= 2*xx;
	
		/* Take the position where the last BUN of the left piece is. */
		*pos = BUNindex(b,ct @7);

		ct  @2= xx*hil;
		/*Extreme case where all lows(or all but one, or all but two) where in the hgh partition (or opposite depending how we move) */
		if (ct @6 tmpt ){
			if (ct == tmpt || ct == tmpt @2 xx) {
				for (i=hil; i >=0 ; i--){
					if (*(@1*)tmpt @4 mid){
						*(oid*)hh = *(oid*)tmph;
						*(@1 *)ht = *(@1 *)tmpt;
						hh @5= xx;
						ht @5= xx;
					}	
					tmpt @5= xx;
					tmph @5= xx;
				}
				for (i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}

			}
			else{
				for (i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}
			}
			return MAL_SUCCEED;
		}

		for(; tmpt @6 ct; tmph @5=xx, tmpt @5=xx){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}
		}
		for (i=hil-1; i >=0 ; i--){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}	
			*(oid*)tmph = scr_h[i];
			*(@1 *)tmpt = scr_t[i];
			tmpt @5= xx;
			tmph @5= xx;
		}
@
@= crackInTwoOrderedPieces
crackers_export str CRKcrackOrderedZero_@2_@1(BAT *b, @1 mid, lng idx_first, lng idx_last, lng *pos);
str
CRKcrackOrderedZero_@2_@1(BAT *b, @1 mid, lng idx_first, lng idx_last, lng *pos)
{
	BUN hh, ht, tmpt, tmph, fh, ft;
	BUN ch, ct, t, s;
	oid *scr_h;
	@1  *scr_t;
	lng hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);
	int j=0, hil=0, scr_size, probe = 25;
	int i;

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @3 mid,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @4 mid,hh,ht,-,hghShrinked++;,&& ht>=tmpt)@
	if (lowShrinked == idx_last - idx_first + 1) {
			*pos = idx_last+1;
			return MAL_SUCCEED;
	}
	if (hghShrinked == idx_last - idx_first + 1){
			*pos = idx_first-1;
			return MAL_SUCCEED;
	}
	
	if (ht == tmpt + xx){
		oid dh = *(oid*)tmph;
		@1  dt = *(@1 *)tmpt;
		*(oid*)tmph = *(oid*)hh;
		*(@1 *)tmpt = *(@1 *)ht;

		*pos = BUNindex(b,tmpt);

		*(oid*)hh = dh;
		*(@1 *)ht = dt;

		return MAL_SUCCEED;
	}

	if (ht == tmpt - xx){
		*pos = BUNindex(b,ht);
		return MAL_SUCCEED;
	}	

	scr_size = (idx_last - idx_first +1 -lowShrinked -hghShrinked);
	if (scr_size >=2) scr_size = scr_size/2;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	t = tmpt;
	s = tmpt+(2*probe*xx);
	for (;t<s;t+=xx)
		j+=*(@1*)t @3 mid;
	
	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OrderedZero(@1,+,<=,@4,-,>=, -xx)@
	}
	else{
		ch =hh; ct = ht;
		fh = tmph, ft = tmpt;
		tmph =hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OrderedZero(@1,-,>=,@3,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@

@= shuffle
        tdummy= *(@1*) @2;
        *(@1*) @2= *(@1*) @3;
        *(@1*) @3= tdummy;

        hdummy= *(oid*)((char*)@2 - b->tloc);
        *(oid*)((char*)@2 - b->tloc) = *(oid*)((char*)@3 - b->tloc);
        *(oid*)((char*)@3 - b->tloc) = hdummy;
@

@= crackInTwoUnorderedPieces
crackers_export str CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, lng first, lng last, lng *pos);
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, lng first, lng last, lng *pos){
        ptr vm, vl;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        vl= BUNtloc(b,BUNptr(b,last));

        while(vm<vl) {
                if (@5_@3(vm, &mval,@6@1))
                        vm = (ptr) ((char *) vm + xx);
                else {
                        while( @5_@4(vl, &mval,@6@1) && vl>vm)
                                vl = (ptr) ((char *) vl - xx);
                        @:shuffle(@1,vm,vl)@
                        vl = (ptr) ((char *) vl - xx);
                        vm = (ptr) ((char *) vm + xx);
                }
        }

	if (vl == vm) {
		if (@5_@4(vl, &mval,@6@1))
			*pos = BUNindex(b,(ptr) ((char *) vl - xx)); /*works for empty left piece also*/
		else{
			*pos = BUNindex(b,vl);
			if (BUNindex(b,vl)==(size_t)last) /*empty right piece*/
				*pos = *pos+1;
		}
	}
	else
		*pos = BUNindex(b,vl);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPieces

crackers_export str CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh);
str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh){
        ptr vm, vl, hmax;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        hmax = BUNtloc(b,BUNptr(b,last));
        while( @8_@7(hmax, &hgh,@9@1) && hmax>vm)
                hmax= (ptr)((char*) hmax - xx);

	if (hmax == vm){
		if (@8_@7(hmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(hmax, &low,@9@1)){  /*result is one bun*/
			*posl = *posh = BUNindex(b,hmax);
		}
		else{
			*posl = BUNindex(b,(ptr) ((char *) hmax + xx));
			*posh = BUNindex(b,hmax);
		}
		return MAL_SUCCEED;
	}

        vl = hmax;
        while( @8_@5(vl, &low,@9@1) && vl>vm){
                /* move all high values into their final place */
                if( @8_@7(vl, &hgh,@9@1)){
                        @:shuffle(@1,vl,hmax)@
                        hmax= (ptr)((char*) hmax - xx);
                }
                vl= (ptr)((char*) vl - xx);
        }
	if (vl == vm){/*left piece is empty*/
		if (@8_@7(vl, &hgh,@9@1)){
			@:shuffle(@1,vl,hmax)@
			*posl = BUNindex(b,vl);
		}
		else if (@8_@5(vl, &low,@9@1)){
			*posl = BUNindex(b,vl);

		}
		else{
			*posl = BUNindex(b,(ptr) ((char *) vl + xx));
			
		}
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@8_@4(vm, &low,@9@1)){
                        vm = (ptr) ((char *) vm + xx);
                } else {
                        @:shuffle(@1,vm,vl)@
                        while( @8_@5(vl, &low,@9@1) && vl>vm){
                                if(@8_@7(vl, &hgh,@9@1) ){
                                        @:shuffle(@1,vl,hmax)@
                                        hmax= (ptr)((char*) hmax - xx);
                                }
                                vl = (ptr) ((char *) vl - xx);
                        }
                }
        }
	if (vm ==  BUNtloc(b,BUNptr(b,last+1))){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /*then middle piece is empty*/
		*posl = BUNindex(b,(ptr) ((char *) vl + xx));
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
	*posl = BUNindex(b,vm);
	*posh = BUNindex(b,hmax);

	return MAL_SUCCEED;
}
@

@= shuffleProjections2
	hdummy = *(@1*) @3;
	*(@1*) @3= *(@1*) @4;
        *(@1*) @4= hdummy;

	tdummy= *(@2*) @5;
        *(@2*) @5= *(@2*) @6;
        *(@2*) @6 = tdummy;
@
@= crackInTwoUnorderedPiecesProjections
crackers_export str CRKcrackUnorderedZeroProjections_@3_@1_@2( BAT *b, @1 mval, lng first, lng last, lng *pos);
str
CRKcrackUnorderedZeroProjections_@3_@1_@2( BAT *b, @1 mval, lng first, lng last, lng *pos){
        BUN vm, vl;
        BUN vmt, vlt;
        int xx;
        @1 hdummy;
        @2 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNhloc(b, BUNptr(b,first));
        vl= BUNhloc(b,BUNptr(b,last));
        vmt = BUNtloc(b, BUNptr(b,first));
        vlt= BUNtloc(b,BUNptr(b,last));

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  += xx; 
			vmt += xx;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  -= xx; 
				vlt -= xx;
			}
                        @:shuffleProjections2(@1,@2,vm,vl,vmt,vlt)@
                        vl  -= xx;
			vlt -= xx;
                        vm  += xx;
			vmt += xx;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = BUNindex(b,vl - xx); /*works for empty left piece also*/
		else{
			*pos = BUNindex(b,vl);
			if (BUNindex(b,vl)==(size_t)last) /*empty right piece*/
				*pos = *pos+1;
		}
	}
	else
		*pos = BUNindex(b,vl);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPiecesProjections

crackers_export str CRKcrackUnorderedThreeProjections_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh);
str
CRKcrackUnorderedThreeProjections_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh){
        BUN vm, vl, hmax;
        BUN vmt, vlt, hmaxt;
        int xx;
        @1 hdummy;
        @2 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNhloc(b, BUNptr(b,first));
        hmax = BUNhloc(b,BUNptr(b,last));
        vmt = BUNtloc(b, BUNptr(b,first));
        hmaxt = BUNtloc(b,BUNptr(b,last));
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm){
                hmax-= xx; hmaxt-= xx;
	}

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@9_@6(hmax, &low,@[10]@1)){  /*result is one bun*/
			*posl = *posh = BUNindex(b,hmax);
		}
		else{
			*posl = BUNindex(b, hmax + xx);
			*posh = BUNindex(b,hmax);
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleProjections2(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax-=xx;hmaxt-=xx;
                }
                vl-= xx; vlt-= xx;
        }
	if (vl == vm){/*left piece is empty*/
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleProjections2(@1,@2,vl,hmax,vlt,hmaxt)@
			*posl = BUNindex(b,vl);
		}
		else if (@9_@6(vl, &low,@[10]@1)){
			*posl = BUNindex(b,vl);

		}
		else{
			*posl = BUNindex(b,vl + xx);
			
		}
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm += xx; vmt += xx;
                } else {
                        @:shuffleProjections2(@1,@2,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleProjections2(@1,@2,vl,hmax,vlt,hmaxt)@
                                        hmax-=xx; hmaxt-=xx;
                                }
                                vl -= xx; vlt -= xx;
                        }
                }
        }
	if (vm ==  BUNhloc(b,BUNptr(b,last+1))){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /*then middle piece is empty*/
		*posl = BUNindex(b,vl + xx);
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
	*posl = BUNindex(b,vm);
	*posh = BUNindex(b,hmax);

	return MAL_SUCCEED;
}
@

@= operationsOrdered
@:crackInTwoOrderedPieces(@1,LE,<=,>)@
@:crackInTwoOrderedPieces(@1,RE,<,>=)@
@:crackInThreeOrderedPieces(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeOrderedPieces(@1,LE,RE,<,>=,<=,>)@
@:crackInThreeOrderedPieces(@1,LO,RO,<=,>,<,>=)@
@:crackInThreeOrderedPieces(@1,LE,RO,<,>=,<,>=)@


crackers_export str CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid);
str
CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid)
{
        BAT *b;
        str msg;
	lng pos;

        if ((b = BATdescriptor(*bid)) == NULL) {
                throw(MAL, "crackers.crack_zeroOrdered", "Cannot access descriptor");
        }

        msg = CRKcrackOrderedZero_LE_@1(b,*mid, 0, BATcount(b)-1,&pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}


crackers_export str CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid);
str
CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid)
{
        BAT *b;
	str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                throw(MAL, "crackers.crack_oneOrdered", "Cannot access descriptor");
        }

	msg = CRKcrackOrderedThree_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);
        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

crackers_export str CRKcrackOrderedTwo_@1 (int *res, int *bid, @1 *low, @1 *hgh);
str
CRKcrackOrderedTwo_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;

	if (*(@1 *) low > *(@1 *) hgh)
		throw(MAL, "crackers.crack_twoOrdered", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "crackers.crack_twoOrdered", "Cannot access descriptor");
	}

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return MAL_SUCCEED;
}

crackers_export str CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
str
CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;
	lng posl,posh;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "crackers.crack_threeOrdered", "Cannot access descriptor");
	}

        msg = CRKcrackOrderedThreeL_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1,&posl, &posh);
	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

@= operations
@:crackInTwoUnorderedPieces(@1,LE,LE,GT,@2,@3)@
@:crackInTwoUnorderedPieces(@1,RE,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
crackers_export str CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid);

str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid)
{
        BAT *b;
        str msg;
	lng pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_zeroUnordered", "Need more clever mapping ");

        msg = CRKcrackUnorderedZero_LE_@1( b, *mid,(size_t) 0, BATcount(b)-1, &pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

crackers_export str CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
        BAT *b;
        str msg;
	lng posl, posh;

        if (*(@1 *) low > *(@1 *) hgh)
                throw(MAL, "crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_threeUnordered", "Need more clever mapping ");

        msg = CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}


@

@= operationsProjections
@:crackInTwoUnorderedPiecesProjections(@1,@2,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesProjections(@1,@2,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesProjections(@1,@2,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesProjections(@1,@2,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesProjections(@1,@2,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesProjections(@1,@2,LE,RO,LT,GE,LT,GE,@3,@4)@
@


@= validate_operations
@:validate_operation_Zero(@1,@2)@
@:validate_operation_One(@1,@2)@
@:validate_operation_Two(@1,@2)@
@:validate_operation_Three(@1,@2)@
@
@= validate_init_1
	BAT *b,*c,*w;
	BUN fst_bn, lst_bn, bn;
	int bs;
	size_t count[6] = {0,0,0,0,0,0};

	/* initialization */
	*res = FALSE;
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "crackers.@2crack_validate", "Cannot access descriptor");
	}

	bs = BUNsize(b);
	fst_bn = BUNfirst(b);
	lst_bn = BUNlast(b);
	bn = fst_bn;
@
@= validate_init_2
	if (low > hgh) {
		BBPunfix(b->batCacheid);
		throw(MAL, "crackers.@2crack_validate", "illegal range");
	}
@
@= validate_checkUnordered
        while (bn < lst_bn @2 @3 ) {
                bn += bs;
                count[@1]++;
        }
@
@= validate_checkOrdered
{	oid hd = 0;
	while (bn < lst_bn && hd <= *(oid*)BUNhloc(b, bn) @2 @3 ) {
		hd = *(oid*)BUNhloc(b, bn);
		bn += bs;
		count[@1]++;
}	}
@
@= validate_check_1
	@:validate_check@5(@2, && *(@1*)BUNtloc(b, bn) @3 @4 )@
@
@= validate_check_2
	@:validate_check@7(@2, && *(@1*)BUNtloc(b, bn) @3 @4 , && *(@1*)BUNtloc(b, bn) @5 @6 )@
@
@= validate_end
	count[0] = BATcount(b);
	if (bn < lst_bn) {
		@3;
		c = BATslice(b, BUNindex(b, fst_bn), BUNindex(b, bn));
		w = BATslice(b, BUNindex(b, bn), BUNindex(b, lst_bn));
		printf("correct:\n");
		BATprint(c);
		printf("wrong:\n");
		BATprint(w);
		BBPunfix(w->batCacheid);
		BBPunfix(c->batCacheid);
		BBPunfix(b->batCacheid);
		throw(MAL, "crackers.@2crack_validate", "Invalid crack");
	}
	assert(bn == lst_bn);
	assert(count[0] == count[1] + count[2] + count[3] + count[4] + count[5]);
	BBPunfix(b->batCacheid);
	*res = TRUE;
	return MAL_SUCCEED;
@
@= validate_operation_Zero
crackers_export str CRKcrack@2Zero_validate_@1 (bit *res, int *bid, @1 *_mid);
str
CRKcrack@2Zero_validate_@1 (bit *res, int *bid, @1 *_mid)
{
	@1 mid=*_mid;
	@:validate_init_1(@1,z)@

	@:validate_check_1(@1,1,<=,mid,@2)@
	@:validate_check_1(@1,2,> ,mid,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2]);\
	)@
}
@
@= validate_operation_One
crackers_export str CRKcrack@2One_validate_@1 (int *res, int *bid, @1 *_mid);
str
CRKcrack@2One_validate_@1 (int *res, int *bid, @1 *_mid)
{
	@1 mid=*_mid;
	@:validate_init_1(@1,)@

	@:validate_check_1(@1,1,< ,mid,@2)@
	@:validate_check_1(@1,2,==,mid,@2)@
	@:validate_check_1(@1,3,> ,mid,@2)@
	
	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2], (dbl)mid, count[3]);\
	)@
}
@
@= validate_operation_Two
crackers_export str CRKcrack@2Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh);
str
CRKcrack@2Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh)
{
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,)@
	@:validate_init_2(@1,)@

	@:validate_check_1(@1,1,< ,low,@2)@
	@:validate_check_1(@1,2,==,low,@2)@
	@:validate_check_2(@1,3,> ,low,< ,hgh,@2)@
	@:validate_check_1(@1,4,==,hgh,@2)@
	@:validate_check_1(@1,5,> ,hgh,@2)@

	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |%f<tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, count[2], (dbl)low, (dbl)hgh, count[3], (dbl)hgh, count[4], (dbl)hgh, count[5]);\
	)@
}
@
@= validate_operation_Three
crackers_export str CRKcrack@2Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh);
str
CRKcrack@2Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh)
{
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,z)@
	@:validate_init_2(@1,z)@

	@:validate_check_1(@1,1,<=,low,@2)@
	@:validate_check_1(@1,2,<=,hgh,@2)@
	@:validate_check_1(@1,3,> ,hgh,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |%f<tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, (dbl)hgh, count[2], (dbl)hgh, count[3]);\
	)@
}
@

@c
@:validate_operations(chr,Unordered)@
@:validate_operations(sht,Unordered)@
@:validate_operations(int,Unordered)@
@:validate_operations(lng,Unordered)@
@:validate_operations(flt,Unordered)@
@:validate_operations(dbl,Unordered)@
@:validate_operations(chr,Ordered)@
@:validate_operations(sht,Ordered)@
@:validate_operations(int,Ordered)@
@:validate_operations(lng,Ordered)@
@:validate_operations(flt,Ordered)@
@:validate_operations(dbl,Ordered)@
@:operations(chr,simple,)@
@:operations(sht,simple,)@
@:operations(int,simple,)@
@:operations(lng,simple,)@
@:operations(flt,simple,)@
@:operations(dbl,simple,)@
@:operations(date,atom,TYPE_)@
@:operationsOrdered(chr,simple,)@
@:operationsOrdered(sht,simple,)@
@:operationsOrdered(int,simple,)@
@:operationsOrdered(lng,simple,)@
@:operationsOrdered(flt,simple,)@
@:operationsOrdered(dbl,simple,)@
@:operationsProjections(int,int,simple,)@
@:operationsProjections(int,sht,simple,)@
@:operationsProjections(int,chr,simple,)@
@:operationsProjections(int,lng,simple,)@
@:operationsProjections(int,flt,simple,)@
@:operationsProjections(int,dbl,simple,)@
@:operationsProjections(int,date,simple,)@  /* TODO: add the rest of the type combinations once code is stable */
@:operationsProjections(date,int,atom,TYPE_)@
@:operationsProjections(date,sht,atom,TYPE_)@
@:operationsProjections(date,chr,atom,TYPE_)@
@:operationsProjections(date,lng,atom,TYPE_)@
@:operationsProjections(date,flt,atom,TYPE_)@
@:operationsProjections(date,dbl,atom,TYPE_)@
@:operationsProjections(date,date,atom,TYPE_)@  /* TODO: add the rest of the type combinations once code is stable */
@}

@c
/* --Updates-- */


str
removeTreeIndex(int *bid){
	BAT *c;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
        	if (TreeIndex[i].bid == *bid){
                	position = i;	
			break;
		}
	/*if (position == -1) return; Trying to erase an index that does not exist*/

	/* Destroy index BAT */
        if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return "FAILED";
        }

	BBPunfix(c->batCacheid);
	BBPreclaim(c);
	TreeIndex[position].cid = -1;
	TreeIndex[position].reCreate = 1;

	/* Delete Tree */
	FreeAVLTree(TreeIndex[position].Tree);
	TreeIndex[position].Tree = NULL;
	
	return MAL_SUCCEED;
}

str
appendCrackerBAT(int * bid, int * new){
        BAT *c, *u;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((c = BATdescriptor(TreeIndex[position].cbid)) == NULL)
                throw(MAL, "bat.append", "Cannot access descriptor");

        if ((u = BATdescriptor(*new)) == NULL) {
                BBPreleaseref(c->batCacheid);
                throw(MAL, "bat.append", "Cannot access descriptor");
        }
	
	if (BATcount(u) == 0) {
		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

        BATappend(c, u, TRUE);

/* printf("\n index size of bat is "SZFMT" \n", BATcount(c));
   printf("\n update size of bat is "SZFMT" \n", BATcount(u));
*/

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

struct tempBATNode{
	BAT *b;
	lng position;
	struct tempBATNode *next;
	lng values;
};

@= newTempBAT
	if ((lastPos - prevPos) == written && crkt <= crkLast) {
		if (deleteNodes == FALSE){
			temp = GDKmalloc(sizeof(struct tempBATNode));
			temp->b = BATnew(TYPE_oid,TYPE_@1,insertions+startPosition);
			temp->next = NULL;
			wscrh = BUNhloc(temp->b,BUNfirst(temp->b));
			wscrt = BUNtloc(temp->b,BUNfirst(temp->b));
			temp->values = 0;
			lastBAT->next = temp;
			lastBAT = temp;
			bats++;
		} else
			hghIndexNode->deleted = TRUE;
		hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
		if (hghIndexNode != NULL)
			lastPos = *(lng*)BUNhloc(c, idxFirst + ((hghIndexNode->position) * zz));
		else
			lastPos = prevcrsize-1; 	
		temp->position  = lastPos;
	}
@

@= mergeInsertionsBody
        BAT *c, *u, *b;
	oid tmph;
	@1  tmpt;
	BUN insh, inst, crkh, crkt, rscrh=NULL, rscrt, wscrh, wscrt, idxFirst, cur, curValue, curPos, crkFirst, crkLast, insLast, insFirst;
	int xx, zz, bats = 0, position = -1;
	struct Node * hghIndexNode, *lowIndexNode;
	struct tempBATNode *tempBATs, *lastBAT, *temp;
	lng extended = 0, extendedIns = 0, insDone = 0, written, pos, prevPos, lastPos, prevcrsize, insertions, needed;
	bit takeNext;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*new)) == NULL)
                throw(MAL, "crackers.mergeInsertions_@1", "Cannot access insertions BAT");

	/* abort if there are no insertions to merge */	
	insertions = BATcount(u);
	if (insertions == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}
	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(TreeIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	insFirst = BUNfirst(u);	
	prevcrsize = BATcount(b);
	xx = BUNsize(b);
	zz = BUNsize(c);
	
	(void)insFirst;
	/* make room for the new buns */
	needed = insertions - (((b)->batBuns->size - (b)->batBuns->free) / xx);
	if ( needed > 0 ){
                size_t ncap = BATcapacity(b) + needed;
                size_t grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	temp = GDKmalloc(sizeof(struct tempBATNode));
	temp->b = BATnew(TYPE_oid,TYPE_@1,insertions+startPosition);
	temp->next = NULL;
	temp->values = 0;
	wscrh = BUNhloc(temp->b,BUNfirst(temp->b));
	wscrt = BUNtloc(temp->b,BUNfirst(temp->b));
	tempBATs = temp;
	lastBAT  = temp;

	insh 	 = BUNhloc(u,BUNfirst(u) + startPosition*xx);
	inst 	 = BUNtloc(u,BUNfirst(u) + startPosition*xx);
	insLast	 = BUNtloc(u,BUNlast(u));
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	crkLast  = BUNtloc(b,BUNlast(b)-xx);

	lowIndexNode = findNodeH_@1(*(@1*)inst, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
	if ( lowIndexNode == NULL )
		goto end;				
	cur      = idxFirst + ((lowIndexNode->position) * zz);
	curPos   = BUNhloc(c, cur);
	curValue = BUNtloc(c, cur);
	crkh = BUNhloc(b, crkFirst + (*(lng*)curPos) * xx + xx);
	crkt = BUNtloc(b, crkFirst + (*(lng*)curPos) * xx + xx);
	prevPos = *(lng*)curPos;
	hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
	if ( hghIndexNode == NULL )
		lastPos = prevcrsize - 1;
	else
		lastPos = *(lng*)BUNhloc(c, idxFirst + ((hghIndexNode->position) * zz) );

	tempBATs->position  = lastPos;
	written = 0;
	while(inst < insLast && (@2_LT(inst,curValue,@3@1) || (@2_EQ(inst,curValue,@3@1) && lowIndexNode->inclusive == FALSE)) @4){
		@:newTempBAT(@1)@
		if (crkt > crkLast){
			*(oid*)crkh = *(oid*)insh;		
			*(@1 *)crkt = *(@1 *)inst;		
			crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
			extendedIns++;
			lastBAT->values++;
			continue;
		}
		*(oid*)wscrh = *(oid*)crkh;		
		*(@1 *)wscrt = *(@1 *)crkt;
		*(oid*)crkh = *(oid*)insh;		
		*(@1 *)crkt = *(@1 *)inst;		
		crkh+=xx; crkt+=xx; insh+=xx; inst+=xx; wscrh+=xx; wscrt+=xx;
		insDone++; written++;
		lastBAT->values++;
	}

	/* update the index */
	*(lng*)curPos = *(lng*)curPos + insDone;

	while (@5){
		int totalValues;
	
		lowIndexNode = findNodeH_@1(*(@1*)BUNtloc(tempBATs->b,BUNfirst(tempBATs->b)), TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
		if (lowIndexNode == NULL)
			break; 	

		cur = idxFirst + ((lowIndexNode->position) * zz);
		curValue = BUNtloc(c, cur);
		curPos = BUNhloc(c, cur);
		pos = 0;
		prevPos = *(lng*)curPos;

		if (crkt <= crkLast){
			crkh = BUNhloc(b, crkFirst + (*(lng*)curPos) * xx + xx);
			crkt = BUNtloc(b, crkFirst + (*(lng*)curPos) * xx + xx);
		}
		if (bats > 0){
			if (crkt <= crkLast){
				temp = tempBATs->next;
				pos = temp->values;
				while (temp->next != NULL){
					temp = temp->next;
					pos += temp->values;
				}
				crkh+=pos*xx;
				crkt+=pos*xx;
				prevPos += pos;
			}
			wscrh = BUNhloc(lastBAT->b,BUNfirst(lastBAT->b)+lastBAT->values*xx);
			wscrt  = BUNtloc(lastBAT->b,BUNfirst(lastBAT->b)+lastBAT->values*xx);
			lastPos = lastBAT->position;
			takeNext = TRUE;
		} else {
			if (crkt <= crkLast){
				hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
				if ( hghIndexNode == NULL )
					lastPos = prevcrsize-1;
				else
					lastPos = *(lng*)BUNhloc(c, idxFirst + ((hghIndexNode->position) * zz) );
			}
			wscrh = BUNhloc(tempBATs->b,BUNfirst(tempBATs->b));
			wscrt = BUNtloc(tempBATs->b,BUNfirst(tempBATs->b));
			takeNext = FALSE;
		}		


		rscrh = BUNhloc(tempBATs->b,BUNfirst(tempBATs->b));
		rscrt = BUNtloc(tempBATs->b,BUNfirst(tempBATs->b));
		totalValues = tempBATs->values;
		/* replace at the and of this chunk all values taken from the beginning of it */
		for (written=0;written<totalValues;written++){
			@:newTempBAT(@1)@
			if (crkt > crkLast){
				*(oid*)crkh = *(oid*)rscrh;
				*(@1 *)crkt = *(@1 *)rscrt;
				crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx;
				extended++;
				if (takeNext == FALSE)
					tempBATs->values--;
				continue;
			}
			tmph = *(oid*)crkh;
			tmpt = *(@1 *)crkt;
			*(oid*)crkh = *(oid*)rscrh;
			*(@1 *)crkt = *(@1 *)rscrt;
			*(oid*)wscrh = tmph;
			*(@1 *)wscrt = tmpt;
			crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx; wscrh+=xx; wscrt+=xx;
			if (bats > 0){
				lastBAT->values++;
				if (takeNext == FALSE)
					tempBATs->values--;
			}
		}
		
		/* then put any insertions that belong here */
		while( inst < insLast && (@2_LT(inst,curValue,@3@1) || (@2_EQ(inst,curValue,@3@1) && lowIndexNode->inclusive == FALSE)) @4){
			@:newTempBAT(@1)@
			if (crkt > crkLast){
				*(oid*)crkh = *(oid*)insh;		
				*(@1 *)crkt = *(@1 *)inst;		
				crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
				extendedIns++;
				continue;
			}
			*(oid*)wscrh = *(oid*)crkh;		
			*(@1 *)wscrt = *(@1 *)crkt;
			*(oid*)crkh = *(oid*)insh;		
			*(@1 *)crkt = *(@1 *)inst;		
			crkh+=xx; crkt+=xx; insh+=xx; inst+=xx; wscrh+=xx; wscrt+=xx; rscrh+=xx; rscrt+=xx;
			insDone++; written++;				
			lastBAT->values++;
		}
		
		/* update the index */
		*(lng*)curPos = *(lng*)curPos + insDone + extendedIns;

		/* take the next temp BAT */
		if (takeNext == TRUE){
			temp = tempBATs;
			tempBATs = tempBATs->next;
			BBPreclaim(temp->b);
			GDKfree(temp);
			bats--;
		}
	}

	end:;
	if (lowIndexNode == NULL){
		crkLast = BUNlast(b) + (extended+extendedIns)*xx;
		crkh = BUNhloc(b,crkLast);
		crkt = BUNtloc(b,crkLast);

		/* append scratch */
		temp  = tempBATs;
		rscrh = BUNhloc(temp->b,BUNfirst(temp->b));
		rscrt = BUNtloc(temp->b,BUNfirst(temp->b));
		written = 0;
		while(1){
			*(oid*)crkh = *(oid*)rscrh;
			*(@1 *)crkt = *(@1 *)rscrt;
			written++; crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx;
			if (written == temp->values){
				crkLast += written*xx;
				if (tempBATs->next != NULL){
					tempBATs = tempBATs->next;
					BBPunfix(temp->b->batCacheid); /* TODO Destroy */
					GDKfree(temp);
					temp = tempBATs;
					rscrh = BUNhloc(temp->b,BUNfirst(temp->b));
					rscrt = BUNtloc(temp->b,BUNfirst(temp->b));
				 	written = 0;
				} else {
					BBPunfix(temp->b->batCacheid); /* TODO Destroy */
					GDKfree(temp);
					break;
				}	
			}
		}
	
		/* append the rest of the insertions if any */
		written = 0;
		while (inst < insLast @4){
			*(oid*)crkh = *(oid*)insh;
			*( @1*)crkt = *( @1*)inst;
			crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
			insDone++;				
			written++;
		}		
	
		crkLast += written*xx;
		b->batBuns->free = crkLast - b->batBuns->base; /* crkt should be the one after the last */
   		BATsetcount(b, b->batBuns->free/xx);
/*	
printf(" \n Total bun in are %lld \n", insDone+ extendedIns);
printf("size is "SZFMT"  --- prev: %lld", BATcount(b), prevcrsize);	
*/
	}
@

@= mergeInsertionsFromTheEndBodyI
        BAT *c, *u, *b;
	BUN insh, inst, crkh, crkt, idxFirst, cur, curVal, curPos, crkFirst, crkLast, insFirst, next, write;
	int xx, zz, position = -1;
	struct Node *IndexNode = NULL;
	lng prevPos, prevcrsize, insertions, remainingIns, buns, needed;
	struct Node *prevNode =NULL;

#ifdef DEBUG_CRACKERS_INSERTIONS
int pieces = 0;
int movements = 0;
lng TstartSearchAVL, TendSearchAVL;
lng TotalSearchAVL = 0;
#endif

	{
		int i;
		for (i = 0; i < maxCrackMap; i++)
			if (TreeIndex[i].bid == *bid){
				position = i;
				break;	
			}
	}

        if ((u = BATdescriptor(*new)) == NULL)
                throw(MAL, "crackers.mergeInsertions_@1", "Cannot access insertions BAT");

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(TreeIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	if (endPosition == -1)
		endPosition = BATcount(u) - 1;
	insertions = endPosition - startPosition + 1;

/* printf("\n inserting %lld", insertions);*/

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	xx = BUNsize(b);
	zz = BUNsize(c);
	insFirst = BUNfirst(u);	

	/* make room for the new buns */
	needed = insertions - (((b)->batBuns->size - (b)->batBuns->free) / xx);
	if ( needed > 0 ){
                size_t ncap = BATcapacity(b) + needed;
                size_t grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = BUNhloc(u, insFirst + endPosition*xx);
	inst 	 = BUNtloc(u, insFirst + endPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	prevPos = prevcrsize - 1;
@
@= mergeLoop

		if ( IndexNode == NULL )
			goto mergeDone;

#ifdef DEBUG_CRACKERS_INSERTIONS
TendSearchAVL = GDKusec();
TotalSearchAVL += TendSearchAVL - TstartSearchAVL;
pieces++;
#endif

		/* first position after the last value of this piece. Here we will start moving values we shift from the begginning of the piece */
		
		write  = next + xx - (prevNode==NULL?0:prevNode->hols)*xx;

		cur    = idxFirst + (IndexNode->position) * zz;
                curPos = BUNhloc(c, cur);
		curVal = BUNtloc(c, cur);
/*
printf("\n prevPos %lld, curPos %lld \n", prevPos, *(lng*)curPos);
*/
		buns   = prevPos - (*(lng*)curPos) - (prevNode==NULL?0:prevNode->hols); /* find out how many values this piece has */

		/* prevPos takes the correct value for the next itteration */
		prevPos = *(lng*)curPos;

		/* next takes the corect value for the next itteration. This is the position of the last value of the previous piece */
		next   = crkFirst + (*(lng*)curPos) * xx;
	
		/* First insert any pending insertions that belong to this piece */
		crkh = BUNhloc(b,write+(remainingIns-1)*xx);
		crkt = BUNtloc(b,write+(remainingIns-1)*xx);
		while(  remainingIns > 0 &&
			(@2_GT(inst,curVal,@3@1) || (@2_EQ(inst,curVal,@3@1) && IndexNode->inclusive == TRUE)) ){
			*(oid*)crkh = *(oid*)insh;
			*(@1 *)crkt = *(@1 *)inst;
			crkh-=xx; crkt-=xx; insh-=xx; inst-=xx; remainingIns--;
		}
/*
if (prevNode == NULL)
printf("\n Hols null, remaining %lld, buns %lld \n", remainingIns, buns);
else
printf("\n Hols %lld, remaining %lld, buns %lld \n", prevNode->hols, remainingIns, buns);
*/
		if (remainingIns == 0)
                	goto mergeDone;

		/* Then we shift values from the beggining of the piece */
		if (buns > remainingIns){
			memcpy(write, next+xx, remainingIns*xx);

#ifdef DEBUG_CRACKERS_INSERTIONS
movements += remainingIns;
#endif

		} else {
			memcpy( write+ (remainingIns-buns)*xx, next+xx, buns*xx);

#ifdef DEBUG_CRACKERS_INSERTIONS
movements += buns;
#endif

		}
		
		/*printf("updating index in position %lld to be %lld \n", *(lng*)curPos, *(lng*)curPos+remainingIns);*/
		/* we always update the index to be +remainingIns since even if we move buns values we put them remainingIns positions ahead */
		*(lng*)curPos =  *(lng*)curPos + remainingIns;
		prevNode = IndexNode;
@
@= mergeInsertionsFromTheEndBodyCG
	/* merge for the last piece only */
	if ( remainingIns > 0) {

#ifdef DEBUG_CRACKERS_INSERTIONS
TstartSearchAVL = GDKusec();
#endif

		/* get the last piece */
		IndexNode = findNodeL_@1(*(@1*)hgh, inclusive, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
/*		IndexNode = NULL;
		temp = TreeIndex[position].Tree;
		if (temp->deleted == FALSE)
			IndexNode = temp;
		while(temp->right != NULL) {
			temp = temp->right;
			if (temp->deleted == FALSE)
				IndexNode = temp;
		}	
		temp = TreeIndex[position].Tree;
		while (IndexNode == NULL && temp->left!=NULL){
			temp = temp->left;
			if (temp->deleted == FALSE)
                		IndexNode = temp;
        		while(temp->right != NULL) {
                       		temp = temp->right;
                        	if (temp->deleted == FALSE)
                               		IndexNode = temp;
               		}
		}
*/
		@:mergeLoop(@1,@2,@3)@
	}

@= mergeInsertionsFromTheEndBodyII
	/* Here the actual merging happens. Starting from the piece where next belongs we continuously 
	   insert and shift until there are no more insertions or pieces */
	while ( remainingIns > 0) {

#ifdef DEBUG_CRACKERS_INSERTIONS
TstartSearchAVL = GDKusec();
#endif

		IndexNode = findPreviousPieceWalkingBack(prevNode);
		@:mergeLoop(@1,@2,@3)@
	}

	mergeDone:;

	/* We reached the first piece. If there are more insertions then they all go here */
	if (IndexNode == NULL && remainingIns > 0){
		
/*		memcpy(next + xx - (prevNode==NULL?0:prevNode->hols)*xx, BUNfirst(u)+startPosition*xx, remainingIns*xx);*/

		crkh = BUNhloc(b,next + xx - (prevNode==NULL?0:prevNode->hols)*xx + (remainingIns-1)*xx);
                crkt = BUNtloc(b,next + xx - (prevNode==NULL?0:prevNode->hols)*xx + (remainingIns-1)*xx);
                while(  remainingIns > 0  ){
                        *(oid*)crkh = *(oid*)insh;
                        *(@1 *)crkt = *(@1 *)inst;
                        crkh-=xx; crkt-=xx; insh-=xx; inst-=xx; remainingIns--;
		}

#ifdef DEBUG_CRACKERS_INSERTIONS
pieces++;
movements += remainingIns;
#endif
	}

@

@= shrinkInsertions
		/* shrink the insertions bat */
		if (startPosition == 0 && (size_t)endPosition == BATcount(u)){
                        BATmode(u, TRANSIENT);
                        TreeIndex[position].iid = -1;
                } else
                if ((size_t)endPosition == BATcount(u)){
                        crkLast = insFirst + startPosition*xx;
                        u->batBuns->free = crkLast - u->batBuns->base;
                        BATsetcount(u, u->batBuns->free/xx);
                } else {
			crkh  = insFirst+startPosition*xx;
			insh  = insFirst+endPosition*xx;
			memmove(crkh,insh, (BATcount(u)-endPosition)*xx);

			crkLast = insFirst + (startPosition + (BATcount(u) - endPosition))*xx;
			u->batBuns->free = crkLast - u->batBuns->base;
   			BATsetcount(u, u->batBuns->free/xx);
		}
@

@= shrinkDeletions
		/* shrink the deletions bat */
		endPosition += 1;
{
BAT *shrinkSLice  = BATslice(u,startPosition,endPosition);
BAT *shrinkCopy = BATcopy(shrinkSLice, shrinkSLice->htype, shrinkSLice->ttype, TRUE);
u = BATdel(u, shrinkCopy, TRUE);
BBPunfix(shrinkSLice->batCacheid);
BBPunfix(shrinkCopy->batCacheid);
}
/*		if (startPosition == 0 && (size_t)endPosition == BATcount(u)){
			BATmode(u, TRANSIENT);
                        TreeIndex[position].did = -1;
                        if (TreeIndex[position].mergeDeletions != 2)
                                TreeIndex[position].mergeDeletions = -1;
		} else
		if ((size_t)endPosition == BATcount(u)){
			crkLast = delFirst + startPosition*xx;
	                u->batBuns->free = crkLast - u->batBuns->base;
        	        BATsetcount(u, u->batBuns->free/xx);
		} else {
			crk  = delFirst+startPosition*xx;
			delt = delFirst+endPosition*xx;
			memmove(crk,delt, (BATcount(u)-endPosition)*xx);

			crkLast = delFirst + (startPosition + (BATcount(u) - endPosition))*xx;
			u->batBuns->free = crkLast - u->batBuns->base;
   			BATsetcount(u, u->batBuns->free/xx);
		}
*/
@

@= mergeDeletionsBody
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN delt, idxFirst, crk, crkFirst, crkLast, delFirst, low, lowVal, hgh, hghPos=NULL, hghVal, pos, posLast;
	int xx, zz, pp, position = -1;
	lng deletions, remainingDel, buns;
	struct Node *lowNode, *hghNode, *temp;
	lng LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	lng holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;

/*
	lng T1=0,T2=0, joinCost=0;
*/

	for (i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(TreeIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	if (endPosition == -1)
		endPosition = BATcount(u) - 1;

	deletions = endPosition - startPosition + 1;

	remainingDel = deletions;
	xx = BUNsize(b);
	zz = BUNsize(c);
	delFirst = BUNfirst(u);	

	delt 	 = BUNtloc(u, delFirst + startPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode = findNodeL_@1(*(@1*)delt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;
	if (lowNode != NULL)
		prevPos = *(lng*)BUNhloc(c,(idxFirst + (lowNode->position) * zz)) + 1;
	else 
		prevPos = 0;
	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = TreeIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);


		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + (lowNode->position) * zz;
                	lowVal = BUNtloc(c, low);

	                hgh    = idxFirst + (hghNode->position) * zz;
                	hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt+=xx;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + (hghNode->position) * zz;
       		        hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt+=xx;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + (lowNode->position) * zz;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);

			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));

			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);
			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);

				/* fill in the hols */
				pp = BUNsize(positions);
				pos = BUNhloc(positions, BUNfirst(positions));
				posLast = BUNhloc(positions, BUNlast(positions)-pp);
				crk = crkFirst + HposCr*xx;
				buns =  HposCr - LposCr;
				while(pos<=posLast){
					if (*(oid*)posLast != (size_t)buns){
						memcpy(crkFirst+(LposCr+(*(oid*)pos))*xx, crk, xx);
						pos+=pp;
					} else
						posLast-=pp;
					crk-=xx; buns--;
				}

				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;
		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns)
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+LposCr*xx, buns*xx);
			else
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+(LposCr+(buns-holSize))*xx, holSize*xx);
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;
		if (hghNode != NULL){
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *(lng*)hghPos+1;
			*(lng*)hghPos = *(lng*)hghPos - holSize - deletedFromCurrentPiece - holPiece;

		} else
			break;
	}

	crkLast = BUNlast(b) - (deletions-remainingDel)*xx + notFound*xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);
/*
printf("\n joinCost %lld \n", joinCost);
*/
@
	
@= mergeInsertionOperations
str
mergeInsertions_@1(int *bid, int *new, lng startPosition, bit deleteNodes){
		
	@:mergeInsertionsBody(@1,@2,@3,,1)@

	BBPunfix(c->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

str
mergeInsertionsGradually_@1(int *bid, int *new, lng startPosition, @1* hgh, bit inclusive, bit deleteNodes){

	lng endPosition;
		
	@:mergeInsertionsBody(@1,@2,@3, && (@2_LT(inst,hgh,@3@1) || (@2_EQ(inst,hgh,@3@1) && inclusive == TRUE)),1)@

	endPosition = startPosition + insDone + extendedIns;

	@:shrinkInsertions(@1)@

	BBPunfix(c->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

str
mergeInsertionsRipple_@1(int *bid, int *new, lng startPosition, @1* hgh, bit inclusive, bit deleteNodes){

	lng endPosition;

	@:mergeInsertionsBody(@1,@2,@3, && (@2_LT(inst,hgh,@3@1) || (@2_EQ(inst,hgh,@3@1) && inclusive == TRUE)), ((@2_LT(curValue,hgh,@3@1) || (@2_EQ(curValue,hgh,@3@1) && inclusive == TRUE && lowIndexNode->inclusive == TRUE)) || bats > 0))@

	endPosition = startPosition + insDone + extendedIns;

	if (lowIndexNode == NULL){
		@:shrinkInsertions(@1)@
	}

	if (lowIndexNode != NULL){
		/* we have to merge the scratch values back in the insertions bat */

		/* order first the temp bat */
		crkLast = BUNfirst(tempBATs->b) + tempBATs->values*xx;
		tempBATs->b->batBuns->free = crkLast - tempBATs->b->batBuns->base;
   		BATsetcount(tempBATs->b, tempBATs->b->batBuns->free/xx);
		
		tempBATs->b->tsorted = FALSE;		
		tempBATs->b->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(tempBATs->b)));
		
		/* merge */
		rscrh = BUNhloc(tempBATs->b, BUNfirst(tempBATs->b));
		rscrt = BUNtloc(tempBATs->b, BUNfirst(tempBATs->b));
		crkh  = BUNhloc(u,insFirst+startPosition*xx);
		crkt  = BUNtloc(u,insFirst+startPosition*xx);
		insh  = BUNhloc(u,insFirst+(endPosition)*xx);
		inst  = BUNtloc(u,insFirst+(endPosition)*xx);

		crkLast = BUNtloc(tempBATs->b,BUNlast(tempBATs->b));
		insLast = BUNtloc(u,BUNlast(u));

		while(rscrt < crkLast || inst < insLast){
			if (rscrt < crkLast && inst >= insLast){
				*(oid*)crkh = *(oid*)rscrh;
                                *( @1*)crkt = *( @1*)rscrt;
                                crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx;
			} else
			if (rscrt >= crkLast && inst < insLast){
				*(oid*)crkh = *(oid*)insh;
                                *( @1*)crkt = *( @1*)inst;
                                crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
			} else {
				if (@2_LE(rscrt,inst,@3@1)){	
					*(oid*)crkh = *(oid*)rscrh;
					*( @1*)crkt = *( @1*)rscrt;
					crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx;
				} else {
					*(oid*)crkh = *(oid*)insh;
					*( @1*)crkt = *( @1*)inst;
					crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
				}
			}
		}
/*
printf("\n -------Rippled %lld tuples \n", insDone+extendedIns);
*/
	}

	BBPunfix(c->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

crackers_export str CRKmergeInsertions_Force_@1(int *k, int *bid, int *new, bit *deleteNodes);
str
CRKmergeInsertions_Force_@1(int *k, int *bid, int *new, bit *deleteNodes){
	(void) k;
	return mergeInsertions_@1(bid, new, 0, *deleteNodes);
}

crackers_export str CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new);
str
CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new){
	BAT *c, *u;
	@1 min;
	BUN inst, insLast;
	int xx, position = -1;
	int i;

	(void) k;

	if ((u = BATdescriptor(*new)) == NULL)
		throw(MAL, "crackers.mergeInsertions_PartiallyForget_@1", "Cannot access insertions");

	if (BATcount(u) == 0)
		return MAL_SUCCEED;

	for (i = 0; i < maxCrackMap; i++)
        	if (TreeIndex[i].bid == *bid){
                	position = i;	
			break;
		}

	/*if (position == -1) return; Trying to erase an index that does not exist*/

	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL){
                BBPunfix(u->batCacheid);
                throw(MAL, "crackers.CRKmergeInsertions_PartiallyForget_@1", "Cannot access cracker index");
        }

	/* get the min value */
	xx = BUNsize(u);
	inst = BUNtloc(u,BUNfirst(u));
	insLast = BUNtloc(u,BUNlast(u));
	min = *(@1*)inst;
	for(inst+=xx;inst < insLast; inst+=xx)
		if (@2_GT(&min,inst,@3@1))
			min = *(@1*)inst;

	/* Partially delete tree with lazy deletion */
	PartiallyLazyFreeAVLTree_@1(TreeIndex[position].Tree, min, c, BUNfirst(c), BUNsize(c));

	appendCrackerBAT(bid,new);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

crackers_export str CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new);
str
CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new){
	lng startPosition = 0;
	lng endPosition   = -1;
	@1 *hgh;
	bit inclusive = TRUE;

	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	(void)k;
	next = BUNlast(b) - xx;
	hgh = (@1*)BUNtloc(b,next);
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

 	return MAL_SUCCEED;
}

str
mergeInsertionsB_@1(int *bid, int *new, lng startPosition, lng endPosition){
#ifdef DEBUG_CRACKERS_INSERTIONS	
lng TstartInsert, TendInsert;
#endif
	@1 *hgh;
	bit inclusive = TRUE;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

#ifdef DEBUG_CRACKERS_INSERTIONS
TstartInsert = GDKusec();
#endif
	next = BUNlast(b) - xx;
	hgh = (@1*)BUNtloc(b,next);
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);
	
#ifdef DEBUG_CRACKERS_INSERTIONS		
TendInsert = GDKusec();
printf("\n Inserted %lld values, costs Insert: %lld, Index search: %lld,  went through %d pieces and did %d movements \n", insertions, TendInsert - TstartInsert, TotalSearchAVL,  pieces, movements);
#endif	

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBGradually_@1(int *bid, int *new, lng startPosition, lng endPosition){
	/* First merge then shrink the insertions column */

#ifdef DEBUG_CRACKERS_INSERTIONS
        lng TstartInsert, TendInsert, TstartShrink, TendShrink;
#endif
	@1 *hgh;
	bit inclusive = TRUE;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - xx;
	hgh = (@1*)BUNtloc(b,next);
	
#ifdef DEBUG_CRACKERS_INSERTIONS
TstartInsert = GDKusec();
#endif
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);
	endPosition++;

#ifdef DEBUG_CRACKERS_INSERTIONS
TendInsert = GDKusec();
TstartShrink = GDKusec();
#endif
	@:shrinkInsertions(@1)@
#ifdef DEBUG_CRACKERS_INSERTIONS
TendShrink = GDKusec();
printf("\n Inserted %lld values, costs Insert: %lld, Shrink: %lld, Index search: %lld, went through %d pieces and did %d movements \n", insertions, TendInsert - TstartInsert, TendShrink - TstartShrink, TotalSearchAVL,  pieces, movements);
#endif

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBRipple_@1(int *bid, int *new, lng startPosition, lng endPosition, @1 *hgh, bit inclusive){
        BAT *ripple;
        BUN rh, rt, rnext, insLast;
	lng toRippleBuns;
	lng exceedBuns = 0;
	struct Node * NextNode;
	bit fromTheEnd = FALSE;
	int i;
	lng consumedRipple = 0, consumedInsertions = 0, values, usedHoles = 0;
	struct Node *rippleNode = NULL;

#ifdef DEBUG_CRACKERS_INSERTIONS
lng TstartRipple=0, TendRipple=0, TstartInsert=0, TendInsert=0, TstartMerge=0, TendMerge=0;
lng TstartM1=0,TstartM2=0,TstartM3=0,TendM1=0,TendM2=0,TendM3=0;
lng t1 = GDKusec();
lng t1I = GDKusec();
#endif

        @:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

#ifdef DEBUG_CRACKERS_INSERTIONS
lng t2I = GDKusec();
lng t1B = GDKusec();
#endif

	insLast = BUNtloc(u,BUNlast(u));	
	toRippleBuns = endPosition - startPosition +1;
	ripple = BATnew(TYPE_oid, TYPE_@1, toRippleBuns);
#ifdef DEBUG_CRACKERS_INSERTIONS
lng t2B = GDKusec();
TstartRipple = GDKusec();
#endif

/*
printf("\n start %lld end %lld \n", startPosition, endPosition);
BATprint(u);
*/
        /* Find out buns that should be rippled. Take this values out in a temporary BAT */

	/* first find the piece where the biggest insertions should be placed */
        if ( (NextNode = findNodeH_@1(*(@1*)hgh, inclusive, TreeIndex[position].Tree, c, idxFirst, zz, NULL)) != NULL ){

		prevNode = NextNode;
		cur     = idxFirst + (NextNode->position) * zz;
                curPos  = BUNhloc(c, cur);

		/* prevPos should not be changed! 
		   mergeInsertionsFromTheEndBodyII expects it to point in the position from where merging will start */
		prevPos = *(lng*)curPos;

		/* merging will start from this bun */		
		next = crkFirst + (*(lng*)curPos) * xx;

		/* use hols if any at the end of the result area */
		if (NextNode->hols > 0){
			rippleNode = NextNode;
			if (NextNode->hols >= insertions)
				goto rippled;
			else 
			if (NextNode->hols < insertions)
				toRippleBuns -= NextNode->hols; 
			
		}

		rh = BUNhloc(ripple, BUNfirst(ripple));
		rt = BUNtloc(ripple, BUNfirst(ripple));

                rnext   = crkFirst + (*(lng*)curPos) * xx + xx;

		NextNode->deleted = TRUE; /* TODO: consider not deleting this piece and instead extend it... */
		/*printf("\n have to delete piece %lld  \n", *(lng*)curPos);*/

                crkh = BUNhloc(b,rnext);
                crkt = BUNtloc(b,rnext);
		crkLast = BUNtloc(b,BUNlast(b));

		/* find out how many buns until we get into the next chunk. Variable buns holds this information*/ 
		if  ((NextNode =findNextPiece(NextNode)) == NULL)
			buns = values = BATcount(b) - prevPos - 1;
		else {
			cur    = idxFirst + (NextNode->position) * zz;
               		curPos = BUNhloc(c, cur);
                	rnext   = crkFirst + (*(lng*)curPos) * xx + xx;
                	buns   = (*(lng*)curPos) - prevPos;
			values = buns - NextNode->hols;
		}
/*
printf("\n prev %lld cur %lld \n", prevPos, *(lng*)curPos);
*/
		/* move values out. If we get into the next piece then we simply delete it */
		for (i=0; i<toRippleBuns; i++){
		
/*	
printf("\n i %d values %lld buns %lld \n", i, values, buns);
*/
			if (i == buns && crkt < crkLast){
				NextNode->deleted = TRUE;
				if  ((NextNode =findNextPiece(NextNode)) == NULL)
					buns = values = BATcount(b) - prevPos - 1;
				else {
					cur    = idxFirst + (NextNode->position)*zz;
               				curPos = BUNhloc(c, cur);
                			rnext  = crkFirst + (*(lng*)curPos)*xx + xx;
                			buns   = (*(lng*)curPos) - prevPos;
					values = buns - NextNode->hols;
				}
			}

			/* do not ripple if this is a hole */
			if (i< values){
				*(oid*)rh = *(oid*)crkh;
				*(@1 *)rt = *(@1 *)crkt;
				rh+=xx; rt+=xx; 
			} else { 
				if (NextNode!=NULL)
					NextNode->hols --;
				usedHoles++;
			}
			crkh+=xx; crkt+=xx;	

			/* we consumed all values until the end of the column. nothing more to ripple */
			if (crkt >= crkLast){
				i++;
				exceedBuns = toRippleBuns - i;
				break;
			}
		}
		if (i == buns && NextNode != NULL) {
			NextNode->deleted = TRUE;
			/*printf("\n have to delete piece %lld  \n", *(lng*)curPos);*/
		}
		ripple->batBuns->free = BUNfirst(ripple) + (i-usedHoles)*xx - ripple->batBuns->base;	
		BATsetcount(ripple, i-usedHoles);
	} else {
/*
printf("\n without ripple \n");
*/
		/* then we do not have to ripple. We simply start merging from the end of the cracker column */
		exceedBuns = toRippleBuns;
		next = BUNlast(b) - xx;
		/* prevPos has been correctly set in mergeInsertionsFromTheEndBodyI pointing at the last bun of the cracker column */
		fromTheEnd = TRUE;
	}
	rippled:;
#ifdef DEBUG_CRACKERS_INSERTIONS
TendRipple = GDKusec();
TstartInsert = GDKusec();
#endif

	if (fromTheEnd){
		@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	}
        @:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@
		
	if (exceedBuns > 0){
		crkLast = BUNlast(b) + exceedBuns * xx;
		b->batBuns->free = crkLast - b->batBuns->base;
       	 	BATsetcount(b, b->batBuns->free/xx);
        }

	if (rippleNode != NULL){
		if (rippleNode->hols > insertions)
			rippleNode->hols -= insertions;
		else
		if (rippleNode->hols <= insertions)
			rippleNode->hols = 0;
	}
	endPosition++;

#ifdef DEBUG_CRACKERS_INSERTIONS
TendInsert = GDKusec();
TstartMerge = GDKusec();
#endif

	/* now we have to merge the rippled values with the remaining insertions */
	if (BATcount(ripple) > 0){
		/* do not ripple values that are marked as pending deletions */
		if (TreeIndex[position].mergeDeletions > 0){
			BAT *deletes, *ripBAT;
			if (TreeIndex[position].did < 0) goto merge;			
			if ((deletes = BATdescriptor(TreeIndex[position].did)) == NULL)
		                return "Cannot access the deletions BAT";	
			if (BATcount(deletes)==0) {
				BBPunfix(deletes->batCacheid);
				goto merge;
			}
ripple->hsorted = FALSE;
ripple->tsorted = FALSE;
ripple->tdense = FALSE;
ripple->hdense = FALSE;
/*
printf("\n ripple \n");
BATprint(ripple);
*/
/* this is just to bypass a bug and shuold be removed from here */
deletes->hsorted = FALSE;
deletes->tsorted = FALSE;
deletes->tdense = FALSE;
deletes->hdense = FALSE;
/*
printf("\n deletes \n");
BATprint(deletes);
*/
			ripBAT = BATsintersect(ripple,deletes);

/*
printf("\n rippleBAT \n");
BATprint(ripBAT);
*/
			if (BATcount(ripBAT)>0){
				ripple = BATdel(ripple,ripBAT,TRUE);
				deletes = BATdel(deletes,ripBAT,TRUE);
/*				
printf("\n ripple: "SZFMT" \n", (size_t)ripple);
BATprint(ripple);
printf("\n deletesBAT \n");
BATprint(deletes);
*/
			} 

                      	BBPunfix(deletes->batCacheid);
                        BBPunfix(ripBAT->batCacheid);
		}
		merge:;
		if (BATcount(ripple)==0)
                        goto EmptyRipple;

		ripple->tsorted = FALSE;		
		ripple->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(ripple)));
		
		/* merge */
		rh    = BUNhloc(ripple, BUNfirst(ripple));
		rt    = BUNtloc(ripple, BUNfirst(ripple));
		crkh  = BUNhloc(u,insFirst+startPosition*xx);
		crkt  = BUNtloc(u,insFirst+startPosition*xx);
		insh  = BUNhloc(u,insFirst+endPosition*xx);
		inst  = BUNtloc(u,insFirst+endPosition*xx);

		crkLast = BUNtloc(ripple,BUNlast(ripple));

#ifdef DEBUG_CRACKERS_INSERTIONS
TstartM1 = GDKusec();	
#endif
		while(rt < crkLast && inst < insLast){
			if (@2_LE(rt,inst,@3@1)){	
				*(oid*)crkh = *(oid*)rh;
				*( @1*)crkt = *( @1*)rt;
				rh+=xx; rt+=xx; consumedRipple++;
			} else {
				*(oid*)crkh = *(oid*)insh;
				*( @1*)crkt = *( @1*)inst;
				insh+=xx; inst+=xx; consumedInsertions++;
			}
			crkh+=xx; crkt+=xx;
		}

#ifdef DEBUG_CRACKERS_INSERTIONS
TendM1 = GDKusec();	
#endif
		
		if (rt < crkLast && inst == insLast){
			int i;
#ifdef DEBUG_CRACKERS_INSERTIONS
TstartM2 = GDKusec();	
#endif
/*			rh    = BUNfirst(ripple)+consumedRipple*xx;
			insh  = insFirst+(startPosition+consumedRipple+consumedInsertions)*xx;
			memcpy(insh,rh,(BATcount(ripple)-consumedRipple)*xx);
*/
			for(i = 0; (size_t)i<BATcount(ripple)-(size_t)consumedRipple; i++){
				*(oid*)crkh = *(oid*)rh;
                                *( @1*)crkt = *( @1*)rt;
				 rh+=xx; rt+=xx;crkh+=xx; crkt+=xx;
			}

#ifdef DEBUG_CRACKERS_INSERTIONS
TendM2 = GDKusec();	
#endif

		} else	
		if (rt == crkLast && inst < insLast){
			int i;

#ifdef DEBUG_CRACKERS_INSERTIONS
TstartM3 = GDKusec();	
#endif

/*			rh    = insFirst+(endPosition+consumedInsertions)*xx;
			insh  = insFirst+(startPosition+consumedRipple+consumedInsertions)*xx;
			memcpy(insh,rh,(BATcount(u)-endPosition -consumedInsertions)*xx);
*/
			for(i = 0; (size_t)i<BATcount(u)-(size_t)endPosition -(size_t)consumedInsertions; i++){
                                *(oid*)crkh = *(oid*)insh;
                                *( @1*)crkt = *( @1*)inst;
                                 insh+=xx; inst+=xx;crkh+=xx; crkt+=xx;
                        }

#ifdef DEBUG_CRACKERS_INSERTIONS			
TendM3 = GDKusec();	
#endif

		}
		/* if some of the insertions went at the end of the cracker column, then the pending insertions has less values now */
		/*if (exceedBuns>0){
			crkLast = BUNlast(u) - exceedBuns*xx;*/
			crkLast = BUNlast(u) - (insertions - BATcount(ripple))*xx;
               	 	u->batBuns->free = crkLast - u->batBuns->base;
                	BATsetcount(u, u->batBuns->free/xx);
/*
printf("\n insertions became\n");
BATprint(u);
*/

#ifdef DEBUG_CRACKERS_INSERTIONS		
printf("\n Rippled "SZFMT" tuples  but extended the main bat for %lld \n", BATcount(ripple), exceedBuns);
#endif
		
	} else {
		EmptyRipple:;
		@:shrinkInsertions(@1)@
	}

#ifdef DEBUG_CRACKERS_INSERTIONS
TendMerge = GDKusec();
lng t1unf = GDKusec();
#endif

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);
	BBPunfix(ripple->batCacheid);

#ifdef DEBUG_CRACKERS_INSERTIONS
lng t2unf = GDKusec();
lng t2 = GDKusec();
printf("\n costs ripple: %lld, Insert: %lld, Merge: %lld, Index search: %lld,  went through %d pieces and did %d movements \n", TendRipple-TstartRipple, TendInsert-TstartInsert, TendMerge-TstartMerge, TotalSearchAVL, pieces, movements);
printf("\n  BAT new cost: %lld \n", t2B-t1B);
printf("\n initialization cost: %lld \n", t2I-t1I);
printf("\n unfix cost: %lld \n", t2unf-t1unf);
printf("\n merge costs: A: %lld, B: %lld, C: %lld \n", TendM1-TstartM1, TendM2-TstartM2, TendM3-TstartM3 );
printf("\n total cost: %lld \n", t2-t1);
#endif

        return MAL_SUCCEED;
}

str
mergeDeletions_@1(int *bid, int *del, lng startPosition, lng endPosition){

	@:mergeDeletionsBody(@1,@2,@3)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGradually_@1(int *bid, int *del, lng startPosition, lng endPosition){

        @:mergeDeletionsBody(@1,@2,@3)@

	@:shrinkDeletions(@1)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGraduallyRipple_@1(int *bid, int *del, lng startPosition, lng endPosition, @1 *lowV, bit inclusiveL, @1 *hghV, bit inclusiveH){
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN delt, idxFirst, crk, crkFirst, crkLast, delFirst, low, lowVal, hgh, hghPos=NULL, hghVal, pos, posLast;
	int xx, zz, pp, position = -1;
	lng deletions, remainingDel, buns;

	struct Node *lowNode, *hghNode, *temp, *stopNode;
	lng LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	lng holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;


	for (i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(TreeIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	if (endPosition == -1)
		endPosition = BATcount(u) - 1;

	deletions = endPosition - startPosition + 1;
/*
printf("\n deletes received: delete from %lld to %lld \n", startPosition, endPosition);
printCrackerDeletions(*bid);
*/
	remainingDel = deletions;
	xx = BUNsize(b);
	zz = BUNsize(c);
	delFirst = BUNfirst(u);	

	delt 	 = BUNtloc(u, delFirst + startPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode = findNodeL_@1(*lowV, inclusiveL, TreeIndex[position].Tree, c, idxFirst, zz, NULL); 
	stopNode = findNodeH_@1(*hghV, inclusiveH, TreeIndex[position].Tree, c, idxFirst, zz, NULL); 

	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;

	if (lowNode != NULL)
		prevPos = *(lng*)BUNhloc(c,(idxFirst + (lowNode->position) * zz)) + 1;
	else 
		prevPos = 0;

	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = TreeIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);
/*
if (hghNode!=NULL){
hgh    = idxFirst + (hghNode->position) * zz;
hghVal = BUNtloc(c, hgh);
hghPos = BUNhloc(c, hgh);
printf("\n Node position %lld \n", *(lng*)hghPos);
if (hghNode->deleted == FALSE)  printf("\n EXISTS \n");
else printf("\n deleted \n");
}		
else printf("\n Node NULL \n");
*/
		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + (lowNode->position) * zz;
                	lowVal = BUNtloc(c, low);

	                hgh    = idxFirst + (hghNode->position) * zz;
                	hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt+=xx;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + (hghNode->position) * zz;
       		        hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt+=xx;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + (lowNode->position) * zz;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
/*
printf("\n low %lld , hgh %lld, deletes here %lld \n", LposDe, HposDe, deletesForCurrentPiece);
*/
/*
u->hsorted=FALSE;
u->hdense=FALSE;
u->tsorted=FALSE;
u->tdense=FALSE;
*/
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);
/*
printf("\n deletes \n");
BATprint(deletesSlice);
printf("\n piece \n");
BATprint(crackerSlice);
*/
			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));
/*
printf("\n piece \n");
BATprint(crackerPieceO);
printf("\n deletesO \n");
BATprint(deletesPieceO);
printf("\n positionsO \n");
BATprint(positionsO);
printf("\n pieceV \n");
BATprint(crackerPieceV);
printf("\n deletesV \n");
BATprint(deletesPieceV);
printf("\n positionsV \n");
BATprint(positionsV);
printf("\n positions \n");
BATprint(positions);
*/
			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);

			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);


				/* fill in the hols */
				pp = BUNsize(positions);
				pos = BUNhloc(positions, BUNfirst(positions));
				posLast = BUNhloc(positions, BUNlast(positions)-pp);
				crk = crkFirst + HposCr*xx;
				buns =  HposCr - LposCr;
				
				while(pos<=posLast){
					if (*(oid*)posLast != (size_t)buns){
						memcpy(crkFirst+(LposCr+(*(oid*)pos))*xx, crk, xx);
						pos+=pp;
					} else 
						posLast-=pp;
					
	
					crk-=xx; buns--;
				}

				/* values requested to be deleted may not exist */
				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;
		/* no need to to shift if nothing has been deleted from previous pieces */
/*
printf("\n deletions %lld, remaining %lld, deletedhere %lld, buns %lld \n", deletions, remainingDel, deletedFromCurrentPiece, buns);
*/
		if (holSize > 0 && buns > 0){
			if (holSize >= buns)
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+LposCr*xx, buns*xx);
			else
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+(LposCr+(buns-holSize))*xx, holSize*xx);
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;

		/* stop the ripple once at the end of the last piece */
		if (hghNode != NULL){
			if (hghNode == stopNode)
				break;
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *(lng*)hghPos+1;
			*(lng*)hghPos = *(lng*)hghPos - holSize - deletedFromCurrentPiece - holPiece;
		} else
			break;
	}
/*
printf("\n deletions %lld , remaining %lld, notFound %lld \n", deletions, remainingDel, notFound);
*/
	if (hghNode == NULL){
		crkLast = BUNlast(b) - (deletions -remainingDel)*xx + notFound*xx;
		b->batBuns->free = crkLast - b->batBuns->base;
	        BATsetcount(b, b->batBuns->free/xx);
	} else
		hghNode->hols = deletions-remainingDel - notFound;
	
	 @:shrinkDeletions(@1)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);
        return MAL_SUCCEED;
}

@

@c
@:mergeInsertionOperations(chr,simple,)@
@:mergeInsertionOperations(sht,simple,)@
@:mergeInsertionOperations(int,simple,)@
@:mergeInsertionOperations(lng,simple,)@
@:mergeInsertionOperations(flt,simple,)@
@:mergeInsertionOperations(dbl,simple,)@
@:mergeInsertionOperations(date,atom,TYPE_)@

str
CRKextendCrackerBAT(int *k, int *bid, lng positions){
	BAT *b;
	int position = existsTreeIndex(*bid);

	(void) k;

	if (position == -1)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot find cracker index");
	if ((b = BATdescriptor(TreeIndex[position].cbid)) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot access cracker BAT");

	if (BATextend(b, positions) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Failed to extend the cracker BAT");	
	
	BBPunfix(b->batCacheid);

	return MAL_SUCCEED;
}

str
appendInsertions(int *new, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*new)) == NULL)
      		 throw(MAL, "crackers.appendInsertions", "Cannot access insertions BAT");
	if (TreeIndex[position].iid < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		TreeIndex[position].iid = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(TreeIndex[position].iid)) == NULL)
      		 	throw(MAL, "crackers.appendInsertions", "Cannot access cracker insertions BAT");
		
		c = BATins(c, u,TRUE);
/*
		if (BATextend(c, BATcount(u)) == NULL)
                	return throwMessage("crackers.appendInsertions", "Failed to extend the pending insertions BAT");
		
		memcpy(BUNlast(c),BUNfirst(u),BATcount(u)*BUNsize(u));

        	c->batBuns->free = (BUNlast(c) + BATcount(u)*BUNsize(u)) - c->batBuns->base;
        	BATsetcount(c, c->batBuns->free/BUNsize(c));
		c->tsorted = FALSE;
*/		
		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}

str
appendDeletions(int *del, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*del)) == NULL)
      		 throw(MAL, "crackers.appendDeletions", "Cannot access deletions BAT");
	if (TreeIndex[position].did < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		TreeIndex[position].did = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(TreeIndex[position].did)) == NULL)
      		 	throw(MAL, "crackers.appendDeletions", "Cannot access cracker deletions BAT");
		
		c = BATins(c,u, TRUE);
/*
		if (BATextend(c, BATcount(u)) == NULL)
                        return throwMessage("crackers.appendInsertions", "Failed to extend the pending insertions BAT");

                memcpy(BUNlast(c),BUNfirst(u),BATcount(u)*BUNsize(u));

                c->batBuns->free = (BUNlast(c) + BATcount(u)*BUNsize(u)) - c->batBuns->base;
                BATsetcount(c, c->batBuns->free/BUNsize(c));
		c->tsorted = FALSE;
*/

		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}

str
CRKmergeInsertions_Forget(int *k, int *bid, int *new){
	(void) k;
	appendCrackerBAT(bid,new);
	removeTreeIndex(bid);

	return MAL_SUCCEED;
}


@= updatesOnNeed
str
CRKmergeInsertionsB_OnNeed@1(int *k, int *bid, int *new){
	int position = existsTreeIndex(*bid);

        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertionsB_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	TreeIndex[position].mergeInsertions = @2;
	TreeIndex[position].deleteNodes = FALSE;	
	TreeIndex[position].mergeFromTheEnd = TRUE;

        return MAL_SUCCEED;
}

str
CRKmergeInsertions_OnNeed@1(int *k, int *bid, int *new, bit *deleteNodes){
	int position = existsTreeIndex(*bid);

        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertions_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	TreeIndex[position].mergeInsertions = @2;
	TreeIndex[position].deleteNodes = *deleteNodes;	
	TreeIndex[position].mergeFromTheEnd = FALSE;

        return MAL_SUCCEED;
}

str
CRKmergeDeletions_OnNeed@1(int *k, int *bid, int *del){
	int position = existsTreeIndex(*bid);

        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeDeletions_OnNeed@1", "Cannot find cracker index");

	appendDeletions(del,position);
	TreeIndex[position].mergeDeletions = @2;

        return MAL_SUCCEED;
}
@

@c
@:updatesOnNeed(,0)@
@:updatesOnNeed(Gradually,1)@
@:updatesOnNeed(GraduallyRipple,2)@

@= SyncOperation

str
Sync_@1_@2(int m, int h){
	BAT *h1,*h2,*b, *c;
	BUN h1head,h1tail,h2head,h2tail,idxFirst;
	int h1size, h2size, xx, zz;
	lng syncs;
	lng size;

        lng vl=-1, vh=-1;
        lng cl1, ch1, cl2, ch2;
        int _vl;
        bit HBound, foundLow=0, foundHgh=0;
        int gapL = 1;
        int gapH = 1;
	bit *inclusiveHgh,*inclusiveLow;
	@1 *low, *hgh;

        if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

	 /* Take the index of the bat */
        if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");


        if ((h1 = BATdescriptor(TreeIndex[h].chid)) == NULL) {
                throw(MAL, "crackers.sync", "Cannot access descriptor");
        }

        if ((h2 = BATdescriptor(TreeIndex[h].hiid)) == NULL) {
                throw(MAL, "crackers.sync", "Cannot access descriptor");
        }

	/* check if the current pair is already synced*/	
	size = BATcount(h1);
	if (TreeIndex[m].nextCrack == size)
		goto done;

	syncs = size - TreeIndex[m].nextCrack;
	h1size = BUNsize(h1);
	h2size = BUNsize(h2);

	h1head = BUNhloc(h1, BUNfirst(h1)+h1size*TreeIndex[m].nextCrack);
	h1tail = BUNtloc(h1, BUNfirst(h1)+h1size*TreeIndex[m].nextCrack);
	h2head = BUNhloc(h2, BUNfirst(h2)+h2size*TreeIndex[m].nextCrack);
	h2tail = BUNtloc(h2, BUNfirst(h2)+h2size*TreeIndex[m].nextCrack);
        zz = BUNsize(c);
        xx = BUNsize(b);
        idxFirst = BUNfirst(c);

	if (TreeIndex[m].nextCrack == 0){
		low = (@1*)h1head;
                hgh = (@1*)h1tail;
                inclusiveLow = (bit*)h2head;
                inclusiveHgh = (bit*)h2tail;
                if (*inclusiveHgh == TRUE) HBound = FALSE;
                else HBound = TRUE;

		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
			lng posl = BUNindex(b,BUNfirst(b));
        	        lng posh = BUNindex(b,BUNlast(b)-BUNsize(b));
	
                	@:crkThreeTreeProjections(@1,@2,posl,posh)@

		}

		h1head += h1size;
                h1tail += h1size; 
                h2head += h2size;
                h2tail += h2size;

	}	

	for (lng j=0; j<syncs; j++){
		low = (@1*)h1head; 
		hgh = (@1*)h1tail; 
		inclusiveLow = (bit*)h2head; 
		inclusiveHgh = (bit*)h2tail; 
		if (*inclusiveHgh == TRUE) HBound = FALSE;
		else HBound = TRUE;

		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
        
       		 	/* find out where in the index the low   falls */
               	 	foundLow = GetLow_@1(*low, *inclusiveLow, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
        
        		/* find out where in the index the high falls */        
			foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
                
			/*need to increase one position for the low bound only since we always store the previous position in the index*/
        		if (cl1 != 0) cl1++;
        		if (cl2 != 0) cl2++;
        
       			 /* If one or both of the result view bounds were not found using the
        		index then we have to crack */
        		if (foundLow == 0 || foundHgh == 0){
                		if (foundLow == 0 && foundHgh == 0){                         
					/* If ch2 is right after cl1 in the index then we split this piece in three pieces*/   
                        		if (cl1 == cl2){
                                		@:crkThreeTreeProjections(@1,@2,cl1,ch2)@
                        		} else {
                                		/* Else we have to do two cracks separatelly */
                                
                                		/* For the cl bound and the next one in the index*/
                                		@:crkTwoLTreeProjections(@1,@2)@
                                
                                		/* For the ch bound and the previous one in the index*/
                                		@:crkTwoRTreeProjections(@1,@2)@
                                
						if (vl>0) _vl=vl-1; 
						else      _vl=vl;
                                        	if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);                                
                                        	if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
                        		}
                		} else
                		if (foundLow == 0){
                        		@:crkTwoLTreeProjections(@1,@2)@
                                	if (vl>0) _vl=vl-1; else _vl=vl;
					if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);
                        		vh = ch2;
                		} else
                		if (foundHgh == 0){
                        		@:crkTwoRTreeProjections(@1,@2)@
                                	if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
                       		 	vl = cl1;
                		}
        		} else {
                		vl = cl1;
                		vh = ch2;
        		}
		}	

/* TODO fill in the rest of the cases */
/*		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && ((@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
		}
		if ( ((@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
		}
*/	
		h1head += h1size;
		h1tail += h1size;
		h2head += h2size;
		h2tail += h2size;
	}		
	
	TreeIndex[m].nextCrack = size;

	done:;
	BBPunfix(h1->batCacheid);
	BBPunfix(h2->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(c->batCacheid);
	return MAL_SUCCEED;
}
@

@= AddHistoryOperations
int
CreateHistoryBats_@1(int bid)
{
	BAT *h1,*h2;
	lng history_size= 200000;

	h1 = BATnew(TYPE_@1,TYPE_@1,history_size);		
	h2 = BATnew(TYPE_bit,TYPE_bit,history_size);		

	h1->batBuns->free =  BUNfirst(h1) - h1->batBuns->base;
        BATsetcount(h1, 0);
	h2->batBuns->free =  BUNfirst(h2) - h2->batBuns->base;
        BATsetcount(h2, 0);

	BBPkeepref(h1->batCacheid);
	BBPkeepref(h2->batCacheid);

	return newTreeIndexHistoryProjections_@1(bid, h1->batCacheid, h2->batCacheid);				
}
str
AddHistory_@1(int h, @1 low, @1 hgh, bit li, bit hi)
{
	BAT *h1,*h2;
	lng size;	

	if ((h1 = BATdescriptor(TreeIndex[h].chid)) == NULL) {
                throw(MAL, "crackers.sync", "Cannot access descriptor");
        }                                       
                                                
        if ((h2 = BATdescriptor(TreeIndex[h].hiid)) == NULL) {
                throw(MAL, "crackers.sync", "Cannot access descriptor");
        }                                       
                                                

        size = BATcount(h1);

        *(@1*)BUNhloc(h1, BUNlast(h1)) = low;
        *(@1*)BUNtloc(h1, BUNlast(h1)) = hgh;
        *(bit*)BUNhloc(h2, BUNlast(h2)) = li;
        *(bit*)BUNtloc(h2, BUNlast(h2)) = hi;

	h1->batBuns->free =  (BUNlast(h1)+BUNsize(h1)) - h1->batBuns->base;
        BATsetcount(h1, size+1);
	h2->batBuns->free =  (BUNlast(h2)+BUNsize(h2)) - h2->batBuns->base;
        BATsetcount(h2, size+1);
	
	BBPunfix(h1->batCacheid);
        BBPunfix(h2->batCacheid);
        return MAL_SUCCEED;

}
@

@c
@:SyncOperation(int,chr,simple,)@
@:SyncOperation(int,sht,simple,)@
@:SyncOperation(int,int,simple,)@
@:SyncOperation(int,lng,simple,)@
@:SyncOperation(int,flt,simple,)@
@:SyncOperation(int,dbl,simple,)@
@:SyncOperation(int,date,simple,)@
@:SyncOperation(date,chr,atom,TYPE_)@
@:SyncOperation(date,sht,atom,TYPE_)@
@:SyncOperation(date,int,atom,TYPE_)@
@:SyncOperation(date,lng,atom,TYPE_)@
@:SyncOperation(date,flt,atom,TYPE_)@
@:SyncOperation(date,dbl,atom,TYPE_)@
@:SyncOperation(date,date,atom,TYPE_)@

@:AddHistoryOperations(chr)@
@:AddHistoryOperations(sht)@
@:AddHistoryOperations(int)@
@:AddHistoryOperations(lng)@
@:AddHistoryOperations(flt)@
@:AddHistoryOperations(dbl)@
@:AddHistoryOperations(date)@

@= verifyIndex
str
verifyCrackerIndex_@1(int *bid){
        BAT *c, *b;
	int position = -1;
	BUN crkt, idxh, idxt, idxFirst, crkFirst, crkLast, bnd, cur;
	int xx, zz;
	struct Node * hghIndexNode;
	bit prevIncl;
	@1 prevVal;
	int tuples=0, indexEntries=0;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == *bid){
                        position = i;
			break;	
		}

	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL)
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	if ((b = BATdescriptor(TreeIndex[position].cbid)) == NULL){
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	
	xx = BUNsize(b);
	zz = BUNsize(c);
	
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	crkLast  = BUNtloc(b, BUNlast(b));
	crkt     = BUNtloc(b, BUNfirst(b));

	hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
	if (hghIndexNode == NULL){
		BBPunfix(c->batCacheid);
        	BBPunfix(b->batCacheid);
        	return MAL_SUCCEED;
	}

	indexEntries++;
	cur = idxFirst + ((hghIndexNode->position) * zz);
	idxh = BUNhloc(c, cur);
	idxt = BUNtloc(c, cur);
	bnd  = BUNtloc(b, crkFirst + (*(lng*)idxh - hghIndexNode->hols) * xx);

	if (crkt > bnd)
		printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n reader pointer is beyond index...", tuples, indexEntries);
	while(crkt <= bnd){

		if (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)){
			crkt+=xx;
			tuples++;
		} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
			BBPunfix(c->batCacheid);
			BBPunfix(b->batCacheid);
			return MAL_SUCCEED;
		}
	}
	crkt+=hghIndexNode->hols * xx;

	prevVal  = *(@1*)idxt;
	prevIncl = hghIndexNode->inclusive;

	while (crkt < crkLast){
		if ((hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL)) == NULL)
			break;
		indexEntries++;
		cur = idxFirst + ((hghIndexNode->position) * zz);
		idxh = BUNhloc(c, cur);
		idxt = BUNtloc(c, cur);
		bnd  = BUNtloc(b, crkFirst + (*(lng*)idxh - hghIndexNode->hols) * xx);

		if (crkt > bnd){
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n reader pointer is beyond index...", tuples, indexEntries);
				BBPunfix(c->batCacheid);
				BBPunfix(b->batCacheid);
				return MAL_SUCCEED;
		}
		while(crkt <= bnd){

			if ( (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)) &&
			     (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)) ){
				crkt+=xx;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
				BBPunfix(c->batCacheid);
				BBPunfix(b->batCacheid);
				return MAL_SUCCEED;
			}
		}
		crkt+=hghIndexNode->hols * xx;
		prevVal  = *(@1*)idxt;
		prevIncl = hghIndexNode->inclusive;
	}
	
	if (hghIndexNode == NULL){
		while(crkt < crkLast){
                        if (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)){
                                crkt+=xx;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
                                BBPunfix(c->batCacheid);
                                BBPunfix(b->batCacheid);
                                return MAL_SUCCEED;
                        }
		}
	}
	
	BBPunfix(c->batCacheid);
        BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

crackers_export str CRKverifyCrackerIndex_@1(int *k, int *bid);
str
CRKverifyCrackerIndex_@1(int *k, int *bid){
	(void) k;		
	return verifyCrackerIndex_@1(bid);
}
@
@c

@:verifyIndex(chr,simple,)@
@:verifyIndex(sht,simple,)@
@:verifyIndex(int,simple,)@
@:verifyIndex(lng,simple,)@
@:verifyIndex(flt,simple,)@
@:verifyIndex(dbl,simple,)@
@:verifyIndex(date,atom,TYPE_)@

@-
This function takes a range and returns a view with the result. To do that, we first search the index to determine which parts of the result we already
know and which parts we have to crack. Then we crack, if necessary,
the appropriate pieces, update the index and return the result.

@= crkTwoRTreeProjections
        /*CRACK in two pieces cl2-ch2 using <incHgh bound*/
        if (*inclusiveHgh == TRUE)
                CRKcrackUnorderedZeroProjections_LE_@1_@2(b,*hgh, cl2, ch2,&vh);
        else
                CRKcrackUnorderedZeroProjections_RE_@1_@2(b,*hgh, cl2, ch2,&vh);

        /*check for gaps*/
        if (vh < cl2)
                /*then the left piece is empty*/
                gapH = -1;
        if (vh > ch2){
                /*then the right piece is empty*/
                gapH = -1;
                vh--;
        }


@= crkTwoLTreeProjections
        /*CRACK in two pieces cl1-ch1 using >incLow bound*/
        if (*inclusiveLow == TRUE)
                CRKcrackUnorderedZeroProjections_RE_@1_@2(b,*low, cl1, ch1,&vl);
        else
                CRKcrackUnorderedZeroProjections_LE_@1_@2(b,*low, cl1, ch1,&vl);
        if (vl < cl1){
                /*then the left piece is empty*/
                gapL = -1;
        }
        if (vl > ch1){
                /*then the right piece is empty*/
                vl--;
                gapL = -1;
        }
        vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
                Instead we want the first bun of the right piece*/

@= crkThreeTreeProjections
        if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeProjections_LE_RE_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeProjections_LE_RO_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeProjections_LO_RE_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeProjections_LO_RO_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);

        if (vl != -1 && vh != -1){
                if (vl>0) _vl=vl-1; else _vl=vl;
                addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);
                addTreeIndex_@1(m,hgh,HBound,vh,c);
        }


@= crkThreeTree
/*printf("crack in three pieces\n");*/
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LE_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LE_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LO_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LO_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
				
	if (vl != -1 && vh != -1){
		if (vl>0) _vl=vl-1; else _vl=vl;		
		addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);
		addTreeIndex_@1(m,hgh,HBound,vh,c);
	}

@= crkThree
/*printf("crack in three pieces\n");*/
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE){
		CRKcrackUnorderedThree_LE_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = -(vl-1); i2 = vh;
	}
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE){
		CRKcrackUnorderedThree_LE_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = -(vl-1); i2 = -vh;
	}
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE){
		CRKcrackUnorderedThree_LO_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = vl-1; i2 = vh;
	}
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE){
		CRKcrackUnorderedThree_LO_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = vl-1; i2 = -vh;
	}
				
	if (vl == -1){ /*middle and right pieces are empty*/
		if (*inclusiveLow == TRUE) i1 = -@3;
		else i1 = @3;
		addOne_@1(m,low,i1,posA);
	}else
	if (vh == -1){ /*left and middle pieces are empty*/
		if (*inclusiveHgh == TRUE) i2 = @2;
		else i2 = -@2;
		addOne_@1(m,hgh,i2,posB);
	}else
		/*The following adds also gaps in the index in the cases where epmty piece
		is the right, the left or the middle. In the latter case vl is always vh+1
		and the index we want for both is vh*/
		addTwo_@1(m,low,i1,posA,hgh,i2,posB);

@= crkTwoL
/*printf("crack in two pieces\n");*/
	h1 = l + xx;
	if (h1 == BUNlast(c)){
		h1 = BUNlast(b) - BUNsize(b);
		ch1 = BUNindex (b, h1);	
	}
	else{
		ch1 = *(lng*)BUNhloc(c, h1);
		if (ch1 < 0) ch1 = ch1 - 2*ch1;
	}
	@:twoL(@1)@

@= crkTwoLFirst
	h1 = BUNlast(b) - BUNsize(b);
	ch1 = BUNindex (b, h1);	
	@:twoL(@1)@

@= twoL
	/*CRACK in two pieces cl-ch1 using >incLow bound*/
	if (*inclusiveLow == TRUE) {
		CRKcrackUnorderedZero_RE_@1(b,*low, cl, ch1,&vl);
		i1 = - vl;
	}
	else {
		CRKcrackUnorderedZero_LE_@1(b,*low, cl, ch1,&vl);
		i1 = vl;
	}
	if (vl < cl){
		/*then the left piece is empty*/
		if (*inclusiveLow == TRUE) i1 = -cl;
		else i1 = cl;
	}
	if (vl > ch1){
		/*then the right piece is empty*/
		vl--;
		if (*inclusiveLow == TRUE) i1 = -ch1;
		else i1 = ch1;
	}

	vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
		Instead we want the first bun of the right piece*/

@= crkTwoLTree
	/*CRACK in two pieces cl1-ch1 using >incLow bound*/
	if (*inclusiveLow == TRUE)
		CRKcrackUnorderedZero_RE_@1(b,*low, cl1, ch1,&vl);
	else
		CRKcrackUnorderedZero_LE_@1(b,*low, cl1, ch1,&vl);
	if (vl < cl1){
		/*then the left piece is empty*/
		gapL = -1;
	}
	if (vl > ch1){
		/*then the right piece is empty*/
		vl--;
		gapL = -1;
	}
	vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
		Instead we want the first bun of the right piece*/

@= crkTwoR
	if (h == BUNfirst(c))
		cl2 = BUNindex(b,  BUNfirst(b));	
	else{
		cl2 = *(lng*)BUNhloc(c, h-xx);
	        if (cl2 < 0) cl2 = cl2 - 2*cl2;
		cl2++;
	}
	@:twoR(@1)@

@= crkTwoRFirst
	cl2 = BUNindex(b,  BUNfirst(b));
	@:twoR(@1)@

@= twoR
/*printf("crack in two pieces\n");*/
	/*CRACK in two pieces cl2-ch using <incHgh bound*/
	if (*inclusiveHgh == TRUE){
		CRKcrackUnorderedZero_LE_@1(b,*hgh, cl2, ch,&vh);
		i2 = vh;
	}
	else{
		CRKcrackUnorderedZero_RE_@1(b,*hgh, cl2, ch,&vh);
		i2 = -vh;
	}

	/*check for gaps*/
	if (vh < cl2){
		/*then the left piece is empty*/
		if (*inclusiveHgh == TRUE) i2 = cl2;
		else i2 = -cl2;
	}
	if (vh > ch){
		/*then the right piece is empty*/
		vh--;
		if (*inclusiveHgh == TRUE) i2 = ch;
		else i2 = -ch;
	}

@= crkTwoRTree
/*printf("crack in two pieces\n");*/
	/*CRACK in two pieces cl2-ch2 using <incHgh bound*/
	if (*inclusiveHgh == TRUE)
		CRKcrackUnorderedZero_LE_@1(b,*hgh, cl2, ch2,&vh);
	else
		CRKcrackUnorderedZero_RE_@1(b,*hgh, cl2, ch2,&vh);

	/*check for gaps*/
	if (vh < cl2)
		/*then the left piece is empty*/
		gapH = -1;
	if (vh > ch2){
		/*then the right piece is empty*/
		gapH = -1;
		vh--;
	}

@= searchForLow
	l = SORTfndfirst_@4(c,low);
	lt = BUNtloc(c, l);
	lh = BUNhloc(c, l);
	posA = l;	

	/* if all indices contain values smaller than low, crack the area
		between the last index and the last BUN of the cracked bat */
	if (l == BUNlast(c)){
		l -= xx; lt -= xx; lh -= xx;
		if  (*(lng*)lh > 0)
			cl = *(lng*)lh;
		else
			cl = *(lng*)lh - 2*(*(lng*)lh);
		cl++;
	} else
	if (@2_EQ(lt,low,@3@1)){
		/* The first two cases are when the low bound already
			exists in the index */
		if  (*(lng*)lh < 0 && *inclusiveLow == TRUE)
			vl = (*(lng*)lh - 2*(*(lng*)lh))+1;
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == FALSE)
			vl = *(lng*)lh+1;

		/* We want values that the previous index has;
		   special case when there is no previous index */
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == TRUE){
			if (l == BUNfirst(c)){
				l  -= xx;
				cl = BUNindex(b, BUNfirst(b));
			}else{
				l  -= xx; lh -= xx; lt -= xx;
				if  (*(lng*)lh > 0)
					cl = *(lng*)lh;
				else
					cl = *(lng*)lh - 2*(*(lng*)lh);
				cl++;
			}
		}else
		if  (*(lng*)lh < 0 && *inclusiveLow == FALSE){
		/*  This index contains values that we do not want (the equals to
			low) so we check the next one. If it is equal to low then
			this is an exact match, otherwise we have to crack.
			Also if this was the last index we have to crack anyway. */
			lt += xx;
			l  +=xx;
			if (@2_EQ(lt,low,@3@1) && l != BUNlast(c)){
				lh += xx;
				vl = *(lng*)lh+1;
			}else{
				lt -= xx;
				l  -= xx;
				cl = (*(lng*)lh - 2*(*(lng*)lh))+1;
			}
		}
	}else{
		/* No exact match was found so we have to crack. Take the
		   previous index because this one is higher than low.
		   If there is no previous index, crack the bat from the beginning. */
		if (l == BUNfirst(c)){
			l  -= xx; lh -= xx; lt -= xx;
			cl = BUNindex(b, BUNfirst(b));
		}else{
			l  -= xx; lh -= xx; lt -= xx;
			if  (*(lng*)lh > 0)
				cl = *(lng*)lh;
			else
				cl = *(lng*)lh - 2*(*(lng*)lh);
			cl++;
		}
	}	

@= searchForGapsLow
	/*check for empty pieces after l*/	
	lhnext = lh + xx;
	gf = 0;	
	while(1){
		
		if ( *(lng*)lhnext == cl ||
			( *(lng*)lhnext < 0 && *(lng*)lhnext - 2*(*(lng*)lhnext) == cl ) ){
			gf = 1;
			l += xx; lt += xx; lh += xx;
			lhnext += xx;
		}
		else break;
	}
	if (gf == 1){
		if (@2_GT(lt,hgh,@3@1)){
			vl =  1;
			vh = -1;
			goto createView;
		}
		else
		if (@2_EQ(lt,hgh,@3@1)){
			if  (*(lng*)lh < 0) vl = *(lng*)lh - 2*(*(lng*)lh);
			else vl = *(lng*)lh;
			vh =  vl;
			goto createView;
		}
		else{
			if  (*(lng*)lh < 0) vl = *(lng*)lh - 2*(*(lng*)lh);
			else vl = *(lng*)lh;
			cl = -1;
		}
	}

@= searchForHgh
	h = SORTfndfirst_@4(c,hgh);
	ht = BUNtloc(c, h);
	hh = BUNhloc(c, h);
	posB = h;	

	if (h == BUNlast(c))
		ch = BUNindex(b, BUNlast(b) - BUNsize(b));
	else
	if (@2_EQ(ht,hgh,@3@1)){
		/* The first two cases are when the low bound already exists in the index */
		if  (*(lng*)hh > 0 && *inclusiveHgh == TRUE)
			vh = *(lng*)hh;
		else if  (*(lng*)hh < 0 && *inclusiveHgh == FALSE)
			vh = *(lng*)hh - 2*(*(lng*)hh);

	/* We want values that the next index has; special case when there is no next index */
		else if  (*(lng*)hh < 0 && *inclusiveHgh == TRUE){
			ht += xx; h  += xx; hh += xx;
			if (h == BUNlast(c)){
				ch = BUNindex(b, BUNlast(b)-BUNsize(b)); /*todo this might be the same with current index*/
			}else if (@2_EQ(ht,hgh,@3@1))
				vh = *(lng*)hh;
			else {
				ch= *(lng*)hh;
				if (ch < 0) ch = *(lng*)hh - 2*(*(lng*)hh);
			}
		}
		/*  This index contains values that we do not want (the equals to hgh)
			so we have to crack up to this one. We know that there is no
			previous index that excludes only the values we do not want (the
			hghs) Also we cannot check for hgh-1 */
		else if  (*(lng*)hh > 0 && *inclusiveHgh == FALSE)
			ch = *(lng*)hh;
	}else{
		/* No exact match was found so we have to crack. */
		if  (*(lng*)hh > 0)
			ch = *(lng*)hh;
		else
			ch = *(lng*)hh - 2*(*(lng*)hh);
	}

@= searchForGapsHgh
	/*check for empty pieces before h*/	
	hhprev = hh - xx;
	gf = 0;	
	while(1){
		if ( *(lng*)hhprev == ch ||
			( *(lng*)hhprev < 0 && *(lng*)hhprev - 2*(*(lng*)hhprev) == ch ) ){
			gf = 1;
			h -= xx; ht -= xx; hh -= xx;
			hhprev -= xx;
		}
		else break;
	}
	if (gf == 1){
		if (@2_LT(ht,low,@3@1)){
			vl =  1;
			vh = -1;
			goto createView;
		}
		else
		if (@2_EQ(ht,low,@3@1)){
			if  (*(lng*)hh < 0) vl = *(lng*)hh - 2*(*(lng*)hh);
			else vl = *(lng*)hh;
			vh =  vl;
			goto createView;
		}
		else{
			if  (*(lng*)hh < 0) vh = *(lng*)hh - 2*(*(lng*)hh);
			else vh = *(lng*)hh;
			ch = -1;
		}
	}

@= CreateResult
createView:
/*	printf("vl: %lld, vh:%lld \n",vl,vh);*/
	view = BATslice(b, vl, vh+1);
/*
	BAT *cpy = BATcopy(b, b->htype, b->ttype, TRUE);
*/	
	if (!tail)
		view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
	
	*vid = view->batCacheid;
	BBPkeepref(*vid);


/*
	*vid = cpy->batCacheid;
	BBPunfix(view->batCacheid);
*/
	BBPunfix(b->batCacheid);
@

@= CreateResultProjections
createView:
        view = BATslice(b, vl, vh+1);

	if (tail)
                view = BATslice(BATmirror(VIEWhead_(BATmirror(b), BAT_READ)), vl, vh+1);
	else 
                view = BATslice(BATmirror(VIEWhead_(b, BAT_READ)), vl, vh+1);

        *vid = view->batCacheid;
        BBPkeepref(*vid);

        BBPunfix(b->batCacheid);
@

@= crackOperations
lng
shiftHoles_@1(struct Node *lowNode, struct Node *lowNodeNext, BAT *b, int xx, BAT *c, BUN idxFirst, int zz, @1 *hgh, bit *inclusiveHgh, int position){
	lng holSize = 0, LposCr = 0, HposCr = 0, holPiece = 0, buns;
	BUN hghPos = NULL, crkFirst;
	struct Node *hghNode, *stopNode;

	crkFirst = BUNfirst(b);
	stopNode = findNodeH_@1(*hgh, *inclusiveHgh, TreeIndex[position].Tree, c, idxFirst, zz, NULL);

	while (1){
		if (lowNode == NULL)
			hghNode = lowNodeNext;
		 else
			hghNode = findNextPiece(lowNode);
		
		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
       	 	        hghPos = BUNhloc(c, idxFirst + (hghNode->position) * xx);
      		        LposCr = *(lng*)BUNhloc(c, idxFirst + (lowNode->position) * xx) + holSize;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
       	 	        hghPos = BUNhloc(c, idxFirst + (hghNode->position) * xx);
			LposCr = 0;
       	 	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			LposCr = *(lng*)BUNhloc(c, idxFirst + (lowNode->position) * xx) + holSize;
       	                HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;
		buns = HposCr - LposCr;
		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns)
				memcpy(crkFirst+(LposCr-(holSize-1))*xx, crkFirst+(LposCr+1)*xx, buns*xx);
			else
				memcpy(crkFirst+(LposCr-(holSize-1))*xx, crkFirst+(LposCr+1+(buns-holSize))*xx, holSize*xx);
		}
		holSize += holPiece;
		if (hghNode != NULL){
			if (hghNode == stopNode)
				break;
			hghNode->hols = 0;
			lowNode = hghNode;
			*(lng*)hghPos = *(lng*)hghPos - holSize;
		} else
			break;
	}

	if (holSize > 0){
		if (hghNode == NULL){
			BUN crkLast = BUNlast(b) - (holSize)*xx;
			b->batBuns->free = crkLast - b->batBuns->base;
	       		BATsetcount(b, b->batBuns->free/xx);
		} else
	                hghNode->hols = holSize;
	}

	return holSize;
}

str
selectMergeDeletionsPart_@1(int *bid, @1 *low, bit *inclusiveLow, @1 *hgh, bit *inclusiveHgh, bit *rippledDeletions, int position){
	BAT *u;
	lng updates, updatesStart, updatesEnd;
	BUN l, lt, updLast;
	int xx;

	if (TreeIndex[position].did == -1) return NULL;
	if ((u = BATdescriptor(TreeIndex[position].did)) == NULL)
		return "Cannot access the deletions BAT";			

	if (TreeIndex[position].mergeInsertions > 0){
                        BAT *insertions, *intersect;
                        if (TreeIndex[position].iid < 0) goto findDeletes; 
                        if ((insertions = BATdescriptor(TreeIndex[position].iid)) == NULL)
                                goto findDeletes;
                        if (BATcount(insertions)==0) {
                                BBPunfix(insertions->batCacheid);
                                goto findDeletes;
                        }

/*
insertions->hsorted=FALSE;
insertions->hdense=FALSE;
insertions->tsorted=FALSE;
insertions->tdense=FALSE;
u->hsorted=FALSE;
u->hdense=FALSE;
u->tsorted=FALSE;
u->tdense=FALSE;
*/  
                      intersect = BATsintersect(insertions,u);

                        if (BATcount(intersect)>0){
                                insertions = BATdel(insertions,intersect,TRUE);
                                u = BATdel(u,intersect,TRUE);
                        }

                        BBPunfix(intersect->batCacheid);
                        BBPunfix(insertions->batCacheid);
        }

	findDeletes:;
	
	updates = BATcount(u);
	if (updates == 0){
		BBPunfix(u->batCacheid);
                return NULL; /* no qualifying values in the deletions */
        }
	xx = BUNsize(u);

	/* if necessary, sort in place the deletions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	/* binary search to find the position of the lowest requested value in the deletions*/
	l = SORTfndfirst_@4(u,low);
	lt = BUNtloc(u,l);
	updLast = BUNtloc(u, BUNlast(u));
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the deletions */
	}
	if (@2_EQ(lt,low,@3@1) && *inclusiveLow == FALSE){
		while (lt < updLast && @2_EQ(lt,low,@3@1))
			lt +=xx;
	} 			
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the deletions */
	}
	if ( @2_GT(lt,hgh,@3@1) || (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh==FALSE) ){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the deletions */ 	
	}
	updatesStart = BUNindex(u,lt);	
	
	/* binary search to find the position of the highest requested value in the deletions */
        l = SORTfndfirst_@4(u, hgh);
	lt = BUNtloc(u,l);
	if (lt < updLast){
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == TRUE){	
			while (lt < updLast && @2_EQ(lt,hgh,@3@1))
                         	lt +=xx;
			lt-=xx;
		} else
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == FALSE)
                        lt -=xx;
		else
		if ( @2_GT(lt,hgh,@3@1) )
                        lt -=xx;
	}

	if (lt == updLast) lt-=xx;
	updatesEnd = BUNindex(u,lt);

	BBPunfix(u->batCacheid);
		
	if (TreeIndex[position].mergeDeletions == 0){	
		/* merge completely */
		mergeDeletions_@1(bid, &TreeIndex[position].did, 0, updates-1);
		TreeIndex[position].mergeDeletions = -1 ;
		TreeIndex[position].did = -1;

	} else if (TreeIndex[position].mergeDeletions == 1)
		/* merge only the requested values */			
		mergeDeletionsGradually_@1(bid, &TreeIndex[position].did, updatesStart, updatesEnd);
			
	else if (TreeIndex[position].mergeDeletions == 2){
		/* merge only the requested values using the ripple strategy */
		mergeDeletionsGraduallyRipple_@1(bid, &TreeIndex[position].did, updatesStart, updatesEnd, low, *inclusiveLow, hgh, *inclusiveHgh);	
		*rippledDeletions = TRUE;
	}

	return NULL;
}

str
selectMergeInsertionsPart_@1(int *bid, @1 *low, bit *inclusiveLow, @1 *hgh, bit *inclusiveHgh, int position){
	BAT *u;
	lng updates, updatesStart, updatesEnd;
	BUN l, lt, updLast;
	int xx;
	 if (TreeIndex[position].iid == -1) return NULL;
	if ((u = BATdescriptor(TreeIndex[position].iid)) == NULL)
		return "Cannot access insertions BAT";			

	updates = BATcount(u);
	if (updates == 0){
        	BBPunfix(u->batCacheid);
                return NULL; /* no qualifying values in the insertions */
        }

	/* if necessary, sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	/* binary search to find the position of the lowest requested value in the insertions*/
	l = SORTfndfirst_@4(u,low);
	lt = BUNtloc(u,l);
	updLast = BUNtloc(u, BUNlast(u));
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	xx = BUNsize(u);
	if (@2_EQ(lt,low,@3@1) && *inclusiveLow == FALSE){
		while (lt < updLast && @2_EQ(lt,low,@3@1))
			lt +=xx;
	} 			
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	if ( @2_GT(lt,hgh,@3@1) || (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh==FALSE) ){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */ 	
	}
	updatesStart = BUNindex(u,lt);	
	
	/* binary search to find the position of the highest requested value in the insertions */
        l = SORTfndfirst_@4(u, hgh);
	lt = BUNtloc(u,l);
	if (lt < updLast){
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == TRUE){	
			while (lt < updLast && @2_EQ(lt,hgh,@3@1))
                            	lt +=xx;
			lt-=xx;
		} else
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == FALSE)
                        lt -=xx;
		else
		if ( @2_GT(lt,hgh,@3@1) )
                        lt -=xx;
	}

	if (lt == updLast) lt-=xx;
	updatesEnd = BUNindex(u,lt);

	BBPunfix(u->batCacheid);
	
	if (TreeIndex[position].mergeInsertions == 0){	
		/* merge completely */
		if (TreeIndex[position].mergeFromTheEnd == TRUE)
			mergeInsertionsB_@1(bid, &TreeIndex[position].iid, 0, updates-1);
		else
			mergeInsertions_@1(bid, &TreeIndex[position].iid, 0, TreeIndex[position].deleteNodes);
		TreeIndex[position].mergeInsertions = -1 ;
		TreeIndex[position].iid = -1;

	} else if (TreeIndex[position].mergeInsertions == 1){
		/* merge only the requested values */			
		if (TreeIndex[position].mergeFromTheEnd == TRUE)
			mergeInsertionsBGradually_@1(bid, &TreeIndex[position].iid, updatesStart, updatesEnd);
		else
			mergeInsertionsGradually_@1(bid, &TreeIndex[position].iid, updatesStart, hgh, *inclusiveHgh, TreeIndex[position].deleteNodes);	
		
	} else if (TreeIndex[position].mergeInsertions == 2){
		/* merge only the requested values using the ripple strategy */
		if (TreeIndex[position].mergeFromTheEnd == TRUE)
			mergeInsertionsBRipple_@1(bid, &TreeIndex[position].iid, updatesStart, updatesEnd, hgh, *inclusiveHgh);	
		else
			mergeInsertionsRipple_@1(bid, &TreeIndex[position].iid, updatesStart, hgh, *inclusiveHgh, TreeIndex[position].deleteNodes);	
       }

	return NULL;
}

str
CRKRangeTree_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail)
{
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1, posl, posh;
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl1, ch1, cl2, ch2;
	/* index values in the case we have to crack
		|cl1...........ch1|.....................|cl2.........ch2|
		if we have to crack only one piece, i.e., if our range falls
		in one piece only then we crack from cl to ch otherwise we use
		the other indices as it is shown */
	int xx, zz;
	int _vl;
	bit HBound, foundLow=0, foundHgh=0;
	int gapL = 1;
	int gapH = 1;
	bit rippledDeletions = FALSE;
	struct Node *lowNode=NULL, *hghNode=NULL, *lowNodeNext=NULL, *temp;
	BUN idxFirst;
	
	if (@2_GT(low,hgh,@3@1))
		throw(MAL, "crackers.crack", "illegal range");
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsTreeIndex(*bid);

	/* if this is the first time we select something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		/*BATkey(b,TRUE);*/
		BATkey(BATmirror(b),FALSE);
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newTreeIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack
		   anyway so crack in three pieces cl-ch */
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));

		/*printf(" %lld \n ",posh-posl);*/
		@:crkThreeTree(@1,posl,posh)@
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before)
		we search the index to find where our range falls after this
		search if we have a match on the low range vl will hold the
		index value, otherwise it will be -1. The same for hgh and vh
		if there is no match for low then cl will hold the index that
		from there on we have to crack. The same from hgh and ch
		Note that in the case of the low range  we always have to increment
		by one since we want the values that are after this index
		(because of the way the crack index is created).
		Also after the search l and h should point to the low and hgh indices
		(in the crack index) found either as a match or to crack.
		This is used later on to determine which pieces we have to crack*/

	/*Check if this bat was previously cracked but the map is not there anymore
		this may happen if we chose to forget the index because of updates, so now we
		have to create a new one and crack in three pieces anyway*/
	if (TreeIndex[m].reCreate == 1){

		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access cracker index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access cracker BAT");
	
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));

		/*printf(" %lld \n ",posh-posl);*/
		@:crkThreeTree(@1,posl,posh)@
		goto createView;
	}
	
	/* Take the index of the bat */
	if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(b);
	zz = BUNsize(c);
	idxFirst = BUNfirst(c);

	/* deal with pending deletions if any */
	if (TreeIndex[m].mergeDeletions >= 0){
		str msg = selectMergeDeletionsPart_@1(bid, low, inclusiveLow, hgh, inclusiveHgh, &rippledDeletions, m);
		if (msg != NULL)
			throw(MAL, "crackers.crackRange",msg);
/*
printf("\n after deletions \n");
printCrackerBAT(*bid);
printAVLTree(TreeIndex[m].Tree, c, idxFirst, xx);
verifyCrackerIndex_@1(bid);
*/
	}

	
	if (TreeIndex[m].mergeDeletions == 2 && rippledDeletions == FALSE){
		lowNode = findNodeL_@1(*low, *inclusiveLow, TreeIndex[m].Tree, c, idxFirst, zz, NULL);
                if (lowNode == NULL){
                        lowNodeNext = NULL;
                        temp = TreeIndex[m].Tree;
                        if (temp->deleted == FALSE)
                                lowNodeNext = temp;
                        while (temp->left != NULL){
                                temp = temp->left;
                                if (temp->deleted == FALSE)
                                        lowNodeNext = temp;
                        }
                } else
                        lowNodeNext = findNextPiece(lowNode);

		shiftHoles_@1(lowNode, lowNodeNext, b, xx, c, idxFirst, zz, hgh, inclusiveHgh, m);	
/*
printf("\n after shiftinted holes \n");
printCrackerBAT(*bid);
printAVLTree(TreeIndex[m].Tree, c, idxFirst, xx);

verifyCrackerIndex_@1(bid);
*/
	}

	/* deal with pending insertions if any */
	if (TreeIndex[m].mergeInsertions >= 0){
		str msg = selectMergeInsertionsPart_@1(bid, low, inclusiveLow, hgh, inclusiveHgh, m);
                if (msg != NULL)
                        throw(MAL, "crackers.crackRange",msg);
/*
printf("\n after insertions \n");
printCrackerBAT(*bid);
printAVLTree(TreeIndex[m].Tree, c, idxFirst, xx);
verifyCrackerIndex_@1(bid);
*/
	}

	/* find out where in the index the low	 falls */
	
	foundLow = GetLow_@1(*low, *inclusiveLow, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0) cl1++;
	if (cl2 != 0) cl2++;

	/* find the hols if any in the pieces to crack so that cracking does not touch deleted buns */
        if (TreeIndex[m].mergeDeletions == 2){
		lng holsLow = 0, holsHgh = 0;
		/* if not done before while shifting hols find lowNode and lowNodeNext */
		if (rippledDeletions == TRUE){
			lowNode = findNodeL_@1(*low, *inclusiveLow, TreeIndex[m].Tree, c, idxFirst, zz, NULL);
       	         	if (lowNode == NULL){
                        	lowNodeNext = NULL;
                   		temp = TreeIndex[m].Tree;
                        	if (temp->deleted == FALSE)
                                	lowNodeNext = temp;
                        	while (temp->left != NULL){
                                	temp = temp->left;
                                	if (temp->deleted == FALSE)
                                	        lowNodeNext = temp;
                        	}
                	} else
                        	lowNodeNext = findNextPiece(lowNode);
		}

		hghNode = findNodeH_@1(*hgh, *inclusiveHgh, TreeIndex[m].Tree, c, idxFirst, zz, NULL);
		if (lowNodeNext != NULL)
			holsLow = lowNodeNext->hols;

		if (hghNode != NULL)
			holsHgh = hghNode->hols;

		/* so if there are hols the positions where we crack are appropriately decreased */
		ch1 -= holsLow;
		ch2 -= holsHgh;
	}	


	/* If one or both of the result view bounds were not found using the
	index then we have to crack */
	if (foundLow == 0 || foundHgh == 0){
		if (foundLow == 0 && foundHgh == 0){
			/* If ch2 is right after cl1 in the index then we split this piece in three pieces*/
			if (cl1 == cl2){
				/*CRACK in three pieces cl1-ch2 */
				/*printf("crack %lld %lld %lld %lld",cl1,ch1,cl2,ch2);*/	
				/*printf(" %lld \n",ch2-cl1);*/
				@:crkThreeTree(@1,cl1,ch2)@

			} else {
				/* Else we have to do two cracks separatelly */
				/*printf("crack %lld %lld %lld %lld",cl1,ch1,cl2,ch2);*/	
	
				/* For the cl bound and the next one in the index*/
				@:crkTwoLTree(@1)@

				/* For the ch bound and the previous one in the index*/
				@:crkTwoRTree(@1)@

				/*printf(" %lld \n",(ch1-cl1)+(ch2-cl2));*/
				if (IndexSize <IndexStop){
					if (vl>0) _vl=vl-1; else _vl=vl;		
					if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);
					if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
				}
			}
		} else
		if (foundLow == 0){
			/*printf("crack %lld %lld",cl1, ch1);*/	
			@:crkTwoLTree(@1)@
			/*printf(" %lld \n",(ch1-cl1));*/
			if (IndexSize <IndexStop){
				if (vl>0) _vl=vl-1; else _vl=vl;		
				if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);
			}
			vh = ch2;
		} else
		if (foundHgh == 0){
			/*printf("crack %lld %lld",cl2,ch2);*/	
			@:crkTwoRTree(@1)@
			/*printf(" %lld \n",(ch2-cl2));*/
			if (IndexSize <IndexStop)
				if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
			vl = cl1;
		} 	
	} else {
		vl = cl1;
		vh = ch2;
	}

	@:CreateResult()@
	return MAL_SUCCEED;
}

str
CRKRangeLeftNilTree_@1(int *vid, int *bid, @1 *hgh, bit *inclusiveHgh, bit tail)
{
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1;
	lng cl2, ch2;
	int xx;
	bit HBound,foundHgh=0;
	int gapH = 1;
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsTreeIndex(*bid);

	/* if this is the first time we select something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newTreeIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		cl2 = BUNindex(b,BUNfirst(b));
		ch2 = BUNindex(b,BUNlast(b)-BUNsize(b));
		/*printf(" %lld \n ",ch2-cl2);*/
		@:crkTwoRTree(@1)@
		if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
		vl = BUNindex(b,BUNfirst(b));
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	if (TreeIndex[m].cid == -1){

		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");
	
		cl2 = BUNindex(b,BUNfirst(b));
		ch2 = BUNindex(b,BUNlast(b)-BUNsize(b));
		/*printf(" %lld \n ",ch2-cl2);*/
		@:crkTwoRTree(@1)@
		if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
		vl = BUNindex(b,BUNfirst(b));

		goto createView;
	}


	/* Take the index of the bat */
	if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	vl = BUNindex(b,BUNfirst(b));

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, HBound, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), xx, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl2 != 0) cl2++;
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
printf("\n  found Hgh=%d \n",foundHgh);
*/


	if (foundHgh == 0){
		/*printf("crack %lld %lld",cl2,ch2);*/	
		@:crkTwoRTree(@1)@
		/*printf(" %lld \n",(ch2-cl2));*/
		if (IndexSize <IndexStop)
			if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
	} 	
	else
		vh = ch2;
		
	@:CreateResult()@
	return MAL_SUCCEED;
}

str
CRKRangeRightNilTree_@1(int *vid, int *bid, @1 *low, bit *inclusiveLow, bit tail)
{
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1;
	lng cl1, ch1;
	int xx;
	bit foundLow=0;
	int gapL = 1;
	
	m = existsTreeIndex(*bid);

	/* if this is the first time we select something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newTreeIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		cl1 = BUNindex(b,BUNfirst(b));
		ch1 = BUNindex(b,BUNlast(b)-BUNsize(b));
		/*printf(" %lld \n ",ch1-cl1);*/
		@:crkTwoLTree(@1)@
		if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNindex(b,BUNlast(b)-BUNsize(b));
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	if (TreeIndex[m].cid == -1){

		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");
	
		cl1 = BUNindex(b,BUNfirst(b));
		ch1 = BUNindex(b,BUNlast(b)-BUNsize(b));
		/*printf(" %lld \n ",ch2-cl2);*/
		@:crkTwoLTree(@1)@
		if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNindex(b,BUNlast(b)-BUNsize(b));

		goto createView;
	}


	/* Take the index of the bat */
	if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	vh = BUNindex(b,BUNlast(b)-BUNsize(b));


	/* find out where in the index the low falls */
	foundLow = GetLow_@1(*low,*inclusiveLow, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), xx, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0) cl1++;
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
printf("\n  found Low=%d \n",foundLow);
*/


	if (foundLow == 0){
		/*printf("crack %lld %lld",cl1,ch1);*/	
		@:crkTwoLTree(@1)@
		/*printf(" %lld \n",(ch1-cl1));*/
		if (IndexSize <IndexStop)
			if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,vl,c);
	} 	
	else
		vl = cl1;
		
	@:CreateResult()@
	return MAL_SUCCEED;
}

str
CRKRange_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail)
{
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1, posl, posh;
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl=-1, ch1=-1, cl2=-1, ch=-1;
	/* index values in the case we have to crack
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls
		in one piece only then we crack from cl to ch otherwise we use
		the other indices as it is shown */
	lng i1=-1,i2=-1;
	BUN l,lt,ht;
	int xx;
	BUN h,lh,hh,h1, posA, posB;
	BUN lhnext, hhprev;
	bit gf;
	/*int firstCrack=0;
	BAT *n=NULL;
	*/
	if (@2_GT(low,hgh,@3@1))
		throw(MAL, "crackers.crack", "illegal range");

	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		/*firstCrack = 1;
		int resMmap,mode=STORE_MMAP;*/
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;
		BATsave(b);
		/*
		resMmap = BATmmap(b,mode,mode,mode);
	        printf("\n result--> %d",resMmap);
                printf("\ncopyM %d\n",b->batMapbuns);
                printf("\noriginalM %d\n",bo->batMapbuns);
                printf("\ncopy %d\n",b->batBuns->storage);
                printf("Original %d\n",bo->batBuns->storage);
		str name = BBPname(b->batCacheid);
		n = BATnew(TYPE_void,TYPE_str,1);
		BUNappend(n,name,FALSE);
		*/

		m = newIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack
		   anyway so crack in three pieces cl-ch */
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));
		posA = BUNfirst(c);
		posB = posA + BUNsize(c);
		
		@:crkThree(@1,posl,posh)@
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before)
		we search the index to find where our range falls after this
		search if we have a match on the low range vl will hold the
		index value, otherwise it will be -1. The same for hgh and vh
		if there is no match for low then cl will hold the index that
		from there on we have to crack. The same from hgh and ch
		Note that in the case of the low range  we always have to increment
		by one since we want the values that are after this index
		(because of the way the crack index is created).
		Also after the search l and h should point to the low and hgh indices
		(in the crack index) found either as a match or to crack.
		This is used later on to determine which pieces we have to crack*/

	/* Take the index of the bat */
	if ((c = BATdescriptor(Index[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(Index[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

       /* printf("\ncopy %d\n",b->batBuns->storage);
        printf("\ncopyM %d\n",b->batMapbuns);
	*/

	/* find out where in the index the low falls */
	@:searchForLow(@1,@2,@3,@4)@
	@:searchForGapsLow(@1,@2,@3)@

	/* find out where in the index the high falls */
	@:searchForHgh(@1,@2,@3,@4)@
	@:searchForGapsHgh(@1,@2,@3)@
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the
	index then we have to crack */
	if (vl == -1 || vh == -1){
		if (vl == -1 && vh == -1){
			/* If ch is right after cl in the index then we split this piece in three pieces*/
			if (h == l + xx){
				/*CRACK in three pieces cl-ch */
				@:crkThree(@1,cl,ch)@
			}else{
				/* Else we have to do two cracks separatelly */
				
				/* For the cl bound and the next one in the index*/
				@:crkTwoL(@1)@
				/* For the ch bound and the previous one in the index*/
				@:crkTwoR(@1)@
				if (IndexSize <IndexStop){		
					addTwo_@1(m,low,i1,posA,hgh,i2,posB);
				IndexSize+=2;}
			}
		}else
		if (vl == -1){
			@:crkTwoL(@1)@
			if (IndexSize <IndexStop){
				addOne_@1(m,low,i1,posA);
			IndexSize++;}
		}else
		if (vh == -1){
			@:crkTwoR(@1)@
			if (IndexSize <IndexStop){
				addOne_@1(m,hgh,i2,posB);
			IndexSize++;}
		} 	
	}
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	/*if (firstCrack == 1) TMsubcommit(n);*/
	return MAL_SUCCEED;
}

str
CRKRange_LeftNil_@1(int *vid, int *bid, @1 *hgh, bit *inclusiveHgh, bit tail)
{
	BAT *b, *c, *bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1;
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl2=-1, ch=-1;
	/* index values in the case we have to crack
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls
		in one piece only then we crack from cl to ch otherwise we use
		the other indices as it is shown */
	lng i2=-1;
	BUN ht;
	int xx;
	BUN h,hh,posB;

	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat,
	   we have to create the crack index for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;
		
		m = newIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack
		   anyway so crack in two pieces cl-ch */
		ch = BUNindex(b, BUNlast(b) - BUNsize(b));
		@:crkTwoRFirst(@1)@
		posB = BUNfirst(c);
		addOne_@1(m,hgh,i2,posB);

		vl = BUNindex(b,BUNfirst(b));
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before)
		we search the index to find where the high falls */

	if ((c = BATdescriptor(Index[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(Index[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	vl = BUNindex(b,BUNfirst(b));

	/* find out where in the index the high falls */
	@:searchForHgh(@1,@2,@3,@4)@
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the
	index then we have to crack */
	if (vh == -1){
		@:crkTwoR(@1)@
		addOne_@1(m,hgh,i2,posB);
	} 	
	
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}

str
CRKRange_RightNil_@1(int *vid, int *bid, @1 *low, bit *inclusiveLow, bit tail)
{
	BAT *b, *c, *bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1;
	/* vl and vh are the low and high index values to create the view with the result */
	lng ch1=-1, cl=-1;
	/* index values in the case we have to crack
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls
		in one piece only then we crack from cl to ch otherwise we use
		the other indices as it is shown */
	lng i1=-1;
	BUN lt;
	int xx;
	BUN l, lh, h1, posA;

	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat,
	   we have to create the crack index for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;
		
		m = newIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack
		   anyway so crack in two pieces cl-ch */
     	        cl = BUNindex(b,  BUNfirst(b));
		@:crkTwoLFirst(@1)@
		posA = BUNfirst(c);
		addOne_@1(m,low,i1,posA);

		vh = BUNindex(b,BUNlast(b)-BUNsize(b));
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before)
		we search the index to find where the high falls */

	if ((c = BATdescriptor(Index[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(Index[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	@:searchForLow(@1,@2,@3,@4)@

	/* find out where in the index the high falls */
	vh = BUNindex(b,BUNlast(b)-BUNsize(b));
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the
	index then we have to crack */
	if (vl == -1){
		@:crkTwoL(@1)@
		addOne_@1(m,low,i1,posA);
	} 	
	
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}

@

@= CreateCrackingPair
		BAT *bo, *bp;
                lng size;
                BUN ptail, ctail, nhead, ntail, nlast;
                int csize, psize, nsize;
                if ((bo = BATdescriptor(*bid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access descriptor");
                if ((bp = BATdescriptor(*pbid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access pdescriptor");

                size = BATcount(bo);
		b = BATnew(bo->ttype, bp->ttype, size);

                nsize = BUNsize(b);
                csize = BUNsize(bo);
                psize = BUNsize(bp);
                nhead = BUNhloc(b,  BUNfirst(b));
                ntail = BUNtloc(b,  BUNfirst(b));
                ctail = BUNtloc(bo, BUNfirst(bo));
                ptail = BUNtloc(bp, BUNfirst(bp));
                for(lng j=0;j<size;j++){
                        *(@1*)nhead = *(@1*)ctail;
                        *(@2*)ntail = *(@2*)ptail;
                        nhead+=nsize;
                        ntail+=nsize;
                        ctail+=csize;
                        ptail+=psize;
                }

                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;
                /*BATkey(b,TRUE);*/
                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);
	
		nlast = BUNfirst(b) + nsize*size;
        	b->batBuns->free =  nlast - b->batBuns->base;
        	BATsetcount(b, size);

                m = newTreeIndexProjections_@1(*bid, b->batCacheid, *pbid);

                bo->batRestricted= BAT_READ;
                BBPunfix(bo->batCacheid);
                BBPunfix(bp->batCacheid);
@

@= crackOperationsProjections
/* Projections tryout code */
str
CRKRangeProjections_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail)
{
        BAT *b,*c;
        BAT *view;
        int  m, h;
        lng vl=-1, vh=-1, posl, posh;
        /* vl and vh are the low and high index values to create the view with the result */
        lng cl1, ch1, cl2, ch2;
        /* index values in the case we have to crack
                |cl1...........ch1|.....................|cl2.........ch2|
                if we have to crack only one piece, i.e., if our range falls
                in one piece only then we crack from cl to ch otherwise we use
                the other indices as it is shown */
        int xx, zz;
        int _vl;
        bit HBound, foundLow=0, foundHgh=0;
        int gapL = 1;
        int gapH = 1;
        BUN idxFirst;


        if (@3_GT(low,hgh,@4@1))
                throw(MAL, "crackers.crack", "illegal range");

        if (*inclusiveHgh == TRUE) HBound = FALSE;
        else    HBound = TRUE;

        m = existsTreeIndexProjections(*bid, *pbid);
        h = existsTreeIndexProjections(*bid, -1);
	if (h == -1)
		h = CreateHistoryBats_@1(*bid); 


        /* if this is the first time we select something from this bat pair, then we have to create it */
        if (m == -1){
	/*	lng T1,T2;
		T1 = GDKusec();
        */

		@:CreateCrackingPair(@1,@2)@		

	/*      T2 = GDKusec();
		printf(" Time cost to create the cracking projection is: %lld \n", T2-T1);
        */
                if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access crack index");

                posl = BUNindex(b,BUNfirst(b));
                posh = BUNindex(b,BUNlast(b)-BUNsize(b));

                @:crkThreeTreeProjections(@1,@2,posl,posh)@

                BBPincref(b->batCacheid,TRUE);
		
		AddHistory_@1(h, *low, *hgh, *inclusiveLow, *inclusiveHgh );
		TreeIndex[m].nextCrack+=1;
                goto createView;
        }

	 /* If an index exists for this bat (so it has been cracked before)
                we search the index to find where our range falls after this
                search if we have a match on the low range vl will hold the
                index value, otherwise it will be -1. The same for hgh and vh
                if there is no match for low then cl will hold the index that
                from there on we have to crack. The same from hgh and ch
                Note that in the case of the low range  we always have to increment
                by one since we want the values that are after this index
                (because of the way the crack index is created).
                Also after the search l and h should point to the low and hgh indices
                (in the crack index) found either as a match or to crack.
                This is used later on to determine which pieces we have to crack*/
        
        /*Check if this bat was previously cracked but the map is not there anymore
                this may happen if we chose to forget the index because of updates, so now we          
                have to create a new one and crack in three pieces anyway*/

        if (TreeIndex[m].reCreate == 1){
                
                reCreateMap_@1(m);
                
                /* Take the index of the bat */
                if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)                        
			throw(MAL, "crackers.crackRange", "Cannot access cracker index");
                
                /* Take the copy of the bat for which we maintain the index */
                if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access cracker BAT");
                
                posl = BUNindex(b,BUNfirst(b));
                posh = BUNindex(b,BUNlast(b)-BUNsize(b));
                
                /*printf(" %lld \n ",posh-posl);*/
                @:crkThreeTreeProjections(@1,@2,posl,posh)@
                goto createView;
        }

	Sync_@1_@2(m,h);        
        
        /* Take the index of the bat */
        if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");
        
        /* Take the copy of the bat for which we maintain the index */
        if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(b);
        zz = BUNsize(c);
        idxFirst = BUNfirst(c);

        
        /* find out where in the index the low   falls */
                foundLow = GetLow_@1(*low, *inclusiveLow, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
        
        /* find out where in the index the high falls */        
		foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
                
	/*need to increase one position for the low bound only since we always store the previous position in the index*/
        if (cl1 != 0) cl1++;
        if (cl2 != 0) cl2++;
        
        /* If one or both of the result view bounds were not found using the
        index then we have to crack */
        if (foundLow == 0 || foundHgh == 0){
                if (foundLow == 0 && foundHgh == 0){                         
			/* If ch2 is right after cl1 in the index then we split this piece in three pieces*/   
                        if (cl1 == cl2){
                                @:crkThreeTreeProjections(@1,@2,cl1,ch2)@
                        } else {
                                /* Else we have to do two cracks separatelly */
                                
                                /* For the cl bound and the next one in the index*/
                                @:crkTwoLTreeProjections(@1,@2)@
                                
                                /* For the ch bound and the previous one in the index*/
                                @:crkTwoRTreeProjections(@1,@2)@
                                
                                if (IndexSize <IndexStop){                                        
					if (vl>0) 
						_vl=vl-1; 
					else 
						_vl=vl;
                                        if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);                                
                                        if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
                                }
                        }
                } else
                if (foundLow == 0){
                        @:crkTwoLTreeProjections(@1,@2)@
                        if (IndexSize <IndexStop){
                                if (vl>0) _vl=vl-1; else _vl=vl;
				if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);
                        }
                        vh = ch2;
                } else
                if (foundHgh == 0){
                        @:crkTwoRTreeProjections(@1,@2)@
                        if (IndexSize <IndexStop)
                                if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
                        vl = cl1;
                }
        } else {
                vl = cl1;
                vh = ch2;
        }

	AddHistory_@1(h, *low, *hgh, *inclusiveLow, *inclusiveHgh );
	TreeIndex[m].nextCrack+=1;
        @:CreateResultProjections()@
        return MAL_SUCCEED;
}

@

@= SelectFunctions
crackers_export str CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{		
	if (IndexType == 1){	
		if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, TRUE);
		else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, TRUE);
		else
			return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);
	} else {
		if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRange_LeftNil_@1(vid, bid, hgh, inclusiveHgh, TRUE);
		else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRange_RightNil_@1(vid, bid, low, inclusiveLow, TRUE);
		else
			return CRKRange_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);
	}

       	throw(MAL, "crackers.CRKselectBounds_@1", "case not handled");
}

crackers_export str CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{
	if (IndexType == 1){	
		if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, FALSE);
		else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, FALSE);
		else
			return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);
	} else {
		if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRange_LeftNil_@1(vid, bid, hgh, inclusiveHgh, FALSE);
		else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRange_RightNil_@1(vid, bid, low, inclusiveLow, FALSE);
		else
			return CRKRange_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);
	}

        throw(MAL, "crackers.CRKuselectBounds_@1", "case not handled");
}

crackers_export str CRKselectValue_@1(int *vid, int *bid, @1 *value);
str
CRKselectValue_@1(int *vid, int *bid, @1 *value)
{
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
}

crackers_export str CRKuselectValue_@1(int *vid, int *bid, @1 *value);
str
CRKuselectValue_@1(int *vid, int *bid, @1 *value)
{
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
}

crackers_export str CRKselect_@1(int *vid, int *bid, @1 *low, @1 *hgh);
str
CRKselect_@1(int *vid, int *bid, @1 *low, @1 *hgh)
{
	bit inclusive = TRUE;
	return CRKselectBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}

crackers_export str CRKuselect_@1(int *vid, int *bid, @1 *low, @1 *hgh);
str
CRKuselect_@1(int *vid, int *bid, @1 *low, @1 *hgh)
{
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}

@

@= SelectFunctionsProjections
crackers_export str CRKhselectBoundsProjections_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKhselectBoundsProjections_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKselectBoundsProjections_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKselectBoundsProjections_@1_@2", "case not handled");
	else
		return CRKRangeProjections_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);

        throw(MAL, "crackers.CRKselectBoundsProjections_@1_@2", "case not handled");
}
crackers_export str CRKtselectBoundsProjections_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKtselectBoundsProjections_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKselectBoundsProjections_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKselectBoundsProjections_@1_@2", "case not handled");
	else
		return CRKRangeProjections_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);

        throw(MAL, "crackers.CRKselectBoundsProjections_@1_@2", "case not handled");
}
@

@= JoinSelectBody
/*
Joins a left=[oid,void] bat with a right=[void, any_type] bat on head-OIDs.
From the right bat, only BUNs that pass the range-restriction on the tail qualify.
The result is a [oid,void] bat.
*/
	BAT *d;
	BUN rt, rbase, dt;
	int zz, dd;
	oid rmin, rmax;
	bit d_hdense = FALSE;

	rmin = *(oid*)BUNhead(r, BUNfirst(r));
	rmax = rmin + (BATcount(r) - 1);
	zz = BUNsize(r);
	rbase = BUNtloc(r, BUNfirst(r)) - rmin*zz;

	if (!inPlace || l->batParentid != 0 || l->htype == TYPE_void) {
		d = BATnew(TYPE_oid, TYPE_void, MIN(BATcount(l), BATcount(r)));
	} else {
		d = l;
	}
	dt = BUNhloc(d, BUNfirst(d));
	dd = BUNsize(d);

	/* For each BUN of the left bat check if the corresponding BUN in the right bat satisfies the restriction.
	   If yes the respective oid is added to the result */
	if (BAThdense(l)) {
		oid lv = MAX(rmin, *(oid*)BUNhead(l, BUNfirst(l)));
		oid llast = MIN(rmax, lv + (BATcount(l) - 1));
		oid l0 = lv;
		BUN d0 = dt;
		rt = rbase + lv*zz;
		while (lv <= llast) {
			if (@1) {
				*(oid*)dt = lv;
				dt += dd;	
			}		
			lv++;
			rt += zz;
		}
		d_hdense = ((size_t)(dt - d0)/dd == (lv - l0));
	} else {
		int xx = BUNsize(l);
		BUN llast = BUNhloc(l, BUNlast(l));
		BUN lt = BUNhloc(l, BUNfirst(l));
		oid lv = oid_nil;

		if (isForeignKey) {
			while (lt < llast) {
				lv = *(oid*)lt;
				rt = rbase + lv*zz;
				if (@1) {
					*(oid*)dt = lv;
					dt += dd;	
				}	
				lt += xx;
			}
		} else if (BAThordered(l)&1) {
			while(lt < llast && (lv = *(oid*)lt) < rmin) {
				lt += xx;
			}
			while(lt < llast && (lv = *(oid*)lt) <= rmax) {
				rt = rbase + lv*zz;
				if (@1) {
					*(oid*)dt = lv;
					dt += dd;	
				}	
				lt += xx;
			}
		} else {
			while(lt < llast){
			    lv = *(oid*)lt;
			    if (lv >= rmin && lv <= rmax) {
				rt = rbase + lv*zz;
				if (@1){
					*(oid*)dt = lv;
					dt += dd;	
				}	
			    }
			    lt += xx;
			}
		}
	}

	d->batBuns->free = dt - d->batBuns->base;
    	BATsetcount(d, d->batBuns->free/dd);
	d->hsorted = (BATcount(d)<2 || BAThordered(l)&1) ? GDK_SORTED : 0;
	d->hdense = BATcount(d)<2 || d_hdense;
	if (d->hdense) {
		if (BATcount(d)==0) {
			/* does not really matter */
			BATseqbase(d, (oid)0);
		} else {
			BATseqbase(d, *(oid*)BUNhloc(d,BUNfirst(d)));
		}
	} else {
		BATseqbase(d, oid_nil);
	}
	BATkey(d, BATcount(d)<2 || l->hkey);
	d->tsorted = FALSE;
	d->tdense = FALSE;
	BATseqbase(BATmirror(d), oid_nil);
	BATkey(BATmirror(d), FALSE);
	d->batRestricted= BAT_READ;
	BBPkeepref(d->batCacheid);
	*res=d->batCacheid;

	if (d != l) {
		BBPunfix(l->batCacheid);
	}
	BBPunfix(r->batCacheid);
	
	return MAL_SUCCEED;
@

@= JoinSelectR
str
JoinSelectRange_@2_@3_@1(int *res, BAT *l, BAT *r, @1 *low, @1 *hgh, bit inPlace, bit isForeignKey)
{
	@:JoinSelectBody(@6_@4(rt,low,@7@1) && @6_@5(rt,hgh,@7@1))@
}
@

@= JoinSelectS
str
JoinSelectSingle_@2_@1(int *res, BAT *l, BAT *r, @1 *mid, bit inPlace, bit isForeignKey)
{
	@:JoinSelectBody(@4_@3(rt,mid,@5@1))@
}
@

@= JoinSelectOperations
@:JoinSelectR(@1,LO,RE,GT,LE,@2,@3)@
@:JoinSelectR(@1,LE,RE,GE,LE,@2,@3)@
@:JoinSelectR(@1,LO,RO,GT,LT,@2,@3)@
@:JoinSelectR(@1,LE,RO,GE,LT,@2,@3)@
@:JoinSelectS(@1,RO,LT,@2,@3)@
@:JoinSelectS(@1,RE,LE,@2,@3)@
@:JoinSelectS(@1,LO,GT,@2,@3)@
@:JoinSelectS(@1,LE,GE,@2,@3)@
@

@= JoinSelectFunctions
crackers_export str CRKjoinSelectDefault_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left);
crackers_export str CRKjoinSelectBounds_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left, bit *inPlace, bit *isForeignKey);

str
CRKjoinSelectDefault_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left)
{
	bit inPlace = FALSE;
	bit isForeignKey = FALSE;
	return CRKjoinSelectBounds_@1( res, right, low, hgh, inclusiveLow, inclusiveHgh, left, &inPlace, &isForeignKey);
}

str
CRKjoinSelectBounds_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left, bit *inPlace, bit *isForeignKey)
{
	BAT *l, *r;

	if ((l = BATdescriptor(*left)) == NULL) {
        	throw(MAL, "crackers.crackJoinSelect", "Cannot access descriptor");
        }

	if ((r = BATdescriptor(*right)) == NULL) {
		BBPunfix(*left);
        	throw(MAL, "crackers.crackJoinSelect", "Cannot access descriptor");
        }

	if (!BAThdense(r)) {
		BBPunfix(*left);
		BBPunfix(*right);
		throw(MAL, "crackers.crackJoinSelect", "right BAT must have a dense head");
	}

	if (BATcount(l) == 0 || BATcount(r) == 0){
		BAT *d = BATnew(TYPE_oid, TYPE_void, 0);
		d->batBuns->free = 0;
		BATsetcount(d, 0);
		d->hsorted = GDK_SORTED;
		d->hdense = TRUE;
		BATseqbase(d, (oid)0);
		BATkey(d, TRUE);
		d->tsorted = FALSE;
		d->tdense = FALSE;
		BATseqbase(BATmirror(d), oid_nil);
		BATkey(BATmirror(d), FALSE);
		d->batRestricted= BAT_READ;
		BBPkeepref(d->batCacheid);
		*res = d->batCacheid;
		BBPunfix(*left);
		BBPunfix(*right);
		return MAL_SUCCEED;
	}	

        if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingle_RE_@1(res, l, r, hgh, *inPlace, *isForeignKey);
		else
                	return JoinSelectSingle_RO_@1(res, l, r, hgh, *inPlace, *isForeignKey);
	}
        else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingle_LE_@1(res, l, r, low, *inPlace, *isForeignKey);
		else
                	return JoinSelectSingle_LO_@1(res, l, r, low, *inPlace, *isForeignKey);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRange_LE_RE_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRange_LE_RO_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRange_LO_RO_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRange_LE_RE_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
	}
        throw(MAL, "crackers.crackJoinSelect", "case not handled");
}
@

@= JoinSelectBodyProjections

        BAT *b, *p;     
        BUN pairt, pivott, pivotlast;        
	lng size;
	int bsize, psize;

        if ((b = BATdescriptor(*cpair)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectProjections", "Cannot access descriptor");
        }  

	size = BATcount(b);
	p = BATnew(TYPE_void,TYPE_bit,size);

	pairt = BUNtloc(b, BUNfirst(b));
	pivott = BUNtloc(p, BUNfirst(p));
	bsize = BUNsize(b);
	psize = BUNsize(p);
	for (lng j = 0; j<size; j++){
		if (@3)	
			*(bit*)pivott = (bit)TRUE;
		else 
			*(bit*)pivott = (bit)FALSE;

		pairt  += bsize;
		pivott += psize;	
	}

	pivotlast = BUNfirst(p) + psize*size;
        p->batBuns->free =  pivotlast - p->batBuns->base;
        BATsetcount(p, size);	
	
	p->hsorted = FALSE;
        p->tsorted = FALSE;
        p->hdense = FALSE;
        p->tdense = FALSE;

	BBPkeepref(p->batCacheid);
	BBPunfix(b->batCacheid);
	*res = p->batCacheid;
	 return MAL_SUCCEED;

@

@= JoinSelectBodyProjectionsWithPivot

        BAT *b, *p, *c, *pair;     
        BUN pairt, pivott;        
	lng size;
	int bsize, psize;
	lng skip;
	int m;
	lng cl1,cl2,ch1,ch2;

	m = existsTreeIndexProjections(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackingPair(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	Sync_@1_@2(m,existsTreeIndexProjections(*bid, -1));

	if ((pair = BATdescriptor(TreeIndex[m].cbid)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectProjections", "Cannot access descriptor");
        }

        if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        GetLow_@1(*low1, *inclusiveLow1, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

        GetHgh_@1(*hgh1, *inclusiveHgh1, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

	if (cl1 != 0) cl1++;

        b = BATslice(pair, cl1, ch2+1);

        if ((p = BATdescriptor(*pivot)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectProjections", "Cannot access descriptor");
        }  

	
	size = BATcount(p);
	pairt = BUNtloc(b, BUNfirst(b));
	pivott = BUNtloc(p, BUNfirst(p));
	bsize = BUNsize(b);
	psize = BUNsize(p);
	skip = 0;
	for (lng j = 0; j<size; j++){
		if (*(bit*)pivott == TRUE){
	        	pairt += skip*bsize;	
			if (!(@3))	
				*(bit*)pivott = FALSE;
			skip = 0;
		}
		pivott += psize;	
		skip++;
	}

	BBPunfix(pair->batCacheid);
	BBPkeepref(p->batCacheid);
	*res = p->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;

@

@= JoinSelectRProjectionsWithoutPivot
str
JoinSelectRangeProjections_@3_@4_@2(int *res, int *cpair, @2 *low, @2 *hgh)
{
        @:JoinSelectBodyProjections(,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}

@= JoinSelectRProjections
str
JoinSelectRangeProjections_P_@3_@4_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1)
{
        @:JoinSelectBodyProjectionsWithPivot(@1,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}
@

@= JoinSelectSProjectionsWithoutPivot
str
JoinSelectSingleProjections_@3_@2(int *res, int *cpair, @2 *mid)
{
        @:JoinSelectBodyProjections(,@2,@5_@4(pairt,mid,@6@2))@
}

@= JoinSelectSProjections
str
JoinSelectSingleProjections_P_@3_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *mid, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1)
{
        @:JoinSelectBodyProjectionsWithPivot(@1,@2,@5_@4(pairt,mid,@6@2))@
}
@

@= JoinSelectOperationsProjections
@:JoinSelectRProjections(@1,@2,LO,RE,GT,LE,@3,@4)@
@:JoinSelectRProjections(@1,@2,LE,RE,GE,LE,@3,@4)@
@:JoinSelectRProjections(@1,@2,LO,RO,GT,LT,@3,@4)@
@:JoinSelectRProjections(@1,@2,LE,RO,GE,LT,@3,@4)@
@:JoinSelectSProjections(@1,@2,RO,LT,@3,@4)@
@:JoinSelectSProjections(@1,@2,RE,LE,@3,@4)@
@:JoinSelectSProjections(@1,@2,LO,GT,@3,@4)@
@:JoinSelectSProjections(@1,@2,LE,GE,@3,@4)@
@
@= JoinSelectOperationsProjectionsWithoutPivot
@:JoinSelectRProjectionsWithoutPivot(,@2,LO,RE,GT,LE,@3,@4)@
@:JoinSelectRProjectionsWithoutPivot(,@2,LE,RE,GE,LE,@3,@4)@
@:JoinSelectRProjectionsWithoutPivot(,@2,LO,RO,GT,LT,@3,@4)@
@:JoinSelectRProjectionsWithoutPivot(,@2,LE,RO,GE,LT,@3,@4)@
@:JoinSelectSProjectionsWithoutPivot(,@2,RO,LT,@3,@4)@
@:JoinSelectSProjectionsWithoutPivot(,@2,RE,LE,@3,@4)@
@:JoinSelectSProjectionsWithoutPivot(,@2,LO,GT,@3,@4)@
@:JoinSelectSProjectionsWithoutPivot(,@2,LE,GE,@3,@4)@
@

@= JoinSelectFunctionsProjectionsWithoutPivot
crackers_export str CRKjoinSelectProjections_@2(int *res, int *cpair, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str                     
CRKjoinSelectProjections_@2(int *res, int *cpair, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingleProjections_RE_@2(res, cpair, hgh);
		else
                	return JoinSelectSingleProjections_RO_@2(res, cpair, hgh);
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingleProjections_LE_@2(res, cpair, low);
		else
                	return JoinSelectSingleProjections_LO_@2(res, cpair, low);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeProjections_LE_RE_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeProjections_LE_RO_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeProjections_LO_RO_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeProjections_LE_RE_@2(res, cpair, low, hgh);
	}
        throw(MAL, "crackers.crackJoinSelectProjections", "case not handled");
}

@= JoinSelectFunctionsProjections
crackers_export str CRKjoinSelectProjections_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str                     
CRKjoinSelectProjections_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingleProjections_P_RE_@1_@2(res, bid, pbid, pivot, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
                	return JoinSelectSingleProjections_P_RO_@1_@2(res, bid, pbid, pivot, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingleProjections_P_LE_@1_@2(res, bid, pbid, pivot, low, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
                	return JoinSelectSingleProjections_P_LO_@1_@2(res, bid, pbid, pivot, low, low1, hgh1, inclusiveLow1, inclusiveHgh1);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeProjections_P_LE_RE_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeProjections_P_LE_RO_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeProjections_P_LO_RO_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeProjections_P_LE_RE_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
	}
        throw(MAL, "crackers.crackJoinSelectProjections", "case not handled");
}
@

@c
@:crackOperations(chr,simple,,chr)@
@:crackOperations(sht,simple,,sht)@
@:crackOperations(int,simple,,int)@
@:crackOperations(lng,simple,,lng)@
@:crackOperations(flt,simple,,flt)@
@:crackOperations(dbl,simple,,dbl)@
@:crackOperations(date,atom,TYPE_,loc)@

@:SelectFunctions(chr,simple,)@
@:SelectFunctions(sht,simple,)@
@:SelectFunctions(int,simple,)@
@:SelectFunctions(lng,simple,)@
@:SelectFunctions(flt,simple,)@
@:SelectFunctions(dbl,simple,)@
@:SelectFunctions(date,atom,TYPE_)@

@:JoinSelectOperations(chr,simple,)@
@:JoinSelectOperations(sht,simple,)@
@:JoinSelectOperations(int,simple,)@
@:JoinSelectOperations(lng,simple,)@
@:JoinSelectOperations(flt,simple,)@
@:JoinSelectOperations(dbl,simple,)@
@:JoinSelectOperations(date,atom,TYPE_)@

@:JoinSelectFunctions(chr,simple,)@
@:JoinSelectFunctions(sht,simple,)@
@:JoinSelectFunctions(int,simple,)@
@:JoinSelectFunctions(lng,simple,)@
@:JoinSelectFunctions(flt,simple,)@
@:JoinSelectFunctions(dbl,simple,)@
@:JoinSelectFunctions(date,atom,TYPE_)@

@:crackOperationsProjections(int,chr,simple,)@
@:crackOperationsProjections(int,sht,simple,)@
@:crackOperationsProjections(int,int,simple,)@
@:crackOperationsProjections(int,lng,simple,)@
@:crackOperationsProjections(int,flt,simple,)@
@:crackOperationsProjections(int,dbl,simple,)@
@:crackOperationsProjections(int,date,simple,)@
@:crackOperationsProjections(date,chr,atom,TYPE_)@
@:crackOperationsProjections(date,sht,atom,TYPE_)@
@:crackOperationsProjections(date,int,atom,TYPE_)@
@:crackOperationsProjections(date,lng,atom,TYPE_)@
@:crackOperationsProjections(date,flt,atom,TYPE_)@
@:crackOperationsProjections(date,dbl,atom,TYPE_)@
@:crackOperationsProjections(date,date,atom,TYPE_)@

@:SelectFunctionsProjections(int,chr,simple,)@
@:SelectFunctionsProjections(int,sht,simple,)@
@:SelectFunctionsProjections(int,int,simple,)@
@:SelectFunctionsProjections(int,lng,simple,)@
@:SelectFunctionsProjections(int,flt,simple,)@
@:SelectFunctionsProjections(int,dbl,simple,)@
@:SelectFunctionsProjections(int,date,simple,)@
@:SelectFunctionsProjections(date,chr,atom,TYPE_)@
@:SelectFunctionsProjections(date,sht,atom,TYPE_)@
@:SelectFunctionsProjections(date,int,atom,TYPE_)@
@:SelectFunctionsProjections(date,lng,atom,TYPE_)@
@:SelectFunctionsProjections(date,flt,atom,TYPE_)@
@:SelectFunctionsProjections(date,dbl,atom,TYPE_)@
@:SelectFunctionsProjections(date,date,atom,TYPE_)@


@:JoinSelectOperationsProjectionsWithoutPivot(,chr,simple,)@
@:JoinSelectOperationsProjectionsWithoutPivot(,sht,simple,)@
@:JoinSelectOperationsProjectionsWithoutPivot(,int,simple,)@
@:JoinSelectOperationsProjectionsWithoutPivot(,lng,simple,)@
@:JoinSelectOperationsProjectionsWithoutPivot(,flt,simple,)@
@:JoinSelectOperationsProjectionsWithoutPivot(,dbl,simple,)@
@:JoinSelectOperationsProjectionsWithoutPivot(,date,atom,TYPE_)@

@:JoinSelectOperationsProjections(int,chr,simple,)@
@:JoinSelectOperationsProjections(int,sht,simple,)@
@:JoinSelectOperationsProjections(int,int,simple,)@
@:JoinSelectOperationsProjections(int,lng,simple,)@
@:JoinSelectOperationsProjections(int,flt,simple,)@
@:JoinSelectOperationsProjections(int,dbl,simple,)@
@:JoinSelectOperationsProjections(int,date,atom,TYPE_)@
@:JoinSelectOperationsProjections(date,chr,atom,TYPE_)@
@:JoinSelectOperationsProjections(date,sht,atom,TYPE_)@
@:JoinSelectOperationsProjections(date,int,atom,TYPE_)@
@:JoinSelectOperationsProjections(date,lng,atom,TYPE_)@
@:JoinSelectOperationsProjections(date,flt,atom,TYPE_)@
@:JoinSelectOperationsProjections(date,dbl,atom,TYPE_)@
@:JoinSelectOperationsProjections(date,date,atom,TYPE_)@


@:JoinSelectFunctionsProjectionsWithoutPivot(,chr,simple,)@
@:JoinSelectFunctionsProjectionsWithoutPivot(,sht,simple,)@
@:JoinSelectFunctionsProjectionsWithoutPivot(,int,simple,)@
@:JoinSelectFunctionsProjectionsWithoutPivot(,lng,simple,)@
@:JoinSelectFunctionsProjectionsWithoutPivot(,flt,simple,)@
@:JoinSelectFunctionsProjectionsWithoutPivot(,dbl,simple,)@
@:JoinSelectFunctionsProjectionsWithoutPivot(,date,atom,TYPE_)@

@:JoinSelectFunctionsProjections(int,chr,simple,)@
@:JoinSelectFunctionsProjections(int,sht,simple,)@
@:JoinSelectFunctionsProjections(int,int,simple,)@
@:JoinSelectFunctionsProjections(int,lng,simple,)@
@:JoinSelectFunctionsProjections(int,flt,simple,)@
@:JoinSelectFunctionsProjections(int,dbl,simple,)@
@:JoinSelectFunctionsProjections(int,date,atom,TYPE_)@
@:JoinSelectFunctionsProjections(date,chr,atom,TYPE_)@
@:JoinSelectFunctionsProjections(date,sht,atom,TYPE_)@
@:JoinSelectFunctionsProjections(date,int,atom,TYPE_)@
@:JoinSelectFunctionsProjections(date,lng,atom,TYPE_)@
@:JoinSelectFunctionsProjections(date,flt,atom,TYPE_)@
@:JoinSelectFunctionsProjections(date,dbl,atom,TYPE_)@
@:JoinSelectFunctionsProjections(date,date,atom,TYPE_)@

@= Project
crackers_export str CRKProjectCrack_@1(int *res, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKProjectCrack_@1_@2(int *res, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{
        BAT *b, *c, *view;
	int m;
	lng cl1,cl2,ch1,ch2;

	m = existsTreeIndexProjections(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackingPair(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	Sync_@1_@2(m,existsTreeIndexProjections(*bid, -1));

        if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectProjections", "Cannot access descriptor");
        }

        if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");
                
        GetLow_@1(*low, *inclusiveLow, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
                
        GetHgh_@1(*hgh, *inclusiveHgh, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	if (cl1 != 0) cl1++;

        view = BATslice(BATmirror(VIEWhead_(BATmirror(b), BAT_READ)), cl1, ch2+1);

        *res = view->batCacheid;
        BBPkeepref(*res);

        BBPunfix(b->batCacheid);
        BBPunfix(c->batCacheid);
        return MAL_SUCCEED;
}

crackers_export str CRKProjectH_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKProjectH_@1_@2(int *res, int *bid, int *pbid,int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{
        BAT *b, *p, *r, *c, *pair;
        BUN pairh, pivott, rest, reslast;
        lng size, fsize;
        int bsize, psize, rsize;
        lng skip;
	int m;
	lng cl1,cl2,ch1,ch2;

	m = existsTreeIndexProjections(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackingPair(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	Sync_@1_@2(m,existsTreeIndexProjections(*bid, -1));

        if ((pair = BATdescriptor(TreeIndex[m].cbid)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectProjections", "Cannot access descriptor");
        }

	if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        GetLow_@1(*low, *inclusiveLow, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

        GetHgh_@1(*hgh, *inclusiveHgh, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

	if (cl1 != 0) cl1++;

        b = BATslice(pair, cl1, ch2+1);
	
        if ((p = BATdescriptor(*pivot)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectProjections", "Cannot access descriptor");
        }

        size = BATcount(p);
 	r = BATnew(TYPE_void,b->htype,size);

        pairh  = BUNhloc(b, BUNfirst(b));
        pivott = BUNtloc(p, BUNfirst(p));
        rest   = BUNtloc(r, BUNfirst(r));
        bsize = BUNsize(b);
        psize = BUNsize(p);
        rsize = BUNsize(r);
        skip = 0;
	fsize = 0;
        for (lng j = 0; j<size; j++){
                if (*(bit*)pivott == TRUE){
                        pairh += skip*bsize;
			*(@1*)rest = *(@1*)pairh; 
			rest += rsize;
                        skip = 0;
			fsize++;
                }
                pivott += psize;
                skip++;
        }

        reslast = BUNfirst(r) + rsize*fsize;
        r->batBuns->free =  reslast - r->batBuns->base;
        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);
        BBPunfix(pair->batCacheid);
        *res = r->batCacheid;
         return MAL_SUCCEED;
}
crackers_export str CRKProject_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKProject_@1_@2(int *res, int *bid, int *pbid,int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{
        BAT *b, *p, *r, *c, *pair;
        BUN pairt, pivott, rest, reslast;
        lng size, fsize;
        int bsize, psize, rsize;
        lng skip;
	int m;
	lng cl1,cl2,ch1,ch2;

	m = existsTreeIndexProjections(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackingPair(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	Sync_@1_@2(m,existsTreeIndexProjections(*bid, -1));

        if ((pair = BATdescriptor(TreeIndex[m].cbid)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectProjections", "Cannot access descriptor");
        }

	if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        GetLow_@1(*low, *inclusiveLow, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

        GetHgh_@1(*hgh, *inclusiveHgh, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

	if (cl1 != 0) cl1++;

        b = BATslice(pair, cl1, ch2+1);
	
        if ((p = BATdescriptor(*pivot)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectProjections", "Cannot access descriptor");
        }

        size = BATcount(p);
 	r = BATnew(TYPE_void,b->ttype,size);

        pairt  = BUNtloc(b, BUNfirst(b));
        pivott = BUNtloc(p, BUNfirst(p));
        rest   = BUNtloc(r, BUNfirst(r));
        bsize = BUNsize(b);
        psize = BUNsize(p);
        rsize = BUNsize(r);
        skip = 0;
	fsize = 0;
        for (lng j = 0; j<size; j++){
                if (*(bit*)pivott == TRUE){
                        pairt += skip*bsize;
			*(@2*)rest = *(@2*)pairt; 
			rest += rsize;
                        skip = 0;
			fsize++;
                }
                pivott += psize;
                skip++;
        }

        reslast = BUNfirst(r) + rsize*fsize;
        r->batBuns->free =  reslast - r->batBuns->base;
        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);
        BBPunfix(pair->batCacheid);
        return MAL_SUCCEED;
}
@

@c
@:Project(int,chr)@
@:Project(int,sht)@
@:Project(int,int)@
@:Project(int,lng)@
@:Project(int,flt)@
@:Project(int,dbl)@
@:Project(int,date)@
@:Project(date,chr,atom,TYPE_)@
@:Project(date,sht,atom,TYPE_)@
@:Project(date,int,atom,TYPE_)@
@:Project(date,lng,atom,TYPE_)@
@:Project(date,flt,atom,TYPE_)@
@:Project(date,dbl,atom,TYPE_)@
@:Project(date,date,atom,TYPE_)@

