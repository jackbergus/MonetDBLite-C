@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f crackers
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006
@* Cracker index


StM: This text is obsolete as of April 26, 2006, and needs to be updated!


A cracker index is a volatile datastructure which acts as
a non-dense index into a BAT. The index is incrementally built
based on the fragments needed by queries.
Each select operation results in a partial re-clustering of the tuples
such that the result set is a consecutive memory area in the BAT.
This set can be returned as a BAT view for further processing.

A cracker index is created with the command @code{crackers.new}
and destroyed using @code{crackers.destroy}.
Multiple calls to create/destroy the cracker index on the same
argument are ignored.

The cracker index can be created for the time being on
tail columns of type {int,lng,dbl,flt,time}. The head
is always of type @code{oid}.

Once a cracker index exist, portions can be extracted 
using @code{crackers.select} and @code{crackers.uselect},
which semantically behave as their algebraic counterparts.
Both operations may have to glue pieces from the cracked
bat to satisfy the BAT semantics.

Qst: are these operators overloaded to initiate a crack
operation first?

In addition, the cracker index can be used to feed a generator
for pieces satisfying a range constraint.
A cracker partition is indicated by the index in the cidx
table. It can be used to initialize a BATview to represent
the partition during processing.

Repeated cracking leads to an ever growing index. This process
can be stopped by setting the granule size,
i.e.  the minimum number of tuples in each piece,
or the maximum number of pieces. 
The operations @code{crackers.setGranule()} and @code{crackers.setLimit()}
implement them. The default is to allow an arbitrary number pieces
with arbitrary sizes.

Pitfalls.
The policy in the kernel to take a copy of a BAT when there
is a need to write to it and there are also views around becomes 
an issue. Instead, it should isolate the views, giving them a
private copy. This way the underlying base table becomes free to re-arrange.
This issue is postponed to the future.

The cracker module should be prepared to deal with any of the base types.
For strings this becomes an issue.

This module contains the experimental code to play with cracked tables.
It supports int-based bats for the time being only.

The current implementation uses an unprotected cracker
index. This limits the interface at slightly more overhead
of searching the cracker index upon each call.

Initial performance indicates around 70 ms processing
overhead on a 1M bat during the first crack operation.
(Athlon 1400, 1Gb)

@= crackfcn
command newIndex(b:bat[:oid,:@1]):void
address CRKnewIndex
comment "Create the index for a cracked table.";

command printIndex(b:bat[:oid,:@1]):void
address CRKprintIndex
comment "Print the index for a cracked table.";
@

@mal
module crackers;

@:crackfcn(int)@
@-
A limited set of relational operators is overloaded to deal with
cracked BATs. The relational select collects the pieces
into a single BAT. Preferably using a BATview, otherwise
the pieces are combined to form a new BAT.

@= crackAlgebra
command select(b:bat[:oid,:@1],l:@1,h:@1):bat[:oid,:@1]
address CRKselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@1],l:@1):bat[:oid,:@1]
address CRKselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:oid,:@1]
address CRKselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:oid,:@1],l:@1,h:@1):bat[:oid,:void]
address CRKuselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:oid,:@1],l:@1):bat[:oid,:void]
address CRKuselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:oid,:void]
address CRKuselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

@-
@mal
@:crackAlgebra(int)@

@-
Temporary interface for the "new cracking competition".
For the time being, we ignore the cracking administration and repeated
cracking, and focus on cracking a complete BAT, returning the cracked BAT.
@
@= crack
command zcrack@4_@1 (b:bat[:oid,:@3], mid:@3) :bat[:oid,:@3]
address CRKcrack@4Zero_@1_@3
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively@5. (By @2.)";

command crack@4_@1 (b:bat[:oid,:@3], mid:@3) :bat[:oid,:@3]
address CRKcrack@4One_@1_@3
comment "Break a BAT into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively@5. (By @2.)";

command crack@4_@1 (b:bat[:oid,:@3], low:@3, hgh:@3) :bat[:oid,:@3]
address CRKcrack@4Two_@1_@3
comment "Break a BAT into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively@5. (By @2.)";

command zcrack@4_@1 (b:bat[:oid,:@3], low:@3, hgh:@3) :bat[:oid,:@3]
address CRKcrack@4Three_@1_@3
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively@5. (By @2.)";

@
@= crack_validate
command zcrack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2Zero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2One_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Two_validate_@1
comment "Validate whether a BAT is correctly broken into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively@3.";

command zcrack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Three_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively@3.";
@
@mal
@:crack(is,Stratos Idreos,int,Ordered,; maintaining the head-oid order within each piece)@
@:crack(MK,Martin Kersten,int,,)@
@:crack(MK,Martin Kersten,int,Ordered,; maintaining the head-oid order within each piece)@
@:crack(SM,Stefan Manegold,int,,)@
@:crack(sm,Stefan Manegold,int,,)@
@:crack(SM,Stefan Manegold,int,Ordered,; maintaining the head-oid order within each piece)@
@:crack(sm,Stefan Manegold,int,Ordered,; maintaining the head-oid order within each piece)@
@:crack_validate(int)@
@:crack_validate(int,Ordered,; maintaining the head-oid order within each piece)@
@-
@{
@- include prelude.mx
@* Implementation
The implementation is geared at early experimentation
without all the details to make the code robust and
ultra fast.

@h
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/

typedef struct {
	int bid;   /* the cracked bat */
	int cid;   /* the index for this cracked bat */
} CrackIndex;

mal_export str CRKselect(int *vid, int *bid, int *low, int *hgh);
mal_export str CRKselectValue(int *vid, int *bid, int *value);
mal_export str CRKuselect(int *vid, int *bid, int *low, int *hgh);
mal_export str CRKuselectValue(int *vid, int *bid, int *value);

mal_export str CRKnewIndex(int *k, int *bid);
mal_export str CRKprintIndex(int *k, int *bid);

#endif /* _CRACKERS_H */

@c
#include "mal.h"
#include "mal_exception.h"
#include "crackers.h"

#define MAXPIECE 1024*100

static int maxCrackMap = 0;

static CrackIndex *Index;

int     
existsIndex(int bid)
{       
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (Index[i].bid == bid)
			return i;
	return -1;
}
@= CreateNewIndex
int     
newIndex_@1(int bid)
{       
	int i, freemap = -1, units = 1024;
	
	for (i = 0; i < maxCrackMap; i++)
		if (Index[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		Index[freemap].bid = bid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackIndex *x;
        
		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackIndex *) GDKmalloc(sizeof(CrackIndex) * units);
		memset(x, 0, sizeof(CrackIndex) * units);
		if (Index) { 
			fprintf(stderr, "reallocate index \n");
			memcpy(x, Index, sizeof(CrackIndex) * i);
			GDKfree(Index);
		}
		Index = x;
		maxCrackMap = units;
	}

	Index[i].bid = bid;
	BAT *b = BATnew(TYPE_lng, TYPE_@1, 100000);	/*todo: size*/
	BBPkeepref(b->batCacheid);
	Index[i].cid = b->batCacheid; 
	return i;
}
@

@c
@:CreateNewIndex(int)@

void
printCrackIndex(int bid)
{
	int i = existsIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(Index[i].cid));
}

str
CRKprintIndex(int *k, int *bid)
{
	(void)k;
	printCrackIndex(*bid);
	return MAL_SUCCEED;
}

str
CRKnewIndex(int *k, int *bid)
{
	(void)k;
	newIndex_int(*bid);
	return MAL_SUCCEED;
}

@= insertIndexElement
	*(lng*) @2 = @4;	
	*(@1 *) @3 = @5;	
	(b)->batBuns->free += xx;
        (b)->batCount ++; 
@
@= InsertIndexElements
void 
addOne_@1(int i, @1 *value, lng index, BUN p)
{
	BAT *b;
        if ((b = BATdescriptor(Index[i].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return;
        }

	int xx = BUNsize(b);
	if (BATcount(b) == 0){
		@:insertIndexElement(@1,BUNhloc(b, BUNfirst(b)), BUNtloc(b, BUNfirst(b)), index, *value)@
		return; 		
	}
	/*todo: check BAT size*/

	BUN ph = BUNhloc(b, p);
	BUN pt = BUNtloc(b, p);
	
	if (p == BUNlast(b)){ /*Insert at the end if everything is smaller than the new value*/
		@:insertIndexElement(@1, ph, pt, index, *value)@
		return;
	}

	/*Else we have to sift some buns to put the new one to the right position*/
	BUN wh = BUNhloc(b, BUNlast(b));
	BUN wt = BUNtloc(b, BUNlast(b));
	BUN rh = wh - xx, rt = wt - xx;
	if (*(@1*)pt == *value && index > 0){ /*negative index values inidicate non inclusive bounds so they should be always first*/
		ph += xx;
		pt += xx;
	} 
	for (;rt>=pt;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
		*(lng*)wh = *(lng*)rh;
		*(@1 *)wt = *(@1 *)rt;
	}
	@:insertIndexElement(@1, ph, pt, index, *value)@
	BBPunfix(b->batCacheid);
}	

void 
addTwo_@1(int i, @1 *valueA, lng indexA, BUN p2, @1 *valueB, lng indexB, BUN p)
{
	BAT *b;
        if ((b = BATdescriptor(Index[i].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return;
        }

	/*todo: check BAT size*/
	int xx = BUNsize(b);
	if (BATcount(b) == 0){
		BUN ph = BUNhloc(b, BUNfirst(b));
		BUN pt = BUNtloc(b, BUNfirst(b));
		@:insertIndexElement(@1, ph, pt, indexA, *valueA)@
		ph += xx;
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
		return; 		
	}

	BUN ph = BUNhloc(b, p);
	BUN pt = BUNtloc(b, p);
	BUN wh = BUNhloc(b, BUNlast(b)+xx);
	BUN wt = BUNtloc(b, BUNlast(b)+xx);
	BUN rh = wh - 2*xx, rt = wt - 2*xx;
        BUN p2h = BUNhloc(b, p2);
        BUN p2t = BUNtloc(b, p2);
	if (p == BUNlast(b)){
		ph += xx; /* sift one more position to make room for pair A too*/
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
	}
	else{   /*Else we have to sift some buns to put the new one to the right position*/
		if (*(@1*)pt == *valueB && indexB > 0){
			ph += xx;
			pt += xx;
		} 
		for (;rt>=pt;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
			*(lng*)wh = *(lng*)rh;
			*(@1 *)wt = *(@1 *)rt;
		}
		ph += xx; /* sift one more position to make room for pair A too*/
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
	}
        wh -= xx;
        wt -= xx;
        if (*(@1*)p2t == *valueA && indexA > 0){
                p2h += xx;
                p2t += xx;
        }
        for (;rt>=p2t;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
                *(lng*)wh = *(lng*)rh;
                *(@1 *)wt = *(@1 *)rt;
        }
        @:insertIndexElement(@1, p2h, p2t, indexA, *valueA)@
	BBPunfix(b->batCacheid);
}	
@

@c
@:InsertIndexElements(int)@


@-
Temporary templates for the "new cracking competition".
For the time being, we ignore the cracking administration and repeated
cracking, and focus on cracking a complete BAT, returning the cracked BAT.
@
@-
Martin Kersten

The code base is prepared to run with different types.
@-
Create a 3- and 5-way cracking of the BAT. Updates of the cracker index
is left along for a while. We don't return anything right now.
Cracking is inplace!
The piece cracking routines are parameterized with a closed bun index
interval.
@
@-
The three way split use knowledge on the type size to issue
the exchanges. Moreover, we should be prepared to handle
a cracking over a mirrored bat.
We support only fixed size buns and rely on the compiler
to arrange proper structs. More advanced schemes, or slower
stepwise ones, are for the future.

The 'struct SCRATCH{ oid hdummy; @1 tdummy; } dummy;' approach
did not produce a noticable difference on the machine at hand.
The generic solution avoids possible compiler alignment issues.

@= shuffleMK
	tdummy= *(@1*) @2;
	*(@1*) @2= *(@1*) @3;
	*(@1*) @3= tdummy;

	hdummy= *(oid*)((char*)@2 - b->tloc);
	*(oid*)((char*)@2 - b->tloc) = *(oid*)((char*)@3 - b->tloc);
	*(oid*)((char*)@3 - b->tloc) = hdummy;

@= MK_operations
str
CRKpieceZero_MK_@1( BAT *b, @1 mval, size_t first, size_t last){
	ptr vm, vl;
	int xx;
	oid hdummy;
	@1 tdummy;

	/* set bounds for the iterator */
	xx = BUNsize(b);

	vm = BUNtloc(b, BUNptr(b,first));
	vl= BUNtloc(b,BUNptr(b,last));

	while(vm<vl) {
		if (*(@1 *) vm <= mval)
			vm = (ptr) ((char *) vm + xx);
		else {
			while( *(@1 *) vl > mval && vl>vm)
				vl = (ptr) ((char *) vl - xx);
			@:shuffleMK(@1,vm,vl)@
			vl = (ptr) ((char *) vl - xx);
			vm = (ptr) ((char *) vm + xx);
		} 
	} 
#ifdef MK_DEBUG
	printf("cracked index %d\n", (int) BUNindex(b,(ptr) ((char*)vm - b->tloc)));
#endif
	return MAL_SUCCEED;
}

str
CRKcrackZero_MK_@1 (int *res, int *bid, @1 *mid)
{
	BAT *b;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) 
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");

	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg=CRKpieceZero_MK_@1( b, *mid,(size_t) 0, BATcount(b)-1);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

str
CRKOrderedpieceOne_MK_@1( BAT *b, const @1 mval, size_t first, size_t last, size_t *start, size_t *end){
	char *tc, *hc, *tv, *hv;
	char *tp, *hp, *tq, *hq;
	const int xx= BUNsize(b);
	int i,j,k,l,n;
	oid *hdummy, *hequal;
	@1  *tdummy, *tequal;
	
	/* set bounds for the two-way iterator */
	tc = BUNtloc(b, BUNptr(b,first));
	tp = BUNtloc(b, BUNptr(b,last));

	/* set the bounds for the scratch areas */
	hdummy= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
	tdummy= (ptr) GDKmalloc((last-first+1) *sizeof(@1));
	i= 0;
	j= last-first;
	hequal= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
	tequal= (ptr) GDKmalloc((last-first+1) *sizeof(@1));
	k= 0;
	l= last-first;

	/* ignore non-moveable bounds*/
	while( *(@1*)tc < mval && tc<=tp){
		tc += xx; 
	}
	/* probe */
	hc= hv= tc;
	hv += 50*xx;
	while(hc<hv){
		if( *(@1*)hc <= mval )
			i++;
		if( *(@1*)hc >= mval )
			k++;
		hc+= xx;
	}
	n= i>k;
/* printf("probe %d %d\n",i,k);*/

	tv=tc; hc= hv= tc-b->tloc;
	while( *(@1*)tp > mval && tp>=tc){
		tp -= xx; 
	}
	tq=tp; hp= hq= tq-b->tloc;
/*printf("left %d right %d\n", i,k);*/
	i=0; k=0;
/* printf("i=%d j=%d\n",i,j);  BATprint(b);*/
	/* move elements out of the way */
	/* use Stratos's insight to move only upon need */
	/* first case is based on left kept in place */
	if(n){
		while( tc <= tp){
			/* skip to next candidate to move*/
			if( *(@1*)tc >= mval ){
				if( *(@1*) tc == mval){
					hequal[k]= *(oid*)hc;
					tequal[k]= *(@1*) tc;
					k++;
				} 
				tc += xx;  hc += xx;
				continue;
			}
			if( *(@1*) tv > mval){
					hdummy[i] = *(oid*)hv; 
					tdummy[i] = *(@1*)tv; 
					i++;
			}
			*(oid*)hv= *(oid*)hc;
			*(@1*)tv = *(@1*)tc;
			tv += xx; hv += xx;
			tc += xx; hc += xx;
		}
		/* squeeze the tail */
			tc -=xx;
		while(tc>= tv){
			if( *(@1*)tc> mval){
				*(oid*)hq= *(oid*)hc;
				*(@1*)tq= *(@1*)tc;
				tq -= xx; hq -= xx;
			}
			tc -= xx; hc -= xx;
		}
	/* printf("equals left=%d equals right=%d larger=%d\n",k,(int)(last-first-l),i); */
	/*BATprint(b);*/
		/* move left equals */
	/* printf("move left equals 0- %d\n",k-1);*/
		*start= BUNindex(b, hv);
		for(n=0;n<k;n++){
			*(oid*) hv = hequal[n]; hv += xx;
			*(@1*)  tv = tequal[n]; tv += xx;
		}
	/* BATprint(b); printf("move right equals %d-%d\n",l, (int) last- (int) first); */
		/* move right equals */
		for(l++, n=last-first; l<=n; l++){
			*(oid*) tv = hequal[l]; hv += xx;
			*(@1*)  tv = tequal[l]; tv += xx;
		}
		*end= BUNindex(b, tv);
			
	/*printf("equals done\n"); BATprint(b);*/
		/* move left surplus */
		for(n=0;n<i;n++){
			*(oid*) hv = hdummy[n]; hv += xx;
			*(@1*)  tv = tdummy[n]; tv += xx;
		}
	} else {
		/* reverse the process */
		tc= tp;
		hc= hp;
		while( tc >= tv){
			/* skip to next candidate to move*/
			if( *(@1*)tc <= mval ){
				if( *(@1*) tc == mval){
					hequal[l]= *(oid*)hc;
					tequal[l]= *(@1*) tc;
					l--;
				} 
				tc -= xx;  hc -= xx;
				continue;
			}
			if( *(@1*) tp < mval){
					hdummy[j] = *(oid*)hp; 
					tdummy[j] = *(@1*)tp; 
					j--;
			}
			*(oid*)hp= *(oid*)hc;
			*(@1*)tp = *(@1*)tc;
			tp -= xx; hp -= xx;
			tc -= xx; hc -= xx;
		}
		/* squeeze the head */
		tc +=xx;
		hv= tv-b->tloc;
		while(tc<= tp){
			if( *(@1*)tc< mval){
				*(oid*)hv= *(oid*)hc;
				*(@1*)tv= *(@1*)tc;
				tv += xx;  hv += xx;
			}
			tc += xx; hc += xx;
		}
	/* printf("equals left=%d equals right=%d larger=%d\n",k,(int)(last-first-l),i); */
	/*BATprint(b);*/
		*end= BUNindex(b, hp);
		/* move right equals */
		for(n=last-first; n>l; n--){
			*(oid*) hp = hequal[n]; hp -= xx;
			*(@1*)  tp = tequal[n]; tp -= xx;
		}
		*start= BUNindex(b, tp);
			
	/*printf("equals done\n"); BATprint(b);*/
		/* move left surplus */
		for(n=last-first;n>j;n--){
			*(oid*) hp = hdummy[n]; hp -= xx;
			*(@1*)  tp = tdummy[n]; tp -= xx;
		}
	}
/* printf("done\n"); BATprint(b);*/
	GDKfree(hdummy); GDKfree(tdummy);
	return MAL_SUCCEED;

}

str
CRKOrderedpieceThree_MK_@1( BAT *b, @1 low, @1 hgh, size_t first, size_t last, int *start, int *end){
	char *tc, *hc, *tv, *hv;
	char *tp, *hp, *tq, *hq;
	const int xx= BUNsize(b);
	int i,j,k,l,n;
	oid *hdummy, *hequal;
	@1  *tdummy, *tequal;
	
	/* set bounds for the two-way iterator */
	tc = BUNtloc(b, BUNptr(b,first));
	tp = BUNtloc(b, BUNptr(b,last));

	/* set the bounds for the scratch areas */
	hdummy= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
	tdummy= (ptr) GDKmalloc((last-first+1) *sizeof(@1));
	i= 0;
	j= last-first;
	hequal= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
	tequal= (ptr) GDKmalloc((last-first+1) *sizeof(@1));
	k= 0;
	l= last-first;

	/* ignore non-moveable bounds*/
	while( *(@1*)tc < low && tc<=tp){
		tc += xx; 
	}
	/* probe */
	hc= hv= tc;
	hv += (last-first)/50*xx;
	while(hc<hv){
		if( *(@1*)hc <= low )
			i++;
		if( *(@1*)hc > hgh )
			k++;
		hc+= xx;
	}
	n= i>k;
	n= (last-first)/50 -i-k;
/* printf("probe %d %d %d\n",i,k,n);*/
	if(n> i+k) n=2; else	/* use middle out */
	if(k> i) n=1; 	/* use reverse walk */
	else n=0;	/* use default */
/* printf("strategy %d\n",n);*/

	tv=tc; hc= hv= tc-b->tloc;
	while( *(@1*)tp > hgh && tp>=tc){
		tp -= xx; 
	}
	tq=tp; hp= hq= tq-b->tloc;
/*printf("left %d right %d\n", i,k);*/
	i=0; k=0;
/* printf("i=%d j=%d\n",i,j);  BATprint(b);*/
	/* move elements out of the way */
	/* use Stratos's insight to move only upon need */
	/* first case is based on left kept in place */
	if(n==2){
		/* in the middle out case we keep low<t<=hgh in the buffer */
		/* and shift low and high to the scratch partition */
/*printf("middleout shuffle\n"); BATprint(b);*/
		tq= tc; hq=hc;
		while( tc <= tp){
			if( *(@1*) tc <= low){
				hequal[i]= *(oid*)hc;
				tequal[i]= *(@1*) tc;
				i++;
				tc += xx;  hc += xx;
				continue;
			}
			if( *(@1*) tc > hgh){
				hdummy[k]= *(oid*)hc;
				tdummy[k]= *(@1*) tc;
				k++;
				tc += xx;  hc += xx;
				continue;
			}
			*(oid*)hv= *(oid*)hc;
			*(@1*)tv = *(@1*)tc;
			tv += xx; hv += xx;
			tc += xx; hc += xx;
		}
/*printf("shuffe done %d %d\n",i,k); BATprint(b);*/
		/* now we have space in the back to put highs
		   back in place */
		for(k--;k>=0;k--){
			*(oid*) hp = hdummy[k]; hp -= xx;
			*(@1*)  tp = tdummy[k]; tp -= xx;
		}
/*printf("highs in place \n"); BATprint(b);*/
		/* shift the middle part into place */
		tc= tq; hc= hq;
		for( tv-=xx, hv -=xx; tv>= tc; tv -= xx, hv -= xx){
			*(oid*) hp = *(oid*)hv; hp -= xx;
			*(@1*)  tp = *(@1*) tv; tp -= xx;
		}
/*printf("middle shift \n"); BATprint(b);*/
		/* put the low one's into place */
		for(i--;i>=0;i--){
			*(oid*) hp = hequal[i]; hp -= xx;
			*(@1*)  tp = tequal[i]; tp -= xx;
		}
/*printf("done shift \n"); BATprint(b);*/
	} else
	if(n==0){
		while( tc <= tp){
			/* skip to next candidate to move*/
			if( *(@1*)tc > low ){
				if( *(@1*) tc <= hgh){
					hequal[k]= *(oid*)hc;
					tequal[k]= *(@1*) tc;
					k++;
				} 
				tc += xx;  hc += xx;
				continue;
			}
			if( *(@1*) tv > hgh){
					hdummy[i] = *(oid*)hv; 
					tdummy[i] = *(@1*)tv; 
					i++;
			}
			*(oid*)hv= *(oid*)hc;
			*(@1*)tv = *(@1*)tc;
			tv += xx; hv += xx;
			tc += xx; hc += xx;
		}
		/* squeeze the tail */
			tc -=xx;
		while(tc>= tv){
			if( *(@1*)tc> hgh){
				*(oid*)hq= *(oid*)hc;
				*(@1*)tq= *(@1*)tc;
				tq -= xx;  hq -= xx;
			}
			tc -= xx; hc -= xx;
		}
	/* printf("equals left=%d equals right=%d larger=%d\n",k,(int)(last-first-l),i); */
	/*BATprint(b);*/
		/* move left equals */
	/* printf("move left equals 0- %d\n",k-1);*/
		*start= BUNindex(b, hv);
		for(n=0;n<k;n++){
			*(oid*) hv = hequal[n]; hv += xx;
			*(@1*)  tv = tequal[n]; tv += xx;
		}
	/* BATprint(b); printf("move right equals %d-%d\n",l, (int) last- (int) first); */
		/* move right equals */
		for(l++, n=last-first; l<=n; l++){
			*(oid*) tv = hequal[l]; hv += xx;
			*(@1*)  tv = tequal[l]; tv += xx;
		}
		*end= BUNindex(b, tv);
			
	/*printf("equals done\n"); BATprint(b);*/
		/* move left surplus */
		for(n=0;n<i;n++){
			*(oid*) hv = hdummy[n]; hv += xx;
			*(@1*)  tv = tdummy[n]; tv += xx;
		}
	} else {
		/* reverse the process */
/*printf("reverse\n"); BATprint(b);*/
		tc= tp;
		hc= hp;
		while( tc >= tv){
			/* skip to next candidate to move*/
			if( *(@1*)tc <= hgh ){
				if( *(@1*) tc > low){
					hequal[l]= *(oid*)hc;
					tequal[l]= *(@1*) tc;
					l--;
				} 
				tc -= xx;  hc -= xx;
				continue;
			}
			if( *(@1*) tp <= low){
					hdummy[j] = *(oid*)hp; 
					tdummy[j] = *(@1*)tp; 
					j--;
			}
			*(oid*)hp= *(oid*)hc;
			*(@1*)tp = *(@1*)tc;
			tp -= xx; hp -= xx;
			tc -= xx; hc -= xx;
		}
		/* squeeze the head */
		tc +=xx;
		hc +=xx;
		hv= tv-b->tloc;
		while(tc<= tp){
			if( *(@1*)tc<= low){
				*(oid*)hv= *(oid*)hc;
				*(@1*)tv= *(@1*)tc;
				tv += xx;  hv += xx;
			}
			tc += xx; hc += xx;
		}
/*printf("equals left=%d equals right=%d larger=%d\n",k,(int)(last-first-l),i); 
BATprint(b);*/
		*end= BUNindex(b, hp);
		/* move right equals */
		for(n=last-first; n>l; n--){
			*(oid*) hp = hequal[n]; hp -= xx;
			*(@1*)  tp = tequal[n]; tp -= xx;
		}
		*start= BUNindex(b, tp);
			
/*printf("equals done\n"); BATprint(b);*/
		/* move left surplus */
		for(n=last-first;n>j;n--){
			*(oid*) hp = hdummy[n]; hp -= xx;
			*(@1*)  tp = tdummy[n]; tp -= xx;
		}
	}
/*printf("done\n"); BATprint(b);*/
	GDKfree(hdummy); GDKfree(tdummy);
	return MAL_SUCCEED;
}

str
CRKOrderedpieceZero_MK_@1( BAT *b, @1 mval, size_t first, size_t last, size_t *start, size_t *end){
	char *tc, *hc, *hv,*tv, *vtop;
	const int xx= BUNsize(b);
	oid *hdummy, *hd;
	@1  *tdummy, *td;
	int i=0,k=0,n;
	
	/* set bounds for the iterator */
	tc = BUNtloc(b, BUNptr(b,first));
	/* probe */
	hc= hv= tc;
	hv += (last-first)/50*xx;
	while(hc<hv){
		if( *(@1*)hc <= mval )
			i++;
		if( *(@1*)hc >= mval )
			k++;
		hc+= xx;
	}
	n= i>k;

	/* move the smallest portion to the scratch area */
	if( n){
		hd= hdummy= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
		td= tdummy= (ptr) GDKmalloc((last-first+1) *sizeof(@1));

		tc = BUNtloc(b, BUNptr(b,first));
		hc = BUNhloc(b, BUNptr(b,first));
		vtop= BUNtloc(b,BUNptr(b,last));
		while( *(@1*) vtop > mval) vtop -= xx;

		hv= hc;
		tv= tc;

		for( ; tc<=vtop; tc += xx, hc += xx) {
			if (*(@1 *) tc <= mval){
				 *(oid*) hv = *(oid*)hc; hv += xx;
				 *(@1*) tv = *(@1*)tc;   tv += xx;
			} else {
				 *hd++ = *(oid*)hc; 
				 *td++ = *(@1*)tc; 
			} 
		} 
		
		/* group the remainder */
		*start= BUNindex(b, hv);
		*end= BUNindex(b, hv);
		/* collect rest */
		vtop= (char*) hd;
		td= tdummy;
		hd= hdummy;
		for( ; (ptr) hd < (ptr) vtop;  td ++,hd++){
				 *(oid*) hv = *hd; hv += xx;
				 *(@1*) tv = *td;  tv += xx;
		}
	} else {
		hd= hdummy= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
		td= tdummy= (ptr) GDKmalloc((last-first+1) *sizeof(@1));

		/* run backwards */
		tc = BUNtloc(b, BUNptr(b,last));
		hc = BUNhloc(b, BUNptr(b,last));
		vtop= BUNtloc(b,BUNptr(b,first));
		while( *(@1*) vtop <= mval) vtop += xx;
		hv= hc;
		tv= tc;

		for( ; tc>=vtop; tc -= xx, hc -= xx) {
			if (*(@1 *) tc > mval){
				 *(oid*) hv = *(oid*)hc; hv -= xx;
				 *(@1*) tv = *(@1*)tc;   tv -= xx;
			} else {
				 *hd++ = *(oid*)hc; 
				 *td++ = *(@1*)tc; 
			} 
		} 
		
		/* group the remainder */
		*start= BUNindex(b, hv);
		*end= BUNindex(b, hv);
		/* collect rest */
		vtop= (char*) hd;
		td= tdummy;
		hd= hdummy;
		for(; (ptr) hd < (ptr) vtop;  td++,hd++){
				 *(oid*) hv = *hd; hv -= xx;
				 *(@1*) tv = *td;  tv -= xx;
		}
	}
	GDKfree(hdummy); GDKfree(tdummy);
	return MAL_SUCCEED;
}
str
CRKcrackOrderedOne_MK_@1 (int *res, size_t *bid, size_t *mid)
{
	BAT *b;
	str msg;
	size_t start, size;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKOrderedpieceOne_MK_@1( b, *mid, 0, BATcount(b)-1, &start, &size);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
str
CRKcrackOrderedTwo_MK_@1 (int *res, size_t *bid, size_t *mid)
{
	BAT *b;
	str msg= MAL_SUCCEED;
/*
	size_t start=0, size=0;
*/

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	(void) mid;
/*
	msg= CRKOrderedpieceOne_MK_@1( b, *mid, 0, BATcount(b)-1, &start, &size);
*/

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
str
CRKcrackOrderedThree_MK_@1 (int *res, size_t *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg= MAL_SUCCEED;
	int start, size;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKOrderedpieceThree_MK_@1( b, *low, *hgh, 0, BATcount(b)-1, &start, &size);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
str
CRKcrackOrderedZero_MK_@1 (int *res, size_t *bid, size_t *mid)
{
	BAT *b;
	str msg= MAL_SUCCEED;
	size_t start, size;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKOrderedpieceZero_MK_@1( b, *mid, 0, BATcount(b)-1, &start, &size);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}


str
CRKpieceOneA_MK_@1( BAT *b, @1 mval, size_t first, size_t last, size_t *start, size_t *end){
	ptr vm, vl;
	int xx;
	oid hdummy;
	@1 tdummy;
	ptr *base,*bp;

	/* set bounds for the iterator */
	xx = BUNsize(b);
	bp=base = (ptr*) GDKmalloc((last-first+1)*sizeof(ptr));

	vm = BUNtloc(b, BUNptr(b,first));
	vl = BUNtloc(b, BUNptr(b,last));

	while(vl>vm && *(@1 *) vl > mval )
		vl = (ptr) ((char *) vl - xx);
	/* perform Zero crack first */
	while(vm <= vl) {
		if (*(@1 *) vm <= mval){
			if (*(@1 *) vm == mval )
				*bp++ =vm;
			vm = (ptr) ((char *) vm + xx);
		} else {
			@:shuffleMK(@1,vm,vl)@
			vl = (ptr) ((char *) vl - xx);
			while(vl>vm && *(@1 *) vl > mval )
				vl = (ptr) ((char *) vl - xx);
		} 
	} 

/* printf("vl %u vm %d \n",(int)BUNindex(b,(ptr)((char*)vl-b->tloc)), (int) BUNindex(b,(ptr)((char*)vm-b->tloc)));
	BATprint(b); */
	vm = BUNtloc(b, BUNptr(b,first));
	while(vl>vm && *(@1*)vl == mval )
		vl= (ptr) ((char*) vl-xx);

	/* get the equals from the scratch*/
	*end= BUNindex(b,(ptr) ((char *) vl - b->tloc));
	while(bp > base){
		bp--;
		vm= *bp;
		if( vm < vl){
			@:shuffleMK(@1,vm,vl)@
			vl = (ptr) ((char *) vl - xx);
		}
	}

/* printf("vl %u vm %d\n",(int)BUNindex(b,(ptr)((char*)vl-b->tloc)), (int) BUNindex(b,(ptr)((char*)vm-b->tloc))); */
	/* BATprint(b);*/
	*start= BUNindex(b,(ptr) ((char *) vl - b->tloc)) +1;
	GDKfree(base);
	return MAL_SUCCEED;
}

str
CRKcrackOne_MK_@1 (int *res, size_t *bid, size_t *mid)
{
	BAT *b;
	str msg;
	size_t start, size;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKpieceOneA_MK_@1( b, *mid, 0, BATcount(b)-1, &start, &size);
/*
	printf("range %d - %d\n",start,size);
*/

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

str
CRKpieceTwo_MK_@1( BAT *b, @1 low, @1 hgh, int first, int last){
	char *tc, *hc, *hv;
	const int xx= BUNsize(b);
	int i=0,k=0;
	size_t start,end;

	/* set bounds for the iterator */
	tc = BUNtloc(b, BUNptr(b,first));
	/* probe */
	hc= hv= tc;
	hv += (last-first)/50*xx;
	while(hc<hv){
		if( *(@1*)hc <= low )
			i++;
		if( *(@1*)hc > hgh )
			k++;
		hc+= xx;
	}

	if( i>k){
		CRKpieceOneA_MK_@1(b,low,first,last, &start, &end);
		/* printf("start %d end %d\n",(int)start, (int)end);*/
		CRKpieceOneA_MK_@1(b,hgh,(int)(end+1),last, &start, &end);
		/* printf("phase2 start %d end %d\n",(int)start, (int)end);*/
	} else {
		CRKpieceOneA_MK_@1(b,hgh,first,last, &start, &end);
		/* printf("start %d end %d\n",(int)start, (int)end);*/
		CRKpieceOneA_MK_@1(b,low, first,(int)end, &start, &end);
		/* printf("phase2 start %d end %d\n",(int)start, (int)end);*/
	}

	/* BATprint(b);*/
	return MAL_SUCCEED;
}

str
CRKcrackTwo_MK_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;

	if (*(@1 *) low > *(@1 *) hgh)
		return throwMessage("crackers.crack_MK", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL)
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");

	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKpieceTwo_MK_@1( b, *low, *hgh, 0, BATcount(b)-1);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

/* case: <=low, <=hgh, >hgh */
str
CRKpieceThree_MK_@1( BAT *b, @1 low, @1 hgh, int first, int last){
	ptr vm, vl, hmax;
	int xx;
	oid hdummy;
	@1 tdummy;

	/* set bounds for the iterator */
	xx = BUNsize(b);

	vm = BUNtloc(b, BUNptr(b,first));
	hmax = BUNtloc(b,BUNptr(b,last));
	while( *(@1 *) hmax > hgh && hmax>vm)
		hmax= (ptr)((char*) hmax - xx);
	vl =hmax;
	while( *(@1 *) vl > low && vl>vm){
		/* move all high values into their final place */
		if( *(@1 *) vl > hgh){
			@:shuffleMK(@1,vl,hmax)@
			hmax= (ptr)((char*) hmax - xx);
		}
		vl= (ptr)((char*) vl - xx);
	}
	/* vl point to the first <=low, all values >hg are beyond hmax */

	/* perform Zero crack first */
	while(vm<=vl) {
		if (*(@1 *) vm <= low){
			vm = (ptr) ((char *) vm + xx);
		} else {
			@:shuffleMK(@1,vm,vl)@
			while( *(@1 *) vl > low && vl>vm){
				if( *(@1*) vl > hgh ){
					@:shuffleMK(@1,vl,hmax)@
					hmax= (ptr)((char*) hmax - xx);
				}
				vl = (ptr) ((char *) vl - xx);
			}
		} 
	} 

	return MAL_SUCCEED;
}
/* handle <=low, low<tail<=hgh, >hgh */
str
CRKcrackThree_MK_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;

	if (*(@1 *) low > *(@1 *) hgh)
		return throwMessage("crackers.crack_MK", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL)
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");

	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKpieceThree_MK_@1( b, *low, *hgh, 0, BATcount(b)-1);


	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}


@


@= SMsm_piece_
@:SMsm_piece_Zero@4(@1,@2,@3,@4)@
@:SMsm_piece_One@4(@1,@2,@3,@4)@
@:SMsm_piece_Two(@1,@2,@3,@4)@
@:SMsm_piece_Three@4(@1,@2,@3,@4)@
@
@= SMsm_crack_
@:SMsm_crack_ZeroOne(@1,@2,Zero,z,@3)@
@:SMsm_crack_ZeroOne(@1,@2,One,,@3)@
@:SMsm_crack_TwoThree(@1,@2,Two,,@3)@
@:SMsm_crack_TwoThree(@1,@2,Three,z,@3)@
@
@= SMsm_operations
@:SMsm_split_in_two(@1,@2,@3,LT,GE,,l,)@
@:SMsm_split_in_two(@1,@2,@3,LE,GT,,g,)@
@:SMsm_split_in_two(@1,@2,@3,LT,GE,EQ,l,*_eq = eq;)@
@:SMsm_split_in_two(@1,@2,@3,LE,GT,EQ,g,*_eq = eq;)@
@:SMsm_piece_(@1,@2,@3,)@
@:SMsm_piece_(@1,@2,@3,Ordered)@
@:SMsm_crack_(@1,@2,)@
@:SMsm_crack_(@1,@2,Ordered)@
@
@c
#define LT	<
#define LE	<=
#define GE	>=
#define GT	>
#define BUNho(b)
#define TAILho(b)	int ho = b->hloc - b->tloc
#define TAILhloc(b,p)	((p) + ho)
#define TAILtloc(b,p)	(p)
#define TAILindex(b,p)	BUNindex(b, (p) - b->tloc)
#define TAILptr(b,i)	BUNtloc(b, BUNptr(b, i))
#define SIG_(x,y,z)
#define SIG_EQ(x,y,z)	x,y,z
#define IF_LT_(x)
#define IF_LE_(x)
#define IF_GE_(x)
#define IF_GT_(x)
#define IF_LT_EQ(x)
#define IF_LE_EQ(x)	x
#define IF_GE_EQ(x)	x
#define IF_GT_EQ(x)
@

@= SMsm_swapTwoBUNs
{
	oid *h1 = (oid*)@2;
	@1  *t1 = (@1 *)@3;
	oid *h2 = (oid*)@4;
	@1  *t2 = (@1 *)@5;
	oid h   = *h1;
	@1  t   = *t1;
	*h1     = *h2;
	*t1     = *t2;
	*h2     = h;
	*t2     = t;
}
@

@= SMsm_split_in_two_advance
	/* advance cursors, skipping over BUNs that are already in the right place */
	while (@6 *(@1*)@2tloc(b, bn_l) @3 mid) {
		IF_@3_@5(if (*(@1*)@2tloc(b, bn_l) == mid) { *eq++ = bn_l; })
		bn_l += bs;
	}
	while (@6 *(@1*)@2tloc(b, bn_g) @4 mid) {
		IF_@4_@5(if (*(@1*)@2tloc(b, bn_g) == mid) { *eq++ = bn_g; })
		bn_g -= bs;
	}
@
@= SMsm_split_in_two
static str
CRKsplit_@2_@1_@4_@5_@6 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lg  SIG_@6(, BUN *eq, BUN **_eq))
{
	/* initialization */
	@3ho(b);
	int bs = BUNsize(b);
	BUN bn_l = @3ptr(b, fst);
	BUN bn_g = @3ptr(b, lst);

	/* advance cursors, skipping over BUNs that are already in the right place */
	@:SMsm_split_in_two_advance(@1,@3,@4,@5,@6,bn_l <= bn_g &&)@

	/* re-shuffel BUNs */
	while (bn_l < bn_g) {
		/* swap BUNs */
		@:SMsm_swapTwoBUNs(@1,@3hloc(b, bn_g),@3tloc(b, bn_g),@3hloc(b, bn_l),@3tloc(b, bn_l))@
		
		/* advance cursors, skipping over BUNs that are already in the right place */
		@:SMsm_split_in_two_advance(@1,@3,@4,@5,@6,)@
	}
	*lg = @3index(b, bn_@7);
	@8

	/* final sanity check */
	assert(bn_l >= bn_g);
	return MAL_SUCCEED;
}
@

@= SMsm_piece_Zero
static str
CRKpiece@4Zero_@2_@1 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lt, size_t *gt)
{
	*lt=0;
	return CRKsplit_@2_@1_LE_GT_ (b, mid, fst, lst, gt);
}
@

@= SMsm_piece_OneTwo_EQ
	bn = @2ptr(b, @3);
	while (eq-- > equal) {
		if (*eq != bn) {
			@:SMsm_swapTwoBUNs(@1,@2hloc(b, bn),@2tloc(b, bn),@2hloc(b, *eq),@2tloc(b, *eq))@
		}
		bn @5 bs;
	}
	@4 = @2index(b, bn);
@
@= SMsm_piece_One
static str
CRKpiece@4One_@2_@1 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lt, size_t *gt)
{
	str msg;
	@3ho(b);
	int bs = BUNsize(b);
	BUN bn, *eq, *equal = (BUN*)GDKmalloc(((lst-fst)+1)*sizeof(BUN));

	if (!equal) {
		return throwMessage("CRKpiece@4One_@2_@1","GDKmalloc failed");
	}
	msg = CRKsplit_@2_@1_LT_GE_EQ (b, mid, fst, lst, lt, equal, &eq);
	if (msg != MAL_SUCCEED) {
		return msg;
	}
	@:SMsm_piece_OneTwo_EQ(@1,@3,*lt,*gt,+=)@

	GDKfree(equal);
	return msg;
}
@

@= SMsm_piece_TwoThree_skip
	/* advance cursors, skipping over BUNs that are already in the right place */
	/* initialization */
	BUN bn_l = @2ptr(b, fst);
	BUN bn_g = @2ptr(b, lst);
	while (bn_l < bn_g && *(@1*)@2tloc(b, bn_l) @3 low) {
		bn_l += bs;
	}
	while (bn_l < bn_g && *(@1*)@2tloc(b, bn_g) @4 hgh) {
		bn_g -= bs;
	}
	fst = @2index(b, bn_l);
	lst = @2index(b, bn_g);
@

@= SMsm_piece_Two
static str
CRKpiece@4Two_@2_@1 (BAT *b, @1 low, @1 hgh, size_t fst, size_t lst, size_t *ltl, size_t *gtl, size_t *lth, size_t *gth)
{
	str msg;
	@3ho(b);
	int bs = BUNsize(b);
	BUN bn, *eq, *equal;

	@:SMsm_piece_TwoThree_skip(@1,@3,<,>)@

	equal = (BUN*)GDKmalloc(((lst-fst)+1)*sizeof(BUN));

	if (!equal) {
		return throwMessage("CRKpiece@4Two_@2_@1","GDKmalloc failed");
	}
	msg = CRKsplit_@2_@1_LT_GE_EQ (b, low, fst, lst, ltl, equal, &eq);
	if (msg != MAL_SUCCEED) {
		return msg;
	}
	@:SMsm_piece_OneTwo_EQ(@1,@3,*ltl,*gtl,+=)@
	msg = CRKsplit_@2_@1_LT_GE_EQ (b, hgh, *gtl, lst, lth, equal, &eq);
	if (msg != MAL_SUCCEED) {
		return msg;
	}
	@:SMsm_piece_OneTwo_EQ(@1,@3,*lth,*gth,+=)@

	GDKfree(equal);
	return msg;
}
@

@= SMsm_piece_Three
static str
CRKpiece@4Three_@2_@1 (BAT *b, @1 low, @1 hgh, size_t fst, size_t lst, size_t *ltl, size_t *gtl, size_t *lth, size_t *gth)
{
	str msg;
	int bs = BUNsize(b);

	@:SMsm_piece_TwoThree_skip(@1,@3,<=,>)@

	*ltl=0;
	msg = CRKsplit_@2_@1_LE_GT_ (b, low, fst, lst, gtl);
	if (msg != MAL_SUCCEED) {
		return msg;
	}
	*lth=0;
	return CRKsplit_@2_@1_LE_GT_ (b, hgh, *gtl, lst, gth);
}
@

@= SMsm_piece_ZeroOrdered
static str
CRKpiece@4Zero_@2_@1 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lt, size_t *gt)
{
	@3ho(b);
	int bs = BUNsize(b);
	BUN r = @3ptr(b, fst);
	BUN w = @3ptr(b, fst);
	BUN q = @3ptr(b, lst);
	size_t n = (lst - fst) + 1, GTm_i = 0;
	oid *buf_h;
	@1  *buf_t;

	buf_h = (oid*) GDKmalloc(n * sizeof(oid));
	buf_t = (@1 *) GDKmalloc(n * sizeof(@1 ));
	for (;r <= q; r += bs) {
		if (*(@1*)@3tloc(b, r) <= mid) {
			*(oid*)@3hloc(b, w) = *(oid*)@3hloc(b, r);
			*(@1 *)@3tloc(b, w) = *(@1 *)@3tloc(b, r);
			w += bs;
		}
		if (*(@1*)@3tloc(b, r) > mid) {
			buf_h[GTm_i] = *(oid*)@3hloc(b, r);
			buf_t[GTm_i] = *(@1 *)@3tloc(b, r);
			GTm_i++;
		}
	}
	for (n = 0; n < GTm_i; n++, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	*lt = 0;
	*gt = lst + GTm_i;

	GDKfree(buf_h);
	GDKfree(buf_t);
	return MAL_SUCCEED;
}
@

@= SMsm_piece_OneOrdered
static str
CRKpiece@4One_@2_@1 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lt, size_t *gt)
{
	@3ho(b);
	int bs = BUNsize(b);
	BUN r = @3ptr(b, fst);
	BUN w = @3ptr(b, fst);
	BUN q = @3ptr(b, lst);
	size_t n = (lst - fst) + 1, EQm_i = n, GTm_i = 0;
	oid *buf_h;
	@1  *buf_t;

	buf_h = (oid*) GDKmalloc(n * sizeof(oid));
	buf_t = (@1 *) GDKmalloc(n * sizeof(@1 ));
	for (;r <= q; r += bs) {
		if (*(@1*)@3tloc(b, r) < mid) {
			*(oid*)@3hloc(b, w) = *(oid*)@3hloc(b, r);
			*(@1 *)@3tloc(b, w) = *(@1 *)@3tloc(b, r);
			w += bs;
		}
		if (*(@1*)@3tloc(b, r) == mid) {
			EQm_i--;
			buf_h[EQm_i] = *(oid*)@3hloc(b, r);
			buf_t[EQm_i] = *(@1 *)@3tloc(b, r);
		}
		if (*(@1*)@3tloc(b, r) > mid) {
			buf_h[GTm_i] = *(oid*)@3hloc(b, r);
			buf_t[GTm_i] = *(@1 *)@3tloc(b, r);
			GTm_i++;
		}
	}
	for (n--; n >= EQm_i; n--, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	for (n = 0; n < GTm_i; n++, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	*gt = lst - GTm_i;
	*lt = *gt - EQm_i + 1;

	GDKfree(buf_h);
	GDKfree(buf_t);
	return MAL_SUCCEED;
}
@

@= SMsm_piece_ThreeOrdered
static str
CRKpiece@4Three_@2_@1 (BAT *b, @1 low, @1 hgh, size_t fst, size_t lst, size_t *ltl, size_t *gtl, size_t *lth, size_t *gth)
{
	@3ho(b);
	int bs = BUNsize(b);
	BUN r = @3ptr(b, fst);
	BUN w = @3ptr(b, fst);
	BUN q = @3ptr(b, lst);
	size_t n = (lst - fst) + 1, LEh_i = n, GTh_i = 0;
	oid *buf_h;
	@1  *buf_t;

	buf_h = (oid*) GDKmalloc(n * sizeof(oid));
	buf_t = (@1 *) GDKmalloc(n * sizeof(@1 ));
	for (;r <= q; r += bs) {
		if (*(@1*)@3tloc(b, r) <= low) {
			*(oid*)@3hloc(b, w) = *(oid*)@3hloc(b, r);
			*(@1 *)@3tloc(b, w) = *(@1 *)@3tloc(b, r);
			w += bs;
		} else
		if (*(@1*)@3tloc(b, r) <= hgh) {
			LEh_i--;
			buf_h[LEh_i] = *(oid*)@3hloc(b, r);
			buf_t[LEh_i] = *(@1 *)@3tloc(b, r);
		}
		if (*(@1*)@3tloc(b, r) > hgh) {
			buf_h[GTh_i] = *(oid*)@3hloc(b, r);
			buf_t[GTh_i] = *(@1 *)@3tloc(b, r);
			GTh_i++;
		}
	}
	for (n--; n >= LEh_i; n--, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	for (n = 0; n < GTh_i; n++, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	*ltl = 0;
	*lth = 0;
	*gth = lst - GTh_i;
	*gtl = *gth - LEh_i + 1;

	GDKfree(buf_h);
	GDKfree(buf_t);
	return MAL_SUCCEED;
}
@

@= SMsm_crack_ZeroOne
str
CRKcrack@5@3_@2_@1 (int *res, int *bid, @1 *mid)
{
	BAT *b;
	str msg;
	size_t fst, lst, lt, gt;

	/* initialization */
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.@4crack@5_SM", "Cannot access descriptor");
	}
	fst = BUNindex(b, BUNfirst(b));
	lst = BUNindex(b, BUNlast (b)) - 1;

	msg = CRKpiece@5@3_@2_@1(b, *mid, fst, lst, &lt, &gt);
	(void)lt;
	(void)gt;

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
@

@= SMsm_crack_TwoThree
str
CRKcrack@5@3_@2_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;
	size_t fst, lst, ltl, gtl, lth, gth;

	/* initialization */
	if (*low > *hgh)
		return throwMessage("crackers.@4crack@5_SM", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.@4crack@5_SM", "Cannot access descriptor");
	}
	fst = BUNindex(b, BUNfirst(b));
	lst = BUNindex(b, BUNlast (b)) - 1;

	msg = CRKpiece@5@3_@2_@1(b, *low, *hgh, fst, lst, &ltl, &gtl, &lth, &gth);
	(void)ltl;
	(void)gtl;
	(void)lth;
	(void)gth;

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
@
Stratos's masterpiece

@= moveOrdered
	while (@1){
		@2 @4= xx;
		@3 @4= xx;
		@5
	}
@

@= OThree
	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)ct @5){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
		
		}
		else{
			scr_h[mids] = *(oid*)tmph;
			scr_t[mids] = *(@1* )tmpt;				
			mids--;	
		}
		tmpt @2= xx;
		tmph @2= xx;
		while (tmpt @3 ht && *(@1*)tmpt @5){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	tmph = hh;
	tmpt = ht;
	ct @2= xx*((scrH-mids)+hil);
	for(; tmpt @7 ct; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
	}
	int i;
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}
	i = mids + 1;
	for (; i <= scrH; i++){
		 if (*(@1*)tmpt @5){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
@

@= crackInThreeOrderedPiecesII
str
CRKcrackOrderedTHREE_is_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last)
{
	BUN hh, ht, tmpt, tmph;
	oid *scr_h;
	@1  *scr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @4 low,tmph,tmpt,+,lowShrinked++;)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	int scrH = scr_size-1;	
	int hil = 0, mids = scrH;
	BUN ch = tmph, ct = tmpt; 
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	int probe = 25;
	BUN t = tmpt, s = tmpt+(2*probe*xx);
	int j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;

	if (j > probe){
		ch = tmph; ct = tmpt; 
		@:OThree(@1,+,<=,@4 low,@7 hgh,-,>=)@
	}
	else{  
		ch = hh; ct = ht; 
		BUN fh = tmph, ft = tmpt;
		tmph = hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OThree(@1,-,>=,@7 hgh,@4 low,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}
str
CRKcrackOrderedTHREELateCopying_is_@2_@3_@1(BAT *b, @1 low, @1 hgh, lng idx_first, lng idx_last, lng *posl, lng *posh)
{
	BUN lh, lt, hh, ht, tmpt, tmph;
	oid *scr_h,*mscr_h;
	@1  *scr_t,*mscr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @4 low,lh,lt,+,lowShrinked++;)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;)@

	/*These are different cases. For now just make sure that the result will be empty.
		todo: when the index will learn from empty results return the appropriate information*/
	
	if (lowShrinked == scr_size) {
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == scr_size){
		*posl =  1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	/*Middle piece is empty and lt = ht + 1*/
	if (lowShrinked + hghShrinked == scr_size){
		*posl =  BUNindex(b,lt);
		*posh =  BUNindex(b,ht);
		return MAL_SUCCEED;
	}

	int scrH = scr_size-1;	
	int hp = 0, hil = 0, mids = scrH, mmids = 0;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	mscr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	mscr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	int probe = 100;
	BUN t = lt, s = lt+(2*probe*xx);
	int j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;
	lng pos1, pos2;
	if (j > probe){
		tmph = lh;
		tmpt = lt;	
		@:OThreeLateCopying(@1,+,<=,@4 low,@7 hgh,-,>=,@5,@6)@
		*posl = pos1;
		*posh = pos2;
	}
	else{  
		tmph = hh;
		tmpt = ht;	
		BUN fh = lh, ft = lt;
		lh = hh; lt = ht;
		hh = fh; ht = ft;
		@:OThreeLateCopying(@1,-,>=,@7 hgh,@4 low,+,<=,@5,@6)@
		*posl = pos2;
		*posh = pos1;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@
@= OThreeLateCopying
	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	BUN tmp1 = lt, tmp2;
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)lt @5){
				scr_h[hil] = *(oid*)lh;
				scr_t[hil] = *(@1* )lt;				
				hil++;	
			}
			if (*(@1*)lt @8 low && *(@1*)lt @9 hgh){
				scr_h[mids] = *(oid*)lh;
				scr_t[mids] = *(@1* )lt;				
				mids--;	
			}
			*(oid*)lh = *(oid*)tmph;
			*(@1 *)lt = *(@1 *)tmpt;
			lh @2= xx;
			lt @2= xx;
		}
		hp++;
		tmpt @2= xx;
		tmph @2= xx;
		while (*(@1*)tmpt @5){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	
	pos1 = BUNindex(b,lt);

	tmph = hh;
	tmpt = ht;
	tmp2 = lt;
	tmp1 @2= xx*(hp+hil);
	for(; tmpt @7 tmp1; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
	}
	int i;
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}

	pos2 = BUNindex(b,tmpt);

	i = 0;
	for (; i < mmids; i++){
		 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = mscr_h[i];
		*(@1 *)tmpt = mscr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
	tmp2 @2= xx*(scrH-mids);
	/*todo check as in the zero case*/
	BUN mh= tmph, mt = tmpt;
	for(; tmpt @7 tmp2; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			if (mt != tmpt){
				*(oid*)mh = *(oid*)tmph;
                        	*(@1 *)mt = *(@1 *)tmpt;
			}
                        mh @6= xx;
                        mt @6= xx;
		}
	}

        i = mids+1;
        for (; i <= scrH; i++){
                 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
                if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
	        	*(oid*)mh = *(oid*)tmph;
                        *(@1 *)mt = *(@1 *)tmpt;
                        mh @6= xx;
                        mt @6= xx;
                }
                *(oid*)tmph = scr_h[i];
                *(@1 *)tmpt = scr_t[i];
                tmph @6= xx;
                tmpt @6= xx;
        }
@
@= OrderedZero
		while (tmpt @3 ht){ 
			while (*(@1*)tmpt @4 mid){
				tmpt @2=xx;
				tmph @2=xx;
			}
			if (*(@1*)ct @4 mid){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
			
			tmpt @2= xx;
			tmph @2= xx;
		}
		tmph @5= 2*xx;
		tmpt @5= 2*xx;
	
		/* Take the position where the last BUN of the left piece is. */
		*pos = BUNindex(b,ct @7);

		ct  @2= xx*hil;
		/*Extreme case that all lows where in the hgh partition (or opposite depending how we move) */
		if (ct @6 tmpt @2 xx){
			for (int i=hil-1; i >=0 ; i--){
				*(oid*)hh = scr_h[i];
				*(@1 *)ht = scr_t[i];
				ht @5= xx;
				hh @5= xx;
			}
			return MAL_SUCCEED;
		}

		for(; tmpt @6 ct; tmph @5=xx, tmpt @5=xx){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}
		}
		for (int i=hil-1; i >=0 ; i--){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}	
			*(oid*)tmph = scr_h[i];
			*(@1 *)tmpt = scr_t[i];
			tmpt @5= xx;
			tmph @5= xx;
		}
@
@= crackInTwoOrderedPiecesII
str
CRKcrackOrderedZERO_is_@2_@1(BAT *b, @1 mid, lng idx_first, lng idx_last, lng *pos)
{
	BUN hh, ht, tmpt, tmph;
	oid *scr_h;
	@1  *scr_t;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @3 mid,tmph,tmpt,+,lowShrinked++;)@
	@:moveOrdered(*(@1*)ht @4 mid,hh,ht,-,hghShrinked++;)@

	if (lowShrinked == idx_last - idx_first +1) {
			*pos = idx_last+1;
			return MAL_SUCCEED;
	}
	if (hghShrinked == idx_last - idx_first +1){
			*pos = idx_first-1;
			return MAL_SUCCEED;
	}
	
	if (ht == tmpt + xx){
		oid dh = *(oid*)tmph;
		@1  dt = *(@1 *)tmpt;
		*(oid*)tmph = *(oid*)hh;
		*(@1 *)tmpt = *(@1 *)ht;

		*pos = BUNindex(b,tmpt);

		*(oid*)hh = dh;
		*(@1 *)ht = dt;

		return MAL_SUCCEED;
	}	

	int hil = 0;
	BUN ch, ct; 
	int scr_size = (idx_last - idx_first +1 -lowShrinked -hghShrinked)/2;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	int probe = 25;
	BUN t = tmpt, s = tmpt+(2*probe*xx);
	int j=0;
	for (;t<s;t+=xx)
		j+=*(@1*)t @3 mid;
	
	if (j > probe){
		ch = tmph; ct = tmpt; 
		@:OrderedZero(@1,+,<=,@4,-,>=, -xx)@
	}
	else{
		ch =hh; ct = ht; 
		BUN fh = tmph, ft = tmpt;
		tmph =hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OrderedZero(@1,-,>=,@3,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@
@= SI_operations
@:crackInTwoOrderedPiecesII(@1,LE,<=,>)@
@:crackInTwoOrderedPiecesII(@1,RE,<,>=)@
@:crackInThreeOrderedPiecesII(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeOrderedPiecesII(@1,LE,RE,<,>=,<=,>)@
@:crackInThreeOrderedPiecesII(@1,LO,RO,<=,>,<,>=)@
@:crackInThreeOrderedPiecesII(@1,LE,RO,<,>=,<,>=)@

str             
CRKcrackOrderedZero_is_@1 (int *res, int *bid, @1 *mid)
{       
        BAT *b;
        str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crack_SI", "Cannot access descriptor");
        }
	lng pos;
        msg= CRKcrackOrderedZERO_is_LE_@1(b,*mid, 0, BATcount(b)-1,&pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;    
        return msg;             
}  


str             
CRKcrackOrderedOne_is_@1 (int *res, int *bid, @1 *mid)
{       
        BAT *b;
	str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crack_SI", "Cannot access descriptor");
        }
	msg= CRKcrackOrderedTHREE_is_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);
        BBPkeepref(b->batCacheid);
        *res = *bid;    
        return msg;             
}  

str
CRKcrackOrderedTwo_is_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;

	if (*(@1 *) low > *(@1 *) hgh)
		return throwMessage("crackers.crack_SI", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return MAL_SUCCEED;
}

str
CRKcrackOrderedThree_is_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}
	lng posl,posh;
        msg= CRKcrackOrderedTHREELateCopying_is_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1,&posl, &posh);
	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

@
@

@= validate_operations
@:validate_operation_Zero(@1,@2)@
@:validate_operation_One(@1,@2)@
@:validate_operation_Two(@1,@2)@
@:validate_operation_Three(@1,@2)@
@
@= validate_init_1
	BAT *b,*c,*w;
	BUN fst_bn, lst_bn, bn;
	int bs;
	size_t count[6] = {0,0,0,0,0,0};

	/* initialization */
	*res = FALSE;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.@3crack_validate", "Cannot access descriptor");
	}
	bs = BUNsize(b);
	fst_bn = BUNfirst(b);
	lst_bn = BUNlast(b);
	bn = fst_bn;
@
@= validate_init_2
	if (low > hgh) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.@3crack_validate", "illegal range");
	}
@
@= validate_check
	while (bn < lst_bn @3 @4 ) {
		bn += bs;
		count[@2]++;
	}
@
@= validate_checkOrdered
{	oid hd = 0;
	while (bn < lst_bn && hd <= *(oid*)BUNhloc(b, bn) @3 @4 ) {
		hd = *(oid*)BUNhloc(b, bn);
		bn += bs;
		count[@2]++;
}	}
@
@= validate_check_1
	@:validate_check@1(,@3, && *(@2*)BUNtloc(b, bn) @4 @5 )@
@
@= validate_check_2
	@:validate_check@1(,@3, && *(@2*)BUNtloc(b, bn) @4 @5 , && *(@2*)BUNtloc(b, bn) @6 @7 )@
@
@= validate_end
	count[0] = BATcount(b);
	if (bn < lst_bn) {
		@4;
		c = BATslice(b, BUNindex(b, fst_bn), BUNindex(b, bn));
		w = BATslice(b, BUNindex(b, bn), BUNindex(b, lst_bn));
		printf("correct:\n");
		BATprint(c);
		printf("wrong:\n");
		BATprint(w);
		BBPunfix(w->batCacheid);
		BBPunfix(c->batCacheid);
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.@3crack_validate", "Invalid crack");
	}
	assert(bn == lst_bn);
	assert(count[0] == count[1] + count[2] + count[3] + count[4] + count[5]);
	BBPunfix(b->batCacheid);
	*res = TRUE;
	return MAL_SUCCEED;
@
@= validate_operation_Zero
str
CRKcrack@1Zero_validate_@2 (bit *res, int *bid, @2 *_mid)
{
	@2 mid=*_mid;
	@:validate_init_1(@1,@2,z)@

	@:validate_check_1(@1,@2,1,<=,mid)@
	@:validate_check_1(@1,@2,2,> ,mid)@

	@:validate_end(@1,@2,z,\
		printf("|b|="SZFMT" ; |tail<=%d|="SZFMT", |tail>%d|="SZFMT" !\n",\
		       count[0], mid, count[1], mid, count[2]);\
	)@
}
@
@= validate_operation_One
str
CRKcrack@1One_validate_@2 (int *res, int *bid, @2 *_mid)
{
	@2 mid=*_mid;
	@:validate_init_1(@1,@2,)@

	@:validate_check_1(@1,@2,1,< ,mid)@
	@:validate_check_1(@1,@2,2,==,mid)@
	@:validate_check_1(@1,@2,3,> ,mid)@
	
	@:validate_end(@1,@2,,\
		printf("|b|="SZFMT" ; |tail<%d|="SZFMT", |tail==%d|="SZFMT", |tail>%d|="SZFMT" !\n",\
		       count[0], mid, count[1], mid, count[2], mid, count[3]);\
	)@
}
@
@= validate_operation_Two
str
CRKcrack@1Two_validate_@2 (bit *res, int *bid, @2 *_low, @2 *_hgh)
{
	@2 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,@2,)@
	@:validate_init_2(@1,@2,)@

	@:validate_check_1(@1,@2,1,< ,low)@
	@:validate_check_1(@1,@2,2,==,low)@
	@:validate_check_2(@1,@2,3,> ,low,< ,hgh)@
	@:validate_check_1(@1,@2,4,==,hgh)@
	@:validate_check_1(@1,@2,5,> ,hgh)@

	@:validate_end(@1,@2,,\
		printf("|b|="SZFMT" ; |tail<%d|="SZFMT", |tail==%d|="SZFMT", |%d<tail<%d|="SZFMT", |tail==%d|="SZFMT", |tail>%d|="SZFMT" !\n",\
		       count[0], low, count[1], low, count[2], low, hgh, count[3], hgh, count[4], hgh, count[5]);\
	)@
}
@
@= validate_operation_Three
str
CRKcrack@1Three_validate_@2 (bit *res, int *bid, @2 *_low, @2 *_hgh)
{
	@2 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,@2,z)@
	@:validate_init_2(@1,@2,z)@

	@:validate_check_1(@1,@2,1,<=,low)@
	@:validate_check_1(@1,@2,2,<=,hgh)@
	@:validate_check_1(@1,@2,3,> ,hgh)@

	@:validate_end(@1,@2,z,\
		printf("|b|="SZFMT" ; |tail<=%d|="SZFMT", |%d<tail<=%d|="SZFMT", |tail>%d|="SZFMT" !\n",\
		       count[0], low, count[1], low, hgh, count[2], hgh, count[3]);\
	)@
}
@

@c
@:validate_operations(,int)@
@:validate_operations(Ordered,int)@

@:MK_operations(int)@

@:SMsm_operations(int,SM,BUN)@
@:SMsm_operations(int,sm,TAIL)@
@:SI_operations(int)@
@}
@-
This function takes a range and returns a view with the result. To do that, we first search the index to determine which parts of the result we already 
know and which parts we have to crack. Then we crack, if necessary, 
the appropriate pieces, update the index and return the result.

@= crkThree
/*printf("crack in three pieces\n");*/
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE){
		CRKcrackOrderedTHREELateCopying_is_LE_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = -(vl-1); i2 = vh;
	}
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE){
		CRKcrackOrderedTHREELateCopying_is_LE_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = -(vl-1); i2 = -vh;
	}
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE){
		CRKcrackOrderedTHREELateCopying_is_LO_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = vl-1; i2 = vh;
	}
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE){
		CRKcrackOrderedTHREELateCopying_is_LO_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = vl-1; i2 = -vh;
	}
				
	if (vl == -1){ /*middle and right pieces are empty*/
		if (*inclusiveLow == TRUE) i1 = -@3;
		else i1 = @3;
		addOne_@1(m,low,i1,posA);
	}else
	if (vh == -1){ /*left and middle pieces are empty*/
		if (*inclusiveHgh == TRUE) i2 = @2;
		else i2 = -@2;
		addOne_@1(m,hgh,i2,posB);
	}else
		/*The following adds also gaps in the index in the cases where epmty piece
		is the right, the left or the middle. In the latter case vl is always vh+1
		and the index we want for both is vh*/
		addTwo_@1(m,low,i1,posA,hgh,i2,posB);

@= crkTwoL
/*printf("crack in two pieces\n");*/
	h1 = l + xx;
	if (h1 == BUNlast(c)){
		h1 = BUNlast(b) - BUNsize(b);
		ch1 = BUNindex (b, h1);	
	}
	else{ 
		ch1 = *(lng*)BUNhloc(c, h1);
		if (ch1 < 0) ch1 = ch1 - 2*ch1;
	}
	@:twoL(@1)@

@= crkTwoLFirst
	h1 = BUNlast(b) - BUNsize(b);
	ch1 = BUNindex (b, h1);	
	@:twoL(@1)@

@= twoL
	/*CRACK in two pieces cl-ch1 using >incLow bound*/
	if (*inclusiveLow == TRUE) {
		CRKcrackOrderedZERO_is_RE_@1(b,*low, cl, ch1,&vl);
		i1 = - vl;
	}
	else {
		CRKcrackOrderedZERO_is_LE_@1(b,*low, cl, ch1,&vl);
		i1 = vl;
	}
	if (vl < cl){
		/*then the left piece is empty*/
		if (*inclusiveLow == TRUE) i1 = -cl;
		else i1 = cl;
	}
	if (vl > ch1){
		/*then the right piece is empty*/
		vl--;
		if (*inclusiveLow == TRUE) i1 = -ch1;
		else i1 = ch1;
	}

	vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
		Instead we want the first bun of the right piece*/

@= crkTwoR
	if (h == BUNfirst(c))
		cl2 = BUNindex(b,  BUNfirst(b));	
	else{
		cl2 = *(lng*)BUNhloc(c, h-xx);
	        if (cl2 < 0) cl2 = cl2 - 2*cl2;
		cl2++;
	}
	@:twoR(@1)@

@= crkTwoRFirst
	cl2 = BUNindex(b,  BUNfirst(b));
	@:twoR(@1)@

@= twoR
/*printf("crack in two pieces\n");*/
	/*CRACK in two pieces cl2-ch using <incHgh bound*/
	if (*inclusiveHgh == TRUE){ 
		CRKcrackOrderedZERO_is_LE_@1(b,*hgh, cl2, ch,&vh);
		i2 = vh;
	}
	else{ 
		CRKcrackOrderedZERO_is_RE_@1(b,*hgh, cl2, ch,&vh);
		i2 = -vh;
	}

	/*check for gaps*/
	if (vh < cl2){
		/*then the left piece is empty*/
		if (*inclusiveHgh == TRUE) i2 = cl2;
		else i2 = -cl2;
	}
	if (vh > ch){
		/*then the right piece is empty*/
		vh--;
		if (*inclusiveHgh == TRUE) i2 = ch;
		else i2 = -ch;
	}

@= searchForLow
	l = SORTfndfirst_@1(c,low);
	lt = BUNtloc(c, l);
	lh = BUNhloc(c, l);
	posA = l;	

	/* if all indices contain values smaller than low, crack the area 
		between the last index and the last BUN of the cracked bat */
	if (l == BUNlast(c)){
		l -= xx; lt -= xx; lh -= xx; 
		if  (*(lng*)lh > 0)
			cl = *(lng*)lh;
		else
			cl = *(lng*)lh - 2*(*(lng*)lh);
		cl++;
	} else
	if (*(@1*)lt == *low){
		/* The first two cases are when the low bound already 
			exists in the index */
		if  (*(lng*)lh < 0 && *inclusiveLow == TRUE)
			vl = (*(lng*)lh - 2*(*(lng*)lh))+1;
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == FALSE)
			vl = *(lng*)lh+1;

		/* We want values that the previous index has; 
		   special case when there is no previous index */
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == TRUE){
			if (l == BUNfirst(c)){
				l  -= xx; 
				cl = BUNindex(b, BUNfirst(b));
			}else{
				l  -= xx; lh -= xx; lt -= xx;
				if  (*(lng*)lh > 0)
					cl = *(lng*)lh;
				else
					cl = *(lng*)lh - 2*(*(lng*)lh);
				cl++;
			}
		}else
		if  (*(lng*)lh < 0 && *inclusiveLow == FALSE){
		/*  This index contains values that we do not want (the equals to 
			low) so we check the next one. If it is equal to low then 
			this is an exact match, otherwise we have to crack. 
			Also if this was the last index we have to crack anyway. */
			lt += xx;
			l  +=xx;
			if (*(@1*)lt == *low && l != BUNlast(c)){
				lh += xx;
				vl = *(lng*)lh+1;
			}else{
				lt -= xx;
				l  -= xx;
				cl = (*(lng*)lh - 2*(*(lng*)lh))+1;
			}
		}
	}else{ 
		/* No exact match was found so we have to crack. Take the 
		   previous index because this one is higher than low.
		   If there is no previous index, crack the bat from the beginning. */
		if (l == BUNfirst(c)){
			l  -= xx; lh -= xx; lt -= xx;
			cl = BUNindex(b, BUNfirst(b));
		}else{
			l  -= xx; lh -= xx; lt -= xx;
			if  (*(lng*)lh > 0)
				cl = *(lng*)lh;
			else
				cl = *(lng*)lh - 2*(*(lng*)lh);
			cl++;
		}
	}	

@= searchForGapsLow
	/*check for empty pieces after l*/	
	lhnext = lh + xx;
	gf = 0;	
	while(1){
		
		if ( *(lng*)lhnext == cl || 
			( *(lng*)lhnext < 0 && *(lng*)lhnext - 2*(*(lng*)lhnext) == cl ) ){ 
			gf = 1;
			l += xx; lt += xx; lh += xx;
			lhnext += xx;
		}
		else break;
	}
	if (gf == 1){
		if (*(@1*)lt > *hgh){
			vl =  1;
			vh = -1;
			goto createView;
		}
		else
		if (*(@1*)lt == *hgh){
			if  (*(lng*)lh < 0) vl = *(lng*)lh - 2*(*(lng*)lh);
			else vl = *(lng*)lh;
			vh =  vl;
			goto createView;
		}
		else{
			if  (*(lng*)lh < 0) vl = *(lng*)lh - 2*(*(lng*)lh);
			else vl = *(lng*)lh;
			cl = -1;
		}
	}

@= searchForHgh
	h = SORTfndfirst_@1(c,hgh);
	ht = BUNtloc(c, h);
	hh = BUNhloc(c, h);
	posB = h;	

	if (h == BUNlast(c))
		ch = BUNindex(b, BUNlast(b) - BUNsize(b));
	else
	if (*(@1*)ht == *hgh){
		/* The first two cases are when the low bound already exists in the index */
		if  (*(lng*)hh > 0 && *inclusiveHgh == TRUE)
			vh = *(lng*)hh;
		else if  (*(lng*)hh < 0 && *inclusiveHgh == FALSE)
			vh = *(lng*)hh - 2*(*(lng*)hh);

		/* We want values that the next index has; special case when there is no next index */
		else if  (*(lng*)hh < 0 && *inclusiveHgh == TRUE){
			ht += xx; h  += xx; hh += xx;
			if (h == BUNlast(c)){
				ch = BUNindex(b, BUNlast(b)-BUNsize(b)); /*todo this might be the same with current index*/
			}else if (*(@1*)ht == *hgh)
				vh = *(lng*)hh;
			else {
				ch= *(lng*)hh;
				if (ch < 0) ch = *(lng*)hh - 2*(*(lng*)hh);
			}
		}
		/*  This index contains values that we do not want (the equals to hgh) 
			so we have to crack up to this one. We know that there is no 
			previous index that excludes only the values we do not want (the 
			hghs) Also we cannot check for hgh-1 */
		else if  (*(lng*)hh > 0 && *inclusiveHgh == FALSE)
			ch = *(lng*)hh;
	}else{ 
		/* No exact match was found so we have to crack. */
		if  (*(lng*)hh > 0)
			ch = *(lng*)hh;
		else
			ch = *(lng*)hh - 2*(*(lng*)hh);
	}

@= searchForGapsHgh
	/*check for empty pieces before h*/	
	hhprev = hh - xx;
	gf = 0;	
	while(1){
		if ( *(lng*)hhprev == ch || 
			( *(lng*)hhprev < 0 && *(lng*)hhprev - 2*(*(lng*)hhprev) == ch ) ){ 
			gf = 1;
			h -= xx; ht -= xx; hh -= xx;
			hhprev -= xx;
		}
		else break;
	}
	if (gf == 1){
		if (*(@1*)ht < *low){
			vl =  1;
			vh = -1;
			goto createView;
		}
		else
		if (*(@1*)ht == *low){
			if  (*(lng*)hh < 0) vl = *(lng*)hh - 2*(*(lng*)hh);
			else vl = *(lng*)hh;
			vh =  vl;
			goto createView;
		}
		else{
			if  (*(lng*)hh < 0) vh = *(lng*)hh - 2*(*(lng*)hh);
			else vh = *(lng*)hh;
			ch = -1;
		}
	}

@= CreateResult
createView:
/*	printf("vl: %lld, vh:%lld \n",vl,vh);*/
	mode= b->batRestricted;
	b->batRestricted= BAT_READ;
	view = BATslice(b, vl, vh+1);
	
	if (!tail) 
		view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
	
	b->batRestricted= mode;
	*vid = view->batCacheid;
	BBPkeepref(*vid);
	BBPunfix(b->batCacheid);

@= crackOperations
str
CRKRange_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail)
{
	BAT *b,*c;
	BAT *view;
	int  m;
	int mode;
	lng vl=-1, vh=-1, posl, posh; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl=-1, ch1=-1, cl2=-1, ch=-1; 
	/* index values in the case we have to crack 
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	lng i1=-1,i2=-1;
	BUN l,lt,ht; 
	int xx;
	BUN h,lh,hh,h1, posA, posB;
	BUN lhnext, hhprev;
	bit gf;
	if (low > hgh)
		return throwMessage("crackers.crack", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access descriptor");
        
	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat, 
		we have to create the crack indx for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if (b->htype ==TYPE_void) {
			 b = BATmaterializeh(b,BATcount(b));
			 b->hsorted = FALSE;
			 b->tsorted = FALSE;
			 b->hdense = FALSE; 
			 b->hdense = FALSE;
		}
		m = newIndex_@1(*bid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in three pieces cl-ch */
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));
		posA = BUNfirst(c);
		posB = posA + BUNsize(c);
		@:crkThree(@1,posl,posh)@
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where our range falls after this 
		search if we have a match on the low range vl will hold the 
		index value, otherwise it will be -1. The same for hgh and vh
		if there is no match for low then cl will hold the index that 
		from there on we have to crack. The same from hgh and ch
		Note that in the case of the low range  we always have to increment 
		by one since we want the values that are after this index 
		(because of the way the crack index is created).
		Also after the search l and h should point to the low and hgh indices 
		(in the crack index) found either as a match or to crack. 
		This is used later on to determine which pieces we have to crack*/

	if ((c = BATdescriptor(Index[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	@:searchForLow(@1)@
	@:searchForGapsLow(@1)@

	/* find out where in the index the high falls */
	@:searchForHgh(@1)@
	@:searchForGapsHgh(@1)@
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (vl == -1 || vh == -1){
		if (vl == -1 && vh == -1){
			/* If ch is right after cl in the index then we split this piece in three pieces*/
			if (h == l + xx){
				/*CRACK in three pieces cl-ch */
				@:crkThree(@1,cl,ch)@
			}else{
				/* Else we have to do two cracks separatelly */
	
				/* For the cl bound and the next one in the index*/
				@:crkTwoL(@1)@

				/* For the ch bound and the previous one in the index*/
				@:crkTwoR(@1)@
				
				addTwo_@1(m,low,i1,posA,hgh,i2,posB);
			}
		}else
		if (vl == -1){
			@:crkTwoL(@1)@
			addOne_@1(m,low,i1,posA);
		}else
		if (vh == -1){
			@:crkTwoR(@1)@
			addOne_@1(m,hgh,i2,posB);
		} 	
	}
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}       

str
CRKRange_LeftNil_@1(int *vid, int *bid, @1 *hgh, bit *inclusiveHgh, bit tail)
{
	BAT *b,*c;
	BAT *view;
	int  m;
	int mode;
	lng vl=-1, vh=-1; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl2=-1, ch=-1; 
	/* index values in the case we have to crack 
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	lng i2=-1;
	BUN ht; 
	int xx;
	BUN h,hh,posB;
	if ((b = BATdescriptor(*bid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access descriptor");
        
	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat, 
	   we have to create the crack index for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if (b->htype ==TYPE_void) {
			 b = BATmaterializeh(b,BATcount(b));
			 b->hsorted = FALSE;
			 b->tsorted = FALSE;
			 b->hdense = FALSE; 
			 b->hdense = FALSE;
		}
		m = newIndex_@1(*bid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in two pieces cl-ch */
		@:crkTwoRFirst(@1)@
		posB = BUNfirst(c);
		addOne_@1(m,hgh,i2,posB);

		vl = BUNindex(b,BUNfirst(b));
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where the high falls */

	if ((c = BATdescriptor(Index[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	vl = BUNindex(b,BUNfirst(b));

	/* find out where in the index the high falls */
	@:searchForHgh(@1)@
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (vh == -1){
		@:crkTwoR(@1)@
		addOne_@1(m,hgh,i2,posB);
	} 	
	
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}       

str
CRKRange_RightNil_@1(int *vid, int *bid, @1 *low, bit *inclusiveLow, bit tail)
{
	BAT *b,*c;
	BAT *view;
	int  m;
	int mode;
	lng vl=-1, vh=-1; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng ch1=-1, cl=-1; 
	/* index values in the case we have to crack 
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	lng i1=-1;
	BUN lt; 
	int xx;
	BUN l, lh, h1, posA;
	if ((b = BATdescriptor(*bid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access descriptor");
        
	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat, 
	   we have to create the crack index for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if (b->htype ==TYPE_void) {
			 b = BATmaterializeh(b,BATcount(b));
			 b->hsorted = FALSE;
			 b->tsorted = FALSE;
			 b->hdense = FALSE; 
			 b->hdense = FALSE;
		}
		m = newIndex_@1(*bid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in two pieces cl-ch */
		@:crkTwoLFirst(@1)@
		posA = BUNfirst(c);
		addOne_@1(m,low,i1,posA);

		vh = BUNindex(b,BUNlast(b)-BUNsize(b));
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where the high falls */

	if ((c = BATdescriptor(Index[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	@:searchForLow(@1)@

	/* find out where in the index the high falls */
	vh = BUNindex(b,BUNlast(b)-BUNsize(b));
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (vl == -1){
		@:crkTwoL(@1)@
		addOne_@1(m,low,i1,posA);
	} 	
	
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}       
@

@= SelectFunctions
str                             
CRKselectValue(int *vid, int *bid, int *value)
{                                       
	return CRKuselectBounds_@1(vid, bid, value, value, TRUE, TRUE);
} 
                
str
CRKuselectValue(int *vid, int *bid, int *value)
{
	return CRKuselectBounds_@1(vid, bid, value, value, TRUE, TRUE);
}

str
CRKselect_@1(int *vid, int *bid, int *low, int *hgh)
{
	return CRKselectBounds_@1(vid, bid, low, hgh, TRUE, TRUE);
}

str                             
CRKuselect_@1(int *vid, int *bid, int *low, int *hgh)
{                               
	return CRKuselectBounds_@1(vid, bid, low, hgh, TRUE, TRUE);
}                               

mal_export str CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{		
	if (*(@1*)low == int_nil)
		CRKRange_LeftNil_@1(vid, bid, hgh, inclusiveHgh, TRUE);
	
	else if (*(@1*)hgh == int_nil)
		CRKRange_RightNil_@1(vid, bid, low, inclusiveLow, TRUE);
	else 
		CRKRange_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);

	return MAL_SUCCEED;
}

mal_export str CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{		
	if (*(@1*)low == int_nil)
		CRKRange_LeftNil_@1(vid, bid, hgh, inclusiveHgh, FALSE);
	else if (*(@1*)hgh == int_nil)
		CRKRange_RightNil_@1(vid, bid, low, inclusiveLow, TRUE);
	else 
		CRKRange_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);

	return MAL_SUCCEED;
}
@c
@:crackOperations(int)@
@:SelectFunctions(int)@
                        
