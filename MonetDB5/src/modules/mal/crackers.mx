@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f crackers
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006
@* Cracker index

Database cracking aims at enhancing query processing by adapting the way 
data is stored to the query workload. Adaptation happens through physical 
reorganization of data. Each query reorganized the data in such a way that 
future queries can be answered faster.

For each BAT b, the system creates on demand a cracker column c, i.e., 
the first time a select operator is fired on b. From there on all queries that 
perform a select operator on b will physically reorganize (i.e., crack) the cracker column c 
such that the result set is in a consecutive area in c. 
The result of the select operator is a non materialized view on c.

For each cracker column c, there exists a cracker index, that maintains knowledge 
on the various pieces created while cracking c. The cracker index is an AVLt-tree
data structure. Each select operator uses the appropriate cracker index to determine 
which pieces it should crack, and updates the index afterwards.

The more queries are fired on a bat b the more the cracker column c of b is cracked.
This way the cracker index on c, is continuously enriched with information that helps speed up 
future queries. This way query processing improves as more queries are answered by adapting to 
the query and data workload.

Initial performance shows an exptected gain of at least on order of magnitude, 
due to analysing less data during the select operator and also due to non materializing 
the select operator result set.

The cracker index can be created for the time being on
tail columns of type {int,lng,dbl,flt,time,date,sht}. The head
is always of type @sc{oid}.

In addition, the cracker index can be used to feed a generator
for pieces satisfying a range constraint.
A cracker partition is indicated by the index in the cidx
table. It can be used to initialize a BATview to represent
the partition during processing.

Updates support for cracker columns happens again in a self-organizing way.
Incoming updates (inserts,deletes or updates) are kept in separate columns for 
each BAT as pending updates. While processing queries, if the crackers select 
operator detects that some of the pending updates should be taken into account,
then updates are "merged" into the cracker column on the fly by also updating the 
cracker index accordingly.

Since the cracker columns are physically reorganized the result of a select operator is not 
ordered in the same way as the rest of the bats of the same relation. This has side-effects 
during projection operations. We cannot use ordered fetch joins anymore. 
This decrades performance significantly
when multiple projections exist in a query plan.

This problem is solved by the second generation cracing, i.e., 
sideways cracking that uses cracker maps instead of cracker columns.
A cracker map contains the values of two attributes of the same relation. 
These are attributes used together in query plans. The main idea is that 
cracking based on one of these attributes (the head of the map) is forwarded on the tail. 
This way projections can be performed by performing simple cracking operations on maps.
Multiple maps can exist for each attribute A as head consisting the map set of A. All maps in the same 
map set S are aligned before used in a query plan. Aligment happens by keeping a history of all cracking 
operations in maps of S and ensuring that the same cracks have been applied to all necessary maps 
and in the same order. Sideways cracking maintains the advantage of cracking even 
in the presence of multiple projection operations.

Ongoing work.
Multitable cracking.

The cracker module should be prepared to deal with any of the base types.
For strings this becomes an issue.

The current implementation uses an unprotected cracker
index. This limits the interface at slightly more overhead
of searching the cracker index upon each call.

Currently crakcer structures are in memory. They need to be stored in disk and become persistent.

Repeated cracking leads to an ever growing index. This process
can be stopped by setting the granule size,
i.e.  the minimum number of tuples in each piece,
or the maximum number of pieces.

@mal
module crackers;

@= crackAlgebra
command select(b:bat[:any_1,:@1],l:@1,h:@1):bat[:any_2,:@1]
address CRKselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:any_1,:@1],l:@1):bat[:any_2,:@1]
address CRKselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@1],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:@1,h:@1):bat[:any_1,:oid]
address CRKuselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:@1):bat[:any_1,:oid]
address CRKuselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_1,:oid]
address CRKuselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";
@

@= joinuselect
command joinuselect( right:bat[:oid,:@1], l:@1, h:@1, li:bit, hi:bit, left:bat[:oid,:oid] ):bat[:oid,:oid]
address CRKjoinSelectDefault_@1
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	The result is a new [:oid,:void] BAT.";

command joinuselect( right:bat[:oid,:@1], l:@1, h:@1, li:bit, hi:bit, left:bat[:oid,:oid], inPlace:bit , isForeignKey:bit):bat[:oid,:oid]
address CRKjoinSelectBounds_@1
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	If inPlace is TRUE (and left has an OID head and is not a BAT-view), we operate in-place,
	overwriting left and returning it as result. Otherwise, the result is a new [:oid,:void] BAT.
	If isForeignKey is TRUE, we assume that each tuple from left finds a match in right,
	and hence skip the respective check.
	(NOTE: This may lead to CRASHES, if isForeignKey is incorrectly passed as TRUE!)";
@

@= crackfcn
command printCrackerIndexBATpart(b:bat[:any_1,:@1]):void
address CRKprintCrackerIndexBATpart
comment "Print the cracker index of b";

command printCrackerBAT(b:bat[:any_1,:@1]):void
address CRKprintCrackerBAT
comment "Print the cracker BAT of b";

command getCrackerBAT(b:bat[:any_1,:@1]):bat[:oid,:@1]
address CRKgetCrackerBAT
comment "Get the cracker BAT of b";

command printCrackerInsertions(b:bat[:any_1,:@1]):void
address CRKprintCrackerInsertions
comment "Print the pending insertions of the cracker BAT of b";

command printCrackerDeletions(b:bat[:any_1,:@1]):void
address CRKprintCrackerDeletions
comment "Print the pending deletions of the cracker BAT of b";

command sizeCrackerInsertions(b:bat[:any_1,:@1]):void
address CRKsizeCrackerInsertions
comment "Get the size of the pending insertions of the cracker BAT of b";

command sizeCrackerDeletions(b:bat[:any_1,:@1]):void
address CRKsizeCrackerDeletions
comment "Get the size of the pending deletions of the cracker BAT of b";

command insertionsForget(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertions_Forget
comment "Append c to the cracked BAT of b and completelly forget the cracker index";

command insertionsPartiallyForget(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertions_PartiallyForget_@1
comment "Append c to the cracked BAT of b and partially forget 
         the cracker index, i.e., forget only what is affected";

command insertionsBForce(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_Force_@1
comment "Merge the insertions BAT with the cracker bat and update the cracker index";

command insertionsBOnNeed(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_OnNeed
comment "Keep the insertions BAT separatelly and do a complete merge 
         only if a relevant query arrives in the future";

command insertionsBOnNeedGradually(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_OnNeedGradually
comment "Keep the insertions BAT separatelly and merge only what is 
         needed if a relevant query arrives in the future";

command insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_OnNeedGraduallyRipple
comment "Keep the insertions BAT separatelly and merge only what is needed 
         using the ripple strategy if a relevant query arrives in the future";

command deletionsOnNeed(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeDeletions_OnNeed
comment "Keep the deletions BAT separatelly and do a complete merge only 
         if a relevant query arrives in the future";

command deletionsOnNeedGradually(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeDeletions_OnNeedGradually
comment "Keep the deletions BAT separatelly and merge only what is 
         needed if a relevant query arrives in the future";

command deletionsOnNeedGraduallyRipple(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeDeletions_OnNeedGraduallyRipple
comment "Keep the deletions BAT separatelly and merge only what is 
         needed using ripple if a relevant query arrives in the future";

command verifyCrackerIndex(b:bat[:any_1,:@1]):void
address CRKverifyCrackerIndex_@1
comment "Check the cracker index and column, whether each value is in the correct chunk";

command extendCrackerBAT(b:bat[:any_1,:@1], P:lng):void
address CRKextendCrackerBAT
comment "Extend the cracker column by P positions";

command printAVLTree_int(b:bat[:any_1,:@1]):void
address CRKprintAVLTree_int
comment "Print the AVL Tree of the cracker index (for debugging purposes)";
@

@= crackO
command zcrackOrdered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackOrderedZero_@1
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackOrderedOne_@1
comment "Break a BAT into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackOrderedThree_@1
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";
@

@= crack
command zcrackUnordered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackUnorderedZero_@1
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackUnorderedThree_@1
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@

@= crack_validate
command zcrackOrdered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackOrderedZero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackOrderedOne_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackOrderedTwo_validate_@1
comment "Validate whether a BAT is correctly broken into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackOrderedThree_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackUnordered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackUnorderedZero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackUnorderedThree_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@

@= crackSig
	@:crackAlgebra(@1)@
	@:joinuselect(@1)@
	@:crackfcn(@1)@
	@:crack(@1)@
	@:crackO(@1)@
	@:crack_validate(@1)@
@

@mal
@:crackSig(chr)@
@:crackSig(sht)@
@:crackSig(int)@
@:crackSig(lng)@
@:crackSig(flt)@
@:crackSig(dbl)@
@:crackSig(date)@

@-
@{
@- include prelude.mx
@* Implementation
The implementation is geared at early experimentation
without all the details to make the code robust and
ultra fast.

@h
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/
/*#define DEBUG_CRACKERS_INSERTIONS*/

#ifdef WIN32
#ifndef LIBCRACKERS
#define crackers_export extern __declspec(dllimport)
#else
#define crackers_export extern __declspec(dllexport)
#endif
#else
#define crackers_export extern
#endif

struct Node{
        lng	      position;
	bit 	      inclusive;	
        struct Node  *left;
        struct Node  *right;
        int	      height;
	bit	      head;
	bit	      deleted;
        struct Node  *previous;
	bit 	      isPreviousSmaller;	
	lng	      hols; /* # of hols before this piece */
};

typedef struct {
			/* Core cracking */
	int 		bid;   		/* The base BAT */
	int 		cbid;   	/* The cracker column/BAT i.e., the copy on which we actually crack */

	int 		cid;   		/* The cracker index for BAT */
	struct Node 	*Tree; 		/* The AVL-tree part of the cracker index */

			/* Updates */
	int 		iid;   		/* The pending insertions column */
	int 		did;   		/* The pending deletions column */

	bit		reCreate;	/* Indicates whether we need to recreate the index if we chose to forget it */

	sht		mergeInsertions;/* Indicates wether there are insertions to merge -->  -1 no insertions,
												0 complete merge,
												1 gradually,
												2 ripple */
	sht		mergeDeletions; /* Indicates wether there are insertions to merge -->  -1 no insertions,
												0 complete merge,
												1 gradually,
												2 ripple */
	bit 		deleteNodes;    /* If set true, merging operations will delete nodes 
					   form the cracker index if this makes things easier */

			/* Sideways cracking */
	int 		pbid; 		/* The cracker map. Together with the bid, they uniquely identify 
				           a cracker map when pid is -1 then chid stores the cracker 
                                           tape for all the cracker maps where bid is head 
				           hiid is a [bit,bit] BAT that stores inclusive information 
					   for each bound stored in chid */

	lng 		nextCrack;	/* Points to the next cracking operation that should be applied 
                                           in thhis map to sync it */
	int 		chid;
	int 		hiid;
} CrackerIndexNode;

crackers_export str CRKselect(int *vid, int *bid, int *low, int *hgh);
crackers_export str CRKselectValue(int *vid, int *bid, int *value);
crackers_export str CRKuselect(int *vid, int *bid, int *low, int *hgh);
crackers_export str CRKuselectValue(int *vid, int *bid, int *value);

crackers_export str CRKprintCrackerIndexBATpart(int *k, int *bid);
crackers_export str CRKprintCrackerBAT(int *k, int *bid);
crackers_export str CRKgetCrackerBAT(int *vid, int *bid);
crackers_export str CRKsizeCrackerInsertions(int *k, int *bid);
crackers_export str CRKsizeCrackerDeletions(int *k, int *bid);
crackers_export str CRKprintCrackerInsertions(int *k, int *bid);
crackers_export str CRKprintCrackerDeletions(int *k, int *bid);
crackers_export str CRKmergeInsertions_Forget(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertions_OnNeed(int *k, int *bid, int *new, bit *deleteNodes);
crackers_export str CRKmergeInsertionsB_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertions_OnNeedGradually(int *k, int *bid, int *new, bit *deleteNodes);
crackers_export str CRKmergeInsertionsB_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertions_OnNeedGraduallyRipple(int *k, int *bid, int *new, bit *deleteNodes);
crackers_export str CRKmergeInsertionsB_OnNeedGraduallyRipple(int *k, int *bid, int *new);
crackers_export str CRKextendCrackerBAT(int *k, int *bid, lng positions);
crackers_export str CRKprintAVLTree_int(int *k, int *bid);
crackers_export str CRKmergeDeletions_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGraduallyRipple(int *k, int *bid, int *new);

#endif /* _CRACKERS_H */
   
@c
#include "mal_config.h"
#include "mal.h"
#include "mal_exception.h"
#include "crackers.h"
#include "mtime.h"
#include "bat5.h"

#define MAXPIECE 1024*100

static int maxCrackMap = 0;

static CrackerIndexNode *CrackerIndex;
int IndexEntries = 220000; /* Initial size used for the bat that stores index values */

/* Temp variables used to test the effect of stop updating the index, they operate only on one cracker bat */
int IndexSize = 0;
int IndexStop = 250000;

/* BEGIN -----------------------AVL-tree implementation for the cracker index --------------------------------------*/
int
Height(struct Node * x){
        if( x == NULL )
                return -1;
        else
                return x->height;
}

struct Node *
SingleRotateLeft(int m, struct Node * node){
        struct Node * l, *lr;
	int nodeLh,nodeRh,lh;

        l = node->left;
	lr = l->right;
        node->left = l->right;
        l->right = node;

	if (node->previous == NULL)
		l->previous = NULL;
	else {
		l->previous = node->previous;
		l->isPreviousSmaller = node->isPreviousSmaller;
        }

	node->previous = l;
	node->isPreviousSmaller = TRUE;
	if (lr != NULL) {
		lr->previous = node;
		lr->isPreviousSmaller = FALSE;
	}
	if (node->head == TRUE){
		node->head = FALSE;
		l->head = TRUE;
		CrackerIndex[m].Tree = l;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	lh = Height(l->left);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        l->height = (lh > node->height ? lh : node->height) + 1;

        return l;
}

struct Node *
SingleRotateRight(int m, struct Node * node){
        struct Node * r, *rl;
	int nodeLh,nodeRh,rh;

        r = node->right;
	rl =  r->left;

        node->right = r->left;
        r->left = node;

	if (node->previous == NULL)
		r->previous = NULL;
	else {
		r->previous = node->previous;
		r->isPreviousSmaller = node->isPreviousSmaller;
	}
	node->previous = r;
	node->isPreviousSmaller = FALSE;

	if (rl != NULL){
		rl->previous = node;
		rl->isPreviousSmaller = TRUE;
	}

	if (node->head == TRUE){
		node->head = FALSE;
		r->head = TRUE;
		CrackerIndex[m].Tree = r;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	rh = Height(r->right);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        r->height = (rh > node->height ? rh : node->height) + 1;

        return r;
}

struct Node *
DoubleRotateLeft(int m, struct Node * node){
            node->left = SingleRotateRight(m, node->left);
            return SingleRotateLeft(m, node);
}

struct Node *
DoubleRotateRight(int m, struct Node * node){
            node->right = SingleRotateLeft(m, node->right);
            return SingleRotateRight(m, node);
}

/* Get the previous node in the tree (in terms of value), the result can be any node, deleted or no */
struct Node *
getPreviousNodeAny(struct Node * current){
	struct Node *res = NULL;

	if (current->left !=NULL){
		res = current->left;
		while(res->right != NULL)
			res = res->right;
	}

	return res;	
}

/* Get the next node in the tree (in terms of value), the result can be any node, deleted or no */
struct Node *
getNextNodeAny(struct Node * current){
        struct Node *res = NULL;

        if (current->right !=NULL){
                res = current->right;
                while(res->left != NULL)
                        res = res->left;
        }

        return res;
}

struct Node *
getP(struct Node * current){
        struct Node *res = NULL;

	if (current->right != NULL)
		res = getP(current->right);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else
		if (current->left != NULL)
			res = getP(current->left);
	}
	return res;
}

struct Node *
getN(struct Node * current){
        struct Node *res = NULL;

	if (current->left != NULL)
		res = getN(current->left);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else
		if (current->right != NULL)
			res = getN(current->right);
	}
	return res;
}

/* Get the previous node in the tree (in terms of value), the result can be only a non deleted node */
struct Node *
getPreviousNode(struct Node * current, struct Node * previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return res;

}

/* Get the next node in the tree (in terms of value), the result can be only a non deleted node */
struct Node *
getNextNode(struct Node * current, struct Node * next){
        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return res;
}

lng
getPreviousPosition(struct Node * current, BAT *b, BUN base, int xx, lng previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return *(lng*)BUNhloc(b,base + ((res->position) * xx));

}

lng
getNextPosition(struct Node * current, BAT *b, BUN base, int xx, lng next){
        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return *(lng*)BUNhloc(b,base + ((res->position) * xx));
}

struct Node *
findPreviousPieceWalkingBack(struct Node * node){
	struct Node * res = NULL, *current = node;

	if (current->left != NULL)
                res= getP(current->left);
	if (res != NULL)
		return res;

	/* If nothing in the current branch we have to move back */
	while (res == NULL) {
		if (current->previous == NULL)
			return NULL;
		while  (current->isPreviousSmaller == FALSE){
			current = current->previous;
			if (current->previous == NULL)
                        	return NULL;
		}
		current = current->previous;

		if (current->deleted == FALSE)
			res = current;
		else if (current->left != NULL)
                	res= getP(current->left);
	}
	
	return res;
}

struct Node *
findNextPiece(struct Node * node){
	struct Node * res = NULL, *current = node;

	if (current->right != NULL)
                res= getN(current->right);
	if (res != NULL)
		return res;

	/* if nothing in the current branch we have to move back */
	while (res == NULL) {
		if (current->previous == NULL)
			return NULL;
		while  (current->isPreviousSmaller == TRUE){
			current = current->previous;
			if (current->previous == NULL)
                        	return NULL;
		}
		current = current->previous;

		if (current->deleted == FALSE)
			res = current;
		else if (current->right != NULL)
                	res= getN(current->right);
	}
	
	return res;
}

@= TreeOperations
bit
GetLow_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next){
	BUN cur, curValue;

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_LT(&x,curValue,@3@1) ){	
			if (current->left == NULL){
        	                *p1 = previous;
                	        *p2 = getNextPosition(current, b, base,  xx, next);
                       	 	return 0;
                	} else
                        	/* check for the left one */
                        	return GetLow_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, getNextPosition(current, b, base,  xx, next));
		}
		if (current->right == NULL){
               	 	*p1 = getPreviousPosition(current, b, base,  xx, previous);
			*p2 = next;
			return 0;
		} else 	
			return GetLow_@1(x, inclusive, current->right, b, base, xx, p1, p2, getPreviousPosition(current, b, base,  xx, previous), next);
	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) ){
		*p1 = *(lng*)BUNhloc(b, cur);	
		return 1;
	}	

       	if ( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL){
			/* crack from the begining of the bat */
                	*p1 = previous;
			*p2 = *(lng*)BUNhloc(b, cur);
			return 0;
		} else
			/* check for the left one */
      			return GetLow_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, *(lng*)BUNhloc(b, cur));
			
	}

	if (current->right == NULL){
		/* crack until the end of the bat */
                *p1 = *(lng*)BUNhloc(b, cur);
		*p2 = next;
		return 0;
	} else 	
		/* check for the right one */
		return GetLow_@1(x, inclusive, current->right, b, base, xx, p1, p2, *(lng*)BUNhloc(b, cur), next);
}

bit
GetHgh_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next){
        BUN cur, curValue;	

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_GT(&x,curValue,@3@1) ){
			 if (current->right == NULL){
                       	 	*p1 = getPreviousPosition(current, b, base,  xx, previous);
                        	*p2 = next;
                        	return 0;
                	} else
                        	return GetHgh_@1(x, inclusive, current->right, b, base, xx, p1, p2, getPreviousPosition(current, b, base,  xx, previous), next);
		}
		if (current->left == NULL){
               	 	*p1 = previous;
                	*p2 = getNextPosition(current, b, base,  xx, next);
               	 	return 0;
	        } else
                	return GetHgh_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, getNextPosition(current, b, base,  xx, next));

	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE))){
		*p2 = *(lng*)BUNhloc(b, cur);	
		return 1;
	}	

	if ( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL){
			/* crack until the end of the BAT if this was the last index entry but the needed value is still bigger */
			*p1 = *(lng*)BUNhloc(b, cur);
                	*p2 = next;
			return 0;
		} else
			/* check for the right one */
      			return GetHgh_@1(x, inclusive, current->right, b, base, xx, p1, p2, *(lng*)BUNhloc(b, cur), next);
	}

	/* then it is smaller than the current value */
	if (current->left == NULL){
		/* crack from the beginning of the bat until here */
		*p1 = previous;
               	*p2 = *(lng*)BUNhloc(b, cur);
		return 0;
	} else	
		/* check for the left one */	
		return GetHgh_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, *(lng*)BUNhloc(b, cur));	
}

struct Node *
InsertTree_@1(int m, int indexPosition, @1 value, bit inclusive, lng crackPosition, struct Node * current, BAT * b, BUN base, int xx){
	BUN cur, curValue, curPosition, Lchild, LchildValue, Rchild, RchildValue;
	int lh, rh;
	bit use;
	struct Node *temp;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
                current->position = indexPosition;
                current->inclusive = inclusive;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		current->hols = 0;
		goto end;
        }

	cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

	/* reuse if possible nodes that have been deleted with lazy deletion */
	use = FALSE;
	if (current->deleted == TRUE){
		if (current->left != NULL && current->right != NULL){
			Lchild = base + (((getPreviousNodeAny(current))->position) * xx);
                        LchildValue = BUNtloc(b, Lchild);
			Rchild = base + (((getNextNodeAny(current))->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);
			
			if ( ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			       inclusive == TRUE && current->right->inclusive == FALSE) )  &&
			     ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
 			       inclusive == FALSE && current->left->inclusive == TRUE) ) )
				use = TRUE;			
		} else
		if (current->left != NULL && current->right == NULL){
			Lchild = base + (((getPreviousNodeAny(current))->position) * xx);
                        LchildValue = BUNtloc(b, Lchild);

			if ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
			     inclusive == FALSE && current->left->inclusive == TRUE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right != NULL){
			Rchild = base + (((getNextNodeAny(current))->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);
			
			if ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			     inclusive == TRUE && current->right->inclusive == FALSE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right == NULL)
				use = TRUE;

		if (use == TRUE){
        		curPosition = BUNhloc(b, cur);
			*(lng*)curPosition = crackPosition;
                        *(@1*)curValue = value;
			current->inclusive = inclusive;
                        current->deleted = FALSE;
                        return NULL;
		}
	}

        if ( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == TRUE && current->inclusive == FALSE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->left, b, base, xx)) == NULL )
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + ((current->left->position) * xx);
        		LchildValue = BUNtloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
			     inclusive == TRUE && current->left->inclusive == FALSE) )
                        	current = SingleRotateLeft(m, current);
                    	else
                        	current = DoubleRotateLeft(m, current);
		}
        } else
        if ( @2_GT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == FALSE && current->inclusive == TRUE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->right, b, base, xx)) == NULL )
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;


                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + ((current->right->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			     inclusive == FALSE && current->right->inclusive == TRUE) )
                        	current = SingleRotateRight(m, current);
                    	else
                        	current = DoubleRotateRight(m, current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

struct Node *
findNodeH_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * next){
        BUN cur,curValue;	

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE)) )
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;

        if( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL)
			return next;
		else
      			return findNodeH_@1(x, inclusive, current->right, b, base, xx, next);
	}

	if (current->left == NULL)
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;
	else		
		return findNodeH_@1(x, inclusive, current->left, b, base, xx, (current->deleted == TRUE) ? getNextNode(current, next) : current);	
}

struct Node *
findNodeL_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * prev){
	BUN cur,curValue;

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) )
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;

        if( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL)
			return prev;
		else
			return findNodeL_@1(x, inclusive, current->left, b, base, xx, prev);
	}

	if (current->right == NULL)
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;
	else
		return findNodeL_@1(x, inclusive, current->right, b, base, xx, (current->deleted == TRUE) ? getPreviousNode(current, prev) : current);
}

void
PartiallyLazyFreeAVLTree_@1(struct Node * current, @1 value, BAT *b, BUN base, int xx){
	BUN cur,curValue;

        cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

	if (current->left != NULL)
		PartiallyLazyFreeAVLTree_@1(current->left, value, b, base, xx);

	if (current->right != NULL)
		PartiallyLazyFreeAVLTree_@1(current->right, value, b, base, xx);

	if( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && current->inclusive == FALSE) )
		current->deleted = TRUE;
	return;
}
@

@c
@:TreeOperations(chr,simple,)@
@:TreeOperations(sht,simple,)@
@:TreeOperations(int,simple,)@
@:TreeOperations(lng,simple,)@
@:TreeOperations(flt,simple,)@
@:TreeOperations(dbl,simple,)@
@:TreeOperations(date,atom,TYPE_)@

void
FreeAVLTree(struct Node * current){

	if (current->left != NULL)
		FreeAVLTree(current->left);

	if (current->right != NULL)
		FreeAVLTree(current->right);

	GDKfree(current);
		
	return;
}

void
printAVLTree(struct Node * current, BAT *b, BUN base, int xx){
	BUN cur;

	cur = base + ((current->position) * xx);
	if (current->deleted == FALSE) {
		printf("\n "LLFMT", %d  Hols:"LLFMT" ", *(lng*)BUNhloc(b, cur), *(int*)BUNtloc(b, cur), current->hols );
	} else
		printf("\n DELETED "LLFMT", %d  Hols:"LLFMT" ", *(lng*)BUNhloc(b, cur), *(int*)BUNtloc(b, cur), current->hols );
	
	if (current->left != NULL)
                printAVLTree(current->left, b, base, xx);

        if (current->right != NULL)
                printAVLTree(current->right, b, base, xx);

        return;

}
/* END -------------------------AVL-tree implementation for the cracker index----------------------------------------------- */

@= CreateNewIndex
int
newCrackerIndex_@1(int bid, int cbid){
	int i, freemap = -1, units = 1024;
	BAT *b;
	
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		CrackerIndex[freemap].bid = bid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackerIndexNode *x;

		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
		memset(x, 0, sizeof(CrackerIndexNode) * units);
		if (CrackerIndex) {
			fprintf(stderr, "reallocate index \n");
			memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
			GDKfree(CrackerIndex);
		}
		CrackerIndex = x;
		maxCrackMap = units;
	}

	CrackerIndex[i].chid = -1;
	CrackerIndex[i].hiid = -1;
	CrackerIndex[i].pbid = -1;
	CrackerIndex[i].bid = bid;
	CrackerIndex[i].cbid = cbid;
	b = BATnew(TYPE_lng, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	CrackerIndex[i].cid = b->batCacheid;
	CrackerIndex[i].iid = -1;
	CrackerIndex[i].did = -1;
	CrackerIndex[i].mergeInsertions = -1;
	CrackerIndex[i].reCreate = 0;
	CrackerIndex[i].Tree = NULL;
	CrackerIndex[i].deleteNodes = FALSE;
	CrackerIndex[i].mergeDeletions = -1;
	return i;
}

void
reCreateMap_@1(int position){
	BAT *b;

	b = BATnew(TYPE_lng, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	CrackerIndex[position].cid = b->batCacheid;
	CrackerIndex[position].reCreate = 0;
	
	return;
}
@

@c
@:CreateNewIndex(chr)@
@:CreateNewIndex(sht)@
@:CreateNewIndex(int)@
@:CreateNewIndex(lng)@
@:CreateNewIndex(flt)@
@:CreateNewIndex(dbl)@
@:CreateNewIndex(date)@

int
existsCrackerIndex(int bid){
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == bid)
			return i;
	return -1;
}

void
printCrackerIndexBATpart(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(CrackerIndex[i].cid));
}

str
CRKprintCrackerIndexBATpart(int *k, int *bid){
	(void)k;
	printCrackerIndexBATpart(*bid);

	return MAL_SUCCEED;
}

str
CRKprintAVLTree_int(int *k, int *bid){
	BAT *c;
	int zz, position;
	BUN idxFirst;

	(void) k;

	position = existsCrackerIndex(*bid);
        if (position == -1)
                fprintf(stderr, " the crack index does not exist \n");

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL)
                throw(MAL, "crackers.CRKprintAVLTree_int", "Cannot access cracker index");

        zz = BUNsize(c);
        idxFirst = BUNfirst(c);
	printAVLTree(CrackerIndex[position].Tree, c, idxFirst, zz);

	BBPunfix(c->batCacheid);

	return MAL_SUCCEED;
}

void
printCrackerBAT(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(CrackerIndex[i].cbid));
}

str
CRKprintCrackerBAT(int *k, int *bid){
	(void)k;
	printCrackerBAT(*bid);

	return MAL_SUCCEED;
}

str
CRKgetCrackerBAT(int *vid, int *bid){
        int i = existsCrackerIndex(*bid);
        if (i == -1)
                fprintf(stderr, " the cracker index does not exist \n");
        if (CrackerIndex[i].cbid > 0)
		*vid = CrackerIndex[i].cbid;
	else
		*vid = -1;

        return MAL_SUCCEED;
}

@= insertIndexElement
	*(lng*) @2 = @4;	
	*(@1 *) @3 = @5;	
	(b)->batBuns->free += xx;
        (b)->batCount ++;
@

@= InsertIndexElements
void
addCrackerIndex_@1(int m, @1 *value, bit inclusive, lng index, BAT * b){
	BUN ph,pt,base;
        int xx = BUNsize(b);

	ph = BUNhloc(b, BUNlast(b));
	pt = BUNtloc(b, BUNlast(b));

        if (BATcount(b) == 0){
                @:insertIndexElement(@1, BUNhloc(b, BUNfirst(b)), BUNtloc(b, BUNfirst(b)), index, *value)@
		CrackerIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                CrackerIndex[m].Tree->position = 0;
                CrackerIndex[m].Tree->inclusive = inclusive;
                CrackerIndex[m].Tree->height = 0;
                CrackerIndex[m].Tree->left = NULL;
                CrackerIndex[m].Tree->right = NULL;		
                CrackerIndex[m].Tree->head = TRUE;	
                CrackerIndex[m].Tree->deleted = FALSE;	
                CrackerIndex[m].Tree->previous = NULL;	
                CrackerIndex[m].Tree->hols = 0;	

                return;
        }

	base = BUNhloc(b, BUNfirst(b));
        if ( (InsertTree_@1(m, BATcount(b), *value, inclusive, index, CrackerIndex[m].Tree, b, base, xx)) != NULL ) {
		/* use a new BUN only if we cannot reuse a previously deleted one */
		@:insertIndexElement(@1, ph, pt, index, *value)@
	}
}
@

@c
@:InsertIndexElements(chr,simple,)@
@:InsertIndexElements(sht,simple,)@
@:InsertIndexElements(int,simple,)@
@:InsertIndexElements(lng,simple,)@
@:InsertIndexElements(flt,simple,)@
@:InsertIndexElements(dbl,simple,)@
@:InsertIndexElements(date,atom,TYPE_)@


/* BEGIN -------------------------------Core cracking ----------------------------------------------------------------------*/
@= moveOrdered
	while (@1 @6 ){
		@2 @4= xx;
		@3 @4= xx;
		@5
	}
@

@= OThree
	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)ct @5){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
		
		}
		else{
			scr_h[mids] = *(oid*)tmph;
			scr_t[mids] = *(@1* )tmpt;				
			mids--;	
		}
		tmpt @2= xx;
		tmph @2= xx;
		while (tmpt @3 ht && *(@1*)tmpt @5){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	tmph = hh;
	tmpt = ht;
	ct @2= xx*((scrH-mids)+hil);
	for(; tmpt @7 ct; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
	}
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}
	i = mids + 1;
	for (; i <= scrH; i++){
		 if (*(@1*)tmpt @5){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
@

@= crackInThreeOrderedPieces
crackers_export str CRKcrackOrderedThree_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last);
str
CRKcrackOrderedThree_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last){
	BUN hh, ht, tmpt, tmph, ch, ct, t, s, fh, ft;
	oid *scr_h;
	@1  *scr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0, scrH, hil, mids, probe, j;
	int xx = BUNsize(b);
	int i;

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @4 low,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht<=tmpt)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	scrH = scr_size-1;	
	hil = 0; mids = scrH;
	ch = tmph; ct = tmpt;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 25;
	t = tmpt;
	s = tmpt+(2*probe*xx);
	j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;

	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OThree(@1,+,<=,@4 low,@7 hgh,-,>=)@
	}
	else{
		ch = hh; ct = ht;
		fh = tmph; ft = tmpt;
		tmph = hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OThree(@1,-,>=,@7 hgh,@4 low,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}

crackers_export str CRKcrackOrderedThreeL_@2_@3_@1(BAT *b, @1 low, @1 hgh, lng idx_first, lng idx_last, lng *posl, lng *posh);
str
CRKcrackOrderedThreeL_@2_@3_@1(BAT *b, @1 low, @1 hgh, lng idx_first, lng idx_last, lng *posl, lng *posh){
	BUN lh, lt, hh, ht, tmpt, tmph, t, s, fh, ft, mh, mt;
	oid *scr_h,*mscr_h;
	@1  *scr_t,*mscr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0, scrH, hp, hil, mids, mmids, j, probe;
	int xx = BUNsize(b);
	lng pos1, pos2;

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @4 low,lh,lt,+,lowShrinked++;,&& lt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht>=lt)@

	/* These are different cases. For now just make sure that the result will be empty.
	   TODO : when the index will learn from empty results return the appropriate information*/
	
	if (lowShrinked == scr_size) {
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == scr_size){
		*posl =  1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	/*Middle piece is empty and lt = ht + 1*/
	if (lowShrinked + hghShrinked == scr_size){
		*posl =  BUNindex(b,lt);
		*posh =  BUNindex(b,ht);
		return MAL_SUCCEED;
	}

	scrH = scr_size-1;	
	hp = 0; hil = 0; mids = scrH; mmids = 0;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	mscr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	mscr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 100;
	t = lt;
	s = lt+(2*probe*xx);
	j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;
	if (j > probe){
		tmph = lh;
		tmpt = lt;	
		@:OThreeLateCopying(@1,+,<=,@4 low,@7 hgh,-,>=,@5,@6)@
		*posl = pos1;
		*posh = pos2;
	}
	else{
		tmph = hh;
		tmpt = ht;	
		fh = lh; ft = lt;
		lh = hh; lt = ht;
		hh = fh; ht = ft;
		@:OThreeLateCopying(@1,-,>=,@7 hgh,@4 low,+,<=,@5,@6)@
		*posl = pos2;
		*posh = pos1;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@

@= OThreeLateCopying
{
	BUN tmp1, tmp2;
	int i;

	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	tmp1 = lt;
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)lt @5){
				scr_h[hil] = *(oid*)lh;
				scr_t[hil] = *(@1* )lt;				
				hil++;	
			}
			if (*(@1*)lt @8 low && *(@1*)lt @9 hgh){
				scr_h[mids] = *(oid*)lh;
				scr_t[mids] = *(@1* )lt;				
				mids--;	
			}
			*(oid*)lh = *(oid*)tmph;
			*(@1 *)lt = *(@1 *)tmpt;
			lh @2= xx;
			lt @2= xx;
		}
		hp++;
		tmpt @2= xx;
		tmph @2= xx;
		while (*(@1*)tmpt @5 && tmpt @3 ht){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	
	pos1 = BUNindex(b,lt);

	tmph = hh;
	tmpt = ht;
	tmp2 = lt;
	tmp1 @2= xx*(hp+hil);
	for(; tmpt @7 tmp1; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
	}
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}

	pos2 = BUNindex(b,tmpt);

	i = 0;
	for (; i < mmids; i++){
		 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = mscr_h[i];
		*(@1 *)tmpt = mscr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
	tmp2 @2= xx*(scrH-mids);
	/*todo check as in the zero case*/
	mh= tmph;
	mt = tmpt;
	for(; tmpt @7 tmp2; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			if (mt != tmpt){
				*(oid*)mh = *(oid*)tmph;
                        	*(@1 *)mt = *(@1 *)tmpt;
			}
                        mh @6= xx;
                        mt @6= xx;
		}
	}

        i = mids+1;
        for (; i <= scrH; i++){
                 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
                if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
	        	*(oid*)mh = *(oid*)tmph;
                        *(@1 *)mt = *(@1 *)tmpt;
                        mh @6= xx;
                        mt @6= xx;
                }
                *(oid*)tmph = scr_h[i];
                *(@1 *)tmpt = scr_t[i];
                tmph @6= xx;
                tmpt @6= xx;
        }
}
@

@= OrderedZero
		while (tmpt @3 ht){
			while (*(@1*)tmpt @4 mid){
				tmpt @2=xx;
				tmph @2=xx;
			}
			if (*(@1*)ct @4 mid){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
			
			tmpt @2= xx;
			tmph @2= xx;
		}
		tmph @5= 2*xx;
		tmpt @5= 2*xx;
	
		/* Take the position where the last BUN of the left piece is. */
		*pos = BUNindex(b,ct @7);

		ct  @2= xx*hil;
		/* Extreme case where all lows(or all but one, or all but two) where in the hgh partition 
                   (or opposite depending how we move) */
		if (ct @6 tmpt ){
			if (ct == tmpt || ct == tmpt @2 xx) {
				for (i=hil; i >=0 ; i--){
					if (*(@1*)tmpt @4 mid){
						*(oid*)hh = *(oid*)tmph;
						*(@1 *)ht = *(@1 *)tmpt;
						hh @5= xx;
						ht @5= xx;
					}	
					tmpt @5= xx;
					tmph @5= xx;
				}
				for (i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}

			}
			else{
				for (i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}
			}
			return MAL_SUCCEED;
		}

		for(; tmpt @6 ct; tmph @5=xx, tmpt @5=xx){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}
		}
		for (i=hil-1; i >=0 ; i--){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}	
			*(oid*)tmph = scr_h[i];
			*(@1 *)tmpt = scr_t[i];
			tmpt @5= xx;
			tmph @5= xx;
		}
@

@= crackInTwoOrderedPieces
crackers_export str CRKcrackOrderedZero_@2_@1(BAT *b, @1 mid, lng idx_first, lng idx_last, lng *pos);
str
CRKcrackOrderedZero_@2_@1(BAT *b, @1 mid, lng idx_first, lng idx_last, lng *pos){
	BUN hh, ht, tmpt, tmph, fh, ft;
	BUN ch, ct, t, s;
	oid *scr_h;
	@1  *scr_t;
	lng hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);
	int j=0, hil=0, scr_size, probe = 25;
	int i;

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @3 mid,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @4 mid,hh,ht,-,hghShrinked++;,&& ht>=tmpt)@
	if (lowShrinked == idx_last - idx_first + 1) {
			*pos = idx_last+1;
			return MAL_SUCCEED;
	}
	if (hghShrinked == idx_last - idx_first + 1){
			*pos = idx_first-1;
			return MAL_SUCCEED;
	}
	
	if (ht == tmpt + xx){
		oid dh = *(oid*)tmph;
		@1  dt = *(@1 *)tmpt;
		*(oid*)tmph = *(oid*)hh;
		*(@1 *)tmpt = *(@1 *)ht;

		*pos = BUNindex(b,tmpt);

		*(oid*)hh = dh;
		*(@1 *)ht = dt;

		return MAL_SUCCEED;
	}

	if (ht == tmpt - xx){
		*pos = BUNindex(b,ht);
		return MAL_SUCCEED;
	}	

	scr_size = (idx_last - idx_first +1 -lowShrinked -hghShrinked);
	if (scr_size >=2) scr_size = scr_size/2;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	t = tmpt;
	s = tmpt+(2*probe*xx);
	for (;t<s;t+=xx)
		j+=*(@1*)t @3 mid;
	
	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OrderedZero(@1,+,<=,@4,-,>=, -xx)@
	}
	else{
		ch =hh; ct = ht;
		fh = tmph, ft = tmpt;
		tmph =hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OrderedZero(@1,-,>=,@3,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@

@= operationsOrdered
@:crackInTwoOrderedPieces(@1,LE,<=,>)@
@:crackInTwoOrderedPieces(@1,RE,<,>=)@
@:crackInThreeOrderedPieces(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeOrderedPieces(@1,LE,RE,<,>=,<=,>)@
@:crackInThreeOrderedPieces(@1,LO,RO,<=,>,<,>=)@
@:crackInThreeOrderedPieces(@1,LE,RO,<,>=,<,>=)@

crackers_export str CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid);
str
CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
        str msg;
	lng pos;

        if ((b = BATdescriptor(*bid)) == NULL) 
                throw(MAL, "crackers.crack_zeroOrdered", "Cannot access descriptor");

        msg = CRKcrackOrderedZero_LE_@1(b,*mid, 0, BATcount(b)-1,&pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

crackers_export str CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid);
str
CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
	str msg;

        if ((b = BATdescriptor(*bid)) == NULL) 
                throw(MAL, "crackers.crack_oneOrdered", "Cannot access descriptor");

	msg = CRKcrackOrderedThree_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);
        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

crackers_export str CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
str
CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
	BAT *b;
	str msg;
	lng posl,posh;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "crackers.crack_threeOrdered", "Cannot access descriptor");

        msg = CRKcrackOrderedThreeL_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1,&posl, &posh);
	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
@c
@:operationsOrdered(chr,simple,)@
@:operationsOrdered(sht,simple,)@
@:operationsOrdered(int,simple,)@
@:operationsOrdered(lng,simple,)@
@:operationsOrdered(flt,simple,)@
@:operationsOrdered(dbl,simple,)@
@:operationsOrdered(date,atom,TYPE_)@
/* END -------------------------Core cracking Ordered---------------------------------------------------------*/

/* BEGIN -----------------------Core Cracking Unordered------------------------------------------------------*/

@= shuffle
        tdummy= *(@1*) @2;
        *(@1*) @2= *(@1*) @3;
        *(@1*) @3= tdummy;

        hdummy= *(oid*)((char*)@2 - b->tloc);
        *(oid*)((char*)@2 - b->tloc) = *(oid*)((char*)@3 - b->tloc);
        *(oid*)((char*)@3 - b->tloc) = hdummy;
@

@= crackInTwoUnorderedPieces
crackers_export str CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, lng first, lng last, lng *pos);
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, lng first, lng last, lng *pos){
        ptr vm, vl;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        vl= BUNtloc(b,BUNptr(b,last));

        while(vm<vl) {
                if (@5_@3(vm, &mval,@6@1))
                        vm = (ptr) ((char *) vm + xx);
                else {
                        while( @5_@4(vl, &mval,@6@1) && vl>vm)
                                vl = (ptr) ((char *) vl - xx);
                        @:shuffle(@1,vm,vl)@
                        vl = (ptr) ((char *) vl - xx);
                        vm = (ptr) ((char *) vm + xx);
                }
        }

	if (vl == vm) {
		if (@5_@4(vl, &mval,@6@1))
			*pos = BUNindex(b,(ptr) ((char *) vl - xx)); /*works for empty left piece also*/
		else{
			*pos = BUNindex(b,vl);
			if (BUNindex(b,vl)==(size_t)last) /*empty right piece*/
				*pos = *pos+1;
		}
	}
	else
		*pos = BUNindex(b,vl);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPieces

crackers_export str CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh);
str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh){
        ptr vm, vl, hmax;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        hmax = BUNtloc(b,BUNptr(b,last));
        while( @8_@7(hmax, &hgh,@9@1) && hmax>vm)
                hmax= (ptr)((char*) hmax - xx);

	if (hmax == vm){
		if (@8_@7(hmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(hmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = BUNindex(b,hmax);
		else{
			*posl = BUNindex(b,(ptr) ((char *) hmax + xx));
			*posh = BUNindex(b,hmax);
		}
		return MAL_SUCCEED;
	}

        vl = hmax;
        while( @8_@5(vl, &low,@9@1) && vl>vm){
                /* move all high values into their final place */
                if( @8_@7(vl, &hgh,@9@1)){
                        @:shuffle(@1,vl,hmax)@
                        hmax= (ptr)((char*) hmax - xx);
                }
                vl= (ptr)((char*) vl - xx);
        }
	if (vl == vm){/*left piece is empty*/
		if (@8_@7(vl, &hgh,@9@1)){
			@:shuffle(@1,vl,hmax)@
			*posl = BUNindex(b,vl);
		}
		else if (@8_@5(vl, &low,@9@1))
			*posl = BUNindex(b,vl);
		else
			*posl = BUNindex(b,(ptr) ((char *) vl + xx));
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@8_@4(vm, &low,@9@1))
                        vm = (ptr) ((char *) vm + xx);
                else {
                        @:shuffle(@1,vm,vl)@
                        while( @8_@5(vl, &low,@9@1) && vl>vm){
                                if(@8_@7(vl, &hgh,@9@1) ){
                                        @:shuffle(@1,vl,hmax)@
                                        hmax= (ptr)((char*) hmax - xx);
                                }
                                vl = (ptr) ((char *) vl - xx);
                        }
                }
        }
	if (vm ==  BUNtloc(b,BUNptr(b,last+1))){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /*then middle piece is empty*/
		*posl = BUNindex(b,(ptr) ((char *) vl + xx));
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
	*posl = BUNindex(b,vm);
	*posh = BUNindex(b,hmax);

	return MAL_SUCCEED;
}
@

@= operations
@:crackInTwoUnorderedPieces(@1,LE,LE,GT,@2,@3)@
@:crackInTwoUnorderedPieces(@1,RE,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
crackers_export str CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid);

str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
        str msg;
	lng pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_zeroUnordered", "Need more clever mapping ");

        msg = CRKcrackUnorderedZero_LE_@1( b, *mid,(size_t) 0, BATcount(b)-1, &pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

crackers_export str CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
        BAT *b;
        str msg;
	lng posl, posh;

        if (*(@1 *) low > *(@1 *) hgh)
                throw(MAL, "crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_threeUnordered", "Need more clever mapping ");

        msg = CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}
@

@c
@:operations(chr,simple,)@
@:operations(sht,simple,)@
@:operations(int,simple,)@
@:operations(lng,simple,)@
@:operations(flt,simple,)@
@:operations(dbl,simple,)@
@:operations(date,atom,TYPE_)@

/* END ---------------------Core cracking Unordered-----------------------------------------------------*/

/* BEGIN -------------------Validation --------------------------------------------------------------*/
@= validate_operations
@:validate_operation_Zero(@1,@2)@
@:validate_operation_One(@1,@2)@
@:validate_operation_Two(@1,@2)@
@:validate_operation_Three(@1,@2)@
@

@= validate_init_1
	BAT *b,*c,*w;
	BUN fst_bn, lst_bn, bn;
	int bs;
	size_t count[6] = {0,0,0,0,0,0};

	/* initialization */
	*res = FALSE;
	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "crackers.@2crack_validate", "Cannot access descriptor");

	bs = BUNsize(b);
	fst_bn = BUNfirst(b);
	lst_bn = BUNlast(b);
	bn = fst_bn;
@

@= validate_init_2
	if (low > hgh) {
		BBPunfix(b->batCacheid);
		throw(MAL, "crackers.@2crack_validate", "illegal range");
	}
@

@= validate_checkUnordered
        while (bn < lst_bn @2 @3 ) {
                bn += bs;
                count[@1]++;
        }
@

@= validate_checkOrdered
{	oid hd = 0;
	while (bn < lst_bn && hd <= *(oid*)BUNhloc(b, bn) @2 @3 ) {
		hd = *(oid*)BUNhloc(b, bn);
		bn += bs;
		count[@1]++;
	}	
}
@

@= validate_check_1
	@:validate_check@5(@2, && *(@1*)BUNtloc(b, bn) @3 @4 )@
@

@= validate_check_2
	@:validate_check@7(@2, && *(@1*)BUNtloc(b, bn) @3 @4 , && *(@1*)BUNtloc(b, bn) @5 @6 )@
@

@= validate_end
	count[0] = BATcount(b);
	if (bn < lst_bn) {
		@3;
		c = BATslice(b, BUNindex(b, fst_bn), BUNindex(b, bn));
		w = BATslice(b, BUNindex(b, bn), BUNindex(b, lst_bn));
		printf("correct:\n");
		BATprint(c);
		printf("wrong:\n");
		BATprint(w);
		BBPunfix(w->batCacheid);
		BBPunfix(c->batCacheid);
		BBPunfix(b->batCacheid);
		throw(MAL, "crackers.@2crack_validate", "Invalid crack");
	}
	assert(bn == lst_bn);
	assert(count[0] == count[1] + count[2] + count[3] + count[4] + count[5]);
	BBPunfix(b->batCacheid);
	*res = TRUE;
	return MAL_SUCCEED;
@

@= validate_operation_Zero
crackers_export str CRKcrack@2Zero_validate_@1 (bit *res, int *bid, @1 *_mid);
str
CRKcrack@2Zero_validate_@1 (bit *res, int *bid, @1 *_mid){
	@1 mid=*_mid;
	@:validate_init_1(@1,z)@

	@:validate_check_1(@1,1,<=,mid,@2)@
	@:validate_check_1(@1,2,> ,mid,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2]);\
	)@
}
@

@= validate_operation_One
crackers_export str CRKcrack@2One_validate_@1 (int *res, int *bid, @1 *_mid);
str
CRKcrack@2One_validate_@1 (int *res, int *bid, @1 *_mid){
	@1 mid=*_mid;
	@:validate_init_1(@1,)@

	@:validate_check_1(@1,1,< ,mid,@2)@
	@:validate_check_1(@1,2,==,mid,@2)@
	@:validate_check_1(@1,3,> ,mid,@2)@
	
	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2], (dbl)mid, count[3]);\
	)@
}
@

@= validate_operation_Two
crackers_export str CRKcrack@2Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh);
str
CRKcrack@2Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh){
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,)@
	@:validate_init_2(@1,)@

	@:validate_check_1(@1,1,< ,low,@2)@
	@:validate_check_1(@1,2,==,low,@2)@
	@:validate_check_2(@1,3,> ,low,< ,hgh,@2)@
	@:validate_check_1(@1,4,==,hgh,@2)@
	@:validate_check_1(@1,5,> ,hgh,@2)@

	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |%f<tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, count[2], (dbl)low, (dbl)hgh, count[3], (dbl)hgh, count[4], (dbl)hgh, count[5]);\
	)@
}
@

@= validate_operation_Three
crackers_export str CRKcrack@2Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh);
str
CRKcrack@2Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh){
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,z)@
	@:validate_init_2(@1,z)@

	@:validate_check_1(@1,1,<=,low,@2)@
	@:validate_check_1(@1,2,<=,hgh,@2)@
	@:validate_check_1(@1,3,> ,hgh,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |%f<tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, (dbl)hgh, count[2], (dbl)hgh, count[3]);\
	)@
}
@

@c
@:validate_operations(chr,Unordered)@
@:validate_operations(sht,Unordered)@
@:validate_operations(int,Unordered)@
@:validate_operations(lng,Unordered)@
@:validate_operations(flt,Unordered)@
@:validate_operations(dbl,Unordered)@
@:validate_operations(chr,Ordered)@
@:validate_operations(sht,Ordered)@
@:validate_operations(int,Ordered)@
@:validate_operations(lng,Ordered)@
@:validate_operations(flt,Ordered)@
@:validate_operations(dbl,Ordered)@
@:validate_operations(date,Ordered)@ /*Fix**/
@:validate_operations(date,Unordered)@ /*Fix**/
@}

@= verifyIndex
str
verifyCrackerIndex_@1(int *bid){
        BAT *c, *b;
	int position = -1;
	BUN crkt, idxh, idxt, idxFirst, crkFirst, crkLast, bnd, cur;
	int xx, zz;
	struct Node * hghIndexNode;
	bit prevIncl;
	@1 prevVal;
	int tuples=0, indexEntries=0;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL)
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	
	xx = BUNsize(b);
	zz = BUNsize(c);
	
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	crkLast  = BUNtloc(b, BUNlast(b));
	crkt     = BUNtloc(b, BUNfirst(b));

	hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, CrackerIndex[position].Tree, c, idxFirst, zz, NULL);
	if (hghIndexNode == NULL){
		BBPunfix(c->batCacheid);
        	BBPunfix(b->batCacheid);
        	return MAL_SUCCEED;
	}

	indexEntries++;
	cur = idxFirst + ((hghIndexNode->position) * zz);
	idxh = BUNhloc(c, cur);
	idxt = BUNtloc(c, cur);
	bnd  = BUNtloc(b, crkFirst + (*(lng*)idxh - hghIndexNode->hols) * xx);

	if (crkt > bnd)
		printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n reader pointer is beyond index...", tuples, indexEntries);
	while(crkt <= bnd){

		if (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)){
			crkt+=xx;
			tuples++;
		} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
			BBPunfix(c->batCacheid);
			BBPunfix(b->batCacheid);
			return MAL_SUCCEED;
		}
	}
	crkt+=hghIndexNode->hols * xx;

	prevVal  = *(@1*)idxt;
	prevIncl = hghIndexNode->inclusive;

	while (crkt < crkLast){
		if ((hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, CrackerIndex[position].Tree, c, idxFirst, zz, NULL)) == NULL)
			break;
		indexEntries++;
		cur = idxFirst + ((hghIndexNode->position) * zz);
		idxh = BUNhloc(c, cur);
		idxt = BUNtloc(c, cur);
		bnd  = BUNtloc(b, crkFirst + (*(lng*)idxh - hghIndexNode->hols) * xx);

		if (crkt > bnd){
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n reader pointer is beyond index...", tuples, indexEntries);
				BBPunfix(c->batCacheid);
				BBPunfix(b->batCacheid);
				return MAL_SUCCEED;
		}
		while(crkt <= bnd){

			if ( (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)) &&
			     (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)) ){
				crkt+=xx;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
				BBPunfix(c->batCacheid);
				BBPunfix(b->batCacheid);
				return MAL_SUCCEED;
			}
		}
		crkt+=hghIndexNode->hols * xx;
		prevVal  = *(@1*)idxt;
		prevIncl = hghIndexNode->inclusive;
	}
	
	if (hghIndexNode == NULL){
		while(crkt < crkLast){
                        if (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)){
                                crkt+=xx;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
                                BBPunfix(c->batCacheid);
                                BBPunfix(b->batCacheid);
                                return MAL_SUCCEED;
                        }
		}
	}
	
	BBPunfix(c->batCacheid);
        BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

crackers_export str CRKverifyCrackerIndex_@1(int *k, int *bid);
str
CRKverifyCrackerIndex_@1(int *k, int *bid){
	(void) k;		
	return verifyCrackerIndex_@1(bid);
}
@

@c
@:verifyIndex(chr,simple,)@
@:verifyIndex(sht,simple,)@
@:verifyIndex(int,simple,)@
@:verifyIndex(lng,simple,)@
@:verifyIndex(flt,simple,)@
@:verifyIndex(dbl,simple,)@
@:verifyIndex(date,atom,TYPE_)@

/* END -------------------Validation --------------------------------------------------------------*/

/* BEGIN -----------------------------------Updates ---------------------------------------------- */
void
printCrackerDeletions(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].did > 0)
		BATprint(BATdescriptor(CrackerIndex[i].did));
}

void
printCrackerInsertions(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].iid > 0)
		BATprint(BATdescriptor(CrackerIndex[i].iid));
}

void
sizeCrackerDeletions(int bid){
        BAT *u;
        int i = existsCrackerIndex(bid);

        if (i == -1)
                fprintf(stderr, " the crack index does not exist \n");
        if (CrackerIndex[i].did > 0){
                u = BATdescriptor(CrackerIndex[i].did);
                printf("\n pending deletions size: "SZFMT"\n",BATcount(u));
                BBPunfix(u->batCacheid);
        }
        else
                printf("\n pending deletions size: 0 \n");
}

str
CRKsizeCrackerDeletions(int *k, int *bid){
        (void)k;
        sizeCrackerDeletions(*bid);
        return MAL_SUCCEED;
}

void
sizeCrackerInsertions(int bid){
	BAT *u;

	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].iid > 0){
		u = BATdescriptor(CrackerIndex[i].iid);
		printf("\n pending insertions size: "SZFMT" \n",BATcount(u));
		BBPunfix(u->batCacheid);
	}
	else
		printf("\n pending insertions size: 0 \n");
}

str
CRKsizeCrackerInsertions(int *k, int *bid){
	(void)k;
	sizeCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerDeletions(int *k, int *bid){
	(void)k;
	printCrackerDeletions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerInsertions(int *k, int *bid){
	(void)k;
	printCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

str
removeCrackerIndex(int *bid){
	BAT *c;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
        	if (CrackerIndex[i].bid == *bid){
                	position = i;	
			break;
		}
	/*if (position == -1) return; Trying to erase an index that does not exist*/

	/* Destroy index BAT */
        if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return "FAILED";
        }

	BBPunfix(c->batCacheid);
	BBPreclaim(c);
	CrackerIndex[position].cid = -1;
	CrackerIndex[position].reCreate = 1;

	/* Delete Tree */
	FreeAVLTree(CrackerIndex[position].Tree);
	CrackerIndex[position].Tree = NULL;
	
	return MAL_SUCCEED;
}

str
appendCrackerBAT(int * bid, int * new){
        BAT *c, *u;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((c = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "bat.append", "Cannot access descriptor");

        if ((u = BATdescriptor(*new)) == NULL) {
                BBPreleaseref(c->batCacheid);
                throw(MAL, "bat.append", "Cannot access descriptor");
        }
	
	if (BATcount(u) == 0) {
		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

        BATappend(c, u, TRUE);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

@= mergeInsertionsFromTheEndBodyI
        BAT *c, *u, *b;
	BUN insh, inst, crkh, crkt, idxFirst, cur, curVal, curPos, crkFirst, crkLast, insFirst, next, write;
	int xx, zz, position = -1;
	struct Node *IndexNode = NULL;
	lng prevPos, prevcrsize, insertions, remainingIns, buns, needed;
	struct Node *prevNode =NULL;

	{
		int i;
		for (i = 0; i < maxCrackMap; i++)
			if (CrackerIndex[i].bid == *bid){
				position = i;
				break;	
			}
	}

        if ((u = BATdescriptor(*new)) == NULL)
                throw(MAL, "crackers.mergeInsertions_@1", "Cannot access insertions BAT");

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	if (endPosition == -1)
		endPosition = BATcount(u) - 1;
	insertions = endPosition - startPosition + 1;

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	xx = BUNsize(b);
	zz = BUNsize(c);
	insFirst = BUNfirst(u);	

	/* make room for the new tuples */
	needed = insertions - (((b)->batBuns->size - (b)->batBuns->free) / xx);
	if ( needed > 0 ){
                size_t ncap = BATcapacity(b) + needed;
                size_t grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = BUNhloc(u, insFirst + endPosition*xx);
	inst 	 = BUNtloc(u, insFirst + endPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	prevPos = prevcrsize - 1;
@

@= mergeLoop
	if ( IndexNode == NULL )
		goto mergeDone;

	/* First position after the last value of this piece. 
           Here we will start moving values we shift from the begginning of the piece */
		
	write  = next + xx - (prevNode==NULL?0:prevNode->hols)*xx;

	cur    = idxFirst + (IndexNode->position) * zz;
        curPos = BUNhloc(c, cur);
	curVal = BUNtloc(c, cur);

	buns   = prevPos - (*(lng*)curPos) - (prevNode==NULL?0:prevNode->hols); /* find out how many values this piece has */

	/* prevPos takes the correct value for the next itteration */
	prevPos = *(lng*)curPos;

	/* next takes the corect value for the next itteration. This is the position of the last value of the previous piece */
	next   = crkFirst + (*(lng*)curPos) * xx;
	
	/* First insert any pending insertions that belong to this piece */
	crkh = BUNhloc(b,write+(remainingIns-1)*xx);
	crkt = BUNtloc(b,write+(remainingIns-1)*xx);
	while(  remainingIns > 0 &&
		(@2_GT(inst,curVal,@3@1) || (@2_EQ(inst,curVal,@3@1) && IndexNode->inclusive == TRUE)) ){
		*(oid*)crkh = *(oid*)insh;
		*(@1 *)crkt = *(@1 *)inst;
		crkh-=xx; crkt-=xx; insh-=xx; inst-=xx; remainingIns--;
	}

	if (remainingIns == 0)
               	goto mergeDone;

	/* Then we shift values from the beggining of the piece */
	if (buns > remainingIns)
		memcpy(write, next+xx, remainingIns*xx);
	 else
		memcpy( write+ (remainingIns-buns)*xx, next+xx, buns*xx);
		
	/* we always update the index to be +remainingIns since even if we move 
           buns values we put them remainingIns positions ahead */
	*(lng*)curPos =  *(lng*)curPos + remainingIns;
	prevNode = IndexNode;
@

@= mergeInsertionsFromTheEndBodyCG
	/* merge for the last piece only */
	if ( remainingIns > 0) {
		/* get the last piece */
		IndexNode = findNodeL_@1(*(@1*)hgh, inclusive, CrackerIndex[position].Tree, c, idxFirst, zz, NULL);
		@:mergeLoop(@1,@2,@3)@
	}

@= mergeInsertionsFromTheEndBodyII
	/* Here the actual merging happens. Starting from the piece where next belongs we continuously 
	   insert and shift until there are no more insertions or pieces */
	while ( remainingIns > 0) {
		IndexNode = findPreviousPieceWalkingBack(prevNode);
		@:mergeLoop(@1,@2,@3)@
	}

	mergeDone:;

	/* We reached the first piece. If there are more insertions then they all go here */
	if (IndexNode == NULL && remainingIns > 0){
		
		crkh = BUNhloc(b,next + xx - (prevNode==NULL?0:prevNode->hols)*xx + (remainingIns-1)*xx);
                crkt = BUNtloc(b,next + xx - (prevNode==NULL?0:prevNode->hols)*xx + (remainingIns-1)*xx);
                while(  remainingIns > 0  ){
                        *(oid*)crkh = *(oid*)insh;
                        *(@1 *)crkt = *(@1 *)inst;
                        crkh-=xx; crkt-=xx; insh-=xx; inst-=xx; remainingIns--;
		}
	}
@

@= shrinkInsertions
	if (startPosition == 0 && (size_t)endPosition == BATcount(u)){
        	BATmode(u, TRANSIENT);
                CrackerIndex[position].iid = -1;
        } else  if ((size_t)endPosition == BATcount(u)){
                crkLast = insFirst + startPosition*xx;
                u->batBuns->free = crkLast - u->batBuns->base;
                BATsetcount(u, u->batBuns->free/xx);
        } else {
		crkh  = insFirst+startPosition*xx;
		insh  = insFirst+endPosition*xx;
		memmove(crkh,insh, (BATcount(u)-endPosition)*xx);

		crkLast = insFirst + (startPosition + (BATcount(u) - endPosition))*xx;
		u->batBuns->free = crkLast - u->batBuns->base;
   		BATsetcount(u, u->batBuns->free/xx);
	}
@

@= shrinkDeletions
	endPosition += 1;
{
	BAT *shrinkSLice  = BATslice(u,startPosition,endPosition);
	BAT *shrinkCopy = BATcopy(shrinkSLice, shrinkSLice->htype, shrinkSLice->ttype, TRUE);

	u = BATdel(u, shrinkCopy, TRUE);

	BBPunfix(shrinkSLice->batCacheid);
	BBPunfix(shrinkCopy->batCacheid);
}
@

@= mergeDeletionsBody
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN delt, idxFirst, crk, crkFirst, crkLast, delFirst, low, lowVal, hgh, hghPos=NULL, hghVal, pos, posLast;
	int xx, zz, pp, position = -1;
	lng deletions, remainingDel, buns;
	struct Node *lowNode, *hghNode, *temp;
	lng LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	lng holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	if (endPosition == -1)
		endPosition = BATcount(u) - 1;

	deletions = endPosition - startPosition + 1;

	remainingDel = deletions;
	xx = BUNsize(b);
	zz = BUNsize(c);
	delFirst = BUNfirst(u);	

	delt 	 = BUNtloc(u, delFirst + startPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode = findNodeL_@1(*(@1*)delt, TRUE, CrackerIndex[position].Tree, c, idxFirst, zz, NULL);
	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;
	if (lowNode != NULL)
		prevPos = *(lng*)BUNhloc(c,(idxFirst + (lowNode->position) * zz)) + 1;
	else 
		prevPos = 0;
	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = CrackerIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);


		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + (lowNode->position) * zz;
                	lowVal = BUNtloc(c, low);

	                hgh    = idxFirst + (hghNode->position) * zz;
                	hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt+=xx;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + (hghNode->position) * zz;
       		        hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt+=xx;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + (lowNode->position) * zz;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);

			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));

			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);
			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);

				/* fill in the hols */
				pp = BUNsize(positions);
				pos = BUNhloc(positions, BUNfirst(positions));
				posLast = BUNhloc(positions, BUNlast(positions)-pp);
				crk = crkFirst + HposCr*xx;
				buns =  HposCr - LposCr;
				while(pos<=posLast){
					if (*(oid*)posLast != (size_t)buns){
						memcpy(crkFirst+(LposCr+(*(oid*)pos))*xx, crk, xx);
						pos+=pp;
					} else
						posLast-=pp;
					crk-=xx; buns--;
				}

				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;
		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns)
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+LposCr*xx, buns*xx);
			else
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+(LposCr+(buns-holSize))*xx, holSize*xx);
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;
		if (hghNode != NULL){
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *(lng*)hghPos+1;
			*(lng*)hghPos = *(lng*)hghPos - holSize - deletedFromCurrentPiece - holPiece;

		} else
			break;
	}

	crkLast = BUNlast(b) - (deletions-remainingDel)*xx + notFound*xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);
@
	
@= mergeInsertionOperations
crackers_export str CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new);
str
CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new){
	BAT *c, *u;
	@1 min;
	BUN inst, insLast;
	int xx, position = -1;
	int i;

	(void) k;

	if ((u = BATdescriptor(*new)) == NULL)
		throw(MAL, "crackers.mergeInsertions_PartiallyForget_@1", "Cannot access insertions");

	if (BATcount(u) == 0)
		return MAL_SUCCEED;

	for (i = 0; i < maxCrackMap; i++)
        	if (CrackerIndex[i].bid == *bid){
                	position = i;	
			break;
		}

	/*if (position == -1) return; Trying to erase an index that does not exist*/

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
                BBPunfix(u->batCacheid);
                throw(MAL, "crackers.CRKmergeInsertions_PartiallyForget_@1", "Cannot access cracker index");
        }

	/* get the min value */
	xx = BUNsize(u);
	inst = BUNtloc(u,BUNfirst(u));
	insLast = BUNtloc(u,BUNlast(u));
	min = *(@1*)inst;
	for(inst+=xx;inst < insLast; inst+=xx)
		if (@2_GT(&min,inst,@3@1))
			min = *(@1*)inst;

	/* Partially delete tree with lazy deletion */
	PartiallyLazyFreeAVLTree_@1(CrackerIndex[position].Tree, min, c, BUNfirst(c), BUNsize(c));

	appendCrackerBAT(bid,new);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

crackers_export str CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new);
str
CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new){
	lng startPosition = 0;
	lng endPosition   = -1;
	@1 *hgh;
	bit inclusive = TRUE;

	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	(void)k;
	next = BUNlast(b) - xx;
	hgh = (@1*)BUNtloc(b,next);
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

 	return MAL_SUCCEED;
}

str
mergeInsertionsB_@1(int *bid, int *new, lng startPosition, lng endPosition){
	@1 *hgh;
	bit inclusive = TRUE;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - xx;
	hgh = (@1*)BUNtloc(b,next);
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBGradually_@1(int *bid, int *new, lng startPosition, lng endPosition){
	/* First merge then shrink the insertions column */
	@1 *hgh;
	bit inclusive = TRUE;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - xx;
	hgh = (@1*)BUNtloc(b,next);
	
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);
	endPosition++;

	@:shrinkInsertions(@1)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBRipple_@1(int *bid, int *new, lng startPosition, lng endPosition, @1 *hgh, bit inclusive){
        BAT *ripple;
        BUN rh, rt, rnext, insLast;
	lng toRippleBuns;
	lng exceedBuns = 0;
	struct Node * NextNode;
	bit fromTheEnd = FALSE;
	int i;
	lng consumedRipple = 0, consumedInsertions = 0, values, usedHoles = 0;
	struct Node *rippleNode = NULL;

        @:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	insLast = BUNtloc(u,BUNlast(u));	
	toRippleBuns = endPosition - startPosition +1;
	ripple = BATnew(TYPE_oid, TYPE_@1, toRippleBuns);

        /* Find out buns that should be rippled. Take this values out in a temporary BAT */

	/* first find the piece where the biggest insertions should be placed */
        if ( (NextNode = findNodeH_@1(*(@1*)hgh, inclusive, CrackerIndex[position].Tree, c, idxFirst, zz, NULL)) != NULL ){

		prevNode = NextNode;
		cur     = idxFirst + (NextNode->position) * zz;
                curPos  = BUNhloc(c, cur);

		/* prevPos should not be changed! 
		   mergeInsertionsFromTheEndBodyII expects it to point in the position from where merging will start */
		prevPos = *(lng*)curPos;

		/* merging will start from this bun */		
		next = crkFirst + (*(lng*)curPos) * xx;

		/* use hols if any at the end of the result area */
		if (NextNode->hols > 0){
			rippleNode = NextNode;
			if (NextNode->hols >= insertions)
				goto rippled;
			else 
			if (NextNode->hols < insertions)
				toRippleBuns -= NextNode->hols; 
			
		}

		rh = BUNhloc(ripple, BUNfirst(ripple));
		rt = BUNtloc(ripple, BUNfirst(ripple));

                rnext   = crkFirst + (*(lng*)curPos) * xx + xx;

		NextNode->deleted = TRUE; /* TODO: consider not deleting this piece and instead extend it... */

                crkh = BUNhloc(b,rnext);
                crkt = BUNtloc(b,rnext);
		crkLast = BUNtloc(b,BUNlast(b));

		/* find out how many buns until we get into the next chunk. Variable buns holds this information*/ 
		if  ((NextNode =findNextPiece(NextNode)) == NULL)
			buns = values = BATcount(b) - prevPos - 1;
		else {
			cur    = idxFirst + (NextNode->position) * zz;
               		curPos = BUNhloc(c, cur);
                	rnext   = crkFirst + (*(lng*)curPos) * xx + xx;
                	buns   = (*(lng*)curPos) - prevPos;
			values = buns - NextNode->hols;
		}
		/* move values out. If we get into the next piece then we simply delete it */
		for (i=0; i<toRippleBuns; i++){
		
			if (i == buns && crkt < crkLast){
				NextNode->deleted = TRUE;
				if  ((NextNode =findNextPiece(NextNode)) == NULL)
					buns = values = BATcount(b) - prevPos - 1;
				else {
					cur    = idxFirst + (NextNode->position)*zz;
               				curPos = BUNhloc(c, cur);
                			rnext  = crkFirst + (*(lng*)curPos)*xx + xx;
                			buns   = (*(lng*)curPos) - prevPos;
					values = buns - NextNode->hols;
				}
			}

			/* do not ripple if this is a hole */
			if (i< values){
				*(oid*)rh = *(oid*)crkh;
				*(@1 *)rt = *(@1 *)crkt;
				rh+=xx; rt+=xx; 
			} else { 
				if (NextNode!=NULL)
					NextNode->hols --;
				usedHoles++;
			}
			crkh+=xx; crkt+=xx;	

			/* we consumed all values until the end of the column. nothing more to ripple */
			if (crkt >= crkLast){
				i++;
				exceedBuns = toRippleBuns - i;
				break;
			}
		}
		if (i == buns && NextNode != NULL) {
			NextNode->deleted = TRUE;
			/*printf("\n have to delete piece "LLFMT"  \n", *(lng*)curPos);*/
		}
		ripple->batBuns->free = BUNfirst(ripple) + (i-usedHoles)*xx - ripple->batBuns->base;	
		BATsetcount(ripple, i-usedHoles);
	} else {
		/* then we do not have to ripple. We simply start merging from the end of the cracker column */
		exceedBuns = toRippleBuns;
		next = BUNlast(b) - xx;
		/* prevPos has been correctly set in mergeInsertionsFromTheEndBodyI pointing at the last bun of the cracker column */
		fromTheEnd = TRUE;
	}
	rippled:;

	if (fromTheEnd){
		@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	}
        @:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@
		
	if (exceedBuns > 0){
		crkLast = BUNlast(b) + exceedBuns * xx;
		b->batBuns->free = crkLast - b->batBuns->base;
       	 	BATsetcount(b, b->batBuns->free/xx);
        }

	if (rippleNode != NULL){
		if (rippleNode->hols > insertions)
			rippleNode->hols -= insertions;
		else
		if (rippleNode->hols <= insertions)
			rippleNode->hols = 0;
	}
	endPosition++;

	/* now we have to merge the rippled values with the remaining insertions */
	if (BATcount(ripple) > 0){
		/* do not ripple values that are marked as pending deletions */
		if (CrackerIndex[position].mergeDeletions > 0){
			BAT *deletes, *ripBAT;
			if (CrackerIndex[position].did < 0) goto merge;			
			if ((deletes = BATdescriptor(CrackerIndex[position].did)) == NULL)
		                return "Cannot access the deletions BAT";	
			if (BATcount(deletes)==0) {
				BBPunfix(deletes->batCacheid);
				goto merge;
			}

			ripple->hsorted = FALSE;
			ripple->tsorted = FALSE;
			ripple->tdense = FALSE;
			ripple->hdense = FALSE;

			/* this is just to bypass a bug and shuold be removed from here */
			deletes->hsorted = FALSE;
			deletes->tsorted = FALSE;
			deletes->tdense = FALSE;
			deletes->hdense = FALSE;

			ripBAT = BATsintersect(ripple,deletes);

			if (BATcount(ripBAT)>0){
				ripple = BATdel(ripple,ripBAT,TRUE);
				deletes = BATdel(deletes,ripBAT,TRUE);
			} 

                      	BBPunfix(deletes->batCacheid);
                        BBPunfix(ripBAT->batCacheid);
		}
		merge:;
		if (BATcount(ripple)==0)
                        goto EmptyRipple;

		ripple->tsorted = FALSE;		
		ripple->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(ripple)));
		
		/* merge */
		rh    = BUNhloc(ripple, BUNfirst(ripple));
		rt    = BUNtloc(ripple, BUNfirst(ripple));
		crkh  = BUNhloc(u,insFirst+startPosition*xx);
		crkt  = BUNtloc(u,insFirst+startPosition*xx);
		insh  = BUNhloc(u,insFirst+endPosition*xx);
		inst  = BUNtloc(u,insFirst+endPosition*xx);

		crkLast = BUNtloc(ripple,BUNlast(ripple));
		while(rt < crkLast && inst < insLast){
			if (@2_LE(rt,inst,@3@1)){	
				*(oid*)crkh = *(oid*)rh;
				*( @1*)crkt = *( @1*)rt;
				rh+=xx; rt+=xx; consumedRipple++;
			} else {
				*(oid*)crkh = *(oid*)insh;
				*( @1*)crkt = *( @1*)inst;
				insh+=xx; inst+=xx; consumedInsertions++;
			}
			crkh+=xx; crkt+=xx;
		}
		
		if (rt < crkLast && inst == insLast){
			int i;
			for(i = 0; (size_t)i<BATcount(ripple)-(size_t)consumedRipple; i++){
				*(oid*)crkh = *(oid*)rh;
                                *( @1*)crkt = *( @1*)rt;
				 rh+=xx; rt+=xx;crkh+=xx; crkt+=xx;
			}
		} else	
		if (rt == crkLast && inst < insLast){
			int i;
			for(i = 0; (size_t)i<BATcount(u)-(size_t)endPosition -(size_t)consumedInsertions; i++){
                                *(oid*)crkh = *(oid*)insh;
                                *( @1*)crkt = *( @1*)inst;
                                 insh+=xx; inst+=xx;crkh+=xx; crkt+=xx;
                        }
		}
		/* if some of the insertions went at the end of the cracker column, then the pending insertions has less values now */
		crkLast = BUNlast(u) - (insertions - BATcount(ripple))*xx;
               	u->batBuns->free = crkLast - u->batBuns->base;
                BATsetcount(u, u->batBuns->free/xx);
	} else {
		EmptyRipple:;
		@:shrinkInsertions(@1)@
	}

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);
	BBPunfix(ripple->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletions_@1(int *bid, int *del, lng startPosition, lng endPosition){
	@:mergeDeletionsBody(@1,@2,@3)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGradually_@1(int *bid, int *del, lng startPosition, lng endPosition){
        @:mergeDeletionsBody(@1,@2,@3)@

	@:shrinkDeletions(@1)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGraduallyRipple_@1(int *bid, int *del, lng startPosition, lng endPosition, @1 *lowV, bit inclusiveL, @1 *hghV, bit inclusiveH){
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN delt, idxFirst, crk, crkFirst, crkLast, delFirst, low, lowVal, hgh, hghPos=NULL, hghVal, pos, posLast;
	int xx, zz, pp, position = -1;
	lng deletions, remainingDel, buns;

	struct Node *lowNode, *hghNode, *temp, *stopNode;
	lng LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	lng holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;


	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	if (endPosition == -1)
		endPosition = BATcount(u) - 1;

	deletions = endPosition - startPosition + 1;

	remainingDel = deletions;
	xx = BUNsize(b);
	zz = BUNsize(c);
	delFirst = BUNfirst(u);	

	delt 	 = BUNtloc(u, delFirst + startPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode = findNodeL_@1(*lowV, inclusiveL, CrackerIndex[position].Tree, c, idxFirst, zz, NULL); 
	stopNode = findNodeH_@1(*hghV, inclusiveH, CrackerIndex[position].Tree, c, idxFirst, zz, NULL); 

	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;

	if (lowNode != NULL)
		prevPos = *(lng*)BUNhloc(c,(idxFirst + (lowNode->position) * zz)) + 1;
	else 
		prevPos = 0;

	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = CrackerIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);

		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + (lowNode->position) * zz;
                	lowVal = BUNtloc(c, low);

	                hgh    = idxFirst + (hghNode->position) * zz;
                	hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt+=xx;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + (hghNode->position) * zz;
       		        hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt+=xx;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + (lowNode->position) * zz;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);
			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));
			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);

			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);


				/* fill in the hols */
				pp = BUNsize(positions);
				pos = BUNhloc(positions, BUNfirst(positions));
				posLast = BUNhloc(positions, BUNlast(positions)-pp);
				crk = crkFirst + HposCr*xx;
				buns =  HposCr - LposCr;
				
				while(pos<=posLast){
					if (*(oid*)posLast != (size_t)buns){
						memcpy(crkFirst+(LposCr+(*(oid*)pos))*xx, crk, xx);
						pos+=pp;
					} else 
						posLast-=pp;
					
	
					crk-=xx; buns--;
				}

				/* values requested to be deleted may not exist */
				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;

		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns)
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+LposCr*xx, buns*xx);
			else
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+(LposCr+(buns-holSize))*xx, holSize*xx);
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;

		/* stop the ripple once at the end of the last piece */
		if (hghNode != NULL){
			if (hghNode == stopNode)
				break;
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *(lng*)hghPos+1;
			*(lng*)hghPos = *(lng*)hghPos - holSize - deletedFromCurrentPiece - holPiece;
		} else
			break;
	}

	if (hghNode == NULL){
		crkLast = BUNlast(b) - (deletions -remainingDel)*xx + notFound*xx;
		b->batBuns->free = crkLast - b->batBuns->base;
	        BATsetcount(b, b->batBuns->free/xx);
	} else
		hghNode->hols = deletions-remainingDel - notFound;
	
	 @:shrinkDeletions(@1)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);
        return MAL_SUCCEED;
}
@

@c
@:mergeInsertionOperations(chr,simple,)@
@:mergeInsertionOperations(sht,simple,)@
@:mergeInsertionOperations(int,simple,)@
@:mergeInsertionOperations(lng,simple,)@
@:mergeInsertionOperations(flt,simple,)@
@:mergeInsertionOperations(dbl,simple,)@
@:mergeInsertionOperations(date,atom,TYPE_)@

str
CRKextendCrackerBAT(int *k, int *bid, lng positions){
	BAT *b;
	int position = existsCrackerIndex(*bid);
	(void) k;

	if (position == -1)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot find cracker index");
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot access cracker BAT");

	if (BATextend(b, positions) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Failed to extend the cracker BAT");	
	
	BBPunfix(b->batCacheid);

	return MAL_SUCCEED;
}

str
appendInsertions(int *new, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*new)) == NULL)
      		 throw(MAL, "crackers.appendInsertions", "Cannot access insertions BAT");

	if (CrackerIndex[position].iid < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		CrackerIndex[position].iid = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(CrackerIndex[position].iid)) == NULL)
      		 	throw(MAL, "crackers.appendInsertions", "Cannot access cracker insertions BAT");
		
		c = BATins(c, u,TRUE);

		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}

str
appendDeletions(int *del, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*del)) == NULL)
      		 throw(MAL, "crackers.appendDeletions", "Cannot access deletions BAT");

	if (CrackerIndex[position].did < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		CrackerIndex[position].did = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(CrackerIndex[position].did)) == NULL)
      		 	throw(MAL, "crackers.appendDeletions", "Cannot access cracker deletions BAT");
		
		c = BATins(c,u, TRUE);

		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}

str
CRKmergeInsertions_Forget(int *k, int *bid, int *new){
	(void) k;
	appendCrackerBAT(bid,new);
	removeCrackerIndex(bid);

	return MAL_SUCCEED;
}


@= updatesOnNeed
str
CRKmergeInsertionsB_OnNeed@1(int *k, int *bid, int *new){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertionsB_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	CrackerIndex[position].mergeInsertions = @2;
	CrackerIndex[position].deleteNodes = FALSE;	

        return MAL_SUCCEED;
}

str
CRKmergeInsertions_OnNeed@1(int *k, int *bid, int *new, bit *deleteNodes){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertions_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	CrackerIndex[position].mergeInsertions = @2;
	CrackerIndex[position].deleteNodes = *deleteNodes;	

        return MAL_SUCCEED;
}

str
CRKmergeDeletions_OnNeed@1(int *k, int *bid, int *del){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeDeletions_OnNeed@1", "Cannot find cracker index");

	appendDeletions(del,position);
	CrackerIndex[position].mergeDeletions = @2;

        return MAL_SUCCEED;
}
@

@c
@:updatesOnNeed(,0)@
@:updatesOnNeed(Gradually,1)@
@:updatesOnNeed(GraduallyRipple,2)@

/* END ----------------------------------Updates----------------------------------------------------------------------*/

/* BEGIN ---------------------------Select Operators----------------------------------------------------------------*/
@= crkThreeTree
        /*printf("crack in three pieces\n");*/
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LE_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LE_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LO_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LO_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
				
	if (vl != -1 && vh != -1){
		if (vl>0) _vl=vl-1; else _vl=vl;		
		addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
		addCrackerIndex_@1(m,hgh,HBound,vh,c);
	}

@= crkTwoLTree
	/*CRACK in two pieces cl1-ch1 using >incLow bound*/
	if (*inclusiveLow == TRUE)
		CRKcrackUnorderedZero_RE_@1(b,*low, cl1, ch1,&vl);
	else
		CRKcrackUnorderedZero_LE_@1(b,*low, cl1, ch1,&vl);
	if (vl < cl1){
		/*then the left piece is empty*/
		gapL = -1;
	}
	if (vl > ch1){
		/*then the right piece is empty*/
		vl--;
		gapL = -1;
	}
	vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
		Instead we want the first bun of the right piece*/
@

@= crkTwoRTree
	/*CRACK in two pieces cl2-ch2 using <incHgh bound*/
	if (*inclusiveHgh == TRUE)
		CRKcrackUnorderedZero_LE_@1(b,*hgh, cl2, ch2,&vh);
	else
		CRKcrackUnorderedZero_RE_@1(b,*hgh, cl2, ch2,&vh);

	/*check for gaps*/
	if (vh < cl2)
		/*then the left piece is empty*/
		gapH = -1;
	if (vh > ch2){
		/*then the right piece is empty*/
		gapH = -1;
		vh--;
	}
@

@= searchForLow
	l = SORTfndfirst_@4(c,low);
	lt = BUNtloc(c, l);
	lh = BUNhloc(c, l);
	posA = l;	

	/* if all indices contain values smaller than low, crack the area
		between the last index and the last BUN of the cracked bat */
	if (l == BUNlast(c)){
		l -= xx; lt -= xx; lh -= xx;
		if  (*(lng*)lh > 0)
			cl = *(lng*)lh;
		else
			cl = *(lng*)lh - 2*(*(lng*)lh);
		cl++;
	} else
	if (@2_EQ(lt,low,@3@1)){
		/* The first two cases are when the low bound already
			exists in the index */
		if  (*(lng*)lh < 0 && *inclusiveLow == TRUE)
			vl = (*(lng*)lh - 2*(*(lng*)lh))+1;
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == FALSE)
			vl = *(lng*)lh+1;

		/* We want values that the previous index has;
		   special case when there is no previous index */
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == TRUE){
			if (l == BUNfirst(c)){
				l  -= xx;
				cl = BUNindex(b, BUNfirst(b));
			}else{
				l  -= xx; lh -= xx; lt -= xx;
				if  (*(lng*)lh > 0)
					cl = *(lng*)lh;
				else
					cl = *(lng*)lh - 2*(*(lng*)lh);
				cl++;
			}
		} else
		if  (*(lng*)lh < 0 && *inclusiveLow == FALSE){
		/*  This index contains values that we do not want (the equals to
			low) so we check the next one. If it is equal to low then
			this is an exact match, otherwise we have to crack.
			Also if this was the last index we have to crack anyway. */
			lt += xx;
			l  +=xx;
			if (@2_EQ(lt,low,@3@1) && l != BUNlast(c)){
				lh += xx;
				vl = *(lng*)lh+1;
			} else{
				lt -= xx;
				l  -= xx;
				cl = (*(lng*)lh - 2*(*(lng*)lh))+1;
			}
		}
	} else{
		/* No exact match was found so we have to crack. Take the
		   previous index because this one is higher than low.
		   If there is no previous index, crack the bat from the beginning. */
		if (l == BUNfirst(c)){
			l  -= xx; lh -= xx; lt -= xx;
			cl = BUNindex(b, BUNfirst(b));
		} else{
			l  -= xx; lh -= xx; lt -= xx;
			if  (*(lng*)lh > 0)
				cl = *(lng*)lh;
			else
				cl = *(lng*)lh - 2*(*(lng*)lh);
			cl++;
		}
	}	
@

@= searchForHgh
	h = SORTfndfirst_@4(c,hgh);
	ht = BUNtloc(c, h);
	hh = BUNhloc(c, h);
	posB = h;	

	if (h == BUNlast(c))
		ch = BUNindex(b, BUNlast(b) - BUNsize(b));
	else
	if (@2_EQ(ht,hgh,@3@1)){
		/* The first two cases are when the low bound already exists in the index */
		if  (*(lng*)hh > 0 && *inclusiveHgh == TRUE)
			vh = *(lng*)hh;
		else if  (*(lng*)hh < 0 && *inclusiveHgh == FALSE)
			vh = *(lng*)hh - 2*(*(lng*)hh);

		/* We want values that the next index has; special case when there is no next index */
		else if  (*(lng*)hh < 0 && *inclusiveHgh == TRUE){
			ht += xx; h  += xx; hh += xx;
			if (h == BUNlast(c))
				ch = BUNindex(b, BUNlast(b)-BUNsize(b)); /*todo this might be the same with current index*/
			else if (@2_EQ(ht,hgh,@3@1))
				vh = *(lng*)hh;
			else {
				ch= *(lng*)hh;
				if (ch < 0) ch = *(lng*)hh - 2*(*(lng*)hh);
			}
		}
		/* This index contains values that we do not want (the equals to hgh)
		   so we have to crack up to this one. We know that there is no
		   previous index that excludes only the values we do not want (the
		   hghs) Also we cannot check for hgh-1 */
		else if  (*(lng*)hh > 0 && *inclusiveHgh == FALSE)
			ch = *(lng*)hh;
	} else{
		/* No exact match was found so we have to crack. */
		if  (*(lng*)hh > 0)
			ch = *(lng*)hh;
		else
			ch = *(lng*)hh - 2*(*(lng*)hh);
	}
@

@= CreateResult
createView:
	view = BATslice(b, vl, vh+1);

	if (!tail)
		view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
	
	*vid = view->batCacheid;
	BBPkeepref(*vid);

	BBPunfix(b->batCacheid);
@

@= crackOperations
lng
shiftHoles_@1(struct Node *lowNode, struct Node *lowNodeNext, BAT *b, int xx, BAT *c, BUN idxFirst, int zz, @1 *hgh, bit *inclusiveHgh, int position){
	lng holSize = 0, LposCr = 0, HposCr = 0, holPiece = 0, buns;
	BUN hghPos = NULL, crkFirst;
	struct Node *hghNode, *stopNode;

	crkFirst = BUNfirst(b);
	stopNode = findNodeH_@1(*hgh, *inclusiveHgh, CrackerIndex[position].Tree, c, idxFirst, zz, NULL);

	while (1){
		if (lowNode == NULL)
			hghNode = lowNodeNext;
		 else
			hghNode = findNextPiece(lowNode);
		
		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
       	 	        hghPos = BUNhloc(c, idxFirst + (hghNode->position) * xx);
      		        LposCr = *(lng*)BUNhloc(c, idxFirst + (lowNode->position) * xx) + holSize;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
       	 	        hghPos = BUNhloc(c, idxFirst + (hghNode->position) * xx);
			LposCr = 0;
       	 	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			LposCr = *(lng*)BUNhloc(c, idxFirst + (lowNode->position) * xx) + holSize;
       	                HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;
		buns = HposCr - LposCr;
		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns)
				memcpy(crkFirst+(LposCr-(holSize-1))*xx, crkFirst+(LposCr+1)*xx, buns*xx);
			else
				memcpy(crkFirst+(LposCr-(holSize-1))*xx, crkFirst+(LposCr+1+(buns-holSize))*xx, holSize*xx);
		}
		holSize += holPiece;
		if (hghNode != NULL){
			if (hghNode == stopNode)
				break;
			hghNode->hols = 0;
			lowNode = hghNode;
			*(lng*)hghPos = *(lng*)hghPos - holSize;
		} else
			break;
	}

	if (holSize > 0){
		if (hghNode == NULL){
			BUN crkLast = BUNlast(b) - (holSize)*xx;
			b->batBuns->free = crkLast - b->batBuns->base;
	       		BATsetcount(b, b->batBuns->free/xx);
		} else
	                hghNode->hols = holSize;
	}

	return holSize;
}

str
selectMergeDeletionsPart_@1(int *bid, @1 *low, bit *inclusiveLow, @1 *hgh, bit *inclusiveHgh, bit *rippledDeletions, int position){
	BAT *u;
	lng updates, updatesStart, updatesEnd;
	BUN l, lt, updLast;
	int xx;

	if (CrackerIndex[position].did == -1) return NULL;
	if ((u = BATdescriptor(CrackerIndex[position].did)) == NULL)
		return "Cannot access the deletions BAT";			

	if (CrackerIndex[position].mergeInsertions > 0){
                        BAT *insertions, *intersect;
                        if (CrackerIndex[position].iid < 0) goto findDeletes; 
                        if ((insertions = BATdescriptor(CrackerIndex[position].iid)) == NULL)
                                goto findDeletes;
                        if (BATcount(insertions)==0) {
                                BBPunfix(insertions->batCacheid);
                                goto findDeletes;
                        }

                        intersect = BATsintersect(insertions,u);

                        if (BATcount(intersect)>0){
                                insertions = BATdel(insertions,intersect,TRUE);
                                u = BATdel(u,intersect,TRUE);
                        }

                        BBPunfix(intersect->batCacheid);
                        BBPunfix(insertions->batCacheid);
        }

	findDeletes:;
	
	updates = BATcount(u);
	if (updates == 0){
		BBPunfix(u->batCacheid);
                return NULL; /* no qualifying values in the deletions */
        }
	xx = BUNsize(u);

	/* if necessary, sort in place the deletions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	/* binary search to find the position of the lowest requested value in the deletions*/
	l = SORTfndfirst_@4(u,low);
	lt = BUNtloc(u,l);
	updLast = BUNtloc(u, BUNlast(u));

        /* no qualifying values in the deletions */
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; 
	}

	if (@2_EQ(lt,low,@3@1) && *inclusiveLow == FALSE){
		while (lt < updLast && @2_EQ(lt,low,@3@1))
			lt +=xx;
	} 
			
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the deletions */
	}

	if ( @2_GT(lt,hgh,@3@1) || (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh==FALSE) ){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the deletions */ 	
	}

	updatesStart = BUNindex(u,lt);	
	
	/* binary search to find the position of the highest requested value in the deletions */
        l = SORTfndfirst_@4(u, hgh);
	lt = BUNtloc(u,l);
	if (lt < updLast){
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == TRUE){	
			while (lt < updLast && @2_EQ(lt,hgh,@3@1))
                         	lt +=xx;
			lt-=xx;
		} else
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == FALSE)
                        lt -=xx;
		else
		if ( @2_GT(lt,hgh,@3@1) )
                        lt -=xx;
	}

	if (lt == updLast) lt-=xx;
	updatesEnd = BUNindex(u,lt);

	BBPunfix(u->batCacheid);
		
	if (CrackerIndex[position].mergeDeletions == 0){	
		/* merge completely */
		mergeDeletions_@1(bid, &CrackerIndex[position].did, 0, updates-1);
		CrackerIndex[position].mergeDeletions = -1 ;
		CrackerIndex[position].did = -1;

	} else if (CrackerIndex[position].mergeDeletions == 1)
		/* merge only the requested values */			
		mergeDeletionsGradually_@1(bid, &CrackerIndex[position].did, updatesStart, updatesEnd);
			
	else if (CrackerIndex[position].mergeDeletions == 2){
		/* merge only the requested values using the ripple strategy */
		mergeDeletionsGraduallyRipple_@1(bid, &CrackerIndex[position].did, updatesStart, updatesEnd, low, *inclusiveLow, hgh, *inclusiveHgh);	
		*rippledDeletions = TRUE;
	}

	return NULL;
}

str
selectMergeInsertionsPart_@1(int *bid, @1 *low, bit *inclusiveLow, @1 *hgh, bit *inclusiveHgh, int position){
	BAT *u;
	lng updates, updatesStart, updatesEnd;
	BUN l, lt, updLast;
	int xx;
	 if (CrackerIndex[position].iid == -1) return NULL;
	if ((u = BATdescriptor(CrackerIndex[position].iid)) == NULL)
		return "Cannot access insertions BAT";			

	updates = BATcount(u);
	if (updates == 0){
        	BBPunfix(u->batCacheid);
                return NULL; /* no qualifying values in the insertions */
        }

	/* if necessary, sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	/* binary search to find the position of the lowest requested value in the insertions */
	l = SORTfndfirst_@4(u,low);
	lt = BUNtloc(u,l);
	updLast = BUNtloc(u, BUNlast(u));
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	xx = BUNsize(u);
	if (@2_EQ(lt,low,@3@1) && *inclusiveLow == FALSE){
		while (lt < updLast && @2_EQ(lt,low,@3@1))
			lt +=xx;
	} 			
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	if ( @2_GT(lt,hgh,@3@1) || (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh==FALSE) ){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */ 	
	}
	updatesStart = BUNindex(u,lt);	
	
	/* binary search to find the position of the highest requested value in the insertions */
        l = SORTfndfirst_@4(u, hgh);
	lt = BUNtloc(u,l);
	if (lt < updLast){
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == TRUE){	
			while (lt < updLast && @2_EQ(lt,hgh,@3@1))
                            	lt +=xx;
			lt-=xx;
		} else
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == FALSE)
                        lt -=xx;
		else
		if ( @2_GT(lt,hgh,@3@1) )
                        lt -=xx;
	}

	if (lt == updLast) lt-=xx;
	updatesEnd = BUNindex(u,lt);

	BBPunfix(u->batCacheid);
	
	if (CrackerIndex[position].mergeInsertions == 0){	
		/* merge completely */
		mergeInsertionsB_@1(bid, &CrackerIndex[position].iid, 0, updates-1);
		CrackerIndex[position].mergeInsertions = -1 ;
		CrackerIndex[position].iid = -1;

	} else if (CrackerIndex[position].mergeInsertions == 1)
		/* merge only the requested values */			
		mergeInsertionsBGradually_@1(bid, &CrackerIndex[position].iid, updatesStart, updatesEnd);

	 else if (CrackerIndex[position].mergeInsertions == 2) 
		/* merge only the requested values using the ripple strategy */
		mergeInsertionsBRipple_@1(bid, &CrackerIndex[position].iid, updatesStart, updatesEnd, hgh, *inclusiveHgh);	

	return NULL;
}

/* This function takes a range and returns a view with the result. 
To do that, we first search the index to determine which parts of the result we already
know and which parts we have to crack. Then we crack, if necessary,
the appropriate pieces, update the index and return the result */
str
CRKRangeTree_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail){
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1, posl, posh;
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl1, ch1, cl2, ch2;
	/* index values in the case we have to crack
		|cl1...........ch1|.....................|cl2.........ch2|
		if we have to crack only one piece, i.e., if our range falls
		in one piece only then we crack from cl to ch otherwise we use
		the other indices as it is shown */
	int xx, zz;
	int _vl;
	bit HBound, foundLow=0, foundHgh=0;
	int gapL = 1;
	int gapH = 1;
	bit rippledDeletions = FALSE;
	struct Node *lowNode=NULL, *hghNode=NULL, *lowNodeNext=NULL, *temp;
	BUN idxFirst;
	
	if (@2_GT(low,hgh,@3@1))
		throw(MAL, "crackers.crack", "illegal range");
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsCrackerIndex(*bid);

	/* if this is the first time we select something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		/*BATkey(b,TRUE);*/
		BATkey(BATmirror(b),FALSE);
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newCrackerIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack
		   anyway so crack in three pieces cl-ch */
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));

		/*printf(" "LLFMT" \n ",posh-posl);*/
		@:crkThreeTree(@1,posl,posh)@
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before)
		we search the index to find where our range falls after this
		search if we have a match on the low range vl will hold the
		index value, otherwise it will be -1. The same for hgh and vh
		if there is no match for low then cl will hold the index that
		from there on we have to crack. The same from hgh and ch
		Note that in the case of the low range  we always have to increment
		by one since we want the values that are after this index
		(because of the way the crack index is created).
		Also after the search l and h should point to the low and hgh indices
		(in the crack index) found either as a match or to crack.
		This is used later on to determine which pieces we have to crack */

	/* Check if this bat was previously cracked but the map is not there anymore
		this may happen if we chose to forget the index because of updates, so now we
		have to create a new one and crack in three pieces anyway */
	if (CrackerIndex[m].reCreate == 1){
		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access cracker index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access cracker BAT");
	
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));

		@:crkThreeTree(@1,posl,posh)@
		goto createView;
	}
	
	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(b);
	zz = BUNsize(c);
	idxFirst = BUNfirst(c);

	/* deal with pending deletions if any */
	if (CrackerIndex[m].mergeDeletions >= 0){
		str msg = selectMergeDeletionsPart_@1(bid, low, inclusiveLow, hgh, inclusiveHgh, &rippledDeletions, m);
		if (msg != NULL)
			throw(MAL, "crackers.crackRange",msg);
	}
	
	if (CrackerIndex[m].mergeDeletions == 2 && rippledDeletions == FALSE){
		lowNode = findNodeL_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, idxFirst, zz, NULL);
                if (lowNode == NULL){
                        lowNodeNext = NULL;
                        temp = CrackerIndex[m].Tree;
                        if (temp->deleted == FALSE)
                                lowNodeNext = temp;
                        while (temp->left != NULL){
                                temp = temp->left;
                                if (temp->deleted == FALSE)
                                        lowNodeNext = temp;
                        }
                } else
                        lowNodeNext = findNextPiece(lowNode);

		shiftHoles_@1(lowNode, lowNodeNext, b, xx, c, idxFirst, zz, hgh, inclusiveHgh, m);	
	}

	/* deal with pending insertions if any */
	if (CrackerIndex[m].mergeInsertions >= 0){
		str msg = selectMergeInsertionsPart_@1(bid, low, inclusiveLow, hgh, inclusiveHgh, m);
                if (msg != NULL)
                        throw(MAL, "crackers.crackRange",msg);
	}

	/* find out where in the index the low	 falls */
	
	foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0) cl1++;
	if (cl2 != 0) cl2++;

	/* find the hols if any in the pieces to crack so that cracking does not touch deleted buns */
        if (CrackerIndex[m].mergeDeletions == 2){
		lng holsLow = 0, holsHgh = 0;
		/* if not done before while shifting hols find lowNode and lowNodeNext */
		if (rippledDeletions == TRUE){
			lowNode = findNodeL_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, idxFirst, zz, NULL);
       	         	if (lowNode == NULL){
                        	lowNodeNext = NULL;
                   		temp = CrackerIndex[m].Tree;
                        	if (temp->deleted == FALSE)
                                	lowNodeNext = temp;
                        	while (temp->left != NULL){
                                	temp = temp->left;
                                	if (temp->deleted == FALSE)
                                	        lowNodeNext = temp;
                        	}
                	} else
                        	lowNodeNext = findNextPiece(lowNode);
		}

		hghNode = findNodeH_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, idxFirst, zz, NULL);
		if (lowNodeNext != NULL)
			holsLow = lowNodeNext->hols;

		if (hghNode != NULL)
			holsHgh = hghNode->hols;

		/* so if there are hols the positions where we crack are appropriately decreased */
		ch1 -= holsLow;
		ch2 -= holsHgh;
	}	


	/* If one or both of the result view bounds were not found using the
	index then we have to crack */
	if (foundLow == 0 || foundHgh == 0){
		if (foundLow == 0 && foundHgh == 0){
			/* If ch2 is right after cl1 in the index then we split this piece in three pieces*/
			if (cl1 == cl2){
				/*CRACK in three pieces cl1-ch2 */
				@:crkThreeTree(@1,cl1,ch2)@

			} else {
				/* Else we have to do two cracks separatelly */
	
				/* For the cl bound and the next one in the index*/
				@:crkTwoLTree(@1)@

				/* For the ch bound and the previous one in the index*/
				@:crkTwoRTree(@1)@

				if (IndexSize <IndexStop){
					if (vl>0) _vl=vl-1; else _vl=vl;		
					if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
					if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
				}
			}
		} else
		if (foundLow == 0){
			@:crkTwoLTree(@1)@
			if (IndexSize <IndexStop){
				if (vl>0) _vl=vl-1; else _vl=vl;		
				if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
			}
			vh = ch2;
		} else
		if (foundHgh == 0){
			@:crkTwoRTree(@1)@
			if (IndexSize <IndexStop)
				if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
			vl = cl1;
		} 	
	} else {
		vl = cl1;
		vh = ch2;
	}

	@:CreateResult()@
	return MAL_SUCCEED;
}

str
CRKRangeLeftNilTree_@1(int *vid, int *bid, @1 *hgh, bit *inclusiveHgh, bit tail){
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1;
	lng cl2, ch2;
	int xx;
	bit HBound,foundHgh=0;
	int gapH = 1;
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsCrackerIndex(*bid);

	/* if this is the first time we select something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newCrackerIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		cl2 = BUNindex(b,BUNfirst(b));
		ch2 = BUNindex(b,BUNlast(b)-BUNsize(b));
		@:crkTwoRTree(@1)@
		if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
		vl = BUNindex(b,BUNfirst(b));
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	if (CrackerIndex[m].cid == -1){
		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");
	
		cl2 = BUNindex(b,BUNfirst(b));
		ch2 = BUNindex(b,BUNlast(b)-BUNsize(b));
		@:crkTwoRTree(@1)@
		if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
		vl = BUNindex(b,BUNfirst(b));

		goto createView;
	}

	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	vl = BUNindex(b,BUNfirst(b));

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, HBound, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), xx, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl2 != 0) cl2++;

	if (foundHgh == 0){
		@:crkTwoRTree(@1)@
		if (IndexSize <IndexStop)
			if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
	} 	
	else
		vh = ch2;
		
	@:CreateResult()@
	return MAL_SUCCEED;
}

str
CRKRangeRightNilTree_@1(int *vid, int *bid, @1 *low, bit *inclusiveLow, bit tail){
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1;
	lng cl1, ch1;
	int xx;
	bit foundLow=0;
	int gapL = 1;
	
	m = existsCrackerIndex(*bid);

	/* if this is the first time we select something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newCrackerIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		cl1 = BUNindex(b,BUNfirst(b));
		ch1 = BUNindex(b,BUNlast(b)-BUNsize(b));
		@:crkTwoLTree(@1)@
		if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNindex(b,BUNlast(b)-BUNsize(b));
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	if (CrackerIndex[m].cid == -1){
		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");
	
		cl1 = BUNindex(b,BUNfirst(b));
		ch1 = BUNindex(b,BUNlast(b)-BUNsize(b));
		@:crkTwoLTree(@1)@
		if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNindex(b,BUNlast(b)-BUNsize(b));

		goto createView;
	}


	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	vh = BUNindex(b,BUNlast(b)-BUNsize(b));


	/* find out where in the index the low falls */
	foundLow = GetLow_@1(*low,*inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), xx, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0) cl1++;

	if (foundLow == 0){
		@:crkTwoLTree(@1)@
		if (IndexSize <IndexStop)
			if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
	} 	
	else
		vl = cl1;
		
	@:CreateResult()@
	return MAL_SUCCEED;
}
@

@c
@:crackOperations(chr,simple,,chr)@
@:crackOperations(sht,simple,,sht)@
@:crackOperations(int,simple,,int)@
@:crackOperations(lng,simple,,lng)@
@:crackOperations(flt,simple,,flt)@
@:crackOperations(dbl,simple,,dbl)@
@:crackOperations(date,atom,TYPE_,loc)@

@= SelectFunctions
crackers_export str CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){		
	if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, TRUE);
	else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, TRUE);
	else
		return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);

       	throw(MAL, "crackers.CRKselectBounds_@1", "case not handled");
}

crackers_export str CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, FALSE);
	else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, FALSE);
	else
		return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);

        throw(MAL, "crackers.CRKuselectBounds_@1", "case not handled");
}

crackers_export str CRKselectValue_@1(int *vid, int *bid, @1 *value);
str
CRKselectValue_@1(int *vid, int *bid, @1 *value){
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
}

crackers_export str CRKuselectValue_@1(int *vid, int *bid, @1 *value);
str
CRKuselectValue_@1(int *vid, int *bid, @1 *value){
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
}

crackers_export str CRKselect_@1(int *vid, int *bid, @1 *low, @1 *hgh);
str
CRKselect_@1(int *vid, int *bid, @1 *low, @1 *hgh){
	bit inclusive = TRUE;
	return CRKselectBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}

crackers_export str CRKuselect_@1(int *vid, int *bid, @1 *low, @1 *hgh);
str
CRKuselect_@1(int *vid, int *bid, @1 *low, @1 *hgh){
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}
@

@c
@:SelectFunctions(chr,simple,)@
@:SelectFunctions(sht,simple,)@
@:SelectFunctions(int,simple,)@
@:SelectFunctions(lng,simple,)@
@:SelectFunctions(flt,simple,)@
@:SelectFunctions(dbl,simple,)@
@:SelectFunctions(date,atom,TYPE_)@

/* END ---------------------------Select Operators----------------------------------------------------------------*/

/* BEGIN ---------------------------JoinSelect Operators----------------------------------------------------------------*/
@= JoinSelectBody
/* Joins a left=[oid,void] bat with a right=[void, any_type] bat on head-OIDs.
From the right bat, only BUNs that pass the range-restriction on the tail qualify.
The result is a [oid,void] bat. */
	BAT *d;
	BUN rt, rbase, dt;
	int zz, dd;
	oid rmin, rmax;
	bit d_hdense = FALSE;

	rmin = *(oid*)BUNhead(r, BUNfirst(r));
	rmax = rmin + (BATcount(r) - 1);
	zz = BUNsize(r);
	rbase = BUNtloc(r, BUNfirst(r)) - rmin*zz;

	if (!inPlace || l->batParentid != 0 || l->htype == TYPE_void) {
		d = BATnew(TYPE_oid, TYPE_void, MIN(BATcount(l), BATcount(r)));
	} else {
		d = l;
	}

	dt = BUNhloc(d, BUNfirst(d));
	dd = BUNsize(d);

	/* For each BUN of the left bat check if the corresponding BUN in the right bat satisfies the restriction.
	   If yes the respective oid is added to the result */
	if (BAThdense(l)) {
		oid lv = MAX(rmin, *(oid*)BUNhead(l, BUNfirst(l)));
		oid llast = MIN(rmax, lv + (BATcount(l) - 1));
		oid l0 = lv;
		BUN d0 = dt;
		rt = rbase + lv*zz;
		while (lv <= llast) {
			if (@1) {
				*(oid*)dt = lv;
				dt += dd;	
			}		
			lv++;
			rt += zz;
		}
		d_hdense = ((size_t)(dt - d0)/dd == (lv - l0));
	} else {
		int xx = BUNsize(l);
		BUN llast = BUNhloc(l, BUNlast(l));
		BUN lt = BUNhloc(l, BUNfirst(l));
		oid lv = oid_nil;

		if (isForeignKey) {
			while (lt < llast) {
				lv = *(oid*)lt;
				rt = rbase + lv*zz;
				if (@1) {
					*(oid*)dt = lv;
					dt += dd;	
				}	
				lt += xx;
			}
		} else if (BAThordered(l)&1) {
			while(lt < llast && (lv = *(oid*)lt) < rmin) {
				lt += xx;
			}
			while(lt < llast && (lv = *(oid*)lt) <= rmax) {
				rt = rbase + lv*zz;
				if (@1) {
					*(oid*)dt = lv;
					dt += dd;	
				}	
				lt += xx;
			}
		} else {
			while(lt < llast){
			    lv = *(oid*)lt;
			    if (lv >= rmin && lv <= rmax) {
				rt = rbase + lv*zz;
				if (@1){
					*(oid*)dt = lv;
					dt += dd;	
				}	
			    }
			    lt += xx;
			}
		}
	}

	d->batBuns->free = dt - d->batBuns->base;
    	BATsetcount(d, d->batBuns->free/dd);
	d->hsorted = (BATcount(d)<2 || BAThordered(l)&1) ? GDK_SORTED : 0;
	d->hdense = BATcount(d)<2 || d_hdense;
	if (d->hdense) {
		if (BATcount(d)==0) {
			/* does not really matter */
			BATseqbase(d, (oid)0);
		} else {
			BATseqbase(d, *(oid*)BUNhloc(d,BUNfirst(d)));
		}
	} else {
		BATseqbase(d, oid_nil);
	}
	BATkey(d, BATcount(d)<2 || l->hkey);
	d->tsorted = FALSE;
	d->tdense = FALSE;
	BATseqbase(BATmirror(d), oid_nil);
	BATkey(BATmirror(d), FALSE);
	d->batRestricted= BAT_READ;
	BBPkeepref(d->batCacheid);
	*res=d->batCacheid;

	if (d != l) {
		BBPunfix(l->batCacheid);
	}
	BBPunfix(r->batCacheid);
	
	return MAL_SUCCEED;
@

@= JoinSelectR
str
JoinSelectRange_@2_@3_@1(int *res, BAT *l, BAT *r, @1 *low, @1 *hgh, bit inPlace, bit isForeignKey){
	@:JoinSelectBody(@6_@4(rt,low,@7@1) && @6_@5(rt,hgh,@7@1))@
}
@

@= JoinSelectS
str
JoinSelectSingle_@2_@1(int *res, BAT *l, BAT *r, @1 *mid, bit inPlace, bit isForeignKey){
	@:JoinSelectBody(@4_@3(rt,mid,@5@1))@
}
@

@= JoinSelectOperations
@:JoinSelectR(@1,LO,RE,GT,LE,@2,@3)@
@:JoinSelectR(@1,LE,RE,GE,LE,@2,@3)@
@:JoinSelectR(@1,LO,RO,GT,LT,@2,@3)@
@:JoinSelectR(@1,LE,RO,GE,LT,@2,@3)@
@:JoinSelectS(@1,RO,LT,@2,@3)@
@:JoinSelectS(@1,RE,LE,@2,@3)@
@:JoinSelectS(@1,LO,GT,@2,@3)@
@:JoinSelectS(@1,LE,GE,@2,@3)@
@

@c
@:JoinSelectOperations(chr,simple,)@
@:JoinSelectOperations(sht,simple,)@
@:JoinSelectOperations(int,simple,)@
@:JoinSelectOperations(lng,simple,)@
@:JoinSelectOperations(flt,simple,)@
@:JoinSelectOperations(dbl,simple,)@
@:JoinSelectOperations(date,atom,TYPE_)@

@= JoinSelectFunctions
crackers_export str CRKjoinSelectDefault_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left);
crackers_export str CRKjoinSelectBounds_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left, bit *inPlace, bit *isForeignKey);

str
CRKjoinSelectDefault_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left){
	bit inPlace = FALSE;
	bit isForeignKey = FALSE;
	return CRKjoinSelectBounds_@1( res, right, low, hgh, inclusiveLow, inclusiveHgh, left, &inPlace, &isForeignKey);
}

str
CRKjoinSelectBounds_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left, bit *inPlace, bit *isForeignKey){
	BAT *l, *r;

	if ((l = BATdescriptor(*left)) == NULL) 
        	throw(MAL, "crackers.crackJoinSelect", "Cannot access descriptor");

	if ((r = BATdescriptor(*right)) == NULL) {
		BBPunfix(*left);
        	throw(MAL, "crackers.crackJoinSelect", "Cannot access descriptor");
        }

	if (!BAThdense(r)) {
		BBPunfix(*left);
		BBPunfix(*right);
		throw(MAL, "crackers.crackJoinSelect", "right BAT must have a dense head");
	}

	if (BATcount(l) == 0 || BATcount(r) == 0){
		BAT *d = BATnew(TYPE_oid, TYPE_void, 0);
		d->batBuns->free = 0;
		BATsetcount(d, 0);
		d->hsorted = GDK_SORTED;
		d->hdense = TRUE;
		BATseqbase(d, (oid)0);
		BATkey(d, TRUE);
		d->tsorted = FALSE;
		d->tdense = FALSE;
		BATseqbase(BATmirror(d), oid_nil);
		BATkey(BATmirror(d), FALSE);
		d->batRestricted= BAT_READ;
		BBPkeepref(d->batCacheid);
		*res = d->batCacheid;
		BBPunfix(*left);
		BBPunfix(*right);
		return MAL_SUCCEED;
	}	

        if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingle_RE_@1(res, l, r, hgh, *inPlace, *isForeignKey);
		else
                	return JoinSelectSingle_RO_@1(res, l, r, hgh, *inPlace, *isForeignKey);
	}
        else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingle_LE_@1(res, l, r, low, *inPlace, *isForeignKey);
		else
                	return JoinSelectSingle_LO_@1(res, l, r, low, *inPlace, *isForeignKey);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRange_LE_RE_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRange_LE_RO_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRange_LO_RO_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRange_LE_RE_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
	}
        throw(MAL, "crackers.crackJoinSelect", "case not handled");
}
@

@c
@:JoinSelectFunctions(chr,simple,)@
@:JoinSelectFunctions(sht,simple,)@
@:JoinSelectFunctions(int,simple,)@
@:JoinSelectFunctions(lng,simple,)@
@:JoinSelectFunctions(flt,simple,)@
@:JoinSelectFunctions(dbl,simple,)@
@:JoinSelectFunctions(date,atom,TYPE_)@
/* END ---------------------------JoinSelect Operators----------------------------------------------------------------*/

/* BEGIN -------------------------------------- Sideways Cracking -------------------------------------------------------------------*/

@= crackAlgebraSideways
command hselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKhselectBoundsSideways_@1_@2
comment "Retrieve the subset head using a cracker
        index producing preferably a BATview.";

command tselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKtselectBoundsSideways_@1_@2
comment "Retrieve the subset tail using a cracker
        index producing preferably a BATview.";

command joinselect( b:bat[:oid,:@2],l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";

command joinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command project( b:bat[:oid,:@1],bp:bat[:oid,:@2], l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectCrack_@1_@2
comment "Sync and project the tail of the cpair";

command project( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProject_@1_@2
comment "Sync the cracking pair and project the tail";

command projectH( b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKProjectH_@1_@2
comment "Sync the cracking pair and project the head";
@

@:crackAlgebraSideways(int,chr)@
@:crackAlgebraSideways(int,sht)@
@:crackAlgebraSideways(int,int)@
@:crackAlgebraSideways(int,lng)@
@:crackAlgebraSideways(int,flt)@
@:crackAlgebraSideways(int,dbl)@
@:crackAlgebraSideways(int,date)@
@:crackAlgebraSideways(date,chr)@
@:crackAlgebraSideways(date,sht)@
@:crackAlgebraSideways(date,int)@
@:crackAlgebraSideways(date,lng)@
@:crackAlgebraSideways(date,flt)@
@:crackAlgebraSideways(date,dbl)@
@:crackAlgebraSideways(date,date)@

/* The cracking functions. Always crack based on the head */
@= shuffleSideways
	hdummy = *(@1*) @3;
	*(@1*) @3= *(@1*) @4;
        *(@1*) @4= hdummy;

	tdummy= *(@2*) @5;
        *(@2*) @5= *(@2*) @6;
        *(@2*) @6 = tdummy;
@

@= crackInTwoUnorderedPiecesSideways
crackers_export str CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, lng first, lng last, lng *pos);
str
CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, lng first, lng last, lng *pos){
        BUN vm, vl;
        BUN vmt, vlt;
        int xx;
        @1 hdummy;
        @2 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNhloc(b, BUNptr(b,first));
        vl= BUNhloc(b,BUNptr(b,last));
        vmt = BUNtloc(b, BUNptr(b,first));
        vlt= BUNtloc(b,BUNptr(b,last));

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  += xx; 
			vmt += xx;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  -= xx; 
				vlt -= xx;
			}
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        vl  -= xx;
			vlt -= xx;
                        vm  += xx;
			vmt += xx;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = BUNindex(b,vl - xx); /*works for empty left piece also*/
		else{
			*pos = BUNindex(b,vl);
			if (BUNindex(b,vl)==(size_t)last) /*empty right piece*/
				*pos = *pos+1;
		}
	}
	else
		*pos = BUNindex(b,vl);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPiecesSideways

crackers_export str CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh);
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh){
        BUN vm, vl, hmax;
        BUN vmt, vlt, hmaxt;
        int xx;
        @1 hdummy;
        @2 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNhloc(b, BUNptr(b,first));
        hmax = BUNhloc(b,BUNptr(b,last));
        vmt = BUNtloc(b, BUNptr(b,first));
        hmaxt = BUNtloc(b,BUNptr(b,last));
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm)
                hmax-= xx; hmaxt-= xx;

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = BUNindex(b,hmax);
		else{
			*posl = BUNindex(b, hmax + xx);
			*posh = BUNindex(b,hmax);
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax-=xx;hmaxt-=xx;
                }
                vl-= xx; vlt-= xx;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
			*posl = BUNindex(b,vl);
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = BUNindex(b,vl);
		else
			*posl = BUNindex(b,vl + xx);
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm += xx; vmt += xx;
                } else {
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                                        hmax-=xx; hmaxt-=xx;
                                }
                                vl -= xx; vlt -= xx;
                        }
                }
        }
	if (vm ==  BUNhloc(b,BUNptr(b,last+1))){ /* Right and middle are empty */
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = BUNindex(b,vl + xx);
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
	*posl = BUNindex(b,vm);
	*posh = BUNindex(b,hmax);

	return MAL_SUCCEED;
}
@

@= operationsSideways
@:crackInTwoUnorderedPiecesSideways(@1,@2,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways(@1,@2,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways(@1,@2,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways(@1,@2,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways(@1,@2,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways(@1,@2,LE,RO,LT,GE,LT,GE,@3,@4)@
@

@c
@:operationsSideways(int,int,simple,)@
@:operationsSideways(int,sht,simple,)@
@:operationsSideways(int,chr,simple,)@
@:operationsSideways(int,lng,simple,)@
@:operationsSideways(int,flt,simple,)@
@:operationsSideways(int,dbl,simple,)@
@:operationsSideways(int,date,simple,)@  /* TODO: add the rest of the type combinations once code is stable */
@:operationsSideways(date,int,atom,TYPE_)@
@:operationsSideways(date,sht,atom,TYPE_)@
@:operationsSideways(date,chr,atom,TYPE_)@
@:operationsSideways(date,lng,atom,TYPE_)@
@:operationsSideways(date,flt,atom,TYPE_)@
@:operationsSideways(date,dbl,atom,TYPE_)@
@:operationsSideways(date,date,atom,TYPE_)@  /* TODO: add the rest of the type combinations once code is stable */

int
existsCrackerIndexSideways(int bid, int pbid){
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == bid && CrackerIndex[i].pbid == pbid)
			return i;
	return -1;
}

@= NewIndexSidewaysCracking
int
newCrackerIndexHistorySideways_@1(int bid, int chid, int hiid){
        int i, freemap = -1, units = 1024;

        for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == -1)
                        freemap = i;

        if (freemap != -1) {
                CrackerIndex[freemap].bid = bid;
                CrackerIndex[freemap].chid = chid;
                CrackerIndex[freemap].hiid = hiid;
                return freemap;
        }

        if (i == maxCrackMap) {
                CrackerIndexNode *x;

                if (maxCrackMap > 0)
                        units = (int) (1.2 * maxCrackMap);
                x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
                memset(x, 0, sizeof(CrackerIndexNode) * units);
                if (CrackerIndex) {
                        fprintf(stderr, "reallocate index \n");
                        memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
                        GDKfree(CrackerIndex);
                }
                CrackerIndex = x;
                maxCrackMap = units;
        }

        CrackerIndex[i].chid = chid;
        CrackerIndex[i].hiid = hiid;
        CrackerIndex[i].pbid = -1;
        CrackerIndex[i].bid = bid;
        CrackerIndex[i].cbid = -1;
        CrackerIndex[i].cid = -1;
        CrackerIndex[i].iid = -1;
        CrackerIndex[i].did = -1;
        CrackerIndex[i].mergeInsertions = -1;
        CrackerIndex[i].reCreate = 0;
        CrackerIndex[i].Tree = NULL;
        CrackerIndex[i].deleteNodes = FALSE;
        CrackerIndex[i].mergeDeletions = -1;
        return i;
}

int
newCrackerIndexSideways_@1(int bid, int cbid, int pbid){
	int i, freemap = -1, units = 1024;
	BAT *b;
	
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		CrackerIndex[freemap].bid = bid;
		CrackerIndex[i].pbid = pbid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackerIndexNode *x;

		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
		memset(x, 0, sizeof(CrackerIndexNode) * units);
		if (CrackerIndex) {
			fprintf(stderr, "reallocate index \n");
			memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
			GDKfree(CrackerIndex);
		}
		CrackerIndex = x;
		maxCrackMap = units;
	}

	CrackerIndex[i].nextCrack = 0;
	CrackerIndex[i].chid = -1;
	CrackerIndex[i].hiid = -1;
	CrackerIndex[i].pbid = pbid;  /* this line is the only addittion compared to the non projections function */
	CrackerIndex[i].bid = bid;
	CrackerIndex[i].cbid = cbid;
	b = BATnew(TYPE_lng, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	CrackerIndex[i].cid = b->batCacheid;
	CrackerIndex[i].iid = -1;
	CrackerIndex[i].did = -1;
	CrackerIndex[i].mergeInsertions = -1;
	CrackerIndex[i].reCreate = 0;
	CrackerIndex[i].Tree = NULL;
	CrackerIndex[i].deleteNodes = FALSE;
	CrackerIndex[i].mergeDeletions = -1;
	return i;
}
@

@c
@:NewIndexSidewaysCracking(chr)@
@:NewIndexSidewaysCracking(sht)@
@:NewIndexSidewaysCracking(int)@
@:NewIndexSidewaysCracking(lng)@
@:NewIndexSidewaysCracking(flt)@
@:NewIndexSidewaysCracking(dbl)@
@:NewIndexSidewaysCracking(date)@

/* function "reCreateMap" is used as is in selections cracking */

@= crkTwoRTreeSideways
        /*CRACK in two pieces cl2-ch2 using <incHgh bound*/
        if (*inclusiveHgh == TRUE)
                CRKcrackUnorderedZeroSideways_LE_@1_@2(b,*hgh, cl2, ch2,&vh);
        else
                CRKcrackUnorderedZeroSideways_RE_@1_@2(b,*hgh, cl2, ch2,&vh);

        /*check for gaps*/
        if (vh < cl2)
                /*then the left piece is empty*/
                gapH = -1;
        if (vh > ch2){
                /*then the right piece is empty*/
                gapH = -1;
                vh--;
        }

@= crkTwoLTreeSideways
        /*CRACK in two pieces cl1-ch1 using >incLow bound*/
        if (*inclusiveLow == TRUE)
                CRKcrackUnorderedZeroSideways_RE_@1_@2(b,*low, cl1, ch1,&vl);
        else
                CRKcrackUnorderedZeroSideways_LE_@1_@2(b,*low, cl1, ch1,&vl);
        if (vl < cl1){
                /*then the left piece is empty*/
                gapL = -1;
        }
        if (vl > ch1){
                /*then the right piece is empty*/
                vl--;
                gapL = -1;
        }
        vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
                Instead we want the first bun of the right piece*/
@

@= crkThreeTreeSideways
        if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeSideways_LE_RE_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeSideways_LE_RO_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeSideways_LO_RE_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeSideways_LO_RO_@1_@2(b,*low,*hgh, @3, @4, &vl, &vh);

        if (vl != -1 && vh != -1){
                if (vl>0) _vl=vl-1; else _vl=vl;
                addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
                addCrackerIndex_@1(m,hgh,HBound,vh,c);
        }
@

@= SyncOperation
str
Sync_@1_@2(int m, int h){
	BAT *h1,*h2,*b, *c;
	BUN h1head,h1tail,h2head,h2tail;
	int h1size, h2size, zz;
	lng syncs;
	lng size;

        lng vl=-1, vh=-1;
        lng cl1, ch1, cl2, ch2;
        int _vl;
        bit HBound, foundLow=0, foundHgh=0;
        int gapL = 1;
        int gapH = 1;
	bit *inclusiveHgh,*inclusiveLow;
	@1 *low, *hgh;
	lng j;

        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

	 /* Take the index of the bat */
        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");


        if ((h1 = BATdescriptor(CrackerIndex[h].chid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");

        if ((h2 = BATdescriptor(CrackerIndex[h].hiid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");

	/* check if the current pair is already synced */	
	size = BATcount(h1);
	if (CrackerIndex[m].nextCrack == size)
		goto done;

	syncs = size - CrackerIndex[m].nextCrack;
	h1size = BUNsize(h1);
	h2size = BUNsize(h2);

	h1head = BUNhloc(h1, BUNfirst(h1)+h1size*CrackerIndex[m].nextCrack);
	h1tail = BUNtloc(h1, BUNfirst(h1)+h1size*CrackerIndex[m].nextCrack);
	h2head = BUNhloc(h2, BUNfirst(h2)+h2size*CrackerIndex[m].nextCrack);
	h2tail = BUNtloc(h2, BUNfirst(h2)+h2size*CrackerIndex[m].nextCrack);
        zz = BUNsize(c);

	if (CrackerIndex[m].nextCrack == 0){
		low = (@1*)h1head;
                hgh = (@1*)h1tail;
                inclusiveLow = (bit*)h2head;
                inclusiveHgh = (bit*)h2tail;
                if (*inclusiveHgh == TRUE) HBound = FALSE;
                else HBound = TRUE;

		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
			lng posl = BUNindex(b,BUNfirst(b));
        	        lng posh = BUNindex(b,BUNlast(b)-BUNsize(b));
	
                	@:crkThreeTreeSideways(@1,@2,posl,posh)@
		}

		h1head += h1size;
                h1tail += h1size; 
                h2head += h2size;
                h2tail += h2size;
	}	

	for (j=0; j<syncs; j++){
		low = (@1*)h1head; 
		hgh = (@1*)h1tail; 
		inclusiveLow = (bit*)h2head; 
		inclusiveHgh = (bit*)h2tail; 
		if (*inclusiveHgh == TRUE) HBound = FALSE;
		else HBound = TRUE;

		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
        
       		 	/* find out where in the index the low   falls */
               	 	foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
        
        		/* find out where in the index the high falls */        
			foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
                
			/*need to increase one position for the low bound only since we always store the previous position in the index*/
        		if (cl1 != 0) cl1++;
        		if (cl2 != 0) cl2++;
        
       			 /* If one or both of the result view bounds were not found using the
        		index then we have to crack */
        		if (foundLow == 0 || foundHgh == 0){
                		if (foundLow == 0 && foundHgh == 0){                         
					/* If ch2 is right after cl1 in the index then we split this piece in three pieces*/   
                        		if (cl1 == cl2){
                                		@:crkThreeTreeSideways(@1,@2,cl1,ch2)@
                        		} else {
                                		/* Else we have to do two cracks separatelly */
                                
                                		/* For the cl bound and the next one in the index*/
                                		@:crkTwoLTreeSideways(@1,@2)@
                                
                                		/* For the ch bound and the previous one in the index*/
                                		@:crkTwoRTreeSideways(@1,@2)@
                                
						if (vl>0) _vl=vl-1; 
						else      _vl=vl;
                                        	if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);                                
                                        	if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
                        		}
                		} else
                		if (foundLow == 0){
                        		@:crkTwoLTreeSideways(@1,@2)@
                                	if (vl>0) _vl=vl-1; else _vl=vl;
					if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
                        		vh = ch2;
                		} else
                		if (foundHgh == 0){
                        		@:crkTwoRTreeSideways(@1,@2)@
                                	if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
                       		 	vl = cl1;
                		}
        		} else {
                		vl = cl1;
                		vh = ch2;
        		}
		}	

/* TODO fill in the rest of the cases */
/*		if ( (!(@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && ((@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
		}
		if ( ((@3_EQ(h1head,ATOMnilptr(TYPE_@1),@4@1))) && (!(@3_EQ(h1tail,ATOMnilptr(TYPE_@1),@4@1)))){
		}
*/	
		h1head += h1size;
		h1tail += h1size;
		h2head += h2size;
		h2tail += h2size;
	}		
	
	CrackerIndex[m].nextCrack = size;

	done:;
	BBPunfix(h1->batCacheid);
	BBPunfix(h2->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(c->batCacheid);
	return MAL_SUCCEED;
}
@

@= TapeOperations
int
CreateTape_@1(int bid){
	BAT *h1,*h2;
	lng tape_size= 200000;

	h1 = BATnew(TYPE_@1,TYPE_@1,tape_size);		
	h2 = BATnew(TYPE_bit,TYPE_bit,tape_size);		

	h1->batBuns->free =  BUNfirst(h1) - h1->batBuns->base;
        BATsetcount(h1, 0);
	h2->batBuns->free =  BUNfirst(h2) - h2->batBuns->base;
        BATsetcount(h2, 0);

	BBPkeepref(h1->batCacheid);
	BBPkeepref(h2->batCacheid);

	return newCrackerIndexHistorySideways_@1(bid, h1->batCacheid, h2->batCacheid);				
}

str
AddToTape_@1(int h, @1 low, @1 hgh, bit li, bit hi){
	BAT *h1,*h2;
	lng size;	

	if ((h1 = BATdescriptor(CrackerIndex[h].chid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");
                                                
        if ((h2 = BATdescriptor(CrackerIndex[h].hiid)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");
                                                
        size = BATcount(h1);

        *(@1*)BUNhloc(h1, BUNlast(h1)) = low;
        *(@1*)BUNtloc(h1, BUNlast(h1)) = hgh;
        *(bit*)BUNhloc(h2, BUNlast(h2)) = li;
        *(bit*)BUNtloc(h2, BUNlast(h2)) = hi;

	h1->batBuns->free =  (BUNlast(h1)+BUNsize(h1)) - h1->batBuns->base;
        BATsetcount(h1, size+1);
	h2->batBuns->free =  (BUNlast(h2)+BUNsize(h2)) - h2->batBuns->base;
        BATsetcount(h2, size+1);
	
	BBPunfix(h1->batCacheid);
        BBPunfix(h2->batCacheid);
        return MAL_SUCCEED;
}
@

@c
@:SyncOperation(int,chr,simple,)@
@:SyncOperation(int,sht,simple,)@
@:SyncOperation(int,int,simple,)@
@:SyncOperation(int,lng,simple,)@
@:SyncOperation(int,flt,simple,)@
@:SyncOperation(int,dbl,simple,)@
@:SyncOperation(int,date,simple,)@
@:SyncOperation(date,chr,atom,TYPE_)@
@:SyncOperation(date,sht,atom,TYPE_)@
@:SyncOperation(date,int,atom,TYPE_)@
@:SyncOperation(date,lng,atom,TYPE_)@
@:SyncOperation(date,flt,atom,TYPE_)@
@:SyncOperation(date,dbl,atom,TYPE_)@
@:SyncOperation(date,date,atom,TYPE_)@

@:TapeOperations(chr)@
@:TapeOperations(sht)@
@:TapeOperations(int)@
@:TapeOperations(lng)@
@:TapeOperations(flt)@
@:TapeOperations(dbl)@
@:TapeOperations(date)@

@= CreateResultSideways
createView:
        view = BATslice(b, vl, vh+1);

	if (tail)
                view = BATslice(BATmirror(VIEWhead_(BATmirror(b), BAT_READ)), vl, vh+1);
	else 
                view = BATslice(BATmirror(VIEWhead_(b, BAT_READ)), vl, vh+1);

        *vid = view->batCacheid;
        BBPkeepref(*vid);

        BBPunfix(b->batCacheid);
@

@= CreateCrackerMap
		BAT *bo, *bp;
                lng size;
                BUN ptail, ctail, nhead, ntail, nlast;
                int csize, psize, nsize;
		lng j;
                if ((bo = BATdescriptor(*bid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access descriptor");
                if ((bp = BATdescriptor(*pbid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access pdescriptor");

                size = BATcount(bo);
		b = BATnew(bo->ttype, bp->ttype, size);

                nsize = BUNsize(b);
                csize = BUNsize(bo);
                psize = BUNsize(bp);
                nhead = BUNhloc(b,  BUNfirst(b));
                ntail = BUNtloc(b,  BUNfirst(b));
                ctail = BUNtloc(bo, BUNfirst(bo));
                ptail = BUNtloc(bp, BUNfirst(bp));
                for(j=0;j<size;j++){
                        *(@1*)nhead = *(@1*)ctail;
                        *(@2*)ntail = *(@2*)ptail;
                        nhead+=nsize;
                        ntail+=nsize;
                        ctail+=csize;
                        ptail+=psize;
                }

                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;
                /*BATkey(b,TRUE);*/
                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);
	
		nlast = BUNfirst(b) + nsize*size;
        	b->batBuns->free =  nlast - b->batBuns->base;
        	BATsetcount(b, size);

                m = newCrackerIndexSideways_@1(*bid, b->batCacheid, *pbid);

                bo->batRestricted= BAT_READ;
                BBPunfix(bo->batCacheid);
                BBPunfix(bp->batCacheid);
@

@= crackOperationsSideways
str
CRKRangeSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail){
        BAT *b, *c, *view;
        int  m, h;
        lng vl=-1, vh=-1, posl, posh, cl1, ch1, cl2, ch2;
        int zz,_vl;
        int gapL = 1, gapH = 1;
        bit HBound, foundLow=0, foundHgh=0;

        if (@3_GT(low,hgh,@4@1))
                throw(MAL, "crackers.crack", "illegal range");

        if (*inclusiveHgh == TRUE) HBound = FALSE;
        else    HBound = TRUE;

	/* get the cracker tape for this set or create one if it does not exist */
        h = existsCrackerIndexSideways(*bid, -1);
	if (h == -1)
		h = CreateTape_@1(*bid); 

	/* get the map */
        m = existsCrackerIndexSideways(*bid, *pbid);

        /* create the map if it does not exist and perform the fist crack 
	   without searching the index (it is empty at this point) */
        if (m == -1){
		@:CreateCrackerMap(@1,@2)@		

                if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* crack the whole map based on the current restriction */
                posl = BUNindex(b,BUNfirst(b));
                posh = BUNindex(b,BUNlast(b)-BUNsize(b));
                @:crkThreeTreeSideways(@1,@2,posl,posh)@

                BBPincref(b->batCacheid,TRUE);
		
		/* update the cracker tape and the cursor of the map */
		AddToTape_@1(h, *low, *hgh, *inclusiveLow, *inclusiveHgh );
		CrackerIndex[m].nextCrack+=1;

                goto createView;
        }

        /*  Check if this map was previously cracked but the map is not there anymore.
            This may happen if we chose to forget the index because of updates, so now we          
            have to create a new one and crack in three pieces anyway. */

        if (CrackerIndex[m].reCreate == 1){
                
                reCreateMap_@1(m);
                
                /* Take the index of the bat */
                if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)                        
			throw(MAL, "crackers.crackRange", "Cannot access cracker index");
                
                /* Take the copy of the bat for which we maintain the index */
                if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access cracker BAT");
                
                posl = BUNindex(b,BUNfirst(b));
                posh = BUNindex(b,BUNlast(b)-BUNsize(b));
                
                @:crkThreeTreeSideways(@1,@2,posl,posh)@

                goto createView;
        }

	 /* If a map exists for this bat (so it has been cracked before)
            we search its index to find where our range falls.
            If we have a match on the low range vl will hold the
            index value, otherwise it will be -1. The same for hgh and vh.
            If there is no match for low, then cl will hold a position on the map that
            from there on we have to crack. The same from hgh and ch.
            
            In the case of the low range we always have to increment
            by one this position since we want the tuples that are after this position
            (because of the way the crack index maintains information).
            
            After the search l and h point to the low and hgh positions
            (in the cracker index) found either as a match or to crack.
            This is used later on to determine which pieces we have to crack. */
        
	/* Align the map based on the position of its cursor in the cracker tape */
	Sync_@1_@2(m,h);        
        
        /* Take the index of the map */
        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");
        
        /* Take the map */
        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        zz = BUNsize(c);
        
        /* find out where in the index the low falls */
        foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
        
        /* find out where in the index the high falls */        
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), zz, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
                
	/* need to increase one position for the low bound only since we always store the previous position in the index */
        if (cl1 != 0) cl1++;
        if (cl2 != 0) cl2++;
        
        /* If one or both of the selection bounds were not found, then we have to crack */
        if (foundLow == 0 || foundHgh == 0){
                if (foundLow == 0 && foundHgh == 0){                         
			/* If ch2 is right after cl1 in the index then we split this piece in three pieces */   
                        if (cl1 == cl2){
                                @:crkThreeTreeSideways(@1,@2,cl1,ch2)@
                        } else {
                                /* Else we have to do two cracks separatelly */
                                
                                /* For the cl bound and the next one in the index */
                                @:crkTwoLTreeSideways(@1,@2)@
                                
                                /* For the ch bound and the previous one in the index */
                                @:crkTwoRTreeSideways(@1,@2)@
                                
                                if (IndexSize <IndexStop){                                        
					if (vl>0) 
						_vl=vl-1; 
					else 
						_vl=vl;
                                        if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);                                
                                        if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
                                }
                        }
                } else
                if (foundLow == 0){
                        @:crkTwoLTreeSideways(@1,@2)@
                        if (IndexSize <IndexStop){
                                if (vl>0) _vl=vl-1; else _vl=vl;
				if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
                        }
                        vh = ch2;
                } else
                if (foundHgh == 0){
                        @:crkTwoRTreeSideways(@1,@2)@
                        if (IndexSize <IndexStop)
                                if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
                        vl = cl1;
                }
        } else {
                vl = cl1;
                vh = ch2;
        }

	/* Update the cracker tape and the cursor */
	AddToTape_@1(h, *low, *hgh, *inclusiveLow, *inclusiveHgh );
	CrackerIndex[m].nextCrack+=1;

	/* Define resulting view: a contiguous area on the map */	
        @:CreateResultSideways()@

        return MAL_SUCCEED;
}
@

@:crackOperationsSideways(int,chr,simple,)@
@:crackOperationsSideways(int,sht,simple,)@
@:crackOperationsSideways(int,int,simple,)@
@:crackOperationsSideways(int,lng,simple,)@
@:crackOperationsSideways(int,flt,simple,)@
@:crackOperationsSideways(int,dbl,simple,)@
@:crackOperationsSideways(int,date,simple,)@
@:crackOperationsSideways(date,chr,atom,TYPE_)@
@:crackOperationsSideways(date,sht,atom,TYPE_)@
@:crackOperationsSideways(date,int,atom,TYPE_)@
@:crackOperationsSideways(date,lng,atom,TYPE_)@
@:crackOperationsSideways(date,flt,atom,TYPE_)@
@:crackOperationsSideways(date,dbl,atom,TYPE_)@
@:crackOperationsSideways(date,date,atom,TYPE_)@

@= SelectFunctionsSideways
crackers_export str CRKhselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKhselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKhselectBoundsSideways_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKhselectBoundsSideways_@1_@2", "case not handled");
	else
		return CRKRangeSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);

        throw(MAL, "crackers.CRKhselectBoundsSideways_@1_@2", "case not handled");
}

crackers_export str CRKtselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKtselectBoundsSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKtselectBoundsSideways_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKtselectBoundsSideways_@1_@2", "case not handled");
	else
		return CRKRangeSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);

        throw(MAL, "crackers.CRKtselectBoundsSideways_@1_@2", "case not handled");
}
@

@:SelectFunctionsSideways(int,chr,simple,)@
@:SelectFunctionsSideways(int,sht,simple,)@
@:SelectFunctionsSideways(int,int,simple,)@
@:SelectFunctionsSideways(int,lng,simple,)@
@:SelectFunctionsSideways(int,flt,simple,)@
@:SelectFunctionsSideways(int,dbl,simple,)@
@:SelectFunctionsSideways(int,date,simple,)@
@:SelectFunctionsSideways(date,chr,atom,TYPE_)@
@:SelectFunctionsSideways(date,sht,atom,TYPE_)@
@:SelectFunctionsSideways(date,int,atom,TYPE_)@
@:SelectFunctionsSideways(date,lng,atom,TYPE_)@
@:SelectFunctionsSideways(date,flt,atom,TYPE_)@
@:SelectFunctionsSideways(date,dbl,atom,TYPE_)@
@:SelectFunctionsSideways(date,date,atom,TYPE_)@

@= JoinSelectBodySideways
        BAT *b, *p;     
        BUN pairt, pivott, pivotlast;        
	lng size;
	int bsize, psize;
	lng j;

        if ((b = BATdescriptor(*cpair)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
        }  

	size = BATcount(b);
	p = BATnew(TYPE_void,TYPE_bit,size);

	pairt = BUNtloc(b, BUNfirst(b));
	pivott = BUNtloc(p, BUNfirst(p));
	bsize = BUNsize(b);
	psize = BUNsize(p);
	for (j = 0; j<size; j++){
		if (@3)	
			*(bit*)pivott = (bit)TRUE;
		else 
			*(bit*)pivott = (bit)FALSE;

		pairt  += bsize;
		pivott += psize;	
	}

	pivotlast = BUNfirst(p) + psize*size;
        p->batBuns->free =  pivotlast - p->batBuns->base;
        BATsetcount(p, size);	
	
	p->hsorted = FALSE;
        p->tsorted = FALSE;
        p->hdense = FALSE;
        p->tdense = FALSE;

	BBPkeepref(p->batCacheid);
	BBPunfix(b->batCacheid);
	*res = p->batCacheid;

	return MAL_SUCCEED;
@

@= JoinSelectBodySidewaysWithPivot
        BAT *b, *p, *c, *pair;     
        BUN pairt, pivott;        
	lng size;
	int bsize, psize;
	lng skip;
	int m;
	lng cl1,cl2,ch1,ch2;
	lng j;

	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	if ((pair = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");

        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        GetLow_@1(*low1, *inclusiveLow1, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

        GetHgh_@1(*hgh1, *inclusiveHgh1, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

	if (cl1 != 0) cl1++;

        b = BATslice(pair, cl1, ch2+1);

        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
	
	size = BATcount(p);
	pairt = BUNtloc(b, BUNfirst(b));
	pivott = BUNtloc(p, BUNfirst(p));
	bsize = BUNsize(b);
	psize = BUNsize(p);
	skip = 0;
	for (j = 0; j<size; j++){
		if (*(bit*)pivott == TRUE){
	        	pairt += skip*bsize;	
			if (!(@3))	
				*(bit*)pivott = FALSE;
			skip = 0;
		}
		pivott += psize;	
		skip++;
	}

	BBPunfix(pair->batCacheid);
	BBPkeepref(p->batCacheid);
	*res = p->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
@

@= JoinSelectRSidewaysWithoutPivot
str
JoinSelectRangeSideways_@3_@4_@2(int *res, int *cpair, @2 *low, @2 *hgh){
        @:JoinSelectBodySideways(,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}

@= JoinSelectRSideways
str
JoinSelectRangeSideways_P_@3_@4_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *low, @2 *hgh, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1){
        @:JoinSelectBodySidewaysWithPivot(@1,@2,@7_@5(pairt,low,@8@2) && @7_@6(pairt,hgh,@8@2))@
}
@

@= JoinSelectSidewaysWithoutPivot
str
JoinSelectSingleSideways_@3_@2(int *res, int *cpair, @2 *mid){
        @:JoinSelectBodySideways(,@2,@5_@4(pairt,mid,@6@2))@
}

@= JoinSelectSideways
str
JoinSelectSingleSideways_P_@3_@1_@2(int *res, int *bid, int *pbid, int *pivot, @2 *mid, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1){
        @:JoinSelectBodySidewaysWithPivot(@1,@2,@5_@4(pairt,mid,@6@2))@
}
@

@= JoinSelectOperationsSideways
@:JoinSelectRSideways(@1,@2,LO,RE,GT,LE,@3,@4)@
@:JoinSelectRSideways(@1,@2,LE,RE,GE,LE,@3,@4)@
@:JoinSelectRSideways(@1,@2,LO,RO,GT,LT,@3,@4)@
@:JoinSelectRSideways(@1,@2,LE,RO,GE,LT,@3,@4)@
@:JoinSelectSideways(@1,@2,RO,LT,@3,@4)@
@:JoinSelectSideways(@1,@2,RE,LE,@3,@4)@
@:JoinSelectSideways(@1,@2,LO,GT,@3,@4)@
@:JoinSelectSideways(@1,@2,LE,GE,@3,@4)@
@

@= JoinSelectOperationsSidewaysWithoutPivot
@:JoinSelectRSidewaysWithoutPivot(,@2,LO,RE,GT,LE,@3,@4)@
@:JoinSelectRSidewaysWithoutPivot(,@2,LE,RE,GE,LE,@3,@4)@
@:JoinSelectRSidewaysWithoutPivot(,@2,LO,RO,GT,LT,@3,@4)@
@:JoinSelectRSidewaysWithoutPivot(,@2,LE,RO,GE,LT,@3,@4)@
@:JoinSelectSidewaysWithoutPivot(,@2,RO,LT,@3,@4)@
@:JoinSelectSidewaysWithoutPivot(,@2,RE,LE,@3,@4)@
@:JoinSelectSidewaysWithoutPivot(,@2,LO,GT,@3,@4)@
@:JoinSelectSidewaysWithoutPivot(,@2,LE,GE,@3,@4)@
@

@= JoinSelectFunctionsSidewaysWithoutPivot
crackers_export str CRKjoinSelectSideways_@2(int *res, int *cpair, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str                     
CRKjoinSelectSideways_@2(int *res, int *cpair, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh){               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingleSideways_RE_@2(res, cpair, hgh);
		else
                	return JoinSelectSingleSideways_RO_@2(res, cpair, hgh);
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingleSideways_LE_@2(res, cpair, low);
		else
                	return JoinSelectSingleSideways_LO_@2(res, cpair, low);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_LE_RE_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_LE_RO_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_LO_RO_@2(res, cpair, low, hgh);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_LE_RE_@2(res, cpair, low, hgh);
	}
        throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
}

@= JoinSelectFunctionsSideways
crackers_export str CRKjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str                     
CRKjoinSelectSideways_P_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh){               
        if (@3_EQ(low,ATOMnilptr(TYPE_@2),@4@2)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingleSideways_P_RE_@1_@2(res, bid, pbid, pivot, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
                	return JoinSelectSingleSideways_P_RO_@1_@2(res, bid, pbid, pivot, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
	}
        else if (@3_EQ(hgh,ATOMnilptr(TYPE_@2),@4@2))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingleSideways_P_LE_@1_@2(res, bid, pbid, pivot, low, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
                	return JoinSelectSingleSideways_P_LO_@1_@2(res, bid, pbid, pivot, low, low1, hgh1, inclusiveLow1, inclusiveHgh1);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_P_LE_RE_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_P_LE_RO_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRangeSideways_P_LO_RO_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRangeSideways_P_LE_RE_@1_@2(res, bid, pbid, pivot, low, hgh, low1, hgh1, inclusiveLow1, inclusiveHgh1);
	}
        throw(MAL, "crackers.crackJoinSelectSideways", "case not handled");
}
@

@:JoinSelectOperationsSidewaysWithoutPivot(,chr,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,sht,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,int,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,lng,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,flt,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,dbl,simple,)@
@:JoinSelectOperationsSidewaysWithoutPivot(,date,atom,TYPE_)@

@:JoinSelectOperationsSideways(int,chr,simple,)@
@:JoinSelectOperationsSideways(int,sht,simple,)@
@:JoinSelectOperationsSideways(int,int,simple,)@
@:JoinSelectOperationsSideways(int,lng,simple,)@
@:JoinSelectOperationsSideways(int,flt,simple,)@
@:JoinSelectOperationsSideways(int,dbl,simple,)@
@:JoinSelectOperationsSideways(int,date,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,chr,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,sht,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,int,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,lng,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,flt,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,dbl,atom,TYPE_)@
@:JoinSelectOperationsSideways(date,date,atom,TYPE_)@

@:JoinSelectFunctionsSidewaysWithoutPivot(,chr,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,sht,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,int,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,lng,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,flt,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,dbl,simple,)@
@:JoinSelectFunctionsSidewaysWithoutPivot(,date,atom,TYPE_)@

@:JoinSelectFunctionsSideways(int,chr,simple,)@
@:JoinSelectFunctionsSideways(int,sht,simple,)@
@:JoinSelectFunctionsSideways(int,int,simple,)@
@:JoinSelectFunctionsSideways(int,lng,simple,)@
@:JoinSelectFunctionsSideways(int,flt,simple,)@
@:JoinSelectFunctionsSideways(int,dbl,simple,)@
@:JoinSelectFunctionsSideways(int,date,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,chr,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,sht,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,int,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,lng,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,flt,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,dbl,atom,TYPE_)@
@:JoinSelectFunctionsSideways(date,date,atom,TYPE_)@

@= Project
crackers_export str CRKProjectCrack_@1(int *res, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKProjectCrack_@1_@2(int *res, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *c, *view;
	int m;
	lng cl1,cl2,ch1,ch2;

	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");

        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");
                
        GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));
                
        GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	if (cl1 != 0) cl1++;

        view = BATslice(BATmirror(VIEWhead_(BATmirror(b), BAT_READ)), cl1, ch2+1);

        *res = view->batCacheid;
        BBPkeepref(*res);

        BBPunfix(b->batCacheid);
        BBPunfix(c->batCacheid);
        return MAL_SUCCEED;
}

crackers_export str CRKProjectH_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKProjectH_@1_@2(int *res, int *bid, int *pbid,int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *p, *r, *c, *pair;
        BUN pairh, pivott, rest, reslast;
        lng size, fsize;
        int bsize, psize, rsize;
        lng skip;
	int m;
	lng cl1,cl2,ch1,ch2;
	lng j;

	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

        if ((pair = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");

	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

        GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

	if (cl1 != 0) cl1++;

        b = BATslice(pair, cl1, ch2+1);
	
        if ((p = BATdescriptor(*pivot)) == NULL) {
                throw(MAL, "crackers.crackJoinSelectSideways", "Cannot access descriptor");
        }

        size = BATcount(p);
 	r = BATnew(TYPE_void,b->htype,size);

        pairh  = BUNhloc(b, BUNfirst(b));
        pivott = BUNtloc(p, BUNfirst(p));
        rest   = BUNtloc(r, BUNfirst(r));
        bsize = BUNsize(b);
        psize = BUNsize(p);
        rsize = BUNsize(r);
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*(bit*)pivott == TRUE){
                        pairh += skip*bsize;
			*(@1*)rest = *(@1*)pairh; 
			rest += rsize;
                        skip = 0;
			fsize++;
                }
                pivott += psize;
                skip++;
        }

        reslast = BUNfirst(r) + rsize*fsize;
        r->batBuns->free =  reslast - r->batBuns->base;
        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);
        BBPunfix(pair->batCacheid);
        *res = r->batCacheid;

        return MAL_SUCCEED;
}

crackers_export str CRKProject_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKProject_@1_@2(int *res, int *bid, int *pbid,int *pivot, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
        BAT *b, *p, *r, *c, *pair;
        BUN pairt, pivott, rest, reslast;
        lng size, fsize;
        int bsize, psize, rsize;
        lng skip;
	int m;
	lng cl1,cl2,ch1,ch2;
	lng j;

	/* If the necessary map does not exits, then create it */	
	m = existsCrackerIndexSideways(*bid, *pbid);
	if (m==-1){	
		@:CreateCrackerMap(@1,@2)@		
		BBPincref(b->batCacheid,TRUE);
	}	

	/* Align the map based on the cracker tape of this set */
	Sync_@1_@2(m,existsCrackerIndexSideways(*bid, -1));

	/* Get the map */
        if ((pair = BATdescriptor(CrackerIndex[m].cbid)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.CRKProject", "Cannot access crack index");

	/* Get the result area on the map
           Note. We know that this search leads to an exact match sice a project call always 
           follows a select call with the same restriction in the same query. 
           Then this restriction is on the cracker tape. */
        GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl1, &ch1, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

        GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), BUNsize(c), &cl2, &ch2, 0, BUNindex(pair, BUNlast(pair)-BUNsize(pair)));

	if (cl1 != 0) cl1++;

        b = BATslice(pair, cl1, ch2+1);
	
        if ((p = BATdescriptor(*pivot)) == NULL) 
                throw(MAL, "crackers.CRKProject", "Cannot access descriptor");

        size = BATcount(p);
 	r = BATnew(TYPE_void,b->ttype,size);

        pairt  = BUNtloc(b, BUNfirst(b));
        pivott = BUNtloc(p, BUNfirst(p));
        rest   = BUNtloc(r, BUNfirst(r));
        bsize = BUNsize(b);
        psize = BUNsize(p);
        rsize = BUNsize(r);
        skip = 0;
	fsize = 0;
        for (j = 0; j<size; j++){
                if (*(bit*)pivott == TRUE){
                        pairt += skip*bsize;
			*(@2*)rest = *(@2*)pairt; 
			rest += rsize;
                        skip = 0;
			fsize++;
                }
                pivott += psize;
                skip++;
        }

        reslast = BUNfirst(r) + rsize*fsize;
        r->batBuns->free =  reslast - r->batBuns->base;
        BATsetcount(r, fsize);

	r->hsorted = FALSE;
        r->tsorted = FALSE;
        r->hdense = FALSE;
        r->tdense = FALSE;

        *res = r->batCacheid;
        BBPkeepref(r->batCacheid);
        BBPunfix(p->batCacheid);
        BBPunfix(b->batCacheid);
        BBPunfix(pair->batCacheid);

        return MAL_SUCCEED;
}
@

@c
@:Project(int,chr)@
@:Project(int,sht)@
@:Project(int,int)@
@:Project(int,lng)@
@:Project(int,flt)@
@:Project(int,dbl)@
@:Project(int,date)@
@:Project(date,chr,atom,TYPE_)@
@:Project(date,sht,atom,TYPE_)@
@:Project(date,int,atom,TYPE_)@
@:Project(date,lng,atom,TYPE_)@
@:Project(date,flt,atom,TYPE_)@
@:Project(date,dbl,atom,TYPE_)@
@:Project(date,date,atom,TYPE_)@

/* END -------------------------------------Sideways cracking-----------------------------------------------------------------*/


/* BEGIN -----------------------------------AVL Tree--------------------------------------------------------------------------*/

/* Implement an AVL index on top of a BAT for comparison against cracking */

@= AVLfcn
command buildAVLIndex(b:bat[:any_1,:@1]):void
address CRKmakeAVLIndex_@1
comment "Create an AVL tree index for this BAT";

command InsertAVLIndex(b:bat[:any_1,:@1], u:bat[:any_1,:@1]):void
address CRKInsertAVLIndex_@1
comment "Insert u in the AVL tree index of BAT b";

command selectAVL(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_6,:@1]
address CRKAVLIndexSelectBounds_@1
comment "Retrieve the subset using the AVL index";

command deleteAVL(b:bat[:any_1,:@1],u:bat[:any_2,:@1]):void
address CRKdeleteFromAVL_@1
comment "Delete a collection of values from the index";
@

@mal
@:AVLfcn(chr)@
@:AVLfcn(sht)@
@:AVLfcn(int)@
@:AVLfcn(lng)@
@:AVLfcn(flt)@
@:AVLfcn(dbl)@
@:AVLfcn(date)@

@c
static int maxAVLIndices = 0;

typedef struct {
	int		bid;
	struct Node 	*Tree;	
} AVLIndexNode;

static AVLIndexNode *AVLIndex;

int
existsAVLIndex(int bid){
        int i;

        for (i = 0; i < maxAVLIndices; i++)
                if (AVLIndex[i].bid == bid)
                        return i;
        return -1;
}

@= NewAVLIndex
int
newAVLIndex_@1(int bid){
        int i, freemap = -1, units = 1024;

        for (i = 0; i < maxAVLIndices; i++)
                if (AVLIndex[i].bid == -1)
                        freemap = i;

        if (freemap != -1) {
                AVLIndex[freemap].bid = bid;
                return freemap;
        }

        if (i == maxAVLIndices) {
                AVLIndexNode *x;

                if (maxAVLIndices > 0)
                        units = (int) (1.2 * maxAVLIndices);
                x = (AVLIndexNode *) GDKmalloc(sizeof(AVLIndexNode) * units);
                memset(x, 0, sizeof(AVLIndexNode) * units);
                if (AVLIndex) {
                        fprintf(stderr, "reallocate index \n");
                        memcpy(x, AVLIndex, sizeof(AVLIndexNode) * i);
                        GDKfree(AVLIndex);
                }
                AVLIndex = x;
                maxAVLIndices = units;
        }

        AVLIndex[i].bid = bid;
        AVLIndex[i].Tree = NULL;
        return i;
}
@

@c
@:NewAVLIndex(chr)@
@:NewAVLIndex(sht)@
@:NewAVLIndex(int)@
@:NewAVLIndex(lng)@
@:NewAVLIndex(flt)@
@:NewAVLIndex(dbl)@
@:NewAVLIndex(date)@

@= AVLIndexOperations
struct Node *
InsertAVLIndex_@1(int m, int indexPosition, @1 value,  struct Node * current, BAT * b, BUN base, int xx){	
	BUN cur, curValue, Lchild, LchildValue, Rchild, RchildValue;
	int lh, rh;
	struct Node *temp;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
                current->position = indexPosition;
                current->inclusive = TRUE;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		current->hols = 0;
		goto end;
        }

	cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

        if ( @2_LT(&value,curValue,@3@1) || @2_EQ(&value,curValue,@3@1) ){
		if ( (temp = InsertAVLIndex_@1(m, indexPosition, value,  current->left, b, base, xx)) == NULL )
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + ((current->left->position) * xx);
        		LchildValue = BUNtloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || @2_EQ(&value,LchildValue,@3@1) )
                        	current = SingleRotateLeft(m, current);
                    	else
                        	current = DoubleRotateLeft(m, current);
		}
        } else {
		if ( (temp = InsertAVLIndex_@1(m, indexPosition, value, current->right, b, base, xx)) == NULL )
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;


                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + ((current->right->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) )
                        	current = SingleRotateRight(m, current);
                    	else
                        	current = DoubleRotateRight(m, current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

void
addAVLIndex_@1(int m,  lng position, BAT * b){
        BUN base;
        int xx = BUNsize(b);

        if (position == 0){
                AVLIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                AVLIndex[m].Tree->position = position;
                AVLIndex[m].Tree->inclusive = TRUE;
                AVLIndex[m].Tree->height = 0;
                AVLIndex[m].Tree->left = NULL;
                AVLIndex[m].Tree->right = NULL;
                AVLIndex[m].Tree->head = TRUE;
                AVLIndex[m].Tree->deleted = FALSE;
                AVLIndex[m].Tree->previous = NULL;

                return;
        }

        base = BUNhloc(b, BUNfirst(b));
        InsertAVLIndex_@1(m, position, *(@1*)BUNtloc(b,base+position*xx),  AVLIndex[m].Tree, b, base, xx);
}

crackers_export str CRKmakeAVLIndex_@1(int *k, int *bid);
str
CRKmakeAVLIndex_@1(int *k, int *bid){
	BUN last, cur;
	int indexPos;
	int xx;
	lng curPos;
	BAT *b;

	(void) k;
        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.make AVL index", "Cannot access descriptor");

	indexPos = newAVLIndex_@1(*bid);
	cur = BUNfirst(b);
	last = BUNlast(b);
	xx = BUNsize(b);
	curPos = 0;
	while (cur < last){
		addAVLIndex_@1(indexPos,curPos,b);
		cur+=xx;
		curPos++;
	}
	
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

crackers_export str CRKInsertAVLIndex_@1(int *k, int *bid, int *uid);
str
CRKInsertAVLIndex_@1(int *k, int *bid, int *uid){
	BUN last, cur;
	int indexPos;
	int xx;
	lng curPos;
	BAT *b, *u;

	(void) k;
	indexPos = existsAVLIndex(*bid);
	if (indexPos == -1)	
		throw(MAL, "crackers.insert AVL index", "No AVL index present for this BAT");

        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access descriptor");

        if ((u = BATdescriptor(*uid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access update descriptor");

	cur = BUNfirst(u);
	last = BUNlast(u);
	xx = BUNsize(b);
	curPos = BATcount(b)-BATcount(u);
	while (cur < last){
		addAVLIndex_@1(indexPos,curPos,b);
		cur+=xx;
		curPos++;
	}
	
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);
	return MAL_SUCCEED;
}

lng 
findQualifyingValuesAVLIndex_@1(@1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, lng resSize, BAT *b, BUN first, int xx, struct Node * cur, BUN resh, BUN rest, @1 prevL){
	BUN rh = resh, rt = rest;
	lng size = resSize;
	
	@1 value = *(@1*)BUNtloc(b,first+cur->position*xx);
	if (cur->deleted == FALSE){
		if ( (@2_GT(&value,low,@3@1) && @2_LT(&value,hgh,@3@1)) ||
		     (@2_EQ(&value,low,@3@1) && *inclusiveLow == TRUE) ||	
		     (@2_EQ(&value,hgh,@3@1) && *inclusiveHgh == TRUE) ){
			*(oid*)rh = (oid)cur->position;
       	         	*(@1 *)rt = *(@1*)BUNtloc(b,first+cur->position*xx);
	       	         rh+=xx; rt+=xx;
        	        size++;	
		}
	}

	if (cur->left != NULL &&  @2_GT(&value,low,@3@1) && @2_LT(&prevL,hgh,@3@1) )
		size = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, size, b, first, xx, cur->left, rh, rt, prevL);
	if (cur->right != NULL && (@2_LT(&value,hgh,@3@1) || (@2_EQ(&value,hgh,@3@1) && *inclusiveHgh == TRUE)))
		size = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, size, b, first, xx, cur->right, rh, rt, value);

	return size;
}

crackers_export str CRKAVLIndexSelectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKAVLIndexSelectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	BAT *b, *result;
	int indexPos;
	struct Node *cur;
	int xx;
	lng  resSize;
	BUN first, resLast, resh, rest;

	indexPos = existsAVLIndex(*bid);
        if (indexPos == -1)
                throw(MAL, "crackers.insert AVL index", "No AVL index present for this BAT");
	
        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access descriptor");

	result = BATnew(TYPE_oid, TYPE_@1, (*(@1*)hgh-*(@1*)low)*2);

	/* find the node that we should start searching from */
	cur = AVLIndex[indexPos].Tree;
	first = BUNfirst(b);
	xx = BUNsize(b);

	while( @2_LT(BUNtloc(b,first+cur->position*xx),low,@3@1) && cur != NULL )		
		cur = cur->right;

	resSize = 0;
	/*if NULL then result is empty */
	if (cur == NULL){
		resLast = BUNfirst(result);
		result->batBuns->free =  resLast - result->batBuns->base;
                BATsetcount(result, 0);
		BBPkeepref(result->batCacheid);
		*vid = result->batCacheid;
		BBPunfix(b->batCacheid);

		return MAL_SUCCEED;
	}

	resh = BUNhloc(result, BUNfirst(result));
	rest = BUNtloc(result, BUNfirst(result));
	if (@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && *inclusiveLow == TRUE){
		while (@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && cur != NULL){
			if (cur->deleted == FALSE){
				*(oid*)resh = (oid)cur->position;
				*(@1 *)rest = *(@1 *)BUNtloc(b,first+cur->position*xx);
				resh+=xx; rest+=xx;
				resSize++;
			}
			cur = cur->right;
		}
	} else
	if (@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && *inclusiveLow == FALSE){
		while(@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && cur != NULL)
			cur = cur->right;
	} 

	if (cur != NULL)       
		resSize = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, resSize, b, first, xx, cur, resh, rest, *(@1*)BUNtloc(b,first+cur->position));


	resLast = BUNfirst(result) + xx*resSize;
        result->batBuns->free =  resLast - result->batBuns->base;
        BATsetcount(result, resSize);
        BBPkeepref(result->batCacheid);
        *vid = result->batCacheid;
        BBPunfix(b->batCacheid);


	return MAL_SUCCEED;
}

/* Locate and mark as deleted a node in the AVL tree, starting from a given node */
struct Node *
LocateDelete_@1(struct Node *cur, oid id, @1 *value, BAT *b, BUN first, int xx){
	struct Node * current = cur;
	if ( @2_GT(BUNtloc(b, first + current->position*xx),value,@3@1) )
		return current->right != NULL ? LocateDelete_@1(current->right, id, value, b, first, xx): NULL;	
	else
	if ( @2_LT(BUNtloc(b, first + current->position*xx),value,@3@1) )
		return current->left != NULL ? LocateDelete_@1(current->left, id, value, b, first, xx): NULL;	
	else
	if ( @2_EQ(BUNtloc(b, first + current->position*xx),value,@3@1) ){
		if ( (oid)current->position ==  id ){
			current->deleted = TRUE;
			return current;
		}
		else {
			while(1){
				if (current->right != NULL)
					current= current->right;
				if ( @2_EQ(BUNtloc(b, first + current->position*xx),value,@3@1) ){
			                if ( (oid)current->position ==  id ){
						current->deleted = TRUE;
               		 		        return current;
					} else
						continue;
				} else {
					return current;
				}
			}
		}
	}

	return NULL;
}

crackers_export str CRKdeleteFromAVL_@1(int *k, int *bid, int *uid);
/* delete from the AVL tree a collection of values */
str
CRKdeleteFromAVL_@1(int *k, int *bid, int *uid){
	BAT *b, *u;
	lng indexPos;
	BUN delt, delh, delLast, first;
	int xx;
	
	(void)k;
	
	indexPos = existsAVLIndex(*bid);
        if (indexPos == -1)
                throw(MAL, "crackers.delete from AVL index", "No AVL index present for this BAT");

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.delete from AVL index", "Cannot access descriptor");


	if ((u = BATdescriptor(*uid)) == NULL)
                throw(MAL, "crackers.delete from AVL index", "Cannot access deletions BAT");

        if (BATcount(u) == 0){
                BBPunfix(u->batCacheid);
                return MAL_SUCCEED; /* no qualifying values in the insertions */
        }

        /* if necessary, sort in place the insertions bat */
        if (u->tsorted == FALSE){
                u->batRestricted = BAT_WRITE;
                BATmirror(BATorder(BATmirror(u)));
        }

	first = BUNfirst(b);
	xx = BUNsize(b);
	delt = BUNtloc(u, BUNfirst(u));
	delh = BUNhloc(u, BUNfirst(u));
	delLast = BUNtloc(u, BUNlast(u));
	while (delt < delLast){
		LocateDelete_@1(AVLIndex[indexPos].Tree, *(oid*)delh, (@1*)delt, b, first, xx);
		delt+=xx; delh+=xx;
	}
	
	BATmode(u, TRANSIENT);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);
	
	return MAL_SUCCEED;
}
@

@c
@:AVLIndexOperations(chr,simple,)@
@:AVLIndexOperations(sht,simple,)@
@:AVLIndexOperations(int,simple,)@
@:AVLIndexOperations(lng,simple,)@
@:AVLIndexOperations(flt,simple,)@
@:AVLIndexOperations(dbl,simple,)@
@:AVLIndexOperations(date,atom,TYPE_)@

/* END ----------------------------- Comparison with AVL-tree index---------------------------------------------------------------- */
