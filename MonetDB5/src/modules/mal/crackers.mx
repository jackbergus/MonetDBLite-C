@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f crackers
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006
@* Cracker index

A cracker index is a volatile datastructure which acts as
a non-dense index into a BAT. The index is incrementally built
based on the fragments needed by queries.
Each select operation results in a partial re-clustering of the tuples
such that the result set is a consecutive memory area in the BAT.
This set can be returned as a BAT view for further processing.

A cracker index is created with the command @code{crackers.new}
and destroyed using @code{crackers.destroy}.
Multiple calls to create/destroy the cracker index on the same
argument are ignored.

The cracker index can be created for the time being on
tail columns of type {int,lng,dbl,flt,time}. The head
is always of type @code{oid}.

Once a cracker index exist, portions can be extracted 
using @code{crackers.select} and @code{crackers.uselect},
which semantically behave as their algebraic counterparts.
Both operations may have to glue pieces from the cracked
bat to satisfy the BAT semantics.

Qst: are these operators overloaded to initiate a crack
operation first?

In addition, the cracker index can be used to feed a generator
for pieces satisfying a range constraint.
A cracker partition is indicated by the index in the cidx
table. It can be used to initialize a BATview to represent
the partition during processing.

Repeated cracking leads to an ever growing index. This process
can be stopped by setting the granule size,
i.e.  the minimum number of tuples in each piece,
or the maximum number of pieces. 
The operations @code{crackers.setGranule()} and @code{crackers.setLimit()}
implement them. The default is to allow an arbitrary number pieces
with arbitrary sizes.

Pitfalls.
The policy in the kernel to take a copy of a BAT when there
is a need to write to it and there are also views around becomes 
an issue. Instead, it should isolate the views, giving them a
private copy. This way the underlying base table becomes free to re-arrange.
This issue is postponed to the future.

The cracker module should be prepared to deal with any of the base types.
For strings this becomes an issue.

This module contains the experimental code to play with cracked tables.
It supports int-based bats for the time being only.

The current implementation uses an unprotected cracker
index. This limits the interface at slightly more overhead
of searching the cracker index upon each call.

Initial performance indicates around 70 ms processing
overhead on a 1M bat during the first crack operation.
(Athlon 1400, 1Gb)

@= crackfcn
command new(b:bat[:oid,:@1]):void
address CRKnew
comment "Create the index for a cracked table.";

command destroy(b:bat[:oid,:@1]):void
address CRKdestroy
comment "Destroy the index for a cracked table.";

command setGranule(b:bat[:oid,:@1], granule:int):void
address CRKsetGranule
comment "Set the minimum granularity for a BAT.";

command setLimit(b:bat[:oid,:@1], cnt:int):void
address CRKsetLimit
comment "Set the maximum number of pieces in the cracker index.";

command info(b:bat[:oid,:@1])
address CRKinfo
comment "Print the cracker index administration";

command crack(b:bat[:oid,:@1],mid:@1) :bat[:oid,:@1]
address CRKcrackValue
comment "Break the partitions into smaller pieces
	using an inclusive range over the tail.";

command crack(b:bat[:oid,:@1],low:@1,hgh:@1) :bat[:oid,:@1]
address CRKcrackRange
comment "Break the partitions into smaller pieces
	using an inclusive range over the tail.";

command crack(b:bat[:oid,:@1],low:@1,hgh:@1,lincl:bit,rincl:bit) :bat[:oid,:@1]
address CRKcrackRangeAll
comment "Break the partitions into smaller pieces
	using a range over the tail";

command crack(b:bat[:oid,:@1],c:bat[:@1,:oid]) :int
address CRKcrackJoin
comment "Break the partitions into smaller pieces
	using a join over the tail";

command newIterator(b:bat[:oid,:@1])
	(a:lng,x:bat[:oid,:@1])
address CRKnewIterator
comment "Retrieve the first piece of a cracked
	BAT as a BAT view and also return the
	identity of the next piece.";

command hasMoreElements(b:bat[:oid,:@1])
	(a:lng,x:bat[:oid,:@1])
address CRKhasMoreElements
comment "Retrieve the next piece of a cracked
	BAT by adjusting the BAT view descriptor.
	It returns the next valid piece id.
	A value zero means 'end-of-sequence'";

command getPiece(b:bat[:oid,:@1], piece:int) :bat[:oid,:@1]
address CRKgetPiece0
comment "Retrieve a piece of a cracked BAT into a new BAT view.";

command getPiece(b:bat[:oid,:@1], crk:bat[:oid,:@1], piece:int)
address CRKgetPiece1
comment "Retrieve a piece of a cracked BAT into a known BAT view.";

command selectPieces( b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKselectPieces
comment "Retrieve identities of all pieces that qualify the selection criterion.";
@mal
module crackers;

@:crackfcn(int)@
@-
A limited set of relational operators is overloaded to deal with
cracked BATs. The relational select collects the pieces
into a single BAT. Preferably using a BATview, otherwise
the pieces are combined to form a new BAT.

@= crackAlgebra
command select(b:bat[:oid,:@1],l:@1,h:@1):bat[:oid,:@1]
address CRKselect
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@1],l:@1):bat[:oid,:@1]
address CRKselectValue
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@1],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKselectBounds_
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:oid,:@1],l:@1,h:@1):bat[:oid,:void]
address CRKuselect
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:oid,:@1],l:@1):bat[:oid,:void]
address CRKuselectValue
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:oid,:@1],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:void]
address CRKuselectBounds
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

@-
@mal
@:crackAlgebra(int)@

@-
Temporary interface for the "new cracking competition".
For the time being, we ignore the cracking administration and repeated
cracking, and focus on cracking a complete BAT, returning the cracked BAT.
@
@= crack
command zcrack@4_@1 (b:bat[:oid,:@3], mid:@3) :bat[:oid,:@3]
address CRKcrack@4Zero_@1_@3
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively@5. (By @2.)";

command crack@4_@1 (b:bat[:oid,:@3], mid:@3) :bat[:oid,:@3]
address CRKcrack@4One_@1_@3
comment "Break a BAT into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively@5. (By @2.)";

command crack@4_@1 (b:bat[:oid,:@3], low:@3, hgh:@3) :bat[:oid,:@3]
address CRKcrack@4Two_@1_@3
comment "Break a BAT into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively@5. (By @2.)";

command zcrack@4_@1 (b:bat[:oid,:@3], low:@3, hgh:@3) :bat[:oid,:@3]
address CRKcrack@4Three_@1_@3
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively@5. (By @2.)";

@
@= crack_validate
command zcrack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2Zero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2One_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Two_validate_@1
comment "Validate whether a BAT is correctly broken into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively@3.";

command zcrack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Three_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively@3.";
@
@mal
@:crack(SI,Stratos Idreos,int,,)@
@:crack(SI,Stratos Idreos,int,Ordered,; maintaining the head-oid order within each piece)@
@:crack(is,Stratos Idreos,int,Ordered,; maintaining the head-oid order within each piece)@
@:crack(MK,Martin Kersten,int,,)@
@:crack(MK,Martin Kersten,int,Ordered,; maintaining the head-oid order within each piece)@
@:crack(SM,Stefan Manegold,int,,)@
@:crack(sm,Stefan Manegold,int,,)@
@:crack(SM,Stefan Manegold,int,Ordered,; maintaining the head-oid order within each piece)@
@:crack(sm,Stefan Manegold,int,Ordered,; maintaining the head-oid order within each piece)@
@:crack_validate(int)@
@:crack_validate(int,Ordered,; maintaining the head-oid order within each piece)@
@-
@{
@include prelude.mx
@* Implementation
The implementation is geared at early experimentation
without all the details to make the code robust and
ultra fast.

@-
The relationships between a table and its cracker index
is locally maintained. 
@h
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/

#define LEAF 'L'
#define PHI  'P'		/* broken using a select */
#define DIAMOND  'D'		/* broken using a join */
#define OMEGA  'O'		/* broken using a group */

@-
A cracker piece describes a region in a BAT such that all
tail values t satisfy the constraint [min<=t, t<=max]
and the physical location is identified by the inclusief
index range.
@h
typedef struct {
	char kind;		/* kind of piece */
	int rng_max;		/* the value ranges */
	int rng_min;
	bit inclusiveMin;       
	bit inclusiveMax;
	int real_rng_max;       /* the value ranges that actually exist in a piece */
	int real_rng_min;
	size_t idx_first;		/* the slice boundaries */
	size_t idx_last;
	int parent;		/* lineage */
	int left, middle, right;	/* tree branch directions */
} Piece;

typedef struct {
	int bid;		/* the original bat */
	int freepiece, maxpiece;
	int granule;	/* low watermark for piece sizes */
	int limit;		/* maximum number of pieces allowed */
	Piece *pieces;
} CrackMap;

mal_export str CRKnew(int *cret, int *bid);
mal_export str CRKdestroy(int *cret, int *bid);
mal_export str CRKsetGranule(int *cret, int *bid, int *gran);
mal_export str CRKsetLimit(int *cret, int *bid, int *cnt);
mal_export str CRKinfo(int *k, int *bid);
mal_export str CRKcrackValue(int *partid, int *bid, int *mid );
mal_export str CRKcrackRange(int *partid, int *bid, int *low, int *hgh);
mal_export str CRKcrackRangeAll(int *partid, int *bid, int *low, int *hgh, bit *lincl, bit *rincl);
mal_export str CRKcrackRangeWithTwoScans(int *vid, int *bid, int low, int hgh, bit tail);
mal_export str CRKcrackJoin(int *partid, int *bid, int *cid);
mal_export int CRKsetBounds(BAT *b, BAT *view, int mid, int pid);
mal_export str CRKnewIterator(lng *newpid, int *vid, int *bid);
mal_export str CRKhasMoreElements(lng *pid, int *vbid, int *bid);
mal_export str CRKgetPiece0(int *vbid, int *bid, int *piece);
mal_export str CRKgetPiece1(int *newpid, int *bid, int *vbid, int *piece);
mal_export str CRKselectNew(int *vid, int *bid, int *low, int *high, bit *li, bit *hi);
mal_export str CRKselectPieces(int *result, int *bid, int *low, int *hgh);
mal_export str CRKselect(int *vid, int *bid, int *low, int *hgh);
mal_export str CRKselectBounds(int *vid, int *bid, int *low, int *hgh, bit *inclusiveLow, bit *inclusiveHgh);
mal_export str CRKselectBounds_(int *vid, int *bid, int *low, int *hgh, bit *inclusiveLow, bit *inclusiveHgh);
mal_export str CRKselectValue(int *vid, int *bid, int *value);
mal_export str CRKuselect(int *vid, int *bid, int *low, int *hgh);
mal_export str CRKuselectBounds(int *vid, int *bid, int *low, int *hgh, bit *inclusiveLow, bit *inclusiveHgh);
mal_export str CRKuselectValue(int *vid, int *bid, int *value);

#endif /* _CRACKERS_H */
@-
During initialization of the crackers structure we already
shuffle the data around to have a first assessment of
the value ranges supported.

Note, this implementation does not protect the crackMap
administration. This is necessary in a concurrent version.
The granularity can be used to limit the number of pieces.
@c
#include "mal.h"
#include "mal_exception.h"
#include "crackers.h"

#define MAXPIECE 1024*100

static CrackMap *crackMap;
static int maxCrackMap = 0;


int     
existsCrackMap(int bid)
{       
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (crackMap[i].bid == bid)
			return i;
	return -1;
}

int     
newCrackMap(int bid)
{       
	int i, freemap = -1, units = 1024;
	
	for (i = 0; i < maxCrackMap; i++)
		if (crackMap[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		crackMap[freemap].bid = bid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackMap *x;
        
		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackMap *) GDKmalloc(sizeof(CrackMap) * units);
		memset(x, 0, sizeof(CrackMap) * units);
		if (crackMap) { 
			fprintf(stderr, "reallocate Crackmap\n");
			memcpy(x, crackMap, sizeof(CrackMap) * i);
			GDKfree(crackMap);
		}
		crackMap = x;
		maxCrackMap = units;
	}
	/* init the crackmap */
	crackMap[i].bid = bid;
	crackMap[i].pieces = GDKmalloc(sizeof(Piece) * MAXPIECE);
	memset((void *) crackMap[i].pieces, 0, sizeof(Piece) * MAXPIECE);
	crackMap[i].freepiece = 0;
	crackMap[i].maxpiece = MAXPIECE;
	return i;
}

int
findCrackMap(int bid)
{
	int m;
	m= existsCrackMap(bid);
	if( m < 0 )
		m= newCrackMap(bid);
	return m;
}

void
freeCrackMap(int m)
{
	assert(m >= 0);
	/* re-initialize crackmap */
	crackMap[m].bid = -1;
	memset((void *) crackMap[m].pieces, 0, sizeof(Piece) * crackMap[m].maxpiece);
	crackMap[m].freepiece = 0;
}

void
printCrackMapElement(Piece * list, int i, int bid)
{
	stream_printf(GDKout, "[ %3d %3d, ", i, bid);
	stream_printf(GDKout, "%c, ", list[i].kind);
	stream_printf(GDKout, "%d ", list[i].parent);
	stream_printf(GDKout, "%d, ", list[i].rng_min);
	stream_printf(GDKout, "%d, ", list[i].rng_max);
	stream_printf(GDKout, "%d, ", list[i].real_rng_min);
	stream_printf(GDKout, "%d, ", list[i].real_rng_max);
	stream_printf(GDKout, " "SZFMT", ", list[i].idx_first);
	stream_printf(GDKout, " "SZFMT", ", list[i].idx_last);
	stream_printf(GDKout, "%d, ", list[i].left);
	stream_printf(GDKout, "%d, ", list[i].middle);
	stream_printf(GDKout, "%d ]\n ", list[i].right);
}

void
printCrackMap(int bid)
{
	int i, m;

	m = findCrackMap(bid);
	if (crackMap[m].freepiece)
		stream_printf(GDKout, "# idx bid kind parent rng_min rng_max real_min real_max idx_first idx_last left middle right# name\n");
	for (i = 0; i < crackMap[m].freepiece; i++)
		printCrackMapElement(crackMap[m].pieces, i, bid);
}

str
initCrackMap(CrackMap * map, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL)
		return throwMessage("crackers.initCrackMap", 
						"Cannot access descriptor");
@-
The target BAT should not be modified by the applications,
otherwise the partitioning scheme becomes void
already. [todo]
@c
	map->pieces[0].rng_min = INT_MIN;
	map->pieces[0].rng_max = INT_MAX;
	map->pieces[0].inclusiveMin = TRUE;
	map->pieces[0].inclusiveMax = TRUE;
	map->pieces[0].real_rng_min = INT_MIN;
	map->pieces[0].real_rng_max = INT_MAX;
	map->pieces[0].idx_first = BUNindex(b, BUNfirst(b));
	map->pieces[0].idx_last = BUNindex(b, BUNlast(b)) - 1;
	map->pieces[0].kind = LEAF;
	map->pieces[0].parent = -1;
	map->pieces[0].left = -1;
	map->pieces[0].middle = -1;
	map->pieces[0].right = -1;
	map->freepiece = 1;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CRKnew(int *cret, int *bid)
{
	int m;

	(void) cret;
	m = findCrackMap(*bid);
	initCrackMap(crackMap + m, bid);
#ifdef DEBUG_CRACKERS
	stream_printf(GDKout, "crackMap created\n");
#endif
	return MAL_SUCCEED;
}

str
CRKdestroy(int *cret, int *bid)
{
	int m;

	(void) cret;
	m = findCrackMap(*bid);
	if( m < 0)
		return throwMessage("crackers.destroy", "Unknown cracked BAT");
	freeCrackMap(m);
	return MAL_SUCCEED;
}

str
CRKsetGranule(int *cret, int *bid, int *gran)
{
	int m;
	(void) cret;

	if( *gran<=0 )
		return throwMessage("crackers.setGranule", "Illegal granule size");

	m= findCrackMap(*bid);
	if( m >=0 )
		crackMap[m].granule= *gran;
	else return throwMessage("crackers.setGranule", "unknown cracked BAT");
	return MAL_SUCCEED;
}

str
CRKsetLimit(int *cret, int *bid, int *cnt)
{
	int m;
	(void) cret;

	if( *cnt<=0 )
		return throwMessage("crackers.setLimit", "Illegal count");

	m= findCrackMap(*bid);
	if( m >=0 )
		crackMap[m].limit= *cnt;
	else return throwMessage("crackers.setLimit", "unknown cracked BAT");
	return MAL_SUCCEED;
}

str
CRKinfo(int *k, int *bid)
{
	(void) k;
	printCrackMap(*bid);
	return MAL_SUCCEED;
}
@-
@= exchange
#ifdef DEBUG_CRACKERS_DETAIL
	printf("exchange %d %d\n",BUNindex(b,@1),BUNindex(b,@2));
#endif
{ /* be aware of reversed bats, which disallow memcpy
	memcpy(buf, @1, BUNsize(b));
	memcpy(@1, @2, BUNsize(b));
	memcpy(@2, buf, BUNsize(b));
*/
	oid hdummy;
	int tdummy;
	(void) buf;
	hdummy= *(oid*) BUNhead(b,@1);
	tdummy= *(int*) BUNtail(b,@1);
	*(oid*) BUNhead(b,@1) = *(oid*) BUNhead(b,@2);
	*(int*) BUNtail(b,@1) = *(int*) BUNtail(b,@2);
	*(oid*) BUNhead(b,@2)= hdummy;
	*(int*) BUNtail(b,@2)= tdummy;
}
@= exchange2
#ifdef DEBUG_CRACKERS_DETAIL
	printf("exchange %d %d %d\n",BUNindex(b,@1),
		BUNindex(b,@2),BUNindex(b,@3));
#endif
/*	memcpy(buf, @1, BUNsize(b));
	memcpy(@1, @3, BUNsize(b));
	memcpy(@3, @2, BUNsize(b));
	memcpy(@2, buf, BUNsize(b));
*/  
        oid hdummy;
	int tdummy;
        (void) buf;
        hdummy= *(oid*) BUNhead(b,@1);
        tdummy= *(int*) BUNtail(b,@1);
        *(oid*) BUNhead(b,@1) = *(oid*) BUNhead(b,@3);
        *(int*) BUNtail(b,@1) = *(int*) BUNtail(b,@3);
        *(oid*) BUNhead(b,@3) = *(oid*) BUNhead(b,@2);
        *(int*) BUNtail(b,@3) = *(int*) BUNtail(b,@2);
        *(oid*) BUNhead(b,@2)= hdummy;
        *(int*) BUNtail(b,@2)= tdummy;

@- Cracking
The key operation for the cracker infrastructure is to process a scan
efficiently and re-shuffle the tuples in the BAT such that a simple
BATview can be used to denote the subrange of interest to upper layers.
Assume the range (low,hgh), both inclusive, is needed then all tuples
not qualifying this range should be moved out of the way by effectively
splitting the BAT into three segments.

Two strategies can be considered; a naive exchange shuffle and
pre-scan shuffle.
The naive exchange shuffle works as follows. We simple walk through the table
left to right and move all elements >=low to the right. 
A slightly improved version is to find groups of tuples to move around
as larger chunks.

The pre-scan shuffle reads the table twice. In the first phase we
calculate (for each partition) the number of elements in the range
(low,hgh). In the second phase we move the data into the designated place.
The advantage over the naive shuffle is potential less data writes.

First experiment is a simple partitioning on the tail value.
@= newPiece
	if(crackMap[@1].maxpiece == crackMap[@1].freepiece ){
		GDKerror("#too many pieces");
		exit(0);
	}
	@2 = crackMap[@1].pieces+ crackMap[@1].freepiece;
	@2->left= @2->middle= @2->right = -1;
	crackMap[@1].freepiece++;
	/* clone it */
	if( @3){
		@2->rng_min = @3->rng_min;
		@2->rng_max = @3->rng_max;
		@2->idx_first = @3->idx_first;
		@2->idx_last = @3->idx_last;
		@2->kind = LEAF;
		@2->parent = @4;
	}
@c
str
CRKcrackRangeAll(int *partid, int *bid, int *low, int *hgh, bit *lincl, bit *rincl)
{
	BAT *b;
	Piece *piece, *npiece;
	int xx;
	ptr p;
	char buf[128];		/* scratch space */
	ptr vmax = 0, vmin = 0, vm;
	int lim, m, i, pid = -1;
	size_t l,h;
	int lval,hval;

	if (*(int *) low > *(int *) hgh)
		return throwMessage("crackers.crack", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crackRange", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);
@-
Inspect the value range table to only further crack qualifying fragments.
@c

	lim = crackMap[m].freepiece;
#ifdef DEBUG_CRACKERS
	printf("search range %d %d [lim=%d]\n", *(int *) low, *(int *) hgh, lim);
#endif
	for (i = 0; i < lim; i++) {
		if (crackMap[m].pieces[i].kind != LEAF)
			continue;
		if ( *(int *) low < crackMap[m].pieces[i].rng_min && 
			 *(int *) hgh > crackMap[m].pieces[i].rng_max) {
			/* the range encloses the complete piece */
			continue;
		}
		/* ignore pieces outside the scope of interest */
		if (crackMap[m].pieces[i].rng_max < *(int *) low)
			continue;
		if (crackMap[m].pieces[i].rng_max == *(int *) low && ! *lincl)
			continue;
		if (crackMap[m].pieces[i].rng_min > *(int *) hgh)
			continue;
		if (crackMap[m].pieces[i].rng_min == *(int *) hgh && ! *rincl)
			continue;

		piece = crackMap[m].pieces + i;
		/* set bounds for the iterator */
		xx = BUNsize(b);
		vmin = (ptr) ((char *) BUNptr(b, piece->idx_first) - xx);
		vmax = (ptr) ((char *) BUNptr(b, piece->idx_last) + xx);

		vm = BUNtail(b, (ptr) ((char *) vmin + xx));
		lval = *(int *) low;
		hval = *(int *) hgh;
@-
The loop should take into account the inclusive bound flags.
We need four copies of this one.
@= crackLoop
		if( @1 )
		for (p = (ptr) ((char *) vmin + xx); p < vmax; 
			 p = (ptr) ((char *) p + xx), vm = (ptr) ((char *) vm + xx)) {
			if (*(int *) vm @2 lval) {
				/* exchange with first low */
				vmin = (ptr) ((char *) vmin + xx);
				if (vmin != p) {
					@:exchange(vmin, p)@
				}
			} else if (*(int *) vm @3 hval) {
				/* exchange with qualifying tail elm */
				vmax = (ptr) ((char *) vmax - xx);
				while (*(int *) BUNtail(b, vmax) @3 hval && vmax > p)
					vmax = (ptr) ((char *) vmax - xx);
				if (vmax != p) {
					@:exchange(vmax, p)@
					vm = (ptr) ((char *) vm - xx);
					p = (ptr) ((char *) p - xx);

				}
			}
		}
@-
The element choosen could also be less then 'low' and an 
exchange operation could be saved. It turned out that
this optimization was not effective when a BUNtail
test was performed. A similar remark holds for having
an additional variable to keep track of the tail value.
@c
@:crackLoop(*lincl==FALSE && *rincl==FALSE,<,>)@
@:crackLoop(*lincl==FALSE && *rincl==TRUE,<,>=)@
@:crackLoop(*lincl==TRUE && *rincl==FALSE,<=,>)@
@:crackLoop(*lincl==TRUE && *rincl==TRUE,<=,>=)@
@-
For each fragment discovered we have to break it into several pieces
and update the administration BATs. 
@c
		l = BUNindex(b, vmin) + 1;
		h = BUNindex(b, vmax) - 1;

		if (piece->idx_first == l) {
			if (h < piece->idx_last) {
#ifdef DEBUG_CRACKERS
				printf("left split [%d] "SZFMT"-"SZFMT" \n", i, l, h);
#endif
				piece->kind = PHI;
				piece->left = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_max = *(int *) hgh;	/* WRONG depend on incl */
				npiece->idx_last = h;
				pid= piece->left;

				piece->middle = -1;

				piece->right = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_min = *(int *) hgh + 1;
				npiece->idx_first = h + 1;
			}
		} else if (piece->idx_last == h) {
			if (l > piece->idx_first) {
#ifdef DEBUG_CRACKERS
				printf("right split [%d] "SZFMT"-"SZFMT" \n", i, l, h);
#endif
				/* falls at high end */
				piece->kind = PHI;
				piece->left = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_max = *(int *) low - 1;
				npiece->idx_last = l - 1;

				piece->middle = -1;

				piece->right = pid = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_min = *(int *) low;
				npiece->idx_first = l;
			}
		} else {
#ifdef DEBUG_CRACKERS
			printf("middle split [%d] "SZFMT"-"SZFMT" \n", i, l, h);
#endif
			piece->kind = PHI;
			piece->left = crackMap[m].freepiece;
			@:newPiece(m, npiece,piece,i)@
			npiece->rng_max = *(int *) low - 1;
			npiece->idx_last = l - 1;

			piece->middle = pid = crackMap[m].freepiece;
			@:newPiece(m, npiece,piece,i)@
			npiece->rng_min = *(int *) low;
			npiece->rng_max = *(int *) hgh;
			npiece->idx_first = l;
			npiece->idx_last = h;

			piece->right = crackMap[m].freepiece;
			@:newPiece(m, npiece,piece,i)@
			npiece->rng_min = *(int *) hgh + 1;
			npiece->idx_first = h + 1;
		}
	}
@-
If this was the first cracking operation it makes sense to administer
the ranges of the outer partitions as well.
@c
#ifdef DEBUG_CRACKERS
	printf("pid returned %d\n", pid);
#endif
	BBPunfix(b->batCacheid);
	*partid = pid;
	return MAL_SUCCEED;
}
@-
The short cut versions.
@c
str
CRKcrackValue(int *partid, int *bid, int *mid){
	bit f= FALSE;
	return CRKcrackRangeAll(partid,bid,mid,mid,&f,&f);
}
str
CRKcrackRange(int *partid, int *bid, int *low, int *high){
	bit f= FALSE;
	return CRKcrackRangeAll(partid,bid,low,high,&f,&f);
}
@-
Stratos's algorithm is slightly different. It uses a double scan
to determine the bounds of the three pieces first. This can avoid
one exchange operation per misplaced element in the middle part.

The second optimization is to make the region administration
more precise, e.g. with/without gaps.

The effect of these optimizations are questionable, because
they lead to more complex code and cpu cycles.
Experiments should (dis) proof this.

@= updateRealBounds

#ifdef DEBUG_CRACKERS
	printf("\n changed @2 bounds from %d to %d  to  ", real_low@2, real_high@2);
#endif
	cur_val = @1;
        if (real_low@2 > cur_val) real_low@2 = cur_val;
	if (real_high@2 < cur_val) real_high@2 = cur_val;

#ifdef DEBUG_CRACKERS
	printf("%d to %d \n", real_low@2, real_high@2);
#endif

@= decideNextPiece
	tmpPiece = crackMap[m].pieces + @1;
	if (tmpPiece->kind == LEAF || firstCrack){
		
		/* CASE low [min, max=hgh] */
		if (low < tmpPiece->rng_min && hgh == tmpPiece->rng_max)
			@2vh = tmpPiece->idx_last;
		/* CASE [min=low,max] hgh */
		else 
		if  (hgh > tmpPiece->rng_max && low == tmpPiece->rng_min)
			@2vl = tmpPiece->idx_first;
		else 
		if  (!(( low < tmpPiece->rng_min && hgh > tmpPiece->rng_max) ||
			(tmpPiece->rng_max < low)||
		 	(tmpPiece->rng_min > hgh)))
			checkPieceWithoutGaps( m, b, xx, @1, low, hgh, @3vl, @3vh, FALSE); 
	}
	else	
	if (tmpPiece->kind != LEAF && !firstCrack){
		if ( low == tmpPiece->rng_min &&  hgh == tmpPiece->rng_max){
                        @2vl = tmpPiece->idx_first;
                        @2vh = tmpPiece->idx_last;
                }
		else checkPieceWithoutGaps( m, b, xx, @1, low, hgh, @3vl, @3vh, FALSE);
	}


@= greater
	((@1>@2) || (@1==@2 && @3==TRUE && @4==FALSE))
@= smaller
	((@1<@2) || (@1==@2 && @3==FALSE && @4==TRUE))
@= equal
	(@1==@1 && @3==@4)
@= greaterORequal
	((@1>@2) || (@1==@2 && ((@3==TRUE && @4==FALSE) || @3==@4)))
@= smallerORequal
	((@1<@2) || (@1==@2 && ((@3==FALSE && @4==TRUE) || @3==@4)))

@= checkNextPiece
	tmpPiece = crackMap[m].pieces + @1;
	if (tmpPiece->kind == LEAF || firstCrack){
		
		/* CASE low [min, max=hgh] */
		if (@:smaller(low,tmpPiece->rng_min,inclusiveLow,tmpPiece->inclusiveMin)@ && 
			@:equal(hgh,tmpPiece->rng_max,inclusiveHgh,tmpPiece->inclusiveMax)@)
			@2vh = tmpPiece->idx_last;
		/* CASE [min=low,max] hgh */
		else 
		if  (@:greater(hgh,tmpPiece->rng_max,inclusiveHgh,tmpPiece->inclusiveMax)@ && 
			@:equal(low,tmpPiece->rng_min,inclusiveLow,tmpPiece->inclusiveMin)@)
			@2vl = tmpPiece->idx_first;
		else 
		if  (!((@:smaller(low,tmpPiece->rng_min,inclusiveLow,tmpPiece->inclusiveMin)@ && 
				@:greater(hgh,tmpPiece->rng_max,inclusiveHgh,tmpPiece->inclusiveMax)@) ||
			(@:greater(low,tmpPiece->rng_max,inclusiveLow,tmpPiece->inclusiveMax)@)||
		 	(@:smaller(hgh,tmpPiece->rng_min,inclusiveHgh,tmpPiece->inclusiveMin)@)))
			checkPiece( m, b, xx, @1, low, hgh, inclusiveLow, inclusiveHgh, @3vl, @3vh, FALSE); 
	}
	else	
	if (tmpPiece->kind != LEAF && !firstCrack){
		if ( @:equal(low,tmpPiece->rng_min,inclusiveLow,tmpPiece->inclusiveMin)@ && 
			@:equal(hgh,tmpPiece->rng_max,inclusiveHgh,tmpPiece->inclusiveMax)@){
                        @2vl = tmpPiece->idx_first;
                        @2vh = tmpPiece->idx_last;
                }
		else checkPiece( m, b, xx, @1, low, hgh,inclusiveLow,inclusiveHgh, @3vl, @3vh, FALSE);
	}


@c
void
checkPiece(int m, BAT *b, int xx, int i, int low, int hgh, bit inclusiveLow, bit inclusiveHgh, size_t  *vl, size_t *vh, bit firstCrack)
{
	Piece *piece, *npiece, *tmpPiece;
        size_t l=0, h=0;
        piece = crackMap[m].pieces + i;

	if (piece->kind != LEAF && !firstCrack){
		if (  ( low >= piece->rng_min &&  low <= piece->rng_max) ||
			  ( hgh >= piece->rng_min &&  hgh <= piece->rng_max) ){
			if (piece->left != -1) {@:checkNextPiece(piece->left,*,)@}
			if (piece->middle != -1) {@:checkNextPiece(piece->middle,*,)@}
			if (piece->right != -1) {@:checkNextPiece(piece->right,*,)@}
		}       
	}
	if (piece->kind == LEAF || firstCrack){
		if (@:smallerORequal(low,piece->rng_min,inclusiveLow,piece->inclusiveMin)@ && 
			@:smaller(hgh,piece->rng_max,inclusiveHgh,piece->inclusiveMax)@ && 
			@:greater(hgh,piece->rng_min,inclusiveHgh,piece->inclusiveMin)@){
			
			/* split in two pieces, h,l get the the indices of the left  new piece, vh is the upper bound for the result
			   also check if we can get the lower bound of the result too in vl
			h = BUNindex(b, vmax)-1;
			*vh = BUNindex(b, vmax)-1;
			l = BUNindex(b, vmin)+1;
			if (low == piece->rng_min) 
				*vl = piece->idx_first;
			*/
		} else 
		if  (@:greaterORequal(hgh,piece->rng_max,inclusiveHgh,piece->inclusiveMax)@ && 
			@:smaller(low,piece->rng_max,inclusiveLow,piece->inclusiveMax)@ && 
			@:greater(low,piece->rng_min,inclusiveLow,piece->inclusiveMin)@){

			/* split in two pieces, h,l get the the indices of the left  new piece, vl is the lower bound for the result
                           also check if we can get the upper bound of the result too in vh
			h = BUNindex(b, vmax)-1;
			l = BUNindex(b, vmin)+1;
			*vl = BUNindex(b, vmax);
			if (hgh == piece->rng_max) 
				*vh = piece->idx_last;
			*/
		} else{
			/* split in three pieces, h,l get the the indices of the middle  new piece, result bounds are the same
			l = BUNindex(b, bls);
			h = BUNindex(b, bh)-1;
			*vl = BUNindex(b, bls);
			*vh = BUNindex(b, bh)-1;
			*/
		}
		if (piece->idx_first == l) {
			if (h < piece->idx_last) {
				piece->kind = PHI;
				piece->left = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				if ( hgh >= piece->rng_max) 
					npiece->rng_max = low-1;
				else npiece->rng_max = hgh;
				npiece->idx_last = h;
														
				piece->middle = -1;     
												
				piece->right = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@	  
				if (hgh >= piece->rng_max) 
					npiece->rng_min = low;
				else npiece->rng_min =  hgh + 1;
				npiece->idx_first = h + 1;      
			}
		} else if (piece->idx_last == h) {      
			if (l > piece->idx_first) {
				piece->kind = PHI;
				piece->left = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_max =  low - 1;
				npiece->idx_last = l - 1;

				piece->middle = -1;
						
				piece->right = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_min = low;
				npiece->idx_first = l;
			}
		} else {
				piece->kind = PHI;
				piece->left = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_max = low - 1;
				npiece->idx_last = l - 1;

				piece->middle = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_min = low;
				npiece->rng_max =  hgh;
				npiece->idx_first = l;
				npiece->idx_last = h;

				piece->right = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_min = hgh + 1;
				npiece->idx_first = h + 1;
		}
	}
}   

void
checkPieceWithoutGaps(int m, BAT *b, int xx, int i, int low, int hgh, size_t  *vl, size_t *vh, bit firstCrack)
{
	ptr vmax = 0, vmin = 0, vm, vmx, bl, bls, bh;
	ptr p, pn=0;
	Piece *piece, *npiece, *tmpPiece;
	size_t l=0, h=0;
	piece = crackMap[m].pieces + i;
	char buf[128];	  /* scratch space */
	int tmpTmax, tmpTmid;
#ifdef DEBUG_CRACKERS
	printf("\n checking piece %d, changing low high from %d, %d to ",i,low,hgh);
#endif

	if (piece->kind == LEAF || firstCrack){
		/* CASE low [min, hgh, max] */
		if (low <= piece->rng_min && hgh < piece->rng_max && hgh > piece->rng_min){
			vmin = (ptr) ((char *) BUNptr(b, piece->idx_first) - xx);
			vmax = (ptr) ((char *) BUNptr(b, piece->idx_last) + xx);
			vm = BUNtail(b, (ptr) ((char *) vmin + xx));
			for (p = (ptr) ((char *) vmin + xx); p < vmax; p = (ptr) ((char *) p + xx), vm = (ptr) ((char *) vm + xx)){
				if (*(int *) vm > hgh){
					vmax = (ptr) ((char *) vmax - xx);
					while (*(int *) BUNtail(b, vmax) > hgh && vmax > p)
						vmax = (ptr) ((char *) vmax - xx);
					if (vmax != p){
						@:exchange(vmax, p)@
					}
				}
			}
			h = BUNindex(b, vmax)-1;
			*vh = BUNindex(b, vmax)-1;
			l = BUNindex(b, vmin)+1;
			if (low == piece->rng_min) 
				*vl = piece->idx_first;
		} else 
		/* CASE low [min,max=hgh] or [min,low,max=hgh] or [min,low,max] hgh */
		if  (hgh >= piece->rng_max && low < piece->rng_max && low > piece->rng_min){

			vmin = (ptr) ((char *) BUNptr(b, piece->idx_first) - xx);
			vmax = (ptr) ((char *) BUNptr(b, piece->idx_last) + xx);
			vm = BUNtail(b, (ptr) ((char *) vmin + xx));
			for (p = (ptr) ((char *) vmin + xx); p < vmax; p = (ptr) ((char *) p + xx), vm = (ptr) ((char *) vm + xx))
				if (*(int *) vm >= low){
					vmax = (ptr) ((char *) vmax - xx);
					while (*(int *) BUNtail(b, vmax) >= low && vmax > p)
						vmax = (ptr) ((char *) vmax - xx);
					if (vmax != p){
						@:exchange(vmax, p)@
				}
			}		
			h = BUNindex(b, vmax)-1;
			l = BUNindex(b, vmin)+1;
			*vl = BUNindex(b, vmax);
			if (hgh == piece->rng_max) 
				*vh = piece->idx_last;
		} else{
#ifdef DEBUG_CRACKERS
			printf("#splitting in three pieces \n");
#endif
			vmin = BUNptr(b, piece->idx_first);
			vmax = BUNptr(b, piece->idx_last);

			/* Make a first scan to count the number of buns that have a value lower than low.
			After the scan bl points to the first BUN with value > low */
				
			bl = vmin;
			bh = vmin;
			vmx = BUNtail(b, vmax);
			for (vm = BUNtail(b, vmin); vm <= vmx;  vm = (ptr) ((char *) vm + xx)){
				bl = (ptr) ((char *) bl + xx*(*(int *) vm < low));
				bh = (ptr) ((char *) bh + xx*(*(int *) vm <= hgh));
			}
			bls = bl;
			   
#ifdef DEBUG_CRACKERS
			printf("# bounds are: low %d, high %d  ", *(int *) BUNtail(b, bl), *(int *) BUNtail(b, bh));
#endif	  
			/* Make a second scan to reshufle the buns */
				
			vm = BUNtail(b, vmin);
				
			for (p = vmin; p < bh; p = (ptr) ((char *) p + xx), vm = (ptr) ((char *) vm + xx)) {

#ifdef DEBUG_CRACKERS   
				printf("#checking  tail %d", *(int *) BUNtail(b, p));
#endif	                
				if (p >= bls){  /* then we have already created the <low partition so we can follow more simple rules now*/

#ifdef DEBUG_CRACKERS	   
					printf("#in the middle partition  ");
#endif	                  
					if (*(int *) vm >  hgh){
						tmpTmax = *(int *) BUNtail(b, vmax);
						while (*(int *) BUNtail(b, vmax) > hgh && vmax > bh){
							vmax = (ptr) ((char *) vmax - xx);
							tmpTmax = *(int *) BUNtail(b, vmax);
						}
						if (tmpTmax >= low && tmpTmax <=  hgh){
							@:exchange(vmax, p)@
						}
					}
					continue;
				} 
				
#ifdef DEBUG_CRACKERS
				printf("#still in the low partition ");
#endif	  
				/* if current BUN is below the low range just leave it there */
						
				if (*(int *) vm >= low && *(int *) vm <= hgh) {
								
#ifdef DEBUG_CRACKERS   
					printf("#current belongs in the middle partition");
#endif	                  
					for (pn = bl; pn < bh; pn = (ptr) ((char *) pn + xx), bl = (ptr) ((char *) bl + xx)){
						tmpTmid = *(int *) BUNtail(b, pn);
						if (tmpTmid < low){
							@:exchange(pn, p)@
							bl = (ptr) ((char *) bl + xx);
							break;
						}

						if (tmpTmid >  hgh){
							tmpTmax = *(int *) BUNtail(b, vmax);
							while (*(int *) BUNtail(b, vmax) > hgh && vmax > bh){
								vmax = (ptr) ((char *) vmax - xx);
								tmpTmax = *(int *) BUNtail(b, vmax);
							}
							if (tmpTmax >= low  && tmpTmax <=  hgh){
								@:exchange(vmax, pn)@
							}
							if (tmpTmax < low){
								@:exchange2(p,pn,vmax)@
								bl = (ptr) ((char *) bl + xx);
								break;
							} 
						}       
					}       
				} else if (*(int *) vm > hgh) {

#ifdef DEBUG_CRACKERS
					printf("#current belongs in the high partition");
#endif
					/* exchange with qualifying tail elm */

					for (pn = vmax; pn >= bh; pn = (ptr) ((char *) pn - xx), vmax = (ptr) ((char *) vmax - xx)){
						tmpTmax = *(int *) BUNtail(b, pn);
						if (tmpTmax < low){
							@:exchange(pn, p)@
							break;
						}
						if (tmpTmax >= low && tmpTmax <=  hgh){
							tmpTmid = *(int *) BUNtail(b, bl);
							while (tmpTmid >= low && tmpTmid <=  hgh && bl < bh){
								bl = (ptr) ((char *) bl + xx);
								tmpTmid = *(int *) BUNtail(b, bl);
							}
							if (tmpTmid > hgh){
								@:exchange(bl, pn)@
							}
							if (tmpTmid < low){
								@:exchange2(pn, bl, p)@
								bl = (ptr) ((char *) bl + xx);
								break;
							}
						}
					}

				}
			}
			l = BUNindex(b, bls);
			h = BUNindex(b, bh)-1;
			*vl = BUNindex(b, bls);
			*vh = BUNindex(b, bh)-1;
		}
@-
For each fragment discovered we have to break it into several pieces
and update the administration BATs.
@c
		if (piece->idx_first == l) {
			if (h < piece->idx_last) {
				piece->kind = PHI;
				piece->left = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				if ( hgh >= piece->rng_max) 
					npiece->rng_max = low-1;
				else npiece->rng_max =  hgh;
				npiece->idx_last = h;
														
				piece->middle = -1;     
												
				piece->right = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@	  
				if (hgh >= piece->rng_max) 
					npiece->rng_min = low;
				else npiece->rng_min =  hgh + 1;
				npiece->idx_first = h + 1;      
			}
		} else if (piece->idx_last == h) {      
#ifdef DEBUG_CRACKERS
				printf("\n administer in the right part\n");
#endif
			if (l > piece->idx_first) {
				/* falls at high end */
				piece->kind = PHI;
				piece->left = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_max =  low - 1;
				npiece->idx_last = l - 1;

				piece->middle = -1;
						
				piece->right = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_min = low;
				npiece->idx_first = l;
			}
		} else {
				piece->kind = PHI;
				piece->left = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_max =  low - 1;
				npiece->idx_last = l - 1;

				piece->middle = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_min =  low;
				npiece->rng_max =  hgh;
				npiece->idx_first = l;
				npiece->idx_last = h;

				piece->right = crackMap[m].freepiece;
				@:newPiece(m, npiece,piece,i)@
				npiece->rng_min =  hgh + 1;
				npiece->idx_first = h + 1;
		}
	}
	else if (piece->kind != LEAF && !firstCrack){
#ifdef DEBUG_CRACKERS
		printf("\n checking piece %d, changing low high from %d, %d to ",i,low,hgh);
#endif

#ifdef DEBUG_CRACKERS   
		printf(" %d, %d \n", low,hgh);
#endif	          
		if (  ( low >= piece->rng_min &&  low <= piece->rng_max) ||
			  ( hgh >= piece->rng_min &&  hgh <= piece->rng_max) ){
			if (piece->left != -1) {@:decideNextPiece(piece->left,*,)@}
			if (piece->middle != -1) {@:decideNextPiece(piece->middle,*,)@}
			if (piece->right != -1) {@:decideNextPiece(piece->right,*,)@}
		}       
	}
}   

void
checkPieceWithGaps(int m, BAT *b, int xx, int i, int *low, int *hgh, size_t  *vl, size_t *vh, bit firstCrack)
{
	ptr vmax = 0, vmin = 0, vm, bl, bls, bh;
	ptr p, pn=0;
	Piece *piece, *npiece;
        size_t l=0, h=0;
	piece = crackMap[m].pieces + i;
	char buf[128];		/* scratch space */
	int real_low1=INT_MAX, real_high1=INT_MIN, 
	    real_low2=INT_MAX, real_high2=INT_MIN, 
	    real_low3=INT_MAX, real_high3=INT_MIN;
	int cur_val;
#ifdef DEBUG_CRACKERS
	printf("\n checking piece %d, with  low high  %d, %d to ",i,*(int*)low,*(int*)hgh);
#endif

	if (i == 0){
		if (*(int *) low < crackMap[m].pieces[i].real_rng_min) *low = crackMap[m].pieces[i].real_rng_min;
		if (*(int *) hgh > crackMap[m].pieces[i].real_rng_max) *hgh = crackMap[m].pieces[i].real_rng_max;
		if (*(int *) low > *(int *) hgh){
			*vl = 1;
			*vh = -1;
			return;
		}
#ifdef DEBUG_CRACKERS
        printf("\n changed to low high  %d, %d to ",*(int*)low,*(int*)hgh);
#endif	
	}
        if (crackMap[m].pieces[i].kind == LEAF || firstCrack){
                if (*(int *) low < crackMap[m].pieces[i].rng_min && *(int *) hgh > crackMap[m].pieces[i].rng_max)
                        return;               
                else if (crackMap[m].pieces[i].rng_max < *(int *) low)
                        return;
                else if (crackMap[m].pieces[i].rng_min > *(int *) hgh)
                        return;
		else if (*(int *) low < crackMap[m].pieces[i].rng_min && *(int *) hgh == crackMap[m].pieces[i].real_rng_max){
                        *vh = piece->idx_last;
                        return;
                }
                else if ((*(int *) low < crackMap[m].pieces[i].rng_min || 
				*(int *) low == crackMap[m].pieces[i].real_rng_min)
			 && *(int *) hgh < crackMap[m].pieces[i].rng_max
                         && *(int *) hgh > crackMap[m].pieces[i].rng_min){
                       
                        vmin = (ptr) ((char *) BUNptr(b, piece->idx_first) - xx);
                        vmax = (ptr) ((char *) BUNptr(b, piece->idx_last) + xx); 
                                
                        vm = BUNtail(b, (ptr) ((char *) vmin + xx));

                        for (p = (ptr) ((char *) vmin + xx); p < vmax; p = (ptr) ((char *) p + xx), vm = (ptr) ((char *) vm + xx)){
                                if (*(int *) vm > *(int*)hgh){
                                        vmax = (ptr) ((char *) vmax - xx);
                                        while (*(int *) BUNtail(b, vmax) > *(int*)hgh && vmax > p){
						@:updateRealBounds(*(int *) BUNtail(b, vmax),3)@
                                                vmax = (ptr) ((char *) vmax - xx);
					}
                                        if (vmax != p) {
						@:exchange(vmax, p)@
					}
					@:updateRealBounds(*(int *) BUNtail(b, vmax),3)@
                                }
				if (vmax != p){
					 @:updateRealBounds(*(int *) BUNtail(b, p),1)@
				}
                        }
                        h = BUNindex(b, vmax)-1;
                        *vh = BUNindex(b, vmax)-1;
                        l = BUNindex(b, vmin)+1;
			if (*(int *) low == crackMap[m].pieces[i].real_rng_min) *vl = piece->idx_first;
                }
		else if  (*(int *) hgh > crackMap[m].pieces[i].rng_max && *(int *) low == crackMap[m].pieces[i].real_rng_min){
                        *vl = piece->idx_first;
                        return;
                }
                else if  ((*(int *) hgh > crackMap[m].pieces[i].rng_max || 
				*(int *) hgh == crackMap[m].pieces[i].real_rng_max) 
			  && *(int *) low < crackMap[m].pieces[i].rng_max
                          && *(int *) low > crackMap[m].pieces[i].rng_min){

                        vmin = (ptr) ((char *) BUNptr(b, piece->idx_first) - xx);
                        vmax = (ptr) ((char *) BUNptr(b, piece->idx_last) + xx);

                        vm = BUNtail(b, (ptr) ((char *) vmin + xx));

                        for (p = (ptr) ((char *) vmin + xx); p < vmax; p = (ptr) ((char *) p + xx), vm = (ptr) ((char *) vm + xx)){
                                if (*(int *) vm >= *(int*)low){
                                        vmax = (ptr) ((char *) vmax - xx);
					while (*(int *) BUNtail(b, vmax) >= *(int*)low && vmax > p){
						@:updateRealBounds(*(int *) BUNtail(b, vmax),3)@	
                                                vmax = (ptr) ((char *) vmax - xx);
                                        }

                                        if (vmax != p){ 
						@:exchange(vmax, p)@
					}
					@:updateRealBounds(*(int *) BUNtail(b, vmax),3)@
					
					
                                }
				if (vmax != p){
					 @:updateRealBounds(*(int *) BUNtail(b, p),1)@
				}
                        }
                        h = BUNindex(b, vmax)-1;
                        l = BUNindex(b, vmin)+1;
                        *vl = BUNindex(b, vmax);
			if (*(int *) hgh == crackMap[m].pieces[i].real_rng_max) *vh = piece->idx_last;
                }
                else{
        #ifdef DEBUG_CRACKERS
                       printf("#splitting in three pieces \n");
	#endif
                        vmin = (ptr) ((char *) BUNptr(b, piece->idx_first) - xx);
                        vmax = (ptr) ((char *) BUNptr(b, piece->idx_last) + xx);
                        
                        vm = BUNtail(b, (ptr) ((char *) vmin + xx));
                        
                        /* Make a first scan to count the nubmer of buns that have a value lower than low.
                        After the scan bl points to the first BUN with value > low */

                        bl = (ptr) ((char *) vmin + xx);
                        bh = (ptr) ((char *) vmin + xx);
                        for (p = (ptr) ((char *) vmin + xx); p < vmax; p = (ptr) ((char *) p + xx), vm = (ptr) ((char *) vm + xx))
                                if (*(int *) vm < *(int *) low){
                                        bl = (ptr) ((char *) bl + xx);
                                        bh = (ptr) ((char *) bh + xx);
                                }
                                else if (*(int *) vm >= *(int *) low && *(int *) vm <= *(int *) hgh)
                                        bh = (ptr) ((char *) bh + xx);

                        bls = (ptr) ((char *) bl);
                       
        #ifdef DEBUG_CRACKERS
                        printf("# bounds are: low %d, high %d  ", *(int *) BUNtail(b, bl), *(int *) BUNtail(b, bh)); 
	#endif
                        /* Make a second scan to resufle the buns */

                        vm = BUNtail(b, (ptr) ((char *) vmin + xx));

                        for (p = (ptr) ((char *) vmin + xx); p < bh; p = (ptr) ((char *) p + xx), vm = (ptr) ((char *) vm + xx)) {

        #ifdef DEBUG_CRACKERS
				printf("#checking  tail %d", *(int *) BUNtail(b, p));
        #endif                        
				if (p >= bls){  /* then we have already created the <low partition so we can follow more simple rules now*/

        #ifdef DEBUG_CRACKERS
                                        printf("#in the middle partition  ");
        #endif
                                        if (*(int *) vm > *(int *) hgh){
                                                vmax = (ptr) ((char *) vmax - xx);
                                                while (*(int *) BUNtail(b, vmax) > *(int *) hgh && vmax > bh){
							@:updateRealBounds(*(int *) BUNtail(b, vmax),3)@
                                                        vmax = (ptr) ((char *) vmax - xx);
                                       		 }
	
                                                if (*(int *) BUNtail(b, vmax) >= *(int *) low && *(int *) BUNtail(b, vmax) <= *(int *) hgh){
                                                        @:exchange(vmax, p)@
							@:updateRealBounds(*(int *) BUNtail(b, vmax),3)@
						}
                                        }
					@:updateRealBounds(*(int *) BUNtail(b, p),2)@
					continue;
                                }

        #ifdef DEBUG_CRACKERS
                                printf("#still in the low partition ");
        #endif
                                /* if current BUN is below the low range just leave it there */

                                if (*(int *) vm >= *(int *) low && *(int *) vm <= *(int *) hgh) {

        #ifdef DEBUG_CRACKERS
                                        printf("#current belongs in the middle partition");
        #endif

                                        for (pn = (ptr) ((char *) bl); pn < bh; pn = (ptr) ((char *) pn + xx), bl = (ptr) ((char *) bl + xx)){
                                                if (*(int *) BUNtail(b, pn) < *(int *) low){
                                                        @:exchange(pn, p)@
							
							@:updateRealBounds(*(int *) BUNtail(b, pn),2)@

                                                        bl = (ptr) ((char *) bl + xx);

		                                        break;
                                                }
                                                if (*(int *) BUNtail(b, pn) > *(int *) hgh){
                                                        vmax = (ptr) ((char *) vmax - xx);
                                                        while (*(int *) BUNtail(b, vmax) > *(int *) hgh && vmax > bh){
                                                       	       @:updateRealBounds(*(int *) BUNtail(b, vmax),3)@ 
								vmax = (ptr) ((char *) vmax - xx);
                                	                }

                                                        if (*(int *) BUNtail(b, vmax) >= *(int *) low && *(int *) BUNtail(b, vmax) <= *(int *) hgh){
                                                                @:exchange(vmax, pn)@
								@:updateRealBounds(*(int *) BUNtail(b, vmax),3)@
							}
                                                	if (*(int *) BUNtail(b, vmax) < *(int *) low){
                                                                @:exchange2(p,pn,vmax)@
                                                        	
								@:updateRealBounds(*(int *) BUNtail(b, pn),2)@	
								@:updateRealBounds(*(int *) BUNtail(b, vmax),3)@	

                                                                bl = (ptr) ((char *) bl + xx);

								break;
                                                        }
                                                }
						@:updateRealBounds(*(int *) BUNtail(b, pn),2)@
					}

                                } else if (*(int *) vm > *(int *) hgh) {

        #ifdef DEBUG_CRACKERS
                                        printf("#current belongs in the high partition");
        #endif
                                        /* exchange with qualifying tail elm */

                                        for (pn = (ptr) ((char *) vmax-xx); pn >= bh; pn = (ptr) ((char *) pn - xx), vmax = (ptr) ((char *) vmax - xx)){

                                                if (*(int *) BUNtail(b, pn) < *(int *) low){
                                                        @:exchange(pn, p)@
							@:updateRealBounds(*(int *) BUNtail(b, pn),3)@	
							break;
                                                }
                                                if (*(int *) BUNtail(b, pn) >= *(int *) low && *(int *) BUNtail(b, pn) <= *(int *) hgh){

                                                        while (*(int *) BUNtail(b, bl) >= *(int *) low && *(int *) BUNtail(b, bl) <= *(int *) hgh && bl < bh){
								@:updateRealBounds(*(int *) BUNtail(b, bl),2)@
                                                                bl = (ptr) ((char *) bl + xx);
							}
                                                        if (*(int *) BUNtail(b, bl) > *(int *) hgh){
                                                                @:exchange(bl, pn)@
								@:updateRealBounds(*(int *) BUNtail(b, bl),2)@
							}
                                                        if (*(int *) BUNtail(b, bl) < *(int *) low){
                                                                @:exchange2(pn, bl, p)@
								
								@:updateRealBounds(*(int *) BUNtail(b, pn),3)@
								@:updateRealBounds(*(int *) BUNtail(b, bl),2)@

                                                                bl = (ptr) ((char *) bl + xx);

                                                                break;
                                                        }
                                                }
						@:updateRealBounds(*(int *) BUNtail(b, pn),3)@
                                        }

                                }
				@:updateRealBounds(*(int *) BUNtail(b, p),1)@
                        }
                	l = BUNindex(b, bls);
			h = BUNindex(b, bh)-1;
                	*vl = BUNindex(b, bls);
			*vh = BUNindex(b, bh)-1;
                }
@-
For each fragment discovered we have to break it into several pieces
and update the administration BATs.
@c              
                if (piece->idx_first == l) {
                        if (h < piece->idx_last) {
				if (firstCrack) {
					piece->real_rng_min = piece->rng_min = real_low1;
					piece->real_rng_max = piece->rng_max = real_high3;
				}
                                piece->kind = PHI;
                                piece->left = crackMap[m].freepiece;
                                @:newPiece(m, npiece,piece,i)@
                                if ((*(int *) hgh > piece->rng_max) || (*(int *) hgh == piece->real_rng_max)) 
					npiece->rng_max = *(int *) low-1;
				else npiece->rng_max = *(int *) hgh;
				npiece->real_rng_min = real_low1;
				npiece->real_rng_max = real_high1;
                                npiece->idx_last = h;

                                piece->middle = -1;

                                piece->right = crackMap[m].freepiece;
                                @:newPiece(m, npiece,piece,i)@
                                if ((*(int *) hgh > piece->rng_max) || (*(int *) hgh == piece->real_rng_max)) 
					npiece->rng_min = *(int *) low;
				else npiece->rng_min = *(int *) hgh + 1;
				npiece->real_rng_min = real_low3;
                                npiece->real_rng_max = real_high3;
                                npiece->idx_first = h + 1;
                        }
                } else if (piece->idx_last == h) {
                        if (l > piece->idx_first) {
#ifdef DEBUG_CRACKERS
			printf("\n administer in the right part\n");
#endif
				if (firstCrack) {
					piece->real_rng_min = piece->rng_min = real_low1;
					piece->real_rng_max = piece->rng_max = real_high3;
				}
                                /* falls at high end */
                                piece->kind = PHI;
                                piece->left = crackMap[m].freepiece;
                                @:newPiece(m, npiece,piece,i)@
                                npiece->rng_max = *(int *) low - 1;
				npiece->real_rng_min = real_low1;
                                npiece->real_rng_max = real_high1;
                                npiece->idx_last = l - 1;

                                piece->middle = -1;

                                piece->right = crackMap[m].freepiece;
                                @:newPiece(m, npiece,piece,i)@
                                npiece->rng_min = *(int *) low;
				npiece->real_rng_min = real_low3;
                                npiece->real_rng_max = real_high3;
                                npiece->idx_first = l;
                        }
                } else {
			if (firstCrack) {
                        	piece->real_rng_min = piece->rng_min = real_low1;
                                piece->real_rng_max = piece->rng_max = real_high3;
                        }
                        piece->kind = PHI;
                        piece->left = crackMap[m].freepiece;
                        @:newPiece(m, npiece,piece,i)@
                        npiece->rng_max = *(int *) low - 1;
						npiece->real_rng_min = real_low1;
                        npiece->real_rng_max = real_high1;
                        npiece->idx_last = l - 1;

                        piece->middle = crackMap[m].freepiece;
                        @:newPiece(m, npiece,piece,i)@
                        npiece->rng_min = *(int *) low;
                        npiece->rng_max = *(int *) hgh;
						npiece->real_rng_min = real_low2;
                        npiece->real_rng_max = real_high2;
                        npiece->idx_first = l;
                        npiece->idx_last = h;
         
	                piece->right = crackMap[m].freepiece;
                        @:newPiece(m, npiece,piece,i)@
                        npiece->rng_min = *(int *) hgh + 1;
			npiece->real_rng_min = real_low3;
                        npiece->real_rng_max = real_high3;
                        npiece->idx_first = h + 1;
                }
	}
	else if (crackMap[m].pieces[i].kind != LEAF && !firstCrack){
#ifdef DEBUG_CRACKERS
		printf("\n checking piece %d, changing low high from %d, %d to ",i,*(int*)low,*(int*)hgh);
#endif
		if ((*(int *) low >= crackMap[m].pieces[i].rng_min && *(int *) low < crackMap[m].pieces[i].real_rng_min) &&
		   (*(int *) hgh >= crackMap[m].pieces[i].rng_min && *(int *) hgh < crackMap[m].pieces[i].real_rng_min)){
			*vl = 1;
                        *vh = -1;
			return;
		}
			 
		if ((*(int *) low > crackMap[m].pieces[i].real_rng_max && *(int *) low <= crackMap[m].pieces[i].rng_max) &&
		   (*(int *) hgh > crackMap[m].pieces[i].real_rng_max && *(int *) hgh <= crackMap[m].pieces[i].rng_max)){
                        *vl = 1;
                        *vh = -1;
                        return;
                }

		if (*(int *) low >= crackMap[m].pieces[i].rng_min && *(int *) low < crackMap[m].pieces[i].real_rng_min) 
			*low = crackMap[m].pieces[i].real_rng_min;
		if (*(int *) hgh > crackMap[m].pieces[i].real_rng_max && *(int *) hgh <= crackMap[m].pieces[i].rng_max) 
			*hgh = crackMap[m].pieces[i].real_rng_max; 


#ifdef DEBUG_CRACKERS
		printf(" \n  new bound are :%d, %d \n", *(int*)low,*(int*)hgh);
#endif
		if (*(int *) low == crackMap[m].pieces[i].real_rng_min && *(int *) hgh == crackMap[m].pieces[i].real_rng_max){
			*vl = piece->idx_first;
			*vh = piece->idx_last;
			return;
		}
                if (  (*(int *) low >= crackMap[m].pieces[i].rng_min && *(int *) low <= crackMap[m].pieces[i].rng_max) ||
                      (*(int *) hgh >= crackMap[m].pieces[i].rng_min && *(int *) hgh <= crackMap[m].pieces[i].rng_max) ){
			if (piece->left != -1) checkPieceWithGaps( m, b, xx, piece->left, low, hgh, vl, vh, FALSE);  
			if (piece->middle != -1) checkPieceWithGaps(m, b, xx, piece->middle, low, hgh, vl, vh, FALSE);  
			if (piece->right != -1) checkPieceWithGaps(m, b, xx, piece->right, low, hgh, vl, vh, FALSE);  
		}
	}	
}

/* alter previous function to achieve the minimum number of exchanges
   when a proper piece is found for cracking it is scanned once to count the
   the positions low high where the desired piece will be at the end
   then this information is used for more efficient exchanges

   It is not going to be always better depending on the size of the piece, in memory or not etc*/
str
CRKcrackRangeWithTwoScans(int *vid, int *bid, int low, int hgh, bit tail)
{
        BAT *b, *view, *uview;
        int xx;
        int  m;
        size_t vl=0, vh=0;
	bit firstCrack = FALSE;
	Piece *tmpPiece;
        if (low >  hgh)
                return throwMessage("crackers.crack", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crackRange", "Cannot access descriptor");
        }
        m = existsCrackMap(*bid);
        if (m == -1){
		if (b->htype ==TYPE_void) {
			 b = BATmaterializeh(b,BATcount(b));
			 b->hsorted = FALSE;
			 b->tsorted = FALSE;
			 b->hdense = FALSE; 
		 	 b->hdense = FALSE;	
		}
                m = newCrackMap(*bid);
                initCrackMap(crackMap + m, bid);
		firstCrack = TRUE;
        }
@-
Inspect the value range table to only further crack qualifying fragments.
@c

#ifdef DEBUG_CRACKERS
        printf("#search range %d %d \n", low, hgh);
#endif
        xx = BUNsize(b);
       /* checkPieceWithGaps(m, b, xx, 0, low, hgh, &vl, &vh, firstCrack);*/
       /* checkPieceWithoutGaps(m, b, xx, 0, *low, *hgh, &vl, &vh, firstCrack);*/
	@:decideNextPiece(0,,&)@

	view = BATslice(b, vl, vh+1);

        if (!tail) {
                uview = BATconst(view,TYPE_void,ATOMnilptr(TYPE_void));
                *vid = uview->batCacheid;		
        }
        else *vid = view->batCacheid;
	BBPfix(*vid);
@-              
If this was the first cracking operation it makes sense to administer
the ranges of the outer partitions as well.                      
@c
        BBPunfix(b->batCacheid);
        return MAL_SUCCEED;
}                               


str
CRKselect(int *vid, int *bid, int *low, int *hgh)
{
        int l = *(int*) low;
        int h = *(int*) hgh;

	if (l == int_nil) {
		l = INT_MIN;
		CRKcrackRangeWithTwoScans(vid, bid, l, h, TRUE);
	}
	else if (h == int_nil) {
		h = INT_MAX;
		CRKcrackRangeWithTwoScans(vid, bid, l, h, TRUE);
	} 
        else CRKcrackRangeWithTwoScans(vid, bid, l, h, TRUE);
        return MAL_SUCCEED;     
}



str
CRKselectBounds_(int *vid, int *bid, int *low, int *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{		
        int l = *(int*) low;
        int h = *(int*) hgh;

	if (l == int_nil)
		l = INT_MIN;
	if (h == int_nil)
		h = INT_MAX;

	if (*(bit*)inclusiveLow == FALSE && *(bit*)inclusiveHgh == FALSE) {
		l=l+1;
		h=h-1;
		CRKcrackRangeWithTwoScans(vid, bid, l, h, TRUE);
	}
	else if (*(bit*)inclusiveLow == FALSE && *(bit*)inclusiveHgh  == TRUE) {	
		l=l+1;	
		CRKcrackRangeWithTwoScans(vid, bid,  l, h, TRUE);
	}
	else if (*(bit*)inclusiveLow == TRUE && *(bit*)inclusiveHgh == FALSE){
		h=h-1;
		CRKcrackRangeWithTwoScans(vid, bid, l, h, TRUE);
	}
	else 
		CRKcrackRangeWithTwoScans(vid, bid, l, h, TRUE);
	return MAL_SUCCEED;
}


str                             
CRKselectValue(int *vid, int *bid, int *value)
{                                       
        int l = *(int*) value;
        int h = *(int*) value;

	CRKcrackRangeWithTwoScans(vid, bid, l, h, TRUE);
        return MAL_SUCCEED;     
} 

str                             
CRKuselect(int *vid, int *bid, int *low, int *hgh)
{                               
        int l = *(int*) low;
        int h = *(int*) hgh;

	if (l == int_nil) {
		l = INT_MIN;
		CRKcrackRangeWithTwoScans(vid, bid, l, h, FALSE);
	}
	else if (h == int_nil) {
		h = INT_MAX;
		CRKcrackRangeWithTwoScans(vid, bid, l, h, FALSE);
	} 
        else CRKcrackRangeWithTwoScans(vid, bid, l, h, FALSE);
        return MAL_SUCCEED;     
}                               
                        
                
str                     
CRKuselectBounds(int *vid, int *bid, int *low, int *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{                       
        int l = *(int*) low;
        int h = *(int*) hgh;

	if (l == int_nil)
		l = INT_MIN;
	if (h == int_nil)
		h = INT_MAX;

	if (*(bit*)inclusiveLow == FALSE && *(bit*)inclusiveHgh == FALSE) {
		l=l+1;
		h=h-1;
		CRKcrackRangeWithTwoScans(vid, bid, l, h, FALSE);
	}
	else if (*(bit*)inclusiveLow == FALSE && *(bit*)inclusiveHgh  == TRUE) {		
		l=l+1;		
		CRKcrackRangeWithTwoScans(vid, bid,  l, h, FALSE);
	}
	else if (*(bit*)inclusiveLow == TRUE && *(bit*)inclusiveHgh == FALSE){		
		 h=h-1;
		 CRKcrackRangeWithTwoScans(vid, bid, l, h, FALSE);
	}
	else
		 CRKcrackRangeWithTwoScans(vid, bid, l, h, FALSE);
        return MAL_SUCCEED;
}                       

str
CRKuselectValue(int *vid, int *bid, int *value)
{
        int l = *(int*) value;
        int h = *(int*) value;

        CRKcrackRangeWithTwoScans(vid, bid, l, h, FALSE);
        return MAL_SUCCEED;
}


str
CRKcrackJoin(int *partid, int *bid, int *cid)
{
	(void) bid;
	(void) cid;
	GDKerror("CRKcrackJoin:not yet implemented\n");
	*partid = 0;
	return MAL_SUCCEED;
}

@- 
The pieces of a cracked BAT are obtained through bat view.
The nextPiece simply changes the dimensions of the BATview
returned previously to represent a cracker piece.
@c
int
CRKsetBounds(BAT *b, BAT *view, int mid, int pid)
{
	int l, h;

	(void) view;		/* fool compiler */

	l = crackMap[mid].pieces[pid].idx_first;
	h = crackMap[mid].pieces[pid].idx_last;
#ifdef DEBUG_CRACKERS
	printf("set view to new dimension[%d,%d]: %d-%d\n", mid, pid, l, h);
#endif
	VIEWbounds(view, l, h);
	if (pid > 0 && (size_t) pid == BATcount(b))
		return 0;
	return pid + 1;
}

str
CRKnewIterator(lng *newpid, int *vid, int *bid)
{
	BAT *b, *view;
	int m, i;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.newIterator", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);

	b->batRestricted = BAT_READ;
	view = VIEWcreate_(b, TRUE);

	*newpid = -1;
	for (i = 0; i < crackMap[m].freepiece; i++)
		if (crackMap[m].pieces[i].kind == LEAF) {
			*newpid = CRKsetBounds(b, view, m, i);
			break;
		}
	BBPunfix(b->batCacheid);
	BBPincref(*vid = view->batCacheid, TRUE);
	return MAL_SUCCEED;
}

str
CRKhasMoreElements(lng *pid, int *vbid, int *bid)
{
	BAT *b, *vid;
	int m, i;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.hasMoreElements", "Cannot access descriptor");
	}
	if ((vid = BATdescriptor(*vbid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.hasMoreElements", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);

	/* test validity of pid  [todo] */
	if (*pid > crackMap[m].freepiece) {
		*pid = -1;
		BBPunfix(b->batCacheid);
		BBPunfix(vid->batCacheid);
		return MAL_SUCCEED;
	}
	if (*pid <= 0) {
		return throwMessage("crackers.hasMoreElements", "illegal piece");
	}

	for (i = (int) *pid; i < crackMap[m].freepiece; i++)
		if (crackMap[m].pieces[i].kind == LEAF) {
			*pid = CRKsetBounds(b, vid, m, i);
			BBPunfix(b->batCacheid);
			BBPunfix(vid->batCacheid);
			return MAL_SUCCEED;
		}
	*pid = -1;
	BBPunfix(b->batCacheid);
	BBPunfix(vid->batCacheid);
	return MAL_SUCCEED;
}

@-
Selectively retrieve the pieces from the jigsaw.
@c
str
CRKgetPiece0(int *vbid, int *bid, int *piece)
{
	BAT *b, *vid;
	int m;
	lng result = 0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.getPiece", "Cannot access descriptor");
	}
	CRKnewIterator(&result, vbid, bid);
	m = (int) result;
	if ((vid = BATdescriptor(m)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.getPiece", "Cannot access descriptor");
	}
	m = findCrackMap(*vbid);
	CRKsetBounds(b, vid, m, *piece);
	BBPunfix(b->batCacheid);
	BBPunfix(vid->batCacheid);
	return MAL_SUCCEED;
}

str
CRKgetPiece1(int *newpid, int *bid, int *vbid, int *piece)
{
	int m;
	BAT *b, *vid;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.getPiece", "Cannot access descriptor");
	}
	if ((vid = BATdescriptor(*vbid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.getPiece", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);
	/* test validity of piece */
	CRKsetBounds(b, vid, m, *piece);
	BBPunfix(b->batCacheid);
	BBPunfix(vid->batCacheid);
	*newpid = 0;
	return MAL_SUCCEED;
}

@-
The combined pieces can be retrieved as an ordinary
overloaded select.  The cracker administration is
organized as an interval tree. The left and right
branch are always set. The middle may be empty.
@c
int
intervalFind(int m, int p, int *val)
{
	int x = -1;

/* printf("search %d in %d[%d,%d]\n",
	*val,p,crackMap[m].pieces[p].rng_min ,crackMap[m].pieces[p].rng_max); */
	if (crackMap[m].pieces[p].left > 0) {
		x = intervalFind(m, crackMap[m].pieces[p].left, val);
	}
	if (x == -1 && crackMap[m].pieces[p].middle > 0) {
		x = intervalFind(m, crackMap[m].pieces[p].middle, val);
	}
	if (x == -1 && crackMap[m].pieces[p].right > 0) {
		x = intervalFind(m, crackMap[m].pieces[p].right, val);
	}
	if (x == -1 && *val >= crackMap[m].pieces[p].rng_min && *val <= crackMap[m].pieces[p].rng_max)
		return p;
	return x;
}

void
intervalSelect(int m, int p, int *low, int *high, int *first, int *last)
{
	if (crackMap[m].pieces[p].rng_min > *low)
		*first = p;
	else
		*first = intervalFind(m, p, low);
/* printf("left found %d\n",*first);*/
	if (crackMap[m].pieces[p].rng_max < *high)
		*last = p;
	else
		*last = intervalFind(m, p, high);
/* printf("right found %d\n",*last);*/
}

@-
The algorithm collects the elements by repeatedly
inspecting the cracker table to extend the scope.
It keeps a count of number of leftover pieces.
If it can not glue the pieces together it should
create a BAT and insert all the left over elements;

The cracking strategy ensures that you don;t have to pick
the left/right pieces. Any piece that qualifies the search
would be sufficient. This works because we know that
the reshuffling of a range always takes place within the
space of its origin.
@c
str
CRKselectNew(int *vid, int *bid, int *low, int *high, bit *li, bit *hi)
{
	BAT *b, *view;
	int m;
	int left, right;

	(void) li;
	(void) hi;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.selectPiece", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);

	b->batRestricted = BAT_READ;
	view = VIEWcreate_(b, TRUE);
	*vid = view->batCacheid;
	intervalSelect(m, 0, low, high, &left, &right);
	/* printf("get range from %d %d\n",left,right); */
	if (left >= 0 && right >= 0)
		VIEWbounds(view, crackMap[m].pieces[left].idx_first, crackMap[m].pieces[right].idx_last);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CRKselectBounds(int *vid, int *bid, int *low, int *high, bit *li, bit *hi)
{
        BAT *b, *view;
        int m, i;
        int leftover, glued;
        int idxlow = -1, idxhgh = -1;

        (void) li;
        (void) hi;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.selectPiece", "Cannot access descriptor");
        }
        m = findCrackMap(*bid);

        b->batRestricted = BAT_READ;
        view = VIEWcreate_(b, TRUE);
        *vid = view->batCacheid;

@-
Select an interval with a desirable value to start the gluing process
@c
        for (i = 0; i < crackMap[m].freepiece; i++)
                if (crackMap[m].pieces[i].kind == LEAF &&       /* NOT NEEDED */
                        ((crackMap[m].pieces[i].rng_min <= *(int *) low && *(int *) low <= crackMap[m].pieces[i].rng_max) || (crackMap[m].pieces[i].rng_min <= *(int *) high && *(int *) high <= crackMap[m].pieces[i].rng_max)
                        )) {
                        CRKsetBounds(b, view, m, i);
                        idxlow = crackMap[m].pieces[i].idx_first;
                        idxhgh = crackMap[m].pieces[i].idx_last;
#ifdef DEBUG_CRACKERS
                        printf("start glue: [%d][%d] "SZFMT" "SZFMT" \n", m, i, crackMap[m].pieces[i].idx_first, crackMap[m].pieces[i].idx_last);
#endif

                        break;
                }
        /* start glue cycle */
        if (idxlow >= 0)
                do {
                        glued = 0;
                        leftover = 0;
                        for (i = 0; i < crackMap[m].freepiece; i++)
                                if (crackMap[m].pieces[i].kind == LEAF &&       /* NOT NEEDED */
                                        crackMap[m].pieces[i].rng_min >= *(int *) low &&
                                        crackMap[m].pieces[i].rng_max <= *(int *) high) {
/* no little speedup, discarded
                        if( crackMap[m].pieces[i].idx_first < idxlow &&
                                crackMap[m].pieces[i].idx_last > idxhgh){
                                VIEWbounds(view,
                                        idxlow= crackMap[m].pieces[i].idx_first,
                                        idxhgh=crackMap[m].pieces[i].idx_last);
                                glued++;

                        } else
*/
                                        if (crackMap[m].pieces[i].idx_last == idxlow - 1) {
#ifdef DEBUG_CRACKERS
                                                printf("lglue: [%d][%d] "SZFMT"  %d\n", m, i, crackMap[m].pieces[i].idx_first, idxhgh);
#endif
                                                VIEWbounds(view, idxlow = crackMap[m].pieces[i].idx_first, idxhgh);
                                                glued++;
                                        } else if (crackMap[m].pieces[i].idx_first == idxhgh + 1) {
#ifdef DEBUG_CRACKERS
                                                printf("rglue: [%d][%d]%d "SZFMT" \n", m, i, idxlow, crackMap[m].pieces[i].idx_last);
#endif
                                                VIEWbounds(view, idxlow, idxhgh = crackMap[m].pieces[i].idx_last);
                                                glued++;
                                        } else if (crackMap[m].pieces[i].idx_first > idxhgh || crackMap[m].pieces[i].idx_last < idxlow)
                                                leftover++;

                                }
#ifdef DEBUG_CRACKERS
                        printf("glued %d leftover %d\n", glued, leftover);
#endif
                } while (leftover);
        BBPunfix(b->batCacheid);
        return MAL_SUCCEED;
}

@-
A common operation is to find all the pieces that
overlap with a range. It can be used for subsequent
iteration and flow-based processing.
@c
str
CRKselectPieces(int *result, int *bid, int *low, int *hgh)
{
	BAT *b;
	int m, i;
	oid o = oid_nil;

	m = findCrackMap(*bid);
	if (m < 0)
		return throwMessage("crackers.select", "Map non-existent");
	b = BATnew(TYPE_void, TYPE_int, 0);
	if (b == 0)
		return throwMessage("crackers.select", "failed to create BAT");
	for (i = 0; i < crackMap[m].freepiece; i++)
		if (crackMap[m].pieces[i].kind == LEAF) {
			if (crackMap[m].pieces[i].rng_max < *low)
				continue;
			if (crackMap[m].pieces[i].rng_min > *hgh)
				continue;
			BUNins(b, &o, &i);
		}
	BBPincref(*result = b->batCacheid, TRUE);
	return MAL_SUCCEED;
}
@-
Temporary templates for the "new cracking competition".
For the time being, we ignore the cracking administration and repeated
cracking, and focus on cracking a complete BAT, returning the cracked BAT.
@
@-
Martin Kersten

The code base is prepared to run with different types.
@-
Create a 3- and 5-way cracking of the BAT. Updates of the cracker index
is left along for a while. We don't return anything right now.
Cracking is inplace!
The piece cracking routines are parameterized with a closed bun index
interval.
@
@-
The three way split use knowledge on the type size to issue
the exchanges. Moreover, we should be prepared to handle
a cracking over a mirrored bat.
We support only fixed size buns and rely on the compiler
to arrange proper structs. More advanced schemes, or slower
stepwise ones, are for the future.

The 'struct SCRATCH{ oid hdummy; @1 tdummy; } dummy;' approach
did not produce a noticable difference on the machine at hand.
The generic solution avoids possible compiler alignment issues.

@= shuffleMK
	tdummy= *(@1*) @2;
	*(@1*) @2= *(@1*) @3;
	*(@1*) @3= tdummy;

	hdummy= *(oid*)((char*)@2 - b->tloc);
	*(oid*)((char*)@2 - b->tloc) = *(oid*)((char*)@3 - b->tloc);
	*(oid*)((char*)@3 - b->tloc) = hdummy;

@= MK_operations
str
CRKpieceZero_MK_@1( BAT *b, @1 mval, size_t first, size_t last){
	ptr vm, vl;
	int xx;
	oid hdummy;
	@1 tdummy;

	/* set bounds for the iterator */
	xx = BUNsize(b);

	vm = BUNtloc(b, BUNptr(b,first));
	vl= BUNtloc(b,BUNptr(b,last));

	while(vm<vl) {
		if (*(@1 *) vm <= mval)
			vm = (ptr) ((char *) vm + xx);
		else {
			while( *(@1 *) vl > mval && vl>vm)
				vl = (ptr) ((char *) vl - xx);
			@:shuffleMK(@1,vm,vl)@
			vl = (ptr) ((char *) vl - xx);
			vm = (ptr) ((char *) vm + xx);
		} 
	} 
#ifdef MK_DEBUG
	printf("cracked index %d\n", (int) BUNindex(b,(ptr) ((char*)vm - b->tloc)));
#endif
	return MAL_SUCCEED;
}

str
CRKcrackZero_MK_@1 (int *res, int *bid, @1 *mid)
{
	BAT *b;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) 
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");

	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg=CRKpieceZero_MK_@1( b, *mid,(size_t) 0, BATcount(b)-1);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

str
CRKOrderedpieceOne_MK_@1( BAT *b, const @1 mval, size_t first, size_t last, size_t *start, size_t *end){
	char *tc, *hc, *tv, *hv;
	char *tp, *hp, *tq, *hq;
	const int xx= BUNsize(b);
	int i,j,k,l,n;
	oid *hdummy, *hequal;
	@1  *tdummy, *tequal;
	
	/* set bounds for the two-way iterator */
	tc = BUNtloc(b, BUNptr(b,first));
	tp = BUNtloc(b, BUNptr(b,last));

	/* set the bounds for the scratch areas */
	hdummy= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
	tdummy= (ptr) GDKmalloc((last-first+1) *sizeof(@1));
	i= 0;
	j= last-first;
	hequal= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
	tequal= (ptr) GDKmalloc((last-first+1) *sizeof(@1));
	k= 0;
	l= last-first;

	/* ignore non-moveable bounds*/
	while( *(@1*)tc < mval && tc<=tp){
		i++;
		tc += xx; 
	}
	/* probe */
	hc= hv= tc;
	hv += (last-first)/50*xx;
	while(hc<hv){
		if( *(@1*)hc <= mval )
			i++;
		if( *(@1*)hc >= mval )
			k++;
		hc+= xx;
	}
	n= i>k;
/* printf("probe %d %d\n",i,k);*/

	tv=tc; hc= hv= tc-b->tloc;
	while( *(@1*)tp > mval && tp>=tc){
		k++;
		tp -= xx; 
	}
	tq=tp; hp= hq= tq-b->tloc;
/*printf("left %d right %d\n", i,k);*/
	i=0; k=0;
/* printf("i=%d j=%d\n",i,j);  BATprint(b);*/
	/* move elements out of the way */
	/* use Stratos's insight to move only upon need */
	/* first case is based on left kept in place */
	if(n){
		while( tc <= tp){
			/* skip to next candidate to move*/
			if( *(@1*)tc >= mval ){
				if( *(@1*) tc == mval){
					hequal[k]= *(oid*)hc;
					tequal[k]= *(@1*) tc;
					k++;
				} 
				tc += xx;  hc += xx;
				continue;
			}
			if( *(@1*) tv > mval){
					hdummy[i] = *(oid*)hv; 
					tdummy[i] = *(@1*)tv; 
					i++;
			}
			*(oid*)hv= *(oid*)hc;
			*(@1*)tv = *(@1*)tc;
			tv += xx; hv += xx;
			tc += xx; hc += xx;
		}
		/* squeeze the tail */
			tc -=xx;
		while(tc>= tv){
			if( *(@1*)tc> mval){
				*(oid*)(tq-b->tloc)= *(oid*)hc;
				*(@1*)tq= *(@1*)tc;
				tq -= xx; 
			}
			tc -= xx; hc -= xx;
		}
	/* printf("equals left=%d equals right=%d larger=%d\n",k,(int)(last-first-l),i); */
	/*BATprint(b);*/
		/* move left equals */
	/* printf("move left equals 0- %d\n",k-1);*/
		*start= BUNindex(b, hv);
		for(n=0;n<k;n++){
			*(oid*) hv = hequal[n]; hv += xx;
			*(@1*)  tv = tequal[n]; tv += xx;
		}
	/* BATprint(b); printf("move right equals %d-%d\n",l, (int) last- (int) first); */
		/* move right equals */
		for(l++, n=last-first; l<=n; l++){
			*(oid*) tv = hequal[l]; hv += xx;
			*(@1*)  tv = tequal[l]; tv += xx;
		}
		*end= BUNindex(b, tv);
			
	/*printf("equals done\n"); BATprint(b);*/
		/* move left surplus */
		for(n=0;n<i;n++){
			*(oid*) hv = hdummy[n]; hv += xx;
			*(@1*)  tv = tdummy[n]; tv += xx;
		}
	} else {
		/* reverse the process */
		tc= tp;
		hc= hp;
		while( tc >= tv){
			/* skip to next candidate to move*/
			if( *(@1*)tc <= mval ){
				if( *(@1*) tc == mval){
					hequal[l]= *(oid*)hc;
					tequal[l]= *(@1*) tc;
					l--;
				} 
				tc -= xx;  hc -= xx;
				continue;
			}
			if( *(@1*) tp < mval){
					hdummy[j] = *(oid*)hp; 
					tdummy[j] = *(@1*)tp; 
					j--;
			}
			*(oid*)hp= *(oid*)hc;
			*(@1*)tp = *(@1*)tc;
			tp -= xx; hp -= xx;
			tc -= xx; hc -= xx;
		}
		/* squeeze the head */
		tc +=xx;
		hv= tv-b->tloc;
		while(tc<= tp){
			if( *(@1*)tc< mval){
				*(oid*)hv= *(oid*)hc;
				*(@1*)tv= *(@1*)tc;
				tv += xx;  hv += xx;
			}
			tc += xx; hc += xx;
		}
	/* printf("equals left=%d equals right=%d larger=%d\n",k,(int)(last-first-l),i); */
	/*BATprint(b);*/
		*end= BUNindex(b, hp);
		/* move right equals */
		for(n=last-first; n>l; n--){
			*(oid*) hp = hequal[n]; hp -= xx;
			*(@1*)  tp = tequal[n]; tp -= xx;
		}
		*start= BUNindex(b, tp);
			
	/*printf("equals done\n"); BATprint(b);*/
		/* move left surplus */
		for(n=last-first;n>j;n--){
			*(oid*) hp = hdummy[n]; hp -= xx;
			*(@1*)  tp = tdummy[n]; tp -= xx;
		}
	}
/* printf("done\n"); BATprint(b);*/
	GDKfree(hdummy); GDKfree(tdummy);
	return MAL_SUCCEED;

}

str
CRKOrderedpieceThree_MK_@1( BAT *b, @1 low, @1 hgh, size_t first, size_t last, int *start, int *end){
	char *tc, *hc, *hv,*tv, *vtop;
	const int xx= BUNsize(b);
	oid *hdummy, *hd, *he;
	@1  *tdummy, *td, *te;
	int lt=0, mid= BATcount(b)/2, m2= mid/2;
	
	/* set bounds for the iterator */
	tc = BUNtloc(b, BUNptr(b,first));
	hc = BUNhloc(b, BUNptr(b,first));
	vtop= BUNtloc(b,BUNptr(b,mid));
	for(; tc< vtop && lt <m2; tc += xx)
		lt += *(@1*) tc <= low;

	if( last)
		return MAL_SUCCEED;
	/* move the smallest portion to the scratch area */
	if( lt >= mid/2 ){
		hd= hdummy= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
		td= tdummy= (ptr) GDKmalloc((last-first+1) *sizeof(@1));
		he= hdummy+last-first;
		te= tdummy+last-first;

		tc = BUNtloc(b, BUNptr(b,first));
		hc = BUNhloc(b, BUNptr(b,first));
		vtop= BUNtloc(b,BUNptr(b,last));
		while( *(@1*) vtop > hgh) vtop -= xx;

		hv= hc;
		tv= tc;

		for( ; tc<=vtop; tc += xx, hc += xx) {
			if (*(@1 *) tc <= hgh){
				if (*(@1 *) tc > low){
					*(oid*) he-- = *(oid*)hc; 
					*(@1*) te-- = *(@1*)tc; 
				} else {
					*(oid*) hv = *(oid*)hc; hv += xx;
					*(@1*) tv = *(@1*)tc;   tv += xx;
				}
			} else {
				 *hd++ = *(oid*)hc; 
				 *td++ = *(@1*)tc; 
			} 
		} 
		/* group the equals */
		vtop= (char *) he;
		he= hdummy+(last-first);
		te= tdummy+(last-first);
		for(; (ptr) he > (ptr) vtop;  te--, he--){
				 *(oid*) hv = *he; hv += xx;
				 *(@1*) tv = *te;  tv += xx;
		}
		
		/* group the remainder */
		*start= BUNindex(b, hv);
		*end= BUNindex(b, hv);
		/* collect rest */
		vtop= (char*) hd;
		td= tdummy;
		hd= hdummy;
		for( ; (ptr) hd < (ptr) vtop;  td ++,hd++){
				 *(oid*) hv = *hd; hv += xx;
				 *(@1*) tv = *td;  tv += xx;
		}
	} else {
		hd= hdummy= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
		td= tdummy= (ptr) GDKmalloc((last-first+1) *sizeof(@1));
		he= hdummy+last-first+1;
		te= tdummy+last-first+1;

/* printf("run back %d\n",lt);
BATprint(b);*/
		/* run backwards */
		tc = BUNtloc(b, BUNptr(b,last));
		hc = BUNhloc(b, BUNptr(b,last));
		vtop= BUNtloc(b,BUNptr(b,first));
		while( *(@1*) vtop <= low) vtop += xx;
		hv= hc;
		tv= tc;

		for( ; tc>=vtop; tc -= xx, hc -= xx) {
			if (*(@1 *) tc > low){
				if (*(@1 *) tc <= hgh){
					*(oid*) he-- = *(oid*)hc; 
					*(@1*) te-- = *(@1*)tc; 
				} else {
					*(oid*) hv = *(oid*)hc; hv -= xx;
					*(@1*) tv = *(@1*)tc;   tv -= xx;
				}
			} else {
				 *hd++ = *(oid*)hc; 
				 *td++ = *(@1*)tc; 
			} 
		} 
/* printf("group the equals\n"); BATprint(b);*/
		/* group the equals */
		vtop= (char *) he;
		he= hdummy+(last-first+1);
		te= tdummy+(last-first+1);

		for( ; (ptr) he > (ptr) vtop;  te--, he--){
				 *(oid*) hv = *he; hv -= xx;
				 *(@1*) tv = *te;  tv -= xx;
		}
/* BATprint(b);*/
		
		
		/* group the remainder */
		*start= BUNindex(b, hv);
		*end= BUNindex(b, hv);
		/* collect rest */
		vtop= (char*) hd;
		td= tdummy;
		hd= hdummy;
		for(; (ptr) hd < (ptr) vtop;  td++,hd++){
				 *(oid*) hv = *hd; hv -= xx;
				 *(@1*) tv = *td;  tv -= xx;
		}
	}
	GDKfree(hdummy); GDKfree(tdummy);
	return MAL_SUCCEED;
}

str
CRKOrderedpieceZero_MK_@1( BAT *b, @1 mval, size_t first, size_t last, size_t *start, size_t *end){
	char *tc, *hc, *hv,*tv, *vtop;
	const int xx= BUNsize(b);
	oid *hdummy, *hd;
	@1  *tdummy, *td;
	int i=0,k=0,n;
	
	/* set bounds for the iterator */
	tc = BUNtloc(b, BUNptr(b,first));
	/* probe */
	hc= hv= tc;
	hv += (last-first)/50*xx;
	while(hc<hv){
		if( *(@1*)hc <= mval )
			i++;
		if( *(@1*)hc >= mval )
			k++;
		hc+= xx;
	}
	n= i>k;

	/* move the smallest portion to the scratch area */
	if( n){
		hd= hdummy= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
		td= tdummy= (ptr) GDKmalloc((last-first+1) *sizeof(@1));

		tc = BUNtloc(b, BUNptr(b,first));
		hc = BUNhloc(b, BUNptr(b,first));
		vtop= BUNtloc(b,BUNptr(b,last));
		while( *(@1*) vtop > mval) vtop -= xx;

		hv= hc;
		tv= tc;

		for( ; tc<=vtop; tc += xx, hc += xx) {
			if (*(@1 *) tc <= mval){
				 *(oid*) hv = *(oid*)hc; hv += xx;
				 *(@1*) tv = *(@1*)tc;   tv += xx;
			} else {
				 *hd++ = *(oid*)hc; 
				 *td++ = *(@1*)tc; 
			} 
		} 
		
		/* group the remainder */
		*start= BUNindex(b, hv);
		*end= BUNindex(b, hv);
		/* collect rest */
		vtop= (char*) hd;
		td= tdummy;
		hd= hdummy;
		for( ; (ptr) hd < (ptr) vtop;  td ++,hd++){
				 *(oid*) hv = *hd; hv += xx;
				 *(@1*) tv = *td;  tv += xx;
		}
	} else {
		hd= hdummy= (ptr) GDKmalloc((last-first+1) *sizeof(oid));
		td= tdummy= (ptr) GDKmalloc((last-first+1) *sizeof(@1));

		/* run backwards */
		tc = BUNtloc(b, BUNptr(b,last));
		hc = BUNhloc(b, BUNptr(b,last));
		vtop= BUNtloc(b,BUNptr(b,first));
		while( *(@1*) vtop <= mval) vtop += xx;
		hv= hc;
		tv= tc;

		for( ; tc>=vtop; tc -= xx, hc -= xx) {
			if (*(@1 *) tc > mval){
				 *(oid*) hv = *(oid*)hc; hv -= xx;
				 *(@1*) tv = *(@1*)tc;   tv -= xx;
			} else {
				 *hd++ = *(oid*)hc; 
				 *td++ = *(@1*)tc; 
			} 
		} 
		
		/* group the remainder */
		*start= BUNindex(b, hv);
		*end= BUNindex(b, hv);
		/* collect rest */
		vtop= (char*) hd;
		td= tdummy;
		hd= hdummy;
		for(; (ptr) hd < (ptr) vtop;  td++,hd++){
				 *(oid*) hv = *hd; hv -= xx;
				 *(@1*) tv = *td;  tv -= xx;
		}
	}
	GDKfree(hdummy); GDKfree(tdummy);
	return MAL_SUCCEED;
}
str
CRKcrackOrderedOne_MK_@1 (int *res, size_t *bid, size_t *mid)
{
	BAT *b;
	str msg;
	size_t start, size;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKOrderedpieceOne_MK_@1( b, *mid, 0, BATcount(b)-1, &start, &size);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
str
CRKcrackOrderedTwo_MK_@1 (int *res, size_t *bid, size_t *mid)
{
	BAT *b;
	str msg= MAL_SUCCEED;
	size_t start, size;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	(void) start; (void) size;
	(void) mid;
/*
	msg= CRKOrderedpieceOne_MK_@1( b, *mid, 0, BATcount(b)-1, &start, &size);
*/

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
str
CRKcrackOrderedThree_MK_@1 (int *res, size_t *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg= MAL_SUCCEED;
	int start, size;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKOrderedpieceThree_MK_@1( b, *low, *hgh, 0, BATcount(b)-1, &start, &size);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
str
CRKcrackOrderedZero_MK_@1 (int *res, size_t *bid, size_t *mid)
{
	BAT *b;
	str msg= MAL_SUCCEED;
	size_t start, size;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKOrderedpieceZero_MK_@1( b, *mid, 0, BATcount(b)-1, &start, &size);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}


str
CRKpieceOneA_MK_@1( BAT *b, @1 mval, size_t first, size_t last, size_t *start, size_t *end){
	ptr vm, vl;
	int xx;
	oid hdummy;
	@1 tdummy;
	ptr *base,*bp;

	/* set bounds for the iterator */
	xx = BUNsize(b);
	bp=base = (ptr*) GDKmalloc((last-first+1)*sizeof(ptr));

	vm = BUNtloc(b, BUNptr(b,first));
	vl = BUNtloc(b, BUNptr(b,last));

	while(vl>vm && *(@1 *) vl > mval )
		vl = (ptr) ((char *) vl - xx);
	/* perform Zero crack first */
	while(vm <= vl) {
		if (*(@1 *) vm <= mval){
			if (*(@1 *) vm == mval )
				*bp++ =vm;
			vm = (ptr) ((char *) vm + xx);
		} else {
			@:shuffleMK(@1,vm,vl)@
			vl = (ptr) ((char *) vl - xx);
			while(vl>vm && *(@1 *) vl > mval )
				vl = (ptr) ((char *) vl - xx);
		} 
	} 

/* printf("vl %u vm %d \n",(int)BUNindex(b,(ptr)((char*)vl-b->tloc)), (int) BUNindex(b,(ptr)((char*)vm-b->tloc)));
	BATprint(b); */
	vm = BUNtloc(b, BUNptr(b,first));
	while(vl>vm && *(@1*)vl == mval )
		vl= (ptr) ((char*) vl-xx);

	/* get the equals from the scratch*/
	*end= BUNindex(b,(ptr) ((char *) vl - b->tloc));
	while(bp > base){
		bp--;
		vm= *bp;
		if( vm < vl){
			@:shuffleMK(@1,vm,vl)@
			vl = (ptr) ((char *) vl - xx);
		}
	}

/* printf("vl %u vm %d\n",(int)BUNindex(b,(ptr)((char*)vl-b->tloc)), (int) BUNindex(b,(ptr)((char*)vm-b->tloc))); */
	/* BATprint(b);*/
	*start= BUNindex(b,(ptr) ((char *) vl - b->tloc)) +1;
	GDKfree(base);
	return MAL_SUCCEED;
}

str
CRKcrackOne_MK_@1 (int *res, size_t *bid, size_t *mid)
{
	BAT *b;
	str msg;
	size_t start, size;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	}
	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKpieceOneA_MK_@1( b, *mid, 0, BATcount(b)-1, &start, &size);
/*
	printf("range %d - %d\n",start,size);
*/

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

/* assume that the [first,last] are inclusive bounds */
str
CRKpieceTwo_MK_@1( BAT *b, @1 low, @1 hgh, int first, int last){
	ptr vm, vl, vmin, hmax, base= 0;
	int xx;
	oid hdummy;
	@1 tdummy;

	/* set bounds for the iterator */
	xx = BUNsize(b);

	vm = BUNtloc(b, BUNptr(b,first));
	hmax = BUNtloc(b,BUNptr(b,last));
	while( *(@1 *) hmax > hgh && hmax>vm)
		hmax= (ptr)((char*) hmax - xx);
	vl =hmax;
	while( *(@1 *) vl > low && vl>vm){
		/* move all high values into their final place */
		if( *(@1 *) vl > hgh){
			tdummy= *(@1*)vl;
			*(@1*)vl= *(@1*)hmax;
			*(@1*)hmax= tdummy;

			hdummy= *(oid*)((char*)vl - b->tloc);
			*(oid*)((char*)vl - b->tloc) = *(oid*)((char*)hmax - b->tloc);
			*(oid*)((char*)hmax - b->tloc) = hdummy;
			hmax= (ptr)((char*) hmax - xx);
		}
		vl= (ptr)((char*) vl - xx);
	}
	/* vl point to the first <=low, all values >hg are beyond hmax */

	/* perform Zero crack first */
	while(vm<=vl) {
		if (*(@1 *) vm <= low){
			if (*(@1 *) vm == low)
				base =vm;
			vm = (ptr) ((char *) vm + xx);
		} else {
			@:shuffleMK(@1,vm,vl)@
			while( *(@1 *) vl > low && vl>vm){
				if( *(@1*) vl > hgh ){
					@:shuffleMK(@1,vl,hmax)@
					hmax= (ptr)((char*) hmax - xx);
				}
				vl = (ptr) ((char *) vl - xx);
			}
		} 
	} 

	/* reshuffle left part using same algorithm */
	if( base)
		vm = base;
	else vm = vl;
	base = BUNtloc(b, BUNptr(b,first));
	while(vm >= base) {
		if (*(@1 *) vm == low){
			@:shuffleMK(@1,vm,vl)@
			do {
				vl = (ptr) ((char *) vl - xx);
			} while( *(@1 *) vl == low && vl>vm);
		} 
		vm = (ptr) ((char *) vm - xx);
	}
	vmin= vl;

	/* perform the same operation on low<V< infinite */
	vm = hmax;
	vl= hmax;
	hmax= (ptr)((char*) hmax + xx);

	/* reshuffle low<V<=hgh  part */
	while(vm >= vmin) {
		if (*(@1 *) vm == hgh){
			@:shuffleMK(@1,vm,vl)@
			vl = (ptr) ((char *) vl - xx);
		} 
		vm = (ptr) ((char *) vm - xx);
	}
#ifdef MK_DEBUG
	printf("indices %d %d %d %d\n",(int) BUNindex(b,lmin)+1, (int) BUNindex(b,lmax),
		(int) BUNindex(b,vl)+1, (int) BUNindex(b,hmax));
#endif
	return MAL_SUCCEED;
}
str
CRKpieceTwoA_MK_@1( BAT *b, @1 low, @1 hgh, int first, int last){
	ptr vm, vl, vmin, vmax;
	ptr *base, *bf, *bl;
	int xx;
	oid hdummy;
	@1 tdummy;
	size_t start,end;

	if( low == hgh )
		return CRKpieceOneA_MK_@1(b,low,first,last, &start, &end);

	/* set bounds for the iterator */
	xx = BUNsize(b);
	bf= base = (ptr*) GDKmalloc((last-first+1)*sizeof(ptr));
	bl= base+last-first;

	vm= vmin = BUNtloc(b, BUNptr(b,first));
	vl= vmax = BUNtloc(b, BUNptr(b,last));
	while( *(@1 *) vmax >= hgh && vmax>=vmin){
		if( *(@1*) vmax == hgh)
			*bl-- = vmax;
		vmax= (ptr)((char*) vmax - xx);
	}
	while( *(@1 *) vmin <= low && vmax>=vmin){
		if( *(@1*) vmin == low)
			*bf++ = vmin;
		vmin= (ptr)((char*) vmin + xx);
	}

	/* now a one-way scan to swap elements */
	vm = vmin; 
	
	while( vm <= vmax){
		/* move all high values into their final place */
		if( *(@1 *) vm>= hgh){
			tdummy =  *(@1*)vm;
			*(@1*)vm= *(@1*)vmax;
			*(@1*)vmax= tdummy;

			hdummy= *(oid*)((char*)vm - b->tloc);
			*(oid*)((char*)vm - b->tloc) = *(oid*)((char*)vmax - b->tloc);
			*(oid*)((char*)vmax - b->tloc) = hdummy;
			if( *(@1*) vmax == hgh)
				*bl-- = vmax;
			vmax= (ptr)((char*) vmax - xx);
		} else
		if( *(@1 *) vm<= low){
			tdummy =  *(@1*)vm;
			*(@1*)vm= *(@1*)vmin;
			*(@1*)vmin= tdummy;

			hdummy= *(oid*)((char*)vm - b->tloc);
			*(oid*)((char*)vm - b->tloc) = *(oid*)((char*)vmin - b->tloc);
			*(oid*)((char*)vmin - b->tloc) = hdummy;
			if( *(@1*) vmin == low)
				*bf++ = vmin;
			vmin= (ptr)((char*) vmin + xx);
			vm= (ptr)((char*) vm + xx);
		} else
			vm= (ptr)((char*) vm + xx);
	}

	/* and now move the equals into place */
	vmin= (ptr)((char*) vmin - xx);
	vmax= (ptr)((char*) vmax + xx);
	vl = base+last-first;

	for( bl++; bl<= (ptr*)vl; bl++)
	if( vmax < *bl ){
		@:shuffleMK(@1,vmax,(*bl))@
		vmax= (ptr)((char*) vmax + xx);
	}

	for( bf--; bf>=base; bf--)
	if( vmin > *bf ){
		@:shuffleMK(@1,vmin,*bf)@
		vmin= (ptr)((char*) vmin - xx);
	}
	/* BATprint(b);*/
#ifdef MK_DEBUG
	printf("indices %d %d %d %d\n",(int) BUNindex(b,lmin)+1, (int) BUNindex(b,lmax),
		(int) BUNindex(b,vl)+1, (int) BUNindex(b,hmax));
#endif
	return MAL_SUCCEED;
}

str
CRKcrackTwo_MK_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;

	if (*(@1 *) low > *(@1 *) hgh)
		return throwMessage("crackers.crack_MK", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL)
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	(void) *res;

	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKpieceTwoA_MK_@1( b, *low, *hgh, 0, BATcount(b)-1);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

/* case: <=low, <=hgh, >hgh */
str
CRKpieceThree_MK_@1( BAT *b, @1 low, @1 hgh, int first, int last){
	ptr vm, vl, hmax;
	int xx;
	oid hdummy;
	@1 tdummy;

	/* set bounds for the iterator */
	xx = BUNsize(b);

	vm = BUNtloc(b, BUNptr(b,first));
	hmax = BUNtloc(b,BUNptr(b,last));
	while( *(@1 *) hmax > hgh && hmax>vm)
		hmax= (ptr)((char*) hmax - xx);
	vl =hmax;
	while( *(@1 *) vl > low && vl>vm){
		/* move all high values into their final place */
		if( *(@1 *) vl > hgh){
			@:shuffleMK(@1,vl,hmax)@
			hmax= (ptr)((char*) hmax - xx);
		}
		vl= (ptr)((char*) vl - xx);
	}
	/* vl point to the first <=low, all values >hg are beyond hmax */

	/* perform Zero crack first */
	while(vm<=vl) {
		if (*(@1 *) vm <= low){
			vm = (ptr) ((char *) vm + xx);
		} else {
			@:shuffleMK(@1,vm,vl)@
			while( *(@1 *) vl > low && vl>vm){
				if( *(@1*) vl > hgh ){
					@:shuffleMK(@1,vl,hmax)@
					hmax= (ptr)((char*) hmax - xx);
				}
				vl = (ptr) ((char *) vl - xx);
			}
		} 
	} 

	return MAL_SUCCEED;
}
/* handle <=low, low<tail<=hgh, >hgh */
str
CRKcrackThree_MK_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;

	if (*(@1 *) low > *(@1 *) hgh)
		return throwMessage("crackers.crack_MK", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL)
		return throwMessage("crackers.crack_MK", "Cannot access descriptor");
	(void) *res;

	/* set bounds for the iterator */
	if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
		return throwMessage("crackers.crack_MK", "Need more clever mapping ");

	msg= CRKpieceThree_MK_@1( b, *low, *hgh, 0, BATcount(b)-1);


	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}


@


@= SMsm_piece_
@:SMsm_piece_Zero@4(@1,@2,@3,@4)@
@:SMsm_piece_One@4(@1,@2,@3,@4)@
@:SMsm_piece_Two(@1,@2,@3,@4)@
@:SMsm_piece_Three@4(@1,@2,@3,@4)@
@
@= SMsm_crack_
@:SMsm_crack_ZeroOne(@1,@2,Zero,z,@3)@
@:SMsm_crack_ZeroOne(@1,@2,One,,@3)@
@:SMsm_crack_TwoThree(@1,@2,Two,,@3)@
@:SMsm_crack_TwoThree(@1,@2,Three,z,@3)@
@
@= SMsm_operations
@:SMsm_split_in_two(@1,@2,@3,LT,GE,,l,)@
@:SMsm_split_in_two(@1,@2,@3,LE,GT,,g,)@
@:SMsm_split_in_two(@1,@2,@3,LT,GE,EQ,l,*_eq = eq;)@
@:SMsm_split_in_two(@1,@2,@3,LE,GT,EQ,g,*_eq = eq;)@
@:SMsm_piece_(@1,@2,@3,)@
@:SMsm_piece_(@1,@2,@3,Ordered)@
@:SMsm_crack_(@1,@2,)@
@:SMsm_crack_(@1,@2,Ordered)@
@
@c
#define LT	<
#define LE	<=
#define GE	>=
#define GT	>
#define BUNho(b)
#define TAILho(b)	int ho = b->hloc - b->tloc
#define TAILhloc(b,p)	((p) + ho)
#define TAILtloc(b,p)	(p)
#define TAILindex(b,p)	BUNindex(b, (p) - b->tloc)
#define TAILptr(b,i)	BUNtloc(b, BUNptr(b, i))
#define SIG_(x,y,z)
#define SIG_EQ(x,y,z)	x,y,z
#define IF_LT_(x)
#define IF_LE_(x)
#define IF_GE_(x)
#define IF_GT_(x)
#define IF_LT_EQ(x)
#define IF_LE_EQ(x)	x
#define IF_GE_EQ(x)	x
#define IF_GT_EQ(x)
@

@= SMsm_swapTwoBUNs
{
	oid *h1 = (oid*)@2;
	@1  *t1 = (@1 *)@3;
	oid *h2 = (oid*)@4;
	@1  *t2 = (@1 *)@5;
	oid h   = *h1;
	@1  t   = *t1;
	*h1     = *h2;
	*t1     = *t2;
	*h2     = h;
	*t2     = t;
}
@

@= SMsm_split_in_two_advance
	/* advance cursors, skipping over BUNs that are already in the right place */
	while (@6 *(@1*)@2tloc(b, bn_l) @3 mid) {
		IF_@3_@5(if (*(@1*)@2tloc(b, bn_l) == mid) { *eq++ = bn_l; })
		bn_l += bs;
	}
	while (@6 *(@1*)@2tloc(b, bn_g) @4 mid) {
		IF_@4_@5(if (*(@1*)@2tloc(b, bn_g) == mid) { *eq++ = bn_g; })
		bn_g -= bs;
	}
@
@= SMsm_split_in_two
static str
CRKsplit_@2_@1_@4_@5_@6 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lg  SIG_@6(, BUN *eq, BUN **_eq))
{
	/* initialization */
	@3ho(b);
	int bs = BUNsize(b);
	BUN bn_l = @3ptr(b, fst);
	BUN bn_g = @3ptr(b, lst);

	/* advance cursors, skipping over BUNs that are already in the right place */
	@:SMsm_split_in_two_advance(@1,@3,@4,@5,@6,bn_l <= bn_g &&)@

	/* re-shuffel BUNs */
	while (bn_l < bn_g) {
		/* swap BUNs */
		@:SMsm_swapTwoBUNs(@1,@3hloc(b, bn_g),@3tloc(b, bn_g),@3hloc(b, bn_l),@3tloc(b, bn_l))@
		
		/* advance cursors, skipping over BUNs that are already in the right place */
		@:SMsm_split_in_two_advance(@1,@3,@4,@5,@6,)@
	}
	*lg = @3index(b, bn_@7);
	@8

	/* final sanity check */
	assert(bn_l >= bn_g);
	return MAL_SUCCEED;
}
@

@= SMsm_piece_Zero
static str
CRKpiece@4Zero_@2_@1 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lt, size_t *gt)
{
	*lt=0;
	return CRKsplit_@2_@1_LE_GT_ (b, mid, fst, lst, gt);
}
@

@= SMsm_piece_OneTwo_EQ
	bn = @2ptr(b, @3);
	while (eq-- > equal) {
		if (*eq != bn) {
			@:SMsm_swapTwoBUNs(@1,@2hloc(b, bn),@2tloc(b, bn),@2hloc(b, *eq),@2tloc(b, *eq))@
		}
		bn @5 bs;
	}
	@4 = @2index(b, bn);
@
@= SMsm_piece_One
static str
CRKpiece@4One_@2_@1 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lt, size_t *gt)
{
	str msg;
	@3ho(b);
	int bs = BUNsize(b);
	BUN bn, *eq, *equal = (BUN*)GDKmalloc(((lst-fst)+1)*sizeof(BUN));

	if (!equal) {
		return throwMessage("CRKpiece@4One_@2_@1","GDKmalloc failed");
	}
	msg = CRKsplit_@2_@1_LT_GE_EQ (b, mid, fst, lst, lt, equal, &eq);
	if (msg != MAL_SUCCEED) {
		return msg;
	}
	@:SMsm_piece_OneTwo_EQ(@1,@3,*lt,*gt,+=)@

	GDKfree(equal);
	return msg;
}
@

@= SMsm_piece_TwoThree_skip
	/* advance cursors, skipping over BUNs that are already in the right place */
	/* initialization */
	BUN bn_l = @2ptr(b, fst);
	BUN bn_g = @2ptr(b, lst);
	while (bn_l < bn_g && *(@1*)@2tloc(b, bn_l) @3 low) {
		bn_l += bs;
	}
	while (bn_l < bn_g && *(@1*)@2tloc(b, bn_g) @4 hgh) {
		bn_g -= bs;
	}
	fst = @2index(b, bn_l);
	lst = @2index(b, bn_g);
@

@= SMsm_piece_Two
static str
CRKpiece@4Two_@2_@1 (BAT *b, @1 low, @1 hgh, size_t fst, size_t lst, size_t *ltl, size_t *gtl, size_t *lth, size_t *gth)
{
	str msg;
	@3ho(b);
	int bs = BUNsize(b);
	BUN bn, *eq, *equal;

	@:SMsm_piece_TwoThree_skip(@1,@3,<,>)@

	equal = (BUN*)GDKmalloc(((lst-fst)+1)*sizeof(BUN));

	if (!equal) {
		return throwMessage("CRKpiece@4Two_@2_@1","GDKmalloc failed");
	}
	msg = CRKsplit_@2_@1_LT_GE_EQ (b, low, fst, lst, ltl, equal, &eq);
	if (msg != MAL_SUCCEED) {
		return msg;
	}
	@:SMsm_piece_OneTwo_EQ(@1,@3,*ltl,*gtl,+=)@
	msg = CRKsplit_@2_@1_LT_GE_EQ (b, hgh, *gtl, lst, lth, equal, &eq);
	if (msg != MAL_SUCCEED) {
		return msg;
	}
	@:SMsm_piece_OneTwo_EQ(@1,@3,*lth,*gth,+=)@

	GDKfree(equal);
	return msg;
}
@

@= SMsm_piece_Three
static str
CRKpiece@4Three_@2_@1 (BAT *b, @1 low, @1 hgh, size_t fst, size_t lst, size_t *ltl, size_t *gtl, size_t *lth, size_t *gth)
{
	str msg;
	int bs = BUNsize(b);

	@:SMsm_piece_TwoThree_skip(@1,@3,<=,>)@

	*ltl=0;
	msg = CRKsplit_@2_@1_LE_GT_ (b, low, fst, lst, gtl);
	if (msg != MAL_SUCCEED) {
		return msg;
	}
	*lth=0;
	return CRKsplit_@2_@1_LE_GT_ (b, hgh, *gtl, lst, gth);
}
@

@= SMsm_piece_ZeroOrdered
static str
CRKpiece@4Zero_@2_@1 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lt, size_t *gt)
{
	@3ho(b);
	int bs = BUNsize(b);
	BUN r = @3ptr(b, fst);
	BUN w = @3ptr(b, fst);
	BUN q = @3ptr(b, lst);
	size_t n = (lst - fst) + 1, GTm_i = 0;
	oid *buf_h;
	@1  *buf_t;

	buf_h = (oid*) GDKmalloc(n * sizeof(oid));
	buf_t = (@1 *) GDKmalloc(n * sizeof(@1 ));
	for (;r <= q; r += bs) {
		if (*(@1*)@3tloc(b, r) <= mid) {
			*(oid*)@3hloc(b, w) = *(oid*)@3hloc(b, r);
			*(@1 *)@3tloc(b, w) = *(@1 *)@3tloc(b, r);
			w += bs;
		}
		if (*(@1*)@3tloc(b, r) > mid) {
			buf_h[GTm_i] = *(oid*)@3hloc(b, r);
			buf_t[GTm_i] = *(@1 *)@3tloc(b, r);
			GTm_i++;
		}
	}
	for (n = 0; n < GTm_i; n++, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	*lt = 0;
	*gt = lst + GTm_i;

	GDKfree(buf_h);
	GDKfree(buf_t);
	return MAL_SUCCEED;
}
@

@= SMsm_piece_OneOrdered
static str
CRKpiece@4One_@2_@1 (BAT *b, @1 mid, size_t fst, size_t lst, size_t *lt, size_t *gt)
{
	@3ho(b);
	int bs = BUNsize(b);
	BUN r = @3ptr(b, fst);
	BUN w = @3ptr(b, fst);
	BUN q = @3ptr(b, lst);
	size_t n = (lst - fst) + 1, EQm_i = n, GTm_i = 0;
	oid *buf_h;
	@1  *buf_t;

	buf_h = (oid*) GDKmalloc(n * sizeof(oid));
	buf_t = (@1 *) GDKmalloc(n * sizeof(@1 ));
	for (;r <= q; r += bs) {
		if (*(@1*)@3tloc(b, r) < mid) {
			*(oid*)@3hloc(b, w) = *(oid*)@3hloc(b, r);
			*(@1 *)@3tloc(b, w) = *(@1 *)@3tloc(b, r);
			w += bs;
		}
		if (*(@1*)@3tloc(b, r) == mid) {
			EQm_i--;
			buf_h[EQm_i] = *(oid*)@3hloc(b, r);
			buf_t[EQm_i] = *(@1 *)@3tloc(b, r);
		}
		if (*(@1*)@3tloc(b, r) > mid) {
			buf_h[GTm_i] = *(oid*)@3hloc(b, r);
			buf_t[GTm_i] = *(@1 *)@3tloc(b, r);
			GTm_i++;
		}
	}
	for (n--; n >= EQm_i; n--, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	for (n = 0; n < GTm_i; n++, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	*gt = lst - GTm_i;
	*lt = *gt - EQm_i + 1;

	GDKfree(buf_h);
	GDKfree(buf_t);
	return MAL_SUCCEED;
}
@

@= SMsm_piece_ThreeOrdered
static str
CRKpiece@4Three_@2_@1 (BAT *b, @1 low, @1 hgh, size_t fst, size_t lst, size_t *ltl, size_t *gtl, size_t *lth, size_t *gth)
{
	@3ho(b);
	int bs = BUNsize(b);
	BUN r = @3ptr(b, fst);
	BUN w = @3ptr(b, fst);
	BUN q = @3ptr(b, lst);
	size_t n = (lst - fst) + 1, LEh_i = n, GTh_i = 0;
	oid *buf_h;
	@1  *buf_t;

	buf_h = (oid*) GDKmalloc(n * sizeof(oid));
	buf_t = (@1 *) GDKmalloc(n * sizeof(@1 ));
	for (;r <= q; r += bs) {
		if (*(@1*)@3tloc(b, r) <= low) {
			*(oid*)@3hloc(b, w) = *(oid*)@3hloc(b, r);
			*(@1 *)@3tloc(b, w) = *(@1 *)@3tloc(b, r);
			w += bs;
		} else
		if (*(@1*)@3tloc(b, r) <= hgh) {
			LEh_i--;
			buf_h[LEh_i] = *(oid*)@3hloc(b, r);
			buf_t[LEh_i] = *(@1 *)@3tloc(b, r);
		}
		if (*(@1*)@3tloc(b, r) > hgh) {
			buf_h[GTh_i] = *(oid*)@3hloc(b, r);
			buf_t[GTh_i] = *(@1 *)@3tloc(b, r);
			GTh_i++;
		}
	}
	for (n--; n >= LEh_i; n--, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	for (n = 0; n < GTh_i; n++, w += bs) {
		*(oid*)@3hloc(b, w) = buf_h[n];
		*(@1 *)@3tloc(b, w) = buf_t[n];
	}
	*ltl = 0;
	*lth = 0;
	*gth = lst - GTh_i;
	*gtl = *gth - LEh_i + 1;

	GDKfree(buf_h);
	GDKfree(buf_t);
	return MAL_SUCCEED;
}
@

@= SMsm_crack_ZeroOne
str
CRKcrack@5@3_@2_@1 (int *res, int *bid, @1 *mid)
{
	BAT *b;
	str msg;
	size_t fst, lst, lt, gt;

	/* initialization */
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.@4crack@5_SM", "Cannot access descriptor");
	}
	fst = BUNindex(b, BUNfirst(b));
	lst = BUNindex(b, BUNlast (b)) - 1;

	msg = CRKpiece@5@3_@2_@1(b, *mid, fst, lst, &lt, &gt);
	(void)lt;
	(void)gt;

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
@

@= SMsm_crack_TwoThree
str
CRKcrack@5@3_@2_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;
	size_t fst, lst, ltl, gtl, lth, gth;

	/* initialization */
	if (*low > *hgh)
		return throwMessage("crackers.@4crack@5_SM", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.@4crack@5_SM", "Cannot access descriptor");
	}
	fst = BUNindex(b, BUNfirst(b));
	lst = BUNindex(b, BUNlast (b)) - 1;

	msg = CRKpiece@5@3_@2_@1(b, *low, *hgh, fst, lst, &ltl, &gtl, &lth, &gth);
	(void)ltl;
	(void)gtl;
	(void)lth;
	(void)gth;

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
@
Stratos's masterpiece
@= move
        while( @6 *(@1*)@2 @5 ){
                @3	
                @2 @4= xx;
                @7 @4= xx;
        }
@

@= exchangeTest
	(void) buf;
	hdummy= *(oid*) @4;
	tdummy= *(@1*) @2;
	*(oid*) @4 = *(oid*) @5;
	*(@1*) @2 = *(@1*) @3;
	*(oid*) @4= hdummy;
	*(@1*) @3= tdummy;
@= exchange2Test
        (void) buf;
        hdummy= *(oid*) @5;
        tdummy= *(@1*) @2;
        *(oid*) @5 = *(oid*) @7;
        *(@1*) @2 = *(@1*) @4;
        *(oid*) @7 = *(oid*) @6;
        *(@1*) @4 = *(@1*) @3;
        *(oid*) @6= hdummy;
        *(@1*) @3= tdummy;
@
@= incdecSI
	@1 @3=xx;
	@2 @3=xx;
@
@= crackInThreePiecesSI
str
CRKcrackONE_SI_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last)
{

	BUN vmax, nmin, vm, bls, bh;
	char buf[128];	  /* scratch space */
	BUN tmpTmax, tmpTmid, hl, hm, hh;
	@1 tmpVmax,tmpVmid;
	int xx = BUNsize(b);
	oid hdummy;
	@1 tdummy;

	/* Start a scan to reduce the size of the piece that 'requires' a prescan. 
	Walk from the first BUN as long as values are < low or > hgh and can be 
	exchanged with a value from the end of the BUN*/ 
	
	vmax = BUNptr(b, idx_last);
	tmpTmax =  BUNtloc(b, vmax);
	hh = BUNhloc(b, vmax);
	nmin = BUNptr(b, idx_first);
	vm = BUNtloc(b, nmin);
	hl = BUNhloc(b, nmin);
	for (; vm < tmpTmax; vm += xx, hl += xx) {
		if (*(@1*)vm @7 hgh){
			@:move(@1,tmpTmax,,-,@7hgh, tmpTmax > vm &&,hh)@
			if (tmpTmax!=vm && *(@1*)tmpTmax @4 low){
				@:exchangeTest(@1,vm,tmpTmax,hl,hh)@							
				@:incdecSI(tmpTmax,hh,-)@
			}	
			else break;
		}
		if (*(@1*)vm @5 low && *(@1*)vm @6 hgh)
			break; 
	}
	@:move(@1,tmpTmax,,-,@7hgh, tmpTmax > vm &&,hh)@
	/* Empty result*/
	if (tmpTmax == vm)
		 return MAL_SUCCEED;
	
	/* Scan the remaining piece to determine the position where after cracking the first BUN 
	with a tail value >=low and <=high will be located. This means we have to count the remaining
	BUN with value <low
	
	TODO check if removing the second check/pointer in the prescan pays off since in the last of Martin's
	checks in tstcrack more scans are second needed that do nothing*/
 
	int ibl = 0, ibh = 0;
	BUN v = vm;
	for (; v <= tmpTmax;  v += xx){
		ibl += *(int *) v @4 low;
		ibh += *(int *) v @6 hgh;
	}

	vmax = tmpTmax;
	
	tmpTmid =vm+ xx*ibl;
	hm = hl+xx*ibl;
	
	hh =hl+xx*ibh; 
	tmpTmax =vm+ xx*ibh;

	bls = tmpTmid;
	bh = tmpTmax;

	/* Now for each value that is >hgh if a middle value m occurs in vmax we can save a redudant exchange by seaching 
	in the middle partition. There middle values are ignored and  a high value is  exchanged with m. 
	Similarly when a middle value occurs */  			

	while(vm != bls){
		if (*(int *) vm @5 low && *(int *) vm @6 hgh) {
			
			while(1){
				@:move(@1,tmpTmid,,+, @5 low && *(@1*)tmpTmid @6  hgh, ,hm)@
				tmpVmid = *(@1*)tmpTmid;
				if (tmpVmid @4 low){
					@:exchangeTest(@1,tmpTmid,vm,hm,hl)@
					@:incdecSI(tmpTmid,hm,+)@
					break;
				}
				if (tmpVmid @7 hgh){
					@:move(@1,tmpTmax,,+,@7hgh, ,hh)@
					
					tmpVmax = *(@1*)tmpTmax;
					if (tmpVmax @5 low  && tmpVmax @6 hgh){
						@:exchangeTest(@1,tmpTmax,tmpTmid,hh,hm)@
						@:incdecSI(tmpTmax,hh,+)@
					}
					if (tmpVmax @4 low){
						@:exchange2Test(@1,vm,tmpTmid,tmpTmax,hl,hm,hh)@
						@:incdecSI(tmpTmid,hm,+)@
						@:incdecSI(tmpTmax,hh,+)@
						break;
					} 
				}
				@:incdecSI(tmpTmid,hm,+)@
			}       
		}  
		if (*(int *) vm @7 hgh) {
			while(1){
				@:move(@1,tmpTmax,,+,@7hgh, ,hh)@
				tmpVmax = *(@1*)tmpTmax;
				if (tmpVmax @4 low){
					@:exchangeTest(@1,tmpTmax,vm,hh,hl)@
					@:incdecSI(tmpTmax,hh,+)@
					break;
				}
				if (tmpVmax @5 low && tmpVmax @6  hgh){
					@:move(@1,tmpTmid,,+, @5 low && *(@1*)tmpTmid @6  hgh, ,hm)@
					tmpVmid = *(@1*)tmpTmid;
					if (tmpVmid @7 hgh){
						@:exchangeTest(@1,tmpTmid,tmpTmax,hm,hh)@
						@:incdecSI(tmpTmid,hm,+)@
					}
					if (tmpVmid @4 low){
						@:exchange2Test(@1,tmpTmax,tmpTmid,vm,hh,hm,hl)@
						@:incdecSI(tmpTmid,hm,+)@
						@:incdecSI(tmpTmax,hh,+)@
						break;
					}
				}
					@:incdecSI(tmpTmax,hh,+)@
			}
		}
                if (tmpTmid == bh )
               		goto finishLowHigh;

                if (tmpTmax > vmax)
                        goto finishLowMiddle;
		
		@:move(@1,vm,,+,@4low,vm < bls &&,hl)@
	}

	for (; tmpTmid < bh; tmpTmid += xx, hm +=xx) {
		if (*(int *) tmpTmid @7  hgh){
			@:move(@1,tmpTmax,,+,@7hgh,,hh)@
			@:exchangeTest(@1,tmpTmax,tmpTmid,hh,hm)@
			@:incdecSI(tmpTmax,hh,+)@
			if (tmpTmax > vmax) break;
		}
	}
	return MAL_SUCCEED;

finishLowHigh:;
	@:incdecSI(vm,hl,+)@

	for (; vm < bls; vm += xx, hl += xx) {
		if (*(int *) vm @7  hgh){
			@:move(@1,tmpTmax,,+,@7hgh,,hh)@
			@:exchangeTest(@1,tmpTmax,vm,hh,hl)@
			@:incdecSI(tmpTmax,hh,+)@
			if (tmpTmax > vmax) break;
		}
	}
	return MAL_SUCCEED;
	
finishLowMiddle:;
		
	@:incdecSI(vm,hl,+)@

	for (; vm < bls; vm += xx, hl += xx) {
		if (*(@1*)vm @5 low && *(@1*)vm @6  hgh){
              		@:move(@1,tmpTmid,,+, @5 low && *(@1*)tmpTmid @6  hgh,,hm)@
			@:exchangeTest(@1,vm,tmpTmid,hl,hm)@
			@:incdecSI(tmpTmid,hm,+)@
			if (bh == tmpTmid) break;
		}
	}
	return MAL_SUCCEED;
	
	
}
@
@= moveOrdered
	while (@1){
		@2 @4= xx;
		@3 @4= xx;
		@5
	}
@
@= rightOrderedZeroSplit

	tmph = lh;
	tmpt = lt;

	llh = fhh - xx;
	llt = fht - xx;

	fh = fht;
	while(tmpt < fh){
		if (*(@1*)fht @2 mid){
			scr_h[spl] = *(oid*)fhh;
			scr_t[spl] = *(@1* )fht;
			spl++;
		}
		else{
			scr_h[sph] = *(oid*)fhh;
			scr_t[sph] = *(@1* )fht;
			sph--;
		}
		*(oid*) fhh = *(oid*)tmph;
                *(@1* ) fht = *(@1 *)tmpt;

		fhh += xx;
		fht += xx;

		tmph += xx;
		tmpt += xx;
		while (*(@1*)tmpt @2 mid){
			*(oid*) lh = *(oid*)tmph;
			*(@1* ) lt = *(@1 *)tmpt;
			lh += xx;
			lt += xx;
			tmph += xx;
			tmpt += xx;
		}
	}

	tmph = hh;	
	tmpt = ht;
	while (tmpt >= fht){
		*(oid*)llh = *(oid*)tmph;
		*(@1 *)llt = *(@1 *)tmpt;

		llh -= xx;
		llt -= xx;

		tmph -= xx;
		tmpt -= xx;
		while (*(@1*)tmpt @3 mid && tmpt >= fht){
			*(oid*) hh = *(oid*)tmph;
			*(@1* ) ht = *(@1 *)tmpt;
			hh -= xx;
			ht -= xx;
			tmph -= xx;
			tmpt -= xx;
		}
	}
	int i = 0;
	for (;i < spl;i++){
		*(oid*)lh = scr_h[i];
		*(@1 *)lt = scr_t[i];
		lh += xx;
		lt += xx;
	}
	i = right_scr_size-1;
	for (;i > sph;i--){
		*(oid*)fhh = scr_h[i];
		*(@1 *)fht = scr_t[i];
		fhh += xx;
		fht += xx;
	}

@

@= leftOrderedZeroSplit

	tmph = hh;
	tmpt = ht;

	llh = fhh - xx;
	llt = fht - xx;

	fh = llt;
	while(tmpt > fh){
		if (*(@1*)llt @2 mid){
			scr_h[spl] = *(oid*)llh;
			scr_t[spl] = *(@1* )llt;
			spl++;
		}
		else{
			scr_h[sph] = *(oid*)llh;
			scr_t[sph] = *(@1* )llt;
			sph--;
		}
		*(oid*) llh = *(oid*)tmph;
                *(@1* ) llt = *(@1 *)tmpt;

		llh -= xx;
		llt -= xx;

		tmph -= xx;
		tmpt -= xx;
		while (*(@1*)tmpt @3 mid){
			*(oid*) hh = *(oid*)tmph;
			*(@1* ) ht = *(@1 *)tmpt;
			hh -= xx;
			ht -= xx;
			tmph -= xx;
			tmpt -= xx;
		}
	}

	tmph = lh;	
	tmpt = lt;
	while (tmpt <= llt){
		*(oid*)fhh = *(oid*)tmph;
		*(@1 *)fht = *(@1 *)tmpt;

		fhh += xx;
		fht += xx;

		tmph += xx;
		tmpt += xx;
		while (*(@1*)tmpt @2 mid && tmpt <= llt){
			*(oid*) lh = *(oid*)tmph;
			*(@1* ) lt = *(@1 *)tmpt;
			lh += xx;
			lt += xx;
			tmph += xx;
			tmpt += xx;
		}
	}
	int i = spl - 1;
	for (; i >= 0 ; i--){
		*(oid*)lh = scr_h[i];
		*(@1 *)lt = scr_t[i];
		lh += xx;
		lt += xx;
	}
	i = sph + 1;
	for (; i <= left_scr_size - 1; i++){
		*(oid*)fhh = scr_h[i];
		*(@1 *)fht = scr_t[i];
		fhh += xx;
		fht += xx;
	}
@
@= crackInThreeOrderedPiecesII
str
CRKcrackOrderedTHREE_is_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last)
{
	BUN lh, lt, hh, ht, fhh, fht, tmpt, tmph;/* fh, llh, llt;*/
	oid *scr_h;
	@1  *scr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @4 low,lh,lt,+,lowShrinked++;)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	tmph = fhh = lh;
	tmpt = fht = lt;	
	int scrH = scr_size-1;	
	int hil = 0, mids = scrH;
	BUN ch = lh, ct = lt; 
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	while (*(@1*)tmpt @7 hgh){
		tmpt += xx;
		tmph += xx;
	}
	while (tmpt <= ht){/*; tmpt+=xx,tmph+=xx){*/
		if ( *(@1*)tmpt @4 low){
			if (*(@1*)ct @7 hgh){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			ch += xx;
			ct += xx;
		
			*(oid*)lh = *(oid*)tmph;
			*(@1 *)lt = *(@1 *)tmpt;
			lh += xx;
			lt += xx;
		}
		else{
			scr_h[mids] = *(oid*)tmph;
			scr_t[mids] = *(@1* )tmpt;				
			mids--;	
		}
		tmpt += xx;
		tmph += xx;
		while ((*(@1*)tmpt @7 hgh)){
			tmpt += xx;
			tmph += xx;
		}
	}

	tmph = hh;
	tmpt = ht;
	ct += xx*((scrH-mids)+hil);
	for(; tmpt >= ct; tmph-=xx, tmpt-=xx){
		if (*(@1*)tmpt @7 hgh ){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh -= xx;
			ht -= xx;
		}
	}
	int i;
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @7 hgh){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh -= xx;
			ht -= xx;
		}	
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt -= xx;
		tmph -= xx;
	}
	i = mids + 1;
	for (; i <= scrH; i++){
		 if (*(@1*)tmpt @7 hgh ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh -= xx;
                        ht -= xx;
                }
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmph -= xx;
		tmpt -= xx;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}
str
CRKcrackOrderedTHREELateCopying_is_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last)
{
	BUN lh, lt, hh, ht, fhh, fht, tmpt, tmph;/* fh, llh, llt;*/
	oid *scr_h,*mscr_h;
	@1  *scr_t,*mscr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @4 low,lh,lt,+,lowShrinked++;)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	tmph = fhh = lh;
	tmpt = fht = lt;	
	int scrH = scr_size-1;	
	int hp = 0, hil = 0, mids = scrH, mmids = 0;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	mscr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	mscr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	while (*(@1*)tmpt @7 hgh){
		tmpt += xx;
		tmph += xx;
	}
	BUN tmp1 = lt, tmp2;
	while (tmpt <= ht){/*; tmpt+=xx,tmph+=xx){*/
		if ( *(@1*)tmpt @4 low){
			if (*(@1*)lt @7 hgh){
				scr_h[hil] = *(oid*)lh;
				scr_t[hil] = *(@1* )lt;				
				hil++;	
			}
			if (*(@1*)lt @5 low && *(@1*)lt @6 hgh){
				scr_h[mids] = *(oid*)lh;
				scr_t[mids] = *(@1* )lt;				
				mids--;	
			}
			*(oid*)lh = *(oid*)tmph;
			*(@1 *)lt = *(@1 *)tmpt;
			lh += xx;
			lt += xx;
		}
		hp++;
		tmpt += xx;
		tmph += xx;
		while ((*(@1*)tmpt @7 hgh)){
			tmpt += xx;
			tmph += xx;
		}
	}
	tmph = hh;
	tmpt = ht;
	tmp2 = lt;
	tmp1 += xx*(hp+hil);
	for(; tmpt >= tmp1; tmph-=xx, tmpt-=xx){
		if (*(@1*)tmpt @7 hgh ){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh -= xx;
			ht -= xx;
		}
		if (*(@1*)tmpt @5 low && *(@1*)tmpt @6 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
	}
	int i;
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @7 hgh){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh -= xx;
			ht -= xx;
		}	
		if (*(@1*)tmpt @5 low && *(@1*)tmpt @6 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt -= xx;
		tmph -= xx;
	}
	i = 0;
	for (; i < mmids; i++){
		 if (*(@1*)tmpt @7 hgh ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh -= xx;
                        ht -= xx;
                }
		if (*(@1*)tmpt @5 low && *(@1*)tmpt @6 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = mscr_h[i];
		*(@1 *)tmpt = mscr_t[i];
		tmph -= xx;
		tmpt -= xx;
	}
	tmp2 += xx*(scrH-mids);
	BUN mh= tmph, mt = tmpt;
	for(; tmpt >= tmp2; tmph-=xx, tmpt-=xx){
		if (*(@1*)tmpt @7 hgh ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh -= xx;
                        ht -= xx;
                }
		if (*(@1*)tmpt @5 low && *(@1*)tmpt @6 hgh){
			if (mt != tmpt){
				*(oid*)mh = *(oid*)tmph;
                        	*(@1 *)mt = *(@1 *)tmpt;
			}
                        mh -= xx;
                        mt -= xx;
		}
	}

        i = mids+1;
        for (; i <= scrH; i++){
                 if (*(@1*)tmpt @7 hgh ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh -= xx;
                        ht -= xx;
                }
                if (*(@1*)tmpt @5 low && *(@1*)tmpt @6 hgh){
	        	*(oid*)mh = *(oid*)tmph;
                        *(@1 *)mt = *(@1 *)tmpt;
                        mh -= xx;
                        mt -= xx;
                }
                *(oid*)tmph = scr_h[i];
                *(@1 *)tmpt = scr_t[i];
                tmph -= xx;
                tmpt -= xx;
        }
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@
@= crackInTwoOrderedPiecesII
str
CRKcrackOrderedZERO_is_@2_@1(BAT *b, @1 mid, int idx_first, int idx_last)
{

	BUN lh, lt, hh, ht, fhh, fht, tmpt, tmph;/* fh, llh, llt;*/
	oid *scr_h;
	@1  *scr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @3 mid,lh,lt,+,lowShrinked++;)@
	@:moveOrdered(*(@1*)ht @4 mid,hh,ht,-,hghShrinked++;)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	tmph = fhh = lh;
	tmpt = fht = lt;	
	
	int hghPos = 0, hil = 0;
	BUN ch = lh, ct = lt; 
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	while (tmpt <= ht && (*(@1*)tmpt @4 mid)){
		tmpt+=xx;
		tmph+=xx;
	}
	while (tmpt <= ht){ 
		hghPos++;
		if (*(@1*)ct @4 mid){
			scr_h[hil] = *(oid*)ch;
			scr_t[hil] = *(@1* )ct;				
			hil++;	
		}
		*(oid*)ch = *(oid*)tmph;
		*(@1 *)ct = *(@1 *)tmpt;
		ch += xx;
		ct += xx;
		
		tmpt+=xx;
		tmph+=xx;
		while (tmpt <= ht && (*(@1*)tmpt @4 mid)){
			tmpt+=xx;
			tmph+=xx;
		}
	}
	tmph = hh;
	tmpt = ht;
	ct += xx*hil;
	for(; tmpt >= ct; tmph-=xx, tmpt-=xx){
		if (*(@1*)tmpt @4 mid){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh -= xx;
			ht -= xx;
		}
	}
	for (int i=hil-1; i >=0 ; i--){
		if (*(@1*)tmpt @4 mid){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh -= xx;
			ht -= xx;
		}	
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt-=xx;
		tmph-=xx;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}
@
@= crackInTwoOrderedPieces
str
CRKcrackOrderedZERO_SI_@2_@1(BAT *b, @1 mid, int idx_first, int idx_last)
{

	BUN lh, lt, hh, ht, fhh, fht, tmpt, tmph, fh, llh, llt;
	oid *scr_h;
	@1  *scr_t;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @3 mid,lh,lt,+,lowShrinked++;)@
	@:moveOrdered(*(@1*)ht @4 mid,hh,ht,-,hghShrinked++;)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	tmph = fhh = lh;
	tmpt = fht = lt;	
	
	int hghPos = 0; 
	for(; tmpt <= ht; tmpt+=xx)
		hghPos+=(*(@1*)tmpt @3 mid);
	

	fhh = lh + xx*hghPos;
	fht = lt + xx*hghPos;
	
	int right_scr_size = idx_last-idx_first + 1 - hghPos - hghShrinked - lowShrinked ;
	int left_scr_size  = hghPos;
	int spl, sph;

	if (right_scr_size <= left_scr_size){
		spl = 0; sph = right_scr_size-1;
		scr_h = (oid*) GDKmalloc(right_scr_size * sizeof(oid));
		scr_t = (@1 *) GDKmalloc(right_scr_size * sizeof(@1 ));
		@:rightOrderedZeroSplit(@1,@3,@4)@
	}
	else{
		spl = 0; sph = left_scr_size-1;
		scr_h = (oid*) GDKmalloc(left_scr_size * sizeof(oid));
		scr_t = (@1 *) GDKmalloc(left_scr_size * sizeof(@1 ));
		@:leftOrderedZeroSplit(@1,@3,@4)@
	} 

	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}
@
@= crackInThreeOrderedPieces
str
CRKcrackOrderedTHREE_SI_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last)
{

	BUN lh, lt, hh, ht, fhh, fht, tmpt, tmph, fh, llh, llt;
	oid *scr_h;
	@1  *scr_t;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt <= low,lh,lt,+,lowShrinked++;)@
	@:moveOrdered(*(@1*)ht >  hgh,hh,ht,-,hghShrinked++;)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	tmph = fhh = lh;
	tmpt = fht = lt;	
	
	int hghPos = 0;
	int midPos = 0; 
	for(; tmpt <= ht; tmpt+=xx){
		hghPos+=(*(@1*)tmpt <= hgh);
		midPos+=(*(@1*)tmpt < low);
	}

	if (hghPos == midPos) return MAL_SUCCEED;

	fhh = lh + xx*hghPos;
	fht = lt + xx*hghPos;

	int midShrinked = 0;
	@:moveOrdered(*(@1*)lt <= hgh,lh,lt,+,midShrinked++;)@
	int right_scr_size = idx_last-idx_first + 1 - hghPos - lowShrinked - hghShrinked;
	int left_scr_size  = hghPos - midShrinked;
	int scr_size = 0;
	int spl, sph;
	int mid = hgh;
	if (right_scr_size <= left_scr_size){
		spl = 0; sph = right_scr_size-1;
		scr_size = right_scr_size;
		scr_h = (oid*) GDKmalloc(right_scr_size * sizeof(oid));
		scr_t = (@1 *) GDKmalloc(right_scr_size * sizeof(@1 ));
		@:rightOrderedZeroSplit(@1,<=,>)@
	}
	else{
		spl = 0; sph = left_scr_size-1;
		scr_size = left_scr_size;
		scr_h = (oid*) GDKmalloc(left_scr_size * sizeof(oid));
		scr_t = (@1 *) GDKmalloc(left_scr_size * sizeof(@1 ));
		@:leftOrderedZeroSplit(@1,<=,>)@
	} 
	int size = lowShrinked + hghPos;
	lh = BUNhloc(b, BUNptr(b, idx_first + lowShrinked));
	lt = BUNtloc(b, BUNptr(b, idx_first + lowShrinked));
	ht = BUNtloc(b, BUNptr(b, size - 1));
	hh = BUNhloc(b, BUNptr(b, size - 1));

	fhh = lh + xx*midPos;
	fht = lt + xx*midPos;

	hghShrinked = 0;
	lowShrinked = 0;
	@:moveOrdered(*(@1*)lt <  low,lh,lt,+,lowShrinked++;)@
	@:moveOrdered(*(@1*)ht >= low,hh,ht,-,hghShrinked++;)@

	right_scr_size = hghPos - midPos - hghShrinked;
	left_scr_size  = midPos - lowShrinked;
	int scr_size2 = 0;
	if (right_scr_size <= left_scr_size) scr_size2 = right_scr_size;
	else scr_size2 = left_scr_size;
	if (scr_size2 > scr_size){
		scr_h = (oid*) GDKrealloc(scr_h, scr_size2 * sizeof(oid));
		scr_t = (@1 *) GDKrealloc(scr_t, scr_size2 * sizeof(@1 ));
	}
	mid = low;
	if (right_scr_size <= left_scr_size){
		spl = 0; sph = right_scr_size-1;
		@:rightOrderedZeroSplit(@1,<,>=)@
	}
	else{
		spl = 0; sph = left_scr_size-1;
		@:leftOrderedZeroSplit(@1,<,>=)@
	} 

	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}
@
@= SI_operations
@:crackInThreePiecesSI(@1,LE,RE,<,>=,<=,>)@
@:crackInThreePiecesSI(@1,LO,RE,<=,>,<=,>)@
@:crackInThreePiecesSI(@1,LE,RO,<,>=,<,>=)@
@:crackInThreePiecesSI(@1,LO,RO,<=,>,<,>=)@
@:crackInTwoOrderedPieces(@1,LE,<=,>)@
@:crackInTwoOrderedPieces(@1,RE,<,>=)@
@:crackInTwoOrderedPiecesII(@1,LE,<=,>)@
@:crackInTwoOrderedPiecesII(@1,RE,<,>=)@
@:crackInThreeOrderedPieces(@1)@
@:crackInThreeOrderedPiecesII(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeOrderedPiecesII(@1,LE,RE,<,>=,<=,>)@
str
CRKcrackZero_SI_@1 (int *res, int *bid, @1 *mid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}

	(void)mid;

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return MAL_SUCCEED;
}

str             
CRKcrackOrderedZero_SI_@1 (int *res, int *bid, @1 *mid)
{       
        BAT *b;
        str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crack_SI", "Cannot access descriptor");
        }
        msg= CRKcrackOrderedZERO_SI_LE_@1(b,*mid, 0, BATcount(b)-1);

        BBPkeepref(b->batCacheid);
        *res = *bid;    
        return msg;             
}  

str             
CRKcrackOrderedZero_is_@1 (int *res, int *bid, @1 *mid)
{       
        BAT *b;
        str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crack_SI", "Cannot access descriptor");
        }
        msg= CRKcrackOrderedZERO_is_LE_@1(b,*mid, 0, BATcount(b)-1);

        BBPkeepref(b->batCacheid);
        *res = *bid;    
        return msg;             
}  

str
CRKcrackOne_SI_@1 (int *res, int *bid, @1 *mid)
{
	BAT *b;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}

	msg= CRKcrackONE_SI_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

str
CRKcrackOrderedOne_SI_@1 (int *res, int *bid, @1 *mid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}

	(void)mid;

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return MAL_SUCCEED;
}

str             
CRKcrackOrderedOne_is_@1 (int *res, int *bid, @1 *mid)
{       
        BAT *b;
	str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crack_SI", "Cannot access descriptor");
        }
	msg= CRKcrackOrderedTHREE_is_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);
        BBPkeepref(b->batCacheid);
        *res = *bid;    
        return msg;             
}  
str
CRKcrackTwo_SI_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;

	if (*(@1 *) low > *(@1 *) hgh)
		return throwMessage("crackers.crack_SI", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return MAL_SUCCEED;
}

str
CRKcrackOrderedTwo_SI_@1 (int *res, int *bid, @1 *mid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}

	(void)mid;

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return MAL_SUCCEED;
}

str
CRKcrackOrderedTwo_is_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;

	if (*(@1 *) low > *(@1 *) hgh)
		return throwMessage("crackers.crack_SI", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return MAL_SUCCEED;
}

str
CRKcrackThree_SI_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}

	msg= CRKcrackONE_SI_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

str
CRKcrackOrderedThree_SI_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}
	msg= CRKcrackOrderedTHREE_SI_@1(b,*low,*hgh, 0, BATcount(b)-1);

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
str
CRKcrackOrderedThree_is_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_SI", "Cannot access descriptor");
	}
        msg= CRKcrackOrderedTHREELateCopying_is_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1);
	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

@
@

@= validate_operations
@:validate_operation_Zero(@1,@2)@
@:validate_operation_One(@1,@2)@
@:validate_operation_Two(@1,@2)@
@:validate_operation_Three(@1,@2)@
@
@= validate_init_1
	BAT *b,*c,*w;
	BUN fst_bn, lst_bn, bn;
	int bs;
	size_t count[6] = {0,0,0,0,0,0};

	/* initialization */
	*res = FALSE;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.@3crack_validate", "Cannot access descriptor");
	}
	bs = BUNsize(b);
	fst_bn = BUNfirst(b);
	lst_bn = BUNlast(b);
	bn = fst_bn;
@
@= validate_init_2
	if (low > hgh) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.@3crack_validate", "illegal range");
	}
@
@= validate_check
	while (bn < lst_bn @3 @4 ) {
		bn += bs;
		count[@2]++;
	}
@
@= validate_checkOrdered
{	oid hd = 0;
	while (bn < lst_bn && hd <= *(oid*)BUNhloc(b, bn) @3 @4 ) {
		hd = *(oid*)BUNhloc(b, bn);
		bn += bs;
		count[@2]++;
}	}
@
@= validate_check_1
	@:validate_check@1(,@3, && *(@2*)BUNtloc(b, bn) @4 @5 )@
@
@= validate_check_2
	@:validate_check@1(,@3, && *(@2*)BUNtloc(b, bn) @4 @5 , && *(@2*)BUNtloc(b, bn) @6 @7 )@
@
@= validate_end
	count[0] = BATcount(b);
	if (bn < lst_bn) {
		@4;
		c = BATslice(b, BUNindex(b, fst_bn), BUNindex(b, bn));
		w = BATslice(b, BUNindex(b, bn), BUNindex(b, lst_bn));
		printf("correct:\n");
		BATprint(c);
		printf("wrong:\n");
		BATprint(w);
		BBPunfix(w->batCacheid);
		BBPunfix(c->batCacheid);
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.@3crack_validate", "Invalid crack");
	}
	assert(bn == lst_bn);
	assert(count[0] == count[1] + count[2] + count[3] + count[4] + count[5]);
	BBPunfix(b->batCacheid);
	*res = TRUE;
	return MAL_SUCCEED;
@
@= validate_operation_Zero
str
CRKcrack@1Zero_validate_@2 (bit *res, int *bid, @2 *_mid)
{
	@2 mid=*_mid;
	@:validate_init_1(@1,@2,z)@

	@:validate_check_1(@1,@2,1,<=,mid)@
	@:validate_check_1(@1,@2,2,> ,mid)@

	@:validate_end(@1,@2,z,\
		printf("|b|="SZFMT" ; |tail<=%d|="SZFMT", |tail>%d|="SZFMT" !\n",\
		       count[0], mid, count[1], mid, count[2]);\
	)@
}
@
@= validate_operation_One
str
CRKcrack@1One_validate_@2 (int *res, int *bid, @2 *_mid)
{
	@2 mid=*_mid;
	@:validate_init_1(@1,@2,)@

	@:validate_check_1(@1,@2,1,< ,mid)@
	@:validate_check_1(@1,@2,2,==,mid)@
	@:validate_check_1(@1,@2,3,> ,mid)@
	
	@:validate_end(@1,@2,,\
		printf("|b|="SZFMT" ; |tail<%d|="SZFMT", |tail==%d|="SZFMT", |tail>%d|="SZFMT" !\n",\
		       count[0], mid, count[1], mid, count[2], mid, count[3]);\
	)@
}
@
@= validate_operation_Two
str
CRKcrack@1Two_validate_@2 (bit *res, int *bid, @2 *_low, @2 *_hgh)
{
	@2 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,@2,)@
	@:validate_init_2(@1,@2,)@

	@:validate_check_1(@1,@2,1,< ,low)@
	@:validate_check_1(@1,@2,2,==,low)@
	@:validate_check_2(@1,@2,3,> ,low,< ,hgh)@
	@:validate_check_1(@1,@2,4,==,hgh)@
	@:validate_check_1(@1,@2,5,> ,hgh)@

	@:validate_end(@1,@2,,\
		printf("|b|="SZFMT" ; |tail<%d|="SZFMT", |tail==%d|="SZFMT", |%d<tail<%d|="SZFMT", |tail==%d|="SZFMT", |tail>%d|="SZFMT" !\n",\
		       count[0], low, count[1], low, count[2], low, hgh, count[3], hgh, count[4], hgh, count[5]);\
	)@
}
@
@= validate_operation_Three
str
CRKcrack@1Three_validate_@2 (bit *res, int *bid, @2 *_low, @2 *_hgh)
{
	@2 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,@2,z)@
	@:validate_init_2(@1,@2,z)@

	@:validate_check_1(@1,@2,1,<=,low)@
	@:validate_check_1(@1,@2,2,<=,hgh)@
	@:validate_check_1(@1,@2,3,> ,hgh)@

	@:validate_end(@1,@2,z,\
		printf("|b|="SZFMT" ; |tail<=%d|="SZFMT", |%d<tail<=%d|="SZFMT", |tail>%d|="SZFMT" !\n",\
		       count[0], low, count[1], low, hgh, count[2], hgh, count[3]);\
	)@
}
@

@c
@:validate_operations(,int)@
@:validate_operations(Ordered,int)@

@:MK_operations(int)@

@:SMsm_operations(int,SM,BUN)@
@:SMsm_operations(int,sm,TAIL)@
@:SI_operations(int)@
@}
