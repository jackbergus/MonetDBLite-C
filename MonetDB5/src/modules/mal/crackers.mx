@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f crackers
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006
@* Cracker index


StM: This text is obsolete as of April 26, 2006, and needs to be updated!


A cracker index is a volatile datastructure which acts as
a non-dense index into a BAT. The index is incrementally built
based on the fragments needed by queries.
Each select operation results in a partial re-clustering of the tuples
such that the result set is a consecutive memory area in the BAT.
This set can be returned as a BAT view for further processing.

A cracker index is created with the command @code{crackers.new}
and destroyed using @code{crackers.destroy}.
Multiple calls to create/destroy the cracker index on the same
argument are ignored.

The cracker index can be created for the time being on
tail columns of type {int,lng,dbl,flt,time}. The head
is always of type @code{oid}.

Once a cracker index exist, portions can be extracted 
using @code{crackers.select} and @code{crackers.uselect},
which semantically behave as their algebraic counterparts.
Both operations may have to glue pieces from the cracked
bat to satisfy the BAT semantics.

Qst: are these operators overloaded to initiate a crack
operation first?

In addition, the cracker index can be used to feed a generator
for pieces satisfying a range constraint.
A cracker partition is indicated by the index in the cidx
table. It can be used to initialize a BATview to represent
the partition during processing.

Repeated cracking leads to an ever growing index. This process
can be stopped by setting the granule size,
i.e.  the minimum number of tuples in each piece,
or the maximum number of pieces. 
The operations @code{crackers.setGranule()} and @code{crackers.setLimit()}
implement them. The default is to allow an arbitrary number pieces
with arbitrary sizes.

Pitfalls.
The policy in the kernel to take a copy of a BAT when there
is a need to write to it and there are also views around becomes 
an issue. Instead, it should isolate the views, giving them a
private copy. This way the underlying base table becomes free to re-arrange.
This issue is postponed to the future.

The cracker module should be prepared to deal with any of the base types.
For strings this becomes an issue.

This module contains the experimental code to play with cracked tables.
It supports int-based bats for the time being only.

The current implementation uses an unprotected cracker
index. This limits the interface at slightly more overhead
of searching the cracker index upon each call.

Initial performance indicates around 70 ms processing
overhead on a 1M bat during the first crack operation.
(Athlon 1400, 1Gb)

@= crackfcn
command printIndex(b:bat[:oid,:@1]):void
address CRKprintIndex
comment "Print the index for a cracked table.";
@

@mal
module crackers;

@:crackfcn(chr)@
@:crackfcn(sht)@
@:crackfcn(int)@
@:crackfcn(lng)@
@:crackfcn(flt)@
@:crackfcn(dbl)@
@-
A limited set of relational operators is overloaded to deal with
cracked BATs. The relational select collects the pieces
into a single BAT. Preferably using a BATview, otherwise
the pieces are combined to form a new BAT.

@= crackAlgebra
command select(b:bat[:any_1,:@1],l:@1,h:@1):bat[:any_2,:@1]
address CRKselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:any_1,:@1],l:@1):bat[:any_2,:@1]
address CRKselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_6,:@1]
address CRKselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:@1,h:@1):bat[:any_2,:void]
address CRKuselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:@1):bat[:any_2,:void]
address CRKuselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_6,:void]
address CRKuselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command joinselect(left:bat[:any_1,:oid], right:bat[:any_2,:@1],l:any_3,h:any_4,li:any_5,hi:any_6):bat[:void,:oid]
address CRKjoinSelectBounds_@1
comment "Join left and right on oids. From right only bun that satisfy the 
	restriction qualify. Result is a new bat.";
@-
@mal
@:crackAlgebra(chr)@
@:crackAlgebra(sht)@
@:crackAlgebra(int)@
@:crackAlgebra(lng)@
@:crackAlgebra(flt)@
@:crackAlgebra(dbl)@

@-
Direct access to the core cracking routines for cracking a complete BAT;
mainly for testing/debugging.
@
@= crack
command zcrackOrdered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackOrderedZero_@1
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackOrderedOne_@1
comment "Break a BAT into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackOrderedTwo_@1
comment "Break a BAT into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackOrderedThree_@1
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackUnordered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackUnorderedZero_@1
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackUnorderedThree_@1
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@
@= crack_validate
command zcrackOrdered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackOrderedZero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackOrderedOne_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackOrderedTwo_validate_@1
comment "Validate whether a BAT is correctly broken into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackOrderedThree_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackUnordered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackUnorderedZero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackUnorderedThree_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@
@mal
@:crack(chr)@
@:crack(sht)@
@:crack(int)@
@:crack(lng)@
@:crack(flt)@
@:crack(dbl)@
@:crack_validate(chr)@
@:crack_validate(sht)@
@:crack_validate(int)@
@:crack_validate(lng)@
@:crack_validate(flt)@
@:crack_validate(dbl)@
@-
@{
@- include prelude.mx
@* Implementation
The implementation is geared at early experimentation
without all the details to make the code robust and
ultra fast.

@h
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/

typedef struct {
	int bid;   /* the cracked bat */
	int cbid;   /* the copy on which we actually crack */
	int cid;   /* the index for this cracked bat */
} CrackIndex;

mal_export str CRKselect(int *vid, int *bid, int *low, int *hgh);
mal_export str CRKselectValue(int *vid, int *bid, int *value);
mal_export str CRKuselect(int *vid, int *bid, int *low, int *hgh);
mal_export str CRKuselectValue(int *vid, int *bid, int *value);

mal_export str CRKprintIndex(int *k, int *bid);

#endif /* _CRACKERS_H */

@c
#include "mal.h"
#include "mal_exception.h"
#include "crackers.h"

#define MAXPIECE 1024*100

static int maxCrackMap = 0;

static CrackIndex *Index;

int     
existsIndex(int bid)
{       
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (Index[i].bid == bid)
			return i;
	return -1;
}
@= CreateNewIndex
int     
newIndex_@1(int bid, int cbid)
{       
	int i, freemap = -1, units = 1024;
	BAT *b;
	
	for (i = 0; i < maxCrackMap; i++)
		if (Index[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		Index[freemap].bid = bid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackIndex *x;
        
		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackIndex *) GDKmalloc(sizeof(CrackIndex) * units);
		memset(x, 0, sizeof(CrackIndex) * units);
		if (Index) { 
			fprintf(stderr, "reallocate index \n");
			memcpy(x, Index, sizeof(CrackIndex) * i);
			GDKfree(Index);
		}
		Index = x;
		maxCrackMap = units;
	}

	Index[i].bid = bid;
	Index[i].cbid = cbid;
	b = BATnew(TYPE_lng, TYPE_@1, 100000);	/*todo: size*/
	BBPkeepref(b->batCacheid);
	Index[i].cid = b->batCacheid; 
	return i;
}
@

@c
@:CreateNewIndex(chr)@
@:CreateNewIndex(sht)@
@:CreateNewIndex(int)@
@:CreateNewIndex(lng)@
@:CreateNewIndex(flt)@
@:CreateNewIndex(dbl)@

void
printCrackIndex(int bid)
{
	int i = existsIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(Index[i].cid));
}

str
CRKprintIndex(int *k, int *bid)
{
	(void)k;
	printCrackIndex(*bid);
	return MAL_SUCCEED;
}


@= insertIndexElement
	*(lng*) @2 = @4;	
	*(@1 *) @3 = @5;	
	(b)->batBuns->free += xx;
        (b)->batCount ++; 
@
@= InsertIndexElements
void 
addOne_@1(int i, @1 *value, lng index, BUN p)
{
	BAT *b;
        if ((b = BATdescriptor(Index[i].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return;
        }

	int xx = BUNsize(b);
	if (BATcount(b) == 0){
		@:insertIndexElement(@1,BUNhloc(b, BUNfirst(b)), BUNtloc(b, BUNfirst(b)), index, *value)@
		return; 		
	}
	/*todo: check BAT size*/

	BUN ph = BUNhloc(b, p);
	BUN pt = BUNtloc(b, p);
	
	if (p == BUNlast(b)){ /*Insert at the end if everything is smaller than the new value*/
		@:insertIndexElement(@1, ph, pt, index, *value)@
		return;
	}

	/*Else we have to sift some buns to put the new one to the right position*/
	BUN wh = BUNhloc(b, BUNlast(b));
	BUN wt = BUNtloc(b, BUNlast(b));
	BUN rh = wh - xx, rt = wt - xx;
	if (*(@1*)pt == *value && index > 0){ /*negative index values inidicate non inclusive bounds so they should be always first*/
		ph += xx;
		pt += xx;
	} 
	for (;rt>=pt;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
		*(lng*)wh = *(lng*)rh;
		*(@1 *)wt = *(@1 *)rt;
	}
	@:insertIndexElement(@1, ph, pt, index, *value)@
	BBPunfix(b->batCacheid);
}	

void 
addTwo_@1(int i, @1 *valueA, lng indexA, BUN p2, @1 *valueB, lng indexB, BUN p)
{
	BAT *b;
        if ((b = BATdescriptor(Index[i].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return;
        }

	/*todo: check BAT size*/
	int xx = BUNsize(b);
	if (BATcount(b) == 0){
		BUN ph = BUNhloc(b, BUNfirst(b));
		BUN pt = BUNtloc(b, BUNfirst(b));
		@:insertIndexElement(@1, ph, pt, indexA, *valueA)@
		ph += xx;
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
		return; 		
	}

	BUN ph = BUNhloc(b, p);
	BUN pt = BUNtloc(b, p);
	BUN wh = BUNhloc(b, BUNlast(b)+xx);
	BUN wt = BUNtloc(b, BUNlast(b)+xx);
	BUN rh = wh - 2*xx, rt = wt - 2*xx;
        BUN p2h = BUNhloc(b, p2);
        BUN p2t = BUNtloc(b, p2);
	if (p == BUNlast(b)){
		ph += xx; /* sift one more position to make room for pair A too*/
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
	}
	else{   /*Else we have to sift some buns to put the new one to the right position*/
		if (*(@1*)pt == *valueB && indexB > 0){
			ph += xx;
			pt += xx;
		} 
		for (;rt>=pt;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
			*(lng*)wh = *(lng*)rh;
			*(@1 *)wt = *(@1 *)rt;
		}
		ph += xx; /* sift one more position to make room for pair A too*/
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
	}
        wh -= xx;
        wt -= xx;
        if (*(@1*)p2t == *valueA && indexA > 0){
                p2h += xx;
                p2t += xx;
        }
        for (;rt>=p2t;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
                *(lng*)wh = *(lng*)rh;
                *(@1 *)wt = *(@1 *)rt;
        }
        @:insertIndexElement(@1, p2h, p2t, indexA, *valueA)@
	BBPunfix(b->batCacheid);
}	
@

@c
@:InsertIndexElements(chr)@
@:InsertIndexElements(sht)@
@:InsertIndexElements(int)@
@:InsertIndexElements(lng)@
@:InsertIndexElements(flt)@
@:InsertIndexElements(dbl)@


@-
The core cracking routines.

@= moveOrdered
	while (@1 @6 ){
		@2 @4= xx;
		@3 @4= xx;
		@5
	}
@

@= OThree
	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)ct @5){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
		
		}
		else{
			scr_h[mids] = *(oid*)tmph;
			scr_t[mids] = *(@1* )tmpt;				
			mids--;	
		}
		tmpt @2= xx;
		tmph @2= xx;
		while (tmpt @3 ht && *(@1*)tmpt @5){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	tmph = hh;
	tmpt = ht;
	ct @2= xx*((scrH-mids)+hil);
	for(; tmpt @7 ct; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
	}
	int i;
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}
	i = mids + 1;
	for (; i <= scrH; i++){
		 if (*(@1*)tmpt @5){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
@

@= crackInThreeOrderedPieces
str
CRKcrackOrderedThree_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last)
{
	BUN hh, ht, tmpt, tmph;
	oid *scr_h;
	@1  *scr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @4 low,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht<=tmpt)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	int scrH = scr_size-1;	
	int hil = 0, mids = scrH;
	BUN ch = tmph, ct = tmpt; 
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	int probe = 25;
	BUN t = tmpt, s = tmpt+(2*probe*xx);
	int j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;

	if (j > probe){
		ch = tmph; ct = tmpt; 
		@:OThree(@1,+,<=,@4 low,@7 hgh,-,>=)@
	}
	else{  
		ch = hh; ct = ht; 
		BUN fh = tmph, ft = tmpt;
		tmph = hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OThree(@1,-,>=,@7 hgh,@4 low,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}

str
CRKcrackOrderedThreeL_@2_@3_@1(BAT *b, @1 low, @1 hgh, lng idx_first, lng idx_last, lng *posl, lng *posh)
{
	BUN lh, lt, hh, ht, tmpt, tmph;
	oid *scr_h,*mscr_h;
	@1  *scr_t,*mscr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @4 low,lh,lt,+,lowShrinked++;,&& lt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht>=lt)@

	/*These are different cases. For now just make sure that the result will be empty.
		todo: when the index will learn from empty results return the appropriate information*/
	
	if (lowShrinked == scr_size) {
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == scr_size){
		*posl =  1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	/*Middle piece is empty and lt = ht + 1*/
	if (lowShrinked + hghShrinked == scr_size){
		*posl =  BUNindex(b,lt);
		*posh =  BUNindex(b,ht);
		return MAL_SUCCEED;
	}

	int scrH = scr_size-1;	
	int hp = 0, hil = 0, mids = scrH, mmids = 0;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	mscr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	mscr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	int probe = 100;
	BUN t = lt, s = lt+(2*probe*xx);
	int j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;
	lng pos1, pos2;
	if (j > probe){
		tmph = lh;
		tmpt = lt;	
		@:OThreeLateCopying(@1,+,<=,@4 low,@7 hgh,-,>=,@5,@6)@
		*posl = pos1;
		*posh = pos2;
	}
	else{  
		tmph = hh;
		tmpt = ht;	
		BUN fh = lh, ft = lt;
		lh = hh; lt = ht;
		hh = fh; ht = ft;
		@:OThreeLateCopying(@1,-,>=,@7 hgh,@4 low,+,<=,@5,@6)@
		*posl = pos2;
		*posh = pos1;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@
@= OThreeLateCopying
	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	BUN tmp1 = lt, tmp2;
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)lt @5){
				scr_h[hil] = *(oid*)lh;
				scr_t[hil] = *(@1* )lt;				
				hil++;	
			}
			if (*(@1*)lt @8 low && *(@1*)lt @9 hgh){
				scr_h[mids] = *(oid*)lh;
				scr_t[mids] = *(@1* )lt;				
				mids--;	
			}
			*(oid*)lh = *(oid*)tmph;
			*(@1 *)lt = *(@1 *)tmpt;
			lh @2= xx;
			lt @2= xx;
		}
		hp++;
		tmpt @2= xx;
		tmph @2= xx;
		while (*(@1*)tmpt @5 && tmpt @3 ht){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	
	pos1 = BUNindex(b,lt);

	tmph = hh;
	tmpt = ht;
	tmp2 = lt;
	tmp1 @2= xx*(hp+hil);
	for(; tmpt @7 tmp1; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
	}
	int i;
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}

	pos2 = BUNindex(b,tmpt);

	i = 0;
	for (; i < mmids; i++){
		 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = mscr_h[i];
		*(@1 *)tmpt = mscr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
	tmp2 @2= xx*(scrH-mids);
	/*todo check as in the zero case*/
	BUN mh= tmph, mt = tmpt;
	for(; tmpt @7 tmp2; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			if (mt != tmpt){
				*(oid*)mh = *(oid*)tmph;
                        	*(@1 *)mt = *(@1 *)tmpt;
			}
                        mh @6= xx;
                        mt @6= xx;
		}
	}

        i = mids+1;
        for (; i <= scrH; i++){
                 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
                if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
	        	*(oid*)mh = *(oid*)tmph;
                        *(@1 *)mt = *(@1 *)tmpt;
                        mh @6= xx;
                        mt @6= xx;
                }
                *(oid*)tmph = scr_h[i];
                *(@1 *)tmpt = scr_t[i];
                tmph @6= xx;
                tmpt @6= xx;
        }
@
@= OrderedZero
		while (tmpt @3 ht){ 
			while (*(@1*)tmpt @4 mid){
				tmpt @2=xx;
				tmph @2=xx;
			}
			if (*(@1*)ct @4 mid){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
			
			tmpt @2= xx;
			tmph @2= xx;
		}
		tmph @5= 2*xx;
		tmpt @5= 2*xx;
	
		/* Take the position where the last BUN of the left piece is. */
		*pos = BUNindex(b,ct @7);

		ct  @2= xx*hil;
		/*Extreme case where all lows(or all but one, or all but two) where in the hgh partition (or opposite depending how we move) */
		if (ct @6 tmpt ){
			if (ct == tmpt || ct == tmpt @2 xx) {
				for (int i=hil; i >=0 ; i--){
					if (*(@1*)tmpt @4 mid){
						*(oid*)hh = *(oid*)tmph;
						*(@1 *)ht = *(@1 *)tmpt;
						hh @5= xx;
						ht @5= xx;
					}	
					tmpt @5= xx;
					tmph @5= xx;
				}
				for (int i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}

			}
			else{
				for (int i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}
			}
			return MAL_SUCCEED;
		}

		for(; tmpt @6 ct; tmph @5=xx, tmpt @5=xx){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}
		}
		for (int i=hil-1; i >=0 ; i--){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}	
			*(oid*)tmph = scr_h[i];
			*(@1 *)tmpt = scr_t[i];
			tmpt @5= xx;
			tmph @5= xx;
		}
@
@= crackInTwoOrderedPieces
str
CRKcrackOrderedZero_@2_@1(BAT *b, @1 mid, lng idx_first, lng idx_last, lng *pos)
{
	BUN hh, ht, tmpt, tmph;
	oid *scr_h;
	@1  *scr_t;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @3 mid,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @4 mid,hh,ht,-,hghShrinked++;,&& ht>=tmpt)@
	if (lowShrinked == idx_last - idx_first +1) {
			*pos = idx_last+1;
			return MAL_SUCCEED;
	}
	if (hghShrinked == idx_last - idx_first +1){
			*pos = idx_first-1;
			return MAL_SUCCEED;
	}
	
	if (ht == tmpt + xx){
		oid dh = *(oid*)tmph;
		@1  dt = *(@1 *)tmpt;
		*(oid*)tmph = *(oid*)hh;
		*(@1 *)tmpt = *(@1 *)ht;

		*pos = BUNindex(b,tmpt);

		*(oid*)hh = dh;
		*(@1 *)ht = dt;

		return MAL_SUCCEED;
	}

	if (ht == tmpt - xx){
		*pos = BUNindex(b,ht);
		return MAL_SUCCEED;
	}	

	int hil = 0;
	BUN ch, ct; 
	int scr_size = (idx_last - idx_first +1 -lowShrinked -hghShrinked);
	if (scr_size >=2) scr_size = scr_size/2;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	int probe = 25;
	BUN t = tmpt, s = tmpt+(2*probe*xx);
	int j=0;
	for (;t<s;t+=xx)
		j+=*(@1*)t @3 mid;
	
	if (j > probe){
		ch = tmph; ct = tmpt; 
		@:OrderedZero(@1,+,<=,@4,-,>=, -xx)@
	}
	else{
		ch =hh; ct = ht; 
		BUN fh = tmph, ft = tmpt;
		tmph =hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OrderedZero(@1,-,>=,@3,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@

@= shuffle
        tdummy= *(@1*) @2;
        *(@1*) @2= *(@1*) @3;
        *(@1*) @3= tdummy;

        hdummy= *(oid*)((char*)@2 - b->tloc);
        *(oid*)((char*)@2 - b->tloc) = *(oid*)((char*)@3 - b->tloc);
        *(oid*)((char*)@3 - b->tloc) = hdummy;
@

@= crackInTwoUnorderedPieces
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, lng first, lng last, lng *pos){
        ptr vm, vl;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        vl= BUNtloc(b,BUNptr(b,last));

        while(vm<vl) {
                if (*(@1 *) vm @3 mval)
                        vm = (ptr) ((char *) vm + xx);
                else {
                        while( *(@1 *) vl @4 mval && vl>vm)
                                vl = (ptr) ((char *) vl - xx);
                        @:shuffle(@1,vm,vl)@
                        vl = (ptr) ((char *) vl - xx);
                        vm = (ptr) ((char *) vm + xx);
                }
        }

	if (vl == vm) {
		if (*(@1*)vl @4 mval)
			*pos = BUNindex(b,(ptr) ((char *) vl - xx)); /*works for empty left piece also*/
		else{
			*pos = BUNindex(b,vl);
			if (BUNindex(b,vl)==last) /*empty right piece*/
				*pos = *pos+1;
		}
	}
	else
		*pos = BUNindex(b,vl);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPieces

str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh){
        ptr vm, vl, hmax;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        hmax = BUNtloc(b,BUNptr(b,last));
        while( *(@1 *) hmax @7 hgh && hmax>vm)
                hmax= (ptr)((char*) hmax - xx);

	if (hmax == vm){
		if (*(@1*)hmax @7 hgh){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (*(@1*)hmax @5 low){  /*result is one bun*/
			*posl = *posh = BUNindex(b,hmax);
		}
		else{
			*posl = BUNindex(b,(ptr) ((char *) hmax + xx));
			*posh = BUNindex(b,hmax);
		}
		return MAL_SUCCEED;
	}

        vl = hmax;
        while( *(@1 *) vl @5 low && vl>vm){
                /* move all high values into their final place */
                if( *(@1 *) vl @7 hgh){
                        @:shuffle(@1,vl,hmax)@
                        hmax= (ptr)((char*) hmax - xx);
                }
                vl= (ptr)((char*) vl - xx);
        }
	if (vl == vm){/*left piece is empty*/
		if (*(@1*) vl @7 hgh){
			@:shuffle(@1,vl,hmax)@
			*posl = BUNindex(b,vl);
		}
		else if (*(@1*)vl @5 low){  
			*posl = BUNindex(b,vl);

		}
		else{
			*posl = BUNindex(b,(ptr) ((char *) vl + xx));
			
		}
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (*(@1 *) vm @4 low){
                        vm = (ptr) ((char *) vm + xx);
                } else {
                        @:shuffle(@1,vm,vl)@
                        while( *(@1 *) vl @5 low && vl>vm){
                                if( *(@1*) vl @7 hgh ){
                                        @:shuffle(@1,vl,hmax)@
                                        hmax= (ptr)((char*) hmax - xx);
                                }
                                vl = (ptr) ((char *) vl - xx);
                        }
                }
        }
	if (vm ==  BUNtloc(b,BUNptr(b,last+1))){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /*then middle piece is empty*/
		*posl = BUNindex(b,(ptr) ((char *) vl + xx));
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
	*posl = BUNindex(b,vm); 
	*posh = BUNindex(b,hmax);
     
	return MAL_SUCCEED;
}
@

@= operations
@:crackInTwoUnorderedPieces(@1,LE,<=,>)@
@:crackInTwoUnorderedPieces(@1,RE,<,>=)@
@:crackInTwoOrderedPieces(@1,LE,<=,>)@
@:crackInTwoOrderedPieces(@1,RE,<,>=)@
@:crackInThreeUnorderedPieces(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeUnorderedPieces(@1,LE,RE,<,>=,<=,>)@
@:crackInThreeUnorderedPieces(@1,LO,RO,<=,>,<,>=)@
@:crackInThreeUnorderedPieces(@1,LE,RO,<,>=,<,>=)@
@:crackInThreeOrderedPieces(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeOrderedPieces(@1,LE,RE,<,>=,<=,>)@
@:crackInThreeOrderedPieces(@1,LO,RO,<=,>,<,>=)@
@:crackInThreeOrderedPieces(@1,LE,RO,<,>=,<,>=)@


str             
CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid)
{       
        BAT *b;
        str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crack_zeroOrdered", "Cannot access descriptor");
        }
	lng pos;
        msg= CRKcrackOrderedZero_LE_@1(b,*mid, 0, BATcount(b)-1,&pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;    
        return msg;             
}  


str             
CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid)
{       
        BAT *b;
	str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crack_oneOrdered", "Cannot access descriptor");
        }
	msg= CRKcrackOrderedThree_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);
        BBPkeepref(b->batCacheid);
        *res = *bid;    
        return msg;             
}  

str
CRKcrackOrderedTwo_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;

	if (*(@1 *) low > *(@1 *) hgh)
		return throwMessage("crackers.crack_twoOrdered", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_twoOrdered", "Cannot access descriptor");
	}

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return MAL_SUCCEED;
}

str
CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_threeOrdered", "Cannot access descriptor");
	}
	lng posl,posh;
        msg= CRKcrackOrderedThreeL_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1,&posl, &posh);
	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid)
{
        BAT *b;
        str msg;
	lng pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                return throwMessage("crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                return throwMessage("crackers.crack_zeroUnordered", "Need more clever mapping ");

        msg=CRKcrackUnorderedZero_LE_@1( b, *mid,(size_t) 0, BATcount(b)-1, &pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
        BAT *b;
        str msg;
	lng posl,posh;

        if (*(@1 *) low > *(@1 *) hgh)
                return throwMessage("crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                return throwMessage("crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                return throwMessage("crackers.crack_threeUnordered", "Need more clever mapping ");

        msg= CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}


@


@= validate_operations
@:validate_operation_Zero(@1,@2)@
@:validate_operation_One(@1,@2)@
@:validate_operation_Two(@1,@2)@
@:validate_operation_Three(@1,@2)@
@
@= validate_init_1
	BAT *b,*c,*w;
	BUN fst_bn, lst_bn, bn;
	int bs;
	size_t count[6] = {0,0,0,0,0,0};

	/* initialization */
	*res = FALSE;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.@2crack_validate", "Cannot access descriptor");
	}
	bs = BUNsize(b);
	fst_bn = BUNfirst(b);
	lst_bn = BUNlast(b);
	bn = fst_bn;
@
@= validate_init_2
	if (low > hgh) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.@2crack_validate", "illegal range");
	}
@
@= validate_checkUnordered
        while (bn < lst_bn @2 @3 ) {
                bn += bs;
                count[@1]++;
        }
@
@= validate_checkOrdered
{	oid hd = 0;
	while (bn < lst_bn && hd <= *(oid*)BUNhloc(b, bn) @2 @3 ) {
		hd = *(oid*)BUNhloc(b, bn);
		bn += bs;
		count[@1]++;
}	}
@
@= validate_check_1
	@:validate_check@5(@2, && *(@1*)BUNtloc(b, bn) @3 @4 )@
@
@= validate_check_2
	@:validate_check@7(@2, && *(@1*)BUNtloc(b, bn) @3 @4 , && *(@1*)BUNtloc(b, bn) @5 @6 )@
@
@= validate_end
	count[0] = BATcount(b);
	if (bn < lst_bn) {
		@3;
		c = BATslice(b, BUNindex(b, fst_bn), BUNindex(b, bn));
		w = BATslice(b, BUNindex(b, bn), BUNindex(b, lst_bn));
		printf("correct:\n");
		BATprint(c);
		printf("wrong:\n");
		BATprint(w);
		BBPunfix(w->batCacheid);
		BBPunfix(c->batCacheid);
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.@2crack_validate", "Invalid crack");
	}
	assert(bn == lst_bn);
	assert(count[0] == count[1] + count[2] + count[3] + count[4] + count[5]);
	BBPunfix(b->batCacheid);
	*res = TRUE;
	return MAL_SUCCEED;
@
@= validate_operation_Zero
str
CRKcrack@2Zero_validate_@1 (bit *res, int *bid, @1 *_mid)
{
	@1 mid=*_mid;
	@:validate_init_1(@1,z)@

	@:validate_check_1(@1,1,<=,mid,@2)@
	@:validate_check_1(@1,2,> ,mid,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2]);\
	)@
}
@
@= validate_operation_One
str
CRKcrack@2One_validate_@1 (int *res, int *bid, @1 *_mid)
{
	@1 mid=*_mid;
	@:validate_init_1(@1,)@

	@:validate_check_1(@1,1,< ,mid,@2)@
	@:validate_check_1(@1,2,==,mid,@2)@
	@:validate_check_1(@1,3,> ,mid,@2)@
	
	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2], (dbl)mid, count[3]);\
	)@
}
@
@= validate_operation_Two
str
CRKcrack@2Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh)
{
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,)@
	@:validate_init_2(@1,)@

	@:validate_check_1(@1,1,< ,low,@2)@
	@:validate_check_1(@1,2,==,low,@2)@
	@:validate_check_2(@1,3,> ,low,< ,hgh,@2)@
	@:validate_check_1(@1,4,==,hgh,@2)@
	@:validate_check_1(@1,5,> ,hgh,@2)@

	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |%f<tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, count[2], (dbl)low, (dbl)hgh, count[3], (dbl)hgh, count[4], (dbl)hgh, count[5]);\
	)@
}
@
@= validate_operation_Three
str
CRKcrack@2Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh)
{
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,z)@
	@:validate_init_2(@1,z)@

	@:validate_check_1(@1,1,<=,low,@2)@
	@:validate_check_1(@1,2,<=,hgh,@2)@
	@:validate_check_1(@1,3,> ,hgh,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |%f<tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, (dbl)hgh, count[2], (dbl)hgh, count[3]);\
	)@
}
@

@c
@:validate_operations(chr,Unordered)@
@:validate_operations(sht,Unordered)@
@:validate_operations(int,Unordered)@
@:validate_operations(lng,Unordered)@
@:validate_operations(flt,Unordered)@
@:validate_operations(dbl,Unordered)@
@:validate_operations(chr,Ordered)@
@:validate_operations(sht,Ordered)@
@:validate_operations(int,Ordered)@
@:validate_operations(lng,Ordered)@
@:validate_operations(flt,Ordered)@
@:validate_operations(dbl,Ordered)@
@:operations(chr)@
@:operations(sht)@
@:operations(int)@
@:operations(lng)@
@:operations(flt)@
@:operations(dbl)@
@}
@-
This function takes a range and returns a view with the result. To do that, we first search the index to determine which parts of the result we already 
know and which parts we have to crack. Then we crack, if necessary, 
the appropriate pieces, update the index and return the result.

@= crkThree
/*printf("crack in three pieces\n");*/
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE){
		CRKcrackUnorderedThree_LE_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = -(vl-1); i2 = vh;
	}
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE){
		CRKcrackUnorderedThree_LE_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = -(vl-1); i2 = -vh;
	}
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE){
		CRKcrackUnorderedThree_LO_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = vl-1; i2 = vh;
	}
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE){
		CRKcrackUnorderedThree_LO_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = vl-1; i2 = -vh;
	}
				
	if (vl == -1){ /*middle and right pieces are empty*/
		if (*inclusiveLow == TRUE) i1 = -@3;
		else i1 = @3;
		addOne_@1(m,low,i1,posA);
	}else
	if (vh == -1){ /*left and middle pieces are empty*/
		if (*inclusiveHgh == TRUE) i2 = @2;
		else i2 = -@2;
		addOne_@1(m,hgh,i2,posB);
	}else
		/*The following adds also gaps in the index in the cases where epmty piece
		is the right, the left or the middle. In the latter case vl is always vh+1
		and the index we want for both is vh*/
		addTwo_@1(m,low,i1,posA,hgh,i2,posB);

@= crkTwoL
/*printf("crack in two pieces\n");*/
	h1 = l + xx;
	if (h1 == BUNlast(c)){
		h1 = BUNlast(b) - BUNsize(b);
		ch1 = BUNindex (b, h1);	
	}
	else{ 
		ch1 = *(lng*)BUNhloc(c, h1);
		if (ch1 < 0) ch1 = ch1 - 2*ch1;
	}
	@:twoL(@1)@

@= crkTwoLFirst
	h1 = BUNlast(b) - BUNsize(b);
	ch1 = BUNindex (b, h1);	
	@:twoL(@1)@

@= twoL
	/*CRACK in two pieces cl-ch1 using >incLow bound*/
	if (*inclusiveLow == TRUE) {
		CRKcrackUnorderedZero_RE_@1(b,*low, cl, ch1,&vl);
		i1 = - vl;
	}
	else {
		CRKcrackUnorderedZero_LE_@1(b,*low, cl, ch1,&vl);
		i1 = vl;
	}
	if (vl < cl){
		/*then the left piece is empty*/
		if (*inclusiveLow == TRUE) i1 = -cl;
		else i1 = cl;
	}
	if (vl > ch1){
		/*then the right piece is empty*/
		vl--;
		if (*inclusiveLow == TRUE) i1 = -ch1;
		else i1 = ch1;
	}

	vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
		Instead we want the first bun of the right piece*/

@= crkTwoR
	if (h == BUNfirst(c))
		cl2 = BUNindex(b,  BUNfirst(b));	
	else{
		cl2 = *(lng*)BUNhloc(c, h-xx);
	        if (cl2 < 0) cl2 = cl2 - 2*cl2;
		cl2++;
	}
	@:twoR(@1)@

@= crkTwoRFirst
	cl2 = BUNindex(b,  BUNfirst(b));
	@:twoR(@1)@

@= twoR
/*printf("crack in two pieces\n");*/
	/*CRACK in two pieces cl2-ch using <incHgh bound*/
	if (*inclusiveHgh == TRUE){ 
		CRKcrackUnorderedZero_LE_@1(b,*hgh, cl2, ch,&vh);
		i2 = vh;
	}
	else{ 
		CRKcrackUnorderedZero_RE_@1(b,*hgh, cl2, ch,&vh);
		i2 = -vh;
	}

	/*check for gaps*/
	if (vh < cl2){
		/*then the left piece is empty*/
		if (*inclusiveHgh == TRUE) i2 = cl2;
		else i2 = -cl2;
	}
	if (vh > ch){
		/*then the right piece is empty*/
		vh--;
		if (*inclusiveHgh == TRUE) i2 = ch;
		else i2 = -ch;
	}

@= searchForLow
	l = SORTfndfirst_@1(c,low);
	lt = BUNtloc(c, l);
	lh = BUNhloc(c, l);
	posA = l;	

	/* if all indices contain values smaller than low, crack the area 
		between the last index and the last BUN of the cracked bat */
	if (l == BUNlast(c)){
		l -= xx; lt -= xx; lh -= xx; 
		if  (*(lng*)lh > 0)
			cl = *(lng*)lh;
		else
			cl = *(lng*)lh - 2*(*(lng*)lh);
		cl++;
	} else
	if (*(@1*)lt == *low){
		/* The first two cases are when the low bound already 
			exists in the index */
		if  (*(lng*)lh < 0 && *inclusiveLow == TRUE)
			vl = (*(lng*)lh - 2*(*(lng*)lh))+1;
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == FALSE)
			vl = *(lng*)lh+1;

		/* We want values that the previous index has; 
		   special case when there is no previous index */
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == TRUE){
			if (l == BUNfirst(c)){
				l  -= xx; 
				cl = BUNindex(b, BUNfirst(b));
			}else{
				l  -= xx; lh -= xx; lt -= xx;
				if  (*(lng*)lh > 0)
					cl = *(lng*)lh;
				else
					cl = *(lng*)lh - 2*(*(lng*)lh);
				cl++;
			}
		}else
		if  (*(lng*)lh < 0 && *inclusiveLow == FALSE){
		/*  This index contains values that we do not want (the equals to 
			low) so we check the next one. If it is equal to low then 
			this is an exact match, otherwise we have to crack. 
			Also if this was the last index we have to crack anyway. */
			lt += xx;
			l  +=xx;
			if (*(@1*)lt == *low && l != BUNlast(c)){
				lh += xx;
				vl = *(lng*)lh+1;
			}else{
				lt -= xx;
				l  -= xx;
				cl = (*(lng*)lh - 2*(*(lng*)lh))+1;
			}
		}
	}else{ 
		/* No exact match was found so we have to crack. Take the 
		   previous index because this one is higher than low.
		   If there is no previous index, crack the bat from the beginning. */
		if (l == BUNfirst(c)){
			l  -= xx; lh -= xx; lt -= xx;
			cl = BUNindex(b, BUNfirst(b));
		}else{
			l  -= xx; lh -= xx; lt -= xx;
			if  (*(lng*)lh > 0)
				cl = *(lng*)lh;
			else
				cl = *(lng*)lh - 2*(*(lng*)lh);
			cl++;
		}
	}	

@= searchForGapsLow
	/*check for empty pieces after l*/	
	lhnext = lh + xx;
	gf = 0;	
	while(1){
		
		if ( *(lng*)lhnext == cl || 
			( *(lng*)lhnext < 0 && *(lng*)lhnext - 2*(*(lng*)lhnext) == cl ) ){ 
			gf = 1;
			l += xx; lt += xx; lh += xx;
			lhnext += xx;
		}
		else break;
	}
	if (gf == 1){
		if (*(@1*)lt > *hgh){
			vl =  1;
			vh = -1;
			goto createView;
		}
		else
		if (*(@1*)lt == *hgh){
			if  (*(lng*)lh < 0) vl = *(lng*)lh - 2*(*(lng*)lh);
			else vl = *(lng*)lh;
			vh =  vl;
			goto createView;
		}
		else{
			if  (*(lng*)lh < 0) vl = *(lng*)lh - 2*(*(lng*)lh);
			else vl = *(lng*)lh;
			cl = -1;
		}
	}

@= searchForHgh
	h = SORTfndfirst_@1(c,hgh);
	ht = BUNtloc(c, h);
	hh = BUNhloc(c, h);
	posB = h;	

	if (h == BUNlast(c))
		ch = BUNindex(b, BUNlast(b) - BUNsize(b));
	else
	if (*(@1*)ht == *hgh){
		/* The first two cases are when the low bound already exists in the index */
		if  (*(lng*)hh > 0 && *inclusiveHgh == TRUE)
			vh = *(lng*)hh;
		else if  (*(lng*)hh < 0 && *inclusiveHgh == FALSE)
			vh = *(lng*)hh - 2*(*(lng*)hh);

		/* We want values that the next index has; special case when there is no next index */
		else if  (*(lng*)hh < 0 && *inclusiveHgh == TRUE){
			ht += xx; h  += xx; hh += xx;
			if (h == BUNlast(c)){
				ch = BUNindex(b, BUNlast(b)-BUNsize(b)); /*todo this might be the same with current index*/
			}else if (*(@1*)ht == *hgh)
				vh = *(lng*)hh;
			else {
				ch= *(lng*)hh;
				if (ch < 0) ch = *(lng*)hh - 2*(*(lng*)hh);
			}
		}
		/*  This index contains values that we do not want (the equals to hgh) 
			so we have to crack up to this one. We know that there is no 
			previous index that excludes only the values we do not want (the 
			hghs) Also we cannot check for hgh-1 */
		else if  (*(lng*)hh > 0 && *inclusiveHgh == FALSE)
			ch = *(lng*)hh;
	}else{ 
		/* No exact match was found so we have to crack. */
		if  (*(lng*)hh > 0)
			ch = *(lng*)hh;
		else
			ch = *(lng*)hh - 2*(*(lng*)hh);
	}

@= searchForGapsHgh
	/*check for empty pieces before h*/	
	hhprev = hh - xx;
	gf = 0;	
	while(1){
		if ( *(lng*)hhprev == ch || 
			( *(lng*)hhprev < 0 && *(lng*)hhprev - 2*(*(lng*)hhprev) == ch ) ){ 
			gf = 1;
			h -= xx; ht -= xx; hh -= xx;
			hhprev -= xx;
		}
		else break;
	}
	if (gf == 1){
		if (*(@1*)ht < *low){
			vl =  1;
			vh = -1;
			goto createView;
		}
		else
		if (*(@1*)ht == *low){
			if  (*(lng*)hh < 0) vl = *(lng*)hh - 2*(*(lng*)hh);
			else vl = *(lng*)hh;
			vh =  vl;
			goto createView;
		}
		else{
			if  (*(lng*)hh < 0) vh = *(lng*)hh - 2*(*(lng*)hh);
			else vh = *(lng*)hh;
			ch = -1;
		}
	}

@= CreateResult
createView:
/*	printf("vl: %lld, vh:%lld \n",vl,vh);*/
	view = BATslice(b, vl, vh+1);
	
	if (!tail) 
		view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
	
	*vid = view->batCacheid;
	BBPkeepref(*vid);
	BBPunfix(b->batCacheid);

@= crackOperations
str
CRKRange_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail)
{
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1, posl, posh; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl=-1, ch1=-1, cl2=-1, ch=-1; 
	/* index values in the case we have to crack 
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	lng i1=-1,i2=-1;
	BUN l,lt,ht; 
	int xx;
	BUN h,lh,hh,h1, posA, posB;
	BUN lhnext, hhprev;
	bit gf;
	if (low > hgh)
		return throwMessage("crackers.crack", "illegal range");
        
	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat, 
		we have to create the crack indx for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo);
		b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE; 
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;
		
		m = newIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in three pieces cl-ch */
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));
		posA = BUNfirst(c);
		posB = posA + BUNsize(c);
		@:crkThree(@1,posl,posh)@
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where our range falls after this 
		search if we have a match on the low range vl will hold the 
		index value, otherwise it will be -1. The same for hgh and vh
		if there is no match for low then cl will hold the index that 
		from there on we have to crack. The same from hgh and ch
		Note that in the case of the low range  we always have to increment 
		by one since we want the values that are after this index 
		(because of the way the crack index is created).
		Also after the search l and h should point to the low and hgh indices 
		(in the crack index) found either as a match or to crack. 
		This is used later on to determine which pieces we have to crack*/

	/* Take the index of the bat */
	if ((c = BATdescriptor(Index[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(Index[m].cbid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	@:searchForLow(@1)@
	@:searchForGapsLow(@1)@

	/* find out where in the index the high falls */
	@:searchForHgh(@1)@
	@:searchForGapsHgh(@1)@
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (vl == -1 || vh == -1){
		if (vl == -1 && vh == -1){
			/* If ch is right after cl in the index then we split this piece in three pieces*/
			if (h == l + xx){
				/*CRACK in three pieces cl-ch */
				@:crkThree(@1,cl,ch)@
			}else{
				/* Else we have to do two cracks separatelly */
	
				/* For the cl bound and the next one in the index*/
				@:crkTwoL(@1)@

				/* For the ch bound and the previous one in the index*/
				@:crkTwoR(@1)@
				
				addTwo_@1(m,low,i1,posA,hgh,i2,posB);
			}
		}else
		if (vl == -1){
			@:crkTwoL(@1)@
			addOne_@1(m,low,i1,posA);
		}else
		if (vh == -1){
			@:crkTwoR(@1)@
			addOne_@1(m,hgh,i2,posB);
		} 	
	}
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}       

str
CRKRange_LeftNil_@1(int *vid, int *bid, @1 *hgh, bit *inclusiveHgh, bit tail)
{
	BAT *b, *c, *bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl2=-1, ch=-1; 
	/* index values in the case we have to crack 
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	lng i2=-1;
	BUN ht; 
	int xx;
	BUN h,hh,posB;
        
	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat, 
	   we have to create the crack index for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo);
		b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE; 
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;
		
		m = newIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in two pieces cl-ch */
		@:crkTwoRFirst(@1)@
		posB = BUNfirst(c);
		addOne_@1(m,hgh,i2,posB);

		vl = BUNindex(b,BUNfirst(b));
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where the high falls */

	if ((c = BATdescriptor(Index[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(Index[m].cbid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	vl = BUNindex(b,BUNfirst(b));

	/* find out where in the index the high falls */
	@:searchForHgh(@1)@
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (vh == -1){
		@:crkTwoR(@1)@
		addOne_@1(m,hgh,i2,posB);
	} 	
	
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}       

str
CRKRange_RightNil_@1(int *vid, int *bid, @1 *low, bit *inclusiveLow, bit tail)
{
	BAT *b, *c, *bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng ch1=-1, cl=-1; 
	/* index values in the case we have to crack 
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	lng i1=-1;
	BUN lt; 
	int xx;
	BUN l, lh, h1, posA;
        
	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat, 
	   we have to create the crack index for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo);
		b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE; 
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;
		
		m = newIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in two pieces cl-ch */
		@:crkTwoLFirst(@1)@
		posA = BUNfirst(c);
		addOne_@1(m,low,i1,posA);

		vh = BUNindex(b,BUNlast(b)-BUNsize(b));
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where the high falls */

	if ((c = BATdescriptor(Index[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(Index[m].cbid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	@:searchForLow(@1)@

	/* find out where in the index the high falls */
	vh = BUNindex(b,BUNlast(b)-BUNsize(b));
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (vl == -1){
		@:crkTwoL(@1)@
		addOne_@1(m,low,i1,posA);
	} 	
	
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}      
@

@= SelectFunctions
mal_export str CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{		
	if (*(@1*)low == int_nil)
		CRKRange_LeftNil_@1(vid, bid, hgh, inclusiveHgh, TRUE);
	
	else if (*(@1*)hgh == int_nil)
		CRKRange_RightNil_@1(vid, bid, low, inclusiveLow, TRUE);
	else 
		CRKRange_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);

	return MAL_SUCCEED;
}

mal_export str CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{		
	if (*(@1*)low == int_nil)
		CRKRange_LeftNil_@1(vid, bid, hgh, inclusiveHgh, FALSE);
	else if (*(@1*)hgh == int_nil)
		CRKRange_RightNil_@1(vid, bid, low, inclusiveLow, FALSE);
	else 
		CRKRange_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);

	return MAL_SUCCEED;
}

str                             
CRKselectValue_@1(int *vid, int *bid, @1 *value)
{                                       
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
} 
                
str
CRKuselectValue_@1(int *vid, int *bid, @1 *value)
{
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
}

str
CRKselect_@1(int *vid, int *bid, @1 *low, @1 *hgh)
{
	bit inclusive = TRUE;
	return CRKselectBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}

str                             
CRKuselect_@1(int *vid, int *bid, @1 *low, @1 *hgh)
{                               
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}

@= JoinSelect
/* joins a left=[void, oid] bat with a right=[void, any_type] bat on oids. 
From the right bat only BUNs that pass the range restriction qualify. 
The result is [void,oid] bat */
str
JoinSelectRange_@2_@3_@1(int *res, int *left, int *right, @1 *low, @1 *hgh)
{
	BAT *l, *r, *d;
	BUN lt, rt, rbase, dt;
	BUN llast;
	int xx, zz, dd;

	if ((l = BATdescriptor(*left)) == NULL)
        	return throwMessage("crackers.crackJoinSelect", "Cannot access descriptor");
	if ((r = BATdescriptor(*right)) == NULL)
        	return throwMessage("crackers.crackJoinSelect", "Cannot access descriptor");

	lt = BUNtloc(l, BUNfirst(l));
	llast = BUNtloc(l, BUNlast(l)-1);
	xx = BUNsize(l);

	rbase = BUNtloc(r, BUNfirst(r));
	zz = BUNsize(r);

	d = BATnew(TYPE_void, TYPE_oid, BATcount(l));
	dt = BUNtloc(d, BUNfirst(d));
	dd =BUNsize(d);

	/* For each BUN of the left bat check if the corresponding BUN in the right bat satisfies the restriction.
	   If yes the respective oid is added to the result */
	while(lt <= llast){
		rt = rbase + (*(oid*)lt)*zz;
		if (*(@1*)rt @4 *low && *(@1*)rt @5 *hgh){
			*(oid*)dt = *(oid*)lt; 
			dt += dd;	
		}		
		lt += xx;
	}

	d->batBuns->free = dt - d->batBuns->base;
        BATsetcount(d, d->batBuns->free/dd);

	*res=d->batCacheid;

	BBPkeepref(d->batCacheid);
	BBPunfix(l->batCacheid);
	BBPunfix(r->batCacheid);
	
	return MAL_SUCCEED;
}         
@

@= JoinSelectOperations
@:JoinSelect(@1,LO,RE,>,<=)@
@:JoinSelect(@1,LE,RE,>=,<=)@
@:JoinSelect(@1,LO,RO,>,<)@
@:JoinSelect(@1,LE,RO,>=,<)@
@

@= JoinSelectFunctions
str
CRKjoinSelectBounds_@1(int *res, int *left, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{
        if (*(@1*)low == int_nil);
        else if (*(@1*)hgh == int_nil);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	JoinSelectRange_LE_RE_@1(res, left, right, low, hgh);
		else 
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	JoinSelectRange_LE_RO_@1(res, left, right, low, hgh);
		else 
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	JoinSelectRange_LO_RO_@1(res, left, right, low, hgh);
		else 
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	JoinSelectRange_LE_RE_@1(res, left, right, low, hgh);
	}
        return MAL_SUCCEED;
}

@
         
@c
@:crackOperations(chr)@
@:crackOperations(sht)@
@:crackOperations(int)@
@:crackOperations(lng)@
@:crackOperations(flt)@
@:crackOperations(dbl)@

@:SelectFunctions(chr)@
@:SelectFunctions(sht)@
@:SelectFunctions(int)@
@:SelectFunctions(lng)@
@:SelectFunctions(flt)@
@:SelectFunctions(dbl)@

@:JoinSelectOperations(chr)@                        
@:JoinSelectOperations(sht)@                        
@:JoinSelectOperations(int)@                        
@:JoinSelectOperations(lng)@                        
@:JoinSelectOperations(flt)@                        
@:JoinSelectOperations(dbl)@                        

@:JoinSelectFunctions(chr)@
@:JoinSelectFunctions(sht)@
@:JoinSelectFunctions(int)@
@:JoinSelectFunctions(lng)@
@:JoinSelectFunctions(flt)@
@:JoinSelectFunctions(dbl)@
