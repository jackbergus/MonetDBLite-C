@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f crackers
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006
@* Cracker index


StM: This text is obsolete as of April 26, 2006, and needs to be updated!


A cracker index is a volatile datastructure which acts as
a non-dense index into a BAT. The index is incrementally built
based on the fragments needed by queries.
Each select operation results in a partial re-clustering of the tuples
such that the result set is a consecutive memory area in the BAT.
This set can be returned as a BAT view for further processing.

A cracker index is created with the command @code{crackers.new}
and destroyed using @code{crackers.destroy}.
Multiple calls to create/destroy the cracker index on the same
argument are ignored.

The cracker index can be created for the time being on
tail columns of type {int,lng,dbl,flt,time}. The head
is always of type @code{oid}.

Once a cracker index exist, portions can be extracted 
using @code{crackers.select} and @code{crackers.uselect},
which semantically behave as their algebraic counterparts.
Both operations may have to glue pieces from the cracked
bat to satisfy the BAT semantics.

Qst: are these operators overloaded to initiate a crack
operation first?

In addition, the cracker index can be used to feed a generator
for pieces satisfying a range constraint.
A cracker partition is indicated by the index in the cidx
table. It can be used to initialize a BATview to represent
the partition during processing.

Repeated cracking leads to an ever growing index. This process
can be stopped by setting the granule size,
i.e.  the minimum number of tuples in each piece,
or the maximum number of pieces. 
The operations @code{crackers.setGranule()} and @code{crackers.setLimit()}
implement them. The default is to allow an arbitrary number pieces
with arbitrary sizes.

Pitfalls.
The policy in the kernel to take a copy of a BAT when there
is a need to write to it and there are also views around becomes 
an issue. Instead, it should isolate the views, giving them a
private copy. This way the underlying base table becomes free to re-arrange.
This issue is postponed to the future.

The cracker module should be prepared to deal with any of the base types.
For strings this becomes an issue.

This module contains the experimental code to play with cracked tables.
It supports int-based bats for the time being only.

The current implementation uses an unprotected cracker
index. This limits the interface at slightly more overhead
of searching the cracker index upon each call.

Initial performance indicates around 70 ms processing
overhead on a 1M bat during the first crack operation.
(Athlon 1400, 1Gb)

@= crackfcn
command printCrackerIndex(b:bat[:any_1,:@1]):void
address CRKprintCrackerIndex
comment "Print the cracker index of b";

command printCrackerBAT(b:bat[:any_1,:@1]):void
address CRKprintCrackerBAT
comment "Print the cracker BAT of b";

command printCrackerInsertions(b:bat[:any_1,:@1]):void
address CRKprintCrackerInsertions
comment "Print the pending insertions of the cracker BAT of b";

command insertionsForget(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertions_Forget 
comment "Append c to the cracked bat of b and completelly forget the cracker index";

command insertionsPartiallyForget(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertions_PartiallyForget_@1 
comment "Append c to the cracked bat of b and partially forget the cracker index, i.e., forget only what is affected";

command insertionsForce(b:bat[:any_1,:@1], c:bat[:any_1,:@1], deleteNodes:bit):void
address CRKmergeInsertions_Force_@1 
comment "Merge the insertions bat with the cracker bat and update the cracker index";

command insertionsBForce(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_Force_@1 
comment "Merge the insertions bat with the cracker bat and update the cracker index";

command insertionsOnNeed(b:bat[:any_1,:@1], c:bat[:any_1,:@1], deleteNodes:bit):void
address CRKmergeInsertions_OnNeed 
comment "Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future";

command insertionsBOnNeed(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_OnNeed 
comment "Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future";

command insertionsOnNeedGradually(b:bat[:any_1,:@1], c:bat[:any_1,:@1], deleteNodes:bit):void
address CRKmergeInsertions_OnNeedGradually 
comment "Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future";

command insertionsBOnNeedGradually(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_OnNeedGradually 
comment "Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future";

command insertionsOnNeedGraduallyRipple(b:bat[:any_1,:@1], c:bat[:any_1,:@1], deleteNodes:bit):void
address CRKmergeInsertions_OnNeedGraduallyRipple 
comment "Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future";

command insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:@1], c:bat[:any_1,:@1]):void
address CRKmergeInsertionsB_OnNeedGraduallyRipple 
comment "Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future";

command verifyCrackerIndex(b:bat[:any_1,:@1]):void
address CRKverifyCrackerIndex_@1 
comment "Check the cracker index and column, whether each value is in the correct chunk";
@

@mal
module crackers;

@:crackfcn(chr)@
@:crackfcn(sht)@
@:crackfcn(int)@
@:crackfcn(lng)@
@:crackfcn(flt)@
@:crackfcn(dbl)@
@:crackfcn(date)@

@-

A limited set of relational operators is overloaded to deal with
cracked BATs. The relational select collects the pieces
into a single BAT. Preferably using a BATview, otherwise
the pieces are combined to form a new BAT.

@= crackAlgebra
command select(b:bat[:any_1,:@1],l:@1,h:@1):bat[:any_2,:@1]
address CRKselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:any_1,:@1],l:@1):bat[:any_2,:@1]
address CRKselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_6,:@1]
address CRKselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:@1,h:@1):bat[:any_2,:void]
address CRKuselect_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:@1):bat[:any_2,:void]
address CRKuselectValue_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@1],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_6,:void]
address CRKuselectBounds_@1
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

@:joinuselect(@1,v,v)@
@:joinuselect(@1,v,)@
@:joinuselect(@1,,v)@
@:joinuselect(@1,,)@
@
@= joinuselect
command joinuselect( right:bat[:@2oid,:@1], l:@1, h:@1, li:bit, hi:bit, left:bat[:@3oid,:void] ):bat[:oid,:void]
address CRKjoinSelectDefault_@1
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	The result is a new [:oid,:void] BAT.";

command joinuselect( right:bat[:@2oid,:@1], l:@1, h:@1, li:bit, hi:bit, left:bat[:@3oid,:void], inPlace:bit , isForeignKey:bit):bat[:oid,:void]
address CRKjoinSelectBounds_@1
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	If inPlace is TRUE (and left has an OID head and is not a BAT-view), we operate in-place,
	overwriting left and returning it as result. Otherwise, the result is a new [:oid,:void] BAT.
	If isForeignKey is TRUE, we assume that each tuple from left finds a match in right,
	and hence skip the respective check. 
	(NOTE: This may lead to CRASHES, if isForeignKey is incorrectly passed as TRUE!)";
@
@mal
@:crackAlgebra(chr)@
@:crackAlgebra(sht)@
@:crackAlgebra(int)@
@:crackAlgebra(lng)@
@:crackAlgebra(flt)@
@:crackAlgebra(dbl)@
@:crackAlgebra(date)@

@-
Direct access to the core cracking routines for cracking a complete BAT;
mainly for testing/debugging.
@
@= crackO
command zcrackOrdered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackOrderedZero_@1
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackOrderedOne_@1
comment "Break a BAT into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackOrderedTwo_@1
comment "Break a BAT into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackOrderedThree_@1
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

@
@= crack
command zcrackUnordered (b:bat[:oid,:@1], mid:@1) :bat[:oid,:@1]
address CRKcrackUnorderedZero_@1
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered (b:bat[:oid,:@1], low:@1, hgh:@1) :bat[:oid,:@1]
address CRKcrackUnorderedThree_@1
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@
@= crack_validate
command zcrackOrdered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackOrderedZero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackOrderedOne_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackOrderedTwo_validate_@1
comment "Validate whether a BAT is correctly broken into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackOrderedThree_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackUnordered_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrackUnorderedZero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrackUnorderedThree_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@
@mal
@:crack(chr)@
@:crack(sht)@
@:crack(int)@
@:crack(lng)@
@:crack(flt)@
@:crack(dbl)@
@:crack(date)@
@:crackO(chr)@
@:crackO(sht)@
@:crackO(int)@
@:crackO(lng)@
@:crackO(flt)@
@:crackO(dbl)@
@:crack_validate(chr)@
@:crack_validate(sht)@
@:crack_validate(int)@
@:crack_validate(lng)@
@:crack_validate(flt)@
@:crack_validate(dbl)@
@-
@{
@- include prelude.mx
@* Implementation
The implementation is geared at early experimentation
without all the details to make the code robust and
ultra fast.

@h
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/

typedef struct {
	int bid;   /* the cracked bat */
	int cbid;  /* the copy on which we actually crack */
	int cid;   /* the index for this cracked bat */
} CrackIndex;

struct Node{
        lng	      position;
	bit 	      inclusive;	
        struct Node  *left;
        struct Node  *right;
        int	      height;
	bit	      head;
	bit	      deleted;
};

typedef struct {
	int 		bid;   		/* the stable bat */
	int 		cbid;   	/* the cracker bat, i.e., the copy on which we actually crack */
	int 		cid;   		/* the index for this cracked bat */
	int 		iid;   		/* pending insertions bat */
	struct Node 	*Tree; 		/* the AVL tree */
	bit		reCreate;	/* indicates whether we need to recreate the index if we chose to forget it */
	sht		mergeInsertions;/* indicates wether there are insertions to merge -->  -1 no insertions, 
												0 complete merge, 
												1 gradually,
												2 ripple */ 
	bit 		deleteNodes;    /* if true, merging operations will delete nodes form the index if it makes things easier */
	bit 		mergeFromTheEnd;
} CrackTreeIndex;

mal_export str CRKselect(int *vid, int *bid, int *low, int *hgh);
mal_export str CRKselectValue(int *vid, int *bid, int *value);
mal_export str CRKuselect(int *vid, int *bid, int *low, int *hgh);
mal_export str CRKuselectValue(int *vid, int *bid, int *value);

mal_export str CRKprintCrackerIndex(int *k, int *bid);
mal_export str CRKprintCrackerBAT(int *k, int *bid);
mal_export str CRKprintCrackerInsertions(int *k, int *bid);
mal_export str CRKmergeInsertions_Forget(int *k, int *bid, int *new);
mal_export str CRKmergeInsertions_OnNeed(int *k, int *bid, int *new, bit *deleteNodes);
mal_export str CRKmergeInsertionsB_OnNeed(int *k, int *bid, int *new);
mal_export str CRKmergeInsertions_OnNeedGradually(int *k, int *bid, int *new, bit *deleteNodes);
mal_export str CRKmergeInsertionsB_OnNeedGradually(int *k, int *bid, int *new);
mal_export str CRKmergeInsertions_OnNeedGraduallyRipple(int *k, int *bid, int *new, bit *deleteNodes);
mal_export str CRKmergeInsertionsB_OnNeedGraduallyRipple(int *k, int *bid, int *new);
#endif /* _CRACKERS_H */

@c
#include "mal.h"
#include "mal_exception.h"
#include "crackers.h"
#include "mtime.h"
#include "bat5.h"

#define MAXPIECE 1024*100

static int maxCrackMap = 0;

static CrackIndex *Index;
static CrackTreeIndex *TreeIndex;
bit IndexType = 1; /* 1 used for tree index, 0 used for bat index */
int IndexEntries = 220000; /* initial size used for the bat that stores index values*/

/* temp variables, used to test effect of stop updating the index, they operate only on one cracker bat */
int IndexSize = 0;
int IndexStop = 250000;

int
Height(struct Node * x){
        if( x == NULL )
                return -1;
        else
                return x->height;
}

struct Node *
SingleRotateLeft(int m, struct Node * node){
        struct Node * l;
	int nodeLh,nodeRh,lh;

        l = node->left;
        node->left = l->right;
        l->right = node;
	
	if (node->head == TRUE){
		node->head = FALSE;
		l->head = TRUE;
		TreeIndex[m].Tree = l;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	lh = Height(l->left);
     
	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        l->height = (lh > node->height ? lh : node->height) + 1;

        return l;
}

struct Node *
SingleRotateRight(int m, struct Node * node){
        struct Node * r;
	int nodeLh,nodeRh,rh;

        r = node->right;
        node->right = r->left;
        r->left = node;

	if (node->head == TRUE){
		node->head = FALSE;
		r->head = TRUE;
		TreeIndex[m].Tree = r;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	rh = Height(r->right);
     
	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        r->height = (rh > node->height ? rh : node->height) + 1;

        return r;
}

struct Node *
DoubleRotateLeft(int m, struct Node * node){
            node->left = SingleRotateRight(m, node->left);
            return SingleRotateLeft(m, node);
}

struct Node *
DoubleRotateRight(int m, struct Node * node){
            node->right = SingleRotateLeft(m, node->right);
            return SingleRotateRight(m, node);
}


/* searching into the tree */

/* get the previous node in the index (in terms of value), the result can be any node, deleted or no */
struct Node *
getPreviousNodeAny(struct Node * current){

	struct Node *res = NULL;

	if (current->left !=NULL){
		res = current->left;
		while(res->right != NULL)
			res = res->right;
	}

	return res;	
}

/* get the next node in the index (in terms of value), the result can be any node, deleted or no */
struct Node *
getNextNodeAny(struct Node * current){

        struct Node *res = NULL;

        if (current->right !=NULL){
                res = current->right;
                while(res->left != NULL)
                        res = res->left;
        }

        return res;
}

struct Node * 
getP(struct Node * current){
                        
        struct Node *res = NULL;

	if (current->right != NULL)
		res = getP(current->right);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else 
		if (current->left != NULL)
			res = getP(current->left);
	}
	return res; 
}

struct Node * 
getN(struct Node * current){
                        
        struct Node *res = NULL;

	if (current->left != NULL)
		res = getN(current->left);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else 
		if (current->right != NULL)
			res = getN(current->right);
	}
	return res; 
}

/* get the previous node in the index (in terms of value), the result can be only a non deleted node */
struct Node *
getPreviousNode(struct Node * current, struct Node * previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return res;
        
}

/* get the next node in the index (in terms of value), the result can be only a non deleted node */
struct Node *
getNextNode(struct Node * current, struct Node * next){

        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return res;
}  

lng
getPreviousPosition(struct Node * current, BAT *b, BUN base, int xx, lng previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return *(lng*)BUNhloc(b,base + ((res->position) * xx));
        
}

lng     
getNextPosition(struct Node * current, BAT *b, BUN base, int xx, lng next){

        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return *(lng*)BUNhloc(b,base + ((res->position) * xx));
}  

@= TreeOperations

bit
GetLow_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next){

	BUN cur,curValue;
 
	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_LT(&x,curValue,@3@1) ){	
			if (current->left == NULL){
        	                *p1 = previous;
                	        *p2 = getNextPosition(current, b, base,  xx, next);
                       	 	return 0;
                	} else
                        	/* check for the left one */
                        	return GetLow_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, getNextPosition(current, b, base,  xx, next));
		}
		if (current->right == NULL){
               	 	*p1 = getPreviousPosition(current, b, base,  xx, previous);
			*p2 = next;
			return 0;
		} else 	
			return GetLow_@1(x, inclusive, current->right, b, base, xx, p1, p2, getPreviousPosition(current, b, base,  xx, previous), next);
	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) ){
		*p1 = *(lng*)BUNhloc(b, cur);	
		return 1;
	}	

       	if ( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL){
			/* crack from the begining of the bat */
                	*p1 = previous;
			*p2 = *(lng*)BUNhloc(b, cur);
			return 0;
		} else
			/* check for the left one */
      			return GetLow_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, *(lng*)BUNhloc(b, cur));
			
	}

	if (current->right == NULL){
		/* crack until the end of the bat */
                *p1 = *(lng*)BUNhloc(b, cur);
		*p2 = next;
		return 0;
	} else 	
		/* check for the right one */
		return GetLow_@1(x, inclusive, current->right, b, base, xx, p1, p2, *(lng*)BUNhloc(b, cur), next);
}

bit
GetHgh_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next){

        BUN cur,curValue;	

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_GT(&x,curValue,@3@1) ){
			 if (current->right == NULL){
                       	 	*p1 = getPreviousPosition(current, b, base,  xx, previous);
                        	*p2 = next;
                        	return 0;
                	} else
                        	return GetHgh_@1(x, inclusive, current->right, b, base, xx, p1, p2, getPreviousPosition(current, b, base,  xx, previous), next);
		}
		if (current->left == NULL){
               	 	*p1 = previous;
                	*p2 = getNextPosition(current, b, base,  xx, next);
               	 	return 0;
	        } else
                	return GetHgh_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, getNextPosition(current, b, base,  xx, next));

	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE))){
		*p2 = *(lng*)BUNhloc(b, cur);	
		return 1;
	}	

	if ( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL){
			/* crack until the end of the BAT if this was the last index entry but the needed value is still bigger */
			*p1 = *(lng*)BUNhloc(b, cur);
                	*p2 = next; 
			return 0;
		} else
			/* check for the right one */
      			return GetHgh_@1(x, inclusive, current->right, b, base, xx, p1, p2, *(lng*)BUNhloc(b, cur), next);
	}

	/* then it is smaller than the current value */
	if (current->left == NULL){
		/* crack from the beginning of the bat until here */
		*p1 = previous;
               	*p2 = *(lng*)BUNhloc(b, cur);
		return 0;
	} else	
		/* check for the left one */	
		return GetHgh_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, *(lng*)BUNhloc(b, cur));	
}


struct Node *
InsertTree_@1(int m, int indexPosition, @1 value, bit inclusive, lng crackPosition, struct Node * current, BAT * b, BUN base, int xx){
	
	BUN cur,curValue,curPosition, Lchild,LchildValue,Rchild,RchildValue;
	int lh,rh;
	bit use;
	struct Node *temp;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
                current->position = indexPosition; 
                current->inclusive = inclusive; 
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		goto end;
        }

	cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

	/* reuse if possible nodes that have been deleted with lazy deletion */
	use = FALSE;
	if (current->deleted == TRUE){
		if (current->left != NULL && current->right != NULL){
			Lchild = base + (((getPreviousNodeAny(current))->position) * xx);
                        LchildValue = BUNtloc(b, Lchild);
			Rchild = base + (((getNextNodeAny(current))->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);
			
			if ( ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && inclusive == TRUE && current->right->inclusive == FALSE))  && 
			     ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && inclusive == FALSE && current->left->inclusive == TRUE) ) )
				use = TRUE;
			
		} else 
		if (current->left != NULL && current->right == NULL){
			Lchild = base + (((getPreviousNodeAny(current))->position) * xx);
                        LchildValue = BUNtloc(b, Lchild);

			if ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && inclusive == FALSE && current->left->inclusive == TRUE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right != NULL){
			Rchild = base + (((getNextNodeAny(current))->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);
			
			if ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && inclusive == TRUE && current->right->inclusive == FALSE) )
				use = TRUE;
		} else 
		if (current->left == NULL && current->right == NULL)
				use = TRUE;

		if (use == TRUE){
        		curPosition = BUNhloc(b, cur);
			*(lng*)curPosition = crackPosition;
                        *(@1*)curValue = value;
			current->inclusive = inclusive;
                        current->deleted = FALSE;
                        return NULL;
		}
	}

        if ( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == TRUE && current->inclusive == FALSE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->left, b, base, xx)) == NULL ) 
                	return NULL;

		current->left = temp;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + ((current->left->position) * xx);
        		LchildValue = BUNtloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && inclusive == TRUE && current->left->inclusive == FALSE) )
                        	current = SingleRotateLeft(m, current);
                    	else
                        	current = DoubleRotateLeft(m, current);
		}
        } else
        if ( @2_GT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == FALSE && current->inclusive == TRUE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->right, b, base, xx)) == NULL )
			return NULL;

                current->right = temp; 

                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + ((current->right->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && inclusive == FALSE && current->right->inclusive == TRUE) )
                        	current = SingleRotateRight(m, current);
                    	else
                        	current = DoubleRotateRight(m, current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

struct Node *
findNodeH_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * next){

        BUN cur,curValue;	

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE)) )
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;

        if( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL)
			return next;
		else
      			return findNodeH_@1(x, inclusive, current->right, b, base, xx, next);
	}

	if (current->left == NULL)
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;
	else		
		return findNodeH_@1(x, inclusive, current->left, b, base, xx, (current->deleted == TRUE) ? getNextNode(current, next) : current);	
}

struct Node *
findNodeL_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * prev){

	BUN cur,curValue;
 
	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) )
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;

        if( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL)
			return prev;
		else
			return findNodeL_@1(x, inclusive, current->left, b, base, xx, prev);
	}

	if (current->right == NULL)
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;
	else
		return findNodeL_@1(x, inclusive, current->right, b, base, xx, (current->deleted == TRUE) ? getPreviousNode(current, prev) : current);
}

void 
PartiallyLazyFreeAVLTree_@1(struct Node * current, @1 value, BAT *b, BUN base, int xx){

	BUN cur,curValue;

        cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

	if (current->left != NULL)
		PartiallyLazyFreeAVLTree_@1(current->left, value, b, base, xx);

	if (current->right != NULL)
		PartiallyLazyFreeAVLTree_@1(current->right, value, b, base, xx);

	if( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && current->inclusive == FALSE) )
		current->deleted = TRUE;
	return;
}
@

@c
@:TreeOperations(chr,simple,)@
@:TreeOperations(sht,simple,)@
@:TreeOperations(int,simple,)@
@:TreeOperations(lng,simple,)@
@:TreeOperations(flt,simple,)@
@:TreeOperations(dbl,simple,)@
@:TreeOperations(date,atom,TYPE_)@

void 
FreeAVLTree(struct Node * current){

	if (current->left != NULL)
		FreeAVLTree(current->left);

	if (current->right != NULL)
		FreeAVLTree(current->right);

	GDKfree(current);
		
	return;
}

int     
existsIndex(int bid)
{       
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (Index[i].bid == bid)
			return i;
	return -1;
}

int     
existsTreeIndex(int bid)
{       
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (TreeIndex[i].bid == bid)
			return i;
	return -1;
}

@= CreateNewIndex

int     
newTreeIndex_@1(int bid, int cbid)
{       
	int i, freemap = -1, units = 1024;
	BAT *b;
	
	for (i = 0; i < maxCrackMap; i++)
		if (TreeIndex[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		TreeIndex[freemap].bid = bid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackTreeIndex *x;
        
		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackTreeIndex *) GDKmalloc(sizeof(CrackTreeIndex) * units);
		memset(x, 0, sizeof(CrackTreeIndex) * units);
		if (TreeIndex) { 
			fprintf(stderr, "reallocate index \n");
			memcpy(x, TreeIndex, sizeof(CrackTreeIndex) * i);
			GDKfree(TreeIndex);
		}
		TreeIndex = x;
		maxCrackMap = units;
	}

	TreeIndex[i].bid = bid;
	TreeIndex[i].cbid = cbid;
	b = BATnew(TYPE_lng, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	TreeIndex[i].cid = b->batCacheid; 
	TreeIndex[i].iid = -1; 
	TreeIndex[i].mergeInsertions = -1;
	TreeIndex[i].reCreate = 0;
	TreeIndex[i].Tree = NULL;
	TreeIndex[i].deleteNodes = FALSE;
	return i;
}

void 
reCreateMap_@1(int position){
	BAT *b;
	b = BATnew(TYPE_lng, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	TreeIndex[position].cid = b->batCacheid;
	TreeIndex[position].reCreate = 0;
	
	return; 
}

int     
newIndex_@1(int bid, int cbid)
{       
	int i, freemap = -1, units = 1024;
	BAT *b;
	
	for (i = 0; i < maxCrackMap; i++)
		if (Index[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		Index[freemap].bid = bid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackIndex *x;
        
		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackIndex *) GDKmalloc(sizeof(CrackIndex) * units);
		memset(x, 0, sizeof(CrackIndex) * units);
		if (Index) { 
			fprintf(stderr, "reallocate index \n");
			memcpy(x, Index, sizeof(CrackIndex) * i);
			GDKfree(Index);
		}
		Index = x;
		maxCrackMap = units;
	}

	Index[i].bid = bid;
	Index[i].cbid = cbid;
	b = BATnew(TYPE_lng, TYPE_@1, 220000);	/*todo: size*/
	BBPkeepref(b->batCacheid);
	Index[i].cid = b->batCacheid; 
	return i;
}
@

@c
@:CreateNewIndex(chr)@
@:CreateNewIndex(sht)@
@:CreateNewIndex(int)@
@:CreateNewIndex(lng)@
@:CreateNewIndex(flt)@
@:CreateNewIndex(dbl)@
@:CreateNewIndex(date)@

void
printCrackerIndex(int bid)
{
	int i = existsTreeIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(TreeIndex[i].cid));
}

str
CRKprintCrackerIndex(int *k, int *bid)
{
	(void)k;
	printCrackerIndex(*bid);
	return MAL_SUCCEED;
}

void
printCrackerBAT(int bid)
{
	int i = existsTreeIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(TreeIndex[i].cbid));
}

void
printCrackerInsertions(int bid)
{
	int i = existsTreeIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (TreeIndex[i].iid > 0)
		BATprint(BATdescriptor(TreeIndex[i].iid));
}

str
CRKprintCrackerBAT(int *k, int *bid)
{
	(void)k;
	printCrackerBAT(*bid);
	return MAL_SUCCEED;
}

str
CRKprintCrackerInsertions(int *k, int *bid)
{
	(void)k;
	printCrackerInsertions(*bid);
	return MAL_SUCCEED;
}

@= insertIndexElement
	*(lng*) @2 = @4;	
	*(@1 *) @3 = @5;	
	(b)->batBuns->free += xx;
        (b)->batCount ++; 
@

@= InsertIndexElements
void            
addTreeIndex_@1(int m, @1 *value, bit inclusive, lng index, BAT * b)
{       
	BUN ph,pt,base;
        int xx = BUNsize(b);
	ph = BUNhloc(b, BUNlast(b));
	pt = BUNtloc(b, BUNlast(b));

        if (BATcount(b) == 0){

                @:insertIndexElement(@1, BUNhloc(b, BUNfirst(b)), BUNtloc(b, BUNfirst(b)), index, *value)@
		TreeIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                TreeIndex[m].Tree->position = 0;
                TreeIndex[m].Tree->inclusive = inclusive;
                TreeIndex[m].Tree->height = 0;
                TreeIndex[m].Tree->left = NULL;
                TreeIndex[m].Tree->right = NULL;		
                TreeIndex[m].Tree->head = TRUE;	
                TreeIndex[m].Tree->deleted = FALSE;	

                return;             
        }

	base = BUNhloc(b, BUNfirst(b));
        if ( (InsertTree_@1(m, BATcount(b), *value, inclusive, index, TreeIndex[m].Tree, b, base, xx)) != NULL ) {
		/* use a new BUN only if we cannot reuse a previously deleted one */
		@:insertIndexElement(@1, ph, pt, index, *value)@ 
	}
}

void 
addOne_@1(int i, @1 *value, lng index, BUN p)
{
	BAT *b;
        if ((b = BATdescriptor(Index[i].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return;
        }

	int xx = BUNsize(b);
	if (BATcount(b) == 0){
		@:insertIndexElement(@1,BUNhloc(b, BUNfirst(b)), BUNtloc(b, BUNfirst(b)), index, *value)@
		return; 		
	}
	/*todo: check BAT size*/

	BUN ph = BUNhloc(b, p);
	BUN pt = BUNtloc(b, p);
	
	if (p == BUNlast(b)){ /*Insert at the end if everything is smaller than the new value*/
		@:insertIndexElement(@1, ph, pt, index, *value)@
		return;
	}

	/*Else we have to sift some buns to put the new one to the right position*/
	BUN wh = BUNhloc(b, BUNlast(b));
	BUN wt = BUNtloc(b, BUNlast(b));
	BUN rh = wh - xx, rt = wt - xx;
	if (@2_EQ(pt,value,@3@1) && index > 0){ /*negative index values inidicate non inclusive bounds so they should be always first*/
		ph += xx;
		pt += xx;
	} 
	for (;rt>=pt;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
		*(lng*)wh = *(lng*)rh;
		*(@1 *)wt = *(@1 *)rt;
	}
	@:insertIndexElement(@1, ph, pt, index, *value)@
	BBPunfix(b->batCacheid);
}	

void 
addTwo_@1(int i, @1 *valueA, lng indexA, BUN p2, @1 *valueB, lng indexB, BUN p)
{
	BAT *b;
        if ((b = BATdescriptor(Index[i].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return;
        }

	/*todo: check BAT size*/
	int xx = BUNsize(b);
	if (BATcount(b) == 0){
		BUN ph = BUNhloc(b, BUNfirst(b));
		BUN pt = BUNtloc(b, BUNfirst(b));
		@:insertIndexElement(@1, ph, pt, indexA, *valueA)@
		ph += xx;
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
		return; 		
	}

	BUN ph = BUNhloc(b, p);
	BUN pt = BUNtloc(b, p);
	BUN wh = BUNhloc(b, BUNlast(b)+xx);
	BUN wt = BUNtloc(b, BUNlast(b)+xx);
	BUN rh = wh - 2*xx, rt = wt - 2*xx;
        BUN p2h = BUNhloc(b, p2);
        BUN p2t = BUNtloc(b, p2);
	if (p == BUNlast(b)){
		ph += xx; /* sift one more position to make room for pair A too*/
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
	}
	else{   /*Else we have to sift some buns to put the new one to the right position*/
		if (@2_EQ(pt,valueB,@3@1) && indexB > 0){
			ph += xx;
			pt += xx;
		} 
		for (;rt>=pt;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
			*(lng*)wh = *(lng*)rh;
			*(@1 *)wt = *(@1 *)rt;
		}
		ph += xx; /* sift one more position to make room for pair A too*/
		pt += xx;
		@:insertIndexElement(@1, ph, pt, indexB, *valueB)@
	}
        wh -= xx;
        wt -= xx;
        if (@2_EQ(p2t,valueA,@3@1) && indexA > 0){
                p2h += xx;
                p2t += xx;
        }
        for (;rt>=p2t;rh-=xx,wh-=xx,rt-=xx,wt-=xx){
                *(lng*)wh = *(lng*)rh;
                *(@1 *)wt = *(@1 *)rt;
        }
        @:insertIndexElement(@1, p2h, p2t, indexA, *valueA)@
	BBPunfix(b->batCacheid);
}	
@

@c
@:InsertIndexElements(chr,simple,)@
@:InsertIndexElements(sht,simple,)@
@:InsertIndexElements(int,simple,)@
@:InsertIndexElements(lng,simple,)@
@:InsertIndexElements(flt,simple,)@
@:InsertIndexElements(dbl,simple,)@
@:InsertIndexElements(date,atom,TYPE_)@


@-
The core cracking routines.

@= moveOrdered
	while (@1 @6 ){
		@2 @4= xx;
		@3 @4= xx;
		@5
	}
@

@= OThree
	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)ct @5){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
		
		}
		else{
			scr_h[mids] = *(oid*)tmph;
			scr_t[mids] = *(@1* )tmpt;				
			mids--;	
		}
		tmpt @2= xx;
		tmph @2= xx;
		while (tmpt @3 ht && *(@1*)tmpt @5){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	tmph = hh;
	tmpt = ht;
	ct @2= xx*((scrH-mids)+hil);
	for(; tmpt @7 ct; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
	}
	int i;
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}
	i = mids + 1;
	for (; i <= scrH; i++){
		 if (*(@1*)tmpt @5){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
@

@= crackInThreeOrderedPieces
str
CRKcrackOrderedThree_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last)
{
	BUN hh, ht, tmpt, tmph;
	oid *scr_h;
	@1  *scr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @4 low,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht<=tmpt)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	int scrH = scr_size-1;	
	int hil = 0, mids = scrH;
	BUN ch = tmph, ct = tmpt; 
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	int probe = 25;
	BUN t = tmpt, s = tmpt+(2*probe*xx);
	int j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;

	if (j > probe){
		ch = tmph; ct = tmpt; 
		@:OThree(@1,+,<=,@4 low,@7 hgh,-,>=)@
	}
	else{  
		ch = hh; ct = ht; 
		BUN fh = tmph, ft = tmpt;
		tmph = hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OThree(@1,-,>=,@7 hgh,@4 low,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}

str
CRKcrackOrderedThreeL_@2_@3_@1(BAT *b, @1 low, @1 hgh, lng idx_first, lng idx_last, lng *posl, lng *posh)
{
	BUN lh, lt, hh, ht, tmpt, tmph;
	oid *scr_h,*mscr_h;
	@1  *scr_t,*mscr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @4 low,lh,lt,+,lowShrinked++;,&& lt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht>=lt)@

	/*These are different cases. For now just make sure that the result will be empty.
		todo: when the index will learn from empty results return the appropriate information*/
	
	if (lowShrinked == scr_size) {
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == scr_size){
		*posl =  1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	/*Middle piece is empty and lt = ht + 1*/
	if (lowShrinked + hghShrinked == scr_size){
		*posl =  BUNindex(b,lt);
		*posh =  BUNindex(b,ht);
		return MAL_SUCCEED;
	}

	int scrH = scr_size-1;	
	int hp = 0, hil = 0, mids = scrH, mmids = 0;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	mscr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	mscr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	int probe = 100;
	BUN t = lt, s = lt+(2*probe*xx);
	int j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;
	lng pos1, pos2;
	if (j > probe){
		tmph = lh;
		tmpt = lt;	
		@:OThreeLateCopying(@1,+,<=,@4 low,@7 hgh,-,>=,@5,@6)@
		*posl = pos1;
		*posh = pos2;
	}
	else{  
		tmph = hh;
		tmpt = ht;	
		BUN fh = lh, ft = lt;
		lh = hh; lt = ht;
		hh = fh; ht = ft;
		@:OThreeLateCopying(@1,-,>=,@7 hgh,@4 low,+,<=,@5,@6)@
		*posl = pos2;
		*posh = pos1;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@
@= OThreeLateCopying
	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	BUN tmp1 = lt, tmp2;
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)lt @5){
				scr_h[hil] = *(oid*)lh;
				scr_t[hil] = *(@1* )lt;				
				hil++;	
			}
			if (*(@1*)lt @8 low && *(@1*)lt @9 hgh){
				scr_h[mids] = *(oid*)lh;
				scr_t[mids] = *(@1* )lt;				
				mids--;	
			}
			*(oid*)lh = *(oid*)tmph;
			*(@1 *)lt = *(@1 *)tmpt;
			lh @2= xx;
			lt @2= xx;
		}
		hp++;
		tmpt @2= xx;
		tmph @2= xx;
		while (*(@1*)tmpt @5 && tmpt @3 ht){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	
	pos1 = BUNindex(b,lt);

	tmph = hh;
	tmpt = ht;
	tmp2 = lt;
	tmp1 @2= xx*(hp+hil);
	for(; tmpt @7 tmp1; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
	}
	int i;
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}

	pos2 = BUNindex(b,tmpt);

	i = 0;
	for (; i < mmids; i++){
		 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = mscr_h[i];
		*(@1 *)tmpt = mscr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
	tmp2 @2= xx*(scrH-mids);
	/*todo check as in the zero case*/
	BUN mh= tmph, mt = tmpt;
	for(; tmpt @7 tmp2; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			if (mt != tmpt){
				*(oid*)mh = *(oid*)tmph;
                        	*(@1 *)mt = *(@1 *)tmpt;
			}
                        mh @6= xx;
                        mt @6= xx;
		}
	}

        i = mids+1;
        for (; i <= scrH; i++){
                 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
                if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
	        	*(oid*)mh = *(oid*)tmph;
                        *(@1 *)mt = *(@1 *)tmpt;
                        mh @6= xx;
                        mt @6= xx;
                }
                *(oid*)tmph = scr_h[i];
                *(@1 *)tmpt = scr_t[i];
                tmph @6= xx;
                tmpt @6= xx;
        }
@
@= OrderedZero
		while (tmpt @3 ht){ 
			while (*(@1*)tmpt @4 mid){
				tmpt @2=xx;
				tmph @2=xx;
			}
			if (*(@1*)ct @4 mid){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
			
			tmpt @2= xx;
			tmph @2= xx;
		}
		tmph @5= 2*xx;
		tmpt @5= 2*xx;
	
		/* Take the position where the last BUN of the left piece is. */
		*pos = BUNindex(b,ct @7);

		ct  @2= xx*hil;
		/*Extreme case where all lows(or all but one, or all but two) where in the hgh partition (or opposite depending how we move) */
		if (ct @6 tmpt ){
			if (ct == tmpt || ct == tmpt @2 xx) {
				for (int i=hil; i >=0 ; i--){
					if (*(@1*)tmpt @4 mid){
						*(oid*)hh = *(oid*)tmph;
						*(@1 *)ht = *(@1 *)tmpt;
						hh @5= xx;
						ht @5= xx;
					}	
					tmpt @5= xx;
					tmph @5= xx;
				}
				for (int i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}

			}
			else{
				for (int i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}
			}
			return MAL_SUCCEED;
		}

		for(; tmpt @6 ct; tmph @5=xx, tmpt @5=xx){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}
		}
		for (int i=hil-1; i >=0 ; i--){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}	
			*(oid*)tmph = scr_h[i];
			*(@1 *)tmpt = scr_t[i];
			tmpt @5= xx;
			tmph @5= xx;
		}
@
@= crackInTwoOrderedPieces
str
CRKcrackOrderedZero_@2_@1(BAT *b, @1 mid, lng idx_first, lng idx_last, lng *pos)
{
	BUN hh, ht, tmpt, tmph;
	oid *scr_h;
	@1  *scr_t;
	int hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @3 mid,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @4 mid,hh,ht,-,hghShrinked++;,&& ht>=tmpt)@
	if (lowShrinked == idx_last - idx_first +1) {
			*pos = idx_last+1;
			return MAL_SUCCEED;
	}
	if (hghShrinked == idx_last - idx_first +1){
			*pos = idx_first-1;
			return MAL_SUCCEED;
	}
	
	if (ht == tmpt + xx){
		oid dh = *(oid*)tmph;
		@1  dt = *(@1 *)tmpt;
		*(oid*)tmph = *(oid*)hh;
		*(@1 *)tmpt = *(@1 *)ht;

		*pos = BUNindex(b,tmpt);

		*(oid*)hh = dh;
		*(@1 *)ht = dt;

		return MAL_SUCCEED;
	}

	if (ht == tmpt - xx){
		*pos = BUNindex(b,ht);
		return MAL_SUCCEED;
	}	

	int hil = 0;
	BUN ch, ct; 
	int scr_size = (idx_last - idx_first +1 -lowShrinked -hghShrinked);
	if (scr_size >=2) scr_size = scr_size/2;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	int probe = 25;
	BUN t = tmpt, s = tmpt+(2*probe*xx);
	int j=0;
	for (;t<s;t+=xx)
		j+=*(@1*)t @3 mid;
	
	if (j > probe){
		ch = tmph; ct = tmpt; 
		@:OrderedZero(@1,+,<=,@4,-,>=, -xx)@
	}
	else{
		ch =hh; ct = ht; 
		BUN fh = tmph, ft = tmpt;
		tmph =hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OrderedZero(@1,-,>=,@3,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@

@= shuffle
        tdummy= *(@1*) @2;
        *(@1*) @2= *(@1*) @3;
        *(@1*) @3= tdummy;

        hdummy= *(oid*)((char*)@2 - b->tloc);
        *(oid*)((char*)@2 - b->tloc) = *(oid*)((char*)@3 - b->tloc);
        *(oid*)((char*)@3 - b->tloc) = hdummy;
@

@= crackInTwoUnorderedPieces
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, lng first, lng last, lng *pos){
        ptr vm, vl;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        vl= BUNtloc(b,BUNptr(b,last));

        while(vm<vl) {
                if (@5_@3(vm, &mval,@6@1))
                        vm = (ptr) ((char *) vm + xx);
                else {
                        while( @5_@4(vl, &mval,@6@1) && vl>vm)
                                vl = (ptr) ((char *) vl - xx);
                        @:shuffle(@1,vm,vl)@
                        vl = (ptr) ((char *) vl - xx);
                        vm = (ptr) ((char *) vm + xx);
                }
        }

	if (vl == vm) {
		if (@5_@4(vl, &mval,@6@1))
			*pos = BUNindex(b,(ptr) ((char *) vl - xx)); /*works for empty left piece also*/
		else{
			*pos = BUNindex(b,vl);
			if (BUNindex(b,vl)==last) /*empty right piece*/
				*pos = *pos+1;
		}
	}
	else
		*pos = BUNindex(b,vl);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPieces

str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh){
        ptr vm, vl, hmax;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        hmax = BUNtloc(b,BUNptr(b,last));
        while( @8_@7(hmax, &hgh,@9@1) && hmax>vm)
                hmax= (ptr)((char*) hmax - xx);

	if (hmax == vm){
		if (@8_@7(hmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(hmax, &low,@9@1)){  /*result is one bun*/
			*posl = *posh = BUNindex(b,hmax);
		}
		else{
			*posl = BUNindex(b,(ptr) ((char *) hmax + xx));
			*posh = BUNindex(b,hmax);
		}
		return MAL_SUCCEED;
	}

        vl = hmax;
        while( @8_@5(vl, &low,@9@1) && vl>vm){
                /* move all high values into their final place */
                if( @8_@7(vl, &hgh,@9@1)){
                        @:shuffle(@1,vl,hmax)@
                        hmax= (ptr)((char*) hmax - xx);
                }
                vl= (ptr)((char*) vl - xx);
        }
	if (vl == vm){/*left piece is empty*/
		if (@8_@7(vl, &hgh,@9@1)){
			@:shuffle(@1,vl,hmax)@
			*posl = BUNindex(b,vl);
		}
		else if (@8_@5(vl, &low,@9@1)){  
			*posl = BUNindex(b,vl);

		}
		else{
			*posl = BUNindex(b,(ptr) ((char *) vl + xx));
			
		}
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@8_@4(vm, &low,@9@1)){
                        vm = (ptr) ((char *) vm + xx);
                } else {
                        @:shuffle(@1,vm,vl)@
                        while( @8_@5(vl, &low,@9@1) && vl>vm){
                                if(@8_@7(vl, &hgh,@9@1) ){
                                        @:shuffle(@1,vl,hmax)@
                                        hmax= (ptr)((char*) hmax - xx);
                                }
                                vl = (ptr) ((char *) vl - xx);
                        }
                }
        }
	if (vm ==  BUNtloc(b,BUNptr(b,last+1))){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /*then middle piece is empty*/
		*posl = BUNindex(b,(ptr) ((char *) vl + xx));
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
	*posl = BUNindex(b,vm); 
	*posh = BUNindex(b,hmax);
     
	return MAL_SUCCEED;
}
@

@= operationsOrdered
@:crackInTwoOrderedPieces(@1,LE,<=,>)@
@:crackInTwoOrderedPieces(@1,RE,<,>=)@
@:crackInThreeOrderedPieces(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeOrderedPieces(@1,LE,RE,<,>=,<=,>)@
@:crackInThreeOrderedPieces(@1,LO,RO,<=,>,<,>=)@
@:crackInThreeOrderedPieces(@1,LE,RO,<,>=,<,>=)@


str             
CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid)
{       
        BAT *b;
        str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crack_zeroOrdered", "Cannot access descriptor");
        }
	lng pos;
        msg= CRKcrackOrderedZero_LE_@1(b,*mid, 0, BATcount(b)-1,&pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;    
        return msg;             
}  


str             
CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid)
{       
        BAT *b;
	str msg;

        if ((b = BATdescriptor(*bid)) == NULL) {
                return throwMessage("crackers.crack_oneOrdered", "Cannot access descriptor");
        }
	msg= CRKcrackOrderedThree_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);
        BBPkeepref(b->batCacheid);
        *res = *bid;    
        return msg;             
}  

str
CRKcrackOrderedTwo_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;

	if (*(@1 *) low > *(@1 *) hgh)
		return throwMessage("crackers.crack_twoOrdered", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_twoOrdered", "Cannot access descriptor");
	}

	BBPkeepref(b->batCacheid);
	*res = *bid;
	return MAL_SUCCEED;
}

str
CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
	BAT *b;
	str msg;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crack_threeOrdered", "Cannot access descriptor");
	}
	lng posl,posh;
        msg= CRKcrackOrderedThreeL_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1,&posl, &posh);
	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}

@= operations
@:crackInTwoUnorderedPieces(@1,LE,LE,GT,@2,@3)@
@:crackInTwoUnorderedPieces(@1,RE,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid)
{
        BAT *b;
        str msg;
	lng pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                return throwMessage("crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                return throwMessage("crackers.crack_zeroUnordered", "Need more clever mapping ");

        msg=CRKcrackUnorderedZero_LE_@1( b, *mid,(size_t) 0, BATcount(b)-1, &pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh)
{
        BAT *b;
        str msg;
	lng posl,posh;

        if (*(@1 *) low > *(@1 *) hgh)
                return throwMessage("crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                return throwMessage("crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                return throwMessage("crackers.crack_threeUnordered", "Need more clever mapping ");

        msg= CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}


@


@= validate_operations
@:validate_operation_Zero(@1,@2)@
@:validate_operation_One(@1,@2)@
@:validate_operation_Two(@1,@2)@
@:validate_operation_Three(@1,@2)@
@
@= validate_init_1
	BAT *b,*c,*w;
	BUN fst_bn, lst_bn, bn;
	int bs;
	size_t count[6] = {0,0,0,0,0,0};

	/* initialization */
	*res = FALSE;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.@2crack_validate", "Cannot access descriptor");
	}
	bs = BUNsize(b);
	fst_bn = BUNfirst(b);
	lst_bn = BUNlast(b);
	bn = fst_bn;
@
@= validate_init_2
	if (low > hgh) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.@2crack_validate", "illegal range");
	}
@
@= validate_checkUnordered
        while (bn < lst_bn @2 @3 ) {
                bn += bs;
                count[@1]++;
        }
@
@= validate_checkOrdered
{	oid hd = 0;
	while (bn < lst_bn && hd <= *(oid*)BUNhloc(b, bn) @2 @3 ) {
		hd = *(oid*)BUNhloc(b, bn);
		bn += bs;
		count[@1]++;
}	}
@
@= validate_check_1
	@:validate_check@5(@2, && *(@1*)BUNtloc(b, bn) @3 @4 )@
@
@= validate_check_2
	@:validate_check@7(@2, && *(@1*)BUNtloc(b, bn) @3 @4 , && *(@1*)BUNtloc(b, bn) @5 @6 )@
@
@= validate_end
	count[0] = BATcount(b);
	if (bn < lst_bn) {
		@3;
		c = BATslice(b, BUNindex(b, fst_bn), BUNindex(b, bn));
		w = BATslice(b, BUNindex(b, bn), BUNindex(b, lst_bn));
		printf("correct:\n");
		BATprint(c);
		printf("wrong:\n");
		BATprint(w);
		BBPunfix(w->batCacheid);
		BBPunfix(c->batCacheid);
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.@2crack_validate", "Invalid crack");
	}
	assert(bn == lst_bn);
	assert(count[0] == count[1] + count[2] + count[3] + count[4] + count[5]);
	BBPunfix(b->batCacheid);
	*res = TRUE;
	return MAL_SUCCEED;
@
@= validate_operation_Zero
str
CRKcrack@2Zero_validate_@1 (bit *res, int *bid, @1 *_mid)
{
	@1 mid=*_mid;
	@:validate_init_1(@1,z)@

	@:validate_check_1(@1,1,<=,mid,@2)@
	@:validate_check_1(@1,2,> ,mid,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2]);\
	)@
}
@
@= validate_operation_One
str
CRKcrack@2One_validate_@1 (int *res, int *bid, @1 *_mid)
{
	@1 mid=*_mid;
	@:validate_init_1(@1,)@

	@:validate_check_1(@1,1,< ,mid,@2)@
	@:validate_check_1(@1,2,==,mid,@2)@
	@:validate_check_1(@1,3,> ,mid,@2)@
	
	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2], (dbl)mid, count[3]);\
	)@
}
@
@= validate_operation_Two
str
CRKcrack@2Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh)
{
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,)@
	@:validate_init_2(@1,)@

	@:validate_check_1(@1,1,< ,low,@2)@
	@:validate_check_1(@1,2,==,low,@2)@
	@:validate_check_2(@1,3,> ,low,< ,hgh,@2)@
	@:validate_check_1(@1,4,==,hgh,@2)@
	@:validate_check_1(@1,5,> ,hgh,@2)@

	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |%f<tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, count[2], (dbl)low, (dbl)hgh, count[3], (dbl)hgh, count[4], (dbl)hgh, count[5]);\
	)@
}
@
@= validate_operation_Three
str
CRKcrack@2Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh)
{
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,z)@
	@:validate_init_2(@1,z)@

	@:validate_check_1(@1,1,<=,low,@2)@
	@:validate_check_1(@1,2,<=,hgh,@2)@
	@:validate_check_1(@1,3,> ,hgh,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |%f<tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, (dbl)hgh, count[2], (dbl)hgh, count[3]);\
	)@
}
@

@c
@:validate_operations(chr,Unordered)@
@:validate_operations(sht,Unordered)@
@:validate_operations(int,Unordered)@
@:validate_operations(lng,Unordered)@
@:validate_operations(flt,Unordered)@
@:validate_operations(dbl,Unordered)@
@:validate_operations(chr,Ordered)@
@:validate_operations(sht,Ordered)@
@:validate_operations(int,Ordered)@
@:validate_operations(lng,Ordered)@
@:validate_operations(flt,Ordered)@
@:validate_operations(dbl,Ordered)@
@:operations(chr,simple,)@
@:operations(sht,simple,)@
@:operations(int,simple,)@
@:operations(lng,simple,)@
@:operations(flt,simple,)@
@:operations(dbl,simple,)@
@:operations(date,atom,TYPE_)@
@:operationsOrdered(chr,simple,)@
@:operationsOrdered(sht,simple,)@
@:operationsOrdered(int,simple,)@
@:operationsOrdered(lng,simple,)@
@:operationsOrdered(flt,simple,)@
@:operationsOrdered(dbl,simple,)@
@}

@c
/* --Updates-- */


str
removeTreeIndex(int *bid){
	BAT *c;
	int position = -1;
	for (int i = 0; i < maxCrackMap; i++)
        	if (TreeIndex[i].bid == *bid){
                	position = i;	
			break;
		}
	/*if (position == -1) return; Trying to erase an index that does not exist*/

	/* Destroy index BAT */
        if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return "FAILED";
        }

	BBPunfix(c->batCacheid);
	BBPreclaim(c);
	TreeIndex[position].cid = -1;
	TreeIndex[position].reCreate = 1;

	/* Delete Tree */
	FreeAVLTree(TreeIndex[position].Tree);
	TreeIndex[position].Tree = NULL;
	
	return MAL_SUCCEED;
}

str
appendCrackerBAT(int * bid, int * new){ 
        BAT *c, *u;
	int position = -1;

	for (int i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((c = BATdescriptor(TreeIndex[position].cbid)) == NULL) 
                return throwMessage("bat.append", "Cannot access descriptor");

        if ((u = BATdescriptor(*new)) == NULL) {
                BBPreleaseref(c->batCacheid);
                return throwMessage("bat.append", "Cannot access descriptor");
        }
	
	if (BATcount(u) == 0) return MAL_SUCCEED;

        BATappend(c, u, TRUE);
       
/* printf("\n index size of bat is "SZFMT" \n", BATcount(c));
   printf("\n update size of bat is "SZFMT" \n", BATcount(u));
*/

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

struct tempBATNode{
	BAT *b;
	lng position;
	struct tempBATNode *next;
	lng values;
};

@= newTempBAT
	if ((lastPos - prevPos) == written && crkt <= crkLast) {
		if (deleteNodes == FALSE){
			temp = GDKmalloc(sizeof(struct tempBATNode));
			temp->b = BATnew(TYPE_oid,TYPE_@1,insertions+startPosition);
			temp->next = NULL;
			wscrh = BUNhloc(temp->b,BUNfirst(temp->b));
			wscrt = BUNtloc(temp->b,BUNfirst(temp->b));
			temp->values = 0;
			lastBAT->next = temp;
			lastBAT = temp;
			bats++;
		} else
			hghIndexNode->deleted = TRUE;
		hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
		if (hghIndexNode != NULL)
			lastPos = *(lng*)BUNhloc(c, idxFirst + ((hghIndexNode->position) * zz));
		else 
			lastPos = prevcrsize-1; 	
		temp->position  = lastPos;
	}
@

@= mergeInsertionsBody
        BAT *c, *u, *b;
	oid tmph;
	@1  tmpt;
	BUN insh, inst, crkh, crkt, rscrh=NULL, rscrt, wscrh, wscrt, idxFirst, cur, curValue, curPos, crkFirst, crkLast, insLast, insFirst;
	int xx, zz, bats = 0, position = -1;
	struct Node * hghIndexNode, *lowIndexNode;
	struct tempBATNode *tempBATs, *lastBAT, *temp;
	lng endPosition, extended = 0, extendedIns = 0, insDone = 0, written, pos, prevPos, lastPos, prevcrsize, insertions;
	bit takeNext;

	for (int i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*new)) == NULL) 
                return throwMessage("crackers.mergeInsertions_@1", "Cannot access insertions BAT");

	/* abort if there are no insertions to merge */	
	insertions = BATcount(u); 
	if (insertions == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}
	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL){ 
		BBPunfix(u->batCacheid);
		return throwMessage("crackers.mergeInsertions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(TreeIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		return throwMessage("crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}

	/* sort in place the insertions bat */ 
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	insFirst = BUNfirst(u);	
	prevcrsize = BATcount(b);
	xx = BUNsize(b);
	zz = BUNsize(c);
	
	(void)insFirst;
	/* make room for the new buns */
	lng needed = insertions - (((b)->batBuns->size - (b)->batBuns->free) / xx);
	if ( needed > 0 ){
                size_t ncap = BATcapacity(b) + needed;
                size_t grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                        return throwMessage("crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	temp = GDKmalloc(sizeof(struct tempBATNode));
	temp->b = BATnew(TYPE_oid,TYPE_@1,insertions+startPosition);
	temp->next = NULL;
	temp->values = 0;
	wscrh = BUNhloc(temp->b,BUNfirst(temp->b));
	wscrt = BUNtloc(temp->b,BUNfirst(temp->b));
	tempBATs = temp;
	lastBAT  = temp;

	insh 	 = BUNhloc(u,BUNfirst(u) + startPosition*xx);
	inst 	 = BUNtloc(u,BUNfirst(u) + startPosition*xx);
	insLast	 = BUNtloc(u,BUNlast(u));
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	crkLast  = BUNtloc(b,BUNlast(b)-xx);

	lowIndexNode = findNodeH_@1(*(@1*)inst, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
	if ( lowIndexNode == NULL ) 
		goto end;				
	cur      = idxFirst + ((lowIndexNode->position) * zz);
	curPos   = BUNhloc(c, cur);
	curValue = BUNtloc(c, cur);
	crkh = BUNhloc(b, crkFirst + (*(lng*)curPos) * xx + xx); 
	crkt = BUNtloc(b, crkFirst + (*(lng*)curPos) * xx + xx); 
	prevPos = *(lng*)curPos;
	hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
	if ( hghIndexNode == NULL )
		lastPos = prevcrsize - 1;
	else 
		lastPos = *(lng*)BUNhloc(c, idxFirst + ((hghIndexNode->position) * zz) );

	tempBATs->position  = lastPos;
	written = 0;
	while(inst < insLast && (@2_LT(inst,curValue,@3@1) || (@2_EQ(inst,curValue,@3@1) && lowIndexNode->inclusive == FALSE)) @4){
		@:newTempBAT(@1)@
		if (crkt > crkLast){
			*(oid*)crkh = *(oid*)insh;		
			*(@1 *)crkt = *(@1 *)inst;		
			crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
			extendedIns++;
			lastBAT->values++;
			continue;
		}
		*(oid*)wscrh = *(oid*)crkh;		
		*(@1 *)wscrt = *(@1 *)crkt;
		*(oid*)crkh = *(oid*)insh;		
		*(@1 *)crkt = *(@1 *)inst;		
		crkh+=xx; crkt+=xx; insh+=xx; inst+=xx; wscrh+=xx; wscrt+=xx;
		insDone++; written++;
		lastBAT->values++;
	}

	/* update the index */
	*(lng*)curPos = *(lng*)curPos + insDone;

	while (@5){
	
		lowIndexNode = findNodeH_@1(*(@1*)BUNtloc(tempBATs->b,BUNfirst(tempBATs->b)), TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
		if (lowIndexNode == NULL)
			break; 	

		cur = idxFirst + ((lowIndexNode->position) * zz);
		curValue = BUNtloc(c, cur);
		curPos = BUNhloc(c, cur);
		pos = 0;
		prevPos = *(lng*)curPos;

		if (crkt <= crkLast){
			crkh = BUNhloc(b, crkFirst + (*(lng*)curPos) * xx + xx); 
			crkt = BUNtloc(b, crkFirst + (*(lng*)curPos) * xx + xx); 
		}
		if (bats > 0){
			if (crkt <= crkLast){
				temp = tempBATs->next;
				pos = temp->values;
				while (temp->next != NULL){
					temp = temp->next;
					pos += temp->values;
				}
				crkh+=pos*xx;
				crkt+=pos*xx;
				prevPos += pos; 
			}
			wscrh = BUNhloc(lastBAT->b,BUNfirst(lastBAT->b)+lastBAT->values*xx);
			wscrt  = BUNtloc(lastBAT->b,BUNfirst(lastBAT->b)+lastBAT->values*xx);
			lastPos = lastBAT->position;
			takeNext = TRUE;
		} else {
			if (crkt <= crkLast){
				hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
				if ( hghIndexNode == NULL )
					lastPos = prevcrsize-1;
				else 
					lastPos = *(lng*)BUNhloc(c, idxFirst + ((hghIndexNode->position) * zz) );
			}
			wscrh = BUNhloc(tempBATs->b,BUNfirst(tempBATs->b));
			wscrt = BUNtloc(tempBATs->b,BUNfirst(tempBATs->b));
			takeNext = FALSE;
		}		


		rscrh = BUNhloc(tempBATs->b,BUNfirst(tempBATs->b));
		rscrt = BUNtloc(tempBATs->b,BUNfirst(tempBATs->b));
		int totalValues = tempBATs->values;
		/* replace at the and of this chunk all values taken from the beginning of it */
		for (written=0;written<totalValues;written++){
			@:newTempBAT(@1)@
			if (crkt > crkLast){
				*(oid*)crkh = *(oid*)rscrh;
				*(@1 *)crkt = *(@1 *)rscrt;
				crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx;
				extended++;
				if (takeNext == FALSE)
					tempBATs->values--;
				continue;
			}
			tmph = *(oid*)crkh;
			tmpt = *(@1 *)crkt;
			*(oid*)crkh = *(oid*)rscrh;
			*(@1 *)crkt = *(@1 *)rscrt;
			*(oid*)wscrh = tmph;
			*(@1 *)wscrt = tmpt;
			crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx; wscrh+=xx; wscrt+=xx;
			if (bats > 0){
				lastBAT->values++;
				if (takeNext == FALSE)
					tempBATs->values--;
			}
		}
		
		/* then put any insertions that belong here */
		while( inst < insLast && (@2_LT(inst,curValue,@3@1) || (@2_EQ(inst,curValue,@3@1) && lowIndexNode->inclusive == FALSE)) @4){
			@:newTempBAT(@1)@
			if (crkt > crkLast){
				*(oid*)crkh = *(oid*)insh;		
				*(@1 *)crkt = *(@1 *)inst;		
				crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
				extendedIns++;
				continue;
			}
			*(oid*)wscrh = *(oid*)crkh;		
			*(@1 *)wscrt = *(@1 *)crkt;
			*(oid*)crkh = *(oid*)insh;		
			*(@1 *)crkt = *(@1 *)inst;		
			crkh+=xx; crkt+=xx; insh+=xx; inst+=xx; wscrh+=xx; wscrt+=xx; rscrh+=xx; rscrt+=xx;
			insDone++; written++;				
			lastBAT->values++;
		}
		
		/* update the index */
		*(lng*)curPos = *(lng*)curPos + insDone + extendedIns;

		/* take the next temp BAT */
		if (takeNext == TRUE){
			temp = tempBATs;
			tempBATs = tempBATs->next;
			BBPreclaim(temp->b);
			GDKfree(temp);
			bats--;
		}
	}

	end:;
	if (lowIndexNode == NULL){
		crkLast = BUNlast(b) + (extended+extendedIns)*xx;
		crkh = BUNhloc(b,crkLast);
		crkt = BUNtloc(b,crkLast);

		/* append scratch */
		temp  = tempBATs;
		rscrh = BUNhloc(temp->b,BUNfirst(temp->b));
		rscrt = BUNtloc(temp->b,BUNfirst(temp->b));
		written = 0;
		while(1){
			*(oid*)crkh = *(oid*)rscrh;
			*(@1 *)crkt = *(@1 *)rscrt;
			written++; crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx;
			if (written == temp->values){
				crkLast += written*xx;
				if (tempBATs->next != NULL){
					tempBATs = tempBATs->next;
					BBPunfix(temp->b->batCacheid); /* TODO Destroy */
					GDKfree(temp);
					temp = tempBATs;
					rscrh = BUNhloc(temp->b,BUNfirst(temp->b));
					rscrt = BUNtloc(temp->b,BUNfirst(temp->b));
				 	written = 0;
				} else {
					BBPunfix(temp->b->batCacheid); /* TODO Destroy */
					GDKfree(temp);
					break;
				}	
			}
		}
	
		/* append the rest of the insertions if any */
		written = 0;
		while (inst < insLast @4){
			*(oid*)crkh = *(oid*)insh;
			*( @1*)crkt = *( @1*)inst;
			crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
			insDone++;				
			written++;
		}		
	
		crkLast += written*xx;
		b->batBuns->free = crkLast - b->batBuns->base; /* crkt should be the one after the last */
   		BATsetcount(b, b->batBuns->free/xx);
/*	
printf(" \n Total bun in are %lld \n", insDone+ extendedIns);
printf("size is "SZFMT"  --- prev: %lld", BATcount(b), prevcrsize);	
*/
	}
	endPosition = startPosition + insDone + extendedIns;
@

@= mergeInsertionsFromTheEndBodyI
        BAT *c, *u, *b;
	BUN insh, inst, crkh, crkt, idxFirst, cur, curVal, curPos, crkFirst, crkLast, insLast, insFirst, next, write;
	int xx, zz, position = -1;
	struct Node *IndexNode = NULL;
	lng prevPos, prevcrsize, insertions, remainingIns, buns;

	BUN wh,wt;
	lng copy;

	for (int i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*new)) == NULL) 
                return throwMessage("crackers.mergeInsertions_@1", "Cannot access insertions BAT");

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL){ 
		BBPunfix(u->batCacheid);
		return throwMessage("crackers.mergeInsertions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(TreeIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		return throwMessage("crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	if (endPosition == -1)
		endPosition = BATcount(u) - 1;
	insertions = endPosition - startPosition + 1;

	/* sort in place the insertions bat */ 
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	xx = BUNsize(b);
	zz = BUNsize(c);
	insFirst = BUNfirst(u);	
	insLast = BUNtloc(u,BUNlast(u));	

	/* make room for the new buns */
	lng needed = insertions - (((b)->batBuns->size - (b)->batBuns->free) / xx);
	if ( needed > 0 ){
                size_t ncap = BATcapacity(b) + needed;
                size_t grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                        return throwMessage("crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = BUNhloc(u, insFirst + endPosition*xx);
	inst 	 = BUNtloc(u, insFirst + endPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
@
@= mergeInsertionsFromTheEndBodyII
	prevPos = prevcrsize - 1;
	while ( remainingIns > 0 && 
		(IndexNode = findNodeL_@1(*(@1*)BUNtloc(b,next), TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL)) != NULL ) {
		
		write  = next + xx;

		cur    = idxFirst + (IndexNode->position) * zz;
                curPos = BUNhloc(c, cur);
		curVal = BUNtloc(c, cur);
		next   = crkFirst + (*(lng*)curPos) * xx;
		buns   = prevPos - (*(lng*)curPos);
	
		crkh = BUNhloc(b,write+(remainingIns-1)*xx);
		crkt = BUNtloc(b,write+(remainingIns-1)*xx);
		while(  remainingIns > 0 && 
			(@2_GT(inst,curVal,@3@1) || (@2_EQ(inst,curVal,@3@1) && IndexNode->inclusive == TRUE)) ){
			*(oid*)crkh = *(oid*)insh;
			*(@1 *)crkt = *(@1 *)inst;
			crkh-=xx; crkt-=xx; insh-=xx; inst-=xx; remainingIns--; 
		}

		if (remainingIns == 0)
                break;

		if (buns>remainingIns){
			/*memcpy(next+xx, write, remainingIns*xx);*/
			crkh = BUNhloc(b, next+xx);
       		        crkt = BUNtloc(b, next+xx);
			wh   = BUNhloc(b,write);
			wt   = BUNtloc(b,write);
			copy = (buns>remainingIns?remainingIns:buns);
			for(int i=0;i<copy;i++){
				*(oid*)wh = *(oid*)crkh;
                       	 	*(@1 *)wt = *(@1 *)crkt;
                       	 	crkh+=xx; crkt+=xx; wh+=xx; wt+=xx;
			}
		} else {
			/*memcpy(next+xx, write+(remainingIns-buns)*xx, buns*xx);*/
			crkh = BUNhloc(b, next+xx);
       		        crkt = BUNtloc(b, next+xx);
			wh   = BUNhloc(b,write+(remainingIns-buns)*xx);
			wt   = BUNtloc(b,write+(remainingIns-buns)*xx);
			copy = (buns>remainingIns?remainingIns:buns);
			for(int i=0;i<copy;i++){
				*(oid*)wh = *(oid*)crkh;
                       	 	*(@1 *)wt = *(@1 *)crkt;
                       	 	crkh+=xx; crkt+=xx; wh+=xx; wt+=xx;
			}
		}
		
		prevPos = *(lng*)curPos;
		*(lng*)curPos =  *(lng*)curPos + remainingIns;
	}

	if (IndexNode == NULL && remainingIns > 0){
		/*memcpy(insFirst, next + xx, remainingIns);*/
		crkh = BUNhloc(b, insFirst+startPosition*xx);
                crkt = BUNtloc(b, insFirst+startPosition*xx);
		wh   = BUNhloc(b, next + xx);
		wt   = BUNtloc(b, next + xx);
		for(int i=0;i<remainingIns;i++){
			*(oid*)wh = *(oid*)crkh;
                        *(@1 *)wt = *(@1 *)crkt;
                        crkh+=xx; crkt+=xx; wh+=xx; wt+=xx;
		}
	}

@

@= shrinkInsertions
		/* shrink the insertions bat */
		crkh  = BUNhloc(u,insFirst+startPosition*xx);
		crkt  = BUNtloc(u,insFirst+startPosition*xx);
		insh  = BUNhloc(u,insFirst+endPosition*xx);
		inst  = BUNtloc(u,insFirst+endPosition*xx);
		while (inst < insLast){
			*(oid*)crkh = *(oid*)insh;
			*( @1*)crkt = *( @1*)inst;
			crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
		}

		crkLast = insFirst + (startPosition + (BATcount(u) - endPosition))*xx;
		u->batBuns->free = crkLast - u->batBuns->base; 
   		BATsetcount(u, u->batBuns->free/xx);
		if (BATcount(u) == 0){
			BATmode(u, TRANSIENT);
			TreeIndex[position].iid = -1;
			TreeIndex[position].mergeInsertions = -1;
/*
printf("\n 				Consumed insertions \n");
*/
		}
@

@= mergeInsertionOperations
str
mergeInsertions_@1(int *bid, int *new, lng startPosition, bit deleteNodes){
		
	@:mergeInsertionsBody(@1,@2,@3,,1)@

	BBPunfix(c->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

str
mergeInsertionsGradually_@1(int *bid, int *new, lng startPosition, @1* hgh, bit inclusive, bit deleteNodes){
		
	@:mergeInsertionsBody(@1,@2,@3, && (@2_LT(inst,hgh,@3@1) || (@2_EQ(inst,hgh,@3@1) && inclusive == TRUE)),1)@

	@:shrinkInsertions(@1)@

	BBPunfix(c->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

str
mergeInsertionsRipple_@1(int *bid, int *new, lng startPosition, @1* hgh, bit inclusive, bit deleteNodes){

	@:mergeInsertionsBody(@1,@2,@3, && (@2_LT(inst,hgh,@3@1) || (@2_EQ(inst,hgh,@3@1) && inclusive == TRUE)), ((@2_LT(curValue,hgh,@3@1) || (@2_EQ(curValue,hgh,@3@1) && inclusive == TRUE && lowIndexNode->inclusive == TRUE)) || bats > 0))@

	if (lowIndexNode == NULL){
		@:shrinkInsertions(@1)@
	}

	if (lowIndexNode != NULL){
		/* we have to merge the scratch values back in the insertions bat */

		/* order first the temp bat */
		crkLast = BUNfirst(tempBATs->b) + tempBATs->values*xx;
		tempBATs->b->batBuns->free = crkLast - tempBATs->b->batBuns->base; 
   		BATsetcount(tempBATs->b, tempBATs->b->batBuns->free/xx);
		
		tempBATs->b->tsorted = FALSE;		
		tempBATs->b->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(tempBATs->b)));
		
		/* merge */
		rscrh = BUNhloc(tempBATs->b, BUNfirst(tempBATs->b));
		rscrt = BUNtloc(tempBATs->b, BUNfirst(tempBATs->b));
		crkh  = BUNhloc(u,insFirst+startPosition*xx);
		crkt  = BUNtloc(u,insFirst+startPosition*xx);
		insh  = BUNhloc(u,insFirst+(startPosition + insDone + extendedIns)*xx);
		inst  = BUNtloc(u,insFirst+(startPosition + insDone + extendedIns)*xx);

		crkLast = BUNtloc(tempBATs->b,BUNlast(tempBATs->b));
		insLast = BUNtloc(u,BUNlast(u));

		while(rscrt < crkLast || inst < insLast){
			if (rscrt < crkLast && inst >= insLast){
				*(oid*)crkh = *(oid*)rscrh;
                                *( @1*)crkt = *( @1*)rscrt;
                                crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx;
			} else
			if (rscrt >= crkLast && inst < insLast){
				*(oid*)crkh = *(oid*)insh;
                                *( @1*)crkt = *( @1*)inst;
                                crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
			} else {
				if (@2_LE(rscrt,inst,@3@1)){	
					*(oid*)crkh = *(oid*)rscrh;
					*( @1*)crkt = *( @1*)rscrt;
					crkh+=xx; crkt+=xx; rscrh+=xx; rscrt+=xx;
				} else {
					*(oid*)crkh = *(oid*)insh;
					*( @1*)crkt = *( @1*)inst;
					crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
				}
			}
		}
/*
printf("\n -------Rippled %lld tuples \n", insDone+extendedIns);
*/
	}

	BBPunfix(c->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

mal_export str CRKmergeInsertions_Force_@1(int *k, int *bid, int *new, bit *deleteNodes);
str
CRKmergeInsertions_Force_@1(int *k, int *bid, int *new, bit *deleteNodes){
	(void) k;
	return mergeInsertions_@1(bid, new, 0, *deleteNodes);
}

mal_export str CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new);
str
CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new){
	(void) k;
	BAT *c, *u;
	@1 min;
	BUN inst, insLast;
	int xx, position = -1;

	if ((u = BATdescriptor(*new)) == NULL) 
		return throwMessage("crackers.mergeInsertions_PartiallyForget_@1", "Cannot access insertions");

	if (BATcount(u) == 0)
		return MAL_SUCCEED;

	for (int i = 0; i < maxCrackMap; i++)
        	if (TreeIndex[i].bid == *bid){
                	position = i;	
			break;
		}

	/*if (position == -1) return; Trying to erase an index that does not exist*/

	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL){
                BBPunfix(u->batCacheid);
                return throwMessage("crackers.CRKmergeInsertions_PartiallyForget_@1", "Cannot access cracker index");
        }

	/* get the min value */
	xx = BUNsize(u);
	inst = BUNtloc(u,BUNfirst(u));
	insLast = BUNtloc(u,BUNlast(u));
	min = *(@1*)inst;
	for(inst+=xx;inst < insLast; inst+=xx)
		if (@2_GT(&min,inst,@3@1))
			min = *(@1*)inst;

	/* Partially delete tree with lazy deletion */
	PartiallyLazyFreeAVLTree_@1(TreeIndex[position].Tree, min, c, BUNfirst(c), BUNsize(c));

	appendCrackerBAT(bid,new);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

mal_export str CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new);
str
CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new){
	(void)k;
	lng startPosition = 0;
	lng endPosition   = -1;

	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - xx;

	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx); 

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

 	return MAL_SUCCEED;
}

str
mergeInsertionsB_@1(int *bid, int *new, lng startPosition, lng endPosition){

	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - xx;

	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx); 

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBGradually_@1(int *bid, int *new, lng startPosition, lng endPosition){

	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - xx;

	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx); 

	endPosition++;
	@:shrinkInsertions(@1)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str                             
mergeInsertionsBRipple_@1(int *bid, int *new, lng startPosition, lng endPosition, @1 *hgh, bit inclusive){
        BAT *ripple;    
        BUN rh, rt, rnext;     
	lng toRippleBuns;
	lng exceedBuns = 0;
                        
        @:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@
                
	toRippleBuns = endPosition - startPosition +1;
	ripple = BATnew(TYPE_oid, TYPE_@1, toRippleBuns);
/*
printf("\n buns to riple are %lld %lld %lld \n", toRippleBuns,startPosition, endPosition);
*/
        /* find out buns that should be rippled */
        if ( (IndexNode = findNodeH_@1(*(@1*)hgh, inclusive, TreeIndex[position].Tree, c, idxFirst, zz, NULL)) != NULL ){
		IndexNode->deleted = TRUE;
		rh = BUNhloc(ripple, BUNfirst(ripple));
		rt = BUNtloc(ripple, BUNfirst(ripple));
		cur     = idxFirst + (IndexNode->position) * zz;
                curPos  = BUNhloc(c, cur); 
		prevPos = *(lng*)curPos;
                rnext   = crkFirst + (*(lng*)curPos) * xx + xx;

		/* merging will start from this bun */		
		next = crkFirst + (*(lng*)curPos) * xx;

                crkh = BUNhloc(b,rnext);
                crkt = BUNtloc(b,rnext);
		crkLast = BUNtloc(b,BUNlast(b));

		/* find out how many buns until we get into the next chunk */
		if ( (IndexNode = findNodeH_@1(*(@1*)BUNtloc(b,rnext),TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL)) == NULL)
			buns = BATcount(b) - (*(lng*)curPos) - 1;
		else {
			cur    = idxFirst + (IndexNode->position) * zz;
               		curPos = BUNhloc(c, cur);
                	rnext   = crkFirst + (*(lng*)curPos) * xx + xx;
                	buns   = (*(lng*)curPos) - prevPos;
		}
		int i;
		for (i=0; i<toRippleBuns; i++){
			if (i > buns && crkt < crkLast){
				IndexNode->deleted = TRUE;
				if ( (IndexNode = findNodeH_@1(*(@1*)BUNtloc(b,rnext),TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL)) == NULL)
					buns = BATcount(b) - prevPos - 1;
				else {
					cur    = idxFirst + (IndexNode->position) * zz;
               				curPos = BUNhloc(c, cur);
                			rnext   = crkFirst + (*(lng*)curPos) * xx + xx;
                			buns   = (*(lng*)curPos) - prevPos;
				}
			}
			*(oid*)rh = *(oid*)crkh;
			*(@1 *)rt = *(@1 *)crkt;
			rh+=xx; rt+=xx; crkh+=xx; crkt+=xx;	
			if (crkt >= crkLast){ 
				i++;
				exceedBuns = toRippleBuns - i;
				break;
			}
		}
		ripple->batBuns->free = BUNfirst(ripple) + i*xx - ripple->batBuns->base;	
		BATsetcount(ripple, i);
	} else 
		next = BUNlast(b) - xx;

        @:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@ 

	if (exceedBuns > 0){
		crkLast = BUNlast(b) + exceedBuns * xx;
		b->batBuns->free = crkLast - b->batBuns->base;
       	 	BATsetcount(b, b->batBuns->free/xx); 
        }

	endPosition++;
	if (BATcount(ripple) > 0){
		ripple->tsorted = FALSE;		
		ripple->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(ripple)));
		
		/* merge */
		rh    = BUNhloc(ripple, BUNfirst(ripple));
		rt    = BUNtloc(ripple, BUNfirst(ripple));
		crkh  = BUNhloc(u,insFirst+startPosition*xx);
		crkt  = BUNtloc(u,insFirst+startPosition*xx);
		insh  = BUNhloc(u,insFirst+endPosition*xx);
		inst  = BUNtloc(u,insFirst+endPosition*xx);

		crkLast = BUNtloc(ripple,BUNlast(ripple));
		insLast = BUNtloc(u,BUNlast(u));

		while(rt < crkLast || inst < insLast){
			if (rt < crkLast && inst >= insLast){
				*(oid*)crkh = *(oid*)rh;
                                *( @1*)crkt = *( @1*)rt;
                                crkh+=xx; crkt+=xx; rh+=xx; rt+=xx;
			} else
			if (rt >= crkLast && inst < insLast){
				*(oid*)crkh = *(oid*)insh;
                                *( @1*)crkt = *( @1*)inst;
                                crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
			} else {
				if (@2_LE(rt,inst,@3@1)){	
					*(oid*)crkh = *(oid*)rh;
					*( @1*)crkt = *( @1*)rt;
					crkh+=xx; crkt+=xx; rh+=xx; rt+=xx;
				} else {
					*(oid*)crkh = *(oid*)insh;
					*( @1*)crkt = *( @1*)inst;
					crkh+=xx; crkt+=xx; insh+=xx; inst+=xx;
				}
			}
		}
/*
printf("\n -------Rippled "SZFMT" tuples \n", BATcount(ripple));
*/		
	} else {
		@:shrinkInsertions(@1)@
	} 
                                
        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);        
        BBPunfix(b->batCacheid);
	BBPreclaim(ripple);
                        
        return MAL_SUCCEED;
} 

@

@c
@:mergeInsertionOperations(chr,simple,)@
@:mergeInsertionOperations(sht,simple,)@
@:mergeInsertionOperations(int,simple,)@
@:mergeInsertionOperations(lng,simple,)@
@:mergeInsertionOperations(flt,simple,)@
@:mergeInsertionOperations(dbl,simple,)@
@:mergeInsertionOperations(date,atom,TYPE_)@

str
appendInsertions(int *new, int position){
	BAT *u, *c;
       	if ((u = BATdescriptor(*new)) == NULL) 
      		 return throwMessage("crackers.appendInsertions", "Cannot access insertions BAT");
	if (TreeIndex[position].iid < 0 ){
		BATmode(u,PERSISTENT);
		TreeIndex[position].iid = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(TreeIndex[position].iid)) == NULL) 
      		 	return throwMessage("crackers.appendInsertions", "Cannot access cracker insertions BAT");
        	BATappend(c, u, TRUE);
		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}
        return MAL_SUCCEED;
}

str
CRKmergeInsertions_Forget(int *k, int *bid, int *new){
	(void) k;
	appendCrackerBAT(bid,new);
	removeTreeIndex(bid);
	return MAL_SUCCEED;
}


@= insertionsOnNeed
str
CRKmergeInsertionsB_OnNeed@1(int *k, int *bid, int *new){
        (void) k;
	int position = existsTreeIndex(*bid);
	if (position == -1) 
		return throwMessage("crackers.CRKmergeInsertionsB_OnNeed@1", "Cannot find cracker index");
	appendInsertions(new,position);
	TreeIndex[position].mergeInsertions = @2;
	TreeIndex[position].deleteNodes = FALSE;	
	TreeIndex[position].mergeFromTheEnd = TRUE;
        return MAL_SUCCEED;
}

str
CRKmergeInsertions_OnNeed@1(int *k, int *bid, int *new, bit *deleteNodes){
        (void) k;
	int position = existsTreeIndex(*bid);
	if (position == -1) 
		return throwMessage("crackers.CRKmergeInsertions_OnNeed@1", "Cannot find cracker index");
	appendInsertions(new,position);
	TreeIndex[position].mergeInsertions = @2;
	TreeIndex[position].deleteNodes = *deleteNodes;	
	TreeIndex[position].mergeFromTheEnd = FALSE;
        return MAL_SUCCEED;
}
@

@c
@:insertionsOnNeed(,0)@
@:insertionsOnNeed(Gradually,1)@
@:insertionsOnNeed(GraduallyRipple,2)@




@= verifyIndex
str
verifyCrackerIndex_@1(int *bid){
        BAT *c, *b;
	int position = -1;
	BUN crkt, idxh, idxt, idxFirst, crkFirst, crkLast, bnd, cur;
	int xx, zz;
	struct Node * hghIndexNode;
	bit prevIncl; 
	@1 prevVal;
	int tuples=0, indexEntries=0;
	for (int i = 0; i < maxCrackMap; i++)
                if (TreeIndex[i].bid == *bid){
                        position = i;
			break;	
		}

	if ((c = BATdescriptor(TreeIndex[position].cid)) == NULL) 
		return throwMessage("crackers.mergeInsertions_@1", "Cannot access cracker index");
	if ((b = BATdescriptor(TreeIndex[position].cbid)) == NULL){
		BBPunfix(c->batCacheid);
		return throwMessage("crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	
	xx = BUNsize(b);
	zz = BUNsize(c);
	
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	crkLast  = BUNtloc(b, BUNlast(b));
	crkt     = BUNtloc(b, BUNfirst(b));

	hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL);
	if (hghIndexNode == NULL){
		BBPunfix(c->batCacheid);
        	BBPunfix(b->batCacheid);
        	return MAL_SUCCEED;
	}
	indexEntries++;
	cur = idxFirst + ((hghIndexNode->position) * zz);
	idxh = BUNhloc(c, cur);
	idxt = BUNtloc(c, cur);
	bnd  = BUNtloc(b, crkFirst + (*(lng*)idxh) * xx); 

	while(crkt <= bnd){

		if (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)){
			crkt+=xx;
			tuples++;
		} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
			BBPunfix(c->batCacheid);
			BBPunfix(b->batCacheid);
			return MAL_SUCCEED; 
		} 
	}

	prevVal  = *(@1*)idxt; 
	prevIncl = hghIndexNode->inclusive;

	while (crkt < crkLast){
		if ((hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, TreeIndex[position].Tree, c, idxFirst, zz, NULL)) == NULL)
			break;

		indexEntries++;
		cur = idxFirst + ((hghIndexNode->position) * zz);
		idxh = BUNhloc(c, cur);
		idxt = BUNtloc(c, cur);
		bnd  = BUNtloc(b, crkFirst + (*(lng*)idxh) * xx); 

		while(crkt <= bnd){

			if ( (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)) &&
			     (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)) ){
				crkt+=xx;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
				BBPunfix(c->batCacheid);
				BBPunfix(b->batCacheid);
				return MAL_SUCCEED; 
			} 
		}

		prevVal  = *(@1*)idxt; 
		prevIncl = hghIndexNode->inclusive;
	}
	
	if (hghIndexNode == NULL){
		while(crkt < crkLast){
                        if (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)){
                                crkt+=xx;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
                                BBPunfix(c->batCacheid);
                                BBPunfix(b->batCacheid);
                                return MAL_SUCCEED;
                        }
		}
	}
	
	BBPunfix(c->batCacheid);
        BBPunfix(b->batCacheid);                         
	return MAL_SUCCEED;
}

mal_export str CRKverifyCrackerIndex_@1(int *k, int *bid);
str
CRKverifyCrackerIndex_@1(int *k, int *bid){
	(void) k;		
	return verifyCrackerIndex_@1(bid); 
}
@
@c

@:verifyIndex(chr,simple,)@
@:verifyIndex(sht,simple,)@
@:verifyIndex(int,simple,)@
@:verifyIndex(lng,simple,)@
@:verifyIndex(flt,simple,)@
@:verifyIndex(dbl,simple,)@
@:verifyIndex(date,atom,TYPE_)@

@-
This function takes a range and returns a view with the result. To do that, we first search the index to determine which parts of the result we already 
know and which parts we have to crack. Then we crack, if necessary, 
the appropriate pieces, update the index and return the result.

@= crkThreeTree
/*printf("crack in three pieces\n");*/
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LE_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LE_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LO_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LO_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
				
	if (vl != -1 && vh != -1){
		if (vl>0) _vl=vl-1; else _vl=vl;		
		addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);
		addTreeIndex_@1(m,hgh,HBound,vh,c);
	}

@= crkThree
/*printf("crack in three pieces\n");*/
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE){
		CRKcrackUnorderedThree_LE_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = -(vl-1); i2 = vh;
	}
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE){
		CRKcrackUnorderedThree_LE_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = -(vl-1); i2 = -vh;
	}
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE){
		CRKcrackUnorderedThree_LO_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = vl-1; i2 = vh;
	}
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE){
		CRKcrackUnorderedThree_LO_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
		i1 = vl-1; i2 = -vh;
	}
				
	if (vl == -1){ /*middle and right pieces are empty*/
		if (*inclusiveLow == TRUE) i1 = -@3;
		else i1 = @3;
		addOne_@1(m,low,i1,posA);
	}else
	if (vh == -1){ /*left and middle pieces are empty*/
		if (*inclusiveHgh == TRUE) i2 = @2;
		else i2 = -@2;
		addOne_@1(m,hgh,i2,posB);
	}else
		/*The following adds also gaps in the index in the cases where epmty piece
		is the right, the left or the middle. In the latter case vl is always vh+1
		and the index we want for both is vh*/
		addTwo_@1(m,low,i1,posA,hgh,i2,posB);

@= crkTwoL
/*printf("crack in two pieces\n");*/
	h1 = l + xx;
	if (h1 == BUNlast(c)){
		h1 = BUNlast(b) - BUNsize(b);
		ch1 = BUNindex (b, h1);	
	}
	else{ 
		ch1 = *(lng*)BUNhloc(c, h1);
		if (ch1 < 0) ch1 = ch1 - 2*ch1;
	}
	@:twoL(@1)@

@= crkTwoLFirst
	h1 = BUNlast(b) - BUNsize(b);
	ch1 = BUNindex (b, h1);	
	@:twoL(@1)@

@= twoL
	/*CRACK in two pieces cl-ch1 using >incLow bound*/
	if (*inclusiveLow == TRUE) {
		CRKcrackUnorderedZero_RE_@1(b,*low, cl, ch1,&vl);
		i1 = - vl;
	}
	else {
		CRKcrackUnorderedZero_LE_@1(b,*low, cl, ch1,&vl);
		i1 = vl;
	}
	if (vl < cl){
		/*then the left piece is empty*/
		if (*inclusiveLow == TRUE) i1 = -cl;
		else i1 = cl;
	}
	if (vl > ch1){
		/*then the right piece is empty*/
		vl--;
		if (*inclusiveLow == TRUE) i1 = -ch1;
		else i1 = ch1;
	}

	vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
		Instead we want the first bun of the right piece*/

@= crkTwoLTree
	/*CRACK in two pieces cl1-ch1 using >incLow bound*/
	if (*inclusiveLow == TRUE)
		CRKcrackUnorderedZero_RE_@1(b,*low, cl1, ch1,&vl);
	else 
		CRKcrackUnorderedZero_LE_@1(b,*low, cl1, ch1,&vl);
	if (vl < cl1){
		/*then the left piece is empty*/
		gapL = -1;;
	}
	if (vl > ch1){
		/*then the right piece is empty*/
		vl--;
		gapL = -1;
	}
	vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
		Instead we want the first bun of the right piece*/

@= crkTwoR
	if (h == BUNfirst(c))
		cl2 = BUNindex(b,  BUNfirst(b));	
	else{
		cl2 = *(lng*)BUNhloc(c, h-xx);
	        if (cl2 < 0) cl2 = cl2 - 2*cl2;
		cl2++;
	}
	@:twoR(@1)@

@= crkTwoRFirst
	cl2 = BUNindex(b,  BUNfirst(b));
	@:twoR(@1)@

@= twoR
/*printf("crack in two pieces\n");*/
	/*CRACK in two pieces cl2-ch using <incHgh bound*/
	if (*inclusiveHgh == TRUE){ 
		CRKcrackUnorderedZero_LE_@1(b,*hgh, cl2, ch,&vh);
		i2 = vh;
	}
	else{ 
		CRKcrackUnorderedZero_RE_@1(b,*hgh, cl2, ch,&vh);
		i2 = -vh;
	}

	/*check for gaps*/
	if (vh < cl2){
		/*then the left piece is empty*/
		if (*inclusiveHgh == TRUE) i2 = cl2;
		else i2 = -cl2;
	}
	if (vh > ch){
		/*then the right piece is empty*/
		vh--;
		if (*inclusiveHgh == TRUE) i2 = ch;
		else i2 = -ch;
	}

@= crkTwoRTree
/*printf("crack in two pieces\n");*/
	/*CRACK in two pieces cl2-ch2 using <incHgh bound*/
	if (*inclusiveHgh == TRUE) 
		CRKcrackUnorderedZero_LE_@1(b,*hgh, cl2, ch2,&vh);
	else
		CRKcrackUnorderedZero_RE_@1(b,*hgh, cl2, ch2,&vh);

	/*check for gaps*/
	if (vh < cl2)
		/*then the left piece is empty*/
		gapH = -1;
	if (vh > ch2){
		/*then the right piece is empty*/
		gapH = -1;
		vh--;
	}

@= searchForLow
	l = SORTfndfirst_@4(c,low);
	lt = BUNtloc(c, l);
	lh = BUNhloc(c, l);
	posA = l;	

	/* if all indices contain values smaller than low, crack the area 
		between the last index and the last BUN of the cracked bat */
	if (l == BUNlast(c)){
		l -= xx; lt -= xx; lh -= xx; 
		if  (*(lng*)lh > 0)
			cl = *(lng*)lh;
		else
			cl = *(lng*)lh - 2*(*(lng*)lh);
		cl++;
	} else
	if (@2_EQ(lt,low,@3@1)){
		/* The first two cases are when the low bound already 
			exists in the index */
		if  (*(lng*)lh < 0 && *inclusiveLow == TRUE)
			vl = (*(lng*)lh - 2*(*(lng*)lh))+1;
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == FALSE)
			vl = *(lng*)lh+1;

		/* We want values that the previous index has; 
		   special case when there is no previous index */
		else
		if  (*(lng*)lh > 0 && *inclusiveLow == TRUE){
			if (l == BUNfirst(c)){
				l  -= xx; 
				cl = BUNindex(b, BUNfirst(b));
			}else{
				l  -= xx; lh -= xx; lt -= xx;
				if  (*(lng*)lh > 0)
					cl = *(lng*)lh;
				else
					cl = *(lng*)lh - 2*(*(lng*)lh);
				cl++;
			}
		}else
		if  (*(lng*)lh < 0 && *inclusiveLow == FALSE){
		/*  This index contains values that we do not want (the equals to 
			low) so we check the next one. If it is equal to low then 
			this is an exact match, otherwise we have to crack. 
			Also if this was the last index we have to crack anyway. */
			lt += xx;
			l  +=xx;
			if (@2_EQ(lt,low,@3@1) && l != BUNlast(c)){
				lh += xx;
				vl = *(lng*)lh+1;
			}else{
				lt -= xx;
				l  -= xx;
				cl = (*(lng*)lh - 2*(*(lng*)lh))+1;
			}
		}
	}else{ 
		/* No exact match was found so we have to crack. Take the 
		   previous index because this one is higher than low.
		   If there is no previous index, crack the bat from the beginning. */
		if (l == BUNfirst(c)){
			l  -= xx; lh -= xx; lt -= xx;
			cl = BUNindex(b, BUNfirst(b));
		}else{
			l  -= xx; lh -= xx; lt -= xx;
			if  (*(lng*)lh > 0)
				cl = *(lng*)lh;
			else
				cl = *(lng*)lh - 2*(*(lng*)lh);
			cl++;
		}
	}	

@= searchForGapsLow
	/*check for empty pieces after l*/	
	lhnext = lh + xx;
	gf = 0;	
	while(1){
		
		if ( *(lng*)lhnext == cl || 
			( *(lng*)lhnext < 0 && *(lng*)lhnext - 2*(*(lng*)lhnext) == cl ) ){ 
			gf = 1;
			l += xx; lt += xx; lh += xx;
			lhnext += xx;
		}
		else break;
	}
	if (gf == 1){
		if (@2_GT(lt,hgh,@3@1)){
			vl =  1;
			vh = -1;
			goto createView;
		}
		else
		if (@2_EQ(lt,hgh,@3@1)){
			if  (*(lng*)lh < 0) vl = *(lng*)lh - 2*(*(lng*)lh);
			else vl = *(lng*)lh;
			vh =  vl;
			goto createView;
		}
		else{
			if  (*(lng*)lh < 0) vl = *(lng*)lh - 2*(*(lng*)lh);
			else vl = *(lng*)lh;
			cl = -1;
		}
	}

@= searchForHgh
	h = SORTfndfirst_@4(c,hgh);
	ht = BUNtloc(c, h);
	hh = BUNhloc(c, h);
	posB = h;	

	if (h == BUNlast(c))
		ch = BUNindex(b, BUNlast(b) - BUNsize(b));
	else
	if (@2_EQ(ht,hgh,@3@1)){
		/* The first two cases are when the low bound already exists in the index */
		if  (*(lng*)hh > 0 && *inclusiveHgh == TRUE)
			vh = *(lng*)hh;
		else if  (*(lng*)hh < 0 && *inclusiveHgh == FALSE)
			vh = *(lng*)hh - 2*(*(lng*)hh);

	/* We want values that the next index has; special case when there is no next index */
		else if  (*(lng*)hh < 0 && *inclusiveHgh == TRUE){
			ht += xx; h  += xx; hh += xx;
			if (h == BUNlast(c)){
				ch = BUNindex(b, BUNlast(b)-BUNsize(b)); /*todo this might be the same with current index*/
			}else if (@2_EQ(ht,hgh,@3@1))
				vh = *(lng*)hh;
			else {
				ch= *(lng*)hh;
				if (ch < 0) ch = *(lng*)hh - 2*(*(lng*)hh);
			}
		}
		/*  This index contains values that we do not want (the equals to hgh) 
			so we have to crack up to this one. We know that there is no 
			previous index that excludes only the values we do not want (the 
			hghs) Also we cannot check for hgh-1 */
		else if  (*(lng*)hh > 0 && *inclusiveHgh == FALSE)
			ch = *(lng*)hh;
	}else{ 
		/* No exact match was found so we have to crack. */
		if  (*(lng*)hh > 0)
			ch = *(lng*)hh;
		else
			ch = *(lng*)hh - 2*(*(lng*)hh);
	}

@= searchForGapsHgh
	/*check for empty pieces before h*/	
	hhprev = hh - xx;
	gf = 0;	
	while(1){
		if ( *(lng*)hhprev == ch || 
			( *(lng*)hhprev < 0 && *(lng*)hhprev - 2*(*(lng*)hhprev) == ch ) ){ 
			gf = 1;
			h -= xx; ht -= xx; hh -= xx;
			hhprev -= xx;
		}
		else break;
	}
	if (gf == 1){
		if (@2_LT(ht,low,@3@1)){
			vl =  1;
			vh = -1;
			goto createView;
		}
		else
		if (@2_EQ(ht,low,@3@1)){
			if  (*(lng*)hh < 0) vl = *(lng*)hh - 2*(*(lng*)hh);
			else vl = *(lng*)hh;
			vh =  vl;
			goto createView;
		}
		else{
			if  (*(lng*)hh < 0) vh = *(lng*)hh - 2*(*(lng*)hh);
			else vh = *(lng*)hh;
			ch = -1;
		}
	}

@= CreateResult
createView:
/*	printf("vl: %lld, vh:%lld \n",vl,vh);*/
	view = BATslice(b, vl, vh+1);
	
	if (!tail) 
		view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
	
	*vid = view->batCacheid;
	BBPkeepref(*vid);
	BBPunfix(b->batCacheid);
@

@= crackOperations
str
CRKRangeTree_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail)
{
	BAT *b,*c,*bo, *u;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1, posl, posh; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl1, ch1, cl2, ch2; 
	/* index values in the case we have to crack 
		|cl1...........ch1|.....................|cl2.........ch2|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	int xx;
	int _vl;
	bit HBound,foundLow=0,foundHgh=0;
	int gapL = 1;
	int gapH = 1;
	BUN l, lt, insLast;
	lng insertionsStart, insertionsEnd, insertions;
	
	if (@2_GT(low,hgh,@3@1))
		return throwMessage("crackers.crack", "illegal range");
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				        

	m = existsTreeIndex(*bid);

	/* if this is the first time we select something from this bat, 
		we have to create the crack indx for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE; 
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newTreeIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in three pieces cl-ch */
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));

		/*printf(" %lld \n ",posh-posl);*/
		@:crkThreeTree(@1,posl,posh)@
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where our range falls after this 
		search if we have a match on the low range vl will hold the 
		index value, otherwise it will be -1. The same for hgh and vh
		if there is no match for low then cl will hold the index that 
		from there on we have to crack. The same from hgh and ch
		Note that in the case of the low range  we always have to increment 
		by one since we want the values that are after this index 
		(because of the way the crack index is created).
		Also after the search l and h should point to the low and hgh indices 
		(in the crack index) found either as a match or to crack. 
		This is used later on to determine which pieces we have to crack*/

	/*Check if this bat was previously cracked but the map is not there anymore
		this may happen if we chose to forget the index because of updates, so now we 
		have to create a new one and crack in three pieces anyway*/
	if (TreeIndex[m].reCreate == 1){

		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access cracker index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access cracker BAT");
	
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));

		/*printf(" %lld \n ",posh-posl);*/
		@:crkThreeTree(@1,posl,posh)@
		goto createView;
	}
	
	/* deal with pending insertions if any */ 
	if (TreeIndex[m].mergeInsertions >= 0){

		if ((u = BATdescriptor(TreeIndex[m].iid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access here insertions BAT");			

		insertions = BATcount(u);
		if (insertions == 0){
                        BBPunfix(u->batCacheid);
                        goto crack; /* no qualifying values in the insertions */
                }

		/* if necessary, sort in place the insertions bat */
		if (u->tsorted == FALSE){
			u->batRestricted = BAT_WRITE;
			BATmirror(BATorder(BATmirror(u)));
		}

		/* binary search to find the position of the lowest requested value in the insertions*/
		l = SORTfndfirst_@4(u,low);
		lt = BUNtloc(u,l);
		insLast = BUNtloc(u, BUNlast(u));
		if (lt == insLast){
			BBPunfix(u->batCacheid);	 
			goto crack; /* no qualifying values in the insertions */
		}
		xx = BUNsize(u);
		if (@2_EQ(lt,low,@3@1) && *inclusiveLow == FALSE){
			while (lt < insLast && @2_EQ(lt,low,@3@1))
				lt +=xx; 
		} 			
		if (lt == insLast){ 
			BBPunfix(u->batCacheid);	 
			goto crack; /* no qualifying values in the insertions */
		}
	   	if ( @2_GT(lt,hgh,@3@1) || (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh==FALSE) ){
			BBPunfix(u->batCacheid);	 
			goto crack; /* no qualifying values in the insertions */ 	
		}
		insertionsStart = BUNindex(u,lt);	
		
		/* binary search to find the position of the highest requested value in the insertions */
                l = SORTfndfirst_@4(u, hgh);
		lt = BUNtloc(u,l);
		if (lt < insLast){
			if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == TRUE){	
				while (lt < insLast && @2_EQ(lt,hgh,@3@1))
                              		lt +=xx;
				lt-=xx;
			} else 
			if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == FALSE)
                                lt -=xx;
		 	else
			if ( @2_GT(lt,hgh,@3@1) )
                                lt -=xx;
		}

		if (lt == insLast) lt-=xx;
		insertionsEnd = BUNindex(u,lt);

		BBPunfix(u->batCacheid);
		
		if (TreeIndex[m].mergeInsertions == 0){	
			/* merge completely */
			if (TreeIndex[m].mergeFromTheEnd == TRUE)
				mergeInsertionsB_@1(bid, &TreeIndex[m].iid, 0, insertions-1); 
			else
				mergeInsertions_@1(bid, &TreeIndex[m].iid, 0, TreeIndex[m].deleteNodes); 
			TreeIndex[m].mergeInsertions = -1 ;
			TreeIndex[m].iid = -1;

		} else if (TreeIndex[m].mergeInsertions == 1){
			/* merge only the requested values */			
			if (TreeIndex[m].mergeFromTheEnd == TRUE)
				mergeInsertionsBGradually_@1(bid, &TreeIndex[m].iid, insertionsStart, insertionsEnd);
			else
				mergeInsertionsGradually_@1(bid, &TreeIndex[m].iid, insertionsStart, hgh, *inclusiveHgh, TreeIndex[m].deleteNodes);	
			
		} else if (TreeIndex[m].mergeInsertions == 2){
			/* merge only the requested values using the ripple strategy */
			if (TreeIndex[m].mergeFromTheEnd == TRUE)
				mergeInsertionsBRipple_@1(bid, &TreeIndex[m].iid, insertionsStart, insertionsEnd, hgh, *inclusiveHgh);	
			else
				mergeInsertionsRipple_@1(bid, &TreeIndex[m].iid, insertionsStart, hgh, *inclusiveHgh, TreeIndex[m].deleteNodes);	
                }
 
	}
		
	crack:;
	/* Take the index of the bat */
	if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	
	foundLow = GetLow_@1(*low, *inclusiveLow, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), xx, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, HBound, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), xx, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0) cl1++;
	if (cl2 != 0) cl2++;
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
printf("\n found Low=%d, found Hgh=%d \n",foundLow,foundHgh);
*/


	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (foundLow == 0 || foundHgh == 0){
		if (foundLow == 0 && foundHgh == 0){
			/* If ch2 is right after cl1 in the index then we split this piece in three pieces*/
			if (cl1 == cl2){
				/*CRACK in three pieces cl1-ch2 */
				/*printf("crack %lld %lld %lld %lld",cl1,ch1,cl2,ch2);*/	
				/*printf(" %lld \n",ch2-cl1);*/
				@:crkThreeTree(@1,cl1,ch2)@
			}else{
				/* Else we have to do two cracks separatelly */
				/*printf("crack %lld %lld %lld %lld",cl1,ch1,cl2,ch2);*/	
	
				/* For the cl bound and the next one in the index*/
				@:crkTwoLTree(@1)@

				/* For the ch bound and the previous one in the index*/
				@:crkTwoRTree(@1)@

				/*printf(" %lld \n",(ch1-cl1)+(ch2-cl2));*/
				if (IndexSize <IndexStop){
					if (vl>0) _vl=vl-1; else _vl=vl;		
					if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);
					if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
				}
			}
		}else
		if (foundLow == 0){
			/*printf("crack %lld %lld",cl1, ch1);*/	
			@:crkTwoLTree(@1)@
			/*printf(" %lld \n",(ch1-cl1));*/
			if (IndexSize <IndexStop){
				if (vl>0) _vl=vl-1; else _vl=vl;		
				if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,_vl,c);
			}
			vh = ch2;
		}else
		if (foundHgh == 0){
			/*printf("crack %lld %lld",cl2,ch2);*/	
			@:crkTwoRTree(@1)@
			/*printf(" %lld \n",(ch2-cl2));*/
			if (IndexSize <IndexStop)
				if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
			vl = cl1;
		} 	
	}
	else{
		vl = cl1;
		vh = ch2;
	
	}
		
	@:CreateResult()@
	return MAL_SUCCEED;
}       

str
CRKRangeLeftNilTree_@1(int *vid, int *bid, @1 *hgh, bit *inclusiveHgh, bit tail)
{
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1; 
	lng cl2, ch2; 
	int xx;
	bit HBound,foundHgh=0;
	int gapH = 1;
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				        

	m = existsTreeIndex(*bid);

	/* if this is the first time we select something from this bat, 
		we have to create the crack indx for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE; 
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newTreeIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		cl2 = BUNindex(b,BUNfirst(b));
		ch2 = BUNindex(b,BUNlast(b)-BUNsize(b));
		/*printf(" %lld \n ",ch2-cl2);*/
		@:crkTwoRTree(@1)@
		if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
		vl = BUNindex(b,BUNfirst(b));
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	if (TreeIndex[m].cid == -1){

		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");
	
		cl2 = BUNindex(b,BUNfirst(b));
		ch2 = BUNindex(b,BUNlast(b)-BUNsize(b));
		/*printf(" %lld \n ",ch2-cl2);*/
		@:crkTwoRTree(@1)@
		if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
		vl = BUNindex(b,BUNfirst(b));

		goto createView;
	}


	/* Take the index of the bat */
	if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	vl = BUNindex(b,BUNfirst(b));

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, HBound, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), xx, &cl2, &ch2, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl2 != 0) cl2++;
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
printf("\n  found Hgh=%d \n",foundHgh);
*/


	if (foundHgh == 0){
		/*printf("crack %lld %lld",cl2,ch2);*/	
		@:crkTwoRTree(@1)@
		/*printf(" %lld \n",(ch2-cl2));*/
		if (IndexSize <IndexStop)
			if (gapH>0) addTreeIndex_@1(m,hgh,HBound,vh,c);
	} 	
	else
		vh = ch2;
		
	@:CreateResult()@
	return MAL_SUCCEED;
}       

str
CRKRangeRightNilTree_@1(int *vid, int *bid, @1 *low, bit *inclusiveLow, bit tail)
{
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1; 
	lng cl1, ch1; 
	int xx;
	bit foundLow=0;
	int gapL = 1;
	
	m = existsTreeIndex(*bid);

	/* if this is the first time we select something from this bat, 
		we have to create the crack indx for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE; 
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newTreeIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		cl1 = BUNindex(b,BUNfirst(b));
		ch1 = BUNindex(b,BUNlast(b)-BUNsize(b));
		/*printf(" %lld \n ",ch1-cl1);*/
		@:crkTwoLTree(@1)@
		if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNindex(b,BUNlast(b)-BUNsize(b));
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	if (TreeIndex[m].cid == -1){

		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");
	
		cl1 = BUNindex(b,BUNfirst(b));
		ch1 = BUNindex(b,BUNlast(b)-BUNsize(b));
		/*printf(" %lld \n ",ch2-cl2);*/
		@:crkTwoLTree(@1)@
		if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNindex(b,BUNlast(b)-BUNsize(b));

		goto createView;
	}


	/* Take the index of the bat */
	if ((c = BATdescriptor(TreeIndex[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(TreeIndex[m].cbid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	vh = BUNindex(b,BUNlast(b)-BUNsize(b));


	/* find out where in the index the low falls */
	foundLow = GetLow_@1(*low,*inclusiveLow, TreeIndex[m].Tree, c, BUNhloc(c, BUNfirst(c)), xx, &cl1, &ch1, 0, BUNindex(b, BUNlast(b)-BUNsize(b)));

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0) cl1++;
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
printf("\n  found Low=%d \n",foundLow);
*/


	if (foundLow == 0){
		/*printf("crack %lld %lld",cl1,ch1);*/	
		@:crkTwoLTree(@1)@
		/*printf(" %lld \n",(ch1-cl1));*/
		if (IndexSize <IndexStop)
			if (gapL>0) addTreeIndex_@1(m,low,*inclusiveLow,vl,c);
	} 	
	else
		vl = cl1;
		
	@:CreateResult()@
	return MAL_SUCCEED;
}       

str
CRKRange_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail)
{
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1, posl, posh; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl=-1, ch1=-1, cl2=-1, ch=-1; 
	/* index values in the case we have to crack 
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	lng i1=-1,i2=-1;
	BUN l,lt,ht; 
	int xx;
	BUN h,lh,hh,h1, posA, posB;
	BUN lhnext, hhprev;
	bit gf;
	/*int firstCrack=0;
	BAT *n=NULL;
	*/
	if (@2_GT(low,hgh,@3@1))
		return throwMessage("crackers.crack", "illegal range");
        
	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat, 
		we have to create the crack indx for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		/*firstCrack = 1;
		int resMmap,mode=STORE_MMAP;*/
		if ((bo = BATdescriptor(*bid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE; 
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;
		BATsave(b);
		/*
		resMmap = BATmmap(b,mode,mode,mode);             
	        printf("\n result--> %d",resMmap);
                printf("\ncopyM %d\n",b->batMapbuns);
                printf("\noriginalM %d\n",bo->batMapbuns);
                printf("\ncopy %d\n",b->batBuns->storage);
                printf("Original %d\n",bo->batBuns->storage); 
		str name = BBPname(b->batCacheid);
		n = BATnew(TYPE_void,TYPE_str,1);
		BUNappend(n,name,FALSE);
		*/

		m = newIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in three pieces cl-ch */
		posl = BUNindex(b,BUNfirst(b));
		posh = BUNindex(b,BUNlast(b)-BUNsize(b));
		posA = BUNfirst(c);
		posB = posA + BUNsize(c);
		
		@:crkThree(@1,posl,posh)@
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where our range falls after this 
		search if we have a match on the low range vl will hold the 
		index value, otherwise it will be -1. The same for hgh and vh
		if there is no match for low then cl will hold the index that 
		from there on we have to crack. The same from hgh and ch
		Note that in the case of the low range  we always have to increment 
		by one since we want the values that are after this index 
		(because of the way the crack index is created).
		Also after the search l and h should point to the low and hgh indices 
		(in the crack index) found either as a match or to crack. 
		This is used later on to determine which pieces we have to crack*/

	/* Take the index of the bat */
	if ((c = BATdescriptor(Index[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(Index[m].cbid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

       /* printf("\ncopy %d\n",b->batBuns->storage);
        printf("\ncopyM %d\n",b->batMapbuns);
	*/

	/* find out where in the index the low falls */
	@:searchForLow(@1,@2,@3,@4)@
	@:searchForGapsLow(@1,@2,@3)@

	/* find out where in the index the high falls */
	@:searchForHgh(@1,@2,@3,@4)@
	@:searchForGapsHgh(@1,@2,@3)@
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (vl == -1 || vh == -1){
		if (vl == -1 && vh == -1){
			/* If ch is right after cl in the index then we split this piece in three pieces*/
			if (h == l + xx){
				/*CRACK in three pieces cl-ch */
				@:crkThree(@1,cl,ch)@
			}else{
				/* Else we have to do two cracks separatelly */
				
				/* For the cl bound and the next one in the index*/
				@:crkTwoL(@1)@
				/* For the ch bound and the previous one in the index*/
				@:crkTwoR(@1)@
				if (IndexSize <IndexStop){		
					addTwo_@1(m,low,i1,posA,hgh,i2,posB);
				IndexSize+=2;}
			}
		}else
		if (vl == -1){
			@:crkTwoL(@1)@
			if (IndexSize <IndexStop){
				addOne_@1(m,low,i1,posA);
			IndexSize++;}
		}else
		if (vh == -1){
			@:crkTwoR(@1)@
			if (IndexSize <IndexStop){
				addOne_@1(m,hgh,i2,posB);
			IndexSize++;}
		} 	
	}
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	/*if (firstCrack == 1) TMsubcommit(n);*/
	return MAL_SUCCEED;
}       

str
CRKRange_LeftNil_@1(int *vid, int *bid, @1 *hgh, bit *inclusiveHgh, bit tail)
{
	BAT *b, *c, *bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng cl2=-1, ch=-1; 
	/* index values in the case we have to crack 
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	lng i2=-1;
	BUN ht; 
	int xx;
	BUN h,hh,posB;
        
	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat, 
	   we have to create the crack index for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE; 
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;
		
		m = newIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in two pieces cl-ch */
		ch = BUNindex(b, BUNlast(b) - BUNsize(b));
		@:crkTwoRFirst(@1)@
		posB = BUNfirst(c);
		addOne_@1(m,hgh,i2,posB);

		vl = BUNindex(b,BUNfirst(b));
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where the high falls */

	if ((c = BATdescriptor(Index[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(Index[m].cbid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	vl = BUNindex(b,BUNfirst(b));

	/* find out where in the index the high falls */
	@:searchForHgh(@1,@2,@3,@4)@
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (vh == -1){
		@:crkTwoR(@1)@
		addOne_@1(m,hgh,i2,posB);
	} 	
	
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}       

str
CRKRange_RightNil_@1(int *vid, int *bid, @1 *low, bit *inclusiveLow, bit tail)
{
	BAT *b, *c, *bo;
	BAT *view;
	int  m;
	lng vl=-1, vh=-1; 
	/* vl and vh are the low and high index values to create the view with the result */
	lng ch1=-1, cl=-1; 
	/* index values in the case we have to crack 
		|cl...........ch1|.....................|cl2.........ch|
		if we have to crack only one piece, i.e., if our range falls 
		in one piece only then we crack from cl to ch otherwise we use 
		the other indices as it is shown */
	lng i1=-1;
	BUN lt; 
	int xx;
	BUN l, lh, h1, posA;
        
	m = existsIndex(*bid);
	/* if this is the first time we select something from this bat, 
	   we have to create the crack index for it and 
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		b = BATmaterializeh(b,BATcount(b));
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE; 
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;
		
		m = newIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(Index[m].cid)) == NULL) 
			return throwMessage("crackers.crackRange", "Cannot access crack index");

		/* Since the index is empty we know we have to crack 
		   anyway so crack in two pieces cl-ch */
     	        cl = BUNindex(b,  BUNfirst(b));
		@:crkTwoLFirst(@1)@
		posA = BUNfirst(c);
		addOne_@1(m,low,i1,posA);

		vh = BUNindex(b,BUNlast(b)-BUNsize(b));
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	/* If an index exists for this bat (so it has been cracked before) 
		we search the index to find where the high falls */

	if ((c = BATdescriptor(Index[m].cid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(Index[m].cbid)) == NULL) 
		return throwMessage("crackers.crackRange", "Cannot access crack index");

	xx = BUNsize(c);

	/* find out where in the index the low falls */
	@:searchForLow(@1,@2,@3,@4)@

	/* find out where in the index the high falls */
	vh = BUNindex(b,BUNlast(b)-BUNsize(b));
/*	
printf("lh: %lld, lt:%d \n",*(lng*)lh,*(int*)lt);
printf("hh: %lld, ht:%d \n",*(lng*)hh,*(int*)ht);
printf("vl: %lld, vh:%lld, cl:%lld, ch:%lld \n",vl,vh,cl,ch);
*/
	/* If one or both of the result view bounds were not found using the 
	index then we have to crack */
	if (vl == -1){
		@:crkTwoL(@1)@
		addOne_@1(m,low,i1,posA);
	} 	
	
/*
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,l), BUNindex(c,lt), BUNindex(c,lh));
printf("Index from ptr:"SZFMT", tail:"SZFMT", head:"SZFMT"\n",BUNindex(c,h), BUNindex(c,ht), BUNindex(c,hh));
printf("vl: %lld, vh:%lld, cl:%lld, ch1:%lld, cl2:%lld, ch:%lld \n",vl,vh,cl,ch1,cl2,ch);
*/	
	@:CreateResult()@
	return MAL_SUCCEED;
}      
@

@= SelectFunctions
mal_export str CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{		
	if (IndexType == 1){	
		if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, TRUE);
		else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, TRUE);
		else 
			return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);
	} else {
		if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRange_LeftNil_@1(vid, bid, hgh, inclusiveHgh, TRUE);
		else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRange_RightNil_@1(vid, bid, low, inclusiveLow, TRUE);
		else 
			return CRKRange_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);
	}

        return throwMessage("crackers.CRKselectBounds_@1", "case not handled");
}

mal_export str CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKuselectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh)
{
	if (IndexType == 1){	
		if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, FALSE);
		else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, FALSE);
		else 
			return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);
	} else {
		if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRange_LeftNil_@1(vid, bid, hgh, inclusiveHgh, FALSE);
		else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
			return CRKRange_RightNil_@1(vid, bid, low, inclusiveLow, FALSE);
		else 
			return CRKRange_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);
	}

        return throwMessage("crackers.CRKuselectBounds_@1", "case not handled");
}

str                             
CRKselectValue_@1(int *vid, int *bid, @1 *value)
{                                       
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
} 
                
str
CRKuselectValue_@1(int *vid, int *bid, @1 *value)
{
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
}

str
CRKselect_@1(int *vid, int *bid, @1 *low, @1 *hgh)
{
	bit inclusive = TRUE;
	return CRKselectBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}

str                             
CRKuselect_@1(int *vid, int *bid, @1 *low, @1 *hgh)
{                               
	bit inclusive = TRUE;
	return CRKuselectBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}

@= JoinSelectBody
/* 
Joins a left=[oid,void] bat with a right=[void, any_type] bat on head-OIDs. 
From the right bat, only BUNs that pass the range-restriction on the tail qualify. 
The result is a [oid,void] bat.
*/
	BAT *d;
	BUN rt, rbase, dt;
	int zz, dd;
	oid rmin, rmax;
	bit d_hdense = FALSE;

	rmin = *(oid*)BUNhead(r, BUNfirst(r));
	rmax = rmin + (BATcount(r) - 1);
	zz = BUNsize(r);
	rbase = BUNtloc(r, BUNfirst(r)) - rmin*zz;

	if (!inPlace || l->batParentid != 0 || l->htype == TYPE_void) {
		d = BATnew(TYPE_oid, TYPE_void, MIN(BATcount(l), BATcount(r)));
	} else {
		d = l;
	}
	dt = BUNhloc(d, BUNfirst(d));
	dd = BUNsize(d);

	/* For each BUN of the left bat check if the corresponding BUN in the right bat satisfies the restriction.
	   If yes the respective oid is added to the result */
	if (BAThdense(l)) {
		oid lv = MAX(rmin, *(oid*)BUNhead(l, BUNfirst(l)));
		oid llast = MIN(rmax, lv + (BATcount(l) - 1));
		oid l0 = lv;
		BUN d0 = dt;
		rt = rbase + lv*zz;
		while (lv <= llast) {
			if (@1) {
				*(oid*)dt = lv; 
				dt += dd;	
			}		
			lv++;
			rt += zz;
		}
		d_hdense = ((dt - d0)/dd == (lv - l0));
	} else {
		int xx = BUNsize(l);
		BUN llast = BUNhloc(l, BUNlast(l));
		BUN lt = BUNhloc(l, BUNfirst(l));
		oid lv = oid_nil;

		if (isForeignKey) {
			while (lt < llast) {
				lv = *(oid*)lt;
				rt = rbase + lv*zz;
				if (@1) {
					*(oid*)dt = lv; 
					dt += dd;	
				}	
				lt += xx;
			}
		} else if (BAThordered(l)&1) {
			while(lt < llast && (lv = *(oid*)lt) < rmin) {
				lt += xx;
			}
			while(lt < llast && (lv = *(oid*)lt) <= rmax) {
				rt = rbase + lv*zz;
				if (@1) {
					*(oid*)dt = lv; 
					dt += dd;	
				}	
				lt += xx;
			}
		} else {
			while(lt < llast){
			    lv = *(oid*)lt;
			    if (lv >= rmin && lv <= rmax) {
				rt = rbase + lv*zz;
				if (@1){
					*(oid*)dt = lv; 
					dt += dd;	
				}	
			    }
			    lt += xx;
			}
		}
	}

	d->batBuns->free = dt - d->batBuns->base;
    	BATsetcount(d, d->batBuns->free/dd);
	d->hsorted = (BATcount(d)<2 || BAThordered(l)&1) ? GDK_SORTED : 0;
	d->hdense = BATcount(d)<2 || d_hdense;
	if (d->hdense) {
		if (BATcount(d)==0) {
			/* does not really matter */
			BATseqbase(d, (oid)0);
		} else {
			BATseqbase(d, *(oid*)BUNhloc(d,BUNfirst(d)));
		}
	} else {
		BATseqbase(d, oid_nil);
	}
	BATkey(d, BATcount(d)<2 || l->hkey);
	d->tsorted = FALSE;
	d->tdense = FALSE;
	BATseqbase(BATmirror(d), oid_nil);
	BATkey(BATmirror(d), FALSE);
	d->batRestricted= BAT_READ;
	BBPkeepref(d->batCacheid);
	*res=d->batCacheid;

	if (d != l) {
		BBPunfix(l->batCacheid);
	}
	BBPunfix(r->batCacheid);
	
	return MAL_SUCCEED;
@

@= JoinSelectR
str
JoinSelectRange_@2_@3_@1(int *res, BAT *l, BAT *r, @1 *low, @1 *hgh, bit inPlace, bit isForeignKey)
{
	@:JoinSelectBody(@6_@4(rt,low,@7@1) && @6_@5(rt,hgh,@7@1))@
} 
@
        
@= JoinSelectS
str
JoinSelectSingle_@2_@1(int *res, BAT *l, BAT *r, @1 *mid, bit inPlace, bit isForeignKey)
{
	@:JoinSelectBody(@4_@3(rt,mid,@5@1))@
}         
@

@= JoinSelectOperations
@:JoinSelectR(@1,LO,RE,GT,LE,@2,@3)@
@:JoinSelectR(@1,LE,RE,GE,LE,@2,@3)@
@:JoinSelectR(@1,LO,RO,GT,LT,@2,@3)@
@:JoinSelectR(@1,LE,RO,GE,LT,@2,@3)@
@:JoinSelectS(@1,RO,LT,@2,@3)@
@:JoinSelectS(@1,RE,LE,@2,@3)@
@:JoinSelectS(@1,LO,GT,@2,@3)@
@:JoinSelectS(@1,LE,GE,@2,@3)@
@

@= JoinSelectFunctions
mal_export str CRKjoinSelectDefault_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left);
mal_export str CRKjoinSelectBounds_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left, bit *inPlace, bit *isForeignKey);

str
CRKjoinSelectDefault_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left)
{
	bit inPlace = FALSE;
	bit isForeignKey = FALSE;
	return CRKjoinSelectBounds_@1( res, right, low, hgh, inclusiveLow, inclusiveHgh, left, &inPlace, &isForeignKey);
}

str
CRKjoinSelectBounds_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left, bit *inPlace, bit *isForeignKey)
{
	BAT *l, *r;

	if ((l = BATdescriptor(*left)) == NULL) {
        	return throwMessage("crackers.crackJoinSelect", "Cannot access descriptor");
        }

	if ((r = BATdescriptor(*right)) == NULL) {
		BBPunfix(*left);
        	return throwMessage("crackers.crackJoinSelect", "Cannot access descriptor");
        }

	if (!BAThdense(r)) {
		BBPunfix(*left);
		BBPunfix(*right);
		return throwMessage("crackers.crackJoinSelect", "right BAT must have a dense head");
	}

	if (BATcount(l) == 0 || BATcount(r) == 0){
		BAT *d = BATnew(TYPE_oid, TYPE_void, 0);
		d->batBuns->free = 0;
		BATsetcount(d, 0);
		d->hsorted = GDK_SORTED;
		d->hdense = TRUE;
		BATseqbase(d, (oid)0);
		BATkey(d, TRUE);
		d->tsorted = FALSE;
		d->tdense = FALSE;
		BATseqbase(BATmirror(d), oid_nil);
		BATkey(BATmirror(d), FALSE);
		d->batRestricted= BAT_READ;
		BBPkeepref(d->batCacheid);
		*res = d->batCacheid;
		BBPunfix(*left);
		BBPunfix(*right);
		return MAL_SUCCEED;
	}	

        if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingle_RE_@1(res, l, r, hgh, *inPlace, *isForeignKey);
		else 
                	return JoinSelectSingle_RO_@1(res, l, r, hgh, *inPlace, *isForeignKey);
	}
        else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingle_LE_@1(res, l, r, low, *inPlace, *isForeignKey);
		else 
                	return JoinSelectSingle_LO_@1(res, l, r, low, *inPlace, *isForeignKey);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRange_LE_RE_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else 
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRange_LE_RO_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else 
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRange_LO_RO_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else 
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRange_LE_RE_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
	}
        return throwMessage("crackers.crackJoinSelect", "case not handled");
}
@
         
@c
@:crackOperations(chr,simple,,chr)@
@:crackOperations(sht,simple,,sht)@
@:crackOperations(int,simple,,int)@
@:crackOperations(lng,simple,,lng)@
@:crackOperations(flt,simple,,flt)@
@:crackOperations(dbl,simple,,dbl)@
@:crackOperations(date,atom,TYPE_,loc)@

@:SelectFunctions(chr,simple,)@
@:SelectFunctions(sht,simple,)@
@:SelectFunctions(int,simple,)@
@:SelectFunctions(lng,simple,)@
@:SelectFunctions(flt,simple,)@
@:SelectFunctions(dbl,simple,)@
@:SelectFunctions(date,atom,TYPE_)@

@:JoinSelectOperations(chr,simple,)@                        
@:JoinSelectOperations(sht,simple,)@                        
@:JoinSelectOperations(int,simple,)@                        
@:JoinSelectOperations(lng,simple,)@                        
@:JoinSelectOperations(flt,simple,)@                        
@:JoinSelectOperations(dbl,simple,)@                        
@:JoinSelectOperations(date,atom,TYPE_)@

@:JoinSelectFunctions(chr,simple,)@
@:JoinSelectFunctions(sht,simple,)@
@:JoinSelectFunctions(int,simple,)@
@:JoinSelectFunctions(lng,simple,)@
@:JoinSelectFunctions(flt,simple,)@
@:JoinSelectFunctions(dbl,simple,)@
@:JoinSelectFunctions(date,atom,TYPE_)@


