@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rdf
@a Peter Boncz, Marco Antonelli
@+ Raptor (librdf.org) library interface
Raptor is a free software / Open Source C library that provides a set
of parsers and serializers that generate Resource Description Framework
(RDF) triples by parsing syntaxes or serialize the triples into a syntax.
The supported parsing syntaxes are RDF/XML, N-Triples, TRiG, Turtle, RSS
tag soup including all versions of RSS, Atom 1.0 and 0.3, GRDDL and
microformats for HTML, XHTML and XML. The serializing syntaxes are RDF/XML
(regular, and abbreviated), N-Triples, RSS 1.0, Atom 1.0 and Adobe XMP.
@{
@mal
module rdf;

command importGraph(fileurl:str, syntax:str, db:str, graph:str, lim:lng) : void
address RDFimportGraph
comment "import a graph in a named rdf db";

command exportGraph(db:str, graph:str, fileurl:str, order:str, syntax:str) : void
address RDFexportGraph
comment "export a graph in a named rdf db";


@+ Implementation


@c
#include "mal_config.h"
#include "mal.h"
#include "mal_exception.h"
#include "mtime.h"

#include <gdk_bbp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <raptor.h>
#include <stdbool.h>
#include <ctype.h>

#define rdf_export extern
#define RET_MAXLEN 1024
#define NUMBER_OF_TYPES 20
#define TYPE2XSD "RDFtype2xsd"

typedef enum
{
	RDF_TYPE_DECIMAL = 0,
	RDF_TYPE_INTEGER = 1,
	RDF_TYPE_NPOS_INT = 2,
	RDF_TYPE_NEG_INT = 3,
	RDF_TYPE_NNEG_INT = 4,
	RDF_TYPE_POS_INT = 5,
	RDF_TYPE_LONG = 6,
	RDF_TYPE_ULONG = 7,
	RDF_TYPE_INT = 8,
	RDF_TYPE_UINT = 9,
	RDF_TYPE_SHORT = 10,
	RDF_TYPE_USHORT = 11,
	RDF_TYPE_BYTE = 12,
	RDF_TYPE_UBYTE = 13,
	RDF_TYPE_FLOAT = 14,
	RDF_TYPE_DOUBLE = 15,
	RDF_TYPE_BOOLEAN = 16,
	RDF_TYPE_STRING = 17,
	RDF_TYPE_DATETIME = 18,
	RDF_TYPE_XML_LITERAL = 19,
	RDF_TYPE_PLAIN = 20,
	RDF_TYPE_OTHER = 21,
	RDF_TYPE_NULL = 22
} rdf_type;

typedef enum
{
    RDF_SEC_BLANK = '0',
    RDF_SEC_IRI = '1',
    RDF_SEC_NEG_INF = '2',
    RDF_SEC_NEG_NUM = '3',
    RDF_SEC_FALSE = '4',
    RDF_SEC_ZERO = '5',
    RDF_SEC_EMPTY_STRING = '6',
    RDF_SEC_LANG_EMPTY_STRING = '7',
    RDF_SEC_STRING = '8',
    RDF_SEC_LANG_STRING = '9',
    RDF_SEC_TRUE = 'A',
    RDF_SEC_POS_NUM = 'B',
    RDF_SEC_POS_INF = 'C',
    RDF_SEC_DATETIME = 'D',
    RDF_SEC_XML_LITERAL = 'E',
    RDF_SEC_OTHER = 'F',
    RDF_SEC_NAN = 'Z'
} rdf_section;

typedef struct {
    raptor_parser *parser;
    lng *cur;
    lng *lim;
    BAT *map;
    BAT *type2xsd;
    BAT *ob;
    BAT *pb;
    BAT *sb;
    BAT *tb;
    str *ret;
    char *ret_array;
} triple_handler_vars;

typedef struct {
    raptor_parser *parser;
    raptor_serializer *serializer;
    str *ret;
    char *ret_array;
} message_handler_vars;

typedef struct
{
    timestamp *tstamp;
    bool msecs_dealloc;
    str msecs;
    bool tzone_dealloc;
    str tzone;
} rdf_datetime;

static str rdf_datetime_new(rdf_datetime **ret)
{
    str msg = MAL_SUCCEED;
    *ret = GDKmalloc(sizeof(rdf_datetime));
    if (*ret)
    {
        (*ret)->msecs = NULL;
        (*ret)->tzone = NULL;
        (*ret)->msecs_dealloc = false;
        (*ret)->tzone_dealloc = false;
        (*ret)->tstamp = GDKmalloc(sizeof(timestamp));
        if (! (*ret)->tstamp)
        {
            msg = "Could not allocate memory for a timestamp";
            GDKfree(*ret);
        }
    }
    else
        msg = "Could not allocate memory for rdf_datetime";
    return msg;
}

static void rdf_datetime_delete(rdf_datetime *dt)
{
    if (dt->msecs_dealloc)
        GDKfree(dt->msecs);
    if (dt->tzone_dealloc)
        GDKfree(dt->tzone);
    GDKfree(dt->tstamp);
    GDKfree(dt);
}

static str rdf_datetime_set_msecs(rdf_datetime *dt, str msecs)
{
    str ret = MAL_SUCCEED;
    if (msecs)
    {
        int len = strlen(msecs);
        dt->msecs = GDKmalloc(len + 1);
        if (dt->msecs)
        {
            dt->msecs_dealloc = true;
            strncpy(dt->msecs, msecs, len + 1);
        }
        else
            ret = "Could not allocate memory for the 'msecs' field of rdf_datetime";
    }
    else
        dt->msecs = "";
    return ret;
}

static str rdf_datetime_set_tzone(rdf_datetime *dt, str tzone)
{
    str ret = MAL_SUCCEED;
    if (tzone)
    {
        dt->tzone = GDKmalloc(7);
        if (dt->tzone)
        {
            dt->tzone_dealloc = true;
            if (!strcmp(tzone, "Z"))
                tzone = "+00:00";
            strncpy(dt->tzone, tzone, 7);
        }
        else
            ret = "Could not allocate memory for the 'tzone' field of rdf_datetime";
    }
    else
        dt->tzone = "";
    return ret;
}

/*TODO
static lng RDFestimate(str url) {
    url=NULL;
    return 8048;
}*/

static rdf_type RDFxsdToType(str uri, BAT *m)
{
    rdf_type ret;
    if (uri == NULL)
        ret = RDF_TYPE_PLAIN;
    else
    {
    	BUN bun;
    	BATiter mi = bat_iterator(BATmirror(m));
    	HASHfnd_str(bun, mi, uri);
    	if (bun == BUN_NONE)
    		ret = RDF_TYPE_OTHER;
    	else
    		ret = (rdf_type) bun;
    }
    return ret;
}

static str RDFtypeToXsd(rdf_type t, BAT *m)
{
    str ret = NULL;
    if (t<NUMBER_OF_TYPES)
    {
    	BATiter it = bat_iterator(m);
    	ret = BUNtail(it, t);
    }
    return ret;
}

static str RDFparseTimezone(str timezone)
{
    str ret = MAL_SUCCEED;
    int timezone_len = strlen(timezone);
    if (timezone_len == 1 && timezone[0] == 'Z')
        ;
    else
    {
        if (timezone_len == 6)
        {
            if (    (timezone[0] == '+' || timezone[0] == '-') &&
                    isdigit(timezone[1]) && isdigit(timezone[2]) &&
                    timezone[3] == ':' &&
                    isdigit(timezone[4]) && isdigit(timezone[5]) )
            {
                char hour_str[4], min_str[3];
                int hour, min;
                strncpy(hour_str, &timezone[0], 3);
                hour_str[3] = '\0';
                strncpy(min_str, &timezone[4], 2);
                min_str[2] = '\0';
                hour = strtol(hour_str, NULL, 10);
                if (hour < -14 || hour > 14)
                    ret = "Timezone hour shoud range from -14 to +14";
                else
                {
                    min = strtol(min_str, NULL, 10);
                    if (min < 0 || min > 59)
                        ret = "Timezone minutes shoud range from 0 to 59";
                    else
                    {
                        if (abs(hour) == 14 && min != 0)
                            ret = "When timezone hour is +/- 14, timezone minutes must be 0";
                        else
                            ret = MAL_SUCCEED;
                    }
                }
            }
            else
                ret = "Valid timezones are signed times of a day, between -14:00 and +14:00";
        }
        else
            ret = "Timezone too short";
    }
    return ret;
}

static str RDFparseFractions(str fractions)
{
    str ret = MAL_SUCCEED;
    int fractions_len = strlen(fractions);
    int i = 0;
    while (i<fractions_len)
    {
        if (!isdigit(fractions[i]))
            ret = "A non-digit has been found parsing the second fractions";
        i++;
    }
    return ret;
}

static str RDFparseSeconds(str seconds)
{
    str ret = MAL_SUCCEED;
    int seconds_len = strlen(seconds);
    if (seconds_len == 2)
    {
        int i = 0;
        while (i<seconds_len && ret==MAL_SUCCEED)
        {
            if (!isdigit(seconds[i]))
                ret = "A non-digit has been found parsing the seconds";
            i++;
        }
    }
    else
        ret = "Seconds should be a two-digit number";
    return ret;
}

static str RDFparseMinutes(str minutes)
{
    str ret = MAL_SUCCEED;
    int minutes_len = strlen(minutes);
    if (minutes_len == 2)
    {
        int i = 0;
        while (i<minutes_len && ret==MAL_SUCCEED)
        {
            if (!isdigit(minutes[i]))
                ret = "A non-digit has been found parsing the minutes";
            i++;
        }
    }
    else
        ret = "Minutes should be a two-digit number";
    return ret;
}

static str RDFparseHour(str hour)
{
    str ret = MAL_SUCCEED;
    int hour_len = strlen(hour);
    if (hour_len == 2)
    {
        int i = 0;
        while (i<hour_len && ret==MAL_SUCCEED)
        {
            if (!isdigit(hour[i]))
                ret = "A non-digit has been found parsing the hour";
            i++;
        }
    }
    else
        ret = "An hour should be a two-digit number";
    return ret;
}

static str RDFparseDay(str day)
{
    str ret = MAL_SUCCEED;
    int day_len = strlen(day);
    if (day_len == 2)
    {
        int i = 0;
        while (i<day_len && ret==MAL_SUCCEED)
        {
            if (!isdigit(day[i]))
                ret = "A non-digit has been found parsing the day";
            i++;
        }
    }
    else
        ret = "A day should be a two-digit number";
    return ret;
}

static str RDFparseMonth(str month)
{
    str ret = MAL_SUCCEED;
    int month_len = strlen(month);
    if (month_len == 2)
    {
        int i = 0;
        while (i<month_len && ret==MAL_SUCCEED)
        {
            if (!isdigit(month[i]))
                ret = "A non-digit has been found parsing the month";
            i++;
        }
    }
    else
        ret = "A month should be a two-digit number";
    return ret;
}

static str RDFparseYear(str year)
{
    str ret = MAL_SUCCEED;
    int year_len = strlen(year);
    int i = 0;
    if (year[0]=='-')
    {
        year = &year[1];
        year_len--;
    }
    if (year_len >= 4)
    {
        while (i<year_len && ret==MAL_SUCCEED)
        {
            if (!isdigit(year[i]))
                ret = "A non-digit has been found parsing the year";
            i++;
        }
        if (ret==MAL_SUCCEED && year_len > 4 && year[0]=='0')
            ret = "Leading zeros are prohibited when year length is grater than 4";
        if (ret==MAL_SUCCEED && year_len == 4)
        {
            bool is0000 = true;/* is the year==0000? it is prohibited */
            for (i=0; i<year_len && is0000; i++)
                if (year[i]!='0')
                    is0000 = false;
            if (is0000)
                ret = "Year 0000 is prohibited";
        }
    }
    else
        ret = "A year must have 4 or more digits";
    return ret;
}

static str rdf_datetime_set_MTIMEtimestamp(rdf_datetime *dt, str year, str month, str day, str hour, str minutes, str seconds, str timezone)
{
    /* mtime.mx does not accept hour 24:00:00, while xml schema does, and in this case
     * it means it is hour 00:00:00 of the next day. This case is treated here */
    
    /* 16 is the sum of lengths of these strings:
     * month, day, hour, minutes, seconds, timezone, separators:
     * 2 + 2 + 2 + 2 + 2 + 6 + 6 */
    str ret = MAL_SUCCEED;
    int len = strlen(year) + 22;
    bool add_a_day = false;
    char tstamp_array[len+1];
    str tstamp_str = tstamp_array;
    bit isnil;
    int rv;
    
    if (timezone == NULL || !strcmp(timezone, "Z"))
        timezone = "+00:00";
    
    if (!strcmp(hour, "24") && !strcmp(minutes, "00") && !strcmp(seconds, "00"))
    {
        hour = "00";
        minutes = "00";
        seconds = "00";
        add_a_day = true;
    }
    snprintf(tstamp_str, len+1, "%s-%s-%s %s:%s:%s %s", year, month, day, hour, minutes, seconds, timezone);
    rv = timestamp_fromstr(tstamp_str, &len, &(dt->tstamp));
    MTIMEtimestamp_isnil(&isnil, dt->tstamp);
    if (rv>0 && !isnil)
    {
        if (add_a_day)
        {
            lng msecs = 24 * 60 * 60 * 1000;
            MTIMEtimestamp_add(dt->tstamp, dt->tstamp, &msecs);
        }
    }
    else
        ret = "mtime.mx could not parse the timestamp";
    return ret;
}
/* 
 * This function parses xml dateTimes, full documentation can
 * be found at http://www.w3.org/TR/xmlschema-2/#dateTime.
 * The lexical form is '-'? yyyy '-' mm '-' dd 'T' hh ':' mm ':' ss ('.' s+)? (zzzzzz)?
 * mtime.mx does not handle fractions of second with more than three digits,
 * here they can be arbitrarly long => see ('.' s+)? in lexical form
 * Datetimes with timezone are normalized to UTC, but the original timezone
 * is stored as well, so this permits:
 * - to obtain the original timezone (if ever needed)
 * - to distinguish between d.t. that originally had a timezone and
 *       those who didn't had it.
 * 
 * The final string, as will be found in the map bat, is:
 * 
 * (1 hex char Prefix) (16 hex chars representing mtime.mx timestamp) (second fractions)
 * (+ or -)(absolute timezone)
 * 
 * For example, datetime 1236-12-15T05:00:00.123+05:00 becomes (D is the prefix)
 * D8006e4cd00000000123+05:00
 * TODO Some bits of mtime.mx timestamps are wasted:
 * timestamp saves the hour of a day in milliseconds, here
 * timestamp are used only with second resolution, since
 * milliseconds are saved as strings. Saving millisecons in
 * hex chars instead of decimal chars, and timezones in
 * some kind of binary format may be worth.
 */
static str RDFparseDateTime(rdf_datetime *dt, str date_string)
{
    str ret = MAL_SUCCEED;
    if (dt)
    {
        int date_len = strlen(date_string);
        chr date_array[date_len+1];
        str date = (str)date_array;
        strncpy(date, date_string, date_len+1);
        if (date_len >= 19)
        {
            int i;
            str year = NULL;
            str month = NULL;
            str day = NULL;
            str hour = NULL;
            str minutes = NULL;
            chr seconds[3];
            str fractions = NULL;
            str timezone = NULL;
            
            year = date;
            if (date[0] == '-')
            {
                date = &date[1];
                date_len--;
            }
            /*'-'? yyyy '-' mm '-' dd 'T' hh ':' mm ':' ss ('.' s+)? (zzzzzz)?*/
            /* find year separator */
            i = 0;
            while (date[i] != '-' && i<date_len)
                i++;
            /* '-' is at i */
            if (i <= date_len - 15)
            {
                date[i] = '\0';
                month = &date[i+1];
                /* find month separator */
                while (date[i] != '-' && i<date_len)
                    i++;
            }
            if (i <= date_len - 12)
            {
                date[i] = '\0';
                day = &date[i+1];
                /* find day separator */
                while (date[i] != 'T' && i<date_len)
                    i++;
            }
            if (i <= date_len - 9)
            {
                date[i] = '\0';
                hour = &date[i+1];
                /* find hour separator */
                while (date[i] != ':' && i<date_len)
                    i++;
            }
            if (i <= date_len - 6)
            {
                date[i] = '\0';
                minutes = &date[i+1];
                /* find minutes separator */
                while (date[i] != ':' && i<date_len)
                    i++;
            }
            if (i <= date_len - 3)
            {
                date[i++] = '\0';
                seconds[0] = date[i++];
                seconds[1] = date[i++];
                seconds[2] = '\0';
            }
            if (i<date_len)
            {
                if (date[i] == '.' && i<date_len-1)/*fractions of second*/
                {
                    str fractions_start; 
                    int fractions_len = 0;
                    i++;
                    fractions_start = &date[i];
                    /* find fractions separator */
                    while(date[i] != '+' && date[i] != '-' && date[i] != 'Z' && i<date_len)
                    {
                        i++;
                        fractions_len++;
                    }
                    fractions = GDKmalloc(fractions_len+1);
                    if (fractions)
                    {
                        strncpy(fractions, fractions_start, fractions_len);
                        fractions[fractions_len] = '\0';
                    }
                    else
                        ret = "Could not allocate memory for fractions of seconds";
                }
                if (ret == MAL_SUCCEED && (date[i] == '+' || date[i] == '-' || date[i] == 'Z')) /* timezone */
                {
                    timezone = &date[i];
                    i = date_len;
                }
            }
            if (ret == MAL_SUCCEED)
            {
                ret = RDFparseYear(year);
                if (ret == MAL_SUCCEED)
                {
                    ret = RDFparseMonth(month);
                    if (ret == MAL_SUCCEED)
                    {
                        ret = RDFparseDay(day);
                        if (ret == MAL_SUCCEED)
                        {
                            ret = RDFparseHour(hour);
                            if (ret == MAL_SUCCEED)
                            {
                                ret = RDFparseMinutes(minutes);
                                if (ret == MAL_SUCCEED)
                                {
                                    ret = RDFparseSeconds((str)seconds);
                                    if (ret == MAL_SUCCEED)
                                    {
                                        if (fractions != NULL)
                                            ret = RDFparseFractions(fractions);
                                        if (ret == MAL_SUCCEED)
                                        {
                                            if (timezone != NULL)
                                            {
                                                ret = RDFparseTimezone(timezone);
                                            }
                                            if (ret == MAL_SUCCEED)
                                            {
                                                ret = rdf_datetime_set_MTIMEtimestamp(dt, year, month, day, hour, minutes, (str)seconds, timezone);
                                                if (ret == MAL_SUCCEED)
                                                {
                                                    ret = rdf_datetime_set_msecs(dt, fractions);
                                                    if (ret == MAL_SUCCEED)
                                                        ret = rdf_datetime_set_tzone(dt, timezone);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (fractions != NULL)
                GDKfree(fractions);
        }
        else
            ret = "DateTime string too short";
    }
    else
        ret = "rdf_datetime should not be NULL";
    return ret;
}

static INLINE void rdf_datetime_toString(str ret, size_t len, rdf_datetime *datetime)
{
    bool firstCharFound = false;
    unsigned long long mask = 0x8000000000000000;
    unsigned long long l = *(unsigned long long*)datetime->tstamp ^ mask;
    snprintf(ret, len, "%16llx%s%s", l, datetime->msecs, datetime->tzone);
    /* change leading white spaces to 0 */
    for (int i=0; i<16 && !firstCharFound; i++)
        if (ret[i] == ' ')
            ret[i] = '0';
        else
            firstCharFound = true;
}

static void rdf_datetime_fromString(rdf_datetime *dt, str string)
{
    char tstamp_str[17];
    unsigned long long l, mask = 0x8000000000000000;
    timestamp *tmp;
    snprintf(tstamp_str, 17, string);
    tstamp_str[16] = '\0';
    string = &string[16];
    if (strcmp(string, ""))
    {
        /* find timezone separator */
        int i;
        for (i=0; string[i]!='+' && string[i]!='-' && string[i]!='\0'; i++)
            ;
        {
            str timezone = &string[i];
            if (i>0)
            {
                char msecs[i+1];
                snprintf(msecs, i+1, string);
                msecs[i] = '\0';
                rdf_datetime_set_msecs(dt, msecs);
            }
            if (strlen(timezone)>0)
                rdf_datetime_set_tzone(dt, timezone);
        }
    }
    l = strtoull(tstamp_str, NULL, 16);
    l ^= mask;
    tmp = (timestamp *)(lng*)&l;
    dt->tstamp->msecs = tmp->msecs;
    dt->tstamp->days = tmp->days;
}
#define RDF_NEGATIVE_MASK 0xffffffffffffffff
#define RDF_POSITIVE_MASK 0x8000000000000000
static void RDFdoubleToHexString(str ret, double val)
{
    unsigned long long l;
    bool firstCharFound = false;
    l = *((unsigned long long*)(dbl*)&val);
    if (val == 0)
        return;/* 0 is a special case in Monet/RDF and it has not to be converted to string here */
    if (val<0)
        l ^= RDF_NEGATIVE_MASK;
    else
        l^= RDF_POSITIVE_MASK;
    snprintf(ret, 17, "%16llx", l);
    /* change leading white spaces to 0 */
    for (int i=0; i<16 && !firstCharFound; i++)
        if (ret[i] == ' ')
            ret[i] = '0';
        else
            firstCharFound = true;
}

static double RDFhexStringToDouble(str string)
{
    double ret;
    unsigned long long l, ispos;
    l = strtoull(string, NULL, 16);
    ispos = l >> 63; /* sign bit is the first, so shift 63 */
    if (ispos)
        l ^= RDF_POSITIVE_MASK;
    else
        l ^= RDF_NEGATIVE_MASK;
    ret = *((double*)(lng*)&l);
    return ret;
}

static str RDFisDigitSequence(str string)
{
    str ret = MAL_SUCCEED;
    int len = strlen(string);
    if (len > 0)
    {
        for (int i=0; i<len && ret == MAL_SUCCEED; i++)
            if (!isdigit(string[i]))
                ret = "Found a non-digit character";
    }
    else
        ret = "Zero length strings are not digit sequences";
    return ret;
}

static str RDFisLexicalNegativeInteger(str string)
{
    str ret = MAL_SUCCEED;
    if (strlen(string)>0)
    {
        if (string[0] == '-')
            ret = RDFisDigitSequence(&string[1]);
        else
            ret = "A negative integer should start with \'-\'";
    }
    else
        ret = "A zero length string is not a valid negative integer";
    return ret;
}

static str RDFisLexicalPositiveInteger(str string)
{
    str ret = MAL_SUCCEED;
    if (strlen(string)>0)
    {
        if (string[0] == '+')
            string = &string[1];
        ret = RDFisDigitSequence(string);
    }
    else
        ret = "A zero length string is not a valid positive integer";
    return ret;
}

static str RDFisLexicalInteger(str string)
{
    str ret = MAL_SUCCEED;
    int len = strlen(string);
    if (len>0)
    {
        if (string[0] == '+' || string[0] == '-')
            ret = RDFisDigitSequence(&string[1]);
        else
            ret = RDFisDigitSequence(string);
    }
    else
        ret = "Zero length strings are not valid integers";
    return ret;
}

static str RDFisLexicalDecimal(str string)
{
    str ret = MAL_SUCCEED;
    int len = strlen(string);
    if (len>0)
    {
        int i;
        for (i=0; i<len && string[i] != '.'; i++)
            ;
        {
            char int_part[i+1];
            str fract_part = NULL;
            strncpy(int_part, string, i);
            int_part[i] = '\0';
            if (string[i] == '.')
            {
                if (i<len-1)
                    fract_part=&string[i+1];
                else
                    return "The decimal number has no fractional part after the dot";
            }
            ret = RDFisLexicalInteger(int_part);
            if (ret == MAL_SUCCEED)
                if (fract_part != NULL)
                    ret = RDFisDigitSequence(fract_part);
        }
    }
    else
        ret = "Zero length strings are not valid decimals";
    return ret;
}

static str RDFisLexicalFloatingPoint(str string, bool isDouble)
{
    str ret = MAL_SUCCEED;
    int len = strlen(string);
    if (len>0)
    {
        int i;
        if (!strcmp(string, "INF") || !strcmp(string, "-INF") || !strcmp(string, "NaN"))
            return MAL_SUCCEED;
        for (i=0; i<len && string[i] != 'e' && string[i] != 'E'; i++);/*semicolon!*/
        {
            /*
             * new block to make possible to declare some stuff without CC complaing
             * for mixing declarations and code
             */
            char mantissa[i+1];
            str exponent = NULL;
            double mantissa_val, exponent_val;
            strncpy(mantissa, string, i);
            mantissa[i] = '\0';
            if (string[i] == 'e' || string[i] == 'E')
            {
                if (i<len-1)
                    exponent=&string[i+1];
                else
                    ret = "There is no exponent after the 'E'";
            }
            if (ret == MAL_SUCCEED)
            {
            	ret = RDFisLexicalDecimal(mantissa);
                if (ret == MAL_SUCCEED && exponent != NULL)
                   ret = RDFisLexicalInteger(exponent);
                if (ret == MAL_SUCCEED)
                {
                    mantissa_val = strtod(mantissa, NULL);
                    if (isDouble)
                    {
                        if (abs(mantissa_val) >= exp2(53))
                            ret = "The mantissa is out of double range, its absolute value should be less than 2^53";
                    }
                    else
                        if (abs(mantissa_val) >= exp2(24))
                            ret = "The mantissa is out of float range, its absolute value should be less than 2^24";
                    if (ret == MAL_SUCCEED && exponent != NULL)
                    {
                        exponent_val = strtod(exponent, NULL);
                        if (isDouble)
                        {
                            if (exponent_val > 970 || exponent_val < -1075)
                                ret = "The exponent is out of double range, should be LE than 970 and GE than -1075";
                        }
                        else
                            if (exponent_val > 104 || exponent_val < -149)
                                ret = "The exponent is out of float range, should be LE than 104 and GE than -149";
                    }
                }
            }
        }
    }
    else
        ret = "An empty string cannot be parsed to a number";
    return ret;
}

static str RDFdecimalStringToDouble(double *val, str string)
{
    str ret = MAL_SUCCEED;
    char *endptr;
    *val = strtod(string, &endptr);
    if (errno == ERANGE && *val == HUGE_VAL)
        ret = "The numeric value is out of the double range";
    else if (*endptr != '\0')
        ret = "Could not convert numeric to double";
    return ret;
}

static str RDFdoubleStringToDouble(double *val, str string)
{
    str ret = MAL_SUCCEED;
    if (!strcmp(string, "INF") || !strcmp(string, "-INF") || !strcmp(string, "NaN"))
        ret = "Cannot parse +/- INF and NaN";
    else
    {
    	/*
    	 * in xml the double lexical form mEn (m decimal, e integer),
    	 * is mapped to the value space by calculating m * 2^n.
    	 * The strtod function parses the same lexical forms by assigning
    	 * a value of m * 10^n.
    	 */
    	char *exp_ptr = strchr(string, 'e');
    	if (exp_ptr==NULL)
    		exp_ptr = strchr(string, 'E');
    	if (exp_ptr == NULL)
        	return RDFdecimalStringToDouble(val, string);
        else
        {
        	int mantissa_len = exp_ptr - string;
	    	int exp_len = strlen(string) - mantissa_len - 1;
        	double mant_val;
        	double exp_val;
        	char mantissa[mantissa_len+1];
        	char exp[exp_len+1];
	    	char *endptr;
        	snprintf(mantissa, mantissa_len+1, string);
        	snprintf(exp, exp_len+1, &exp_ptr[1]);
	        mant_val = strtod(mantissa, &endptr);
	        if (errno == ERANGE && mant_val == HUGE_VAL)
	            ret = "The mantissa value is out of the double range";
	        else if (*endptr != '\0')
	        	ret = "Could not convert numeric to double";
	        if (ret==MAL_SUCCEED)
	        {
				exp_val = strtod(exp, &endptr);
		        if (errno == ERANGE && exp_val == HUGE_VAL)
		            ret = "The exponent value is out of the double range";
		        else if (*endptr != '\0')
		        	ret = "Could not convert numeric to double";
				if (ret == MAL_SUCCEED)
					*val = mant_val * exp2(exp_val);
	        }
        }
    }
    return ret;
}

/* TODO
 * this function was supposed to check value boundaries of xml numeric
 * types as described in http://www.w3.org/TR/xmlschema-2/#built-in-datatypes,
 * but it's really ugly and would probably not compile on 32-bits platform
 * This checks are not performed any more

static str RDFcheckNumericValueSpace(double val, rdf_type t);
*/

static str RDFcheckNumericLexicalSpace(str string, rdf_type t)
{
    switch (t)
    {
        case RDF_TYPE_DECIMAL:
            return RDFisLexicalDecimal(string);
        case RDF_TYPE_INTEGER:
        case RDF_TYPE_NPOS_INT:
        case RDF_TYPE_NNEG_INT:
        case RDF_TYPE_LONG:
        case RDF_TYPE_INT:
        case RDF_TYPE_SHORT:
        case RDF_TYPE_BYTE:
            return RDFisLexicalInteger(string);
        case RDF_TYPE_ULONG:
        case RDF_TYPE_UINT:
        case RDF_TYPE_USHORT:
        case RDF_TYPE_UBYTE:
            return RDFisDigitSequence(string);
        case RDF_TYPE_NEG_INT:
            return RDFisLexicalNegativeInteger(string);
        case RDF_TYPE_POS_INT:
            return RDFisLexicalPositiveInteger(string);
        case RDF_TYPE_FLOAT:
            return RDFisLexicalFloatingPoint(string, false);
        case RDF_TYPE_DOUBLE:
            return RDFisLexicalFloatingPoint(string, true);
        default:
            return "RDFcheckLexicalSpace: type error, default case";
    }
}

static str RDFparseDecimal(double *val, str string, rdf_type type)
{
    str ret = RDFcheckNumericLexicalSpace(string, type);
    if (ret == MAL_SUCCEED)
        ret = RDFdecimalStringToDouble(val, string);
    return ret;
}

void message_handler(void *user_data, raptor_locator *locator, const char *message)
{
    size_t length = 0;
    message_handler_vars *info = (message_handler_vars *)user_data;
    str *ret = info->ret;
    char *ret_array = info->ret_array;
    int written = 0;
    str msg = ret_array;
    *ret = ret_array;
    if (locator->uri)
    {
        written = snprintf(msg, RET_MAXLEN, "In URI location \"%s\": ", (str)raptor_uri_as_string(locator->uri));
        if (written >= RET_MAXLEN)
            ret_array[RET_MAXLEN-1] = '\0';
        length = strlen(*ret);
        msg = *ret + length * (sizeof(char));
    }
    if (locator->line >=0 && length < RET_MAXLEN-1)
    {
        written = snprintf(msg, RET_MAXLEN-length, "at line %d: ", locator->line);
        if (written >= RET_MAXLEN)
            ret_array[RET_MAXLEN-1] = '\0';
        length = strlen(*ret);
        msg = *ret + length * (sizeof(char));
    }
    if (locator->column >=0 && length < RET_MAXLEN-1)
    {
        written = snprintf(msg, RET_MAXLEN-length, "at column %d: ", locator->column);
        if (written >= RET_MAXLEN)
            ret_array[RET_MAXLEN-1] = '\0';
        length = strlen(*ret);
        msg = *ret + length * (sizeof(char));
    }
    if (message && length < RET_MAXLEN-1)
    {
        written = snprintf(msg, RET_MAXLEN-length, "%s\n", message);
        if (written >= RET_MAXLEN)
            ret_array[RET_MAXLEN-1] = '\0';
    }
    if (info->parser)
        raptor_parse_abort(info->parser);
    if (info->serializer)
        raptor_serialize_end(info->serializer);
}

@= RDFins
    HASHfnd_str(bun, mi, @1v);/*bun is returned, is an index.*/
    if (bun == BUN_NONE)
    {
        if (map->T->hash == NULL || BATcount(map) > 4 * map->T->hash->mask)
        {
            HASHdestroy(map); /* keeps hash performance in check */
            BAThash(BATmirror(map), 2*BATcount(map));
        }
        bun = (BUN) map->batCount;
        if (!BUNappend(map,(ptr)@1v, TRUE)) {
            GDKerror("RDFimport: @1[" LLFMT "] = %s, BUNappend fails\n", cur, @1v);
            *ret = ret_array;
            snprintf(*ret, RET_MAXLEN, "BUNappend failed inserting \'%s\'", @1v);
        }
   }
   /* s,p,o[cur] are set to the virtual oid which is bun s p and o are arrays of oid */
   @1[*cur] = (oid) bun;

@= RDFprefix
    size_t len = strlen(@2) + 2; /* +1 for '\0', +1 for the prefix */
    chr prefix = @3;
    @1 = GDKmalloc(len*sizeof(char));
    if (@1)
        snprintf(@1, len, "%c%s", prefix, @2);
    else
        *ret = "Failed to allocate memory for @1";

@= RDFprefixLanguage
    size_t len = strlen((char*)@2) + strlen((char *)@3) +2; /* +1 for '\0', +1 for '@' */
    @1 = GDKmalloc(len*sizeof(char));
    if (@1)
        snprintf(@1, len, "%s\@%s", @3, @2);
    else
        *ret = "Failed to allocate memory for @1";

@= RDFprefixDatatype
    size_t len = strlen((char*)@2) + strlen((char *)@3) +2; /* +1 for '\0', +1 for '^' */
    @1 = GDKmalloc(len*sizeof(char));
    if (@1)
        snprintf(@1, len, "%s^%s", @3, @2);
    else
        *ret = "Failed to allocate memory for @1";

@c
void
triples_handler(void* user_data, const raptor_statement* triple) 
{
    triple_handler_vars *data = (triple_handler_vars *)user_data;
    lng *cur = data->cur;
    lng *lim = data->lim;
    str ov = NULL, pv = NULL, sv = NULL;
    bte tv;
    BAT *map = data->map;
    BAT *type2xsd = data->type2xsd;
    BAT *sb = data->sb;
    BAT *pb = data->pb;
    BAT *ob = data->ob;
    BAT *tb = data->tb;
    
    oid *o = (oid *) Tloc(ob, BUNfirst(ob));
    oid *p = (oid *) Tloc(pb, BUNfirst(pb));
    oid *s = (oid *) Tloc(sb, BUNfirst(sb));
    bte *t = (bte *) Tloc(tb, BUNfirst(tb));
    
    str *ret = data->ret;
    char *ret_array = data->ret_array;
    BATiter mi = bat_iterator(BATmirror(map));
    BUN bun;
    
    /* get the subject */
    if (triple->subject_type == RAPTOR_IDENTIFIER_TYPE_RESOURCE)
    {
        @:RDFprefix(sv, (str)raptor_uri_as_string((raptor_uri *)triple->subject), RDF_SEC_IRI)@
    }
    else if (triple->subject_type == RAPTOR_IDENTIFIER_TYPE_ANONYMOUS)
    {
        @:RDFprefix(sv, (str)triple->subject, RDF_SEC_BLANK)@
    }
    else
        *ret = "Unexpected subject type";
    
    if (*ret == MAL_SUCCEED)
    {
        /* get the predicate */
        if(triple->predicate_type == RAPTOR_IDENTIFIER_TYPE_RESOURCE)
        {
            @:RDFprefix(pv, (str)raptor_uri_as_string((raptor_uri *)triple->predicate), RDF_SEC_IRI)@
        }
        else
            *ret="Unexpected predicate type";
        
        if (*ret == MAL_SUCCEED)
        {
            /* get the object */
            switch (triple->object_type)
            {
            case RAPTOR_IDENTIFIER_TYPE_RESOURCE:
            {
                @:RDFprefix(ov, (str)raptor_uri_as_string((raptor_uri *)triple->object), RDF_SEC_IRI)@
                tv = RDF_TYPE_NULL;
                break;
            }
            case RAPTOR_IDENTIFIER_TYPE_ANONYMOUS:
            {
                @:RDFprefix(ov, (str)triple->object, RDF_SEC_BLANK)@
                tv = RDF_TYPE_NULL;
                break;
            }
            case RAPTOR_IDENTIFIER_TYPE_LITERAL:
            {
                char *obj_datatype = (char *)raptor_uri_as_string(triple->object_literal_datatype);
                rdf_type obj_type = RDFxsdToType(obj_datatype, type2xsd);
                tv = obj_type;
                if (triple->object_literal_language != NULL && obj_type != RDF_TYPE_PLAIN)
                {
                    *ret = ret_array;
                    snprintf(*ret, RET_MAXLEN,
                            "The object \'%s\' has language tag \'%s\', but has datatype \'%s\'; only plain literals may have a language tag",
                            (str)triple->object, (str)triple->object_literal_language, obj_datatype);
                }
                else
                {
                    switch (obj_type)
                    {
                    /* for numerics */
                    double val;
                    case RDF_TYPE_PLAIN:
                    case RDF_TYPE_STRING:
                    {
                        if (( obj_type == RDF_TYPE_PLAIN ) &&
                            ( triple->object_literal_language != NULL ) )
                        {
                            str langPrefixedObject;
                            @:RDFprefixLanguage(langPrefixedObject, (str)triple->object, (str)triple->object_literal_language)@
                            if (*ret == MAL_SUCCEED)
                            {
                                if (strlen((str)triple->object) == 0)
                                {
                                    @:RDFprefix(ov, langPrefixedObject, RDF_SEC_LANG_EMPTY_STRING)@
                                }
                                else
                                {
                                    @:RDFprefix(ov, langPrefixedObject, RDF_SEC_LANG_STRING)@
                                }
                                GDKfree(langPrefixedObject);
                            }
                        }
                        else
                        {
                            if (strlen((str)triple->object) == 0)
                            {
                                @:RDFprefix(ov, (str)triple->object, RDF_SEC_EMPTY_STRING)@
                            }
                            else
                            {
                                @:RDFprefix(ov, (str)triple->object, RDF_SEC_STRING)@
                            }
                        }
                        break;
                    }
                    case RDF_TYPE_XML_LITERAL:
                    {
                        @:RDFprefix(ov, (str)triple->object, RDF_SEC_XML_LITERAL)@
                        break;
                    }
                    case RDF_TYPE_DECIMAL:
                    case RDF_TYPE_INTEGER:
                    case RDF_TYPE_NPOS_INT:
                    case RDF_TYPE_NEG_INT:
                    case RDF_TYPE_NNEG_INT:
                    case RDF_TYPE_POS_INT:
                    case RDF_TYPE_LONG:
                    case RDF_TYPE_ULONG:
                    case RDF_TYPE_INT:
                    case RDF_TYPE_UINT:
                    case RDF_TYPE_SHORT:
                    case RDF_TYPE_USHORT:
                    case RDF_TYPE_BYTE:
                    case RDF_TYPE_UBYTE:
                    {
                        *ret = RDFparseDecimal(&val, (str)triple->object, obj_type);
                        goto save;
                    }
                    case RDF_TYPE_FLOAT:
                    case RDF_TYPE_DOUBLE:
                    {
                        *ret = RDFcheckNumericLexicalSpace((str)triple->object, obj_type);
                        if (*ret == MAL_SUCCEED)
                        {
                            if (!strcmp((str)triple->object, "INF"))
                            {
                                @:RDFprefix(ov, "", RDF_SEC_POS_INF)@
                            }
                            else if (!strcmp((str)triple->object, "-INF"))
                            {
                                @:RDFprefix(ov, "", RDF_SEC_NEG_INF)@
                            }
                            else if (!strcmp((str)triple->object, "NaN"))
                            {
                                @:RDFprefix(ov, "", RDF_SEC_NAN)@
                            }
                            else
                            {
                                *ret = RDFdoubleStringToDouble(&val, (str)triple->object);
        save:                   if (*ret == MAL_SUCCEED)
                                {
                                    if (val == 0)
                                    {
                                        @:RDFprefix(ov, "", RDF_SEC_ZERO)@
                                    }
                                    else
                                    {
                                        char string[17];
                                        RDFdoubleToHexString(string, val);
                                        if (val > 0)
                                        {
                                            @:RDFprefix(ov, string, RDF_SEC_POS_NUM)@
                                        }
                                        else if (val < 0)
                                        {
                                            @:RDFprefix(ov, string, RDF_SEC_NEG_NUM)@
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    }
                    case RDF_TYPE_BOOLEAN:
                    {
                        if (!strcmp((str)triple->object, "1") || !strcmp((str)triple->object, "true"))
                        {
                            @:RDFprefix(ov, "", RDF_SEC_TRUE)@
                        }
                        else if (!strcmp((str)triple->object, "0") || !strcmp((str)triple->object, "false"))
                        {
                            @:RDFprefix(ov, "", RDF_SEC_FALSE)@
                        }
                        else
                        {
                            *ret = ret_array;
                            snprintf(*ret, RET_MAXLEN, "Invalid boolean: \'%s\'", (str)triple->object);
                        }
                        break;
                    }
                    case RDF_TYPE_DATETIME:
                    {
                        rdf_datetime *datetime;
                        *ret = rdf_datetime_new(&datetime);
                        if (*ret == MAL_SUCCEED)
                        {
                            *ret = RDFparseDateTime(datetime, (str)triple->object);
                            if (*ret == MAL_SUCCEED)
                            {
                                /* convert tstamp in hexadecimal chars, each byte is represented by 2 chars;
                                 * thus size_t is sizeof(timestamp)*2, len of msecs,
                                 * len of timezone, and terminating NULL */
                                size_t datetime_strlen = sizeof(timestamp)*2 + strlen(datetime->msecs) + strlen(datetime->tzone) + 1;
                                char datetime_str[datetime_strlen];
                                rdf_datetime_toString(datetime_str, datetime_strlen, datetime);
                                {
                                    @:RDFprefix(ov, datetime_str, RDF_SEC_DATETIME)@
                                }
                            }
                            rdf_datetime_delete(datetime);
                        }
                        break;
                    }
                    case RDF_TYPE_OTHER:
                    {
                        if (strchr(obj_datatype, '^')==NULL)
                        {
                            str datatypePrefixedObj;
                            @:RDFprefixDatatype(datatypePrefixedObj, (str)triple->object, obj_datatype)@
                            if (*ret == MAL_SUCCEED)
                            {
                                @:RDFprefix(ov, datatypePrefixedObj, RDF_SEC_OTHER)@
                                GDKfree(datatypePrefixedObj);
                            }
                        }
                        else
                        {
                            *ret = ret_array;
                            snprintf(*ret, RET_MAXLEN, "Invalid datatype URI: \'%s\'", obj_datatype);
                        }
                        break;
                    }
                    default:
                        *ret = "Control flow should never reach this point";
                    }/*END of switch (obj_type)*/
                    break;
                }
            }
            default:
                *ret="Unexpected object type";
            }
            if (*ret == MAL_SUCCEED)
            {
                @:RDFins(o)@
                if (*ret == MAL_SUCCEED)
                {
                    @:RDFins(p)@
                    if (*ret == MAL_SUCCEED)
                    {
                        @:RDFins(s)@
                        if (*ret == MAL_SUCCEED)
                        {
                            t[*cur] = tv;
                            if (++(*cur) == *lim) {
                                *lim *= 2;
                                data->ob = BATextend(ob, *lim);
                                data->pb = BATextend(pb, *lim);
                                data->sb = BATextend(sb, *lim);
                                data->tb = BATextend(tb, *lim);
                                if (ob == NULL || pb == NULL || sb == NULL || tb == NULL)
                                    *ret = "BATextend failed";
                            }
                        }
                    }
                }
                GDKfree(ov);
            }
            GDKfree(pv);
        }
        GDKfree(sv);
    }
    if (*ret != MAL_SUCCEED)
    {
        /* print all the triple with the error message and exit */
        size_t len, slen, plen, olen, retlen = strlen(*ret);
        char tmp[retlen+1];
        str subj, prop, obj;
        strcpy(tmp, *ret);
        subj = (str)raptor_statement_part_as_counted_string(triple->subject, triple->subject_type, NULL, NULL, &slen);
        if(subj)
        {
            prop = (str)raptor_statement_part_as_counted_string(triple->predicate, triple->predicate_type, NULL, NULL, &plen);
            if (prop)
            {
                obj = (str)raptor_statement_part_as_counted_string(triple->object, triple->object_type, triple->object_literal_datatype, triple->object_literal_language, &olen);
                if (obj)
                {
                    *ret = ret_array;
                    snprintf(*ret, RET_MAXLEN, "In triple: %s %s %s : %s", subj, prop, obj, tmp);
                    len = 16 + slen + plen + olen + retlen;
                    if (len < RET_MAXLEN-1)
                        (*ret)[len] = '\0';
                    else
                        (*ret)[RET_MAXLEN-1] = '\0';
                    free(obj);
                }
                free(prop);
            }
            free(subj);
        }
        raptor_parse_abort(data->parser);
    }
}

static str 
RDFimport_(BAT** S, BAT** P, BAT **O, BAT **T, str filename,
			BAT *map, BAT *type2xsd, char *ret_array, str syntax, lng *lim) {
    raptor_parser *parser;
    FILE *rdf_file;
    str ret = MAL_SUCCEED;
    raptor_init();
    parser = raptor_new_parser(syntax);
    if (!parser)
        ret = "Could not create a Redland parser";
    else
    {
    	/* if filename is an uri, remove the leading "file://" */
    	if (strncmp("file://", filename, 7)==0)
    		filename = &filename[7];
        rdf_file = fopen(filename, "r");
        if (!rdf_file)
        {
            ret = ret_array;
            snprintf(ret, RET_MAXLEN, "Invalid filename: \'%s\'", filename);
        }
        else
        {
            triple_handler_vars *data;
            message_handler_vars *info;
            lng /**lim,*/ *cur, /*limv,*/ curv;
            /*limv = 1048576;*/
            curv = 0;
            /*lim = &limv;TODO *lim = RDFestimate(url);*/
            cur = &curv;
            
            data = GDKmalloc(sizeof(triple_handler_vars));
            if (data)
            {
                info = GDKmalloc(sizeof(message_handler_vars));
                if (info)
                {
                    data->sb = BATnew(TYPE_void, TYPE_oid, *lim);
                    if (data->sb)
                    {
                        data->pb = BATnew(TYPE_void, TYPE_oid, *lim);
                        if (data->pb)
                        {
                            data->ob = BATnew(TYPE_void, TYPE_oid, *lim);
                            if (data->ob)
                            {
                                data->tb = BATnew(TYPE_void, TYPE_bte, *lim);
                                if (data->tb)
                                {
                                	raptor_uri *base;
                                    data->parser = parser;
                                    data->cur = cur;
                                    data->lim = lim;
                                    data->map = map;
                                    data->type2xsd = type2xsd;
                                    data->ret = &ret;
                                    data->ret_array = ret_array;
                                    
                                    info->serializer=NULL;
                                    info->parser = parser;
                                    info->ret = &ret;
                                    info->ret_array = ret_array;
                                    
                                    raptor_set_statement_handler(parser, data, triples_handler);
                                    raptor_set_fatal_error_handler(parser, info, message_handler);
                                    raptor_set_error_handler(parser, info, message_handler);
                                    raptor_set_warning_handler(parser, info, message_handler);
                                    raptor_set_parser_strict(parser, TRUE);
                                    base = raptor_new_uri((unsigned char*)"http://dummyrequireduri.com/");
                                    if (base)
                                    {
	                                    /*if (raptor_parse_file(parser, rdf_file, NULL) == 0)*/
	                                    if (raptor_parse_file_stream(parser, rdf_file, NULL, base) == 0)
	                                    {
	                                        /* data->sb,pb,ob may be changed now */
	                                        if (ret == MAL_SUCCEED)
	                                        {
	                                            BATseqbase(data->ob, 0);
	                                            BATseqbase(data->pb, 0);
	                                            BATseqbase(data->sb, 0);
	                                            BATseqbase(data->tb, 0);
	                                            BATsetcount(data->ob, *cur);
	                                            BATsetcount(data->pb, *cur);
	                                            BATsetcount(data->sb, *cur);
	                                            BATsetcount(data->tb, *cur);
	                                            
	                                            data->ob->tsorted = 0;
	                                            data->pb->tsorted = 0;
	                                            data->sb->tsorted = 0;
	                                            data->tb->tsorted = 0;
	                                            BATkey(BATmirror(data->ob), FALSE);
	                                            BATkey(BATmirror(data->sb), FALSE);
	                                            BATkey(BATmirror(data->pb), FALSE);
	                                            BATkey(BATmirror(data->tb), FALSE);
	                                            *S = data->sb;
	                                            *P = data->pb;
	                                            *O = data->ob;
	                                            *T = data->tb;
	                                        }
	                                    }
	                                    else
	                                    	ret = "raptor_parse could not parse file";
	                                    raptor_free_uri(base);
                                    }
                                    else
                                    	ret = "RDFimport_: memory allocation failure";
                                    if (ret!=MAL_SUCCEED)
                                        BBPreclaim(data->tb);
                                }
                                else
                                    ret = "Could not create the tb bat";
                                if (ret!=MAL_SUCCEED)
                                    BBPreclaim(data->ob);
                            }
                            else
                                ret = "Could not create the ob bat";
                            if (ret!=MAL_SUCCEED)
                                BBPreclaim(data->pb);
                        }
                        else
                            ret = "Could not create the pb bat";
                        if (ret!=MAL_SUCCEED)
                            BBPreclaim(data->sb);
                    }
                    else
                        ret = "Could not create the sb bat";
                    GDKfree(info);
                }
                else
                    ret = "message_handler_vars malloc failed";
                GDKfree(data);
            }
            else
                ret = "triple_handler_vars malloc failed";
            fclose(rdf_file);
        }
        raptor_free_parser(parser);
    }
    raptor_finish();
    return ret;
}
/*
rdf_export
str RDFimport(int* S, int* P, int* O, str *url, bat m)
{
    BAT *sb = NULL, *ob=NULL, *pb = NULL, *tb = NULL, *map = BATdescriptor(m);
    str ret;
    char ret_array[RET_MAXLEN];
    if (map) {
        lng lim = 8192;
        RDFimport_(&sb, &pb, &ob, &tb, *url, map, ret_array, "rdfxml", &lim);
        if (ret == MAL_SUCCEED) {
            BBPkeepref(*O = ob->batCacheid);*changes physical reference to logical*
            BBPkeepref(*P = pb->batCacheid);
            BBPkeepref(*S = sb->batCacheid);
        }
        BBPreleaseref(map->batCacheid);
    }
    return ret;
}
*/

int CTrefine(BAT **ret, BAT *b, BAT *a);
BAT * BATmalleftfetchjoin(BAT *l, BAT *r);
static str
RDFsort(BAT *commit,
        BAT *S, BAT *sb, BAT *pb, BAT *ob, BAT *tb,
        BAT **Spot, BAT **sPot, BAT **spOt, BAT **spoT,
        str Spot_nme, str sPot_nme, str spOt_nme, str spoT_nme, str db, str graph)
{
    BAT *SPO, *SP;
    str ret = MAL_SUCCEED;
    CTrefine(&SP, S, pb);
    if (SP) {
        CTrefine(&SPO, SP, ob);
        BBPreclaim(SP);
        if (SPO) {
            BAT *piv = BATmirror(BATmark(SPO, 0));
            BBPreclaim(SPO);
            if (piv) {
                /*BATleftfetchjoin wants also a size_t estimate
                 * BATmalleftfetchjoin not. Which has to be used?
                 * TODO*/ 
                *Spot = BATleftfetchjoin(piv, sb, oid_nil);
                if (*Spot) {
                    *sPot = BATleftfetchjoin(piv, pb, oid_nil);
                    if (*sPot) {
                        *spOt = BATleftfetchjoin(piv, ob, oid_nil);
                        if (*spOt) {
                            *spoT = BATleftfetchjoin(piv, tb, oid_nil);
                            if (*spoT) {
                                char Spot_buf[1024], sPot_buf[1024], spOt_buf[1024], spoT_buf[1024];
                                snprintf(Spot_buf, 1024, "%s_%s_%s", db, graph, Spot_nme);
                                snprintf(sPot_buf, 1024, "%s_%s_%s", db, graph, sPot_nme);
                                snprintf(spOt_buf, 1024, "%s_%s_%s", db, graph, spOt_nme);
                                snprintf(spoT_buf, 1024, "%s_%s_%s", db, graph, spoT_nme);
                                
                                if (BATname(*Spot, Spot_buf) == 0 &&
                                    BATname(*sPot, sPot_buf) == 0 &&
                                    BATname(*spOt, spOt_buf) == 0 &&
                                    BATname(*spoT, spoT_buf) == 0) 
                                {
                                    if (BATmode(*Spot, PERSISTENT) &&
                                        BATmode(*sPot, PERSISTENT) &&
                                        BATmode(*spOt, PERSISTENT) &&
                                        BATmode(*spoT, PERSISTENT))
                                    {
                                        BBPreclaim(piv);
                                        BUNfastins(commit, &((*Spot)->batCacheid), Spot_buf);
                                        BUNfastins(commit, &((*sPot)->batCacheid), sPot_buf);
                                        BUNfastins(commit, &((*spOt)->batCacheid), spOt_buf);
                                        BUNfastins(commit, &((*spoT)->batCacheid), spoT_buf);
                                        /* physical reference, i.e. memory pressure */
                                        BBPreleaseref((*Spot)->batCacheid);
                                        BBPreleaseref((*sPot)->batCacheid);
                                        BBPreleaseref((*spOt)->batCacheid);
                                        BBPreleaseref((*spoT)->batCacheid);
                                        return MAL_SUCCEED;
                                    } else {
                                        BATmode(*Spot, TRANSIENT);
                                        BATmode(*sPot, TRANSIENT);
                                        BATmode(*spOt, TRANSIENT);
                                        BATmode(*spoT, TRANSIENT);
                                        ret = "BATmode failed";
                                    }
                                }
                                else
                                    ret = "BATname failed";
                                BBPreclaim(*spoT);
                            }
                            else
                                ret = "BATleftfetchjoin(piv, tb, oid_nil) failed";
                            BBPreclaim(*spOt);
                        }
                        else
                            ret = "BATleftfetchjoin(piv, ob, oid_nil) failed";
                        BBPreclaim(*sPot);
                    }
                    else
                        ret = "BATleftfetchjoin(piv, pb, oid_nil) failed";
                    BBPreclaim(*Spot);
                }
                else
                    ret = "BATleftfetchjoin(piv, sb, oid_nil) failed";
                BBPreclaim(piv);
            }
            else
                ret = "BATmirror(BATmark(SPO, 0)) failed";
        }
        else
            ret = "CTrefine(&SPO, SP, ob) failed";
    }
    else
        ret = "CTrefine(&SP, S, pb) failed";
    return ret;
}

static str checkSyntax(str syntax)
{
    if (    /*!strcmp(syntax, "atom") ||*/
            !strcmp(syntax, "ntriples") ||
            !strcmp(syntax, "rdfxml") ||
            !strcmp(syntax, "rdfxml-abbrev") ||
            !strcmp(syntax, "rdfxml-xmp") ||
            !strcmp(syntax, "turtle") ||
            /*!strcmp(syntax, "rdfxml-xmp") ||*/
            !strcmp(syntax, "rss-1.0") ||
            !strcmp(syntax, "dot"))
    {
        return MAL_SUCCEED;
    }
    else
        return "syntax may be only one among \"atom\",\"ntriples\",\"rdfxml\",\"rdfxml-abbrev\",\"rdfxml-xmp\",\"turtle\",\"rdfxml-xmp\",\"rss-1.0\",\"dot\"";
}

static str RDFfillType2xsd(BAT *m)
{
	str ret = MAL_SUCCEED;
	BATseqbase(m, 0);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#decimal", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#integer", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#nonPositiveInteger", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#negativeInteger", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#nonNegativeInteger", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#positiveInteger", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#long", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#unsignedLong", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#int", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#unsignedInt", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#short", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#unsignedShort", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#byte", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#unsignedByte", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#float", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#double", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#boolean", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#string", TRUE);
	BUNappend(m, "http://www.w3.org/2001/XMLSchema#dateTime", TRUE);
	BUNappend(m, "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral", TRUE);
	if (BATname(m, TYPE2XSD) != 0)
		ret ="BATname error";
	if (!BATmode(m, PERSISTENT))
		ret = "BATmode error";
	return ret;
}

@= sort
RDFsort(commit, sorted, @1,@2,@3,@4,&@5,&@6,&@7,&@8,"@5","@6","@7","@8",*db,*graph);
@c
str RDFimportGraph(int *d, str *fileurl, str *syntax, str *db, str *graph, lng *lim)
{
    BAT *map = NULL, *sb = NULL, *ob=NULL,
        *pb = NULL, *tb = NULL, *commit,
    	*type2xsd;
    char map_buf[1024];
    char ret_array[RET_MAXLEN];
    str ret = MAL_SUCCEED;
    (void)d;
    ret = checkSyntax(*syntax);
    if (ret == MAL_SUCCEED)
    {
        commit = BATnew(TYPE_bat, TYPE_str, 25);
        if (commit)
        {
            int mapIndex;
            snprintf(map_buf, 1024, "%s_%s_map", *db, *graph);
            mapIndex = BBPindex(map_buf);
            memset(map_buf, 0, 1024);
            if (!mapIndex)
            {
                map = BATnew(TYPE_void, TYPE_str, *lim);/* TODO estimate */
                if (map)
                {
                	int type2xsdIndex = BBPindex(TYPE2XSD);
                    BATseqbase(map, 0);
                    
                    if (!type2xsdIndex)
                    {
                    	type2xsd = BATnew(TYPE_void, TYPE_str, NUMBER_OF_TYPES);
                    	if (type2xsd)
                    		ret = RDFfillType2xsd(type2xsd);
                    }
                    else
                    	type2xsd = BATdescriptor(type2xsdIndex);
                    if (type2xsd)
                    {
                    	ret = RDFimport_(&sb, &pb, &ob, &tb, *fileurl, map, type2xsd, ret_array, *syntax, lim);
	                    if (ret == MAL_SUCCEED)
	                    {
	                        BAT *Spot = NULL, *sPot = NULL, *spOt = NULL, *spoT = NULL; 
	                        BAT *Sopt = NULL, *sOpt = NULL, *soPt = NULL, *sopT = NULL; 
	                        BAT *Post = NULL, *pOst = NULL, *poSt = NULL, *posT = NULL; 
	                        BAT *Psot = NULL, *pSot = NULL, *psOt = NULL, *psoT = NULL; 
	                        BAT *Opst = NULL, *oPst = NULL, *opSt = NULL, *opsT = NULL; 
	                        BAT *Ospt = NULL, *oSpt = NULL, *osPt = NULL, *ospT = NULL;
	                        BAT *new_map, *oid_translation, *new_sb, *new_pb, *new_ob, *sorted;
	                        BATiter ci = bat_iterator(commit);
	                        BUN p, q;
	                        BATorder(BATmirror(map));
	                        /* now map is a bat of type [:oid, :str], ordered on tail */
	                        /* create the new map and the oid_translation bat */
	                        new_map = BATmirror(BATmark(BATmirror(map), 0));
	                        oid_translation = BATmark(map, 0);
	                        /* destroy the old map, use the new */
	                        BBPreclaim(map);
	                        map = new_map;
	                        /* Translate the oids of sb, pb and ob */
	                        new_sb = BATleftjoin(sb, oid_translation, 0);/*TODO number of triples*/
	                        if (new_sb)
	                        {
	                            BBPreclaim(sb);
	                            sb = new_sb;
	                            
	                            new_pb = BATleftjoin(pb, oid_translation, 0);
	                            if (new_pb)
	                            {
	                                BBPreclaim(pb);
	                                pb = new_pb;
	                                
	                                new_ob = BATleftjoin(ob, oid_translation, 0);
	                                if (new_ob)
	                                {
	                                    BBPreclaim(ob);
	                                    ob = new_ob;
	                                    
	                                    snprintf(map_buf, 1024, "%s_%s_map", *db, *graph);
	                                    if ((BATname(map, map_buf) == 0) && BATmode(map, PERSISTENT))
	                                    {/* TODO should not be persistent if S,P,O aren't */
	                                        BUNfastins(commit, &(map->batCacheid), map_buf);
	                                        sorted = BATmirror(BATsort(BATmirror(sb)));
	                                        if (sorted)
	                                        {
	                                            ret = @:sort(sb,pb,ob,tb,Spot,sPot,spOt,spoT)@
	                                            if (ret  == MAL_SUCCEED)
	                                            {
	                                                ret = @:sort(sb,ob,pb,tb,Sopt,sOpt,soPt,sopT)@
	                                                if (ret == MAL_SUCCEED)
	                                                {
	                                                    BBPreclaim(sorted);
	                                                    sorted = BATmirror(BATsort(BATmirror(pb)));
	                                                    if (sorted)
	                                                    {
	                                                        ret = @:sort(pb,ob,sb,tb,Post,pOst,poSt,posT)@
	                                                        if (ret == MAL_SUCCEED)
	                                                        {
	                                                            ret = @:sort(pb,sb,ob,tb,Psot,pSot,psOt,psoT)@
	                                                            if (ret == MAL_SUCCEED)
	                                                            {
	                                                                BBPreclaim(sorted);
	                                                                sorted = BATmirror(BATsort(BATmirror(ob)));
	                                                                if (sorted)
	                                                                {
	                                                                    ret = @:sort(ob,pb,sb,tb,Opst,oPst,opSt,opsT)@
	                                                                    if (ret == MAL_SUCCEED)
	                                                                    {
	                                                                        ret = @:sort(ob,sb,pb,tb,Ospt,oSpt,osPt,ospT)@
	                                                                    	BBPreclaim(sorted);
	                                                                        if (ret == MAL_SUCCEED)
	                                                                            goto succeed;
	                                                                        BBPreclaim(Opst);
	                                                                        BBPreclaim(oPst);
	                                                                        BBPreclaim(opSt);
	                                                                        BBPreclaim(opsT);
	                                                                    }
	                                                                    else
	                                                                        BBPreclaim(sorted);
	                                                                }
	                                                                else
	                                                                    ret = "Could not create a sorted copy of ob";
	                                                                BBPreclaim(Psot);
	                                                                BBPreclaim(pSot);
	                                                                BBPreclaim(psOt);
	                                                                BBPreclaim(psoT);
	                                                            }
	                                                            else
	                                                                BBPreclaim(sorted);
	                                                            BBPreclaim(Post);
	                                                            BBPreclaim(pOst);
	                                                            BBPreclaim(poSt);
	                                                            BBPreclaim(posT);
	                                                        }
	                                                        else
	                                                            BBPreclaim(sorted);
	                                                    }
	                                                    else
	                                                        ret = "Could not create a sorted copy of pb";
	                                                    BBPreclaim(Sopt);
	                                                    BBPreclaim(sOpt);
	                                                    BBPreclaim(soPt);
	                                                    BBPreclaim(sopT);
	                                                }
	                                                else
	                                                    BBPreclaim(sorted);
	                                                BBPreclaim(Spot);
	                                                BBPreclaim(sPot);
	                                                BBPreclaim(spOt);
	                                                BBPreclaim(spoT);
	                                            }
	                                            else
	                                                BBPreclaim(sorted);
	                                succeed:    if (ret == MAL_SUCCEED && TMsubcommit(commit))
	                                            {
	                                                ret = "commit failed";
	                                            }
	                                        }
	                                        else
	                                            ret = "Could not create a sorted copy of sb";
	                                        if (ret != MAL_SUCCEED)
	                                        {
	                                            /* we failed to create everything succesfully and commit. destroy all bats */
	                                            BATloop(commit, p, q) { 
	                                                bat bid = *(bat*) BUNhead(ci,p);
	                                                BAT *b = BATdescriptor(bid);
	                                                if (b) {
	                                                    BATmode(b, TRANSIENT);
	                                                    BBPreleaseref(bid);
	                                                }
	                                            }
	                                        }
	                                    }
	                                    else
	                                        ret = "BATname or BATmode(map, PERSISTENT) failed";
	                                }
	                                else
	                                    ret = "Could not translate the ob oids";
	                            }
	                            else
	                                ret = "Could not translate the pb oids";
	                        }
	                        else
	                            ret = "Could not translate the sb oids";
	                        BBPreclaim(oid_translation);
	                        BBPreleaseref(sb->batCacheid);/* release physical ref */
	                        BBPreleaseref(pb->batCacheid);/* TODO why not BBPreclaim ?? */
	                        BBPreleaseref(ob->batCacheid);
	                        BBPreleaseref(tb->batCacheid);
	                    }
	                    BBPreleaseref(type2xsd->batCacheid);
                    }
                    else
                    	ret = "Could not create the type2xsd BAT";
                    BBPreleaseref(map->batCacheid);
                }
                else
                    ret = "Could not create the map BAT";
            }
            else
            {
                ret = ret_array;
                snprintf(ret, RET_MAXLEN, "There is already a graph named \'%s\' in database \'%s\'", *graph, *db);                
            }
            BBPreclaim(commit); /* will release logical refs on all bats (if they are persistent, they will stay alive) */
        }
        else
            ret = "Could not create commit bat";
    }
    if (ret != MAL_SUCCEED)
        throw(MAL, "RDFimportGraph", ret);
    return MAL_SUCCEED;
}

static str getBatNames(str db, str graph, char *s_buf,char *p_buf,char *o_buf, char *t_buf, str order)
{
    str err = "order may be only one among \"spo\",\"sop\",\"pso\",\"pos\",\"osp\",\"ops\"";
    if (strlen(order)>3)
        return err;
    if (strcmp(order, "spo")==0)
    {
        snprintf(s_buf, 1024, "%s_%s_Spot", db, graph);
        snprintf(p_buf, 1024, "%s_%s_sPot", db, graph);
        snprintf(o_buf, 1024, "%s_%s_spOt", db, graph);
        snprintf(t_buf, 1024, "%s_%s_spoT", db, graph);
    }
    else if (strcmp(order, "sop")==0)
    {
        snprintf(s_buf, 1024, "%s_%s_Sopt", db, graph);
        snprintf(o_buf, 1024, "%s_%s_sOpt", db, graph);
        snprintf(p_buf, 1024, "%s_%s_soPt", db, graph);
        snprintf(t_buf, 1024, "%s_%s_sopT", db, graph);
    }
    else if (strcmp(order, "pos")==0)
    {
        snprintf(p_buf, 1024, "%s_%s_Post", db, graph);
        snprintf(o_buf, 1024, "%s_%s_pOst", db, graph);
        snprintf(s_buf, 1024, "%s_%s_poSt", db, graph);
        snprintf(t_buf, 1024, "%s_%s_posT", db, graph);
    }
    else if (strcmp(order, "pso")==0)
    {
        snprintf(p_buf, 1024, "%s_%s_Psot", db, graph);
        snprintf(s_buf, 1024, "%s_%s_pSot", db, graph);
        snprintf(o_buf, 1024, "%s_%s_psOt", db, graph);
        snprintf(t_buf, 1024, "%s_%s_psoT", db, graph);
    }
    else if (strcmp(order, "osp")==0)
    {
        snprintf(o_buf, 1024, "%s_%s_Ospt", db, graph);
        snprintf(s_buf, 1024, "%s_%s_oSpt", db, graph);
        snprintf(p_buf, 1024, "%s_%s_osPt", db, graph);
        snprintf(t_buf, 1024, "%s_%s_ospT", db, graph);
    }
    else if (strcmp(order, "ops")==0)
    {
        snprintf(o_buf, 1024, "%s_%s_Opst", db, graph);
        snprintf(p_buf, 1024, "%s_%s_oPst", db, graph);
        snprintf(s_buf, 1024, "%s_%s_opSt", db, graph);
        snprintf(t_buf, 1024, "%s_%s_opsT", db, graph);
    }
    else
        return err;
    return MAL_SUCCEED;
}

static void mantissaToCanonicalLexicalForm(double mant_val, str *mantissa_lexical)
{
	int mantissa_len;
	str dot_ptr;
	snprintf(*mantissa_lexical, 512, "%.10f", mant_val);
	/* XML wants no leading plus, at least one decimal digit,
	 * that maybe just a zero, and no trailing zeros */
	mantissa_len = strlen(*mantissa_lexical);
	dot_ptr = strchr(*mantissa_lexical, '.');
	if (dot_ptr==NULL)
	{
		(*mantissa_lexical)[mantissa_len] = '.';
		(*mantissa_lexical)[mantissa_len+1] = '0';
		(*mantissa_lexical)[mantissa_len+2] = '\0';
	}
	else
	{
		/* remove trailing zeros after the decimal dot */
		for (int i=mantissa_len-1; *mantissa_lexical[i]!='0'; i--)
			mantissa_lexical[i]='\0';
	}
}

static str RDFserializeTriple(raptor_statement *triple, raptor_serializer* serializer,
                            str sv, str pv, str ov, bte tv, BAT *type2xsd)
{
    str ret = MAL_SUCCEED;
    bool     dealloc_subj = false, dealloc_prop = false,    dealloc_obj = false,
            dealloc_obj_datatype = false, dealloc_obj_lang = false;
    char obj_string[512]; /* used by numeric types and datetimes for conversion */
    rdf_section subj_sec = (rdf_section) sv[0];
    rdf_section prop_sec = (rdf_section) pv[0];
    rdf_section obj_sec = (rdf_section) ov[0];
    rdf_type obj_type = (rdf_type) tv;
    memset(obj_string, 0, 512);
    sv = sv + sizeof(chr);
    pv = pv + sizeof(chr);
    ov = ov + sizeof(chr);
    
    if (subj_sec == RDF_SEC_IRI)
    {
        triple->subject = raptor_new_uri((const unsigned char*)sv);
        if (triple->subject)
        {
            triple->subject_type = RAPTOR_IDENTIFIER_TYPE_RESOURCE;
            dealloc_subj = true;
        }
        else
            ret = "Failed to allocate memory for the subject IRI";
    }
    else if (subj_sec == RDF_SEC_BLANK)
    {
        triple->subject = sv;
        triple->subject_type = RAPTOR_IDENTIFIER_TYPE_ANONYMOUS;
    }
    else
        ret = "Subject type unknown";
    
    if (ret == MAL_SUCCEED)
    {
        if (prop_sec == RDF_SEC_IRI)
        {
            triple->predicate = raptor_new_uri((const unsigned char*)pv);
            if (triple->predicate)
            {
                triple->predicate_type = RAPTOR_IDENTIFIER_TYPE_RESOURCE;
                dealloc_prop = true;
            }
            else
                ret = "Failed to allocate memory for the property IRI";
        }
        else
            ret = "Property type unknown";
    }
    
    if (ret == MAL_SUCCEED)
    {
        str xsd_type = RDFtypeToXsd(obj_type, type2xsd);
        
        if (xsd_type != NULL)
        {
            triple->object_literal_datatype = raptor_new_uri((const unsigned char*)xsd_type);
            if (triple->object_literal_datatype)
                dealloc_obj_datatype = true;
            else
                ret = "Failed to allocate memory for the object datatype";
        }
        else
            triple->object_literal_datatype = NULL;
        
        triple->object_literal_language = NULL;
        
        if (ret == MAL_SUCCEED)
        {
            if (obj_sec == RDF_SEC_BLANK)
            {
                triple->object = ov;
                triple->object_type = RAPTOR_IDENTIFIER_TYPE_ANONYMOUS;
            }
            else if (obj_sec == RDF_SEC_IRI)
            {
                triple->object = raptor_new_uri((const unsigned char*)ov);
                if (triple->object)
                {
                    triple->object_type = RAPTOR_IDENTIFIER_TYPE_RESOURCE;
                    dealloc_obj = true;
                }
                else
                    ret = "Failed to allocate memory for the object IRI value";
            }
            else
            {
                triple->object_type = RAPTOR_IDENTIFIER_TYPE_LITERAL;
                switch (obj_sec)
                {
                    case RDF_SEC_EMPTY_STRING:
                    case RDF_SEC_LANG_EMPTY_STRING:
                    case RDF_SEC_STRING:
                    case RDF_SEC_LANG_STRING:
                        if (obj_sec == RDF_SEC_LANG_EMPTY_STRING || obj_sec == RDF_SEC_LANG_STRING)
                        {
                            unsigned char *lang;
                            int i;
                            chr cur = ov[0];
                            for (i=0; cur!='\@'; i++)
                                cur = ov[i];
                            lang = GDKmalloc(sizeof(chr)*i);
                            if (lang)
                            {
                                dealloc_obj_lang = true;
                                strncpy((char *)lang, ov, i);
                                lang[i-1] = '\0';
                                triple->object_literal_language = lang;
                                ov = &(ov[i]);
                            }
                            else
                                ret = "Failed to allocate memory for the object language";
                        }
                        if (ret == MAL_SUCCEED)
                            triple->object = ov;
                        break;
                    case RDF_SEC_XML_LITERAL:
                        triple->object = ov;
                        break;
                    case RDF_SEC_FALSE:
                        triple->object = "false";
                        break;
                    case RDF_SEC_TRUE:
                        triple->object = "true";
                        break;
                    case RDF_SEC_ZERO:
                    	switch (obj_type)
                    	{
							case RDF_TYPE_FLOAT:
							case RDF_TYPE_DOUBLE:
								triple->object = "0.0E0";
								break;
							case RDF_TYPE_DECIMAL:
								triple->object = "0.0";
								break;
							default:
								triple->object = "0";
								break;
						}
                        break;
                    case RDF_SEC_NEG_INF:
                        triple->object = "-INF";
                        break;
                    case RDF_SEC_POS_INF:
                        triple->object = "INF";
                        break;
                    case RDF_SEC_NAN:
                        triple->object = "NaN";
                        break;
                    case RDF_SEC_NEG_NUM:
                    case RDF_SEC_POS_NUM:
                    {
                        double val = RDFhexStringToDouble(ov);
                        snprintf(obj_string, 512, "%.10G", val);
                        /* if there an exponent is printed, this means a power of ten, 
                         * while XML wants a power of two for lexical forms.
                         * To have a power of two exponent, the double will be printed
                         * with the 'a' switch, that prints the value as hexadecimal
                         * string with power of two exponent. Mantissa is then
                         * converted to decimal, while exponent is already printed as decimal
                         */
                        if (strchr(obj_string, 'E')!=NULL)
                        {
                        	char *exp_ptr;
                        	snprintf(obj_string, 512, "%A", val);
                        	exp_ptr = strchr(obj_string, 'P');
                        	if (exp_ptr!=NULL)
                        	{
	                        	int mantissa_hex_len = exp_ptr - obj_string;
	                	    	int exp_len = strlen(obj_string) - mantissa_hex_len - 1;
	                        	double mant_val;
	                        	char mantissa_hex[mantissa_hex_len+1];
	                        	char exp[exp_len+1];
	                	    	char *endptr;
	                        	snprintf(mantissa_hex, mantissa_hex_len+1, obj_string);
	                        	snprintf(exp, exp_len+1, &exp_ptr[1]);
	                	        mant_val = strtod(mantissa_hex, &endptr);
	                	        if (errno == ERANGE && mant_val == HUGE_VAL)
	                	            ret = "The mantissa value is out of the double range";
	                	        else if (*endptr != '\0')
	                	        	ret = "Could not convert numeric to double";
	                	        if (ret==MAL_SUCCEED)
	                	        {
	                	        	char mantissa_dec[512];
	                	        	str exp_str;
	                	        	mantissaToCanonicalLexicalForm(mant_val, (str*)&mantissa_dec);
	                	        	/* exponent has not to have leading + */
	                	        	if (exp[0]=='+')
	                	        		exp_str = &exp[1];
	                	        	else
	                	        		exp_str = exp;
	                	        	/* now print as decimal */
	                	        	snprintf(obj_string, 512, "%sE%s", mantissa_dec, exp_str);
	                	        }                        	
                        	}
                        }
                        /* float and double always have a trailing 'E0'*/
                        else if (obj_type == RDF_TYPE_FLOAT || obj_type == RDF_TYPE_DOUBLE)
                        {
                        	int len = strlen(obj_string);
							obj_string[len] = 'E';
							obj_string[len+1] = '0';
							obj_string[len+2] = '\0';
                        }
                        /* a decimal should always have a decimal digit in its canonical representation */
                        else if (obj_type == RDF_TYPE_DECIMAL)
                        {
                        	str dot_ptr = strchr(obj_string, '.');
							if (dot_ptr==NULL)
							{
								int dec_len = strlen(obj_string);
								obj_string[dec_len] = '.';
								obj_string[dec_len+1] = '0';
								obj_string[dec_len+2] = '\0';
							}
                        }
                        triple->object = obj_string;
                        break;
                    }
                    case RDF_SEC_DATETIME:
                    {
                        rdf_datetime *val;
                        ret = rdf_datetime_new(&val);
                        if (ret==MAL_SUCCEED)
                        {
                            tzone *utc;
                            rdf_datetime_fromString(val, ov);
                            utc = GDKmalloc(sizeof(tzone));
                            if (utc)
                            {
                                bit isnil;
                                int utc_minutes_offset = 0;
                                MTIMEtzone_create(utc, &utc_minutes_offset);
                                MTIMEtzone_isnil(&isnil, utc);
                                if (!isnil)
                                {
                                    int len = 128, i;
                                    char buf[len];
                                    str tstamp_str = buf, format;
                                    timestamp_tz_tostr(&tstamp_str, &len, val->tstamp, utc);
                                    for (i=0; tstamp_str[i]!=' '; i++);
                                    tstamp_str[i] = 'T';
                                    for (; tstamp_str[i]!='.'; i++);
                                    tstamp_str[i] = '\0';
                                    if (!val->msecs)
                                        val->msecs = "";
                                    if (!val->tzone)
                                        val->tzone = "";
                                    len = strlen(tstamp_str) + strlen(val->msecs) + strlen(val->tzone) + 1;
                                    if (strlen(val->msecs)>0)
                                    {
                                        format = "%s.%s%s";
                                        len++;
                                    }
                                    else
                                        format = "%s%s%s";
                                    snprintf(obj_string, len, format, tstamp_str, val->msecs, val->tzone);
                                    triple->object = obj_string;
                                }
                                else
                                    ret = "Could not set timezone to UTC";
                                GDKfree(utc);
                            }
                            else
                                ret = "Could not allocate memory for a tzone";
                            rdf_datetime_delete(val);
                        }
                        break;
                    }
                    case RDF_SEC_OTHER:
                    {
                        unsigned char *datatype;
                        int i;
                        chr cur = ov[0];
                        for (i=0; cur!='^'; i++)
                            cur = ov[i];
                        datatype = GDKmalloc(sizeof(chr)*i);
                        if (datatype)
                        {
                            strncpy((char *)datatype, ov, i);
                            datatype[i-1] = '\0';
                            triple->object_literal_datatype = raptor_new_uri(datatype);
                            GDKfree(datatype);
                            if (triple->object_literal_datatype)
                            {
                                dealloc_obj_datatype = true;
                                ov = &(ov[i]);
                                triple->object = ov;
                            }
                            else
                                ret = "Failed to allocate memory for the object datatype URI";
                        }
                        else
                            ret = "Failed to allocate memory for the object datatype";
                        break;
                    }
                    default:
                        /* will never arrive here */
                        ret = "RDFserializeTriple: section error, reached default case";
                        break;
                }
            }
        }
    }
    
    if (ret == MAL_SUCCEED)
    {
        /* Write the triple */
        if (raptor_serialize_statement(serializer, triple)!=0)
            ret="failed to serialize a statement";
    }
    if (dealloc_subj)
        raptor_free_uri((raptor_uri*)triple->subject);
    if (dealloc_prop)
        raptor_free_uri((raptor_uri*)triple->predicate);
    if (dealloc_obj_datatype)
        raptor_free_uri((raptor_uri*)triple->object_literal_datatype);
    if (dealloc_obj_lang)
        GDKfree((unsigned char *)triple->object_literal_language);
    if (dealloc_obj)
        raptor_free_uri((raptor_uri*)triple->object);
    return ret;
}

static str 
RDFexport_(bat M, bat S, bat P, bat O, bat T, bat type2xsdIndex, str fileurl, str syntax)
{
    char ret_array[RET_MAXLEN];
    str ret = MAL_SUCCEED;
    BAT *map = BATdescriptor(M);
    if (map)
    {
        BAT *sb = BATdescriptor(S);
        if (sb)
        {
            BAT *pb = BATdescriptor(P);
            if (pb)
            {
                BAT *ob = BATdescriptor(O);
                if (ob)
                {
                    BAT *tb = BATdescriptor(T);
                    if (tb)
                    {
                    	BAT *type2xsd = BATdescriptor(type2xsdIndex);
                    	if (type2xsd)
                    	{
	                        raptor_serializer* rdf_serializer;
	                        lng i, cnt = BATcount(ob);
	                        oid *o = (oid *) Tloc(ob, BUNfirst(ob));
	                        oid *p = (oid *) Tloc(pb, BUNfirst(pb));
	                        oid *s = (oid *) Tloc(sb, BUNfirst(sb));
	                        bte *t = (bte *) Tloc(tb, BUNfirst(tb));
	                        /* var_t position in heap */
	                        var_t *off = (var_t *) Tloc(map, BUNfirst(map));
	                        str base = (str) map->T->vheap->base;/* heap first position */
	                        
	                        raptor_init();
	                        rdf_serializer = raptor_new_serializer(syntax);
	                        
	                        if (rdf_serializer)
	                        {
	                            message_handler_vars *info = GDKmalloc(sizeof(message_handler_vars));
	                            if (info)
	                            {
	                                info->parser=NULL;
	                                info->serializer = rdf_serializer;
	                                info->ret = &ret;
	                                info->ret_array = ret_array;
	                                
	                                raptor_serializer_set_error_handler(rdf_serializer, info, message_handler);
	                                raptor_serializer_set_warning_handler(rdf_serializer, info, message_handler);
	                                if (raptor_serialize_start_to_filename(rdf_serializer, fileurl) == 0)
	                                {
	                                    for(i=0; i <cnt; i++)
	                                    {
	                                        if (ret==MAL_SUCCEED)
	                                        {
	                                            raptor_statement *triple;
	                                            str ov = base + off[o[i]];
	                                            str pv = base + off[p[i]];
	                                            str sv = base + off[s[i]];
	                                            bte tv = t[i];
	                                            /* Make a triple with URI subject, URI predicate, literal object */
	                                            triple=GDKmalloc(sizeof(raptor_statement));
	                                            if (triple)
	                                            {
	                                                ret = RDFserializeTriple(triple, rdf_serializer, sv, pv, ov, tv, type2xsd);
	                                                GDKfree(triple);
	                                            }
	                                            else
	                                                ret = "Failed to allocate memory for raptor_statement";
	                                        }
	                                    }
	                                    raptor_serialize_end(rdf_serializer);
	                                }
	                                else
	                                    if (ret == MAL_SUCCEED)
	                                        ret = "raptor_serialize_start_to_filename failed";
	                                GDKfree(info);
	                            }
	                            else
	                                ret = "Failed to allocate memory for message_handler_vars";
	                            raptor_free_serializer(rdf_serializer);
	                        }
	                        else
	                            ret = "raptor_new_serializer failed";
	                        raptor_finish();
	                        BBPreleaseref(type2xsd->batCacheid);
                    	}
                    	else
                    		ret = "Failed to obtain type2xsd bat";
                    	BBPreleaseref(tb->batCacheid);
                    }
                    else
                        ret = "Failed to obtain T bat";
                    BBPreleaseref(ob->batCacheid);
                }
                else
                    ret = "Failed to obtain O bat";
                BBPreleaseref(pb->batCacheid);
            }
            else
                ret = "Failed to obtain P bat";
            BBPreleaseref(sb->batCacheid);
        }
        else
            ret = "Failed to obtain S bat";
        BBPreleaseref(map->batCacheid);
    }
    else
        ret = "Failed to obtain MAP bat";
    return ret;
}

str RDFexportGraph(int *d, str *db, str *graph, str *fileurl, str *order, str *syntax)
{
    char m_buf[1024], o_buf[1024], p_buf[1024], s_buf[1024], t_buf[1024];
    bat map, ob, pb, sb, tb, type2xsd;
    str ret;
    (void)d;
    ret = checkSyntax(*syntax);
    if (ret!= MAL_SUCCEED)
        throw(MAL, "RDFexportGraph", ret);
    ret = getBatNames(*db, *graph, s_buf, p_buf, o_buf, t_buf, *order);
    if (ret!= MAL_SUCCEED)
        throw(MAL, "RDFexportGraph", ret);
    snprintf(m_buf, 1024, "%s_%s_map", *db, *graph);
    map = BBPindex(m_buf);
    if (map) {
        sb = BBPindex(s_buf);
        if (sb) {
            pb = BBPindex(p_buf);
            if (pb) {
                ob = BBPindex(o_buf);
                if (ob) {
                    tb = BBPindex(t_buf);
                    if (tb) {
                    	type2xsd = BBPindex(TYPE2XSD);
                    	if (type2xsd)
                    		ret = RDFexport_(map, sb, pb, ob, tb, type2xsd, *fileurl, *syntax);
                    	else
                    		ret = "Failed to obtain type2xsd bat";
                    }
                    else
                        ret = "Failed to obtain T bat";
                }
                else
                    ret = "Failed to obtain O bat";
            }
            else
                ret = "Failed to obtain P bat";
        }
        else
            ret = "Failed to obtain S bat";
    }
    else
        ret = "Failed to obtain map bat";
    if (ret != MAL_SUCCEED)
        throw(MAL, "RDFexportGraph", ret);
    return MAL_SUCCEED;
}
@}
