@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rdf
@a M. Antonelli
@+ Raptor (librdf.org) library interface
Raptor is a free software / Open Source C library that provides a set
of parsers and serializers that generate Resource Description Framework
(RDF) triples by parsing syntaxes or serialize the triples into a syntax.
The supported parsing syntaxes are RDF/XML, N-Triples, TRiG, Turtle, RSS
tag soup including all versions of RSS, Atom 1.0 and 0.3, GRDDL and
microformats for HTML, XHTML and XML. The serializing syntaxes are RDF/XML
(regular, and abbreviated), N-Triples, RSS 1.0, Atom 1.0 and Adobe XMP.
@{
@mal
module rdf;

command import(url:str, map:bat[:str,:oid])(:bat[:oid,:oid],:bat[:oid,:oid],:bat[:oid,:oid])
address RDFimport 
comment "import a url with RDF, put the triples in the three new returned bats. 
         The map is used and extended to map URI/literals to oids";

command export( url:str, map:bat[:str,:oid], o:bat[:oid,:oid], p:bat[:oid,:oid], s:bat[:oid,:oid]) : void
address RDFexport
comment "export a triple table to some file url";

command importGraph( url:str, db:str, graph:str) : void
address RDFimportGraph
comment "import a graph in a named rdf db";

command exportGraph(db:str, graph:str, order:str, syntax:str) : void
address RDFexportGraph
comment "export a graph in a named rdf db";


@+ Implementation


@c
#include "mal_config.h"
#include "mal.h"
#include "mal_exception.h"

#include <gdk_bbp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <raptor.h>
#include <stdbool.h>

#define rdf_export extern
#define RET_MAXLEN 1024

typedef enum
{
	RDF_TYPE_BLANK,
	RDF_TYPE_IRI,
	RDF_TYPE_PLAIN,
	RDF_TYPE_INTEGER,
	RDF_TYPE_DECIMAL,
	RDF_TYPE_DOUBLE,
	RDF_TYPE_BOOLEAN,
	RDF_TYPE_FLOAT,
	RDF_TYPE_STRING,
	RDF_TYPE_DATETIME,
	RDF_TYPE_XML_LITERAL,
	RDF_TYPE_OTHER
} rdf_type;

typedef enum
{
	RDF_SEC_BLANK,
	RDF_SEC_IRI,
	RDF_SEC_NEG_INF,
	RDF_SEC_NEG_NUM,
	RDF_SEC_FALSE,
	RDF_SEC_ZERO,
	RDF_SEC_EMPTY_STRING,
	RDF_SEC_LANG_EMPTY_STRING,
	RDF_SEC_STRING,
	RDF_SEC_LANG_STRING,
	RDF_SEC_TRUE,
	RDF_SEC_POS_NUM,
	RDF_SEC_POS_INF,
	RDF_SEC_DATETIME,
	RDF_SEC_XML_LITERAL,
	RDF_SEC_OTHER,
	RDF_SEC_NAN
} rdf_section;

typedef struct {
	raptor_parser *parser;
	lng *cur;
	lng *lim;
	BAT *map;
	BAT *ob;
	BAT *pb;
	BAT *sb;
	BAT *tb;
	oid *o;
	oid *p;
	oid *s;
	chr *t;
	str *ret;
	char *ret_array;
} triple_handler_vars;

typedef struct {
	raptor_parser *parser;
	raptor_serializer *serializer;
	str *ret;
	char *ret_array;
} message_handler_vars;
/*TODO
static lng RDFestimate(str url) {
	url=NULL;
	return 8048;
}*/

static chr RDFsectionToChr(rdf_section s)
{
	chr c;
	switch (s)
	{
	case RDF_SEC_BLANK:
		c = '0';
		break;
	case RDF_SEC_IRI:
		c = '1';
		break;
	case RDF_SEC_NEG_INF:
		c = '2';
		break;
	case RDF_SEC_NEG_NUM:
		c = '3';
		break;
	case RDF_SEC_FALSE:
		c = '4';
		break;
	case RDF_SEC_ZERO:
		c = '5';
		break;
	case RDF_SEC_EMPTY_STRING:
		c = '6';
		break;
	case RDF_SEC_LANG_EMPTY_STRING:
		c = '7';
		break;
	case RDF_SEC_STRING:
		c = '8';
		break;
	case RDF_SEC_LANG_STRING:
		c = '9';
		break;
	case RDF_SEC_TRUE:
		c = 'A';
		break;
	case RDF_SEC_POS_NUM:
		c = 'B';
		break;
	case RDF_SEC_POS_INF:
		c = 'C';
		break;
	case RDF_SEC_DATETIME:
		c = 'D';
		break;
	case RDF_SEC_XML_LITERAL:
		c = 'E';
		break;
	case RDF_SEC_OTHER:
		c = 'F';
		break;
	case RDF_SEC_NAN:
		c = 'Z';
		break;
	}
	return c;
}

static rdf_section RDFchrToSection(chr c)
{
	rdf_section s;
	switch (c)
	{
	case '0':
		s = RDF_SEC_BLANK;
		break;
	case '1':
		s = RDF_SEC_IRI;
		break;
	case '2':
		s = RDF_SEC_NEG_INF;
		break;
	case '3':
		s = RDF_SEC_NEG_NUM;
		break;
	case '4':
		s = RDF_SEC_FALSE;
		break;
	case '5':
		s = RDF_SEC_ZERO;
		break;
	case '6':
		s = RDF_SEC_EMPTY_STRING;
		break;
	case '7':
		s = RDF_SEC_LANG_EMPTY_STRING;
		break;
	case '8':
		s = RDF_SEC_STRING;
		break;
	case '9':
		s = RDF_SEC_LANG_STRING;
		break;
	case 'A':
		s = RDF_SEC_TRUE;
		break;
	case 'B':
		s = RDF_SEC_POS_NUM;
		break;
	case 'C':
		s = RDF_SEC_POS_INF;
		break;
	case 'D':
		s = RDF_SEC_DATETIME;
		break;
	case 'E':
		s = RDF_SEC_XML_LITERAL;
		break;
	case 'F':
		s = RDF_SEC_OTHER;
		break;
	case 'Z':
		s = RDF_SEC_NAN;
		break;
	}
	return s;
}

static chr RDFtypeToChr(rdf_type t)
{
	chr c;
	switch (t)
	{
	case RDF_TYPE_BLANK:
		c = 'l';
		break;
	case RDF_TYPE_IRI:
		c = 'u';
		break;
	case RDF_TYPE_PLAIN:
		c = 'p';
		break;
	case RDF_TYPE_INTEGER:
		c = 'i';
		break;
	case RDF_TYPE_DECIMAL:
		c = 'm';
		break;
	case RDF_TYPE_DOUBLE:
		c = 'd';
		break;
	case RDF_TYPE_BOOLEAN:
		c = 'b';
		break;
	case RDF_TYPE_FLOAT:
		c = 'f';
		break;
	case RDF_TYPE_STRING:
		c = 's';
		break;
	case RDF_TYPE_DATETIME:
		c = 't';
		break;
	case RDF_TYPE_XML_LITERAL:
		c = 'x';
		break;
	case RDF_TYPE_OTHER:
		c = 'o';
	}
	return c;
}

static rdf_type RDFchrToType(chr c)
{
	rdf_type t;
	switch (c)
	{
	case 'l':
		t = RDF_TYPE_BLANK;
		break;
	case 'u':
		t = RDF_TYPE_IRI;
		break;
	case 'p':
		t = RDF_TYPE_PLAIN;
		break;
	case 'i':
		t = RDF_TYPE_INTEGER;
		break;
	case 'm':
		t = RDF_TYPE_DECIMAL;
		break;
	case 'd':
		t = RDF_TYPE_DOUBLE;
		break;
	case 'b':
		t = RDF_TYPE_BOOLEAN;
		break;
	case 'f':
		t = RDF_TYPE_FLOAT;
		break;
	case 's':
		t = RDF_TYPE_STRING;
		break;
	case 't':
		t = RDF_TYPE_DATETIME;
		break;
	case 'x':
		t = RDF_TYPE_XML_LITERAL;
		break;
	case 'o':
		t = RDF_TYPE_OTHER;
	}
	return t;
}

static rdf_type RDFxsdToType(str uri)
{
	rdf_type ret;
	if (uri == NULL)
		ret = RDF_TYPE_PLAIN;
	else if (	!strcmp(uri, "http://www.w3.org/2001/XMLSchema#int") ||
				!strcmp(uri, "http://www.w3.org/2001/XMLSchema#integer"))
		ret = RDF_TYPE_INTEGER;
	else if (!strcmp(uri, "http://www.w3.org/2001/XMLSchema#decimal"))
		ret = RDF_TYPE_DECIMAL;
	else if (!strcmp(uri, "http://www.w3.org/2001/XMLSchema#double"))
		ret = RDF_TYPE_DOUBLE;
	else if (!strcmp(uri, "http://www.w3.org/2001/XMLSchema#boolean"))
		ret = RDF_TYPE_BOOLEAN;
	else if (!strcmp(uri, "http://www.w3.org/2001/XMLSchema#float"))
		ret = RDF_TYPE_FLOAT;
	else if (!strcmp(uri, "http://www.w3.org/2001/XMLSchema#string"))
		ret = RDF_TYPE_STRING;
	else if (!strcmp(uri, "http://www.w3.org/2001/XMLSchema#dateTime"))
		ret = RDF_TYPE_DATETIME;
	else if (!strcmp(uri, "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral"))
		ret = RDF_TYPE_XML_LITERAL;
	else
		ret = RDF_TYPE_OTHER;
	return ret;
}

static str RDFtypeToXsd(rdf_type t)
{
	str ret;
	if (t == RDF_TYPE_INTEGER)
		ret = "http://www.w3.org/2001/XMLSchema#integer";
	else if (t == RDF_TYPE_DECIMAL)
		ret = "http://www.w3.org/2001/XMLSchema#decimal";
	else if (t == RDF_TYPE_DOUBLE)
		ret = "http://www.w3.org/2001/XMLSchema#double";
	else if (t == RDF_TYPE_BOOLEAN)
		ret = "http://www.w3.org/2001/XMLSchema#boolean";
	else if (t == RDF_TYPE_FLOAT)
		ret = "http://www.w3.org/2001/XMLSchema#float";
	else if (t == RDF_TYPE_STRING)
		ret = "http://www.w3.org/2001/XMLSchema#string";
	else if (t == RDF_TYPE_DATETIME)
		ret = "http://www.w3.org/2001/XMLSchema#dateTime";
	else if (t == RDF_TYPE_XML_LITERAL)
		ret = "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral";
	else
		ret = NULL;
	
	return ret;
}

typedef struct
{
	long year;
	long month;
	long day;
	long hour;
	long minutes;
	long seconds;
	long fractions;
	bool hasTimeZone;
	long timezone_hour;
	long timezone_minutes;
} rdf_datetime;

static bool RDFisDigit(chr c)
{
	if (c=='0' || c=='1' || c=='2' || c=='3' || c=='4' ||
		c=='5' || c=='6' || c=='7' || c=='8' || c=='9')
		return true;
	else
		return false;
}

static str RDFparseTimezone(rdf_datetime *dt, str timezone)
{
	str ret = MAL_SUCCEED;
	int timezone_len = strlen(timezone);
	if (timezone_len == 1 && timezone[0] == 'Z')
	{
		dt->timezone_hour = 0;
		dt->timezone_minutes = 0;
	}
	else
	{
		ret = "A timezone should be represented or by a \'Z\' or in form (\'+\' | \'-\') hh \':\' mm)";
		if (timezone_len == 6)
		{
			if (	(timezone[0] == '+' || timezone[0] == '-') &&
					RDFisDigit(timezone[1]) && RDFisDigit(timezone[2]) &&
					timezone[3] == ':' &&
					RDFisDigit(timezone[4]) && RDFisDigit(timezone[5]) )
			{
				char hour[4], minutes[3];
				strncpy(hour, &timezone[0], 3);
				hour[3] = '\0';
				strncpy(minutes, &timezone[4], 2);
				minutes[2] = '\0';
				dt->timezone_hour = strtol(hour, NULL, 10);
				if (dt->timezone_hour < -14 || dt->timezone_hour > 14)
					ret = "Timezone hour shoud range from -14 to +14";
				else
				{
					dt->timezone_minutes = strtol(minutes, NULL, 10);
					if (dt->timezone_minutes < 0 || dt->timezone_minutes > 59)
						ret = "Timezone minutes shoud range from 0 to 59";
					else
					{
						if (dt->timezone_hour == 14 && dt->timezone_minutes != 0)
							ret = "When timezone hour is 14, timezone minutes must be 0";
						else
							ret = MAL_SUCCEED;
					}
				}
			}
		}
	}
	return ret;
}

static str RDFparseFractions(rdf_datetime *dt, str fractions)
{
	str ret = MAL_SUCCEED;
	int fractions_len = strlen(fractions);
	int i = 0;
	while (i<fractions_len)
	{
		if (!RDFisDigit(fractions[i]))
			ret = "A non-digit has been found parsing the second fractions";
		i++;
	}
	if (ret == MAL_SUCCEED)
	{
		dt->fractions = strtol(fractions, NULL, 10);
		if (errno == ERANGE && (dt->fractions == LONG_MAX || dt->fractions == LONG_MIN))
			ret = "Seconds fractions is out of long range";
		if (ret == MAL_SUCCEED)
			if (dt->fractions < 0)
				ret = "Second fractions should be greater or equal to zero";
	}
	return ret;
}

static str RDFparseSeconds(rdf_datetime *dt, str seconds)
{
	str ret = MAL_SUCCEED;
	int seconds_len = strlen(seconds);
	if (seconds_len == 2)
	{
		int i = 0;
		while (i<seconds_len && ret==MAL_SUCCEED)
		{
			if (!RDFisDigit(seconds[i]))
				ret = "A non-digit has been found parsing the seconds";
			i++;
		}
		if (ret == MAL_SUCCEED)
		{
			dt->seconds = strtol(seconds, NULL, 10);
			if (dt->seconds < 0 || dt->seconds > 59)
				ret = "Seconds should range between 0 and 59";
		}
	}
	else
		ret = "Seconds should be a two-digit number";
	return ret;
}

static str RDFparseMinutes(rdf_datetime *dt, str minutes)
{
	str ret = MAL_SUCCEED;
	int minutes_len = strlen(minutes);
	if (minutes_len == 2)
	{
		int i = 0;
		while (i<minutes_len && ret==MAL_SUCCEED)
		{
			if (!RDFisDigit(minutes[i]))
				ret = "A non-digit has been found parsing the minutes";
			i++;
		}
		if (ret == MAL_SUCCEED)
		{
			dt->minutes = strtol(minutes, NULL, 10);
			if (dt->minutes < 0 || dt->minutes > 59)
				ret = "Minutes should range between 0 and 59";
		}
	}
	else
		ret = "Minutes should be a two-digit number";
	return ret;
}

static str RDFparseHour(rdf_datetime *dt, str hour)
{
	str ret = MAL_SUCCEED;
	int hour_len = strlen(hour);
	if (hour_len == 2)
	{
		int i = 0;
		while (i<hour_len && ret==MAL_SUCCEED)
		{
			if (!RDFisDigit(hour[i]))
				ret = "A non-digit has been found parsing the hour";
			i++;
		}
		if (ret == MAL_SUCCEED)
		{
			dt->hour = strtol(hour, NULL, 10);
			if (dt->hour < 0 || dt->hour > 24)
				ret = "An hour should range between 0 and 24";
		}
	}
	else
		ret = "An hour should be a two-digit number";
	return ret;
}

static str RDFparseDay(rdf_datetime *dt, str day)
{
	str ret = MAL_SUCCEED;
	int day_len = strlen(day);
	if (day_len == 2)
	{
		int i = 0;
		while (i<day_len && ret==MAL_SUCCEED)
		{
			if (!RDFisDigit(day[i]))
				ret = "A non-digit has been found parsing the day";
			i++;
		}
		if (ret == MAL_SUCCEED)
		{
			dt->day = strtol(day, NULL, 10);
			if (dt->day < 1 || dt->day > 31)
				ret = "A day should range between 1 and 31";
		}
	}
	else
		ret = "A day should be a two-digit number";
	return ret;
}

static str RDFparseMonth(rdf_datetime *dt, str month)
{
	str ret = MAL_SUCCEED;
	int month_len = strlen(month);
	if (month_len == 2)
	{
		int i = 0;
		while (i<month_len && ret==MAL_SUCCEED)
		{
			if (!RDFisDigit(month[i]))
				ret = "A non-digit has been found parsing the month";
			i++;
		}
		if (ret == MAL_SUCCEED)
		{
			dt->month = strtol(month, NULL, 10);
			if (dt->month < 1 || dt->month > 12)
				ret = "A month should range between 1 and 12";
		}
	}
	else
		ret = "A month should be a two-digit number";
	return ret;
}

static str RDFparseYear(rdf_datetime *dt, str year)
{
	str ret = MAL_SUCCEED;
	int year_len = strlen(year);
	if (year_len>=4)
	{
		int i, digitStart;
		if (year[0]=='-')
			digitStart = i = 1;
		else
			digitStart = i = 0;
		while (i<year_len && ret==MAL_SUCCEED)
		{
			if (!RDFisDigit(year[i]))
				ret = "A non-digit has been found parsing the year";
			i++;
		}
		if (ret==MAL_SUCCEED && year_len > 4 && year[digitStart]=='0')
			ret = "Leading zeros are prohibited when year length is grater than 4";
		if (ret==MAL_SUCCEED && year_len == 4)
		{
			bool is0000 = true;/* is the year==0000? it is prohibited */
			for (i=0; i<year_len; i++)
				if (year[i]!='0')
					is0000 = false;
			if (is0000)
				ret = "Year 0000 is prohibited";
		}
		if (ret == MAL_SUCCEED)
		{
			dt->year = strtol(year, NULL, 10);
			if (errno==ERANGE &&  (dt->year == LONG_MAX || dt->year == LONG_MIN))
				ret = "Year is out of long range";
		}
	}
	else
		ret = "A year must have 4 or more digits";
	return ret;
}

static str RDFdateTimeSemanticCheck(rdf_datetime *dt)
{
	str ret = MAL_SUCCEED;
	/* check if day is correct */
	if (dt->day == 31)
	{
		if (dt->month != 1 || dt->month != 3 || dt->month != 31 ||
			dt->month != 7 || dt->month != 8 || dt->month != 10 || dt->month != 31)
			ret = "The month in the date has not 31 days";
	}
	if (dt->day == 30 && dt->month==2)
		ret = "February has not 30 days";
	/* check hour */
	if (dt->hour == 24)
	{
		if (dt->minutes != 0)
			ret = "If hour is 24, minutes must be 0";
		else
		{
			dt->hour = 0;
			dt->day++;/*what happens if we are in 28 february?? a mess */
		}
	}
	return ret;
}

static str RDFparseDateTime(rdf_datetime *dt, str date_string)
{
	str ret = MAL_SUCCEED;
	if (dt)
	{
		int date_len = strlen(date_string);
		chr date_array[date_len+1];
		str date = (str)date_array;
		strncpy(date, date_string, date_len+1);
		if (date_len >= 19)
		{
			int i;
			str year;
			str month;
			str day;
			str hour;
			str minutes;
			chr seconds[3];
			str fractions = NULL;
			str timezone = NULL;
			
			year = date;
			if (date[0] == '-')
			{
				date = &date[1];
				date_len--;
			}
			/*'-'? yyyy '-' mm '-' dd 'T' hh ':' mm ':' ss ('.' s+)? (zzzzzz)?*/
			/* find year separator */
			i = 0;
			while (date[i] != '-' && i<date_len)
				i++;
			/* '-' is at i */
			if (i <= date_len - 15)
			{
				date[i] = '\0';
				month = &date[i+1];
				/* find month separator */
				while (date[i] != '-' && i<date_len)
					i++;
			}
			if (i <= date_len - 12)
			{
				date[i] = '\0';
				day = &date[i+1];
				/* find day separator */
				while (date[i] != 'T' && i<date_len)
					i++;
			}
			if (i <= date_len - 9)
			{
				date[i] = '\0';
				hour = &date[i+1];
				/* find hour separator */
				while (date[i] != ':' && i<date_len)
					i++;
			}
			if (i <= date_len - 6)
			{
				date[i] = '\0';
				minutes = &date[i+1];
				/* find minutes separator */
				while (date[i] != ':' && i<date_len)
					i++;
			}
			if (i <= date_len - 3)
			{
				date[i++] = '\0';
				seconds[0] = date[i++];
				seconds[1] = date[i++];
				seconds[2] = '\0';
			}
			if (i<date_len)
			{
				if (date[i] == '.' && i<date_len-1)/*fractions of second*/
				{
					str fractions_start; 
					int fractions_len = 0;
					i++;
					fractions_start = &date[i];
					/* find fractions separator */
					while(date[i] != '+' && date[i] != '-' && date[i] != 'Z' && i<date_len)
					{
						i++;
						fractions_len++;
					}
					fractions = GDKmalloc(fractions_len+1);
					strncpy(fractions, fractions_start, fractions_len);
					fractions[fractions_len] = '\0';
				}
				if (date[i] == '+' || date[i] == '-' || date[i] == 'Z') /* timezone */
				{
					timezone = &date[i];
					i = date_len;
				}
			}
			ret = RDFparseYear(dt, year);
			if (ret == MAL_SUCCEED)
			{
				ret = RDFparseMonth(dt, month);
				if (ret == MAL_SUCCEED)
				{
					ret = RDFparseDay(dt, day);
					if (ret == MAL_SUCCEED)
					{
						ret = RDFparseHour(dt, hour);
						if (ret == MAL_SUCCEED)
						{
							ret = RDFparseMinutes(dt, minutes);
							if (ret == MAL_SUCCEED)
							{
								ret = RDFparseSeconds(dt, (str)seconds);
								if (ret == MAL_SUCCEED)
								{
									if (fractions != NULL)
										ret = RDFparseFractions(dt, fractions);
									if (ret == MAL_SUCCEED)
									{
										if (timezone != NULL)
										{
											dt->hasTimeZone = true;
											ret = RDFparseTimezone(dt, timezone);
										}
										else
											dt->hasTimeZone = false;
										if (ret == MAL_SUCCEED)
											ret = RDFdateTimeSemanticCheck(dt);
									}
								}
							}
						}
					}
				}
			}
			if (fractions != NULL)
				GDKfree(fractions);
		}
		else
			ret = "DateTime string too short";
	}
	else
		ret = "rdf_datetime should not be NULL";
	return ret;
}

static void RDFdoubleToString(str ret, double val)
{
	unsigned long long l, mask_pos = 0x8000000000000000, mask_neg = 0xffffffffffffffff;
	bool firstCharFound = false;
	l = *((unsigned long long*)&val);
	if (val == 0)
		return;/* 0 is a special case in Monet/RDF and it has not to be converted to string here */
	if (val<0)
		l ^= mask_neg;
	else
		l ^= mask_pos;
	snprintf(ret, 17, "%16llx", l);
	/* change leading white spaces to 0 */
	for (int i=0; i<16 && !firstCharFound; i++)
		if (ret[i] == ' ')
			ret[i] = '0';
		else
			firstCharFound = true;
}

static double RDFstringToDouble(str string, bool positive)
{
	double ret;
	unsigned long long l, mask_pos = 0x8000000000000000, mask_neg = 0xffffffffffffffff;
	l = strtoull(string, NULL, 16);
	if (positive)
		l ^= mask_pos;
	else
		l ^= mask_neg;
	ret = *((double*)&l);
	return ret;
}

static bool RDFisDigitSequence(str string)
{
	bool ret = true;
	int len = strlen(string);
	if (len > 0)
	{
		for (int i=0; i<len && ret == true; i++)
			if (!RDFisDigit(string[i]))
				ret = false;
	}
	else
		ret = false;
	return ret;
}

static bool RDFisInteger(str string)
{
	bool ret = true;
	int len = strlen(string);
	if (len>0)
		if (string[0] == '+' || string[0] == '-')
			ret = RDFisDigitSequence(&string[1]);
		else
			ret = RDFisDigitSequence(string);
	else
		ret = false;
	return ret;
}

static bool RDFisDecimal(str string)
{
	int len = strlen(string);
	if (len>0)
	{
		int i;
		for (i=0; i<len && string[i] != '.'; i++);
		{
			char int_part[i+1];
			str fract_part = NULL;
			strncpy(int_part, string, i);
			int_part[i] = '\0';
			if (string[i] == '.')
			{
				if (i<len-1)
					fract_part=&string[i+1];
				else
					return false;
			}
			if (RDFisInteger(int_part) && (fract_part == NULL || RDFisDigitSequence(fract_part)))
				return true;
			else
				return false;
		}
	}
	else
		return false;
}

static str RDFisDoubleOrFloat(str string, bool isDouble)
{
	str ret = MAL_SUCCEED;
	int len = strlen(string);
	if (len>0)
	{
		int i;
		if (!strcmp(string, "INF") || !strcmp(string, "-INF") || !strcmp(string, "NaN"))
			return MAL_SUCCEED;
		for (i=0; i<len && string[i] != 'e' && string[i] != 'E'; i++);/*semicolon!*/
		{
			/*
			 * new block to make possible to declare some stuff without CC complaing
			 * for mixing declarations and code
			 */
			char mantissa[i+1];
			str exponent = NULL;
			double mantissa_val, exponent_val;
			strncpy(mantissa, string, i);
			mantissa[i] = '\0';
			if (string[i] == 'e' || string[i] == 'E')
			{
				if (i<len-1)
					exponent=&string[i+1];
				else
					ret = "There is no exponent after the 'E'";
			}
			if (ret == MAL_SUCCEED)
			{
				if (!RDFisDecimal(mantissa))
					ret = "The mantissa is not a decimal";
				else
					if (exponent != NULL && !RDFisInteger(exponent))
						ret = "The exponent is not an integer";
				if (ret == MAL_SUCCEED)
				{
					mantissa_val = strtod(mantissa, NULL);
					if (isDouble)
					{
						if (abs(mantissa_val) >= exp2(53))
							ret = "The mantissa is out of double range, its absolute value should be less than 2^53";
					}
					else
						if (abs(mantissa_val) >= exp2(24))
							ret = "The mantissa is out of float range, its absolute value should be less than 2^24";
					if (ret == MAL_SUCCEED && exponent != NULL)
					{
						exponent_val = strtod(exponent, NULL);
						if (isDouble)
						{
							if (exponent_val > 970 || exponent_val < -1075)
								ret = "The exponent is out of double range, should be LE than 970 and GE than -1075";
						}
						else
							if (exponent_val > 104 || exponent_val < -149)
								ret = "The exponent is out of float range, should be LE than 104 and GE than -149";
					}
				}
			}
		}
	}
	else
		ret = "An empty string cannot be parsed to a number";
	return ret;
}

static str RDFisFloat(str string)
{
	return RDFisDoubleOrFloat(string, false);
}

static str RDFisDouble(str string)
{
	return RDFisDoubleOrFloat(string, true);
}

static str RDFparseDoubleOrFloat(double *val, str string)
{
	str ret = MAL_SUCCEED;
	if (!strcmp(string, "INF") || !strcmp(string, "-INF") || !strcmp(string, "NaN"))
		ret = "Cannot parse +/- INF and NaN";
	else
	{
		char *endptr;
		*val = strtod(string, &endptr);
		if (errno == ERANGE && *val == HUGE_VAL)
			ret = "The numeric value is out of the double range";
		else if (*endptr != '\0')
			ret = "Could not convert numeric to double";
	}
	return ret;
}
/*
static str RDFparseFloat(double *val, str string, bool checkLexicalForm)
{
	str ret = MAL_SUCCEED;
	if (checkLexicalForm)
		ret = RDFisFloat(string);
	if (ret == MAL_SUCCEED)
		ret = RDFparseDoubleOrFloat(val, string);
	return ret;
}
*/
static str RDFparseDouble(double *val, str string, bool checkLexicalForm)
{
	str ret = MAL_SUCCEED;
	if (checkLexicalForm)
		ret = RDFisDouble(string);
	if (ret == MAL_SUCCEED)
		ret = RDFparseDoubleOrFloat(val, string);
	return ret;
}

void message_handler(void *user_data, raptor_locator *locator, const char *message)
{
	size_t length = 0;
	message_handler_vars *info = (message_handler_vars *)user_data;
	str *ret = info->ret;
	char *ret_array = info->ret_array;
	int written = 0;
	str msg = ret_array;
	*ret = ret_array;
	if (locator->uri)
	{
		written = snprintf(msg, RET_MAXLEN, "In URI location \"%s\": ", raptor_uri_as_string(locator->uri));
		if (written >= RET_MAXLEN)
			ret_array[RET_MAXLEN-1] = '\0';
		length = strlen(*ret);
		msg = *ret + length * (sizeof(char));
	}
	if (locator->line >=0 && length < RET_MAXLEN-1)
	{
		written = snprintf(msg, RET_MAXLEN-length, "at line %d: ", locator->line);
		if (written >= RET_MAXLEN)
			ret_array[RET_MAXLEN-1] = '\0';
		length = strlen(*ret);
		msg = *ret + length * (sizeof(char));
	}
	if (locator->column >=0 && length < RET_MAXLEN-1)
	{
		written = snprintf(msg, RET_MAXLEN-length, "at column %d: ", locator->column);
		if (written >= RET_MAXLEN)
			ret_array[RET_MAXLEN-1] = '\0';
		length = strlen(*ret);
		msg = *ret + length * (sizeof(char));
	}
	if (message && length < RET_MAXLEN-1)
	{
		written = snprintf(msg, RET_MAXLEN-length, "%s\n", message);
		if (written >= RET_MAXLEN)
			ret_array[RET_MAXLEN-1] = '\0';
	}
	if (info->parser)
		raptor_parse_abort(info->parser);
	if (info->serializer)
		raptor_serialize_end(info->serializer);
}

@= RDFins
	HASHfnd_str(bun, mi, @1v);/*bun is returned, is an index.*/
    if (bun == BUN_NONE)
    {
    	if (map->T->hash == NULL || BATcount(map) > 4 * map->T->hash->mask)
    	{
		HASHdestroy(map); /* keeps hash performance in check */
	        BAThash(BATmirror(map), 2*BATcount(map));
    	}
        bun = (BUN) map->batCount;
        if (!BUNappend(map,(ptr)@1v, TRUE)) {
            GDKerror("RDFimport: @1[" LLFMT "] = %s, BUNappend fails\n", cur, @1v);/*????TODO ask*/
            *ret = ret_array;
            snprintf(*ret, RET_MAXLEN, "BUNappend failed inserting \'%s\'", @1v);
        }
   }
   /* s,p,o[cur] are set to the virtual oid which is bun s p and o are arrays of oid */
   @1[*cur] = (oid) bun;

@= RDFprefix
	size_t len = strlen(@2) + 2; /* +1 for '\0', +1 for the prefix */
	char prefix = RDFsectionToChr(@3);
	@1 = GDKmalloc(len*sizeof(char));
	if (@1)
		snprintf(@1, len, "%c%s", prefix, @2);
	else
		*ret = "Failed to allocate memory for @1";

@= RDFprefixLanguage
	size_t len = strlen((char*)@2) + strlen((char *)@3) +2; /* +1 for '\0', +1 for '@' */
	@1 = GDKmalloc(len*sizeof(char));
	if (@1)
		snprintf(@1, len, "%s\@%s", @3, @2);
	else
		*ret = "Failed to allocate memory for @1";

@= RDFprefixDatatype
	size_t len = strlen((char*)@2) + strlen((char *)@3) +2; /* +1 for '\0', +1 for '^' */
	@1 = GDKmalloc(len*sizeof(char));
	if (@1)
		snprintf(@1, len, "%s^%s", @3, @2);
	else
		*ret = "Failed to allocate memory for @1";

@c
void
triples_handler(void* user_data, const raptor_statement* triple) 
{
	triple_handler_vars *data = (triple_handler_vars *)user_data;
	lng *cur = data->cur;
	lng *lim = data->lim;
	str ov, pv, sv;
	chr tv;
	BAT *map = data->map;
	BAT *sb = data->sb;
	BAT *pb = data->pb;
	BAT *ob = data->ob;
	BAT *tb = data->tb;
	oid *o = data->o;
	oid *p = data->p;
	oid *s = data->s;
	chr *t = data->t;
	str *ret = data->ret;
	char *ret_array = data->ret_array;
	BATiter mi = bat_iterator(BATmirror(map));
	BUN bun;
	
	/* get the subject */
	if (triple->subject_type == RAPTOR_IDENTIFIER_TYPE_RESOURCE)
	{
		@:RDFprefix(sv, (str)raptor_uri_as_string((raptor_uri *)triple->subject), RDF_SEC_IRI)@
	}
	else if (triple->subject_type == RAPTOR_IDENTIFIER_TYPE_ANONYMOUS)
	{
		@:RDFprefix(sv, (str)triple->subject, RDF_SEC_BLANK)@
	}
	else
		*ret = "Unexpected subject type";
	
	if (*ret == MAL_SUCCEED)
	{
		/* get the predicate */
		if(triple->predicate_type == RAPTOR_IDENTIFIER_TYPE_RESOURCE)
		{
		    @:RDFprefix(pv, (str)raptor_uri_as_string((raptor_uri *)triple->predicate), RDF_SEC_IRI)@
		}
		else
			*ret="Unexpected predicate type";
		
		if (*ret == MAL_SUCCEED)
		{
			/* get the object */
			switch (triple->object_type)
			{
			case RAPTOR_IDENTIFIER_TYPE_RESOURCE:
			{
				@:RDFprefix(ov, (str)raptor_uri_as_string((raptor_uri *)triple->object), RDF_SEC_IRI)@
				tv = RDFtypeToChr(RDF_TYPE_IRI);
				break;
			}
			case RAPTOR_IDENTIFIER_TYPE_ANONYMOUS:
			{
				@:RDFprefix(ov, (str)triple->object, RDF_SEC_BLANK)@/*TODO correct??*/
				tv = RDFtypeToChr(RDF_TYPE_BLANK);
				break;
			}
			case RAPTOR_IDENTIFIER_TYPE_LITERAL:
			{
				char *obj_datatype = (char *)raptor_uri_as_string(triple->object_literal_datatype);
				rdf_type obj_type = RDFxsdToType(obj_datatype);
				tv = RDFtypeToChr(obj_type);
				if (triple->object_literal_language != NULL && obj_type != RDF_TYPE_PLAIN)
				{
					*ret = ret_array;
					snprintf(*ret, RET_MAXLEN,
							"The object \'%s\' has language tag \'%s\', but has datatype \'%s\'; only plain literals may have a language tag",
							(str)triple->object, triple->object_literal_language, obj_datatype);
				}
				else
				{
					switch (obj_type)
					{
					case RDF_TYPE_PLAIN:
					case RDF_TYPE_STRING:
					{
						if (( obj_type == RDF_TYPE_PLAIN ) &&
							( triple->object_literal_language != NULL ) )
						{
							str langPrefixedObject;
							@:RDFprefixLanguage(langPrefixedObject, (str)triple->object, triple->object_literal_language)@
							if (*ret == MAL_SUCCEED)
							{
								if (strlen((str)triple->object) == 0)
								{
									@:RDFprefix(ov, langPrefixedObject, RDF_SEC_LANG_EMPTY_STRING)@
								}
								else
								{
									@:RDFprefix(ov, langPrefixedObject, RDF_SEC_LANG_STRING)@
								}
								GDKfree(langPrefixedObject);
							}
						}
						else
						{
							if (strlen((str)triple->object) == 0)
							{
								@:RDFprefix(ov, (str)triple->object, RDF_SEC_EMPTY_STRING)@
							}
							else
							{
								@:RDFprefix(ov, (str)triple->object, RDF_SEC_STRING)@
							}
						}
						break;
					}
					case RDF_TYPE_XML_LITERAL:
					{
						@:RDFprefix(ov, (str)triple->object, RDF_SEC_XML_LITERAL)@
						break;
					}
					case RDF_TYPE_INTEGER:
						if (!RDFisInteger((str)triple->object))
							*ret = "The object is not a valid integer";
						goto parse;
					case RDF_TYPE_DECIMAL:
						if (!RDFisDecimal((str)triple->object))
							*ret = "The object is not a valid decimal";
						goto parse;
					case RDF_TYPE_FLOAT:
						*ret = RDFisFloat((str)triple->object);
						goto parse;
					case RDF_TYPE_DOUBLE:
					{
						*ret = RDFisDouble((str)triple->object);
		parse:			if (*ret == MAL_SUCCEED)
						{
							double val;
							if (!strcmp((str)triple->object, "INF"))
							{
								@:RDFprefix(ov, "", RDF_SEC_POS_INF)@
							}
							else if (!strcmp((str)triple->object, "-INF"))
							{
								@:RDFprefix(ov, "", RDF_SEC_NEG_INF)@
							}
							else if (!strcmp((str)triple->object, "NaN"))
							{
								@:RDFprefix(ov, "", RDF_SEC_NAN)@
							}
							else
							{
								*ret = RDFparseDouble(&val, (str)triple->object, false);
								if (*ret == MAL_SUCCEED)
								{
									if (val == 0)
									{
										@:RDFprefix(ov, "", RDF_SEC_ZERO)@
									}
									else
									{
										char string[17];
										RDFdoubleToString(string, val);
										if (val > 0)
										{
											@:RDFprefix(ov, string, RDF_SEC_POS_NUM)@
										}
										else if (val < 0)
										{
											@:RDFprefix(ov, string, RDF_SEC_NEG_NUM)@
										}
									}
								}
							}
						}
						break;
					}
					case RDF_TYPE_BOOLEAN:
					{
						if (!strcmp((str)triple->object, "1") || !strcmp((str)triple->object, "true"))
						{
							@:RDFprefix(ov, "", RDF_SEC_TRUE)@
						}
						else if (!strcmp((str)triple->object, "0") || !strcmp((str)triple->object, "false"))
						{
							@:RDFprefix(ov, "", RDF_SEC_FALSE)@
						}
						else
						{
							*ret = ret_array;
							snprintf(*ret, RET_MAXLEN, "Invalid boolean: \'%s\'", (str)triple->object);
						}
						break;
					}
					case RDF_TYPE_DATETIME:
					{
						rdf_datetime *datetime = GDKmalloc(sizeof(rdf_datetime));
						if (datetime)
						{
							*ret = RDFparseDateTime(datetime, (str)triple->object);
							if (*ret == MAL_SUCCEED)
							{
								str datetime_string;// = RDFdateTimeToString(dt);
								@:RDFprefix(ov, datetime_string, RDF_SEC_DATETIME)@
								GDKfree(datetime);
							}
							else
							{
								/*TODO better error handling, print all the triple */
								*ret = ret_array;
								snprintf(*ret, RET_MAXLEN, "Invalid datetime: \'%s\'", (str)triple->object);
							}
							break;
						}
						else
							*ret = "Could not allocate memory for a rdf_datetime";
					}
					case RDF_TYPE_OTHER:
					{
						if (strchr(obj_datatype, '^')==NULL)
						{
							str datatypePrefixedObj;
							@:RDFprefixDatatype(datatypePrefixedObj, (str)triple->object, obj_datatype)@
							if (*ret == MAL_SUCCEED)
							{
								@:RDFprefix(ov, datatypePrefixedObj, RDF_SEC_OTHER)@
								GDKfree(datatypePrefixedObj);
							}
						}
						else
						{
							*ret = ret_array;
							snprintf(*ret, RET_MAXLEN, "Invalid datatype URI: \'%s\'", obj_datatype);
						}
						break;
					}
					default:
						*ret = "Control flow should never reach this point";
					}/*END of switch (obj_type)*/
					break;
				}
			}
			default:
				*ret="Unexpected object type";
			}
			
			if (*ret == MAL_SUCCEED)
			{
				@:RDFins(o)@
				if (*ret == MAL_SUCCEED)
				{
				    @:RDFins(p)@
				    if (*ret == MAL_SUCCEED)
				    {
				    	@:RDFins(s)@
				    	if (*ret == MAL_SUCCEED)
				    	{
				    		t[*cur] = tv;
						    if (++(*cur) > *lim) {
						        *lim *= 2;
						        ob = BATextend(ob, *lim);
						        pb = BATextend(pb, *lim);
						        sb = BATextend(sb, *lim);
						        tb = BATextend(tb, *lim);
						        if (ob == NULL || pb == NULL || sb == NULL || tb == NULL)
						            *ret = "BATextend failed";
						        else
						        {
							        o = (oid *) Tloc(ob, BUNfirst(ob));
							        p = (oid *) Tloc(pb, BUNfirst(pb));
							        s = (oid *) Tloc(sb, BUNfirst(sb));
							        t = (chr *) Tloc(tb, BUNfirst(tb));
						        }
						    }
				    	}
				    }
				}
				GDKfree(ov);
			}
			GDKfree(pv);
		}
		GDKfree(sv);
	}
	if (*ret != MAL_SUCCEED)
		raptor_parse_abort(data->parser);
}

static str 
RDFimport_(BAT** S, BAT** P, BAT **O, BAT **T, str url, BAT *map, char *ret_array) {
	raptor_parser *parser;
	raptor_uri *rdf_file;
	str ret = MAL_SUCCEED;
	raptor_init();
	parser = raptor_new_parser("rdfxml");
	if (!parser)
		ret = "Could not create a Redland parser";
	else
	{
		rdf_file = raptor_new_uri((unsigned char*)url);
		if (!rdf_file)
		{
			ret = ret_array;
			snprintf(ret, RET_MAXLEN, "Invalid url: \'%s\'", url);
		}
		else
		{
			BAT *ob, *pb, *sb, *tb;
			oid *o,*p,*s;
			chr *t;
			triple_handler_vars *data;
			message_handler_vars *info;
			lng *lim, *cur, limv, curv;
			limv = 8192;
			curv = 0;
			lim = &limv;/*TODO *lim = RDFestimate(url);*/
			cur = &curv;
			
			ob = *O = BATnew(TYPE_void, TYPE_oid, *lim);
		    pb = *P = BATnew(TYPE_void, TYPE_oid, *lim);
		    sb = *S = BATnew(TYPE_void, TYPE_oid, *lim);
		    tb = *T = BATnew(TYPE_void, TYPE_chr, *lim);
		    
		    o = (oid *) Tloc(ob, BUNfirst(ob));
		    p = (oid *) Tloc(pb, BUNfirst(pb));
		    s = (oid *) Tloc(sb, BUNfirst(sb));
		    t = (chr *) Tloc(tb, BUNfirst(tb));
		    
		    if (map == NULL || ob == NULL || pb == NULL || sb == NULL || tb == NULL)
		        ret = "Creation of one of map, ob, pv or sb failed";
		    else
		    {
			    data = GDKmalloc(sizeof(triple_handler_vars));
			    if (data)
			    {
			    	info = GDKmalloc(sizeof(message_handler_vars));
			    	if (info)
			    	{
				    	data->parser = parser;
				    	data->cur = cur;
				    	data->lim = lim;
				    	data->map =map;
				    	data->sb = sb;
				    	data->pb = pb;
				    	data->ob = ob;
				    	data->tb = tb;
				    	data->s = s;
				    	data->p = p;
				    	data->o = o;
				    	data->t = t;
				    	data->ret = &ret;
				    	data->ret_array = ret_array;
				    	
				    	info->serializer=NULL;
				    	info->parser = parser;
				    	info->ret = &ret;
				    	info->ret_array = ret_array;
				    	
				    	raptor_set_statement_handler(parser, data, triples_handler);
						raptor_set_fatal_error_handler(parser, info, message_handler);
						raptor_set_error_handler(parser, info, message_handler);
						raptor_set_warning_handler(parser, info, message_handler);
						raptor_set_parser_strict(parser, TRUE);
					    
					    if (raptor_parse_file(parser, rdf_file, NULL) == 0)
					    {
					    	if (ret == MAL_SUCCEED)
						    {
							    BATseqbase(ob, 0);
							    BATseqbase(pb, 0);
							    BATseqbase(sb, 0);
							    BATseqbase(tb, 0);
							    BATsetcount(ob, *cur);
							    BATsetcount(pb, *cur);
							    BATsetcount(sb, *cur);
							    BATsetcount(tb, *cur);
							    ob->tsorted = 0;
							    pb->tsorted = 0;
							    sb->tsorted = 0;
							    tb->tsorted = 0;
							    BATkey(BATmirror(ob), FALSE);
							    BATkey(BATmirror(sb), FALSE);
							    BATkey(BATmirror(pb), FALSE);
							    BATkey(BATmirror(tb), FALSE);
						    }
					    }
					    GDKfree(info);
			    	}
			    	else
			    		ret = "message_handler_vars malloc failed";
			    	GDKfree(data);
			    }
			    else
			    	ret = "triple_handler_vars malloc failed";
			    raptor_free_uri(rdf_file);
		    }
		}
		raptor_free_parser(parser);
	}
    raptor_finish();
	return ret;
}

rdf_export
str RDFimport(int* S, int* P, int* O, str *url, bat m)
{
    BAT *sb = NULL, *ob=NULL, *pb = NULL, *tb = NULL, *map = BATdescriptor(m);
    str ret;
    char ret_array[RET_MAXLEN];
    if (map) {
    	RDFimport_(&sb, &pb, &ob, &tb, *url, map, ret_array);
        if (ret == MAL_SUCCEED) {
            BBPkeepref(*O = ob->batCacheid);/*changes physical reference to logical*/
            BBPkeepref(*P = pb->batCacheid);
            BBPkeepref(*S = sb->batCacheid);
        }
        BBPreleaseref(map->batCacheid);
    }
    return ret;
}

int CTrefine(BAT **ret, BAT *b, BAT *a);
BAT * BATmalleftfetchjoin(BAT *l, BAT *r);
static str
RDFsort(BAT *commit,
		BAT *S, BAT *sb, BAT *pb, BAT *ob, BAT *tb,
		BAT **Spot, BAT **sPot, BAT **spOt, BAT **spoT,
		str Spot_nme, str sPot_nme, str spOt_nme, str spoT_nme, str db, str graph)
{
    BAT *SPO, *SP;
    str ret = MAL_SUCCEED;
    CTrefine(&SP, S, pb);
    if (SP) {
        CTrefine(&SPO, SP, ob);
        BBPreclaim(SP);
        if (SPO) {
            BAT *piv = BATmirror(BATmark(SPO, 0));
            BBPreclaim(SPO);
            if (piv) {
            	/*BATleftfetchjoin wants also a size_t estimate
            	 * BATmalleftfetchjoin not. Which has to be used?
            	 * TODO*/ 
                *Spot = BATleftfetchjoin(piv, sb, oid_nil);
                if (Spot) {
                    *sPot = BATleftfetchjoin(piv, pb, oid_nil);
                    if (sPot) {
                        *spOt = BATleftfetchjoin(piv, ob, oid_nil);
                        if (spOt) {
                        	*spoT = BATleftfetchjoin(piv, tb, oid_nil);
                        	if (spoT) {
                        		char Spot_buf[1024], sPot_buf[1024], spOt_buf[1024], spoT_buf[1024];
                        		snprintf(Spot_buf, 1024, "%s_%s_%s", db, graph, Spot_nme);
                        		snprintf(sPot_buf, 1024, "%s_%s_%s", db, graph, sPot_nme);
                        		snprintf(spOt_buf, 1024, "%s_%s_%s", db, graph, spOt_nme);
                        		snprintf(spoT_buf, 1024, "%s_%s_%s", db, graph, spoT_nme);
                        		
                        		if (BATname(*Spot, Spot_buf) == 0 &&
                        			BATname(*sPot, sPot_buf) == 0 &&
                        			BATname(*spOt, spOt_buf) == 0 &&
                        			BATname(*spoT, spoT_buf) == 0) 
                        		{
                        			if (BATmode(*Spot, PERSISTENT) &&
                        				BATmode(*sPot, PERSISTENT) &&
                        				BATmode(*spOt, PERSISTENT) &&
                        				BATmode(*spoT, PERSISTENT))
                        			{
                        				BBPreclaim(piv);
                        				BUNfastins(commit, &((*Spot)->batCacheid), Spot_buf);
                        				BUNfastins(commit, &((*sPot)->batCacheid), sPot_buf);
                        				BUNfastins(commit, &((*spOt)->batCacheid), spOt_buf);
                        				BUNfastins(commit, &((*spoT)->batCacheid), spoT_buf);
                        				/* physical reference, i.e. memory pressure */
                        				BBPreleaseref((*Spot)->batCacheid);
                        				BBPreleaseref((*sPot)->batCacheid);
                        				BBPreleaseref((*spOt)->batCacheid);
                        				BBPreleaseref((*spoT)->batCacheid);
                        				return MAL_SUCCEED;
                        			} else {
                        				BATmode(*Spot, TRANSIENT);
                        				BATmode(*sPot, TRANSIENT);
                        				BATmode(*spOt, TRANSIENT);
                        				BATmode(*spoT, TRANSIENT);
                        				ret = "BATmode failed";
                        			}
                        		}
                                else
                                	ret = "BATname failed";
                        		BBPreclaim(*spoT);
                        	}
                            else
                            	ret = "BATleftfetchjoin(piv, tb, oid_nil) failed";
                            BBPreclaim(*spOt);
                        }
                        else
                        	ret = "BATleftfetchjoin(piv, ob, oid_nil) failed";
                        BBPreclaim(*sPot);
                    }
                    else
                    	ret = "BATleftfetchjoin(piv, pb, oid_nil) failed";
                    BBPreclaim(*Spot);
                }
                else
                	ret = "BATleftfetchjoin(piv, sb, oid_nil) failed";
                BBPreclaim(piv);
            }
            else
            	ret = "BATmirror(BATmark(SPO, 0)) failed";
        }
        else
        	ret = "CTrefine(&SPO, SP, ob) failed";
    }
    else
    	ret = "CTrefine(&SP, S, pb) failed";
    return ret;
}

@= sort
RDFsort(commit, sorted, @1,@2,@3,@4,&@5,&@6,&@7,&@8,"@5","@6","@7","@8",*db,*graph);
@c
str RDFimportGraph(int *d, str *url, str *db, str *graph)
{
    BAT *map = NULL, *sb = NULL, *ob=NULL,
    	*pb = NULL, *tb = NULL, *commit = BATnew(TYPE_bat, TYPE_str, 20);
    char map_buf[1024];
    char ret_array[RET_MAXLEN];
    str ret = MAL_SUCCEED;
    (void)d;
    if (commit) {
        int mapIndex;
        snprintf(map_buf, 1024, "%s_%s_map", *db, *graph);
        mapIndex = BBPindex(map_buf);
        if (mapIndex)
        {
        	ret = ret_array;
        	snprintf(ret, RET_MAXLEN, "There is already a graph named \'%s\' in database \'%s\'", *graph, *db);
        }
        else {
            map = BATnew(TYPE_void, TYPE_str, 8192);/*TODO fix constant*/
            if (map)
            	BATseqbase(map, 0);
            else
            	ret = "Could not create the map BAT";
        }
        memset(map_buf, 0, 1024);
    }
    if (ret == MAL_SUCCEED)
    {
        ret = RDFimport_(&sb, &pb, &ob, &tb, *url, map, ret_array);
        if (ret == MAL_SUCCEED) {
            BAT *Spot = NULL, *sPot = NULL, *spOt = NULL, *spoT = NULL; 
            BAT *Sopt = NULL, *sOpt = NULL, *soPt = NULL, *sopT = NULL; 
            BAT *Post = NULL, *pOst = NULL, *poSt = NULL, *posT = NULL; 
            BAT *Psot = NULL, *pSot = NULL, *psOt = NULL, *psoT = NULL; 
            BAT *Opst = NULL, *oPst = NULL, *opSt = NULL, *opsT = NULL; 
            BAT *Ospt = NULL, *oSpt = NULL, *osPt = NULL, *ospT = NULL; 
            BAT *sorted;
            BATiter ci = bat_iterator(commit);
            BUN p, q;
            BAT *id_translation = BATorder(BATmirror(map));
            if (id_translation)
            {
	            map = BATmirror(BATmark(id_translation, 0));
	            if (map)
	            {
		            id_translation = BATmark(BATmirror(id_translation), 0);
		            if (id_translation)
		            {/* TODO better? how? make error msgs */
			            sb = BATjoin(sb, id_translation, 0);/*TODO number of triples*/
			            pb = BATjoin(pb, id_translation, 0);
			            ob = BATjoin(ob, id_translation, 0);
			            sorted = BATmirror(BATsort(BATmirror(sb)));
			            snprintf(map_buf, 1024, "%s_%s_map", *db, *graph);
			            if ((BATname(map, map_buf) == 0) && BATmode(map, PERSISTENT))
			            {
			            	BUNfastins(commit, &(map->batCacheid), map_buf);
				            if (sorted) {
				            	ret = @:sort(sb,pb,ob,tb,Spot,sPot,spOt,spoT)@
				                if (ret  == MAL_SUCCEED) {
				                	ret = @:sort(sb,ob,pb,tb,Sopt,sOpt,soPt,sopT)@
				                    if (ret == MAL_SUCCEED) {
				                        BBPreclaim(sorted);
				                        sorted = BATmirror(BATsort(BATmirror(pb)));
				                        if (sorted) {
				                        	ret = @:sort(pb,ob,sb,tb,Post,pOst,poSt,posT)@
				                            if (ret == MAL_SUCCEED) {
				                            	ret = @:sort(pb,sb,ob,tb,Psot,pSot,psOt,psoT)@
				                                if (ret == MAL_SUCCEED) {
				                                    BBPreclaim(sorted);
				                                    sorted = BATmirror(BATsort(BATmirror(ob)));
				                                    if (sorted) {
				                                    	ret = @:sort(ob,pb,sb,tb,Opst,oPst,opSt,opsT)@
				                                        if (ret == MAL_SUCCEED) {
				                                        	ret = @:sort(ob,sb,pb,tb,Ospt,oSpt,osPt,ospT)@
				                                            if (ret == MAL_SUCCEED) {
				                                                ret = MAL_SUCCEED;
				                                                BBPreclaim(sorted);
				                                                goto succeed;
				                                            }
				                                            else
				                                            	BBPreclaim(sorted);
				                                            BBPreclaim(Opst);
				                                            BBPreclaim(oPst);
				                                            BBPreclaim(opSt);
				                                            BBPreclaim(opsT);
				                                        }
				                                        else
				                                        	BBPreclaim(sorted);
				                                    }
				                                    BBPreclaim(Psot);
				                                    BBPreclaim(pSot);
				                                    BBPreclaim(psOt);
				                                    BBPreclaim(psoT);
				                                }
				                                else
				                                	BBPreclaim(sorted);
				                                BBPreclaim(Post);
				                                BBPreclaim(pOst);
				                                BBPreclaim(poSt);
				                                BBPreclaim(posT);
				                            }
				                            else
				                            	BBPreclaim(sorted);
				                        }
				                        BBPreclaim(Sopt);
				                        BBPreclaim(sOpt);
				                        BBPreclaim(soPt);
				                        BBPreclaim(sopT);
				                    }
				                    else
				                    	BBPreclaim(sorted);
				                    BBPreclaim(Spot);
				                    BBPreclaim(sPot);
				                    BBPreclaim(spOt);
				                    BBPreclaim(spoT);
				                }
				                else
				                	BBPreclaim(sorted);
				            }
				succeed:    if (ret == MAL_SUCCEED && TMsubcommit(commit)) {
				                ret = "commit failed";
				            }
							if (ret != MAL_SUCCEED) {
				                /* we failed to create everything succesfully and commit. destroy all bats */
				                BATloop(commit, p, q) { 
				                    bat bid = *(bat*) BUNhead(ci,p);
				                    BAT *b = BATdescriptor(bid);
				                    if (b) {
				                        BATmode(b, TRANSIENT);
				                        BBPreleaseref(bid);
				                    }
				                }
				            }
				            BBPreleaseref(sb->batCacheid);/* release physical ref */
				            BBPreleaseref(pb->batCacheid);
				            BBPreleaseref(ob->batCacheid);
				            BBPreleaseref(tb->batCacheid);
			        	}
			            else
			            {
			            	BBPreclaim(map);
			            	map = NULL;
			            	ret = "BATname or BATmode(map, PERSISTENT) failed";
			            }
		            }
	            }
	            BBPreclaim(id_translation);
            }
        }
    }
    BBPreclaim(commit); /* will release logical refs on all bats (if they are persistent, they will stay alive) */  
    if (ret != MAL_SUCCEED)
        throw(MAL, "RDFimportGraph", ret);
    return MAL_SUCCEED;
}

static str getBatNames(str db, str graph, char *s_buf,char *p_buf,char *o_buf, char *t_buf, str order)
{
	str err = "order may be only one among \"spo\",\"sop\",\"pso\",\"pos\",\"osp\",\"ops\"";
	if (strlen(order)>3)
		return err;
	if (strcmp(order, "spo")==0)
	{
		snprintf(s_buf, 1024, "%s_%s_Spot", db, graph);
	    snprintf(p_buf, 1024, "%s_%s_sPot", db, graph);
	    snprintf(o_buf, 1024, "%s_%s_spOt", db, graph);
	    snprintf(t_buf, 1024, "%s_%s_spoT", db, graph);
	}
	else if (strcmp(order, "sop")==0)
	{
		snprintf(s_buf, 1024, "%s_%s_Sopt", db, graph);
	    snprintf(o_buf, 1024, "%s_%s_sOpt", db, graph);
	    snprintf(p_buf, 1024, "%s_%s_soPt", db, graph);
	    snprintf(t_buf, 1024, "%s_%s_sopT", db, graph);
	}
	else if (strcmp(order, "pos")==0)
	{
	    snprintf(p_buf, 1024, "%s_%s_Post", db, graph);
	    snprintf(o_buf, 1024, "%s_%s_pOst", db, graph);
		snprintf(s_buf, 1024, "%s_%s_poSt", db, graph);
		snprintf(t_buf, 1024, "%s_%s_posT", db, graph);
	}
	else if (strcmp(order, "pso")==0)
	{
	    snprintf(p_buf, 1024, "%s_%s_Psot", db, graph);
		snprintf(s_buf, 1024, "%s_%s_pSot", db, graph);
	    snprintf(o_buf, 1024, "%s_%s_psOt", db, graph);
	    snprintf(t_buf, 1024, "%s_%s_psoT", db, graph);
	}
	else if (strcmp(order, "osp")==0)
	{
	    snprintf(o_buf, 1024, "%s_%s_Ospt", db, graph);
		snprintf(s_buf, 1024, "%s_%s_oSpt", db, graph);
	    snprintf(p_buf, 1024, "%s_%s_osPt", db, graph);
	    snprintf(t_buf, 1024, "%s_%s_ospT", db, graph);
	}
	else if (strcmp(order, "ops")==0)
	{
	    snprintf(o_buf, 1024, "%s_%s_Opst", db, graph);
	    snprintf(p_buf, 1024, "%s_%s_oPst", db, graph);
		snprintf(s_buf, 1024, "%s_%s_opSt", db, graph);
		snprintf(t_buf, 1024, "%s_%s_opsT", db, graph);
	}
	else
		return err;
	return MAL_SUCCEED;
}

static str checkSyntax(str syntax)
{
	if (	/*!strcmp(syntax, "atom") ||*/
			!strcmp(syntax, "ntriples") ||
			!strcmp(syntax, "rdfxml") ||
			!strcmp(syntax, "rdfxml-abbrev") ||
			!strcmp(syntax, "rdfxml-xmp") ||
			!strcmp(syntax, "turtle") ||
			/*!strcmp(syntax, "rdfxml-xmp") ||*/
			!strcmp(syntax, "rss-1.0") ||
			!strcmp(syntax, "dot"))
	{
		return MAL_SUCCEED;
	}
	else
		return "syntax may be only one among \"atom\",\"ntriples\",\"rdfxml\",\"rdfxml-abbrev\",\"rdfxml-xmp\",\"turtle\",\"rdfxml-xmp\",\"rss-1.0\",\"dot\"";
}

static str RDFserializeTriple(raptor_statement *triple, raptor_serializer* serializer,
							str sv, str pv, str ov, chr tv)
{
	str ret = MAL_SUCCEED;
	bool 	dealloc_subj = false, dealloc_prop = false,	dealloc_obj = false,
			dealloc_obj_datatype = false, dealloc_obj_lang = false;
	char obj_string[512]; /* used by numeric types for conversion */
	chr ss = sv[0];
	chr ps = pv[0];
	chr os = ov[0];
	rdf_section subj_sec = RDFchrToSection(ss);
	rdf_section prop_sec = RDFchrToSection(ps);
	rdf_section obj_sec = RDFchrToSection(os);
	rdf_type obj_type = RDFchrToType(tv);
	sv = sv + sizeof(chr);
	pv = pv + sizeof(chr);
	ov = ov + sizeof(chr);
	
	if (subj_sec == RDF_SEC_IRI)
	{
		triple->subject = raptor_new_uri((const unsigned char*)sv);
		if (triple->subject)
		{
			triple->subject_type = RAPTOR_IDENTIFIER_TYPE_RESOURCE;
			dealloc_subj = true;
		}
		else
			ret = "Failed to allocate memory for the subject IRI";
	}
	else if (subj_sec == RDF_SEC_BLANK)
	{
		triple->subject = sv;
		triple->subject_type = RAPTOR_IDENTIFIER_TYPE_ANONYMOUS;
	}
	else
		ret = "Subject type unknown";
	
	if (ret == MAL_SUCCEED)
	{
		if (prop_sec == RDF_SEC_IRI)
		{
			triple->predicate = raptor_new_uri((const unsigned char*)pv);
			if (triple->predicate)
			{
				triple->predicate_type = RAPTOR_IDENTIFIER_TYPE_RESOURCE;
				dealloc_prop = true;
			}
			else
				ret = "Failed to allocate memory for the property IRI";
		}
		else
			ret = "Property type unknown";
	}
	
	if (ret == MAL_SUCCEED)
	{
		str xsd_type = RDFtypeToXsd(obj_type);
		
		if (xsd_type != NULL)
		{
			triple->object_literal_datatype = raptor_new_uri((const unsigned char*)xsd_type);
			if (triple->object_literal_datatype)
				dealloc_obj_datatype = true;
			else
				ret = "Failed to allocate memory for the object datatype";
		}
		else
			triple->object_literal_datatype = NULL;
		
		triple->object_literal_language = NULL;
		
		if (ret == MAL_SUCCEED)
		{
			if (obj_sec == RDF_SEC_BLANK && obj_type == RDF_TYPE_BLANK)
			{
				triple->object = ov;
				triple->object_type = RAPTOR_IDENTIFIER_TYPE_ANONYMOUS;
			}
			else if (obj_sec == RDF_SEC_IRI && obj_type == RDF_TYPE_IRI)
			{
				triple->object = raptor_new_uri((const unsigned char*)ov);
				if (triple->object)
				{
					triple->object_type = RAPTOR_IDENTIFIER_TYPE_RESOURCE;
					dealloc_obj = true;
				}
				else
					ret = "Failed to allocate memory for the object IRI value";
			}
			else
			{
				triple->object_type = RAPTOR_IDENTIFIER_TYPE_LITERAL;
				
				if ( (	obj_sec == RDF_SEC_EMPTY_STRING ||
							obj_sec == RDF_SEC_LANG_EMPTY_STRING ||
							obj_sec == RDF_SEC_STRING ||
							obj_sec == RDF_SEC_LANG_STRING ) &&
						  (	obj_type == RDF_TYPE_PLAIN ||
							obj_type == RDF_TYPE_STRING ) )
				{
					if (obj_sec == RDF_SEC_LANG_EMPTY_STRING || obj_sec == RDF_SEC_LANG_STRING)
					{
						unsigned char *lang;
						int i;
						chr cur = ov[0];
						for (i=0; cur!='\@'; i++)
							cur = ov[i];
						lang = GDKmalloc(sizeof(chr)*i);
						if (lang)
						{
							dealloc_obj_lang = true;
							strncpy((char *)lang, ov, i);
							lang[i-1] = '\0';
							triple->object_literal_language = lang;
							ov = &(ov[i]);
						}
						else
							ret = "Failed to allocate memory for the object language";
					}
					if (ret == MAL_SUCCEED)
						triple->object = ov;
				}
				else if (obj_sec == RDF_SEC_XML_LITERAL && obj_type == RDF_TYPE_XML_LITERAL)
					triple->object = ov;
				else if (obj_sec == RDF_SEC_FALSE && obj_type == RDF_TYPE_BOOLEAN)
					triple->object = "false";
				else if (obj_sec == RDF_SEC_TRUE && obj_type == RDF_TYPE_BOOLEAN)
					triple->object = "true";
				else if (obj_sec == RDF_SEC_ZERO)
					triple->object = "0";
				else if (obj_sec == RDF_SEC_NEG_INF && (obj_type == RDF_TYPE_FLOAT || obj_type == RDF_TYPE_DOUBLE))
					triple->object = "-INF";
				else if (obj_sec == RDF_SEC_POS_INF && (obj_type == RDF_TYPE_FLOAT || obj_type == RDF_TYPE_DOUBLE))
					triple->object = "INF";
				else if (obj_sec == RDF_SEC_NAN && (obj_type == RDF_TYPE_FLOAT || obj_type == RDF_TYPE_DOUBLE))
					triple->object = "NaN";
				else if (obj_sec == RDF_SEC_NEG_NUM || obj_sec == RDF_SEC_POS_NUM)
				{
					double val;
					if (obj_sec == RDF_SEC_NEG_NUM)
						val = RDFstringToDouble(ov, false);
					else
						val = RDFstringToDouble(ov, true);
					snprintf(obj_string, 512, "%.10g", val);
					triple->object = obj_string;
				}
				else if (obj_sec == RDF_SEC_OTHER && obj_type == RDF_TYPE_OTHER)
				{
					unsigned char *datatype;
					int i;
					chr cur = ov[0];
					for (i=0; cur!='^'; i++)
						cur = ov[i];
					datatype = GDKmalloc(sizeof(chr)*i);
					if (datatype)
					{
						strncpy((char *)datatype, ov, i);
						datatype[i-1] = '\0';
						triple->object_literal_datatype = raptor_new_uri(datatype);
						GDKfree(datatype);
						if (triple->object_literal_datatype)
						{
							dealloc_obj_datatype = true;
							ov = &(ov[i]);
							triple->object = ov;
						}
						else
							ret = "Failed to allocate memory for the object datatype URI";
					}
					else
						ret = "Failed to allocate memory for the object datatype";
				}
			}
		}
	}
	
	if (ret == MAL_SUCCEED)
	{
		/* Write the triple */
		if (raptor_serialize_statement(serializer, triple)!=0)
			ret="failed to serialize a statement";
	}
	if (dealloc_subj)
		raptor_free_uri((raptor_uri*)triple->subject);
	if (dealloc_prop)
		raptor_free_uri((raptor_uri*)triple->predicate);
	if (dealloc_obj_datatype)
		raptor_free_uri((raptor_uri*)triple->object_literal_datatype);
	if (dealloc_obj_lang)
		GDKfree((unsigned char *)triple->object_literal_language);
	if (dealloc_obj)
		raptor_free_uri((raptor_uri*)triple->object);
	return ret;
}

static str 
RDFexport_(bat M, bat S, bat P, bat O, bat T, str syntax)
{
	char ret_array[RET_MAXLEN];
    str ret = MAL_SUCCEED;
    BAT *map = BATdescriptor(M);
    if (map)
    {
        BAT *sb = BATdescriptor(S);
        if (sb)
        {
            BAT *pb = BATdescriptor(P);
            if (pb)
            {
                BAT *ob = BATdescriptor(O);
                if (ob)
                {
                	BAT *tb = BATdescriptor(T);
                	if (tb)
                	{
				raptor_serializer* rdf_serializer;
		        	const char *filename="/ufs/antonell/Desktop/output.rdf";
		        	lng i, cnt = BATcount(ob);
	                    oid *o = (oid *) Tloc(ob, BUNfirst(ob));
	                    oid *p = (oid *) Tloc(pb, BUNfirst(pb));
	                    oid *s = (oid *) Tloc(sb, BUNfirst(sb));
	                    chr *t = (chr *) Tloc(tb, BUNfirst(tb));
	                    /* var_t position in heap */
	                    var_t *off = (var_t *) Tloc(map, BUNfirst(map));
	                    str base = (str) map->T->vheap->base;/* heap first position */
	                    
	                    raptor_init();
	                    rdf_serializer = raptor_new_serializer(syntax);
	                    
	                    if (rdf_serializer)
	                    {
	                    	message_handler_vars *info = GDKmalloc(sizeof(message_handler_vars));
	                    	if (info)
	                    	{
	                    		info->parser=NULL;
	                    		info->serializer = rdf_serializer;
	                    		info->ret = &ret;
	                    		info->ret_array = ret_array;
	                    		
		                    	raptor_serializer_set_error_handler(rdf_serializer, info, message_handler);
			                    raptor_serializer_set_warning_handler(rdf_serializer, info, message_handler);
			                    if (raptor_serialize_start_to_filename(rdf_serializer, filename) == 0)
			                    {
				                    for(i=0; i <cnt; i++)
				                    {
				                    	if (ret==MAL_SUCCEED)
				                    	{
				                    		raptor_statement *triple;
					                    	str ov = base + off[o[i]];
				    	                    str pv = base + off[p[i]];
				    	                    str sv = base + off[s[i]];
				    	                    chr tv = t[i];
				    	                    /*stream_printf(GDKout, "'%s' '%s' '%s' '%s'\n", ov, pv, sv, url);*/
											/* Make a triple with URI subject, URI predicate, literal object */
											triple=GDKmalloc(sizeof(raptor_statement));
											if (triple)
											{
												ret = RDFserializeTriple(triple, rdf_serializer, sv, pv, ov, tv);
												GDKfree(triple);
											}
											else
												ret = "Failed to allocate memory for raptor_statement";
				                    	}
				                    }
				                    raptor_serialize_end(rdf_serializer);
			                    }
			                    else
			                    	if (ret == MAL_SUCCEED)
			                    		ret = "raptor_serialize_start_to_filename failed";
			                    GDKfree(info);
	                    	}
	                    	else
	                    		ret = "Failed to allocate memory for message_handler_vars";
	                    	raptor_free_serializer(rdf_serializer);
	                    }
	                    else
	                    	ret = "raptor_new_serializer failed";
	                    raptor_finish();
	                    BBPreleaseref(tb->batCacheid);
                	}
                	else
                		ret = "Failed to obtain T bat";
                    BBPreleaseref(ob->batCacheid);
                }
                else
                	ret = "Failed to obtain O bat";
                BBPreleaseref(pb->batCacheid);
            }
            else
            	ret = "Failed to obtain P bat";
            BBPreleaseref(sb->batCacheid);
        }
        else
        	ret = "Failed to obtain S bat";
        BBPreleaseref(map->batCacheid);
    }
    else
    	ret = "Failed to obtain MAP bat";
    return ret;
}

str 
RDFexport(bat M, bat S, bat P, bat O, bat T) {
    str ret = RDFexport_(M, S, P, O, T, "dummy syntax");
    if (ret != MAL_SUCCEED)
        throw(MAL, "RDFexport", ret);
    return MAL_SUCCEED;
}

str RDFexportGraph(int *d, str *db, str *graph, str *order, str *syntax)
{
    char m_buf[1024], o_buf[1024], p_buf[1024], s_buf[1024], t_buf[1024];
    bat map, ob, pb, sb, tb;
    str ret;
    (void)d;
    ret = checkSyntax(*syntax);
    if (ret!= MAL_SUCCEED)
        throw(MAL, "RDFexportGraph", ret);
    ret = getBatNames(*db, *graph, s_buf, p_buf, o_buf, t_buf, *order);
    if (ret!= MAL_SUCCEED)
    	throw(MAL, "RDFexportGraph", ret);
    snprintf(m_buf, 1024, "%s_%s_map", *db, *graph);
    map = BBPindex(m_buf);
    if (map) {
        sb = BBPindex(s_buf);
        if (sb) {
            pb = BBPindex(p_buf);
            if (pb) {
                ob = BBPindex(o_buf);
                if (ob) {
                	tb = BBPindex(t_buf);
                	if (tb) {
                		ret = RDFexport_(map, sb, pb, ob, tb, *syntax);
                	}
                	else
                		ret = "Failed to obtain T bat";
                }
                else
                	ret = "Failed to obtain O bat";
            }
            else
            	ret = "Failed to obtain P bat";
        }
        else
        	ret = "Failed to obtain S bat";
    }
    else
    	ret = "Failed to obtain map bat";
    if (ret != MAL_SUCCEED)
        throw(MAL, "RDFexportGraph", ret);
    return MAL_SUCCEED;
}
@}
