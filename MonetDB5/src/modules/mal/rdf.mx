@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rdf
@a M. Antonelli
@+ Raptor (librdf.org) library interface
Raptor is a free software / Open Source C library that provides a set
of parsers and serializers that generate Resource Description Framework
(RDF) triples by parsing syntaxes or serialize the triples into a syntax.
The supported parsing syntaxes are RDF/XML, N-Triples, TRiG, Turtle, RSS
tag soup including all versions of RSS, Atom 1.0 and 0.3, GRDDL and
microformats for HTML, XHTML and XML. The serializing syntaxes are RDF/XML
(regular, and abbreviated), N-Triples, RSS 1.0, Atom 1.0 and Adobe XMP.
@{
@mal
module rdf;

command import(url:str, map:bat[:str,:oid])(:bat[:oid,:oid],:bat[:oid,:oid],:bat[:oid,:oid])
address RDFimport 
comment "import a url with RDF, put the triples in the three new returned bats. 
         The map is used and extended to map URI/literals to oids";

command export( url:str, map:bat[:str,:oid], o:bat[:oid,:oid], p:bat[:oid,:oid], s:bat[:oid,:oid]) : void
address RDFexport
comment "export a triple table to some file url";

command importGraph( url:str, db:str, graph:str) : void
address RDFimportGraph
comment "import a graph in a named rdf db";

command exportGraph( url:str, db:str, graph:str, order:str, syntax:str) : void
address RDFexportGraph
comment "export a graph in a named rdf db";


@+ Implementation

@h
typedef enum
{
	BLANK,
	URI,
	PLAIN,
	INTEGER,
	DECIMAL,
	DOUBLE,
	BOOLEAN,
	FLOAT,
	STRING,
	DATETIME,
	UNKNOWN
} rdf_type;
@c
#include "mal_config.h"
#include "mal.h"
#include "mal_exception.h"
#include "rdf.h"

#include <gdk_bbp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <raptor.h>

#define rdf_export extern
#define RET_MAXLEN 2048

typedef struct {
	lng *cur;
	lng *lim;
	BAT *map;
	BAT *ob;
	BAT *pb;
	BAT *sb;
	BAT *tb;
	oid *o;
	oid *p;
	oid *s;
	chr *t;
	str *ret;
} triple_handler_vars;
//TODO
//static lng RDFestimate(str url) {
//	url=NULL;
//	return 8048;
//}



static chr RDFtypeToChar(rdf_type t)
{
	chr c;
	switch (t)
	{
	case BLANK:
		c = 'l';
		break;
	case URI:
		c = 'u';
		break;
	case PLAIN:
		c = 'p';
		break;
	case INTEGER:
		c = 'i';
		break;
	case DECIMAL:
		c = 'm';
		break;
	case DOUBLE:
		c = 'd';
		break;
	case BOOLEAN:
		c = 'b';
		break;
	case FLOAT:
		c = 'f';
		break;
	case STRING:
		c = 's';
		break;
	case DATETIME:
		c = 't';
		break;
	case UNKNOWN:
		c = '\0';
	}
	return c;
}

static rdf_type RDFparseXsdDataType(char *uri)
{
	rdf_type ret;
	if (uri == NULL)
		ret = PLAIN;
	else if (	strcmp(uri, "http://www.w3.org/2001/XMLSchema#int") ||
				strcmp(uri, "http://www.w3.org/2001/XMLSchema#integer"))
		ret = INTEGER;
	else if (strcmp(uri, "http://www.w3.org/2001/XMLSchema#decimal"))
		ret = DECIMAL;
	else if (strcmp(uri, "http://www.w3.org/2001/XMLSchema#double"))
		ret = DOUBLE;
	else if (strcmp(uri, "http://www.w3.org/2001/XMLSchema#boolean"))
		ret = BOOLEAN;
	else if (strcmp(uri, "http://www.w3.org/2001/XMLSchema#float"))
		ret = FLOAT;
	else if (strcmp(uri, "http://www.w3.org/2001/XMLSchema#string"))
		ret = STRING;
	else if (strcmp(uri, "http://www.w3.org/2001/XMLSchema#dateTime"))
		ret = DATETIME;
	else
		ret = UNKNOWN;
	
	raptor_free_memory(uri);
	return ret;
}

static str RDFimport_fail(BAT* map, BAT* ob, BAT* pb, BAT *sb, BAT *tb) {
    if (map) BBPunfix(map->batCacheid);
    if (ob) BBPreclaim(ob);
    if (pb) BBPreclaim(pb);
    if (sb) BBPreclaim(sb);
    if (tb) BBPreclaim(tb);
    throw(MAL, "RDFimport", "allocation failure"); 
}

void message_handler(void *user_data, raptor_locator *locator, const char *message)
{
	size_t length = 0;
	str *ret = (str *)user_data;
	str msg = *ret;
	if (locator->uri)
	{
		snprintf(msg, RET_MAXLEN, "In URI location \"%s\": ", raptor_uri_as_string(locator->uri));
		length = strlen(*ret);
		msg = *ret + length * (sizeof(char));
	}
	if (locator->line >=0 && length < RET_MAXLEN-1)
	{
		snprintf(msg, RET_MAXLEN-length, "at line %d: ", locator->line);
		length = strlen(*ret);
		msg = *ret + length * (sizeof(char));
	}
	if (locator->column >=0 && length < RET_MAXLEN-1)
	{
		snprintf(msg, RET_MAXLEN-length, "at column %d: ", locator->column);
		length = strlen(*ret);
		msg = *ret + length * (sizeof(char));
	}
	if (message && length < RET_MAXLEN-1)
	{
		snprintf(msg, RET_MAXLEN-length, "%s\n", message);
	}
}

@= RDFins
	HASHfnd_str(bun, mi, @1v);//bun is returned, is an index.
    if (bun == BUN_NONE)
    {
    	if (map->T->hash == NULL || BATcount(map) > 4 * map->T->hash->mask)
    	{
		HASHdestroy(map); /* keeps hash performance in check */
	        BAThash(BATmirror(map), 2*BATcount(map));
    	}
        bun = (BUN) map->batCount;
        if (!BUNappend(map,(ptr)@1v, TRUE)) {
            GDKerror("RDFimport: @1[" LLFMT "] = %s, BUNappend fails\n", cur, @1v);
            *(data->ret) = RDFimport_fail(map,ob,pb,sb,tb);
        }
   }
   /* s,p,o[cur] are set to the virtual oid which is bun s p and o are arrays of oid */
   @1[*cur] = (oid) bun;
@c
void
triples_handler(void* user_data, const raptor_statement* triple) 
{
	triple_handler_vars *data = (triple_handler_vars *)user_data;
	lng *cur = data->cur;
	lng *lim = data->lim;
	str ov, pv, sv;
	chr tv;
	BAT *map = data->map;
	BAT *sb = data->sb;
	BAT *pb = data->pb;
	BAT *ob = data->ob;
	BAT *tb = data->tb;
	oid *o = data->o;
	oid *p = data->p;
	oid *s = data->s;
	chr *t = data->t;
	str *ret = data->ret;
	BATiter mi = bat_iterator(BATmirror(map));
	BUN bun;
	*t = 'a';
	if (strlen(*ret)!=0)
		return;
	/* get the subject */
	if (triple->subject_type == RAPTOR_IDENTIFIER_TYPE_RESOURCE)
		sv = (str)raptor_uri_as_string((raptor_uri *)triple->subject);
	else if (triple->subject_type == RAPTOR_IDENTIFIER_TYPE_ANONYMOUS)
		sv = (str)triple->subject;
	else
	{
		*ret="Unexpected subject type";
		return;
	}
	
	/* get the predicate */
	if(triple->predicate_type == RAPTOR_IDENTIFIER_TYPE_RESOURCE)
	    pv = (str)raptor_uri_as_string((raptor_uri *)triple->predicate);
	else
	{
		*ret="Unexpected predicate type";
		return;
	}
	
	/* get the object */
	
	switch (triple->object_type)
	{
	unsigned char *datatype_uri;
	rdf_type literal_type;
	case RAPTOR_IDENTIFIER_TYPE_RESOURCE:
		ov = (str)raptor_uri_as_string((raptor_uri*)triple->object);
		tv = RDFtypeToChar(URI);
		break;
	case RAPTOR_IDENTIFIER_TYPE_ANONYMOUS:
		ov = (str)triple->subject;//TODO correct??
		tv = RDFtypeToChar(BLANK);
		break;
	case RAPTOR_IDENTIFIER_TYPE_LITERAL:
		datatype_uri = raptor_uri_to_string(triple->object_literal_datatype);
		literal_type = RDFparseXsdDataType((char *)datatype_uri);
		raptor_free_memory(datatype_uri);
		if (literal_type == UNKNOWN)
		{
			*ret = "Unexpected object literal type";
			return;
		}
		tv = RDFtypeToChar(literal_type);
		//TODO lang
		ov = (str)triple->object;
		break;
	default:
		*ret="Unexpected object type";
		return;
	}
	
	@:RDFins(o)@
	if (strlen(*ret)==0)
	{
	    @:RDFins(p)@
	    if (strlen(*ret)==0)
	    {
	    	@:RDFins(s)@
	    	if (strlen(*ret)==0)
	    	{
	    		t[*cur] = tv;
	    		
			    if (++(*cur) > *lim) {
			        *lim *= 2;
			        ob = BATextend(ob, *lim);
			        pb = BATextend(pb, *lim);
			        sb = BATextend(sb, *lim);
			        if (ob == NULL || pb == NULL || sb == NULL)
			            *ret = RDFimport_fail(map,ob,pb,sb,tb);
			        o = (oid *) Tloc(ob, BUNfirst(ob));
			        p = (oid *) Tloc(pb, BUNfirst(pb));
			        s = (oid *) Tloc(sb, BUNfirst(sb));
			    }
	    	}
	    }
	}
}

static str 
RDFimport_(BAT** S, BAT** P, BAT **O, BAT **T, str url, BAT *map) {
	raptor_parser *parser;
	raptor_uri *rdf_file;
	str ret;
	raptor_init();
	parser = raptor_new_parser("rdfxml");
	if (parser)
	{
		rdf_file = raptor_new_uri((unsigned char*)url);
		if (rdf_file)
		{
			BAT *ob, *pb, *sb, *tb;
			oid *o,*p,*s;
			chr *t;
			triple_handler_vars *data;
			lng *cur;
			lng *lim;
			*cur = 0;
			*lim = 8192;//TODO RDFestimate(url);
			
			ob = *O = BATnew(TYPE_void, TYPE_oid, *lim);
		    pb = *P = BATnew(TYPE_void, TYPE_oid, *lim);
		    sb = *S = BATnew(TYPE_void, TYPE_oid, *lim);
		    tb = *T = BATnew(TYPE_void, TYPE_chr, *lim);
		    
		    o = (oid *) Tloc(ob, BUNfirst(ob));
		    p = (oid *) Tloc(pb, BUNfirst(pb));
		    s = (oid *) Tloc(sb, BUNfirst(sb));
		    t = (chr *) Tloc(sb, BUNfirst(sb));
		    
		    if (map == NULL || ob == NULL || pb == NULL || sb == NULL || tb == NULL)
		        return RDFimport_fail(map,ob,pb,sb,tb);
		    
		    data = GDKmalloc(sizeof(triple_handler_vars));
		    if (data)
		    {
		    	char ret_array[RET_MAXLEN];
		    	str ret_ptr = ret_array;
		    	ret_array[0] = '\0';
		    	data->cur = cur;
		    	data->lim = lim;
		    	data->map =map;
		    	data->sb = sb;
		    	data->pb = pb;
		    	data->ob = ob;
		    	data->tb = tb;
		    	data->s = s;
		    	data->p = p;
		    	data->o = o;
		    	data->t = t;
		    	data->ret = &ret_ptr;
		    	raptor_set_statement_handler(parser, data, triples_handler);
				raptor_set_fatal_error_handler(parser, &ret_ptr, message_handler);
				raptor_set_error_handler(parser, &ret_ptr, message_handler);
				raptor_set_warning_handler(parser, &ret_ptr, message_handler);
				raptor_set_parser_strict(parser, TRUE);
			    
			    if (raptor_parse_file(parser, rdf_file, NULL) == 0)
			    {
			    	if(strlen(ret_ptr)==0)
				    {
			    		ret = MAL_SUCCEED;
					    BATseqbase(ob, 0);
					    BATseqbase(pb, 0);
					    BATseqbase(sb, 0);
					    BATsetcount(ob, *cur);
					    BATsetcount(pb, *cur);
					    BATsetcount(sb, *cur);
					    ob->tsorted = 0;
					    pb->tsorted = 0;
					    sb->tsorted = 0;
					    BATkey(BATmirror(ob), FALSE);
					    BATkey(BATmirror(sb), FALSE);
					    BATkey(BATmirror(pb), FALSE);
				    }
			    }
			    else
			    	ret = "RDF parsing error";
			    GDKfree(data);
		    }
		    else
		    	ret = "triple_handler_vars malloc failed";
		    raptor_free_uri(rdf_file);
		}
		else
			ret = "Unexistent url";
		raptor_free_parser(parser);
	}
	else
		ret = "Could not create a Redland parser";
    raptor_finish();
	if (ret != MAL_SUCCEED)
		throw(MAL, "rdf.import", ret);
	
	return MAL_SUCCEED;
}

rdf_export
str RDFimport(int* S, int* P, int* O, str *url, bat m)
{
    BAT *sb = NULL, *ob=NULL, *pb = NULL, *tb = NULL, *map = BATdescriptor(m);
    str ret;
    if (map) {
        RDFimport_(&sb, &pb, &ob, &tb, *url, map);
        if (ret == MAL_SUCCEED) {
            BBPkeepref(*O = ob->batCacheid);//changes physical reference to logical
            BBPkeepref(*P = pb->batCacheid);
            BBPkeepref(*S = sb->batCacheid);
        }
        BBPreleaseref(map->batCacheid);
    }
    return ret;
}

static str 
RDFexport_(str url, bat M, bat S, bat P, bat O, str syntax)
{
    str ret = MAL_SUCCEED;
    BAT *map = BATdescriptor(M);
    (void)url;
    if (map)
    {
        BAT *sb = BATdescriptor(S);
        if (sb)
        {
            BAT *pb = BATdescriptor(P);
            if (pb)
            {
                BAT *ob = BATdescriptor(O);
                if (ob)
                {
                	raptor_serializer* rdf_serializer;
                	const char *filename="/ufs/antonell/Desktop/output.rdf";
                	lng i, cnt = BATcount(ob);
                    oid *o = (oid *) Tloc(ob, BUNfirst(ob));
                    oid *p = (oid *) Tloc(pb, BUNfirst(pb));
                    oid *s = (oid *) Tloc(sb, BUNfirst(sb));
                    //var_t position in heap
                    var_t *off = (var_t *) Tloc(map, BUNfirst(map));
                    str base = (str) map->T->vheap->base;//heap first position
                    
                    raptor_init();
                    rdf_serializer = raptor_new_serializer(syntax);
                    
                    if (rdf_serializer)
                    {
                    	char ret_array[RET_MAXLEN];
    			    	str ret_ptr = ret_array;
    			    	ret_array[0] = '\0';
                    	raptor_serializer_set_error_handler(rdf_serializer, &ret_ptr, message_handler);
	                    raptor_serializer_set_warning_handler(rdf_serializer, &ret_ptr, message_handler);
	                    if (raptor_serialize_start_to_filename(rdf_serializer, filename) == 0)
	                    {
		                    for(i=0; i <cnt; i++)
		                    {
		                    	if (strlen(ret_ptr)==0)
		                    	{
		                    		raptor_statement *triple;
			                    	str ov = base + off[o[i]];
		    	                    str pv = base + off[p[i]];
		    	                    str sv = base + off[s[i]];
		    	                    //stream_printf(GDKout, "'%s' '%s' '%s' '%s'\n", ov, pv, sv, url);
									/* Make a triple with URI subject, URI predicate, literal object */
									triple=GDKmalloc(sizeof(raptor_statement));
									
									triple->subject=(void*)raptor_new_uri((const unsigned char*)sv);
									triple->subject_type=RAPTOR_IDENTIFIER_TYPE_RESOURCE;
									
									triple->predicate=(void*)raptor_new_uri((const unsigned char*)pv);
									triple->predicate_type=RAPTOR_IDENTIFIER_TYPE_RESOURCE;
									
									triple->object=ov;
									triple->object_type=RAPTOR_IDENTIFIER_TYPE_LITERAL;
									//triple->object_literal_language=(const unsigned char*)"en";
									triple->object_literal_language=NULL;
									triple->object_literal_datatype = NULL;
									/* Write the triple */
									if (raptor_serialize_statement(rdf_serializer, triple)!=0)
										ret="failed to serialize a statement";
									
									/* Delete the triple */
									raptor_free_uri((raptor_uri*)triple->subject);
									raptor_free_uri((raptor_uri*)triple->predicate);
									GDKfree(triple);
		                    	}
		                    }
		                    ret = MAL_SUCCEED;
		                    raptor_serialize_end(rdf_serializer);
	                    }
	                    else
	                    	ret = "raptor_serialize_start failed";
	                    raptor_free_serializer(rdf_serializer);
                    }
                    else
                    	ret = "raptor_new_serializer failed";
                    raptor_finish();
                    BBPreleaseref(ob->batCacheid);
                }
                else
                	ret = "Failed to obtain O bat";
                BBPreleaseref(pb->batCacheid);
            }
            else
            	ret = "Failed to obtain P bat";
            BBPreleaseref(sb->batCacheid);
        }
        else
        	ret = "Failed to obtain S bat";
        BBPreleaseref(map->batCacheid);
    }
    else
    	ret = "Failed to obtain MAP bat";
    return ret;
}

str 
RDFexport(str *url, bat M, bat S, bat P, bat O) {
    str ret = RDFexport_(*url, M, S, P, O, "dummy syntax");
    if (ret != MAL_SUCCEED)
        throw(MAL, "RDFexport", ret);
    return MAL_SUCCEED;
}

int CTrefine(BAT **ret, BAT *b, BAT *a);
BAT * BATmalleftfetchjoin(BAT *l, BAT *r);
static str
RDFsort(BAT *commit,
		BAT *S, BAT *sb, BAT *pb, BAT *ob,
		BAT **Spo, BAT **sPo, BAT **spO,
		str Spo_nme, str sPo_nme, str spO_nme, str db, str graph)
{
    BAT *SPO, *SP;
    str ret = "RDFsort: allocation failure";
    CTrefine(&SP, S, pb);
    if (SP) {
        CTrefine(&SPO, SP, ob);
        BBPreclaim(SP);
        if (SPO) {
            BAT *piv = BATmirror(BATmark(SPO, 0));
            BBPreclaim(SPO);
            if (piv) {
            	/*BATleftfetchjoin wants also a size_t estimate
            	 * BATmalleftfetchjoin not. Which has to be used?
            	 * TODO*/ 
                *Spo = BATleftfetchjoin(piv, sb, oid_nil);
                if (Spo) {
                    *sPo = BATleftfetchjoin(piv, pb, oid_nil);
                    if (sPo) {
                        *spO = BATleftfetchjoin(piv, ob, oid_nil);
                        if (spO) {
                            char Spo_buf[1024], sPo_buf[1024], spO_buf[1024];
                            snprintf(Spo_buf, 1024, "%s_%s_%s", db, graph, Spo_nme);
                            snprintf(sPo_buf, 1024, "%s_%s_%s", db, graph, sPo_nme);
                            snprintf(spO_buf, 1024, "%s_%s_%s", db, graph, spO_nme);
    
                            ret = "RDFsort: BATname failure";
                            if (BATname(*Spo, Spo_buf) == 0 &&
                                BATname(*sPo, sPo_buf) == 0 &&
                                BATname(*spO, spO_buf) == 0) 
                            {
                                ret = "RDFsort: BATmode failure";
                                if (BATmode(*Spo, PERSISTENT) &&
                                    BATmode(*sPo, PERSISTENT) &&
                                    BATmode(*spO, PERSISTENT))
                                {
                                    BBPreclaim(piv);
                                    BUNfastins(commit, &((*Spo)->batCacheid), Spo_buf);
                                    BUNfastins(commit, &((*sPo)->batCacheid), sPo_buf);
                                    BUNfastins(commit, &((*spO)->batCacheid), spO_buf);

                                    // physical reference, i.e. memory pressure
                                    BBPreleaseref((*Spo)->batCacheid);
                                    BBPreleaseref((*sPo)->batCacheid);
                                    BBPreleaseref((*spO)->batCacheid);
                                    return MAL_SUCCEED;
                                } else {
                                    BATmode(*Spo, TRANSIENT);
                                    BATmode(*sPo, TRANSIENT);
                                    BATmode(*spO, TRANSIENT);
                                }
                            }
                            BBPreclaim(*spO);
                        }
                        BBPreclaim(*sPo);
                    }
                    BBPreclaim(*Spo);
                }
                BBPreclaim(piv);
            }
        } 
    }	
    return ret;
}

@= sort
RDFsort(commit, sorted, @1,@2,@3,&@4,&@5,&@6,"@4","@5","@6",*db,*graph);
@c
str RDFimportGraph(int *d, str *url, str *db, str *graph)
{
    BAT *map = NULL, *sb = NULL, *ob=NULL,
    	*pb = NULL, *tb = NULL, *commit = BATnew(TYPE_bat, TYPE_str, 20);
    str ret = "RDFimportGraph failed to obtain bats";
    (void)d;
    if (commit) {
        char map_buf[1024];
        int mapIndex;
        snprintf(map_buf, 1024, "%s_%s_map", *db, *graph);
        mapIndex = BBPindex(map_buf);
        if (mapIndex) {
            map = BATdescriptor(mapIndex);
        } else {
            map = BATnew(TYPE_void, TYPE_str, 8192);//TODO fix constant
            if (map && (BATname(map, map_buf) == 0) && BATmode(map, PERSISTENT)) {
                /*
                 * inserts in commit a pointer to map in the left column
                 * and the map name (map_buf) in the right one
                 */
		BATseqbase(map, 0);
            	BUNfastins(commit, &(map->batCacheid), map_buf);
            } else if (map) {
                BBPreclaim(map);
                map = NULL;
            }
        }
    }
    if (map) {
        ret = RDFimport_(&sb, &pb, &ob, &tb, *url, map);
        if (ret == MAL_SUCCEED) {
            BAT *Spo = NULL, *sPo = NULL, *spO = NULL; 
            BAT *Sop = NULL, *sOp = NULL, *soP = NULL; 
            BAT *Pos = NULL, *pOs = NULL, *poS = NULL; 
            BAT *Pso = NULL, *pSo = NULL, *psO = NULL; 
            BAT *Ops = NULL, *oPs = NULL, *opS = NULL; 
            BAT *Osp = NULL, *oSp = NULL, *osP = NULL; 
            
            BATiter ci = bat_iterator(commit);
            BUN p, q;
            BAT *sorted = BATmirror(BATsort(BATmirror(sb)));

            ret = "RDFimportGraph: sorting failed";
            if (sorted) {
            	ret = @:sort(sb,pb,ob,Spo,sPo,spO)@
                if (ret  == MAL_SUCCEED) {
                	ret = @:sort(sb,ob,pb,Sop,sOp,soP)@
                    if (ret == MAL_SUCCEED) {
                        BBPreclaim(sorted);
                        sorted = BATmirror(BATsort(BATmirror(pb)));
                        if (sorted) {
                        	ret = @:sort(pb,ob,sb,Pos,pOs,poS)@
                            if (ret == MAL_SUCCEED) {
                            	ret = @:sort(pb,sb,ob,Pso,pSo,psO)@
                                if (ret == MAL_SUCCEED) {
                                    BBPreclaim(sorted);
                                    sorted = BATmirror(BATsort(BATmirror(ob)));
                                    if (sorted) {
                                    	ret = @:sort(ob,pb,sb,Ops,oPs,opS)@
                                        if (ret == MAL_SUCCEED) {
                                        	ret = @:sort(ob,sb,pb,Osp,oSp,osP)@
                                            if (ret == MAL_SUCCEED) {
                                                ret = MAL_SUCCEED;
                                                goto succeed;
                                            }
                                            BBPreclaim(Ops); BBPreclaim(oPs); BBPreclaim(opS);
                                        }
                                        BBPreclaim(sorted);
                                    } 
                                    BBPreclaim(psO); BBPreclaim(pSo); BBPreclaim(psO);
                                } 
                                BBPreclaim(Pos); BBPreclaim(pOs); BBPreclaim(poS);
                            } 
                        }
                        BBPreclaim(Sop); BBPreclaim(sOp); BBPreclaim(soP);
                    } 
                    BBPreclaim(Spo); BBPreclaim(sPo); BBPreclaim(spO);
                } 
            }
succeed:    if (ret == MAL_SUCCEED && TMsubcommit(commit)) {
                ret = "RDFimportGraph: commit failed";
            }
	    if (ret != MAL_SUCCEED) {
                /* we failed to create everything succesfully and commit. destroy all bats */
                BATloop(commit, p, q) { 
                    bat bid = *(bat*) BUNhead(ci,p);
                    BAT *b = BATdescriptor(bid);
                    if (b) {
                        BATmode(b, TRANSIENT);
                        BBPreleaseref(bid);
                    }
                }
            }
            BBPreleaseref(sb->batCacheid);// release physical ref
            BBPreleaseref(pb->batCacheid);
            BBPreleaseref(ob->batCacheid);
        }
        BBPreclaim(commit); // will release logical refs on all bats (if they are persistent, they will stay alive)  
    }
    if (ret != MAL_SUCCEED)
        throw(MAL, "RDFimportGraph", ret);
    return MAL_SUCCEED;
}

static str getBatNames(str db, str graph, char *s_buf,char *p_buf,char *o_buf, str order)
{
	str err = "order may be only one among \"spo\",\"sop\",\"pso\",\"pos\",\"osp\",\"ops\"";
	if (strlen(order)>3)
		return err;
	if (strcmp(order, "spo")==0)
	{
		snprintf(s_buf, 1024, "%s_%s_Spo", db, graph);
	    snprintf(p_buf, 1024, "%s_%s_sPo", db, graph);
	    snprintf(o_buf, 1024, "%s_%s_spO", db, graph);
	}
	else if (strcmp(order, "sop")==0)
	{
		snprintf(s_buf, 1024, "%s_%s_Sop", db, graph);
	    snprintf(o_buf, 1024, "%s_%s_sOp", db, graph);
	    snprintf(p_buf, 1024, "%s_%s_soP", db, graph);
	}
	else if (strcmp(order, "pos")==0)
	{
	    snprintf(p_buf, 1024, "%s_%s_Pos", db, graph);
	    snprintf(o_buf, 1024, "%s_%s_pOs", db, graph);
		snprintf(s_buf, 1024, "%s_%s_poS", db, graph);
	}
	else if (strcmp(order, "pso")==0)
	{
	    snprintf(p_buf, 1024, "%s_%s_Pso", db, graph);
		snprintf(s_buf, 1024, "%s_%s_pSo", db, graph);
	    snprintf(o_buf, 1024, "%s_%s_psO", db, graph);
	}
	else if (strcmp(order, "osp")==0)
	{
	    snprintf(o_buf, 1024, "%s_%s_Osp", db, graph);
		snprintf(s_buf, 1024, "%s_%s_oSp", db, graph);
	    snprintf(p_buf, 1024, "%s_%s_osP", db, graph);
	}
	else if (strcmp(order, "ops")==0)
	{
	    snprintf(o_buf, 1024, "%s_%s_Ops", db, graph);
	    snprintf(p_buf, 1024, "%s_%s_oPs", db, graph);
		snprintf(s_buf, 1024, "%s_%s_opS", db, graph);
	}
	else
		return err;
	return MAL_SUCCEED;
}

static str checkSyntax(str syntax)
{
	if (	//!strcmp(syntax, "atom") ||
			!strcmp(syntax, "ntriples") ||
			!strcmp(syntax, "rdfxml") ||
			!strcmp(syntax, "rdfxml-abbrev") ||
			!strcmp(syntax, "rdfxml-xmp") ||
			!strcmp(syntax, "turtle") ||
			//!strcmp(syntax, "rdfxml-xmp") ||
			!strcmp(syntax, "rss-1.0") ||
			!strcmp(syntax, "dot"))
	{
		return MAL_SUCCEED;
	}
	else
		return "syntax may be only one among \"atom\",\"ntriples\",\"rdfxml\",\"rdfxml-abbrev\",\"rdfxml-xmp\",\"turtle\",\"rdfxml-xmp\",\"rss-1.0\",\"dot\"";
}

str RDFexportGraph(int *d, str *url, str *db, str *graph, str *order, str *syntax)
{
    char m_buf[1024], o_buf[1024], p_buf[1024], s_buf[1024];
    bat map, ob, pb, sb;
    str ret;
    (void)d;
    ret = checkSyntax(*syntax);
    if (ret!= MAL_SUCCEED)
        throw(MAL, "RDFexportGraph", ret);
    ret = getBatNames(*db, *graph, s_buf, p_buf, o_buf, *order);
    if (ret!= MAL_SUCCEED)
    	throw(MAL, "RDFexportGraph", ret);
    snprintf(m_buf, 1024, "%s_%s_map", *db, *graph);
    map = BBPindex(m_buf);
    if (map) {
        sb = BBPindex(s_buf);
        if (sb) {
            pb = BBPindex(p_buf);
            if (pb) {
                ob = BBPindex(o_buf);
                if (ob) {
                    ret = RDFexport_(*url, map, sb, pb, ob, *syntax);
                }
                else
                	ret = "Failed to obtain O bat";
            }
            else
            	ret = "Failed to obtain P bat";
        }
        else
        	ret = "Failed to obtain S bat";
    }
    else
    	ret = "Failed to obtain map bat";
    if (ret != MAL_SUCCEED)
        throw(MAL, "RDFexportGraph", ret);
    return MAL_SUCCEED;
}
@}
