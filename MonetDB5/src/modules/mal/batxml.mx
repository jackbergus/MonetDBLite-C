@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f batxml
@a M.L. Kersten
@+ XML multiplexes
SQL/XML requires a handful of instructions.
The collection of routines provided here are map operations
for the atom xml primitives. 

In line with the batcalc module, we assume that
if two bat operands are provided that they are already
aligned on the head. Moreover, the head of the BATs
are limited to :oid.

The implementation is focussed on functionality. At a later stage
we may postpone string contstruction until it is really needed.
@{
@mal

command xml.xml(src:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLstr2xml
comment "Cast the string to an xml compliant string";

command xml.str(src:bat[:oid,:xml]):bat[:oid,:str]
address BATXMLxml2str
comment "Cast the string to an xml compliant string";

command xml.document(src:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLdocument
comment "Parse the string as a document";

command xml.content(src:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLcontent
comment "Parse the string as a document";

command xml.tag(nme:str,val:bat[:oid,:xml]):bat[:oid,:xml]
address BATXMLtag
comment "Routine to put element brackets around an XML value";

command xml.comment(val:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLcomment
comment "Construct an comment struction ";

command xml.parse(val:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLparse
comment "Parse the XML document or element string values ";

command xml.serialize(val:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLxml2str
comment "Serialize the XML object to a string";

command xml.text(val:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLxml2str
comment "Serialize the XQuery object to a string";

command xml.xquery(val:bat[:oid,:str],expr:str):bat[:oid,:xml]
address BATXMLxquery
comment "Execute the XQuery against the elements";

#todo
#command xml.table(val:bat[:oid,:str],expr:str):bat[:oid,:xml]
#address BATXMLquery
#comment "Execute the XQuery against the elements";

command xml.pi(operator:str, ret:bat[:oid,:xml]):bat[:oid,:xml]
address XMLpi
comment "Call the processing instruction";

command xml.attribute(name:str, val:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLattribute
comment "Construct an attribute value pair";

command xml.element(name:str, s:bat[:oid,:xml]) :bat[:oid,:xml]
address BATXMLtag
comment "The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified."; 

command xml.options(tag:str, option:str,left:bat[:oid,:xml]):bat[:oid,:xml]
address BATXMLoptions
comment "Create the components including NULL conversions";

command xml.element(name:str, ns:xml, attr:xml, s:bat[:oid,:xml]):bat[:oid,:xml]
address BATXMLelement
comment "The basic building block for XML elements are namespaces, attributes and a sequence of xml elements. The name space and the attributes may be left unspecified(=nilt).";

command xml.concat(left:bat[:oid,:xml],right:bat[:oid,:xml] ):bat[:oid,:xml]
address BATXMLconcat
comment "Concatenate the xml values";

pattern xml.forest(val:bat[:oid,:xml]...):bat[:oid,:xml]
address BATXMLforest
comment "Construct an element list";

command xml.agg(val:bat[:oid,:xml],grp:bat[:oid,:oid],e:bat[:oid,:any_1]):bat[:oid,:xml]
address BATXMLagg3
comment "Aggregate the XML values over grouping specified";

command xml.agg(val:bat[:oid,:xml],grp:bat[:oid,:oid]):bat[:oid,:xml]
address BATXMLagg
comment "Aggregate the XML values over grouping specified";

command xml.agg(val:bat[:oid,:xml]):bat[:oid,:xml]
address BATXMLgroup
comment "Aggregate the XML values over grouping specified";

command xml.root(val:bat[:oid,:xml], version:str, standalone:str):bat[:oid,:xml]
address BATXMLroot
comment "Contruct the root nodes";

command xml.isdocument(val:bat[:oid,:str]):bat[:oid,:bit]
address BATXMLisdocument
comment "Validate the string as a document";

module batcalc;
command xml(src:bat[:oid,:str]):bat[:oid,:xml] address BATXMLstr2xml;

@{
@include ../kernel/kprelude.mx

@+ Implementation
@h
#ifndef _BATXML_H_
#define _BATXML_H_
#include "mal_config.h"
#include <gdk.h>
#include "ctype.h"
#include <string.h>
#include "mal_interpreter.h"
#include "mal_function.h"
#include "xml.h"
#ifdef HAVE_LIBXML2
#include <libxml2.h>
#endif


#ifdef WIN32
#ifndef LIBBATXML
#define batxml_export extern __declspec(dllimport)
#else
#define batxml_export extern __declspec(dllexport)
#endif
#else
#define batxml_export extern
#endif

batxml_export str BATXMLxml2str(int *ret, int *bid);
batxml_export str BATXMLstr2xml(int *x, int *s);
batxml_export str BATXMLdocument(int *x, int *s);
batxml_export str BATXMLcontent(int *x, int *s);
batxml_export str BATXMLisdocument(int *x, int *s);
batxml_export str BATXMLtag(int *x, str *name, int *s);
batxml_export str BATXMLoptions(int *x, str *name, str *options, int *s);
batxml_export str BATXMLcomment(int *x, int *s);
batxml_export str BATXMLparse(int *x, int *s);
batxml_export str BATXMLxquery(int *x, int *s, str *expr);
batxml_export str BATXMLpi(int *x, str *oper, int *s);
batxml_export str BATXMLroot(int *ret, int *bid, str *version, str *standalone);
batxml_export str BATXMLattribute(int *ret, str *name, int *bid);
batxml_export str BATXMLelement(int *ret, str *name, str *ns, str *attr, int *bid);
batxml_export str BATXMLconcat(int *ret, int *bid, int *rid);
batxml_export str BATXMLforest(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
batxml_export str BATXMLagg(int *ret, int *bid, int *grp);
batxml_export str BATXMLagg3(int *ret, int *bid, int *grp, int *e);
batxml_export str BATXMLgroup(int *ret, int *bid);
#endif  /* _BATXML_H_ */
@c
#include "batxml.h"

#define prepareOperand(X,Y,Z) \
    if( (X= BATdescriptor(*Y)) == NULL ) \
        throw(MAL, "xml." Z, "Cannot access descriptor");

#define prepareResult(X,Y,T,Z) \
    X= BATnew(Y->htype,T,BATcount(Y)); \
    if( Y->htype== TYPE_void) \
        BATseqbase(X, Y->hseqbase); \
    if( X == NULL){ \
        BBPreleaseref(Y->batCacheid); \
        throw(MAL, "xml." Z, "no space available "); \
    } \
    X->hsorted=Y->hsorted; \
    X->tsorted=0;

#define finalizeResult(X,Y,Z) \
    if (!((Y)->batDirty&2)) (Y) = BATsetaccess((Y), BAT_READ); \
    *X = (Y)->batCacheid; \
    BBPkeepref(*(X));\
    BBPreleaseref(Z->batCacheid);

str
BATXMLxml2str(int *ret, int *bid)
{
	BAT *b;
	@:getBATdescriptor(bid,b,"xml.xml")@
	BBPkeepref(*ret= b->batCacheid);
	return MAL_SUCCEED;
}
@-
The core of the activity is xml2str, where the actual strings
are constructed.
To avoid repeatitive copying we make sure that the garbage
collector does not remove the xml intermediates. 
This way, we know that as long as the xml-variables are not
reused, the complete structure of the xml document(s) are available.
We merely have to collect the pieces.
[FOR LATER, FIRST GO FOR THE EASY IMPLEMENTATION]
@-
XML values are represented by strings already.
@c
static 
int
BATXMLcountEscape(char *s){
	int cnt=0;
	for(; s && *s; s++)
	switch(*s){
	case '&':
	case '>':
	case '<':
	case '"':
	case '\'':
		cnt++;
		break;
	default:
		if ((*s & 0xFF) < 0x20)
			cnt++;
	}
	return cnt;
}
str
BATXMLstr2xml(int *ret, int *bid)
{
	BAT *b,*bn;
	BUN p,q;
	str s,buf= GDKmalloc(BUFSIZ);
	int elm,len,size= BUFSIZ;
	BATiter bi;

	prepareOperand(b,bid,"str");
	prepareResult(bn,b,TYPE_xml,"str");
	bi = bat_iterator(b);
	BATloop(b,p,q){
		ptr h= BUNhead(bi,p);
		str t= (str) BUNtail(bi,p);
		if( (elm=BATXMLcountEscape(t)) ){
			if( (len=strlen(t)+6*elm+1) >= size){
				assert(0);
				buf= GDKrealloc(buf, len);
				size= len;
			}
			for(s=buf, *s=0; *t; t++)
			if (*t == '&'){
				*s++ = '&'; *s++ = 'a'; *s++ = 'm'; *s++ = 'p';
				*s++ = ';';
			} else if (*t == '<'){
				*s++ = '&'; *s++ = 'l'; *s++ = 't'; *s++ = ';';
			} else if (*t == '>'){
				*s++ = '&'; *s++ = 'g'; *s++ = 't'; *s++ = ';';
			} else if (*t == '"'){
				*s++ = '&'; *s++ = 'q'; *s++ = 'u'; *s++ = 'o';
				*s++ = 't'; *s++ = ';';
			} else if (*t == '\''){
				*s++ = '&'; *s++ = 'a'; *s++ = 'p'; *s++ = 'o';
				*s++ = 's'; *s++ = ';';
			} else if ((*t & 0xFF) < 0x20){
				s+=sprintf(s, "&#%d;", *t & 0xFF);
			} else {
				*s++= *t;
			}
			*s=0;
			bunfastins(bn,h,buf);
		} else {
			bunfastins(bn,h,t);
		}
	}
	GDKfree(buf);
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "batstr.xml", "bunins failed");
}
str
BATXMLdocument(int *ret, int *bid)
{
/* ue libxml for validity checkes */
	(void) ret;
	(void) bid;
	throw(MAL, "batstr.document", "Not yet implemented");
}

str
BATXMLcontent(int *ret, int *bid)
{
	/* ue libxml for validity checkes */
	(void) ret;
	(void) bid;
	throw(MAL, "batstr.content", "Not yet implemented");
}

str
BATXMLisdocument(int *x, int *s){
	/* ue libxml for validity checkes */
	(void) x;
	(void) s;
	throw(MAL,"xml.isdocument","Not yet implemented");
}

str
BATXMLtag(int *ret, str *name, int *bid)
{
	BAT *b,*bn;
	BUN p,q;
	str buf= GDKmalloc(BUFSIZ);
	int tlen= strlen(*name)+2, len, size= BUFSIZ;
	BATiter bi;

	prepareOperand(b,bid,"tag");
	prepareResult(bn,b,TYPE_xml,"tag");
	snprintf(buf,size,"<%s>",*name);

	bi = bat_iterator(b);
	BATloop(b,p,q){
		ptr h= BUNhead(bi,p);
		str t= (str) BUNtail(bi,p);
		if( (len=strlen(t) + 2*tlen+10) >= size){
			buf= GDKrealloc(buf,len);
			snprintf(buf,size,"<%s>",*name);
			size= len;
		}
		snprintf(buf+tlen,size,"%s</%s>",t,*name);
		bunfastins(bn,h,buf);
	}
	GDKfree(buf);
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "batstr.tag", "bunins failed");
}
@-
The standard supports specific mappings for
NULL values,i.e. {null,abscent,empty,nil,niloncontent)
in the context of an element and forest construction.
The standard should be studied in more detail, because
the syntax(rules) seem ambiguous.
It applies to all components of an element or their
concatenation.

For the time being, the variaton on XMLtag seems the
most reasonable interpretation.
@c
str
BATXMLoptions(int *ret, str *name, str *options, int *bid)
{
	BAT *b,*bn;
	BUN p,q;
	str buf= GDKmalloc(BUFSIZ);
	str val= GDKmalloc(BUFSIZ);
	int size= BUFSIZ, len=strlen(*name);
	BATiter bi;

	prepareOperand(b,bid,"options");
	prepareResult(bn,b,TYPE_xml,"options");

	if( strcmp(*options,"abscent")==0)
		buf[0]=0;
	else
	if( strcmp(*options,"empty")==0)
		snprintf(buf,size,"<%s></%s>",*name,*name);
	else
	if( strcmp(*options,"null")==0)
		snprintf(buf,size,"null");
	else
	if( strcmp(*options,"nil")==0)
		snprintf(buf,size,"nil");
	else
	/*if( strcmp(*options,"niloncontent")==0) */
		throw(MAL,"xml.options","Not yet implemented");

	snprintf(val,size,"<%s>",*name);
	bi = bat_iterator(b);
	BATloop(b,p,q){
		ptr h= BUNhead(bi,p);
		str t= (str) BUNtail(bi,p);
		if(strNil(t)){
			bunfastins(bn,h,buf);
		} else {
			if( (int)strlen(t)> size-2*len-6){
				size+= strlen(t);
				val= (char*) GDKrealloc(val, size+strlen(t));
			}
			snprintf(val+len+2,size-len,"%s</%s>",t,*name);
			bunfastins(bn,h, val);
		}
	}
	GDKfree(buf);
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "batxml.options", "bunins failed");
}

str
BATXMLcomment(int *ret, int *bid)
{
	BAT *b,*bn;
	BUN p,q;
	str buf= GDKmalloc(BUFSIZ);
	int len,size= BUFSIZ;
	BATiter bi;

	prepareOperand(b,bid,"comment");
	prepareResult(bn,b,TYPE_xml,"comment");
	bi = bat_iterator(b);
	BATloop(b,p,q){
		ptr h= BUNhead(bi,p);
		str t= (str) BUNtail(bi,p);
		if( (len=strlen(t)) >= size){
			buf= GDKrealloc(buf,len+20);
			size= len+20;
		}
		snprintf(buf,size,"<!-- %s -->",t);
		bunfastins(bn,h,buf);
	}
	GDKfree(buf);
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "batstr.comment", "bunins failed");
}

str
BATXMLparse(int *ret, int *bid)
{
	BAT *b,*bn;
	BUN p,q;

	prepareOperand(b,bid,"parse");
	prepareResult(bn,b,TYPE_xml,"parse");
	BATloop(b,p,q){
	}
	finalizeResult(ret,bn,b);
	throw(MAL,"xml.parse","Not yet implemented");
}

str
BATXMLpi(int *ret, str *operator, int *bid)
{
	BAT *b,*bn;
	BUN p,q;

	(void) operator;
	prepareOperand(b,bid,"pi");
	prepareResult(bn,b,TYPE_xml,"pi");
	BATloop(b,p,q){
	}
	finalizeResult(ret,bn,b);
	throw(MAL,"xml.pi","Not yet implemented");
}

str
BATXMLroot(int *ret, int *bid, str *version, str *standalone)
{
	BAT *b,*bn;
	BUN p,q;
	str buf= GDKmalloc(BUFSIZ);
	int len,size= BUFSIZ;
	BATiter bi;

	prepareOperand(b,bid,"root");
	prepareResult(bn,b,TYPE_xml,"root");

	len= strlen(*version)+strlen(*standalone)+
			strlen("<? version=\"\" standalone=\"\"?>");
	bi = bat_iterator(b);
	BATloop(b,p,q){
		ptr h= BUNhead(bi,p);
		str t= (str) BUNtail(bi,p);
		if( (len=strlen(t)) >= size){
			buf= GDKrealloc(buf,len+20);
			size= len+20;
		}
		snprintf(buf,size,"<? version=\"%s\" stanalone=\"%s\"?>%s",
			*version,*standalone,t);
		bunfastins(bn,h,buf);
	}
	GDKfree(buf);
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "batstr.root", "bunins failed");
}

str
BATXMLattribute(int *ret, str *name, int *bid)
{
	BAT *b,*bn;
	BUN p,q;
	str buf= GDKmalloc(BUFSIZ);
	int len,size= BUFSIZ;
	BATiter bi;

	prepareOperand(b,bid,"attribute");
	prepareResult(bn,b,TYPE_xml,"attribute");
	bi = bat_iterator(b);
	BATloop(b,p,q){
		ptr h= BUNhead(bi,p);
		str t= (str) BUNtail(bi,p);
		if( (len=strlen(t)) >= size){
			buf= GDKrealloc(buf,len+20);
			size= len+20;
		}
		snprintf(buf,size," %s=\"%s\"",*name,t);
		bunfastins(bn,h,buf);
	}
	GDKfree(buf);
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "xml.attribute", "bunins failed");
}

str
BATXMLelement(int *ret, str *name, str *namespace, str *attributes, int *bid)
{
	BAT *b,*bn;
	BUN p,q;
	str buf= GDKmalloc(BUFSIZ);
	int offset,len,size= BUFSIZ;
	BATiter bi;

	(void) namespace;
	/* collect the admin for the xml elements */
	b=  BATdescriptor( *bid);

/* check for errors */
	if( b== NULL)
		throw(MAL,"xml.element","Can not access BAT");

	prepareResult(bn,b,TYPE_xml,"element");

	bi = bat_iterator(b);
	BATloop(b,p,q){
		str t= (str) BUNtail(bi,p);
		oid *h= (oid*) BUNhead(bi,p);
		int elm;

		/* include attributes */
		if( attributes) {

			if( (len=strlen(t)) >= size){
				buf= GDKrealloc(buf,len+strlen(*name)+BUFSIZ);
				size= len+strlen(*name)+BUFSIZ;
			}
			snprintf(buf,size,"<%s %s>",*name,*attributes);
		} else 
			snprintf(buf,size,"<%s>",*name);
		elm= offset= strlen(buf);

		/* fetch the elements */

		if( (len=strlen(t)+elm) >= size-offset){
			buf= GDKrealloc(buf,size+2*elm);
			size= len+2*elm;
		}
		snprintf(buf+offset,size-offset,"%s",t);
		offset+= strlen(buf+offset);
	
		snprintf(buf + offset,size-offset, "</%s>\n",*name);
		bunfastins(bn,h,buf);
	}
	GDKfree(buf);
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "xml.element", "bunins failed");
}

str
BATXMLforest(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret= (int*) getArgReference(stk,pci,0);
	BAT *bn;
	BATiter *bi;
	BUN *p,*q;
	str buf= GDKmalloc(BUFSIZ);
	int i,offset,len,size= BUFSIZ;

	(void)mb;
	bi= alloca(sizeof(BATiter) * pci->argc);
	p= alloca(sizeof(BUN) * pci->argc);
	q= alloca(sizeof(BUN) * pci->argc);
	
	/* collect the admin for the xml elements */
	for(i=pci->retc; i<pci->argc; i++){
		if ( (bi[i].b = BATdescriptor( *(int*)getArgReference(stk,pci,i)))==NULL)
			break;
		p[i]= BUNfirst(bi[i].b);
		q[i]= BUNlast(bi[i].b);
	}
	/* check for errors */
	if( i!= pci->argc) {
		for( i--; i>=pci->retc; i--)
			if (bi[i].b)
				BBPunfix(bi[i].b->batCacheid);
		throw(MAL,"xml.forest","Can not access BAT");
	}

	prepareResult(bn,bi[pci->retc].b,TYPE_xml,"attribute");

	while(p[pci->retc] < q[pci->retc]){
		str t;
		oid *h;

		/* fetch the elements */
		h= (oid*) BUNhead(bi[pci->retc],p[pci->retc]);
		offset=0;
		for(i= pci->retc; i< pci->argc; i++)
		{
			t= (str) BUNtail(bi[i],p[i]);

			if( (len=strlen(t)) >= size-offset){
				buf= GDKrealloc(buf,size+len);
				size= size+len;
			}
			snprintf(buf+offset,size-offset,"%s",t);
			offset+= strlen(buf+offset);
		}
		bunfastins(bn,h,buf);

		for(i= pci->retc; i< pci->argc; i++)
			if (bi[i].b)
				p[i]++;
	}
	GDKfree(buf);
	finalizeResult(ret,bn,bi[pci->retc].b);
	return MAL_SUCCEED;
bunins_failed:
	for(i= pci->retc; i< pci->argc; i++)
		if (bi[i].b)
			BBPreleaseref(bi[i].b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "xml.forest", "bunins failed");
}

str
BATXMLconcat(int *ret, int *bid, int *rid)
{
	BAT *b,*r=0, *bn;
	BUN p,q, rp = 0;
	str buf= GDKmalloc(BUFSIZ);
	int len,size= BUFSIZ;
	BATiter bi, ri;

	if( *rid && (r=  BATdescriptor( *rid)) ){
		rp= BUNfirst(r);
	}
	if(r==0)
		throw(MAL,"xml.concat","Can not access BAT");

	/* collect the admin for the xml elements */
	if ( (b=  BATdescriptor( *bid)) ){
		p= BUNfirst(b);
		q= BUNlast(b);
	}
	if( b== NULL){
		if(r) BBPunfix(r->batCacheid);
		throw(MAL,"xml.concat","Can not access BAT");
	}

	prepareResult(bn,b,TYPE_xml,"concat");

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	while(p < q){
		str t= (str) BUNtail(bi,p);
		oid *h= (oid*) BUNhead(bi,p);
		str v= (str) BUNtail(ri,rp);
		len= strlen(t)+strlen(v)+2;

		if( len >= size){
			if(buf) GDKfree(buf);
			buf= GDKmalloc(len);
			size= len;
		}
		snprintf(buf,size,"%s%s",t,v);
		bunfastins(bn,h,buf);
		rp ++;
		p ++;
	}
	GDKfree(buf);
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(r->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "xml.concat", "bunins failed");
}

str
BATXMLagg3(int *ret, int *bid,int *grp, int *ext)
{
	BAT *j, *r, *g, *b, *bn, *e;
	BUN p,q;
	oid gid = 0,o=0;
	int first= 1;
	str t;
	str buf= GDKmalloc(BUFSIZ);
	int len, size=BUFSIZ,offset;
	BATiter ri;
	
	@:getBATdescriptor(ext,e,"xml.agg")@
	@:getBATdescriptor(grp,g,"xml.agg",BBPunfix(e->batCacheid))@
	@:getBATdescriptor(bid,b,"xml.agg",BBPunfix(e->batCacheid);BBPunfix(g->batCacheid))@
	
	bn= BATnew(TYPE_oid, b->ttype,BATcount(e));
	if( bn== NULL){
		BBPunfix(b->batCacheid);
		BBPunfix(g->batCacheid);
		BBPunfix(e->batCacheid);
		throw(MAL,"xml.agg","Could not create BAT");
	}

	/* this will not work as it will corrupt the order of the column, ie
	   the order in which the data will be generated */
	j= BATjoin(BATmirror(g),b,oid_nil);
	r= BATsort(j);

	/* now we can perform a simple scan and emit the group*/

	buf[0]=0; 
	offset=0;
	first=1;
	ri = bat_iterator(r);
	BATloop(r,p,q){
		o= *(oid*) BUNhead(ri,p);
		t= (str) BUNtail(ri,p);

		if( gid != o && first==0){
			/* flush */
			bunfastins(bn,&gid,buf);
			buf[0]=0;
			offset =0;
		}
		gid=o;
		first=0;
		len= strlen(t)+1;
		if( len >= size-offset){
			if(buf) GDKfree(buf);
			buf= GDKrealloc(buf,size+len);
			size= size+len;
		}
		snprintf(buf+offset,size-offset,"%s",t);
		offset+= len-1;
	}
	/* end the leftover element */
	if( first ==0)
		bunfastins(bn,&gid,buf);

	BBPunfix(r->batCacheid);
	BBPunfix(j->batCacheid);
	GDKfree(buf);
	BBPunfix(e->batCacheid);
	BBPunfix(g->batCacheid);
	BBPunfix(b->batCacheid);
	BBPkeepref(*ret=bn->batCacheid);
	return MAL_SUCCEED;
bunins_failed:
	BBPunfix(e->batCacheid);
	BBPunfix(g->batCacheid);
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "xml.agg", "bunins failed");
}

str
BATXMLagg(int *ret, int *bid,int *grp)
{
	BAT *j, *r, *g, *b, *bn;
	BUN p,q;
	oid gid = 0,o=0;
	int first= 1;
	str t;
	str buf= GDKmalloc(BUFSIZ);
	int len, size=BUFSIZ,offset;
	BATiter ri;
	
	@:getBATdescriptor(grp,g,"xml.agg")@
	@:getBATdescriptor(bid,b,"xml.agg",BBPunfix(g->batCacheid))@
	
	bn= BATnew(g->htype, b->ttype,BATcount(g));
	if( bn== NULL){
		BBPunfix(b->batCacheid);
		BBPunfix(g->batCacheid);
		throw(MAL,"xml.agg","Could not create BAT");
	}

	j= BATjoin(BATmirror(g),b,oid_nil);
	r= BATsort(j);

	/* now we can perform a simple scan and emit the group*/

	buf[0]=0; 
	offset=0;
	first=1;
	ri = bat_iterator(r);
	BATloop(r,p,q){
		o= *(oid*) BUNhead(ri,p);
		t= (str) BUNtail(ri,p);

		if( gid != o && first==0){
			/* flush */
			bunfastins(bn,&gid,buf);
			buf[0]=0;
			offset =0;
		}
		gid=o;
		first=0;
		len= strlen(t)+1;
		if( len >= size-offset){
			if(buf) GDKfree(buf);
			buf= GDKrealloc(buf,size+len);
			size= size+len;
		}
		snprintf(buf+offset,size-offset,"%s",t);
		offset+= len-1;
	}
	/* end the leftover element */
	if( first ==0)
		bunfastins(bn,&gid,buf);

	BBPunfix(r->batCacheid);
	BBPunfix(j->batCacheid);
	GDKfree(buf);
	BBPkeepref(*ret=bn->batCacheid);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(g->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	GDKfree(buf);
	throw(MAL, "xml.agg", "bunins failed");
}

str
BATXMLgroup(int *ret, int *bid)
{
	BAT *b, *g;
	str msg= MAL_SUCCEED;
	oid o= 0;
	BUN p,q;
	BATiter bi;

	@:getBATdescriptor(bid,b,"xml.group")@

	g= BATnew(BAThtype(b),TYPE_oid,BATcount(b));
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr v = BUNhead(bi,p);
		bunfastins(g,v, &o);
	}
	msg= BATXMLagg(ret,bid,&g->batCacheid);
	bunins_failed:
	BBPunfix(g->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
str
BATXMLxquery(int *ret, int *bid, str *expr)
{
	(void) ret;
	(void) bid;
	(void) expr;
	/* use external library to solve this */
	throw(MAL,"xml.xquery","Not yet implemented");
}

@}

@sql
CREATE AGGREGATE "xmlagg"( x xml ) RETURNS xml external name xml.agg;
