@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f tablet
@a Niels Nes, Martin Kersten
@d 29/07/2003
@* The tablet module

A database cannot live without ASCII tabular print/dump/load operations. 
It is needed to produce reasonable listings, to exchange answers
with a client, and to keep a database version for backup.
This is precisely where the tablet module comes in handy.
[This module should replace all other table dump/load functions]

We start with a simple example to illustrate the plain ASCII
representation and the features provided. Consider the
relational table answer(name:str, age:int, sex:chr, address:str, dob:date)
obtained by calling the routine tablet.page(B1,...,Bn) where the Bi represent
BATS.
@verbatim
[ "John Doe",		25,	'M',	"Parklane 5",	"25-12-1978" ]
[ "Maril Streep",	23,	'F',	"Church 5",	"12-07-1980" ]
[ "Mr. Smith",		53,	'M',	"Church 1",	"03-01-1950" ]
@end verbatim
@-
The lines contain the representation of a list in Monet tuple format.
This format has been chosen to ease parsing by any front-end. The scalar values
are represented according to their type. For visual display, the columns
are aligned by placing enough tabs between columns based on sampling the
underlying bat to determine a maximal column width.
(Note,actual commas are superfluous)

The arguments to the command can be any sequence of BATs, but which are
assumed to be aligned. That is, they all should have the same number of
tuples and the j-th tuple tail of Bi is printed along-side the j-th tuple
tail of Bi+1. 

Printing both columns of a single bat is handled by tablet as a
print of two columns. This slight inconvenience is catch-ed by
the io.print(b) command, which resolves most back-ward compatibility issues.
@-
In many cases this output would suffice for communication with a front-end.
However, for visual inspection the user should be provided also some meta
information derived from the database schema. Likewise, when reading a
table this information is needed to prepare a first approximation of
the schema namings. This information is produced by the command
tablet.header(B1,...,Bn), which lists the column role name.
If no role name is give, a default is generated based on the
BAT name, e.g. B1_tail.

@verbatim
#------------------------------------------------------#
# name,           age, sex, address,       dob         #
#------------------------------------------------------#
[ "John Doe",      25, 'M', "Parklane 5", "25-12-1978" ]
[ "Maril Streep",  23, 'F', "Church 5",   "12-07-1980" ]
[ "Mr. Smith",     53, 'M', "Church 1",   "03-01-1950" ]
@end verbatim
@-

The command tablet.display(B1,...,Bn) is a contraction of tablet.header();
tablet.page().  

In many cases the tablet produced may be too long to consume completely
by the front end. In that case, the user needs page size control, much
like the more/less utilities under Linux. However, no guarantee
is given for arbitrarily going back and forth. 
[but works as long as we materialize results first ]
A portion of the tablet can be printed by identifying the rows of interest as
the first parameter(s) in the page command, e.g.


@verbatim
tablet.page(nil,10,B1,...,Bn);	#prints first 10 rows
tablet.page(10,20,B1,...,Bn);	#prints next 10 rows
tablet.page(100,nil,B1,...,Bn);	#starts printing at tuple 100 until end
@end verbatim

A paging system also provides the commands tablet.firstPage(), 
tablet.nextPage(), tablet.prevPage(), and tablet.lastPage() using 
a user controlled tablet size tablet.setPagesize(L). 

The tablet display operations use a client (thread) specific formatting
structure. This structure is initialized using either 
tablet.setFormat(B1,...,Bn) or tablet.setFormat(S1,...,Sn) (Bi is a BAT, Si a scalar).
Subsequently, some additional properties can be set/modified, 
column width and brackets. 
After printing/paging the BAT resources should be freed using
the command tablet.finish().

Any access outside the page-range leads to removal of the report structure.
Subsequent access will generate an error.
To illustrate, the following code fragment would be generated by
the SQL compiler

@verbatim
	tablet.setFormat(B1,B2);
	tablet.setDelimiters("|","\t","|\n");
	tablet.setColumnName(0, "Name");
	tablet.setColumnNull(0, "?");
	tablet.setColumnWidth(0, 15);
	tablet.setColumnBracket(0, " ", ",");
	tablet.setColumnName(1, "Age");
	tablet.setColumnNull(1, "-");
	tablet.setColumnDecimal(1, 9,2);
	tablet.SQLtitle("Query: select * from tables");
	tablet.page();
	tablet.SQLfooter(count(B1),cpuTicks);
@end verbatim

@-
This table is printed with tab separator(s) between elements
and the bar (|) to mark begin and end of the string.
The column parameters give a new title, 
a null replacement value, and the preferred column width.
Each column value is optionally surrounded by brackets.
Note, scale and precision can be applied to integer values only.
A negative scale leads to a right adjusted value.

The title and footer operations are SQL specific routines to
decorate the output.

Another example involves printing a two column table in XML format.
[Alternative, tablet.XMLformat(B1,B2) is a shorthand for the following:]
@T
@verbatim
	tablet.setFormat(B1,B2);
	tablet.setTableBracket("<rowset>","</rowset>");
	tablet.setRowBracket("<row>","</row>");
	tablet.setColumnBracket(0, "<name>", "</name>");
	tablet.setColumnBracket(1, "<age>", "</age>");
	tablet.page();
@end verbatim
@+ Tablet properties
More detailed header information can be obtained with the command 
tablet.setProperties(S), where S
is a comma separated list of properties of interest,
followed by the tablet.header().
The properties to choose from are: bat, name, type, width, 
sorted, dense, key, base, min, max, card,....

@verbatim
#--------------------------------------#
# B1,   B2,     B3,     B4,     B5     # BAT
# str,  int,    chr,    str,    date   # type
# true, false,  false,  false,  false  # sorted
# true, true,   false,  false,  false  # key
# ,     23,     'F',    ,              # min
# ,     53,     'M',	,              # max
# 4,     4,     4,      4,      4      # count
# 4,i    3,     2,      2,      3      # card
# name,	age,    sex,   address, dob    # name
#--------------------------------------#
@end verbatim

@+ Scalar tablets
In line with the 10-year experience of Monet, printing scalar values
follow the tuple layout structure. This means that the header() 
command is also applicable.
For example, the sequence "i:=0.2;v:=sin(i); tablet.display(i,v);"
produces the answer:
@verbatim
#----------------#
# i,	v	 #
#----------------#
[ 0.2,	0.198669 ]
#----------------#
@end verbatim
@-

All other formatted printing should be done with the printf() operations
contained in the module io.

@+ Tablet dump/restore

Dump and restore operations are abstractions over sequence of tablet commands.
The command tablet.dump(stream,B1,...,Bn) is a contraction of the sequence
tablet.setStream(stream);
tablet.setProperties("name,type,dense,sorted,key,min,max");
tablet.header(B1,..,Bn); tablet.page(B1,..,Bn). 
The result can be read by tablet.load(stream,B1,..,Bn) command. 
If loading is successful, e.g. no parsing
errors occurred, the tuples are appended to the corresponding BATs.

@+ Front-end extension
A general bulk loading of foreign tables, e.g. CSV-files and fixed position 
records, is not provided. Instead, we extend the list upon need. 
Currently, the routines tablet.SQLload(stream,delim1,delim2, B1,..,Bn) 
reads the files using the Oracle(?) storage. The counterpart for
dumping is tablet.SQLdump(stream,delim1,delim2);

@+ The commands

The load operation is for bulk loading a table, each column will be loaded
into its own bat. The arguments are void-aligned bats describing the
input, ie the name of the column, the tuple separator and the type.  
The nr argument can be -1 (The input (datafile) is read until the end)
or a maximum.

The dump operation is for dumping a set of bats, which are aligned.
Again with void-aligned arguments, with name (currently not used), 
tuple separator (the last is the record separator) and bat to be dumped. 
With the nr argument the dump can be limited (-1 for unlimited).

The output operation is for ordered output. A bat (possibly form the collection)
gives the order. For each element in the order bat the values in the bats are
searched, if all are found they are output in the datafile, with the given
separators.

The scripts from the LOAD part are all there too for backward compatibility
with the old Mload format files. 

The load_format loads the format file, since the old format file was
in a table format it can be loaded with the load command. 

The result from load_format can be used with load_data to load the data
into a set of new bats.

These bats can be made persistent with the make_persistent script or
merge with existing bats with the merge_data script.

The dump_format scripts dump a format file for a given set of 
to be dumped bats. These bats can be dumped with dump_data.
@mal
# the major tablet shuffling routines
module tablet;

command load( names:bat[:void,:str], seps:bat[:void,:str], 
		types:bat[:void,:str], datafile:str, nr:int ) :bat[:str,:bat] 
address CMDtablet_load
comment "Load a bat using specific format.";

command input( names:bat[:void,:str], seps:bat[:void,:str], 
		types:bat[:void,:str], s:stream, nr:int ) :bat[:str,:bat] 
address CMDtablet_input
comment "Load a bat using specific format.";

command dump(names:bat[:void,:str], seps:bat[:void,:str], 
		bats:bat[:void,:bat], datafile:str, nr:int) :void 
address CMDtablet_dump 
comment "Dump the bat in ASCII format";

command output(order:bat[:any_1,:any_2], seps:bat[:void,:str], 
		bats:bat[:void,:bat], s:stream) :void 
address CMDtablet_output 
comment "Send the bat to an output stream.";

pattern display(v:any...):int 
address TABdisplayRow
comment "Display a formatted row";
pattern display(v:bat[:any_1,:any]...):int 
address TABdisplayTable
comment "Display a formatted table";

pattern page(b:bat[:any,:any]...):int 
address TABpage
comment "Display all pages at once without header";
pattern header(b:any...):int 
address TABheader
comment "Display the minimal header for the table";
command setProperties(prop:str):int 
address TABsetProperties
comment "Define the set of properties";
pattern dump(s:stream,b:bat[:any,:any]...):int 
address TABdump
comment "Print all pages with header to a stream";

pattern setFormat(b:any...):void 
address TABsetFormat
comment "Initialize a new reporting structure.";
command finish():void 
address TABfinishReport
comment "Free the storage space of the report descriptor";
command setStream(s:stream):void 
address TABsetStream
comment "Redirect the output to a stream.";
command setPivot(b:bat[:void,:oid]) :void
address TABsetPivot
comment "The pivot bat identifies the tuples of interest. The only requirement 
        is that all keys mentioned in the pivot tail exist in all BAT parameters 
        of the print comment. The pivot also provides control over the order 
        in which the tuples are produced.";
command setDelimiter(sep:str):void 
address TABsetDelimiter
comment "Set the column separator.";
command setTableBracket(lbrk:str,rbrk:str)
address TABsetTableBracket
comment "Format the brackets around a table";
command setRowBracket(lbrk:str,rbrk:str)
address TABsetRowBracket
comment "Format the brackets around a row";

# Set the column properties 
pattern setColumn(idx:int, v:any_1)
address TABsetColumn
comment "Bind i-th output column to a variable";
command setColumnName(idx:int, nme:str)
address TABsetColumnName
comment "Set the display name for a given column";
command setColumnBracket(idx:int,lbrk:str,rbrk:str)
address TABsetColumnBracket
comment "Format the brackets around a field";
command setColumnNull(idx:int, fmt:str)
address TABsetColumnNull
comment "Set the display format for a null value for a given column";
command setColumnWidth(idx:int, maxwidth:int)
address TABsetColumnWidth
comment "Set the maximal display witdh for a given column. All values exceeding 
	the length are simple shortened without any notice.";
command setColumnPosition(idx:int,f:int,i:int)
address TABsetColumnPosition
comment "Set the character position to use for this field when loading according to 
	fixed (punch-card) layout.";
command setColumnDecimal(idx:int,s:int,p:int)
address TABsetColumnDecimal
comment "Set the scale and precision for numeric values";

command firstPage():void 
address TABfirstPage
comment "Produce the first page of output";
command lastPage():void 
address TABlastPage
comment "Produce the last page of output";
command nextPage():void 
address TABnextPage
comment "Produce the next page of output";
command prevPage():void 
address TABprevPage
comment "Produce the prev page of output";
command getPageCnt():void 
address TABgetPageCnt
comment "Return the size in number of pages";
command getPage(i:int):void 
address TABgetPage
comment "Produce the i-th page of output";
@-
@{
@include prelude.mx
@+ Implementation
The implementation needs the stream abstraction, which also provides
primitives to compress/decompress files on the fly.
The file can plain ASCII, gzipped or bzipped, decided by the extention 
(none, gz or bz2). The default is plain ASCII, which is formatted to
pre presented on the screen directly.

@h
#ifndef _TABLET_IO2_H_
#define _TABLET_IO2_H_

#include <gdk.h>
#include "streams.h"
#include "mal_exception.h"
#include "mal_client.h"
#include "mal_interpreter.h"

typedef ptr *(*frStr) (void *extra, int type, char *s);
typedef int (*toStr) (void *extra, char **buf, int *len, int type, ptr a);

typedef struct Column_t {
	char *batname;
	char *name;		/* column title */
	char *sep;
	int seplen;
	char *type;
	int adt;		/* type index */
	BAT *bval;		/* set to NULL when scalar is meant */
	ptr pval;
	int base;		/* of first tuple */
	unsigned int tabs;	/* field size in tab positions */
	str lbrk, rbrk;		/* column brackets */
	str nullstr;		/* null representation */
	int quoted;		/* escape charaters */
	unsigned int width;	/* actual column width */
	unsigned int maxwidth;	/* permissible width */
	int fieldstart;		/* Fixed character field load positions */
	int fieldwidth;
	int scale, precision;
	toStr tostr;
	frStr frstr;
	void *extra;
} Column;

@-
All table printing is based on building a report structure first.
This table structure is private to a client, which made us to
keep it in an ADT.
@h

typedef struct Table_t {
	int signature;
	char *sep;		/* default separator */
	str ttopbrk, tbotbrk;	/* table brackets */
	str rlbrk, rrbrk;	/* row brackets */
	str properties;		/* of header to display */
	str title, footer;	/* alternatives */
	size_t offset;
	size_t nr;		/* allocated space for table loads */
	size_t pageLimit;
	size_t firstrow, lastrow;	/* last window to print */
	size_t nr_attrs;	/* attributes found sofar */
	size_t max_attrs;
	Column *format;		/* remove later */
	stream *fd;
	BAT *pivot;
	unsigned int rowwidth;		/* sum of columns used for mallocs */
	Column columns[1];
} Tablet;

#ifdef _MSC_VER
#ifndef LIBTABLET
#define tablet_export extern __declspec(dllimport)
#else
#define tablet_export extern __declspec(dllexport)
#endif
#else
#define tablet_export extern
#endif

tablet_export BAT *TABLETload(BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr);
tablet_export BAT *TABLETinput(BAT *names, BAT *seps, BAT *types, bstream *s, size_t nr);
tablet_export size_t TABLEToutput(BAT *order, BAT *seps, BAT *bats, stream *s);
tablet_export void TABLETdump(BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr);

/* The low level routines are primarilly used by the SQL front-end.*/
tablet_export int TABLETcreate_bats(Tablet * as);
tablet_export size_t TABLETassign_BATs(Tablet * as, BAT *bats);
tablet_export int TABLETload_file(Tablet * as, bstream *b);
tablet_export BAT *TABLETcollect_bats(Tablet * as);
tablet_export void TABLETdestroy_format(Tablet * as);
tablet_export void TABLEToutput_file(Tablet * as, BAT *order, stream *s);

tablet_export ptr *TABLETadt_frStr(void *extra, int type, char *s);
tablet_export int TABLETadt_toStr(void *extra, char **buf, int *len, int type, ptr a);

#endif
@c
#include "tablet.h"
#include "algebra.h"

#include <string.h>
#include <ctype.h>

#define CLEAR(X) if(X) {GDKfree(X);X = NULL;}
#define isScalar(C)  C->adt != TYPE_bat

mal_export str TABsetFormat(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str TABheader(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str TABdisplayTable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str TABdisplayRow(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str TABpage(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str TABsetProperties(int *ret, str *prop);
mal_export str TABdump(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str TABfinishReport(int *ret);
mal_export str TABsetStream(int *ret, stream **s);
mal_export str TABsetPivot(int *ret, int *bid);
mal_export str TABsetDelimiter(int *ret, str *sep);
mal_export str TABsetColumn(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str TABsetColumnName(int *ret, int *idx, str *s);
mal_export str TABsetTableBracket(int *ret, str *lbrk, str *rbrk);
mal_export str TABsetRowBracket(int *ret, str *lbrk, str *rbrk);
mal_export str TABsetColumnBracket(int *ret, int *idx, str *lbrk, str *rbrk);
mal_export str TABsetColumnNull(int *ret, int *idx, str *nullstr);
mal_export str TABsetColumnWidth(int *ret, int *idx, int *width);
mal_export str TABsetColumnPosition(int *ret, int *idx, int *first, int *width);

mal_export str TABsetColumnDecimal(int *ret, int *idx, int *scale, int *prec);
mal_export str TABfirstPage(int *ret);
mal_export str TABlastPage(int *ret);
mal_export str TABnextPage(int *ret);
mal_export str TABprevPage(int *ret);
mal_export str TABgetPage(int *ret, int *pnr);
mal_export str TABgetPageCnt(int *ret);
mal_export ptr *TABLETadt_frStr(void *extra, int type, char *s);
mal_export int TABLETadt_toStr(void *extra, char **buf, int *len, int type, ptr a);
mal_export void TABLETdestroy_format(Tablet * as);
mal_export size_t TABLETassign_BATs(Tablet * as, BAT *bats);
mal_export int TABLETcreate_bats(Tablet * as);
mal_export BAT * TABLETcollect_bats(Tablet * as);
mal_export int TABLETload_file(Tablet * as, bstream *b);
mal_export BAT * TABLETload(BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr);
mal_export BAT * TABLETinput(BAT *names, BAT *seps, BAT *types, bstream *s, size_t nr);
mal_export void TABLETdump(BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr);
mal_export void TABLEToutput_file(Tablet * as, BAT *order, stream *s);
mal_export size_t TABLEToutput(BAT *order, BAT *seps, BAT *bats, stream *s);
mal_export int init_tablet(int *debug);
mal_export int tablet_load(BAT **bats, BAT *names, BAT *seps, BAT *types, str datafile, int *nr);
mal_export int tablet_input(BAT **bats, BAT *names, BAT *seps, BAT *types, void
**s, int *nr);
mal_export int tablet_dump(BAT *names, BAT *seps, BAT *bats, str datafile, int *
nr);
mal_export int tablet_output(BAT *order, BAT *seps, BAT *bats, void **s);
mal_export str CMDtablet_load(int *ret, int *nameid, int *sepid, int *typeid, str *filename, int *nr);
mal_export str CMDtablet_dump(int *ret, int *nameid, int *sepid, int *bids, str
*filename, int *nr);
mal_export str CMDtablet_input(int *ret, int *nameid, int *sepid, int *typeid, stream *s, int *nr);
mal_export str CMDtablet_output(int *ret, int *nameid, int *sepid, int *bids, void **s);
mal_export void TABshowHeader(Tablet * t);
mal_export void TABshowRow(Tablet * t);
mal_export void TABshowRange(Tablet * t, lng first, lng last);

static void makeTableSpace(int rnr, unsigned int acnt);
static str bindVariable(Tablet * t, unsigned int anr, str nme, int tpe, ptr val, int *k);
static void clearTable(Tablet * t);
static int isScalarVector(Tablet * t);
static int isBATVector(Tablet * t);

static void TABshowPage(Tablet * t);
static int setTabwidth(Column * c);

#define LINE(s, X)     { int n=(int)(X)-1; stream_write(s, "#", 1, 1); while(--n>0) \
                                stream_write(s, "-", 1, 1); \
                                stream_printf(s, "#\n"); }
#define TABS(s, X)     { int n=(int)(X); while(n-->0) stream_printf(s, "\t");  }
@+
The table formatting information is stored in a system wide table.
Access is granted to a single client thread only.
The table structure depends on the columns to be printed,
it will be dynamically extended to accommodate the space.
@c
static int tablet_debug = 0;
static Tablet *tableReports[MAL_MAXCLIENTS];


static void
TABformatPrepare(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = getClient();
	int rnr = c - mal_clients;
	Tablet *t;
	int anr = 0, i, tpe, k;
	ptr val;

	makeTableSpace(rnr, pci->argc - pci->retc);
	t = tableReports[rnr];
	if (t->rlbrk == 0)
		t->rlbrk = GDKstrdup("[ ");
	if (t->rrbrk == 0)
		t->rrbrk = GDKstrdup("]");
	if (t->sep == 0)
		t->sep = GDKstrdup("\t");
	t->rowwidth = strlen(t->rlbrk) + strlen(t->rrbrk) - 2;

	for (i = pci->retc; i < pci->argc; anr++, i++) {
		/* The type should be taken from the stack ! */
		tpe = stk->stk[pci->argv[i]].vtype;
		val = (ptr) getArgReference(stk, pci, i);
		bindVariable(t, anr, getArgName(mb, pci, i), tpe, val, &k);
	}
	t->nr_attrs = anr;
	t->fd = c->fdout;
	t->pivot = 0;
}

str
TABsetFormat(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	TABformatPrepare(mb, stk, pci);
	return MAL_SUCCEED;
}

str
TABheader(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	TABformatPrepare(mb, stk, pci);
	TABshowHeader(tableReports[rnr]);
	return MAL_SUCCEED;
}

str
TABdisplayTable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = getClient();
	int rnr = c - mal_clients;
	Tablet *t;

	TABheader(mb, stk, pci);
	t = tableReports[rnr];
	if (!isBATVector(t))
		return throwMessage("tablet.print", "Only aligned BATs expected");
	else {
		t->pageLimit = 20;
		t->firstrow = t->lastrow = 0;
		TABshowPage(t);
	}
	return MAL_SUCCEED;
}

str
TABdisplayRow(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = getClient();
	int rnr = c - mal_clients;
	Tablet *t;

	TABheader(mb, stk, pci);
	t = tableReports[rnr];
	if (!isScalarVector(t))
		return throwMessage("tablet.print", "Only scalars expected");
	else
		TABshowRow(t);
	if (t->tbotbrk == 0) {
		LINE(t->fd, t->rowwidth);
	} else
		stream_write(t->fd, t->tbotbrk, 1, strlen(t->tbotbrk));
	return MAL_SUCCEED;
}

str
TABpage(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = getClient();
	int rnr = c - mal_clients;
	Tablet *t;

	TABformatPrepare(mb, stk, pci);
	t = tableReports[rnr];
	if (t->ttopbrk == 0) {
		LINE(t->fd, t->rowwidth);
	} else
		stream_write(t->fd, t->ttopbrk, 1, strlen(t->ttopbrk));
	if (!isBATVector(t))
		return throwMessage("tablet.print", "Only aligned BATs expected");
	else {
		t->pageLimit = 20;
		t->firstrow = t->lastrow = 0;
		TABshowPage(t);
	}
	return MAL_SUCCEED;
}

str
TABsetProperties(int *ret, str *prop)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	if (tableReports[rnr] == 0)
		return throwMessage("tablet.properties", "Format definition missing");
	CLEAR(tableReports[rnr]->properties);
	tableReports[rnr]->properties = !strNil(*prop) ? GDKstrdup(*prop) : 0;
	return MAL_SUCCEED;
}

str
TABdump(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	return throwMessage("tablet.report", "not yet implemented");
}

str
TABfinishReport(int *ret)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	if (tableReports[rnr] == 0)
		return throwMessage("tablet.finish", "Header information missing");
	clearTable(tableReports[rnr]);
	GDKfree(tableReports[rnr]);
	tableReports[rnr] = 0;
	return MAL_SUCCEED;
}


str
TABsetStream(int *ret, stream **s)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	if (tableReports[rnr] == 0)
		return throwMessage("tablet.setStream", "Header information missing");
	tableReports[rnr]->fd = *s;
	return MAL_SUCCEED;
}

str
TABsetPivot(int *ret, int *bid)
{
	Client c = getClient();
	int rnr = c - mal_clients;
	BAT *b;

	(void) ret;		/* fool compiler */
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("tablet.setPivot", "Pivot BAT missing");
	}

	tableReports[rnr]->pivot = b;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
TABsetDelimiter(int *ret, str *sep)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	if (tableReports[rnr] == 0)
		return throwMessage("tablet.setDelimiters", "Header information missing");
	tableReports[rnr]->sep = !strNil(*sep) ? GDKstrdup(*sep) : 0;
	return MAL_SUCCEED;
}

str
TABsetColumn(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	return throwMessage("tablet.setColumn", "not yet implemented");
}

str
TABsetColumnName(int *ret, int *idx, str *s)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	tableReports[rnr]->columns[*idx].name = !strNil(*s) ? GDKstrdup(*s) : 0;
	return MAL_SUCCEED;
}

str
TABsetTableBracket(int *ret, str *lbrk, str *rbrk)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, MAXARG);
	tableReports[rnr]->ttopbrk = !strNil(*lbrk) ? GDKstrdup(*lbrk) : 0;
	tableReports[rnr]->tbotbrk = !strNil(*rbrk) ? GDKstrdup(*rbrk) : 0;
	return MAL_SUCCEED;
}

str
TABsetRowBracket(int *ret, str *lbrk, str *rbrk)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, MAXARG);
	tableReports[rnr]->rlbrk = !strNil(*lbrk) ? GDKstrdup(*lbrk) : 0;
	tableReports[rnr]->rrbrk = !strNil(*rbrk) ? GDKstrdup(*rbrk) : 0;
	return MAL_SUCCEED;
}

str
TABsetColumnBracket(int *ret, int *idx, str *lbrk, str *rbrk)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	tableReports[rnr]->columns[*idx].lbrk = !strNil(*lbrk) ? GDKstrdup(*lbrk) : 0;
	tableReports[rnr]->columns[*idx].rbrk = !strNil(*rbrk) ? GDKstrdup(*rbrk) : 0;
	return MAL_SUCCEED;
}

str
TABsetColumnNull(int *ret, int *idx, str *nullstr)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	tableReports[rnr]->columns[*idx].nullstr = !strNil(*nullstr) ? GDKstrdup(*nullstr) : 0;
	return MAL_SUCCEED;
}

str
TABsetColumnWidth(int *ret, int *idx, int *width)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	tableReports[rnr]->columns[*idx].maxwidth = *width;
	return MAL_SUCCEED;
}

str
TABsetColumnPosition(int *ret, int *idx, int *first, int *width)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;
	(void) first;		/* fool compiler */
	tableReports[rnr]->columns[*idx].fieldwidth = *width;
	tableReports[rnr]->columns[*idx].fieldstart = *width;
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	return MAL_SUCCEED;
}

str
TABsetColumnDecimal(int *ret, int *idx, int *scale, int *prec)
{
	Client c = getClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	if (*prec > *scale)
		return throwMessage("tablet.setColumnDecimal", "illegal range");
	tableReports[rnr]->columns[*idx].precision = *prec;
	tableReports[rnr]->columns[*idx].scale = *scale;
	return MAL_SUCCEED;
}

str
TABfirstPage(int *ret)
{
	(void) ret;		/* fool compiler */
	return throwMessage("tablet.firstPage", "not yet implemented");
}

str
TABlastPage(int *ret)
{
	(void) ret;		/* fool compiler */
	return throwMessage("tablet.lastPage", "not yet implemented");
}

str
TABnextPage(int *ret)
{
	(void) ret;		/* fool compiler */
	return throwMessage("tablet.nextPage", "not yet implemented");
}

str
TABprevPage(int *ret)
{
	(void) ret;		/* fool compiler */
	return throwMessage("tablet.prevPage", "not yet implemented");
}

str
TABgetPage(int *ret, int *pnr)
{
	(void) ret;
	(void) pnr;		/* fool compiler */
	return throwMessage("tablet.getPage", "not yet implemented");
}

str
TABgetPageCnt(int *ret)
{
	(void) ret;		/* fool compiler */
	return throwMessage("tablet.getPageCnt", "not yet implemented");
}

static ptr
bun_tail(BAT *b, size_t nr)
{
	REGISTER size_t _i = BUNindex((b), BUNfirst((b)));

	return (ptr) BUNtail(b, BUNptr(b, _i + nr));
}


static BAT *
void_bat_create(int adt, size_t nr)
{
	BAT *b = BATnew(TYPE_void, adt, nr);

	BATseqbase(b, 0);
	return b;
}

static char *
sep_dup(char *sep)
{
	size_t len = strlen(sep);
	char *res = GDKmalloc(len + 1), *result = res;
	char *end = sep + len;

	while (sep < end) {
		if (*sep == '\\') {
			++sep;
			switch (*sep++) {
			case 'r':
				*res++ = '\r';
				break;
			case 'n':
				*res++ = '\n';
				break;
			case 't':
				*res++ = '\t';
				break;
			}
		} else {
			*res++ = *sep++;
		}
	}
	*res = '\0';
	return result;
}

ptr *
TABLETadt_frStr(void *extra, int type, char *s)
{
	int l = 0;
	ptr *res = NULL;

	(void) extra;		/* fool compiler */
	if (type == TYPE_str) {
		if (s == NULL || strcmp(s, "nil") == 0)
			res = (ptr *) ATOMnil(TYPE_str);
		else
			res = (ptr *) GDKstrdup(s);
	} else
		(void) (*BATatoms[type].atomFromStr) (s, &l, (ptr) &res);
	return res;
}

int
TABLETadt_toStr(void *extra, char **buf, int *len, int type, ptr a)
{
	(void) extra;		/* fool compiler */
	if (type == TYPE_str) {
		char *dst, *src = a;
		int l;

		if (GDK_STRNIL(src)) {
			src = "nil";
		}
		l = strlen(src);
		if (l + 3 > *len) {
			GDKfree(buf);
			*len = 2 * l + 3;
			*buf = GDKmalloc(*len);
		}
		dst = *buf;
		dst[0] = '"';
		strncpy(dst + 1, src, l);
		dst[l + 1] = '"';
		dst[l + 2] = 0;
		return l + 2;
	} else {
		return (*BATatoms[type].atomToStr) (buf, len, a);
	}
}

static
    size_t
create_loadformat(Tablet * as, BAT *names, BAT *seps, BAT *types)
{
	size_t p;
	size_t nr_attrs = BATcount(names);
	Column *fmt = as->format = (Column *) GDKmalloc(sizeof(Column) * (nr_attrs + 1));

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); *//* i.e. it fits */
	for (p = 0; p < nr_attrs; p++) {
		fmt[p].name = (char *) bun_tail(names, p);
		fmt[p].sep = sep_dup((char *) bun_tail(seps, p));
		fmt[p].seplen = (int) strlen(fmt[p].sep);
		fmt[p].type = (char *) bun_tail(types, p);
		fmt[p].adt = ATOMindex(fmt[p].type);
		fmt[p].tostr = &TABLETadt_toStr;
		fmt[p].frstr = &TABLETadt_frStr;
		fmt[p].extra = NULL;
		if (tablet_debug)
			stream_printf(GDKerr, "%s\n", fmt[p].name);
	}
	return as->nr_attrs;
}

static
    size_t
create_dumpformat(Tablet * as, BAT *names, BAT *seps, BAT *bats)
{
	size_t p;
	size_t nr_attrs = BATcount(bats);
	Column *fmt = as->format = (Column *) GDKmalloc(sizeof(Column) * (nr_attrs + 1));

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); *//* i.e. it fits */
	for (p = 0; p < nr_attrs; p++) {
		BAT *b = (BAT *) BATdescriptor(*(bat *) bun_tail(bats, p));

		if (!b)
			return -1;
		fmt[p].name = NULL;
		if (names)
			fmt[p].name = (char *) bun_tail(names, p);
		fmt[p].sep = sep_dup((char *) bun_tail(seps, p));
		fmt[p].seplen = (int) strlen(fmt[p].sep);
		fmt[p].type = ATOMname(b->ttype);
		fmt[p].adt = (b)->ttype;
		fmt[p].tostr = &TABLETadt_toStr;
		fmt[p].frstr = &TABLETadt_frStr;
		fmt[p].extra = NULL;
	}
	return as->nr_attrs;
}

void
TABLETdestroy_format(Tablet * as)
{
	size_t p;
	Column *fmt = as->format;

	for (p = 0; p < as->nr_attrs; p++) {
		if (fmt[p].bval)
			BBPunfix(fmt[p].bval->batCacheid);
		GDKfree(fmt[p].sep);
	}
	GDKfree(fmt);
}

size_t
TABLETassign_BATs(Tablet * as, BAT *bats)
{
	Column *fmt = as->format;
	size_t res = as->nr;
	size_t i;

	for (i = 0; i < as->nr_attrs; i++) {
		BAT *b = (BAT *) BATdescriptor(*(bat *) bun_tail(bats, i));

		fmt[i].bval = (b);
		if (res == ~(size_t) 0 || BATcount(fmt[i].bval) < res)
			res = BATcount(fmt[i].bval);
	}
	as->nr = res;
	return res;
}

static
    oid
check_BATs(Tablet * as)
{
	Column *fmt = as->format;
	size_t i;
	size_t cnt = BATcount(fmt[0].bval);
	oid base = fmt[0].bval->hseqbase;

	if (!BAThdense(fmt[0].bval))
		return oid_nil;

	for (i = 0; i < as->nr_attrs; i++) {
		BAT *b = fmt[i].bval;
		int offset = BUNindex(b, BUNfirst(b)) + as->offset;

		if (BATcount(b) != cnt || b->hseqbase != base)
			return oid_nil;

		fmt[i].pval = BUNptr(b, offset);
	}
	return base;
}

int
TABLETcreate_bats(Tablet * as)
{
	Column *fmt = as->format;
	size_t i;

	for (i = 0; i < as->nr_attrs; i++) {
		fmt[i].bval = void_bat_create(fmt[i].adt, as->nr);
	}
	return 0;
}

BAT *
TABLETcollect_bats(Tablet * as)
{
	BAT *bats = BATnew(TYPE_str, TYPE_bat, as->nr_attrs);
	Column *fmt = as->format;
	size_t i;
	size_t cnt = BATcount(fmt[0].bval);

	for (i = 0; i < as->nr_attrs; i++) {
		BUNins(bats, (ptr) fmt[i].name, (ptr) &fmt[i].bval->batCacheid);
		if (cnt != BATcount(fmt[i].bval)) {
			GDKerror("Error: counts are not equal\n");
			return NULL;
		}
	}
	return bats;
}

static INLINE int
myisspace(int s)
{
	return s == ' ' || s == '\t' || s == '\n';
}

static INLINE char *
strip(char *s, char *e)
{
	while (myisspace((int) *s)) {
		s++;
	}
	e--;
	while (myisspace((int) *e)) {
		e--;
	}
	e++;
	if (e && *e) {
		*e = 0;
	}
	return s;
}

static INLINE int
insert_val(Column * fmt, char *s, char *e)
{
	ptr *adt;
	oid on = oid_nil;	/* can't use &oid_nil because of the
				   way it's defined */
	adt = fmt->frstr(fmt->extra, fmt->adt, strip(s, e));

	if (!adt) {
		GDKerror("%ld not inserted %s\n", (long) adt, s);
		return 1;
	}

	BUNins(fmt->bval, &on, adt);
	GDKfree(adt);
	return 0;
}

static char *
find_quote(char *str, char quote)
{
	while (*str !=quote)
		str ++;
	return str;
}
static char *
rfind_quote(char *str, char quote)
{
	while (*str !=quote)
		str --;
	return str;
}
static char *
skip_string(char *str, char quote)
{
	int esc = 0;

	while (*str) {
		if (*str == '\\' && !esc)
			esc = 1;
		else if (*str == quote && !esc)
			break;
		else
			esc = 0;
		str ++;
	}
	if (*str)
		str ++;

	else
		return NULL;
	return str;
}

static INLINE int
insert_line(Tablet * as, char *line)
{
	int res = 0;
	Column *fmt = as->format;
	char *s, *e = 0, quote = '\"';
	size_t i;
	int quotes = 0;
	int first = 0;

	for (i = 0; i < as->nr_attrs - 1 && res == 0; i++) {
		first = 1;
		s = line;
		while (*line) {
			if (*line == *(fmt[i].sep) && strncmp(fmt[i].sep, line, fmt[i].seplen) == 0) {
				e = line;	/*strstr( line, fmt[i].sep ); */
				break;
			} else if (first && (*line == '\"' || *line == '\'')
				   && *(line - 1) != '\\') {
				quotes = 1;
				quote = *line;
				line++;
				line = skip_string(line, quote);
				if (!line)
					return -1;
				first = 0;
			} else {
				if (first && !isspace((int) *line))
					first = 0;
				line++;
			}
		}
		if (e) {
			char *end = e;

			if (quotes) {
				quotes = 0;
				s = find_quote(s, quote);
				if (!s)
					return -1;
				s++;
				e = rfind_quote(e, quote);
			}
			*e = 0;
			res |= insert_val(&fmt[i], s, e);
			line = end + fmt[i].seplen;
		} else {
			GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->bval), i);
			return -1;
		}
		e = 0;
	}
	s = line;
	first = 1;
	while (*line) {
		if (*line == *(fmt[as->nr_attrs - 1].sep) && strncmp(fmt[as->nr_attrs - 1].sep, line, fmt[as->nr_attrs - 1].seplen) == 0) {
			e = line;	/*strstr( line, fmt[as->nr_attrs-1].sep ); */
			break;
		} else if (first && (*line == '\"' || *line == '\'')
			   && *(line - 1) != '\\') {
			quotes = 1;
			quote = *line;
			line++;
			line = skip_string(line, quote);
			if (!line)
				return -1;
			first = 0;
		} else {
			if (first && !isspace((int) *line))
				first = 0;
			line++;
		}
	}
	if (!e)
		e = line;
	if (e) {
		char *end = e;

		if (quotes) {
			quotes = 0;
			s = find_quote(s, quote);
			if (!s)
				return -1;
			s++;
			e = rfind_quote(e, quote);
		}
		*e = 0;
		res |= insert_val(&fmt[as->nr_attrs - 1], s, e);
		line = end + fmt[as->nr_attrs - 1].seplen;
	} else {
		GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->bval), i);
		return -1;
	}
	e = 0;
	return res;
}

static INLINE int
dump_line(char **buf, int *len, Column * fmt, stream *fd, size_t nr_attrs, size_t id)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		Column *f = fmt + i;
		char *p = (char *) bun_tail(f->bval, id);
		int l = f->tostr(f->extra, buf, len, f->adt, p);

		(void) stream_write(fd, *buf, 1, l);
		(void) stream_write(fd, f->sep, 1, f->seplen);
	}
	return 0;
}

static INLINE int
output_line(char **buf, int *len, Column * fmt, stream *fd, size_t nr_attrs, ptr id)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		fmt[i].pval = BUNfnd(fmt[i].bval, id);

		if (fmt[i].pval == 0)
			break;
	}
	if (i == nr_attrs) {
		for (i = 0; i < nr_attrs; i++) {
			Column *f = fmt + i;
			char *p = BUNtail(f->bval, f->pval);
			int l = f->tostr(f->extra, buf, len, f->adt, p);

			(void) stream_write(fd, *buf, 1, l);
			(void) stream_write(fd, f->sep, 1, f->seplen);
		}
	}
	return 0;
}

static INLINE int
output_line_dense(char **buf, int *len, Column * fmt, stream *fd, size_t nr_attrs)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		Column *f = fmt + i;
		char *p = BUNtail(f->bval, f->pval);
		int l = f->tostr(f->extra, buf, len, f->adt, p);

		(void) stream_write(fd, *buf, 1, l);
		(void) stream_write(fd, f->sep, 1, f->seplen);
		f->pval = BUNnext(f->bval, f->pval);
	}
	return 0;
}

static INLINE int
output_line_lookup(char **buf, int *len, Column * fmt, stream *fd, size_t nr_attrs, size_t id)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		Column *f = fmt + i;
		char *p = BUNtail(f->bval, BUNptr(f->bval, id +BUNindex(f->bval, BUNfirst(f->bval))));
		int l = f->tostr(f->extra, buf, len, f->adt, p);

		(void) stream_write(fd, *buf, 1, l);
		(void) stream_write(fd, f->sep, 1, f->seplen);
	}
	return 0;
}


int
TABLETload_file(Tablet * as, bstream *b)
{
	int res = 0, eof = 0, done = 0;
	size_t i = 0;
	char *sep = as->format[as->nr_attrs - 1].sep;
	int seplen = as->format[as->nr_attrs - 1].seplen;

	if (tablet_debug)
		stream_printf(GDKerr, "TABLETload_file\n");

	while (eof < 2 && res == 0 && (as->nr == ~(size_t) 0 || i < as->nr)) {
		char *s, *end;

		if (bstream_read(b, b->size - (b->len - b->pos)) == 0 || stream_errnr(b->s)) {
			eof++;
			b->eof = 0;
		} else
			eof = 0;
		end = b->buf + b->len;
		s = b->buf + b->pos;
		*end = '\0';
		done = 0;
		while (s < end) {
			char *e = strstr(s, sep);

			if (e) {
				*e = '\0';
				if ((e - s) <= 1) {	/* empty line indicates eof */
					eof = 2;
					break;
				}
				if (insert_line(as, s) < 0) {
					GDKerror("value %s not inserted\n", s);
					res = -1;
					break;
				}
				s = e + seplen;
				done = 1;
			} else if (eof && s + as->nr_attrs < end) {
				if (insert_line(as, s) < 0) {
					GDKerror("value %s not inserted\n", s);
					res = -1;
					break;
				}
				s = end;
			} else {
				if (!done) {	/* nothing found in current buf
						 * ie. need to enlarge 
						 */
					if (bstream_read(b, b->size * 16) == 0)
						eof = 2;
					end = b->buf + b->len;
					s = b->buf + b->pos;
					*end = '\0';
					continue;
				}
				break;
			}
			b->pos = (s - b->buf);
			i++;
			if (tablet_debug && (i % 100000) == 0)
				stream_printf(GDKerr, "inserted %d\n", i);
			if (as->nr != ~(size_t) 0 && i >= as->nr)
				break;
		}
	}
	as->nr = i;
	if (res < 0)
		return res;
	return as->nr;
}

static
    int
dump_file(Tablet * as, stream *fd)
{
	size_t i = 0;
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);

	for (i = 0; i < as->nr; i++) {
		if (dump_line(&buf, &len, as->format, fd, as->nr_attrs, i) < 0) {
			GDKfree(buf);
			return -1;
		}
		if (tablet_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped %d lines\n", i);
	}
	GDKfree(buf);
	return 0;
}

static
    void
output_file_default(Tablet * as, BAT *order, stream *fd)
{
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);
	BUN p, q;
	size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for (q = BUNptr(order, offset + as->nr), p = BUNptr(order, offset); p < q; p = BUNnext(order, p)) {
		ptr h = BUNhead(order, p);

		if (output_line(&buf, &len, as->format, fd, as->nr_attrs, h) < 0) {
			GDKfree(buf);
			return;
		}
		i++;
		if (tablet_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped %lu lines\n", (unsigned long) i);
	}
	GDKfree(buf);
}

static
    void
output_file_dense(Tablet * as, stream *fd)
{
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);
	size_t i = 0;

	for (i = 0; i < as->nr; i++) {
		if (output_line_dense(&buf, &len, as->format, fd, as->nr_attrs) < 0) {
			GDKfree(buf);
			return;
		}
		if (tablet_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped %lu lines\n", (unsigned long) i);
	}
	GDKfree(buf);
}

static
    void
output_file_ordered(Tablet * as, BAT *order, stream *fd, oid base)
{
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);
	BUN p, q;
	size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for (q = BUNptr(order, offset + as->nr), p = BUNptr(order, offset); p < q; p = BUNnext(order, p)) {
		size_t h = *(oid *) BUNhead(order, p) - base;

		if (output_line_lookup(&buf, &len, as->format, fd, as->nr_attrs, h) < 0) {
			GDKfree(buf);
			return;
		}
		if (tablet_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped %lu lines\n", (unsigned long) i);
	}
	GDKfree(buf);
}

#define SIZE 1*1024*1024
BAT *
TABLETload(BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr)
{
	BAT *res;
	stream *s = open_rastream(datafile);
	bstream *b = NULL;

	if (stream_errnr(s)) {
		GDKerror("could not open file %s\n", datafile);
		return NULL;
	}
	res = TABLETinput(names, seps, types, b = bstream_create(s, SIZE), nr);
	bstream_destroy(b);
	stream_close(s);
	stream_destroy(s);
	return res;
}

BAT *
TABLETinput(BAT *names, BAT *seps, BAT *types, bstream *s, size_t nr)
{
	BAT *bats = NULL;
	Tablet as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_loadformat(&as, names, seps, types) != ~(size_t) 0 && TABLETcreate_bats(&as) >= 0) {
		if (TABLETload_file(&as, s) >= 0)
			bats = TABLETcollect_bats(&as);
	}
	TABLETdestroy_format(&as);
	return bats;
}

void
TABLETdump(BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr)
{
	Tablet as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_dumpformat(&as, names, seps, bats) != ~(size_t) 0 && TABLETassign_BATs(&as, bats) != ~(size_t) 0) {
		stream *s = open_wastream(datafile);

		if (!stream_errnr(s) && dump_file(&as, s) >= 0) {
			stream_printf(GDKerr, "saved in %s\n", datafile);
		}
		if (stream_errnr(s)) {
			GDKerror("could not open file %s\n", datafile);
		} else {
			stream_close(s);
		}
		stream_destroy(s);
	}
	TABLETdestroy_format(&as);
}

void
TABLEToutput_file(Tablet * as, BAT *order, stream *s)
{
	oid base = oid_nil;

	if ((base = check_BATs(as)) != oid_nil) {
		if (BAThdense(order) && order->hseqbase == base && BATcount(order) == as->nr)
			output_file_dense(as, s);
		else
			output_file_ordered(as, order, s, base);
	} else {
		output_file_default(as, order, s);
	}
}

size_t
TABLEToutput(BAT *order, BAT *seps, BAT *bats, stream *s)
{
	Tablet as;

	as.nr_attrs = 0;
	as.nr = ~(size_t) 0;
	if (create_dumpformat(&as, NULL, seps, bats) != ~(size_t) 0 && TABLETassign_BATs(&as, bats) != ~(size_t) 0) {
		TABLEToutput_file(&as, order, s);
	}
	TABLETdestroy_format(&as);
	return as.nr;
}

int
init_tablet(int *debug)
{
	tablet_debug = *debug;

	return GDK_SUCCEED;
}

int
tablet_load(BAT **bats, BAT *names, BAT *seps, BAT *types, str datafile, int *nr)
{
	*bats = TABLETload(names, seps, types, datafile, *nr);
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}
int
tablet_input(BAT **bats, BAT *names, BAT *seps, BAT *types, void **s, int *nr)
{
	bstream *b = NULL;

	*bats = TABLETinput(names, seps, types, b = bstream_create(*(stream **) s, SIZE), *nr);
	bstream_destroy(b);
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}

int
tablet_dump(BAT *names, BAT *seps, BAT *bats, str datafile, int *nr)
{
	TABLETdump(names, seps, bats, datafile, *nr);
	return GDK_SUCCEED;
}

int
tablet_output(BAT *order, BAT *seps, BAT *bats, void **s)
{
	TABLEToutput(order, seps, bats, *(stream **) s);
	return GDK_SUCCEED;
}

@+ MAL interface
@c
str
CMDtablet_load(int *ret, int *nameid, int *sepid, int *typeid, str *filename, int *nr)
{
	BAT *names, *seps, *types, *bn;

	if ((names = BATdescriptor(*nameid)) == NULL) {
		return throwMessage("tablet.load", "BAT missing");
	}
	if ((seps = BATdescriptor(*sepid)) == NULL) {
		BBPunfix(names->batCacheid);
		return throwMessage("tablet.load", "BAT missing");
	}
	if ((types = BATdescriptor(*typeid)) == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		return throwMessage("tablet.load", "BAT missing");
	}

	tablet_load(&bn, names, seps, types, *filename, nr);
	if (bn == NULL)
		return throwMessage("tablet.load", "failed to load");
	BBPincref(*ret, TRUE);
	*ret = bn->batCacheid;
	BBPunfix(names->batCacheid);
	BBPunfix(seps->batCacheid);
	BBPunfix(types->batCacheid);
	return MAL_SUCCEED;
}

str
CMDtablet_dump(int *ret, int *nameid, int *sepid, int *bids, str *filename, int *nr)
{
	BAT *names, *seps, *bats;

	(void) ret;

	if ((names = BATdescriptor(*nameid)) == NULL) {
		return throwMessage("tablet.dump", "BAT missing");
	}
	if ((seps = BATdescriptor(*sepid)) == NULL) {
		BBPunfix(names->batCacheid);
		return throwMessage("tablet.dump", "BAT missing");
	}
	if ((bats = BATdescriptor(*bids)) == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		return throwMessage("tablet.dump", "BAT missing");
	}

	tablet_dump(names, seps, bats, *filename, nr);
	BBPunfix(names->batCacheid);
	BBPunfix(seps->batCacheid);
	BBPunfix(bats->batCacheid);
	return MAL_SUCCEED;
}

str
CMDtablet_input(int *ret, int *nameid, int *sepid, int *typeid, stream *s, int *nr)
{
	BAT *names, *seps, *types, *bn;

	if ((names = BATdescriptor(*nameid)) == NULL) {
		return throwMessage("tablet.load", "BAT missing");
	}
	if ((seps = BATdescriptor(*sepid)) == NULL) {
		BBPunfix(names->batCacheid);
		return throwMessage("tablet.load", "BAT missing");
	}
	if ((types = BATdescriptor(*typeid)) == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		return throwMessage("tablet.load", "BAT missing");
	}

	tablet_input(&bn, names, seps, types, (void **) s, nr);
	if (bn == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		BBPunfix(types->batCacheid);
		return throwMessage("tablet.load", "failed to load");
	}
	BBPincref(*ret, TRUE);
	*ret = bn->batCacheid;
	BBPunfix(names->batCacheid);
	BBPunfix(seps->batCacheid);
	BBPunfix(types->batCacheid);
	return MAL_SUCCEED;
}

str
CMDtablet_output(int *ret, int *nameid, int *sepid, int *bids, void **s)
{
	BAT *names, *seps, *bats;

	if ((names = BATdescriptor(*nameid)) == NULL) {
		return throwMessage("tablet.output", "BAT missing");
	}
	if ((seps = BATdescriptor(*sepid)) == NULL) {
		BBPunfix(names->batCacheid);
		return throwMessage("tablet.output", "BAT missing");
	}
	if ((bats = BATdescriptor(*bids)) == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		return throwMessage("tablet.output", "BAT missing");
	}
	*ret = tablet_output(names, seps, bats, s);
	BBPunfix(names->batCacheid);
	BBPunfix(seps->batCacheid);
	BBPunfix(bats->batCacheid);
	return MAL_SUCCEED;
}


@mil

PROC test_tablet() : void := {

    #tablet_debug(1);

    fp := fopen ( "format", "w+" );
    fputs( "key,\",\",str\n", fp);
    fputs( "a_io_test,\"\\n\",dbl\n", fp);
    fclose( fp );

    fp := fopen ( "data", "w+" );
    fputs( "test, 0.12345\n", fp);
    fputs( "second line, 9.0\n", fp);
    fclose( fp );

    bats := load_data(load_format("format"),"data",10);
    bats.print;
    a := bats.find("key").reverse().join( bats.find("a_io_test") );
    a.print;
    dump_data(load_format("format"), bats, "data", -1);

    fp := fopen ( "data", "r" );
    s := fgets( fp ); 
    s.print();
    fclose( fp );
}

@+ Tablet report
The routines to manage the table descriptor
@c
static void
clearColumn(Column * c)
{
	CLEAR(c->batname);
	CLEAR(c->name);
	CLEAR(c->sep);
	c->width = 0;
	c->tabs = 0;
	c->bval = c->pval = 0;
	/* keep nullstr and brackets */
}
static void
clearTable(Tablet * t)
{
	unsigned int i;

	for (i = 0; i < t->nr_attrs; i++)
		clearColumn(t->columns + i);
	CLEAR(t->ttopbrk);
	CLEAR(t->tbotbrk);
	CLEAR(t->rlbrk);
	CLEAR(t->rrbrk);
	CLEAR(t->properties);
	CLEAR(t->title);
	CLEAR(t->footer);
	CLEAR(t->sep);
	t->rowwidth = 0;
	t->nr_attrs = 0;
	t->firstrow = t->lastrow = 0;
	/* keep brackets and stream */
}

@-
Expansion of a table report descriptor should not
mean loosing its content.
@c
static void
makeTableSpace(int rnr, unsigned int acnt)
{
	Tablet *t = 0;

	assert(rnr >= 0 && rnr < MAL_MAXCLIENTS);
	t = tableReports[rnr];
	if (t == 0) {
		int len = sizeof(Tablet) + acnt * sizeof(Column);

		t = tableReports[rnr] = (Tablet *) GDKmalloc(len);
		memset((char *) t, 0, len);
		t->max_attrs = acnt;
	}
	if (t && t->max_attrs < acnt) {
		Tablet *tn;
		int len = sizeof(Tablet) + acnt * sizeof(Column);

		tn = tableReports[rnr] = (Tablet *) GDKmalloc(len);
		memcpy((char *) tn, (char *) t, sizeof(Tablet) + t->max_attrs * sizeof(Column));
		GDKfree(t);
		t->max_attrs = acnt;
	}
}

@-
Binding variables also involves setting the default
formatting scheme. These are based on the storage type only
at this point. The variables should be either all BATs
or all scalars. But this is to be checked just before
printing.
@c
static int
isScalarVector(Tablet * t)
{
	unsigned int i;

	for (i = 0; i < t->nr_attrs; i++)
		if (t->columns[i].bval)
			return 0;
	return 1;
}
static int
isBATVector(Tablet * t)
{
	unsigned int i, cnt;

	if (t->columns[0].bval == 0)
		return 0;
	cnt = BATcount(t->columns[0].bval);
	for (i = 0; i < t->nr_attrs; i++)
		if (t->columns[i].bval == 0)
			return 0;
		else if (BATcount(t->columns[i].bval) != cnt)
			return 0;
	return 1;
}
static str
bindVariable(Tablet * t, unsigned int anr, str nme, int tpe, ptr val, int *k)
{
	Column *c;
	char *buf;
	int tpeStore;

	c = t->columns + anr;
	tpeStore = ATOMstorage(tpe);
	c->type = GDKstrdup(ATOMname(tpeStore));
	c->adt = tpe;
	c->name = GDKstrdup(nme);
	if (c->rbrk == 0)
		c->rbrk = GDKstrdup(",");
	c->width = strlen(nme);	/* plus default bracket(s) */

	if (anr >= t->nr_attrs)
		t->nr_attrs = anr + 1;
	buf = (char *) GDKmalloc(BUFSIZ);

	if (tpe == TYPE_bat) {
		BAT *b;
		int bid = *(int *) val;

		if ((b = BATdescriptor(bid)) == NULL) {
			return throwMessage("tablet.bindVariable", "Cannot access descriptor");
		}

		c->bval = b;
		/* the first column should take care of leader text size */
		if (c->bval)
			setTabwidth(c);
	} else if (val) {
		if (ATOMstorage(tpe) == TYPE_str || ATOMstorage(tpe) > TYPE_str)
			val = *(str *) val;	/* V5 */
		(*BATatoms[tpe].atomToStr) (&buf, k, val);
		c->width = MAX(c->width, strlen(buf));
		if (c->lbrk)
			c->width += strlen(c->lbrk);
		if (c->rbrk)
			c->width += strlen(c->rbrk);
	}
	GDKfree(buf);

	c->pval = val;
	if (c->scale)
		c->width = c->scale + 2;	/* decimal point  and '-' */
	c->width += (c->rbrk ? strlen(c->rbrk) : 0) + (c->lbrk ? strlen(c->lbrk) : 0);
	if (c->maxwidth && c->maxwidth < c->width)
		c->width = c->maxwidth;
	if (t->columns == c)
		c->width += t->rlbrk ? strlen(t->rlbrk) : 0;
	c->tabs = 1 + (c->width) / 8;
	t->rowwidth += 8 * c->tabs;
	*k = c->width;
	if (c->bval)
		BBPunfix(c->bval->batCacheid);
	return NULL;
}

@+ Actual printing
@c


void
TABshowHeader(Tablet * t)
{
	unsigned int i;
	char *prop = "name", *p, *q;

	if (t->title)
		stream_write(t->fd, t->title, 1, strlen(t->title));
	else {
		LINE(t->fd, t->rowwidth);
	}

	p = t->properties ? t->properties : prop;
	while (p) {
		q = strchr(p, ',');
		if (q)
			*q = 0;
		stream_write(t->fd, "# ", 1, 2);
		for (i = 0; i < t->nr_attrs; i++) {
			Column *c = t->columns + i;
			unsigned int len;
			str prop = 0;
			int u = 0, v = 0;

			if (strcmp(p, "name") == 0)
				prop = c->name;
			else if (strcmp(p, "type") == 0)
				prop = c->type;
			else if (!isScalar(c) && c->bval) {
				if (strcmp(p, "bat") == 0) {
					prop = BBPname(c->bval->batCacheid);
				}
				if (strcmp(p, "name") == 0) {
					prop = GDKstrdup(c->bval->tident);
				}
				if (strcmp(p, "base") == 0) {
					char buf[BUFSIZ];

					sprintf(buf, SZFMT, (size_t)c->bval->hseqbase);
					prop = GDKstrdup(buf);
				}
				if (strcmp(p, "sorted") == 0) {
					if (BATtordered(c->bval))
						prop = GDKstrdup("true");
					else
						prop = GDKstrdup("false");
				}
				if (strcmp(p, "dense") == 0) {
					if (BATtdense(c->bval))
						prop = GDKstrdup("true");
					else
						prop = GDKstrdup("false");
				}
				if (strcmp(p, "key") == 0) {
					if (c->bval->tkey)
						prop = GDKstrdup("true");
					else
						prop = GDKstrdup("false");
				}
				if (strcmp(p, "min") == 0) {
@-
@= setAggr
case TYPE_@1: {
	@1 m;
	char buf[BUFSIZ];
	BAT@2(c->bval,&m);
	sprintf(buf,@3,m);
	prop= GDKstrdup(buf);
}
break;
@c
					switch (c->adt) {
						@:setAggr(int,min,"%d")@
						@:setAggr(lng,min,"%lld")@
						@:setAggr(sht,min,"%d")@
						@:setAggr(dbl,min,"%f")@

					default:
						prop = GDKstrdup("");
					}
				}
				if (strcmp(p, "max") == 0) {
					switch (c->adt) {
						@:setAggr(int,max,"%d")@
						@:setAggr(lng,max,"%lld")@
						@:setAggr(sht,max,"%d")@
						@:setAggr(dbl,max,"%f")@

					default:
						prop = GDKstrdup("");
					}
				}
			}
			len = prop ? strlen(prop) : 0;
			if (c->maxwidth && len > c->maxwidth)
				len = c->maxwidth;
			if (c->lbrk)
				stream_write(t->fd, c->lbrk, 1, u = strlen(c->lbrk));
			stream_write(t->fd, prop, len, 1);
			if (c->rbrk && i + 1 < t->nr_attrs)
				stream_write(t->fd, c->rbrk, 1, v = strlen(c->rbrk));
			if (c == t->columns)
				len += t->rlbrk ? strlen(t->rlbrk) : 0;
			TABS(t->fd, c->tabs - ((len + u + v) / 8));
			if (prop) {
				GDKfree(prop);
				prop = 0;
			}

		}
		stream_write(t->fd, "# ", 1, 2);
		stream_write(t->fd, p, 1, strlen(p));
		stream_write(t->fd, "\n", 1, 1);
		if (q) {
			*q = ',';
			p = q + 1;
		} else
			p = 0;
	}

	if (t->tbotbrk == 0) {
		LINE(t->fd, t->rowwidth);
	} else
		stream_write(t->fd, t->tbotbrk, 1, strlen(t->tbotbrk));
}

void
TABshowRow(Tablet * t)
{
	unsigned int i = 0;
	unsigned int m = 0;
	int zero = 0;
	char *buf = 0;
	Column *c = t->columns + i;
	unsigned int len;
	int u = 0, v = 0;

	buf = (char *) GDKmalloc(m = t->rowwidth);

	if (t->rlbrk)
		stream_printf(t->fd, "%s", t->rlbrk);
	for (i = 0; i < t->nr_attrs; i++) {
		c = t->columns + i;
		u = 0;
		v = 0;
		if (c->pval)
			(*BATatoms[c->adt].atomToStr) (&buf, &zero, c->pval);
		m= (unsigned int) zero;
		if (strcmp(buf, "nil") == 0 && c->nullstr && strlen(c->nullstr) < m)
			strcpy(buf, c->nullstr);
		if (c->precision) {
			if (strcmp(buf, "nil") == 0) {
				snprintf(buf, m, "%*s", c->scale + (c->precision ? 1 : 0), "nil");
			} else
				switch (c->adt) {
				case TYPE_int:
				{
					int vi = *(int *) c->pval, vj = vi, m = 1;
					int k;

					for (k = c->precision; k > 0; k--) {
						vi /= 10;
						m *= 10;
					}
					snprintf(buf, m, "%*d.%d", c->scale - c->precision, vi, vj % m);
				}
				}
		}
		len = strlen(buf);
		if (c->maxwidth && len > c->maxwidth)
			len = c->maxwidth;
		if (c->lbrk)
			stream_write(t->fd, c->lbrk, 1, u = strlen(c->lbrk));
		stream_write(t->fd, buf, 1, len);
		if (c->rbrk) {
			v = strlen(c->rbrk);
			if (i + 1 < t->nr_attrs) {
				stream_write(t->fd, c->rbrk, 1, v);
			} else if (*c->rbrk != ',')
				stream_write(t->fd, c->rbrk, 1, v);
		}

		if (c == t->columns)
			len += t->rlbrk ? strlen(t->rlbrk) : 0;
		TABS(t->fd, c->tabs - ((len + u + v - 1) / 8));
	}
	if (t->rrbrk)
		stream_printf(t->fd, "%s\n", t->rrbrk);
	GDKfree(buf);
}

void
TABshowRange(Tablet * t, lng first, lng last)
{
	lng i, j;
	oid k;

	i = BATcount(t->columns[0].bval);
	if (last < 0 || last > i)
		last = i;
	if (first <= 0)
		first = 0;

	for (i = first; i < last; i++) {
		if (t->pivot) {
			k = *(oid *) BUNtail(t->pivot, BUNptr(t->pivot, t->pivot->hseqbase + i));
		} else
			k = (oid) i;
		for (j = 0; j < t->nr_attrs; j++) {
			BAT *b = t->columns[j].bval;
			int base = t->columns[j].base;

			t->columns[j].pval = BUNtail(b, BUNptr(b, base + k));
		}
		TABshowRow(t);
	}
}
static void
TABshowPage(Tablet * t)
{
	/* if( t->ttopbrk==0) { LINE(t->fd,t->rowwidth); }
	   else stream_printf(t->fd, "%s\n", t->ttopbrk); */
	TABshowRange(t, 0, -1);
	if (t->tbotbrk == 0) {
		LINE(t->fd, t->rowwidth);
	} else
		stream_printf(t->fd, "%s\n", t->tbotbrk);
}

@+ V4 stuff
The remainder is a patched copy of material from gdk_storage.
@c
typedef int (*strFcn) (str *s, int *len, ptr val);

#define printfcn(b)	((b->ttype==TYPE_void && b->tseqbase==oid_nil)?\
			          print_nil:BATatoms[b->ttype].atomToStr)
static int
print_nil(char **dst, int *len, ptr dummy)
{
	(void) dummy;		/* fool compiler */
	if (*len < 3) {
		if (*dst)
			GDKfree(*dst);
		*dst = (char *) GDKmalloc(*len = 40);
	}
	strcpy(*dst, "nil");
	return 3;
}

static int
setTabwidth(Column * c)
{
	strFcn tostr = printfcn(c->bval);
	size_t cnt = BATcount(c->bval);
	int ret = 0;
	unsigned int max;
	int t = BATttype(c->bval);
	char *buf = 0;
	char *title = c->bval->tident;

	if (strcmp(c->bval->tident, "t") == 0) {
		title = GDKmalloc(strlen(BATgetId(c->bval)) + 7);
		snprintf(title, 20, "%s", BATgetId(c->bval));
	}
	c->base = BUNindex(c->bval, BUNfirst(c->bval));
	c->type = GDKstrdup(ATOMname(c->bval->ttype));
	c->adt = c->bval->ttype;
	buf = (char *) GDKmalloc(ret = strLen(title));
	max = MAX((int) strlen(c->type), ret);
	if (c->nullstr)
		max = MAX(max, strlen(c->nullstr));
	if (c->lbrk)
		max += strlen(c->lbrk);
	if (c->rbrk)
		max += strlen(c->rbrk);

	if (t >= 0 && t < GDKatomcnt && tostr) {
		size_t off = BUNindex(c->bval, BUNfirst(c->bval));
		size_t j, i, probe = MIN(10000, MAX(200, cnt / 100));

		for (i = 0; i < probe; i++) {
			if (i >= cnt)
				break;
			j = off + ((cnt < probe) ? i : (rand() % cnt));
			(*tostr) (&buf, &ret, BUNtail(c->bval, BUNptr(c->bval, j)));
			max = MAX(max, strlen(buf));
		}
	}
	c->width = max;
	c->name = GDKstrdup(title);
	return c->width;
}

@}
