@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f tablet
@a Niels Nes, Martin Kersten
@d 29/07/2003
@+ The table interface

A database cannot live without ASCII tabular print/dump/load operations. 
It is needed to produce reasonable listings, to exchange answers
with a client, and to keep a database version for backup.
This is precisely where the tablet module comes in handy.
[This module should replace all other table dump/load functions]

We start with a simple example to illustrate the plain ASCII
representation and the features provided. Consider the
relational table answer(name:str, age:int, sex:chr, address:str, dob:date)
obtained by calling the routine tablet.page(B1,...,Bn) where the Bi represent
BATS.
@verbatim
[ "John Doe",		25,	'M',	"Parklane 5",	"25-12-1978" ]
[ "Maril Streep",	23,	'F',	"Church 5",	"12-07-1980" ]
[ "Mr. Smith",		53,	'M',	"Church 1",	"03-01-1950" ]
@end verbatim
@-
The lines contain the representation of a list in Monet tuple format.
This format has been chosen to ease parsing by any front-end. The scalar values
are represented according to their type. For visual display, the columns
are aligned by placing enough tabs between columns based on sampling the
underlying bat to determine a maximal column width.
(Note,actual commas are superfluous).

The arguments to the command can be any sequence of BATs, but which are
assumed to be aligned. That is, they all should have the same number of
tuples and the j-th tuple tail of Bi is printed along-side the j-th tuple
tail of Bi+1. 

Printing both columns of a single bat is handled by tablet as a
print of two columns. This slight inconvenience is catch-ed by
the io.print(b) command, which resolves most back-ward compatibility issues.
@-
In many cases, this output would suffice for communication with a front-end.
However, for visual inspection the user should be provided also some meta
information derived from the database schema. Likewise, when reading a
table this information is needed to prepare a first approximation of
the schema namings. This information is produced by the command
tablet.header(B1,...,Bn), which lists the column role name.
If no role name is give, a default is generated based on the
BAT name, e.g. B1_tail.

@verbatim
#------------------------------------------------------#
# name,           age, sex, address,       dob         #
#------------------------------------------------------#
[ "John Doe",      25, 'M', "Parklane 5", "25-12-1978" ]
[ "Maril Streep",  23, 'F', "Church 5",   "12-07-1980" ]
[ "Mr. Smith",     53, 'M', "Church 1",   "03-01-1950" ]
@end verbatim
@-

The command tablet.display(B1,...,Bn) is a contraction of tablet.header();
tablet.page().  

In many cases, the @code{tablet} produced may be too long to consume completely
by the front end. In that case, the user needs page size control, much
like the more/less utilities under Linux. However, no guarantee
is given for arbitrarily going back and forth. 
[but works as long as we materialize results first ].
A portion of the tablet can be printed by identifying the rows of interest as
the first parameter(s) in the page command, e.g.


@verbatim
tablet.page(nil,10,B1,...,Bn);	#prints first 10 rows
tablet.page(10,20,B1,...,Bn);	#prints next 10 rows
tablet.page(100,nil,B1,...,Bn);	#starts printing at tuple 100 until end
@end verbatim

A paging system also provides the commands tablet.firstPage(), 
tablet.nextPage(), tablet.prevPage(), and tablet.lastPage() using 
a user controlled tablet size tablet.setPagesize(L). 

The tablet display operations use a client (thread) specific formatting
structure. This structure is initialized using either 
tablet.setFormat(B1,...,Bn) or tablet.setFormat(S1,...,Sn) (Bi is a BAT, Si a scalar).
Subsequently, some additional properties can be set/modified, 
column width and brackets. 
After printing/paging the BAT resources should be freed using
the command tablet.finish().

Any access outside the page-range leads to removal of the report structure.
Subsequent access will generate an error.
To illustrate, the following code fragment would be generated by
the SQL compiler

@verbatim
	tablet.setFormat(B1,B2);
	tablet.setDelimiters("|","\t","|\n");
	tablet.setName(0, "Name");
	tablet.setNull(0, "?");
	tablet.setWidth(0, 15);
	tablet.setBracket(0, " ", ",");
	tablet.setName(1, "Age");
	tablet.setNull(1, "-");
	tablet.setDecimal(1, 9,2);
	tablet.SQLtitle("Query: select * from tables");
	tablet.page();
	tablet.SQLfooter(count(B1),cpuTicks);
@end verbatim

@-
This table is printed with tab separator(s) between elements
and the bar (|) to mark begin and end of the string.
The column parameters give a new title, 
a null replacement value, and the preferred column width.
Each column value is optionally surrounded by brackets.
Note, scale and precision can be applied to integer values only.
A negative scale leads to a right adjusted value.

The title and footer operations are SQL specific routines to
decorate the output.

Another example involves printing a two column table in XML format.
[Alternative, tablet.XMLformat(B1,B2) is a shorthand for the following:]

@verbatim
	tablet.setFormat(B1,B2);
	tablet.setTableBracket("<rowset>","</rowset>");
	tablet.setRowBracket("<row>","</row>");
	tablet.setBracket(0, "<name>", "</name>");
	tablet.setBracket(1, "<age>", "</age>");
	tablet.page();
@end verbatim
@- Tablet properties
More detailed header information can be obtained with the command 
tablet.setProperties(S), where S
is a comma separated list of properties of interest,
followed by the tablet.header().
The properties to choose from are: bat, name, type, width, 
sorted, dense, key, base, min, max, card,....

@verbatim
#--------------------------------------#
# B1,   B2,     B3,     B4,     B5     # BAT
# str,  int,    chr,    str,    date   # type
# true, false,  false,  false,  false  # sorted
# true, true,   false,  false,  false  # key
# ,     23,     'F',    ,              # min
# ,     53,     'M',	,              # max
# 4,     4,     4,      4,      4      # count
# 4,i    3,     2,      2,      3      # card
# name,	age,    sex,   address, dob    # name
#--------------------------------------#
@end verbatim

@- Scalar tablets
In line with the 10-year experience of Monet, printing scalar values
follow the tuple layout structure. This means that the header() command 
is also applicable.
For example, the sequence "i:=0.2;v:=sin(i); tablet.display(i,v);"
produces the answer:
@verbatim
#----------------#
# i,	v	 #
#----------------#
[ 0.2,	0.198669 ]
#----------------#
@end verbatim
@-

All other formatted printing should be done with the printf() operations
contained in the module @sc{io}.

@- Tablet dump/restore

Dump and restore operations are abstractions over sequence of tablet commands.
The command tablet.dump(stream,B1,...,Bn) is a contraction of the sequence
tablet.setStream(stream);
tablet.setProperties("name,type,dense,sorted,key,min,max");
tablet.header(B1,..,Bn); tablet.page(B1,..,Bn). 
The result can be read by tablet.load(stream,B1,..,Bn) command. 
If loading is successful, e.g. no parsing
errors occurred, the tuples are appended to the corresponding BATs.

@- Front-end extension
A general bulk loading of foreign tables, e.g. CSV-files and fixed position 
records, is not provided. Instead, we extend the list upon need. 
Currently, the routines tablet.SQLload(stream,delim1,delim2, B1,..,Bn) 
reads the files using the Oracle(?) storage. The counterpart for
dumping is tablet.SQLdump(stream,delim1,delim2);

@- The commands

The load operation is for bulk loading a table, each column will be loaded
into its own bat. The arguments are void-aligned bats describing the
input, ie the name of the column, the tuple separator and the type.
The nr argument can be -1 (The input (datafile) is read until the end)
or a maximum.

The dump operation is for dumping a set of bats, which are aligned.
Again with void-aligned arguments, with name (currently not used),
tuple separator (the last is the record separator) and bat to be dumped.
With the nr argument the dump can be limited (-1 for unlimited).

The output operation is for ordered output. A bat (possibly form the collection)
gives the order. For each element in the order bat the values in the bats are
searched, if all are found they are output in the datafile, with the given
separators.

The scripts from the tablet.mil file are all there too for backward
compatibility with the old Mload format files.

The load_format loads the format file, since the old format file was
in a table format it can be loaded with the load command.

The result from load_format can be used with load_data to load the data
into a set of new bats.

These bats can be made persistent with the make_persistent script or
merge with existing bats with the merge_data script.

The dump_format scripts dump a format file for a given set of
to be dumped bats. These bats can be dumped with dump_data.
@mal
# the major tablet shuffling routines
module tablet;

command load( names:bat[:oid,:str], seps:bat[:oid,:str], 
		types:bat[:oid,:str], datafile:str, nr:int ) :bat[:str,:bat] 
address CMDtablet_load
comment "Load a bat using specific format.";

command input( names:bat[:oid,:str], seps:bat[:oid,:str], 
		types:bat[:oid,:str], s:streams, nr:int ) :bat[:str,:bat] 
address CMDtablet_input
comment "Load a bat using specific format.";

command dump(names:bat[:oid,:str], seps:bat[:oid,:str], 
		bats:bat[:oid,:bat], datafile:str, nr:int) :void 
address CMDtablet_dump 
comment "Dump the bat in ASCII format";

command output(order:bat[:any_1,:any_2], seps:bat[:oid,:str], 
		bats:bat[:oid,:bat], s:streams) :void 
address CMDtablet_output 
comment "Send the bat to an output stream.";

pattern display(v:any...):int 
address TABdisplayRow
comment "Display a formatted row";
pattern display(v:bat[:any_1,:any]...):int 
address TABdisplayTable
comment "Display a formatted table";

pattern page(b:bat[:any_1,:any]...):int 
address TABpage
comment "Display all pages at once without header";
pattern header(b:any...):int 
address TABheader
comment "Display the minimal header for the table";
command setProperties(prop:str):int 
address TABsetProperties
comment "Define the set of properties";
pattern dump(s:streams,b:bat[:any,:any]...):int 
address TABdump
comment "Print all pages with header to a stream";

pattern setFormat(b:any...):void 
address TABsetFormat
comment "Initialize a new reporting structure.";
command finish():void 
address TABfinishReport
comment "Free the storage space of the report descriptor";
command setStream(s:streams):void 
address TABsetStream
comment "Redirect the output to a stream.";
command setPivot(b:bat[:void,:oid]) :void
address TABsetPivot
comment "The pivot bat identifies the tuples of interest. The only requirement 
	    is that all keys mentioned in the pivot tail exist in all BAT parameters 
	    of the print comment. The pivot also provides control over the order 
	    in which the tuples are produced.";
command setDelimiter(sep:str):void 
address TABsetDelimiter
comment "Set the column separator.";
command setTableBracket(lbrk:str,rbrk:str)
address TABsetTableBracket
comment "Format the brackets around a table";
command setRowBracket(lbrk:str,rbrk:str)
address TABsetRowBracket
comment "Format the brackets around a row";

# Set the column properties 
pattern setColumn(idx:int, v:any_1)
address TABsetColumn
comment "Bind i-th output column to a variable";
command setName(idx:int, nme:str)
address TABsetColumnName
comment "Set the display name for a given column";
command setBracket(idx:int,lbrk:str,rbrk:str)
address TABsetColumnBracket
comment "Format the brackets around a field";
command setNull(idx:int, fmt:str)
address TABsetColumnNull
comment "Set the display format for a null value for a given column";
command setWidth(idx:int, maxwidth:int)
address TABsetColumnWidth
comment "Set the maximal display witdh for a given column. All values exceeding 
	the length are simple shortened without any notice.";
command setPosition(idx:int,f:int,i:int)
address TABsetColumnPosition
comment "Set the character position to use for this field when loading according to 
	fixed (punch-card) layout.";
command setDecimal(idx:int,s:int,p:int)
address TABsetColumnDecimal
comment "Set the scale and precision for numeric values";

command firstPage():void 
address TABfirstPage
comment "Produce the first page of output";
command lastPage():void 
address TABlastPage
comment "Produce the last page of output";
command nextPage():void 
address TABnextPage
comment "Produce the next page of output";
command prevPage():void 
address TABprevPage
comment "Produce the prev page of output";
command getPageCnt():void 
address TABgetPageCnt
comment "Return the size in number of pages";
command getPage(i:int):void 
address TABgetPage
comment "Produce the i-th page of output";
@-
@{
@include prelude.mx
@+ Implementation
The implementation needs the stream abstraction, which also provides
primitives to compress/decompress files on the fly.
The file can plain ASCII, gzipped or bzipped, decided by the extention 
(none, gz or bz2). The default is plain ASCII, which is formatted to
pre presented on the screen directly.

@h
#ifndef _TABLET_IO2_H_
#define _TABLET_IO2_H_

#include <gdk.h>
#include "streams.h"
#include <mal_exception.h>
#include <mal_client.h>
#include <mal_interpreter.h>

#ifdef WIN32
#ifndef LIBTABLET
#define tablet_export extern __declspec(dllimport)
#else
#define tablet_export extern __declspec(dllexport)
#endif
#else
#define tablet_export extern
#endif

typedef ptr *(*frStr) (void *extra, int type, char *s, char *e, char quote);
typedef int (*toStr) (void *extra, char **buf, int *len, int type, ptr a);

typedef struct Column_t {
	char *batname;
	char *name;		/* column title */
	char *sep;
	int seplen;
	char *type;
	int adt;		/* type index */
	BAT *c;			/* set to NULL when scalar is meant */
	ptr p;
	int base;		/* of first tuple */
	unsigned int tabs;	/* field size in tab positions */
	str lbrk, rbrk;		/* column brackets */
	str nullstr;		/* null representation */
	int quoted;		/* escape charaters */
	unsigned int width;	/* actual column width */
	unsigned int maxwidth;	/* permissible width */
	int fieldstart;		/* Fixed character field load positions */
	int fieldwidth;
	int scale, precision;
	toStr tostr;
	frStr frstr;
	void *extra;
	void *data;
	int len;
	int nillen;
} Column;

@-
All table printing is based on building a report structure first.
This table structure is private to a client, which made us to
keep it in an ADT.
@h

typedef struct Table_t {
	int signature;
	char *sep;		/* default separator */
	str ttopbrk, tbotbrk;	/* table brackets */
	str rlbrk, rrbrk;	/* row brackets */
	str properties;		/* of header to display */
	str title, footer;	/* alternatives */
	size_t offset;
	size_t nr;		/* allocated space for table loads */
	size_t pageLimit;
	size_t firstrow, lastrow;	/* last window to print */
	size_t nr_attrs;	/* attributes found sofar */
	size_t max_attrs;
	Column *format;		/* remove later */
	stream *fd;
	BAT *pivot;
	str error;	/* last error */
	unsigned int rowwidth;		/* sum of columns used for mallocs */
	Column columns[1];			/* at least one column, enlarged upon need */
} Tablet;

tablet_export BAT *TABLETload(BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr);
tablet_export BAT *TABLETinput(BAT *names, BAT *seps, BAT *types, bstream *s, stream *out, size_t nr, size_t est);
tablet_export size_t TABLEToutput(BAT *order, BAT *seps, BAT *bats, stream *s);
tablet_export void TABLETdump(BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr);

/* The low level routines are primarilly used by the SQL front-end.*/
tablet_export int TABLETcreate_bats(Tablet * as, size_t est);
tablet_export size_t TABLETassign_BATs(Tablet * as, BAT *bats);
tablet_export ssize_t TABLETload_file(Tablet * as, bstream *b, stream *out);
tablet_export BAT *TABLETcollect_bats(Tablet * as);
tablet_export void TABLETdestroy_format(Tablet * as);
tablet_export int TABLEToutput_file(Tablet * as, BAT *order, stream *s);

tablet_export ptr *TABLETstrFrStr(Column *c, char *s, char *e);
tablet_export ptr *TABLETadt_frStr(void *extra, int type, char *s, char *e, char quote);
tablet_export int TABLETadt_toStr(void *extra, char **buf, int *len, int type, ptr a);
tablet_export int insert_line(Tablet * as, char *line, ptr key);
tablet_export int output_file_dense(Tablet * as, stream *fd);

#endif
@c
#include "mal_config.h"
#include "tablet.h"
#include "algebra.h"

#include <string.h>
#include <ctype.h>

#define CLEAR(X) if(X) {GDKfree(X);X = NULL;}
#define isScalar(C)  C->adt != TYPE_bat

tablet_export str TABsetFormat(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
tablet_export str TABheader(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
tablet_export str TABdisplayTable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
tablet_export str TABdisplayRow(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
tablet_export str TABpage(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
tablet_export str TABsetProperties(int *ret, str *prop);
tablet_export str TABdump(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
tablet_export str TABfinishReport(int *ret);
tablet_export str TABsetStream(int *ret, stream **s);
tablet_export str TABsetPivot(int *ret, int *bid);
tablet_export str TABsetDelimiter(int *ret, str *sep);
tablet_export str TABsetColumn(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
tablet_export str TABsetColumnName(int *ret, int *idx, str *s);
tablet_export str TABsetTableBracket(int *ret, str *lbrk, str *rbrk);
tablet_export str TABsetRowBracket(int *ret, str *lbrk, str *rbrk);
tablet_export str TABsetColumnBracket(int *ret, int *idx, str *lbrk, str *rbrk);
tablet_export str TABsetColumnNull(int *ret, int *idx, str *nullstr);
tablet_export str TABsetColumnWidth(int *ret, int *idx, int *width);
tablet_export str TABsetColumnPosition(int *ret, int *idx, int *first, int *width);

tablet_export str TABsetColumnDecimal(int *ret, int *idx, int *scale, int *prec);
tablet_export str TABfirstPage(int *ret);
tablet_export str TABlastPage(int *ret);
tablet_export str TABnextPage(int *ret);
tablet_export str TABprevPage(int *ret);
tablet_export str TABgetPage(int *ret, int *pnr);
tablet_export str TABgetPageCnt(int *ret);
tablet_export str CMDtablet_load(int *ret, int *nameid, int *sepid, int *typeid, str *filename, int *nr);
tablet_export str CMDtablet_dump(int *ret, int *nameid, int *sepid, int *bids, str
*filename, int *nr);
tablet_export str CMDtablet_input(int *ret, int *nameid, int *sepid, int *typeid, stream *s, int *nr);
tablet_export str CMDtablet_output(int *ret, int *nameid, int *sepid, int *bids, void **s);
tablet_export void TABshowHeader(Tablet * t);
tablet_export void TABshowRow(Tablet * t);
tablet_export void TABshowRange(Tablet * t, lng first, lng last);

static void makeTableSpace(int rnr, unsigned int acnt);
static str bindVariable(Tablet * t, unsigned int anr, str nme, int tpe, ptr val, int *k);
static void clearTable(Tablet * t);
static int isScalarVector(Tablet * t);
static int isBATVector(Tablet * t);

static void TABshowPage(Tablet * t);
static int setTabwidth(Column * c);

#define LINE(s, X)     { int n=(int)(X)-1; stream_write(s, "#", 1, 1); while(--n>0) \
	                            stream_write(s, "-", 1, 1); \
	                            stream_printf(s, "#\n"); }
#define TABS(s, X)     { int n=(int)(X); while(n-->0) stream_printf(s, "\t");  }
@+
The table formatting information is stored in a system wide table.
Access is granted to a single client thread only.
The table structure depends on the columns to be printed,
it will be dynamically extended to accommodate the space.
@c
static int tablet_debug = 0;
static Tablet *tableReports[MAL_MAXCLIENTS];


static void
TABformatPrepare(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;
	Tablet *t;
	int anr = 0, i, tpe, k=0;
	ptr val;

	makeTableSpace(rnr, pci->argc - pci->retc);
	t = tableReports[rnr];
	if (t->rlbrk == 0)
		t->rlbrk = GDKstrdup("[ ");
	if (t->rrbrk == 0)
		t->rrbrk = GDKstrdup("]");
	if (t->sep == 0)
		t->sep = GDKstrdup("\t");
	t->rowwidth = strlen(t->rlbrk) + strlen(t->rrbrk) - 2;

	for (i = pci->retc; i < pci->argc; anr++, i++) {
		/* The type should be taken from the stack ! */
		tpe = stk->stk[pci->argv[i]].vtype;
		val = (ptr) getArgReference(stk, pci, i);
		bindVariable(t, anr, getArgName(mb, pci, i), tpe, val, &k);
	}
	t->nr_attrs = anr;
	t->fd = c->fdout;
	t->pivot = 0;
}

str
TABsetFormat(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	TABformatPrepare(mb, stk, pci);
	return MAL_SUCCEED;
}

str
TABheader(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	TABformatPrepare(mb, stk, pci);
	TABshowHeader(tableReports[rnr]);
	return MAL_SUCCEED;
}

str
TABdisplayTable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;
	Tablet *t;

	TABheader(mb, stk, pci);
	t = tableReports[rnr];
	if (!isBATVector(t))
		throw(MAL, "tablet.print", "Only aligned BATs expected");
	else {
		t->pageLimit = 20;
		t->firstrow = t->lastrow = 0;
		TABshowPage(t);
	}
	return MAL_SUCCEED;
}

str
TABdisplayRow(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;
	Tablet *t;

	TABheader(mb, stk, pci);
	t = tableReports[rnr];
	if (!isScalarVector(t))
		throw(MAL, "tablet.print", "Only scalars expected");
	else
		TABshowRow(t);
	if (t->tbotbrk == 0) {
		LINE(t->fd, t->rowwidth);
	} else
		stream_write(t->fd, t->tbotbrk, 1, strlen(t->tbotbrk));
	return MAL_SUCCEED;
}

str
TABpage(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;
	Tablet *t;

	TABformatPrepare(mb, stk, pci);
	t = tableReports[rnr];
	if (t->ttopbrk == 0) {
		LINE(t->fd, t->rowwidth);
	} else
		stream_write(t->fd, t->ttopbrk, 1, strlen(t->ttopbrk));
	if (!isBATVector(t))
		throw(MAL, "tablet.print", "Only aligned BATs expected");
	else {
		t->pageLimit = 20;
		t->firstrow = t->lastrow = 0;
		TABshowPage(t);
	}
	return MAL_SUCCEED;
}

str
TABsetProperties(int *ret, str *prop)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	if (tableReports[rnr] == 0)
		throw(MAL, "tablet.properties", "Format definition missing");
	CLEAR(tableReports[rnr]->properties);
	tableReports[rnr]->properties = !strNil(*prop) ? GDKstrdup(*prop) : 0;
	return MAL_SUCCEED;
}

str
TABdump(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	throw(MAL, "tablet.report", "Not yet implemented");
}

str
TABfinishReport(int *ret)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	if (tableReports[rnr] == 0)
		throw(MAL, "tablet.finish", "Header information missing");
	clearTable(tableReports[rnr]);
	GDKfree(tableReports[rnr]);
	tableReports[rnr] = 0;
	return MAL_SUCCEED;
}


str
TABsetStream(int *ret, stream **s)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	if (tableReports[rnr] == 0)
		throw(MAL, "tablet.setStream", "Header information missing");
	tableReports[rnr]->fd = *s;
	return MAL_SUCCEED;
}

str
TABsetPivot(int *ret, int *bid)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;
	BAT *b;

	(void) ret;		/* fool compiler */
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "tablet.setPivot", "Pivot BAT missing");
	}

	tableReports[rnr]->pivot = b;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
TABsetDelimiter(int *ret, str *sep)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	if (tableReports[rnr] == 0)
		throw(MAL, "tablet.setDelimiters", "Header information missing");
	tableReports[rnr]->sep = !strNil(*sep) ? GDKstrdup(*sep) : 0;
	return MAL_SUCCEED;
}

str
TABsetColumn(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	throw(MAL, "tablet.setColumn", "Not yet implemented");
}

str
TABsetColumnName(int *ret, int *idx, str *s)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	tableReports[rnr]->columns[*idx].name = !strNil(*s) ? GDKstrdup(*s) : 0;
	return MAL_SUCCEED;
}

str
TABsetTableBracket(int *ret, str *lbrk, str *rbrk)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, MAXARG);
	tableReports[rnr]->ttopbrk = !strNil(*lbrk) ? GDKstrdup(*lbrk) : 0;
	tableReports[rnr]->tbotbrk = !strNil(*rbrk) ? GDKstrdup(*rbrk) : 0;
	return MAL_SUCCEED;
}

str
TABsetRowBracket(int *ret, str *lbrk, str *rbrk)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, MAXARG);
	tableReports[rnr]->rlbrk = !strNil(*lbrk) ? GDKstrdup(*lbrk) : 0;
	tableReports[rnr]->rrbrk = !strNil(*rbrk) ? GDKstrdup(*rbrk) : 0;
	return MAL_SUCCEED;
}

str
TABsetColumnBracket(int *ret, int *idx, str *lbrk, str *rbrk)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	tableReports[rnr]->columns[*idx].lbrk = !strNil(*lbrk) ? GDKstrdup(*lbrk) : 0;
	tableReports[rnr]->columns[*idx].rbrk = !strNil(*rbrk) ? GDKstrdup(*rbrk) : 0;
	return MAL_SUCCEED;
}

str
TABsetColumnNull(int *ret, int *idx, str *nullstr)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	tableReports[rnr]->columns[*idx].nullstr = !strNil(*nullstr) ? GDKstrdup(*nullstr) : 0;
	return MAL_SUCCEED;
}

str
TABsetColumnWidth(int *ret, int *idx, int *width)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	tableReports[rnr]->columns[*idx].maxwidth = *width;
	return MAL_SUCCEED;
}

str
TABsetColumnPosition(int *ret, int *idx, int *first, int *width)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;
	(void) first;		/* fool compiler */
	tableReports[rnr]->columns[*idx].fieldwidth = *width;
	tableReports[rnr]->columns[*idx].fieldstart = *width;
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	return MAL_SUCCEED;
}

str
TABsetColumnDecimal(int *ret, int *idx, int *scale, int *prec)
{
	Client c = MCgetClient();
	int rnr = c - mal_clients;

	(void) ret;		/* fool compiler */
	makeTableSpace(rnr, (*idx >= MAXARG ? *idx : MAXARG));
	if (*prec > *scale)
		throw(MAL, "tablet.setColumnDecimal", "Illegal range");
	tableReports[rnr]->columns[*idx].precision = *prec;
	tableReports[rnr]->columns[*idx].scale = *scale;
	return MAL_SUCCEED;
}

str
TABfirstPage(int *ret)
{
	(void) ret;		/* fool compiler */
	throw(MAL, "tablet.firstPage", "Not yet implemented");
}

str
TABlastPage(int *ret)
{
	(void) ret;		/* fool compiler */
	throw(MAL, "tablet.lastPage", "Not yet implemented");
}

str
TABnextPage(int *ret)
{
	(void) ret;		/* fool compiler */
	throw(MAL, "tablet.nextPage", "Not yet implemented");
}

str
TABprevPage(int *ret)
{
	(void) ret;		/* fool compiler */
	throw(MAL, "tablet.prevPage", "Not yet implemented");
}

str
TABgetPage(int *ret, int *pnr)
{
	(void) ret;
	(void) pnr;		/* fool compiler */
	throw(MAL, "tablet.getPage", "Not yet implemented");
}

str
TABgetPageCnt(int *ret)
{
	(void) ret;		/* fool compiler */
	throw(MAL, "tablet.getPageCnt", "Not yet implemented");
}

static ptr
bun_tail(BAT *b, size_t nr)
{
	REGISTER size_t _i = BUNindex((b), BUNfirst((b)));

	return (ptr) BUNtail(b, BUNptr(b, _i + nr));
}


static BAT *
void_bat_create(int adt, size_t nr)
{
	BAT *b = BATnew(TYPE_void, adt, BATTINY);
	BAT *bm = NULL;

	/* check for correct structures */
	if (b == NULL)
		return b;
	if (BATmirror(b))
		BATseqbase(b, 0);
	if (nr > (size_t) REMAP_PAGE_MAXSIZE)
        	BATmmap(b, STORE_MMAP, STORE_MMAP, STORE_MMAP);
	if (nr > BATTINY && adt)
		b = BATextend(b, nr);

	/* disable all properties here */
	bm = BBP_cache(-b->batCacheid);
	b->tsorted = FALSE;
	b->T->nosorted = 0;
	b->tdense = FALSE;
	b->T->nodense = 0;
	b->tkey = bm->hkey = FALSE;
	b->T->nokey[0] = 0;
	b->T->nokey[1] = 1;
	return b;
}

static char *
sep_dup(char *sep)
{
	size_t len = strlen(sep);
	char *res = GDKmalloc(len*2 + 1), *result = res;
	char *end = sep + len;

	while (sep < end) {
		if (*sep == '\\') {
			++sep;
			switch (*sep++) {
			case 'r':
				*res++ = '\r';
				break;
			case 'n':
				*res++ = '\n';
				break;
			case 't':
				*res++ = '\t';
				break;
			}
		} else {
			*res++ = *sep++;
		}
	}
	*res = '\0';
	return result;
}


ptr *
TABLETstrFrStr(Column *c, char *s, char *e)
{
	int len = (int) (e - s + 1); /* 64bit: should check for overflow */

	if (c->len < len){
		c->len = len;
		c->data = GDKrealloc(c->data,len); 
	}

	if (s == e) {
		*(char*)c->data = 0;
	} else if (GDKstrFromStr(c->data, (unsigned char *) s, e - s) < 0) {
		return NULL;
	}
	return c->data;
}

ptr *
TABLETadt_frStr(void *extra, int type, char *s, char *e, char quote)
{
	Column *c = extra;

	if (s == NULL || (!quote && strcmp(s, "nil") == 0)) {
        	memcpy(c->data, ATOMnilptr(type), c->nillen);
	} else if (type == TYPE_str) {
		return TABLETstrFrStr(c, s, e);
	} else {
		(void)(*BATatoms[type].atomFromStr)(s, &c->len, (ptr) &c->data);
	}
	return c->data;
}

int
TABLETadt_toStr(void *extra, char **buf, int *len, int type, ptr a)
{
	(void) extra;		/* fool compiler */
	if (type == TYPE_str) {
		char *dst, *src = a;
		int l;

		if (GDK_STRNIL(src)) {
			src = "nil";
		}
		l = strlen(src);
		if (l + 3 > *len) {
			GDKfree(buf);
			*len = 2 * l + 3;
			*buf = GDKmalloc(*len);
			memset(*buf,0,*len);
		}
		dst = *buf;
		dst[0] = '"';
		strncpy(dst + 1, src, l);
		dst[l + 1] = '"';
		dst[l + 2] = 0;
		return l + 2;
	} else {
		return (*BATatoms[type].atomToStr) (buf, len, a);
	}
}

static size_t
create_loadformat(Tablet * as, BAT *names, BAT *seps, BAT *types)
{
	size_t p;
	size_t nr_attrs = BATcount(names);
	Column *fmt = as->format = (Column *) GDKmalloc(sizeof(Column) * (nr_attrs + 1));

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); *//* i.e. it fits */
	for (p = 0; p < nr_attrs; p++) {
		fmt[p].name = (char *) bun_tail(names, p);
		fmt[p].sep = sep_dup((char *) bun_tail(seps, p));
		fmt[p].seplen = (int) strlen(fmt[p].sep);
		fmt[p].type = (char *) bun_tail(types, p);
		fmt[p].adt = ATOMindex(fmt[p].type);
		if (fmt[p].adt <= 0) {
			GDKerror("create_loadformat: %s has unknown type %s (using str instead).\n", fmt[p].name, fmt[p].name);
			fmt[p].adt = TYPE_str;
		}
		fmt[p].tostr = &TABLETadt_toStr;
		fmt[p].frstr = &TABLETadt_frStr;
		fmt[p].extra = fmt+p;
		fmt[p].len = fmt[p].nillen = 
			ATOMlen(fmt[p].adt, ATOMnilptr(fmt[p].adt));
		fmt[p].data = GDKmalloc(fmt[p].len);
		if (tablet_debug)
			stream_printf(GDKerr, "%s\n", fmt[p].name);
	}
	return as->nr_attrs;
}

static
size_t
create_dumpformat(Tablet * as, BAT *names, BAT *seps, BAT *bats)
{
	size_t p;
	size_t nr_attrs = BATcount(bats);
	Column *fmt = as->format = (Column *) GDKmalloc(sizeof(Column) * (nr_attrs + 1));

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); *//* i.e. it fits */
	for (p = 0; p < nr_attrs; p++) {
		BAT *b = (BAT *) BATdescriptor(*(bat *) bun_tail(bats, p));

		if (!b)
			return ~(size_t) 0;	/* (size_t)(-1) */
		fmt[p].name = NULL;
		if (names)
			fmt[p].name = (char *) bun_tail(names, p);
		fmt[p].sep = sep_dup((char *) bun_tail(seps, p));
		fmt[p].seplen = (int) strlen(fmt[p].sep);
		fmt[p].type = ATOMname(b->ttype);
		fmt[p].adt = (b)->ttype;
		fmt[p].tostr = &TABLETadt_toStr;
		fmt[p].frstr = &TABLETadt_frStr;
		fmt[p].extra = fmt+p;
		fmt[p].data = NULL;
		fmt[p].len = 0;
		fmt[p].nillen = 0;
		BBPunfix(b->batCacheid);
	}
	return as->nr_attrs;
}

void
TABLETdestroy_format(Tablet * as)
{
	size_t p;
	Column *fmt = as->format;

	for (p = 0; p < as->nr_attrs; p++) {
		if (fmt[p].c)
			BBPunfix(fmt[p].c->batCacheid);
		GDKfree(fmt[p].sep);
		if (fmt[p].data)
			GDKfree(fmt[p].data);
	}
	GDKfree(fmt);
}

size_t
TABLETassign_BATs(Tablet * as, BAT *bats)
{
	Column *fmt = as->format;
	size_t res = as->nr;
	size_t i;

	for (i = 0; i < as->nr_attrs; i++) {
		BAT *b = (BAT *) BATdescriptor(*(bat *) bun_tail(bats, i));

		fmt[i].c = (b);
		if (res == ~(size_t) 0 || BATcount(fmt[i].c) < res)
			res = BATcount(fmt[i].c);
	}
	as->nr = res;
	return res;
}

static oid
check_BATs(Tablet * as)
{
	Column *fmt = as->format;
	size_t i = 0;
	size_t cnt;
	oid base;

	if (fmt[i].c == NULL)
		i++;
	cnt = BATcount(fmt[i].c);
	base = fmt[i].c->hseqbase;

	if (!BAThdense(fmt[i].c) || as->nr != cnt )
		return oid_nil;

	for (i = 0; i < as->nr_attrs; i++) {
		BAT *b;
		size_t offset;

		b = fmt[i].c;
		if (b == NULL)
			continue;
		offset = BUNindex(b, BUNfirst(b)) + as->offset;

		if (BATcount(b) != cnt || !BAThdense(b) || b->hseqbase != base)
			return oid_nil;

		fmt[i].p = BUNptr(b, offset);
	}
	return base;
}

int
TABLETcreate_bats(Tablet * as, size_t est)
{
	Column *fmt = as->format;
	size_t i;

	for (i = 0; i < as->nr_attrs; i++) {
		fmt[i].c = void_bat_create(fmt[i].adt, est);
		if (!fmt[i].c) {
			GDKerror("TABLETcreate_bats: Failed to create bat of size " SZFMT "\n", as->nr);
			return -1;
		}
	}
	return 0;
}

BAT *
TABLETcollect_bats(Tablet * as)
{
	BAT *bats = BATnew(TYPE_str, TYPE_bat, as->nr_attrs);
	Column *fmt = as->format;
	size_t i;
	size_t cnt = BATcount(fmt[0].c);

	if (bats == NULL)
		return NULL;
	for (i = 0; i < as->nr_attrs; i++) {
		BUNins(bats, (ptr) fmt[i].name, (ptr) &fmt[i].c->batCacheid, FALSE);
		BATsetaccess(fmt[i].c, BAT_READ);
		BATpropcheck(fmt[i].c, BATPROPS_ALL);
		if (cnt != BATcount(fmt[i].c)) {
			GDKerror("Error: counts are not equal\n");
			return NULL;
		}
	}
	return bats;
}

#define myisspace(s)  (s == ' ' || s == '\t' || s == '\n')

static INLINE char *
lstrip(char *s)
{
	while (myisspace((int) *s)) 
		s++;
	return s;
}

static INLINE char *
rstrip(char *e)
{
	e--;
	while (myisspace((int) *e)) 
		e--;
	e++;
	if (e && *e) 
		*e = 0;
	return e;
}

static INLINE char *
find_quote(char *s, char quote)
{
	while (*s != quote)
		s++;
	return s;
}

static INLINE char *
rfind_quote(char *s, char quote)
{
	while (*s != quote)
		s--;
	return s;
}

static INLINE int
insert_val(Column * fmt, char *s, char *e, char quote, ptr key, str *err)
{
	char *end = e;
	char bak = *e;
	ptr *adt;
	char buf[BUFSIZ];

	if (quote) {
		/* string needs the quotes included */
		s = find_quote(s, quote);
		if (!s) {
			snprintf(buf,BUFSIZ, "quote '%c' expected but not found in \"%s\" from line %d\n", quote, s, (int) BATcount(fmt->c));
			*err= GDKstrdup(buf);
			return -1;
		}
		s++;
		e = rfind_quote(e, quote);
		*e = 0;
	} else if (e > s) {
		s = lstrip(s);
		e = rstrip(e);
	}
	if (e < s) 
		e = s;
	adt = fmt->frstr(fmt->extra, fmt->adt, s, e, quote);
	*end = bak;

	if (!adt) {
		snprintf(buf,BUFSIZ, "value %s from line %d not inserted\n", 
				s, (int) BATcount(fmt->c));
		*err= GDKstrdup(buf);
		return -1;
	}

	/* key maybe NULL but thats not a problem, as long as we have void */
	bunfastins(fmt->c, key, adt);
	return 0;
bunins_failed:
	return -1;
}

static INLINE char *
skip_string(char *s, char quote)
{
	int esc = 0;

	while (*s) {
		if (*s == '\\' && !esc)
			esc = 1;
		else if (*s == quote && !esc)
			break;
		else
			esc = 0;
		s++;
	}
	if (*s)
		s++;
	else
		return NULL;
	return s;
}

INLINE int
insert_line(Tablet * as, char *line, ptr key)
{
	int res = 0;
	Column *fmt = as->format;
	char *s, *e = 0, quote = 0;
	size_t i;
	char errmsg[BUFSIZ];

	for (i = 0; i < as->nr_attrs && res == 0; i++) {
		e = 0;
		s = line;

		/* skip leading spaces */
		while (myisspace((int) (*line)))
			line++;

		/* recognize fields starting with a quote */
		if ( (*line == '\"' || *line == '\'') && 
	             (line == s || *(line - 1) != '\\')) {
			quote = *line;
			line++;
			line = skip_string(line, quote);
			if (!line) {
				snprintf(errmsg,BUFSIZ, "End of string (%c) missing "
					"in %s at line %d\n", quote, s, (int) BATcount(fmt->c));
				as->error= GDKstrdup(errmsg);
				return -1;
			}
		}

		/* skip until separator */
		while (*line) {
			if (*line == *(fmt[i].sep) &&
			    (fmt[i].sep[1] == 0 || 
			     strncmp(fmt[i].sep, line, fmt[i].seplen) == 0)) {
				e = line;
				break;
			}
			line++;
		}
		if (!e && i == (as->nr_attrs-1))
			e = line;
		if (e) {
			res |= insert_val(&fmt[i], s, e, quote, key, &as->error);
			quote = 0;
			line = e + fmt[i].seplen;
		} else {
			snprintf(errmsg,BUFSIZ, "missing sep %s line %d field %d\n", 
				fmt->sep, (int)BATcount(fmt->c), (int)i);
			as->error= GDKstrdup(errmsg);
			return -1;
		}
	}
	return res;
}

static int
TABLET_error(stream *s)
{
	if (!stream_errnr(GDKerr)) {
		char *err = stream_error(s);

		stream_printf(GDKerr, "Stream error %s\n", err);
		/* use free as stream allocates out side GDK */
		if (err)
			free(err);
	}
	return -1;
}

static INLINE int
dump_line(char **buf, int *len, Column * fmt, stream *fd, size_t nr_attrs, size_t id)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		Column *f;
		char *p;
		int l;

		f = fmt + i;
		if (f->c) {
			p = (char *) bun_tail(f->c, id);

			l = f->tostr(f->extra, buf, len, f->adt, p);
			if (stream_write(fd, *buf, 1, l) != l)
				return TABLET_error(fd);
		}
		if (stream_write(fd, f->sep, 1, f->seplen) != f->seplen)
			return TABLET_error(fd);
	}
	return 0;
}

#define MB 1024*1024
static INLINE int
output_line(char **buf, int *len, Column * fmt, stream *fd, size_t nr_attrs, ptr id)
{
	size_t i;
	char lbuf[MB]; /* collect first before write */
	int k=0;

	for (i = 0; i < nr_attrs; i++) {
		if (fmt[i].c == NULL)
			continue;
		fmt[i].p = BUNfnd(fmt[i].c, id);

		if (fmt[i].p == 0)
			break;
	}
	lbuf[k]=0;
	if (i == nr_attrs) {
		for (i = 0; i < nr_attrs; i++) {
			Column *f;
			ptr p;
			int l=0;

			f = fmt + i;
			if (f->c) {
				p = BUNtail(f->c, f->p);
				l = f->tostr(f->extra, buf, len, f->adt, p);
			}
			if( k+f->seplen+l+1 >=MB){
				if( stream_write(fd, lbuf, 1, k) != l)
					return TABLET_error(fd);
				l=0;
			}
			if( f->c)
				strcat(lbuf+k,*buf);
			strcat(lbuf+k,f->sep);
			k+= strlen(lbuf+k);
		}
	}
	if( k && stream_write(fd, lbuf, 1, k) != k)
				return TABLET_error(fd);
	return 0;
}

static INLINE int
output_line_dense(char **buf, int *len, Column * fmt, stream *fd, size_t nr_attrs)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		Column *f = fmt + i;

		if (f->c) {
			char *p = BUNtail(f->c, f->p);
			int l = f->tostr(f->extra, buf, len, f->adt, p);

			if (stream_write(fd, *buf, 1, l) != l)
				return TABLET_error(fd);
			f->p = BUNnext(f->c, f->p);
		}
		if (stream_write(fd, f->sep, 1, f->seplen) != f->seplen)
			return TABLET_error(fd);
	}
	return 0;
}

static INLINE int
output_line_lookup(char **buf, int *len, Column * fmt, stream *fd, size_t nr_attrs, size_t id)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		Column *f = fmt + i;

		if (f->c) {
			char *p = BUNtail(f->c, BUNptr(f->c,
						   id +BUNindex(f->c, BUNfirst(f->c))));
			int l = f->tostr(f->extra, buf, len, f->adt, p);

			if (stream_write(fd, *buf, 1, l) != l)
				return TABLET_error(fd);
		}
		if (stream_write(fd, f->sep, 1, f->seplen) != f->seplen)
			return TABLET_error(fd);
	}
	return 0;
}

static INLINE int
read_more(bstream *in, stream *out, size_t n)
{
	if (out) {
		do {
			/* query is not finished ask for more */
			/* we need more query text */
			if (bstream_next(in) < 0)
				return EOF;
			if (in->eof) {
				if (out && stream_write(out, PROMPT2, sizeof(PROMPT2) - 1, 1) == 1)
					stream_flush(out);
				in->eof = 0;
				/* we need more query text */
				if (bstream_next(in) < 0)
					return EOF;
			}
		} while (in->len <= in->pos);
	} else if(bstream_read(in, n) <= 0) {
		return EOF;
	}
	return 1;
}


ssize_t
TABLETload_file(Tablet * as, bstream *b, stream *out)
{
	int res = 0, done = 0;
	size_t i = 0;
	char *sep = as->format[as->nr_attrs - 1].sep;
	int seplen = as->format[as->nr_attrs - 1].seplen;

	if (tablet_debug)
		stream_printf(GDKerr, "TABLETload_file\n");

	while ((b->pos < b->len || !b->eof) && res == 0 && (as->nr == ~(size_t) 0 || i < as->nr)) {
		char *s, *end;

		if (b->pos >= b->len && read_more(b, out, b->size - (b->len - b->pos)) == EOF) {
			if (as->nr != ~(size_t)0 && i < as->nr) {
				res = 1; 
				if (b->len > b->pos) {
					GDKerror("TABLETload_file: read error (after loading %d records)\n", BATcount(as->format[0].c));
					res = -1;
				}
			}
			break;
		}
		end = b->buf + b->len;
		s = b->buf + b->pos;
		*end = '\0';
		done = 0;
		while (s < end) {
			char *e = strstr(s, sep);

			if (e) {
				*e = '\0';
				if (insert_line(as, s, NULL) < 0) {
					s = e + seplen;
					b->pos = (s - b->buf);
					res = -1;
					break;
				}
				s = e + seplen;
				done = 1;
			} else {
				if (!done) {	/* nothing found in current buf
						 * ie. need to enlarge
						 */
					size_t size = b->size;

					if (b->pos == 0 || (b->len - b->pos > b->size >> 1))
						size <<= 4;
					if (read_more(b, out, size) == EOF) {
						/* some data left? */
						res = 1; 
						if (b->len > b->pos &&
						    insert_line(as, s, NULL) < 0) {
								GDKerror(as->error);
								as->error=0;
								GDKerror("TABLETload_file: read error "
										"(after loading %d records)\n",
										BATcount(as->format[0].c));
							res = -1;
						}
						break;
					}
					end = b->buf + b->len;
					s = b->buf + b->pos;
					*end = '\0';
					continue;
				}
				break;
			}
			b->pos = (s - b->buf);
			i++;
			if (tablet_debug && (i % 100000) == 0)
				stream_printf(GDKerr, "inserted " SZFMT "\n", i);
			if (as->nr != ~(size_t) 0 && i >= as->nr)
				break;
		}
	}
	as->nr = i;
	if (res < 0)
		return res;
	return (ssize_t) as->nr;
}

static int
dump_file(Tablet * as, stream *fd)
{
	size_t i = 0;
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);

	for (i = 0; i < as->nr; i++) {
		if (dump_line(&buf, &len, as->format, fd, as->nr_attrs, i) < 0) {
			GDKfree(buf);
			return -1;
		}
		if (tablet_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
	}
	GDKfree(buf);
	return 0;
}

static int
output_file_default(Tablet * as, BAT *order, stream *fd)
{
	int len = BUFSIZ, res = 0;
	char *buf = GDKmalloc(len);
	BUN p, q;
	size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for (q = BUNptr(order, offset + as->nr), p = BUNptr(order, offset); p < q; p = BUNnext(order, p)) {
		ptr h = BUNhead(order, p);

		if ((res = output_line(&buf, &len, as->format, fd, as->nr_attrs, h)) < 0) {
			GDKfree(buf);
			return res;
		}
		i++;
		if (tablet_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
	}
	GDKfree(buf);
	return res;
}

int
output_file_dense(Tablet * as, stream *fd)
{
	int len = BUFSIZ, res = 0;
	char *buf = GDKmalloc(len);
	size_t i = 0;

	for (i = 0; i < as->nr; i++) {
		if ((res = output_line_dense(&buf, &len, as->format, fd, as->nr_attrs)) < 0) {
			GDKfree(buf);
			return res;
		}
		if (tablet_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
	}
	GDKfree(buf);
	return res;
}

static int
output_file_ordered(Tablet * as, BAT *order, stream *fd, oid base)
{
	int len = BUFSIZ, res = 0;
	char *buf = GDKmalloc(len);
	BUN p, q;
	size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for (q = BUNptr(order, offset + as->nr), p = BUNptr(order, offset); p < q; p = BUNnext(order, p)) {
		size_t h = *(oid *) BUNhead(order, p) - base;

		if ((res = output_line_lookup(&buf, &len, as->format, fd, as->nr_attrs, h)) < 0) {
			GDKfree(buf);
			return res;
		}
		if (tablet_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
	}
	GDKfree(buf);
	return res;
}

#define SIZE 1*1024*1024
@-
Estimate the size of a BAT to avoid multiple extends.
@c
static size_t
estimator(char *datafile){
	long size;
	char buf[BUFSIZ+1],*s=buf;
	size_t nr=0;
	FILE *f;
	f= fopen(datafile,"r");
	if(f == NULL) return 0;

	buf[BUFSIZ]=0;
	if( (nr = fread(buf, 0, BUFSIZ,f)) >0){
		buf[nr] = 0;
		nr = 0;
		for(s = buf; *s; s++)
			if (*s == '\n')
				nr++;
	} else
		nr = 0;
	fseek(f,0L,SEEK_END);
	size= ftell(f);
	fclose(f);
	if( nr == 0) 
		return size/BUFSIZ;
	return size/BUFSIZ/nr;
}

BAT *
TABLETload(BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr)
{
	BAT *res;
	stream *s = open_rastream(datafile);
	bstream *b = NULL;
	size_t est = nr;

	if (s == NULL || stream_errnr(s)) {
		GDKerror("could not open file %s\n", datafile);
		if (s) {
			stream_destroy(s);
		}
		return NULL;
	}
	if (nr == ~(size_t) 0)
		est = estimator(datafile);
	res = TABLETinput(names, seps, types, b = bstream_create(s, SIZE), NULL, nr, est);
	bstream_destroy(b);
	stream_close(s);
	stream_destroy(s);
	return res;
}

BAT *
TABLETinput(BAT *names, BAT *seps, BAT *types, bstream *s, stream *out, size_t nr, size_t est)
{
	BAT *bats = NULL;
	Tablet as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_loadformat(&as, names, seps, types) != ~(size_t) 0 && TABLETcreate_bats(&as, est) >= 0) {
		if (TABLETload_file(&as, s, out) >= 0)
			bats = TABLETcollect_bats(&as);
	}
	TABLETdestroy_format(&as);
	return bats;
}

void
TABLETdump(BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr)
{
	Tablet as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_dumpformat(&as, names, seps, bats) != ~(size_t) 0 && TABLETassign_BATs(&as, bats) != ~(size_t) 0) {
		stream *s = open_wastream(datafile);

		if (s != NULL && !stream_errnr(s) && dump_file(&as, s) >= 0) {
			stream_printf(GDKerr, "saved in %s\n", datafile);
		}
		if (s == NULL || stream_errnr(s)) {
			GDKerror("could not open file %s\n", datafile);
		} else {
			stream_close(s);
		}
		stream_destroy(s);
	}
	TABLETdestroy_format(&as);
}

int
TABLEToutput_file(Tablet * as, BAT *order, stream *s)
{
	oid base = oid_nil;
	size_t maxnr = BATcount(order);

	/* only set nr if it is zero or lower (bogus) to the maximum value
	 * possible (BATcount), if already set within BATcount range,
	 * preserve value such that for instance SQL's reply_size still
	 * works
	 */
	if (as->nr == ~(size_t)0 || as->nr > maxnr)
		as->nr = maxnr;

	if ((base = check_BATs(as)) != oid_nil) {
		if (BAThdense(order) && order->hseqbase == base)
			return output_file_dense(as, s);
		else
			return output_file_ordered(as, order, s, base);
	} else {
		return output_file_default(as, order, s);
	}
}

size_t
TABLEToutput(BAT *order, BAT *seps, BAT *bats, stream *s)
{
	int res = 0;
	Tablet as;

	as.nr_attrs = 0;
	as.nr = ~(size_t) 0;
	if (create_dumpformat(&as, NULL, seps, bats) != ~(size_t) 0 && TABLETassign_BATs(&as, bats) != ~(size_t) 0) {
		res = TABLEToutput_file(&as, order, s);
	}
	TABLETdestroy_format(&as);
	if (res >= 0)
		return as.nr;
	return ~(size_t) 0;
}

static void
tablet_load(BAT **bats, BAT *names, BAT *seps, BAT *types, str datafile, int *N)
{
	size_t nr = ~(size_t)0;

	if (*N >= 0)
		nr = *N;
	*bats = TABLETload(names, seps, types, datafile, nr);
}
static void
tablet_input(BAT **bats, BAT *names, BAT *seps, BAT *types, void **s, int *N)
{
	bstream *b = NULL;
	size_t nr = ~(size_t)0;
	size_t est = 0;

	if (*N >= 0) {
		nr = *N;
		est = nr;
	}
	*bats = TABLETinput(names, seps, types, b = bstream_create(*(stream **) s, SIZE), NULL, nr, est);
	bstream_destroy(b);
}

void
tablet_dump(BAT *names, BAT *seps, BAT *bats, str datafile, int *nr)
{
	TABLETdump(names, seps, bats, datafile, *nr);
}

static void
tablet_output(BAT *order, BAT *seps, BAT *bats, void **s)
{
	(void) TABLEToutput(order, seps, bats, *(stream **) s);
}

@+ MAL interface
@c
str
CMDtablet_load(int *ret, int *nameid, int *sepid, int *typeid, str *filename, int *nr)
{
	BAT *names, *seps, *types, *bn;

	if ((names = BATdescriptor(*nameid)) == NULL) {
		throw(MAL, "tablet.load", "BAT missing");
	}
	if ((seps = BATdescriptor(*sepid)) == NULL) {
		BBPunfix(names->batCacheid);
		throw(MAL, "tablet.load", "BAT missing");
	}
	if ((types = BATdescriptor(*typeid)) == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		throw(MAL, "tablet.load", "BAT missing");
	}

	tablet_load(&bn, names, seps, types, *filename, nr);
	if (bn == NULL)
		throw(MAL, "tablet.load", "Failed to load");
	BBPincref(*ret, TRUE);
	*ret = bn->batCacheid;
	BBPunfix(names->batCacheid);
	BBPunfix(seps->batCacheid);
	BBPunfix(types->batCacheid);
	return MAL_SUCCEED;
}

str
CMDtablet_dump(int *ret, int *nameid, int *sepid, int *bids, str *filename, int *nr)
{
	BAT *names, *seps, *bats;

	(void) ret;

	if ((names = BATdescriptor(*nameid)) == NULL) {
		throw(MAL, "tablet.dump", "BAT missing");
	}
	if ((seps = BATdescriptor(*sepid)) == NULL) {
		BBPunfix(names->batCacheid);
		throw(MAL, "tablet.dump", "BAT missing");
	}
	if ((bats = BATdescriptor(*bids)) == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		throw(MAL, "tablet.dump", "BAT missing");
	}

	tablet_dump(names, seps, bats, *filename, nr);
	BBPunfix(names->batCacheid);
	BBPunfix(seps->batCacheid);
	BBPunfix(bats->batCacheid);
	return MAL_SUCCEED;
}

str
CMDtablet_input(int *ret, int *nameid, int *sepid, int *typeid, stream *s, int *nr)
{
	BAT *names, *seps, *types, *bn;

	if ((names = BATdescriptor(*nameid)) == NULL) {
		throw(MAL, "tablet.load", "BAT missing");
	}
	if ((seps = BATdescriptor(*sepid)) == NULL) {
		BBPunfix(names->batCacheid);
		throw(MAL, "tablet.load", "BAT missing");
	}
	if ((types = BATdescriptor(*typeid)) == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		throw(MAL, "tablet.load", "BAT missing");
	}

	tablet_input(&bn, names, seps, types, (void **) s, nr);
	if (bn == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		BBPunfix(types->batCacheid);
		throw(MAL, "tablet.load", "Failed to load");
	}
	BBPincref(*ret, TRUE);
	*ret = bn->batCacheid;
	BBPunfix(names->batCacheid);
	BBPunfix(seps->batCacheid);
	BBPunfix(types->batCacheid);
	return MAL_SUCCEED;
}

str
CMDtablet_output(int *ret, int *nameid, int *sepid, int *bids, void **s)
{
	BAT *names, *seps, *bats;
	(void) ret;

	if ((names = BATdescriptor(*nameid)) == NULL) {
		throw(MAL, "tablet.output", "BAT missing");
	}
	if ((seps = BATdescriptor(*sepid)) == NULL) {
		BBPunfix(names->batCacheid);
		throw(MAL, "tablet.output", "BAT missing");
	}
	if ((bats = BATdescriptor(*bids)) == NULL) {
		BBPunfix(names->batCacheid);
		BBPunfix(seps->batCacheid);
		throw(MAL, "tablet.output", "BAT missing");
	}
	tablet_output(names, seps, bats, s);
	BBPunfix(names->batCacheid);
	BBPunfix(seps->batCacheid);
	BBPunfix(bats->batCacheid);
	return MAL_SUCCEED;
}


@mil

PROC test_tablet() : void := {

	#tablet_debug(1);

	fp := fopen ( "format", "w+" );
	fputs( "key,\",\",str\n", fp);
	fputs( "a_io_test,\"\\n\",dbl\n", fp);
	fclose( fp );

	fp := fopen ( "data", "w+" );
	fputs( "test, 0.12345\n", fp);
	fputs( "second line, 9.0\n", fp);
	fclose( fp );

	bats := load_data(load_format("format"),"data",10);
	bats.print;
	a := bats.find("key").reverse().join( bats.find("a_io_test") );
	a.print;
	dump_data(load_format("format"), bats, "data", -1);

	fp := fopen ( "data", "r" );
	s := fgets( fp ); 
	s.print();
	fclose( fp );
}

@+ Tablet report
The routines to manage the table descriptor
@c
static void
clearColumn(Column * c)
{
	CLEAR(c->batname);
	CLEAR(c->name);
	CLEAR(c->sep);
	c->width = 0;
	c->tabs = 0;
	c->c = c->p = 0;
	/* keep nullstr and brackets */
}
static void
clearTable(Tablet * t)
{
	unsigned int i;

	for (i = 0; i < t->nr_attrs; i++)
		clearColumn(t->columns + i);
	CLEAR(t->ttopbrk);
	CLEAR(t->tbotbrk);
	CLEAR(t->rlbrk);
	CLEAR(t->rrbrk);
	CLEAR(t->properties);
	CLEAR(t->title);
	CLEAR(t->footer);
	CLEAR(t->sep);
	t->rowwidth = 0;
	t->nr_attrs = 0;
	t->firstrow = t->lastrow = 0;
	/* keep brackets and stream */
}

@-
Expansion of a table report descriptor should not
mean loosing its content.
@c
static void
makeTableSpace(int rnr, unsigned int acnt)
{
	Tablet *t = 0;

	assert(rnr >= 0 && rnr < MAL_MAXCLIENTS);
	t = tableReports[rnr];
	if (t == 0) {
		int len = sizeof(Tablet) + acnt * sizeof(Column);

		t = tableReports[rnr] = (Tablet *) GDKmalloc(len);
		memset((char *) t, 0, len);
		t->max_attrs = acnt;
	}
	if (t && t->max_attrs < acnt) {
		Tablet *tn;
		int len = sizeof(Tablet) + acnt * sizeof(Column);

		tn = tableReports[rnr] = (Tablet *) GDKmalloc(len);
		memset((char *) tn, 0, len);
		memcpy((char *) tn, (char *) t, sizeof(Tablet) + t->max_attrs * sizeof(Column));
		GDKfree(t);
		tn->max_attrs = acnt;
	}
}

@-
Binding variables also involves setting the default
formatting scheme. These are based on the storage type only
at this point. The variables should be either all BATs
or all scalars. But this is to be checked just before
printing.
@c
static int
isScalarVector(Tablet * t)
{
	unsigned int i;

	for (i = 0; i < t->nr_attrs; i++)
		if (t->columns[i].c)
			return 0;
	return 1;
}
static int
isBATVector(Tablet * t)
{
	unsigned int i, cnt;

	if (t->columns[0].c == 0)
		return 0;
	cnt = BATcount(t->columns[0].c);
	for (i = 0; i < t->nr_attrs; i++)
		if (t->columns[i].c == 0)
			return 0;
		else if (BATcount(t->columns[i].c) != cnt)
			return 0;
	return 1;
}
static str
bindVariable(Tablet * t, unsigned int anr, str nme, int tpe, ptr val, int *k)
{
	Column *c;
	char *buf;
	int tpeStore;

	c = t->columns + anr;
	tpeStore = ATOMstorage(tpe);
	c->type = GDKstrdup(ATOMname(tpeStore));
	c->adt = tpe;
	c->name = GDKstrdup(nme);
	if (c->rbrk == 0)
		c->rbrk = GDKstrdup(",");
	c->width = strlen(nme);	/* plus default bracket(s) */

	if (anr >= t->nr_attrs)
		t->nr_attrs = anr + 1;
	buf = (char *) GDKmalloc(BUFSIZ);
	memset(buf,0,BUFSIZ);

	if (tpe == TYPE_bat) {
		BAT *b;
		int bid = *(int *) val;

		if ((b = BATdescriptor(bid)) == NULL) {
			throw(MAL, "tablet.bindVariable", "Cannot access descriptor");
		}

		c->c = b;
		/* the first column should take care of leader text size */
		if (c->c)
			setTabwidth(c);
	} else if (val) {
		if (ATOMstorage(tpe) == TYPE_str || ATOMstorage(tpe) > TYPE_str)
			val = *(str *) val;	/* V5 */
		(*BATatoms[tpe].atomToStr) (&buf, k, val);
		c->width = MAX(c->width, strlen(buf));
		if (c->lbrk)
			c->width += strlen(c->lbrk);
		if (c->rbrk)
			c->width += strlen(c->rbrk);
	}
	GDKfree(buf);

	c->p = val;
	if (c->scale)
		c->width = c->scale + 2;	/* decimal point  and '-' */
	c->width += (c->rbrk ? strlen(c->rbrk) : 0) + (c->lbrk ? strlen(c->lbrk) : 0);
	if (c->maxwidth && c->maxwidth < c->width)
		c->width = c->maxwidth;
	if (t->columns == c)
		c->width += t->rlbrk ? strlen(t->rlbrk) : 0;
	c->tabs = 1 + (c->width) / 8;
	t->rowwidth += 8 * c->tabs;
	*k = c->width;
	if (c->c)
		BBPunfix(c->c->batCacheid);
	return NULL;
}

@+ Actual printing
@c


void
TABshowHeader(Tablet * t)
{
	unsigned int i;
	char *prop = "name", *p, *q;

	if (t->title)
		stream_write(t->fd, t->title, 1, strlen(t->title));
	else {
		LINE(t->fd, t->rowwidth);
	}

	p = t->properties ? t->properties : prop;
	while (p) {
		q = strchr(p, ',');
		if (q)
			*q = 0;
		stream_write(t->fd, "# ", 1, 2);
		for (i = 0; i < t->nr_attrs; i++) {
			Column *c = t->columns + i;
			unsigned int len;
			str prop = 0;
			int u = 0, v = 0;

			if (strcmp(p, "name") == 0)
				prop = c->name;
			else if (strcmp(p, "type") == 0)
				prop = c->type;
			else if (!isScalar(c) && c->c) {
				if (strcmp(p, "bat") == 0) {
					prop = BBPname(c->c->batCacheid);
				}
				if (strcmp(p, "name") == 0) {
					prop = GDKstrdup(c->c->tident);
				}
				if (strcmp(p, "base") == 0) {
					char buf[BUFSIZ];

					sprintf(buf, SZFMT, (size_t)c->c->hseqbase);
					prop = GDKstrdup(buf);
				}
				if (strcmp(p, "sorted") == 0) {
					if (BATtordered(c->c)&1)
						prop = GDKstrdup("true");
					else
						prop = GDKstrdup("false");
				}
				if (strcmp(p, "dense") == 0) {
					if (BATtdense(c->c))
						prop = GDKstrdup("true");
					else
						prop = GDKstrdup("false");
				}
				if (strcmp(p, "key") == 0) {
					if (c->c->tkey)
						prop = GDKstrdup("true");
					else
						prop = GDKstrdup("false");
				}
				if (strcmp(p, "min") == 0) {
@-
@= setAggr
case TYPE_@1: {
	@1 m;
	char buf[BUFSIZ];
	BAT@2(c->c,&m);
	sprintf(buf,@3,m);
	prop= GDKstrdup(buf);
}
break;
@c
					switch (c->adt) {
						@:setAggr(int,min,"%d")@
						@:setAggr(lng,min,LLFMT)@
						@:setAggr(sht,min,"%d")@
						@:setAggr(dbl,min,"%f")@

					default:
						prop = GDKstrdup("");
					}
				}
				if (strcmp(p, "max") == 0) {
					switch (c->adt) {
						@:setAggr(int,max,"%d")@
						@:setAggr(lng,max,LLFMT)@
						@:setAggr(sht,max,"%d")@
						@:setAggr(dbl,max,"%f")@

					default:
						prop = GDKstrdup("");
					}
				}
			}
			len = prop ? strlen(prop) : 0;
			if (c->maxwidth && len > c->maxwidth)
				len = c->maxwidth;
			if (c->lbrk)
				stream_write(t->fd, c->lbrk, 1, u = strlen(c->lbrk));
			stream_write(t->fd, prop, len, 1);
			if (c->rbrk && i + 1 < t->nr_attrs)
				stream_write(t->fd, c->rbrk, 1, v = strlen(c->rbrk));
			if (c == t->columns)
				len += t->rlbrk ? strlen(t->rlbrk) : 0;
			TABS(t->fd, c->tabs - ((len + u + v) / 8));
			if (prop) {
				GDKfree(prop);
				prop = 0;
			}

		}
		stream_write(t->fd, "# ", 1, 2);
		stream_write(t->fd, p, 1, strlen(p));
		stream_write(t->fd, "\n", 1, 1);
		if (q) {
			*q = ',';
			p = q + 1;
		} else
			p = 0;
	}

	if (t->tbotbrk == 0) {
		LINE(t->fd, t->rowwidth);
	} else
		stream_write(t->fd, t->tbotbrk, 1, strlen(t->tbotbrk));
}

void
TABshowRow(Tablet * t)
{
	unsigned int i = 0;
	unsigned int m = 0;
	int zero = 0;
	char *buf = 0;
	Column *c = t->columns + i;
	unsigned int len;
	int u = 0, v = 0;

	buf = (char *) GDKmalloc(m = t->rowwidth);

	if (t->rlbrk)
		stream_printf(t->fd, "%s", t->rlbrk);
	for (i = 0; i < t->nr_attrs; i++) {
		c = t->columns + i;
		u = 0;
		v = 0;
		if (c->p)
			(*BATatoms[c->adt].atomToStr) (&buf, &zero, c->p);
		m= (unsigned int) zero;
		if (strcmp(buf, "nil") == 0 && c->nullstr && strlen(c->nullstr) < m)
			strcpy(buf, c->nullstr);
		if (c->precision) {
			if (strcmp(buf, "nil") == 0) {
				snprintf(buf, m, "%*s", c->scale + (c->precision ? 1 : 0), "nil");
			} else
				switch (c->adt) {
				case TYPE_int:
				{
					int vi = *(int *) c->p, vj = vi, m = 1;
					int k;

					for (k = c->precision; k > 0; k--) {
						vi /= 10;
						m *= 10;
					}
					snprintf(buf, m, "%*d.%d", c->scale - c->precision, vi, vj % m);
				}
				}
		}
		len = strlen(buf);
		if (c->maxwidth && len > c->maxwidth)
			len = c->maxwidth;
		if (c->lbrk)
			stream_write(t->fd, c->lbrk, 1, u = strlen(c->lbrk));
		stream_write(t->fd, buf, 1, len);
		if (c->rbrk) {
			v = strlen(c->rbrk);
			if (i + 1 < t->nr_attrs) {
				stream_write(t->fd, c->rbrk, 1, v);
			} else if (*c->rbrk != ',')
				stream_write(t->fd, c->rbrk, 1, v);
		}

		if (c == t->columns)
			len += t->rlbrk ? strlen(t->rlbrk) : 0;
		TABS(t->fd, c->tabs - ((len + u + v - 1) / 8));
	}
	if (t->rrbrk)
		stream_printf(t->fd, "%s\n", t->rrbrk);
	GDKfree(buf);
}

void
TABshowRange(Tablet * t, lng first, lng last)
{
	lng i;
	size_t j;
	oid k;

	i = BATcount(t->columns[0].c);
	if (last < 0 || last > i)
		last = i;
	if (first <= 0)
		first = 0;

	for (i = first; i < last; i++) {
		if (t->pivot) {
			k = *(oid *) BUNtail(t->pivot, BUNptr(t->pivot, t->pivot->hseqbase + i));
		} else
			k = (oid) i;
		for (j = 0; j < t->nr_attrs; j++) {
			BAT *b = t->columns[j].c;
			int base = t->columns[j].base;

			t->columns[j].p = BUNtail(b, BUNptr(b, base + k));
		}
		TABshowRow(t);
	}
}
static void
TABshowPage(Tablet * t)
{
	/* if( t->ttopbrk==0) { LINE(t->fd,t->rowwidth); }
	   else stream_printf(t->fd, "%s\n", t->ttopbrk); */
	TABshowRange(t, 0, -1);
	if (t->tbotbrk == 0) {
		LINE(t->fd, t->rowwidth);
	} else
		stream_printf(t->fd, "%s\n", t->tbotbrk);
}

@+ V4 stuff
The remainder is a patched copy of material from gdk_storage.
@c
typedef int (*strFcn) (str *s, int *len, ptr val);

#define printfcn(b)	((b->ttype==TYPE_void && b->tseqbase==oid_nil)?\
			          print_nil:BATatoms[b->ttype].atomToStr)
static int
print_nil(char **dst, int *len, ptr dummy)
{
	(void) dummy;		/* fool compiler */
	if (*len < 3) {
		if (*dst)
			GDKfree(*dst);
		*dst = (char *) GDKmalloc(*len = 40);
	}
	strcpy(*dst, "nil");
	return 3;
}

static int
setTabwidth(Column * c)
{
	strFcn tostr = printfcn(c->c);
	size_t cnt = BATcount(c->c);
	int ret = 0;
	unsigned int max;
	int t = BATttype(c->c);
	char *buf = 0;
	char *title = c->c->tident;

	if (strcmp(c->c->tident, "t") == 0) {
		title = GDKmalloc(strlen(BATgetId(c->c)) + 7);
		snprintf(title, 20, "%s", BATgetId(c->c));
	}
	c->base = BUNindex(c->c, BUNfirst(c->c));
	c->type = GDKstrdup(ATOMname(c->c->ttype));
	c->adt = c->c->ttype;
	buf = (char *) GDKmalloc(ret = strLen(title));
	max = MAX((int) strlen(c->type), ret);
	if (c->nullstr)
		max = MAX(max, strlen(c->nullstr));
	if (c->lbrk)
		max += strlen(c->lbrk);
	if (c->rbrk)
		max += strlen(c->rbrk);

	if (t >= 0 && t < GDKatomcnt && tostr) {
		size_t off = BUNindex(c->c, BUNfirst(c->c));
		size_t j, i, probe = MIN(10000, MAX(200, cnt / 100));

		for (i = 0; i < probe; i++) {
			if (i >= cnt)
				break;
			j = off + ((cnt < probe) ? i : (rand() % cnt));
			(*tostr) (&buf, &ret, BUNtail(c->c, BUNptr(c->c, j)));
			max = MAX(max, strlen(buf));
		}
	}
	c->width = max;
	c->name = GDKstrdup(title);
	return c->width;
}

@}
