@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f cluster
@a Martin Kersten, Niels Nes
@v 1.0
@t Hash cluster Algorithms

@* Introduction
Hash structures in MonetDB are optimized to build in a single scan. 
Also their use is limited to a single bat. Read optimized hashes (or clusters) 
could be used in many algorithms, such as select, join, group by and 
distinct checking. This calls for physical locality of elements
hashing to the same element. Preferrable the elements in a collision
list are physically close, as are the lists of subsequent lists.

This module extends the built in hashing scheme with a method 
to reorganize BATs based on their hash key. It is a linear-time,
near-optimal N-way reclustering based on key ranges.

We start with collecting all hash keys from the underlying 
table into the table H[:oid,:int].
The next step is an inplace reclustering step to bring
elements together based on the hash key. This step is based
on the assumption that values in the hash-key are uniformly
distributed. We create as many buckets as we  consider
justified in terms of the IO. The tuples are 'thrown' into
their bucket until they become full and can not easily
be extended by harvesting free space from their neighor bucket.
Then the bounds for all buckets are fine-tuned by 
redistribution all remaining space evenly. 
If there are not enough slots to redistribute, we keep the
tuple in its place, polluting the clustering objective.
We know that the number of out of bucket elemens <N.
[For the purists, this could be solved by a clever
re-shuffling over all buckets in the end]

The result is a oid-key table that represents an IO
'optimal' sequence of tuples. IO optimal, because 
with determining N we have 2N read/write pointers
in the table. Tuples are reclustered amongst those.
The outerloop touches each tuple once, causing
the order in the oid list to represent the IO
activity too. This means we can use it directly
as a driver for redistributing value columns.

The remaining step is to perform this in parallel
for a large collection of BATs.
@mal
module cluster;

command key(b:bat[:oid,:any_1]) :bat[:oid,:int]
address CLUSTER_key
comment "Create the hash key list";

command new(b:bat[:oid,:int], N:int) :void
address CLUSTER_new
comment "Recluster hash key table in N partitions";

pattern remap(m:bat[:oid,:int], b:bat[:oid,:any]...):void
address CLUSTER_remap
comment "Reorder tail of bat b using a cluster map";

pattern map(b:bat[:oid,:any]...):void
address CLUSTER_map
comment "Recluster the bats after selecting a suitable number of baskets";
@h
#ifndef _CLUSTER_H
#define _CLUSTER_H

#include <mal.h>
#include "mal_interpreter.h"
#include "mal_client.h"

/* #define _CLUSTER_DEBUG	for local debugging */

#ifdef WIN32
#ifndef LIBCLUSTER
#define cluster_export extern __declspec(dllimport)
#else
#define cluster_export extern __declspec(dllexport)
#endif
#else
#define cluster_export extern
#endif

cluster_export str  CLUSTER_key( bat *M, bat *B);
cluster_export str  CLUSTER_remap( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
cluster_export str  CLUSTER_map( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif /* _CLUSTER_H */
@c

#include "mal_config.h"
#include "cluster.h"
#include <mal_exception.h>
#include "algebra.h"

@= map_fixed
void
CLUSTER_key_@1( BAT *map, BAT *b)
{
	@1 *bt, *be;
	oid o= 0;

	bt = (@1*)Tloc(b, BUNfirst(b));
	be = bt + BATcount(b);
	for ( ; bt < be; bt++){
		int h = hash_@1(b->T->hash,bt);
		BUNfastins(map, (ptr)&o, (ptr)&h);
		o++;
	}
}

str  
CLUSTER_map_@1(BAT *nb, BAT *b, BAT *cmap)
{
	@1 *r;
	oid *ct, *ce;
	BUN p;
	BATiter bi= bat_iterator(b);
	
	r = (@1*)Tloc(nb, BUNfirst(nb));
	ct = (oid *)Hloc(cmap, BUNfirst(cmap));
	ce = ct + BATcount(cmap);
	for ( ; ct < ce; ct++){
		p = BUNfnd(b,(ptr) ct);
		*r++ = *(@1*) BUNtail(bi,p);
	}
	return MAL_SUCCEED;
}

@c
@:map_fixed(chr)@
@:map_fixed(bte)@
@:map_fixed(sht)@
@:map_fixed(oid)@
@:map_fixed(wrd)@
@:map_fixed(int)@
@:map_fixed(lng)@
@:map_fixed(flt)@
@:map_fixed(dbl)@
@-
The hash key and the oid are materialized to prepare for reclustering.
@c
str
CLUSTER_key( bat *M, bat *B){
	BAT *map, *b;

	if ((b = BATdescriptor(*B)) == NULL)
		throw(MAL, "cluster.key", "Cannot access descriptor");
	(void) BATprepareHash(BATmirror(b));

	if ((map = BATnew(TYPE_oid, TYPE_int, BATcount(b)+1)) == NULL) {
		BBPunfix(*B);
		throw(MAL, "cluster.key", "Cannot create hash map");
	}
	map->tsorted= FALSE;
	map->tdense= FALSE;

	switch(ATOMstorage(b->ttype)) {
		case TYPE_chr: CLUSTER_key_chr(map,b); break;
		case TYPE_bte: CLUSTER_key_bte(map,b); break;
		case TYPE_sht: CLUSTER_key_sht(map,b); break;
		case TYPE_oid: CLUSTER_key_oid(map,b); break;
		case TYPE_wrd: CLUSTER_key_wrd(map,b); break;
		case TYPE_str:
		case TYPE_int: CLUSTER_key_int(map,b); break;
		case TYPE_lng: CLUSTER_key_lng(map,b); break;
		case TYPE_flt: CLUSTER_key_flt(map,b); break;
		case TYPE_dbl: CLUSTER_key_dbl(map,b); 
	}
	BATsave(map);	/* dump dirty pages from memory */
	BBPunfix(*B);
	BBPkeepref(*M = map->batCacheid);
	return MAL_SUCCEED;
}
@-
Recluster the <oid,key> table into a number of buckets
on the high order bits,
If the baskets are full before we have moved everything
in place, we redistribute the free space again. This process
continues until the amount of space to be redistribute is
to small.
@c
typedef struct{
	int low,hgh;
	BUN base,limit;
} Basket;

static int
CLUSTER_redistribute(Basket *basket, int N){
	int i;
	BUN j,slice, free=0;
	for (i=0; i<N; i++)
		free+= basket[i+1].base-basket[i].limit;

#ifdef _CLUSTER_DEBUG
	stream_printf(GDKout,"redistribute %d\n",(int) free);
#endif
	if ((int)free <= N) return 0;
	slice= free/N;
	for (i=0;i<N-1;i++){
		j= basket[i+1].limit - basket[i+1].base;
		basket[i+1].base = basket[i].limit + slice;
		basket[i+1].limit = basket[i+1].base + j;
	}
	return 1;
}

str  
CLUSTER_new(bat *RB, bat *B, int *N)
{
	BAT *b;
	BATiter bi;
	BUN i=0,p,q;
	oid ocur,onxt;
	int wcur, wnxt,rng;
	int bnr=0, h;
	BUN bsize;
	Basket *basket = (Basket*) alloca((*N+1) * sizeof(Basket));
	(void) RB;

	if ( *N <= 0)
		throw(MAL, "cluster.cluster", "Illegal basket count");
	if ( (b = BATdescriptor(*B)) == NULL)
		throw(MAL, "cluster.cluster", "Cannot access descriptor");
	bi= bat_iterator(b);
	BATmax(b, (ptr) &rng);
	bsize= rng / *N;
#ifdef _CLUSTER_DEBUG
	stream_printf(GDKout,"bucket size %d max %d\n",bsize,rng);
#endif

	/* prepare buffers */
	basket[0].base= basket[0].limit=0;
	basket[0].low= 0;
	basket[0].hgh= bsize;
#ifdef _CLUSTER_DEBUG
	stream_printf(GDKout,"basket %d %d-%d %d-%d\n",0, 
		basket[0].base, basket[0].limit, basket[0].low, basket[0].hgh);
#endif
	for (h=1; h < *N; h++){
		basket[h].base= basket[h].limit= basket[h-1].limit + BATcount(b) / *N;
		basket[h].low= basket[h-1].hgh;
		basket[h].hgh= basket[h-1].hgh + bsize;
#ifdef _CLUSTER_DEBUG
	stream_printf(GDKout,"basket %d %d-%d %d-%d\n",h, 
		basket[h].base, basket[h].limit, basket[h].low, basket[h].hgh);
#endif
	}
	basket[h-1].hgh= rng;
#ifdef _CLUSTER_DEBUG
	stream_printf(GDKout,"basket %d %d-%d %d-%d\n",h-1, 
		basket[h-1].base, basket[h-1].limit, basket[h-1].low, basket[h-1].hgh);
#endif
	basket[h].low= basket[h].hgh= rng;
	basket[h].base= basket[h].limit= BATcount(b);

	BATloop(b,p,q){
		ocur= *(oid*) BUNhead(bi,p);
		wcur= *(int*) BUNtail(bi,p);
		/* push it forward to the right basket using domino effect */

		/* start with a dumb linear search */
		for (bnr = 0; bnr < *N -1 ; bnr++)
		if ( wcur >= basket[bnr].low && wcur < basket[bnr].hgh)
			break;

		/* is the element in the right basket already? */
		if ( i>= basket[bnr].base && i < basket[bnr].limit ){
#ifdef _CLUSTER_DEBUG
		printf("case 1 mov %d %d", (int) i, (int) wcur);
		printf(" basket %d %d-%d %d-%d\n",bnr, 
			(int) basket[bnr].base, (int) basket[bnr].limit, (int) basket[bnr].low, (int) basket[bnr].hgh);
#endif
			if ( i== basket[bnr+1].base)
				basket[bnr+1].base++;
			basket[bnr].limit++;
			i++;
			continue;
		}

		/* allocate space in the target basket */
		if (basket[bnr].limit < basket[bnr+1].base){
#ifdef _CLUSTER_DEBUG
		printf("case 2 mov %d %d", (int) i, (int) wcur);
		printf(" basket %d %d-%d %d-%d\n",bnr, 
			(int) basket[bnr].base, (int) basket[bnr].limit, (int) basket[bnr].low, (int) basket[bnr].hgh);
#endif
			onxt= *(oid*) BUNhloc(bi, basket[bnr].limit);
			wnxt= *(int*) BUNtail(bi, basket[bnr].limit);
			*(oid*) BUNhloc(bi, basket[bnr].limit)= ocur;
			*(int*) BUNtloc(bi, basket[bnr].limit)= wcur;
			*(oid*) BUNhead(bi,p)= onxt;
			*(int*) BUNtail(bi,p)= wnxt;
			basket[bnr].limit++;
			p--;
			continue;
		}
		/* reallocate the free space */
		if (CLUSTER_redistribute(basket, *N)){
			p--;
			continue;
		}
		i++;
	}
	return MAL_SUCCEED;
}
@-
The order of the tuples in the cluster map
represent the read/write order. Under the assumption
that those read/writes are already localized, it becomes
opportune to simply rebuild the clustered column by 
probing. This leads to ca 2N read/write hotspots.

Extend this operation to accept a sequence of BATs.
@c
void 
CLUSTER_column(BAT *nb, BAT *cmap)
{
	BAT *b;
	b= BATcopy(nb, nb->htype, nb->ttype, TRUE);
	BATseqbase(nb, b->H->seq);
	BATsetcount(nb, BATcount(b));
	nb->tsorted= FALSE;
	nb->tdense= FALSE;

	/* determine the work for all threads */
	/* to be done, first assume that we can remap in one go */

	switch(ATOMstorage(b->ttype)) {
	case TYPE_chr: CLUSTER_map_chr(nb, b, cmap);break;
	case TYPE_bte: CLUSTER_map_bte(nb, b, cmap);break;
	case TYPE_sht: CLUSTER_map_sht(nb, b, cmap);break;
	case TYPE_oid: CLUSTER_map_oid(nb, b, cmap);break;
	case TYPE_wrd: CLUSTER_map_wrd(nb, b, cmap);break;
	case TYPE_int: CLUSTER_map_int(nb, b, cmap);break;
	case TYPE_lng: CLUSTER_map_lng(nb, b, cmap);break;
	case TYPE_flt: CLUSTER_map_flt(nb, b, cmap);break;
	case TYPE_dbl: CLUSTER_map_dbl(nb, b, cmap);break;
	}
	BBPunfix(b->batCacheid);
}
str  
CLUSTER_remap( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *CMAP =(int *) getArgReference(stk, pci, pci->retc);
	bat *B;
	BAT *nb, *cmap = NULL, *b = NULL;
	int i;

	(void) cntxt;
	(void) mb;

	for (i=pci->retc+1; i<pci->argc; i++){
		B =(int *) getArgReference(stk, pci, i);
		if ( (b = BATdescriptor(*B)) == NULL)
			throw(MAL, "cluster.map", "Cannot access 1st descriptor");
		/* small-defense line */
		switch(ATOMstorage(b->ttype)) {
		case TYPE_chr: case TYPE_bte: case TYPE_sht: case TYPE_oid:
		case TYPE_wrd: case TYPE_int: case TYPE_lng: case TYPE_flt:
		case TYPE_dbl: case TYPE_str:
				/* doit */
				break;
		default:
			BBPunfix(*B);
			throw(MAL, "cluster.map", "Cannot recluster operand");
		}
		BBPunfix(*B);
	}

	if ( (cmap = BATdescriptor(*CMAP)) == NULL ){
		BBPunfix(*CMAP);
		throw(MAL, "cluster.map", "Cannot access 3rd descriptor");
	}

	for (i= pci->retc; i<pci->argc; i++){
		/* we replace the order in the argument */
		/* this calls for a copy to take values from */
		/* could be improved with some pointer swissling */
		B =(int *) getArgReference(stk, pci, i);
		nb = BATdescriptor(*B);
		CLUSTER_column(nb,cmap);
		BBPunfix(nb->batCacheid);
	}
	BBPunfix(*CMAP);
	return MAL_SUCCEED;
}
@-
The self-organizing version should determine the optimal
number of buckets. Thereafter it can just call the
remapping;
@c
str  
CLUSTER_map( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat map;
	bat *B =(int *) getArgReference(stk, pci, 1);
	BAT *nb, *cmap;
	str msg;
	int i;
	int N=3; /* to be optimized based on size and # columns */
	
	(void) cntxt;
	(void) mb;

	msg= CLUSTER_key(&map, B);
	if ( msg != MAL_SUCCEED)
		return msg;
	msg= CLUSTER_new(&map, &map,  &N);
	if ( msg != MAL_SUCCEED)
		return msg;

	cmap= BATdescriptor(map);
	if( cmap == NULL)
			throw(MAL, "cluster.map", "Cannot access map descriptor");
	for (i=pci->retc; i<pci->argc; i++){
		B =(int *) getArgReference(stk, pci, i);
		nb = BATdescriptor(*B);
		if (nb == NULL)
			throw(MAL, "cluster.map", "Cannot access column descriptor");
		CLUSTER_column(nb,cmap);
		BBPunfix(nb->batCacheid);
	}
	BBPunfix(map);
	return msg;
}
