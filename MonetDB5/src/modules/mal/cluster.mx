@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f cluster
@a Martin Kersten, Niels Nes
@v 1.0
@t Hash cluster Algorithms

@* Introduction
Hash structures in MonetDB are optimized to build in a single scan. 
Also their use is limited to a single bat. Read optimized hashes (or clusters) 
could be used in many algorithms, such as select, join, group by and 
distinct checking. This calls for physical locality of elements
hashing to the same element. Preferrable the elements in a collision
list are physically close, as are the lists of subsequent lists.

This module extends the built in hashing scheme with a method 
to reorganize BATs based on their hash key. It is a linear-time,
near-optimal N-way reclustering based on key ranges.

We start with collecting all hash keys from the underlying 
table into the table H[:oid,:oid].
The next step is a reclustering step to bring
elements together based on the hash key. This step is based
on the assumption that values in the hash-key are uniformly
distributed. We create as many buckets as we  consider
justified in terms of the IO. The tuples are 'thrown' into
their bucket until they become full or can be extended 
by harvesting free space from its direct neighor buckets.
If there is no free space left, we circularly look for a bucket
with space, partly  polluting the clustering objective.

The result is a void-oid table that represents an IO
'optimal' sequence of tuples. IO optimal, because 
with determining N we have 2N read/write pointers
in the table. Tuples are reclustered amongst those
using an ordinary join operation.
The outerloop touches each tuple once, causing
the order in the oid list to represent the IO
activity too. This means we can use it directly
as a driver for redistributing value columns.

The remaining step is to perform this in parallel
for a large collection of BATs.
@mal
module cluster;

command key(b:bat[:oid,:any_1]) :bat[:oid,:oid]
address CLUSTER_key
comment "Create the hash key list";

command new(b:bat[:oid,:oid]) :bat[:oid,:oid]
address CLUSTER_new
comment "Recluster hash key table and produce a re-allocation map";

pattern map(m:bat[:oid,:oid], b:bat[:oid,:int]):void
address CLUSTER_map
comment "Reorder tail of the bates referred to a cluster map";
@{
@h
#ifndef _CLUSTER_H
#define _CLUSTER_H

#include <mal.h>
#include "mal_interpreter.h"
#include "mal_client.h"

#define _CLUSTER_DEBUG	/* for local debugging */

#ifdef WIN32
#ifndef LIBCLUSTER
#define cluster_export extern __declspec(dllimport)
#else
#define cluster_export extern __declspec(dllexport)
#endif
#else
#define cluster_export extern
#endif

cluster_export str  CLUSTER_key( bat *M, bat *B);
cluster_export str  CLUSTER_new(bat *RB, bat *B);
cluster_export str  CLUSTER_map( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif /* _CLUSTER_H */
@c

#include "mal_config.h"
#include "cluster.h"
#include <mal_exception.h>
#include "algebra.h"

@= map_fixed
void
CLUSTER_key_@1( BAT *map, BAT *b)
{
	@1 *bt, *be;
	oid *o;

	o = (oid*)Tloc(map, BUNfirst(map));
	bt = (@1*)Tloc(b, BUNfirst(b));
	be = bt + BATcount(b);
	for ( ; bt < be; bt++){
		BUN h = hash_@1(b->T->hash,bt);
		*o++= h;
	}
}

str  
CLUSTER_map_@1(BAT *nb, BAT *b, BAT *cmap)
{
	@1 *r;
	oid *ct, *ce;
	BUN p;
	BATiter bi= bat_iterator(b);
	
	r = (@1*)Tloc(nb, BUNfirst(nb));
	ct = (oid *)Hloc(cmap, BUNfirst(cmap));
	ce = ct + BATcount(cmap);
	for ( ; ct < ce; ct++){
		p = BUNfnd(b,(ptr) ct);
		*r++ = *(@1*) BUNtail(bi,p);
	}
	return MAL_SUCCEED;
}

@c
@:map_fixed(chr)@
@:map_fixed(bte)@
@:map_fixed(sht)@
@:map_fixed(oid)@
@:map_fixed(wrd)@
@:map_fixed(int)@
@:map_fixed(lng)@
@:map_fixed(flt)@
@:map_fixed(dbl)@
@-
The hash key and the oid are materialized to prepare for reclustering.
@c
str
CLUSTER_key( bat *M, bat *B){
	BAT *map, *b;

	if ((b = BATdescriptor(*B)) == NULL)
		throw(MAL, "cluster.key", "Cannot access descriptor");
	(void) BATprepareHash(BATmirror(b)); /* only produce the hash structure! */

	if ((map = BATnew(TYPE_void, TYPE_oid, BATcount(b)+1)) == NULL) {
		BBPunfix(*B);
		throw(MAL, "cluster.key", "Cannot create hash map");
	}
	map->tsorted= FALSE;
	map->tdense= FALSE;
	BATseqbase(map, b->H->seq);
	BATsetcount(map, BATcount(b));

	switch(ATOMstorage(b->ttype)) {
		case TYPE_chr: CLUSTER_key_chr(map,b); break;
		case TYPE_bte: CLUSTER_key_bte(map,b); break;
		case TYPE_sht: CLUSTER_key_sht(map,b); break;
		case TYPE_oid: CLUSTER_key_oid(map,b); break;
		case TYPE_wrd: CLUSTER_key_wrd(map,b); break;
		case TYPE_int: CLUSTER_key_int(map,b); break;
		case TYPE_lng: CLUSTER_key_lng(map,b); break;
		case TYPE_flt: CLUSTER_key_flt(map,b); break;
		case TYPE_dbl: CLUSTER_key_dbl(map,b); break;
		default:
			throw(MAL, "cluster.key", "Cannot recluster on this type");
		
	}
	BATsave(map);	/* dump dirty pages from memory */
	BBPunfix(*B);
	BBPkeepref(*M = map->batCacheid);
	return MAL_SUCCEED;
}
@-
Recluster the <oid,hash> table into a number of buckets
on the high order bits,
If the baskets are full before we have moved everything
in place, we redistribute the free space again. This process
continues until the amount of space to be redistribute is
to small.

The self-organizing version should determine the optimal
number of buckets. Thereafter it can just call the
remapping;
@c
typedef struct{
	oid low,hgh;
	BUN base,limit;
} Basket;

str  
CLUSTER_new(bat *RB, bat *B)
{
	BUN rng,bsize, bnr=0, h, N= 3; /* number of buckets */
	BAT *b, *map;
	BATiter bi,mi;
	BUN p,q;
	oid *mp, ocur,idx = 0;
	BUN i;
	Basket *basket;
	(void) RB;

	if ( (b = BATdescriptor(*B)) == NULL)
		throw(MAL, "cluster.new", "Cannot access descriptor");

	if ((map = BATnew(TYPE_void, TYPE_oid, BATcount(b)+1)) == NULL) {
		BBPunfix(*B);
		throw(MAL, "cluster.new", "Cannot create hash map");
	}
	map->hsorted= TRUE;
	map->hdense= TRUE;
	BATseqbase(map, 0);
	map->tsorted= FALSE;
	map->tdense= FALSE;
	BATsetcount(map, BATcount(b));
	mi= bat_iterator(map);
	bi= bat_iterator(b);
	BATmax(b, (ptr) &rng); /* get the maximum hash key , could use mask !*/
@-
The key challenge is to determine the number of clusters.
A large number of clusters benefits subsequent performance,
but also challenges the prepare phase. The clustering should
work both for relatively small tables and those that do not
fit in memory.

The bottomline is the number of elements that fit in a single
diskblock.
@c
	N= (BUN)MT_npages() /10;
	bsize= (BUN) (MT_pagesize()/sizeof(lng));
	if (N > (rng/ bsize))
		N = bsize;
	bsize= rng / N;
#ifdef _CLUSTER_DEBUG
	N=3; bsize= rng / N; /* for debugging only */
	stream_printf(GDKout,"bucket pages %d size %d max %d  N %d\n", 
		(int)MT_npages(),bsize,rng,N);
#endif
	basket = (Basket*) alloca((N+1) * sizeof(Basket));
	if (basket==NULL)
		throw(MAL, "cluster.new", "Not enough space");

	/* prepare buffers */
	basket[0].base= basket[0].limit=0;
	basket[0].low= 0;
	basket[0].hgh= bsize;
#ifdef _CLUSTER_DEBUG
	stream_printf(GDKout,"basket %d %d-%d %d-%d\n",0, 
		basket[0].base, basket[0].limit, basket[0].low, basket[0].hgh);
#endif
	for (h=1; h < N; h++){
		basket[h].base= basket[h].limit= basket[h-1].limit + BATcount(b) / N;
		basket[h].low= basket[h-1].hgh;
		basket[h].hgh= basket[h-1].hgh + bsize;
#ifdef _CLUSTER_DEBUG
	stream_printf(GDKout,"basket %d %d-%d %d-%d\n",h, 
		basket[h].base, basket[h].limit, basket[h].low, basket[h].hgh);
#endif
	}
	basket[h-1].hgh= rng;
	basket[h].low= basket[h].hgh= rng;
	basket[h].base= basket[h].limit= BATcount(b);

	mp= (oid*) BUNtail(mi, BUNfirst(map));
	BATloop(b,p,q){
		ocur= *(oid*) BUNtail(bi,p);
		/* push it forward to the right basket using domino effect */

		/* start with a dumb linear search */
		for (bnr = 0; bnr < N -1 ; bnr++)
		if ( ocur >= basket[bnr].low && ocur < basket[bnr].hgh)
			break;


		/* allocate space in the target basket */
		if (basket[bnr].limit < basket[bnr+1].base){
#ifdef _CLUSTER_DEBUG
			printf("case 1 mov %d %d", (int) ocur, (int) idx);
			printf(" basket %d %d-%d %d-%d\n",(int) bnr, 
				(int) basket[bnr].base, (int) basket[bnr].limit, 
				(int) basket[bnr].low, (int) basket[bnr].hgh);
#endif
			mp[basket[bnr].limit]= idx++;
			basket[bnr].limit++;
			continue;
		} else
		if ( bnr>0 && basket[bnr-1].limit < basket[bnr].base){
#ifdef _CLUSTER_DEBUG
			printf("case 2 mov %d %d", (int) ocur, (int) idx);
			printf(" basket %d %d-%d %d-%d\n",(int) bnr, 
				(int) basket[bnr].base, (int) basket[bnr].limit, 
				(int) basket[bnr].low, (int) basket[bnr].hgh);
#endif
			basket[bnr].base--;
			mp[basket[bnr].base]= idx++;
			continue;
		}

		/* find a free slot somewhere, but try to maintain clustering */
		bnr= (bnr+3) % N;
		i= N;
		do {
			if (basket[bnr].limit < basket[bnr+1].base){
#ifdef _CLUSTER_DEBUG
				printf("case 3 mov %d %d", (int) ocur, (int) idx);
				printf(" basket %d %d-%d %d-%d\n",(int) bnr, 
					(int) basket[bnr].base, (int) basket[bnr].limit, 
					(int) basket[bnr].low, (int) basket[bnr].hgh);
#endif
				mp[basket[bnr].limit]= idx++;
				basket[bnr].limit++;
				goto cont;
			}
			bnr= (bnr+1) % N;
		} while( --i );
		cont: ;
	}
	BBPkeepref(*RB= map->batCacheid);
	return MAL_SUCCEED;
}
@-
The order of the tuples in the cluster map
represent the read/write order. Under the assumption
that those read/writes are already localized, it becomes
opportune to simply rebuild the clustered column by 
probing. 

Extend this operation to accept a sequence of BATs.
We change the BAT in place using a temporary copy
to guide the move.
@c
void 
CLUSTER_column(BAT *nb, BAT *cmap)
{
	BAT *b;
	b= BATcopy(nb, nb->htype, nb->ttype, TRUE);
	nb->tsorted= FALSE;
	nb->tdense= FALSE;

	/* determine the work for all threads */
	/* to be done, first assume that we can remap in one go */

	switch(ATOMstorage(b->ttype)) {
	case TYPE_chr: CLUSTER_map_chr(nb, b, cmap);break;
	case TYPE_bte: CLUSTER_map_bte(nb, b, cmap);break;
	case TYPE_sht: CLUSTER_map_sht(nb, b, cmap);break;
	case TYPE_oid: CLUSTER_map_oid(nb, b, cmap);break;
	case TYPE_wrd: CLUSTER_map_wrd(nb, b, cmap);break;
	case TYPE_int: CLUSTER_map_int(nb, b, cmap);break;
	case TYPE_lng: CLUSTER_map_lng(nb, b, cmap);break;
	case TYPE_flt: CLUSTER_map_flt(nb, b, cmap);break;
	case TYPE_dbl: CLUSTER_map_dbl(nb, b, cmap);break;
	}
	BBPunfix(b->batCacheid);
}
str  
CLUSTER_map( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *CMAP =(int *) getArgReference(stk, pci, 1);
	bat *B =(int *) getArgReference(stk, pci, 2);
	BATiter bi;
	int *p, *q;
	BAT *nb, *cmap = NULL, *b = NULL;

	(void) cntxt;
	(void) mb;
	if ( (cmap = BATdescriptor(*CMAP)) == NULL )
		throw(MAL, "cluster.map", "Cannot access  descriptor");
	if ( (b = BATdescriptor(*B)) == NULL ){
		BBPunfix(*CMAP);
		throw(MAL, "cluster.map", "Cannot access  descriptor");
	}

	bi= bat_iterator(b);
	p = (int*)Tloc(b, BUNfirst(b));
	q = p + BATcount(b);
	for(; p<q; p++){
#ifdef _CLUSTER_DEBUG
		printf("recluster %d test\n", *(int*)p);
#endif
		if ( (nb = BATdescriptor(*(int*)p)) == NULL)
			throw(MAL, "cluster.map", "Cannot access descriptor");
		/* small-defense line */
		switch(ATOMstorage(nb->ttype)) {
		case TYPE_chr: case TYPE_bte: case TYPE_sht: case TYPE_oid:
		case TYPE_wrd: case TYPE_int: case TYPE_lng: case TYPE_flt:
		case TYPE_dbl: case TYPE_str:
				/* doit */
				break;
		default:
			BBPunfix(nb->batCacheid);
			throw(MAL, "cluster.map", "Cannot recluster operand");
		}
		BBPunfix(nb->batCacheid);
	}

	p = (int*)Tloc(b, BUNfirst(b));
	for(; p<q; p++){
#ifdef _CLUSTER_DEBUG
		printf("recluster %d\n", *(int*)p);
#endif
		nb = BATdescriptor(*(int*) p);
		CLUSTER_column(nb,cmap);
		BBPunfix(nb->batCacheid);
	}
	BBPunfix(*CMAP);
	return MAL_SUCCEED;
}
@-
A test skeleton for re-clustering a specific SQL table.

include cluster;
function clusterTable(nme:str);
	t0:= alarm.time();
	sql_catalog:bat[:int,:str] := bbp.bind("sql_catalog");
	pat := "%_"+nme;
	pat := pat+"_%";
	items := pcre.like_uselect(sql_catalog,pat,"");
	rn:= bat.reverse(items);
	io.print(rn);
	first:= algebra.fetch(rn,0);
	b1:bat[:void,:any] := bbp.bind(first);
	io.print(b1);
	cmap:= cluster.new(first);
	io.printf("cluster %s\n",pat);
	cluster.map(cmap,rn);
	t1:= alarm.time();
	t1:= t1-t0;
	io.printf("time %d\n",t1);
end clusterTable;
@}
