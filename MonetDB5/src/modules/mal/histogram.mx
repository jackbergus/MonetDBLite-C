@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f histogram
@a Martin Kersten
@v 1
@+ Histogram 
This support module is geared at handling small equi-bin histograms.
@mal
module histogram;
@-
@{
@+ Implementation
@h
#ifndef _HISTOGRAM_H
#define _HISTOGRAM_H 
#include <stdarg.h>
#include <gdk.h>
#include <mmath.h>

#ifdef WIN32
#ifndef LIBHISTOGRAM
#define histogram_export extern __declspec(dllimport)
#else
#define histogram_export extern __declspec(dllexport)
#endif
#else
#define histogram_export extern
#endif

typedef struct {
	int bins;
	ValRecord low, hgh, inc;
	lng cnt[];
} *Histogram;

#define HSTinc_sht(H,X) H->cnt[(X - H->low.val.shval) / H->inc.val.shval]++
#define HSTinc_bte(H,X) H->cnt[(X - H->low.val.btval) / H->inc.val.btval]++
#define HSTinc_int(H,X) H->cnt[(X - H->low.val.ival) / H->inc.val.ival]++
#define HSTinc_lng(H,X) H->cnt[(X - H->low.val.lval) / H->inc.val.lval]++
#define HSTinc_flt(H,X) H->cnt[(int)((X - H->low.val.fval) / H->inc.val.fval)]++
#define HSTinc_dbl(H,X) H->cnt[(int)((X - H->low.val.dval) / H->inc.val.dval)]++

histogram_export Histogram HSTnew(int bins, ValPtr minval, ValPtr maxval);
histogram_export void HSTincrement(Histogram h, ValPtr val);
histogram_export void HSTprint(stream *s, Histogram h);
histogram_export void HSTprintf(Histogram h);

histogram_export dbl HSTeuclidian(Histogram h1, Histogram h2);
histogram_export int HSTeuclidianWhatIf(Histogram h1, Histogram h2, ValPtr val);
histogram_export dbl HSTcityblock(Histogram h1, Histogram h2);
histogram_export dbl HSTchebyshev(Histogram h1, Histogram h2);
histogram_export dbl HSTeuclidianDelta(Histogram h1, Histogram h2, dbl d, int idx, int cnt);
histogram_export dbl HSTcityblockDelta(Histogram h1, Histogram h2, dbl d, int idx, int cnt);
histogram_export dbl HSTchebyshevDelta(Histogram h1, Histogram h2, dbl d, int idx, int cnt);
#endif /* _HISTOGRAM_H */
@- 
@c
#include "mal_config.h"
#include "histogram.h"

Histogram
HSTnew(int bins, ValPtr minval, ValPtr maxval)
{
	Histogram h;
	int i=0;

	assert( minval && maxval);
	assert( minval->vtype == maxval->vtype);
	assert( bins > 0);

	h = (Histogram) GDKzalloc(sizeof(*h) + sizeof(long) * bins);
	h->low = *minval;
	h->hgh = h->inc = *maxval;
	h->bins = bins;
	for ( i = 0; i < h->bins;  i++)
		h->cnt[i]=0;
	
	switch( minval->vtype){
		case TYPE_bte:
			h->inc.val.btval = (maxval->val.btval - minval->val.btval)/ bins + 1; 
			assert(h->inc.val.btval);
			break;
		case TYPE_sht:
			h->inc.val.shval = (maxval->val.shval - minval->val.shval)/ bins + 1; 
			assert(h->inc.val.shval);
			break;
		case TYPE_int:
			h->inc.val.ival = (maxval->val.ival - minval->val.ival)/ bins + 1; 
			assert(h->inc.val.ival);
			break;
		case TYPE_lng:
			h->inc.val.lval = (maxval->val.lval - minval->val.lval)/ bins + 1; 
			assert(h->inc.val.lval);
			break;
		case TYPE_dbl:
			h->inc.val.dval = (maxval->val.dval - minval->val.dval)/ bins + 1; 
			assert(h->inc.val.dval);
			break;
		case TYPE_flt:
			h->inc.val.fval = (maxval->val.fval - minval->val.fval)/ bins + 1; 
			assert(h->inc.val.fval);
	}
	return h;
}

void 
HSTincrement(Histogram h, ValPtr val){
	switch( val->vtype){
		case TYPE_bte: HSTinc_bte(h, val->val.btval); break;
		case TYPE_sht: HSTinc_sht(h, val->val.shval); break;
		case TYPE_int: HSTinc_int(h, val->val.ival); break;
		case TYPE_lng: HSTinc_lng(h, val->val.lval); break;
		case TYPE_dbl: HSTinc_dbl(h, val->val.dval); break;
		case TYPE_flt: HSTinc_flt(h, val->val.fval); break;
	}
}

dbl
HSTeuclidian(Histogram h1, Histogram h2){
	lng sum= 0;
	int i;
	assert(h1->bins == h2->bins);
	for ( i = 0; i < h1->bins; i++)
		sum += (h1->cnt[i] - h2->cnt[i]) * (h1->cnt[i] - h2->cnt[i]);
	return sqrt((double) sum);
}

/*get the bin we would increment if we would add this value*/
int
HSTincrementWhatIf(Histogram h, ValPtr val){
	int index;
	switch( val->vtype){
		case TYPE_bte: index= (val->val.btval - h->low.val.btval) / h->inc.val.btval;
		case TYPE_sht: index= (val->val.shval - h->low.val.shval) / h->inc.val.shval; 
		case TYPE_int: index= (val->val.ival - h->low.val.ival) / h->inc.val.ival; 
		case TYPE_lng: index= (val->val.lval - h->low.val.lval) / h->inc.val.lval;
		case TYPE_dbl: index= (val->val.dval - h->low.val.dval) / h->inc.val.dval;
		case TYPE_flt: index= (val->val.fval - h->low.val.fval) / h->inc.val.fval;
	}
	return index;
}

/* if 1 then adding this value to h2 increase the distance between h1-h2*/
int
HSTeuclidianWhatIf(Histogram h1, Histogram h2, ValPtr val){
	lng sum= 0, sumWhatIf=0, cur;
	dbl distance, distanceWhatIf;
	int i, affectedBin;
	assert(h1->bins == h2->bins);

	affectedBin = HSTincrementWhatIf(h2,val);

	for ( i = 0; i < h1->bins; i++){
		cur = (h1->cnt[i] - h2->cnt[i]) * (h1->cnt[i] - h2->cnt[i]);
		sum += cur;
		if (i==affectedBin)
			sumWhatIf += (h1->cnt[i] - (h2->cnt[i]+1)) * (h1->cnt[i] - (h2->cnt[i]+1));	
		else
			sumWhatIf += cur;
	}

	distance = sqrt((double) sum);
	distanceWhatIf = sqrt((double) sumWhatIf);
	printf("distance %f  new distance %f \n", distance, distanceWhatIf);
	if (distanceWhatIf > distance) return 1;
	return 0;
}

dbl
HSTcityblock(Histogram h1, Histogram h2){
	lng sum=0;
	int i;
	assert(h1->bins == h2->bins);
	for ( i = 0; i < h1->bins; i++)
		sum += ABS(h1->cnt[i] - h2->cnt[i]);
	return (dbl) sum;
}

dbl
HSTchebyshev(Histogram h1, Histogram h2){
	lng max, i;
	assert(h1->bins == h2->bins);
	max = ABS(h1->cnt[0] - h2->cnt[0]);
	for ( i = 1; i < h1->bins; i++)
		if ( ABS(h1->cnt[i] - h2->cnt[i]) > max)
			max = ABS(h1->cnt[i] - h2->cnt[i]);
	return (dbl) max;
}

@-
The next series determine the effect on the distance when a single
component in the histogram h1 is incremented/ decremented.
@c
dbl
HSTeuclidianDelta(Histogram h1, Histogram h2, dbl distance, int idx, int cnt){
	lng inc;
	dbl sum = distance * distance;
	inc = (h1->cnt[idx] + cnt - h2->cnt[idx]);
	return sqrt(sum - (h1->cnt[idx]- h2->cnt[idx])+ inc * inc);
}

dbl
HSTcityblockDelta(Histogram h1, Histogram h2, dbl d, int idx, int cnt){
	return d - ABS(h1->cnt[idx] - h2->cnt[idx]) + ABS(h1->cnt[idx] + cnt - h2->cnt[idx]);
}

dbl
HSTchebyshevDelta(Histogram h1, Histogram h2, dbl distance, int idx, int cnt){
	lng max;
	int i;

	(void) distance;
	assert(h1->bins == h2->bins);
	max = ABS(h1->cnt[0] + (idx == 0? cnt: 0) - h2->cnt[0]);
	for ( i = 1; i < h1->bins; i++)
		if ( ABS(h1->cnt[i] + (idx == i? cnt: 0) - h2->cnt[i]) > max)
			max = ABS(h1->cnt[i] + (idx == i? cnt: 0) - h2->cnt[i]);
	return (dbl) max;
}

void
HSTprint(stream *s, Histogram h){
	int i;

	for ( i = 0; i < h->bins;  i++)
		stream_printf(s, "[%d] " LLFMT "\n", i, h->cnt[i]);
	stream_printf(s, "\n");
}

void
HSTprintf(Histogram h){
	int i;

	for ( i = 0; i < h->bins;  i++)
		printf("[%d] " LLFMT "\n", i, h->cnt[i]);
	printf("\n");
}
@}
