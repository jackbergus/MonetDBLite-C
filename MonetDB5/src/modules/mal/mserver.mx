@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f mserver
@a N.J. Nes P. Boncz, S. Mullender, M. Kersten
@v 1.1
@+ MonetDB server interface
This module contains a simple interface for setting up
internet connections and to initialize a client session.

Clients may initialize a private listener to implement
specific services. For example, in an OLTP environment
it may make sense to have a listener for each transaction
type, which simply parses a sequence of transaction parameters.

Authorization of access to the server is handled as part
of the client record initialization phase.

The complete Mapi library is also available to setup
communication with another Mserver.
This library internally uses pointer handles, which we replace with
an index in a locally maintained table. It provides a handle
to easily detect havoc clients.
@mal
module mserver;

command listen():int
address SERVERlisten_default
comment "Start a Mapi server with the default settings.";
command listen(port:int):int
address SERVERlisten_port
comment "Start a Mapi server on the given port";
command listen(port:int, maxusers:int):int
address SERVERlisten2
comment "Start a Mapi server";

command listen(port:int, maxusers:int, cmd:str):int
address SERVERlisten3
comment "Start the Mapi listener on <port> for <maxusers>. 
	For a new client connection MAL procedure <cmd>(Stream s_in, Stream s_out)
	is called.If no <cmd> is specified a new client thread is forked.";

command listen_ssl(port:int, maxusers:int,
	keyfile:str,certfile:str, cmd:str):int
address SERVERlistenSSL
comment "Start the Mapi listener on <port> for <maxusers> using SSL. 
	<keyfile> and <certfile> give the path names for files with the 
	server key and certificates in PEM format. For a new client connection 
	MAL procedure <cmd>(Stream s_in, Stream s_out) is called.
	If no <cmd> is specified a new client thread is forked.";

command stop():void
address SERVERstop
comment "Terminate connection listeners"; 

command suspend():void
address SERVERsuspend
comment "Suspend accepting connections";

command resume():void
address SERVERresume
comment "Resume connection listeners";

command malclient(in:streams, out:streams):void
address SERVERclient
comment "Start a Mapi client.";


command trace(mid:int,flag:int):void
address SERVERtrace
comment "Toggle the Mapi library tracer";

command reconnect(host:str, port:int, usr:str, passwd:str,lang:str):int
address SERVERreconnectWithoutAlias
comment "Re-establish connection with a remote mserver";

command reconnect(host:str, port:int, db_alias:str, usr:str, passwd:str,lang:str):int
address SERVERreconnectAlias
comment "Re-establish connection with a remote mserver";

command reconnect(mid:int):void
address SERVERreconnect
comment "Re-establish a connection";

command connect(host:str, port:int, usr:str, passwd:str,lang:str):int
address SERVERconnect
comment "Establish connection with a remote mserver";

command connect_ssl(host:str, port:int, usr:str, passwd:str,lang:str):int
address SERVERconnectssl
comment "Establish connection with a remote mserver using the
secure socket layer";

command disconnect(dbalias:str):int
address SERVERdisconnectWithAlias
comment "Close connection with a remote mserver";

command disconnect():int
address SERVERdisconnectALL
comment "Close connections with all remote mserver";

command setAlias(dbalias:str)
address SERVERsetAlias
comment "Give the channel a logical name";

command lookup(dbalias:str):int
address SERVERlookup
comment "Retrieve the connection identifier";

command disconnect(mid:int):void
address SERVERdisconnect
comment "Terminate the session";

command destroy(mid:int):void
address SERVERdestroy
comment "Destroy the handle";

command ping(mid:int):int
address SERVERping
comment "Test availability of server";

command query(mid:int, qry:str):int
address SERVERquery
comment "Sent the query for execution";

command query_handle(mid:int, qry:str):int
address SERVERquery_handle
comment "Sent the query for execution";

pattern query_array(mid:int, qry:str, arg:str...):int
address SERVERquery_array
comment "Sent the query for execution replacing '?' by arguments";

command prepare(mid:int, qry:str):int
address SERVERprepare
comment "Prepare a query for execution";

command finish(hdl:int):int
address SERVERfinish
comment "Remove all remaining answers";

command get_field_count(hdl:int):int
address SERVERget_field_count
comment "Return number of fields";

command get_row_count(hdl:int):int
address SERVERget_row_count
comment "Return number of rows";

command fetch_row(hdl:int):int
address SERVERrows_affected
comment "Return number of affected rows";

command fetch_row(hdl:int):int
address SERVERfetch_row
comment "Retrieve the next row for analysis";

command fetch_all_rows(hdl:int):int
address SERVERfetch_all_rows
comment "Retrieve all rows into the cache";

command fetch_field(hdl:int,fnr:int):str
address SERVERfetch_field_str
comment "Retrieve a single field";

command fetch_field(hdl:int,fnr:int):int
address SERVERfetch_field_int
comment "Retrieve a single int field";

command fetch_field(hdl:int,fnr:int):lng
address SERVERfetch_field_lng
comment "Retrieve a single lng field";

command fetch_field(hdl:int,fnr:int):sht
address SERVERfetch_field_sht
comment "Retrieve a single sht field";

command fetch_field(hdl:int,fnr:int):void
address SERVERfetch_field_void
comment "Retrieve a single void field";

command fetch_field(hdl:int,fnr:int):oid
address SERVERfetch_field_oid
comment "Retrieve a single void field";

command fetch_field(hdl:int,fnr:int):chr
address SERVERfetch_field_chr
comment "Retrieve a single chr field";

command fetch_field_array(hdl:int):bat[:int,:str]
address SERVERfetch_field_bat
comment "Retrieve all fields for a row";

command fetch_line(hdl:int):str
address SERVERfetch_line
comment "Retrieve a complete line";

command fetch_reset(hdl:int):int
address SERVERfetch_reset
comment "Reset the cache read line.";

command next_result(hdl:int):int
address SERVERnext_result
comment "Go to next result set";

command error(mid:int):int
address SERVERerror
comment "Check for an error in the communication";

command getError(mid:int):str
address SERVERgetError
comment "Get error message";

command explain(mid:int):str
address SERVERexplain
comment "Turn the error seen into a string";

pattern put(mid:int, nme:str, val:any_1):void
address SERVERput
comment "Send a value to a remote site";

pattern put(nme:str, val:any_1):str
address SERVERputLocal
comment "Prepare sending a value to a remote site";

pattern rpc(key:int,qry:str...):any
address SERVERmapi_rpc_single_row
comment "Sent a simple query for execution and fetch result";

pattern rpc(key:int,qry:str):bat[:any_1,:any_2]
address SERVERmapi_rpc_bat;

command rpc(key:int,qry:str):void
address SERVERquery
comment "Sent a simple query for execution";

pattern bind(key:int,rschema:str,rtable:str,rcolumn:str,i:int):bat[:any_1,:any_2]
address SERVERbindBAT
comment "Bind a remote variable to a local one";

pattern bind(key:int,rschema:str,rtable:str,i:int):bat[:any_1,:any_2]
address SERVERbindBAT
comment "Bind a remote variable to a local one";

pattern bind(key:int,remoteName:str):bat[:any_1,:any_2]
address SERVERbindBAT
comment "Bind a remote variable to a local one";


mserver.listen();
@-
@{
#command listen(open:bit):int
#address SERVERlisten_open
#comment "Start a Mapi server on the default port global bound or not";
#command receive(key:int,nme:str):bat[:any_1,:any_2]
#address SERVERreceive
#comment "Fetch a bat from a remote site";

#command send(key:int,nme:str, r:bat[:any_1,:any_2]):void
#address SERVERsend
#comment "Sent a bat to a remote site";
command prelude()
address SERVERprelude;
command epilogue()
address SERVERepilogue;

@h
#ifndef SERVER_H
#define SERVER_H
/* #define DEBUG_SERVER */

#include "mal_client.h"
#include "mal_session.h"
#include "mal_exception.h"
#include "mal_interpreter.h"
#include "mal_authorize.h"
#include "mal_sabaoth.h"
#include <Mapi.h>

#ifdef WIN32
#ifndef LIBMSERVER
#define m_export extern __declspec(dllimport)
#else
#define m_export extern __declspec(dllexport)
#endif
#else
#define m_export extern
#endif


#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define SERVERPORT		50000
#define SERVERSSLPORT		40000
#define SERVERMAXUSERS 		5

m_export str SERVERlistenThread(int *Sock);
m_export str SERVERlisten(int *Port, str *Usockfile, int *Maxusers, str *Cmd);
m_export bat * SERVERprelude(void);
m_export void SERVERepilogue(void);
m_export str SERVERlistenSSL(int *Port, int *Maxusers, str keyfile, str certfile, str cmd);
m_export str SERVERlisten_default(int *ret);
m_export str SERVERlisten2(int *ret, int *port, int *maxusers);
m_export str SERVERlisten3(int *ret, int *port, int *maxusers, str *cmd);
m_export str SERVERlisten_port(int *ret, int *pid);
m_export str SERVERstop(int *ret);
m_export str SERVERsuspend(int *ret);
m_export str SERVERresume(int *ret);
m_export void SERVERexit(void);

m_export str SERVERconnect(int *ret, str *host, int *port, str *username, str *password, str *lang);
m_export str SERVERdisconnectWithAlias(int *ret, str *db_alias);
m_export str SERVERdisconnectALL(int *ret);
m_export str SERVERreconnectAlias(int *ret, str *host, int *port, str *dbalias, str *username, str *password, str *lang);
m_export str SERVERreconnectWithoutAlias(int *ret, str *host, int *port, str *username, str *password, str *lang);
m_export str SERVERconnectssl(int *ret, str *host, int *port, str *username, str *password, str *lang);
m_export str SERVERtrace(int *ret, int *mid, int *flag);
m_export str SERVERdisconnect(int *ret, int *mid);
m_export str SERVERsetAlias(int *ret, int *mid, str *dbalias);
m_export str SERVERlookup(int *ret, str *dbalias);
m_export str SERVERdestroy(int *ret, int *mid);
m_export str SERVERreconnect(int *ret, int *mid);
m_export str SERVERping(int *ret, int *mid);
m_export str SERVERquery(int *ret, int *mid, str *qry);
m_export str SERVERquery_handle(int *ret, int *mid, str *qry);
m_export str SERVERquery_array(MalBlkPtr mb, MalStkPtr stk, InstrPtr pc);
m_export str SERVERprepare(int *ret, int *key, str *qry);
m_export str SERVERexecute(int *ret, int *idx);
m_export str SERVERfinish(int *ret, int *idx);
m_export str SERVERrows_affected(int *ret, int *idx);
m_export str SERVERget_row_count(int *ret, int *idx);
m_export str SERVERget_field_count(int *ret, int *idx);
m_export str SERVERfetch_row(int *ret, int *idx);
m_export str SERVERfetch_all_rows(int *ret, int *idx);
m_export str SERVERfetch_field_str(str *ret, int *idx, int *fnr);
m_export str SERVERfetch_field_int(int *ret, int *idx, int *fnr);
m_export str SERVERfetch_field_lng(lng *ret, int *idx, int *fnr);
m_export str SERVERfetch_field_sht(sht *ret, int *idx, int *fnr);
m_export str SERVERfetch_field_void(oid *ret, int *idx, int *fnr);
m_export str SERVERfetch_field_oid(oid *ret, int *idx, int *fnr);
m_export str SERVERfetch_field_chr(chr *ret, int *idx, int *fnr);
m_export str SERVERfetch_line(str *ret, int *key);
m_export str SERVERnext_result(int *ret, int *key);
m_export str SERVERfetch_reset(int *ret, int *key);
m_export str SERVERfetch_field_bat(int *bid, int *idx);
m_export str SERVERerror(int *ret, int *idx);
m_export str SERVERgetError(str *ret, int *idx);
m_export str SERVERexplain(str *ret, int *idx);
m_export str SERVERmapi_rpc_single_row(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
m_export str SERVERmapi_rpc_single_bat(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
m_export str SERVERput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
m_export str SERVERputLocal(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
m_export str SERVERbindBAT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
m_export str SERVERclient(int *res, stream **In, stream **Out);
m_export str SERVERmapi_rpc_single_row(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
m_export str SERVERmapi_rpc_bat(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif /* SERVER_H */
@c
#include "mal_config.h"
#include "mserver.h"

#include  <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef NATIVE_WIN32
#define s_close(s)	closesocket(s)
#else
#define s_close(s)	close(s)
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif

static char seedChars[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
	'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
	'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
	'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'};


static void generateChallenge(str buf, int min, int max) {
	size_t size;
	size_t chr;
	size_t i;

	/* don't seed the randomiser, or you get the same challenge during
	 * the same second */
	/* srand(time(NULL)); */
	size = rand();
	size = (size % (max - min)) + min;
	for (i = 0; i < size; i++) {
		chr = rand();
		chr %= 62;
		buf[i] = seedChars[chr];
	}
	buf[i] = '\0';
}

static void 
doChallenge(str cmd, int msgsock) {
	if (cmd == NULL) {
		char *buf = (char *) GDKmalloc(BLOCK);
		char *challenge;
		char *algos;
		stream *fdin = block_stream( socket_rastream(msgsock, "Server read"));
		stream *fdout = block_stream( socket_wastream(msgsock, "Server write"));
		bstream *bs;

		if (!fdin || !fdout) {
			GDKsyserror("SERVERlisten:fdin or fdout problems");
			return;
		}

		assert(buf);

		/* generate the challenge string */
		challenge = alloca(sizeof(char) * (12 + 1));
		generateChallenge(challenge, 8, 12);
		if (AUTHgetHashAlgorithms(&algos) != MAL_SUCCEED) assert (0);
		/* note that we claim to speak proto 8 here */
		stream_printf(fdout, "%s:mserver:8:%s:%s",
				challenge,
				algos,
#ifdef WORDS_BIGENDIAN
				"BIG"
#else
				"LIT"
#endif
				);
		stream_flush(fdout);
		/* get response */
		stream_read_block(fdin, buf, BLOCK, 1);

		/* in embedded mode we allow just one client */
		if (GDKembedded && MCcountClients() > 1) {
			stream_close(fdin);
			stream_destroy(fdin);
			stream_close(fdout);
			stream_destroy(fdout);
			return;
		}
#ifdef DEBUG_SERVER
		printf("mserver:Client accepted %s\n", name);
		fflush(stdout);

		THRprintf(GDKout, "#SERVERlisten:client accepted %d\n", msgsock);
		THRprintf(GDKout, "#SERVERlisten:client string %s\n", name);
#endif
		bs = bstream_create(fdin, 128 * BLOCK);

		bs->eof = 1;
		MSscheduleClient(buf, challenge, bs, fdout);
	} else {
		/* in M4 it is possible to execute a command directly */
	}
}

static char *threadcommand;
static int usock = -1;
static MT_Id listener[8]; 
static int lastlistener=0;
static int serveractive=TRUE;

str
SERVERlistenThread(int *Sock)
{
	char *msg = 0;
	char *cmd = threadcommand;

	if( lastlistener < 8 )
		listener[lastlistener++] = MT_getpid();
	(void)usock;
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		int sock = *Sock;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select(msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "select failed";
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR || serveractive==FALSE) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
#ifdef DEBUG_SERVER
		printf("server:accepted\n");
		fflush(stdout);
#endif
		doChallenge(cmd, msgsock);
	} while (1);
error:
	throw(IO, "mserver.listen", msg);
}

/**
 * Small utility function to call the sabaoth marchConnection function
 * with the right arguments.  If the socket is bound to 0.0.0.0 the
 * hostname address is used, to make the info usable for servers outside
 * localhost.
 */
void SERVERannounce(struct in_addr addr, int port, int ssl) {
	str buf = alloca(sizeof(char) * 1024);
	str host = NULL;
	bit bssl = ssl != 0 ? 1 : 0;

	if (addr.s_addr == INADDR_ANY) {
		host = alloca(sizeof(char) * (90 + 1));
		gethostname(host, 90);
		host[90] = '\0';
	} else {
		/* avoid doing this, it requires some includes that probably
		 * give trouble on windowz
		host = inet_ntoa(addr);
		 */
		host = alloca(sizeof(char) * ((3 + 1 + 3 + 1 + 3 + 1 + 3) + 1));
		sprintf(host, "%u.%u.%u.%u",
				(unsigned) ((ntohl(addr.s_addr) >> 24) & 0xff),
				(unsigned) ((ntohl(addr.s_addr) >> 16) & 0xff),
				(unsigned) ((ntohl(addr.s_addr) >> 8) & 0xff),
				(unsigned) (ntohl(addr.s_addr) & 0xff));
	}
	if ((buf = SABAOTHmarchConnection(&ssl, &host, &port, &bssl)) != MAL_SUCCEED)
		GDKfree(buf);
}

str
SERVERlisten(int *Port, str *Usockfile, int *Maxusers, str *Cmd)
{
	struct sockaddr_in server;
	int sock = -1;
	int *Sock = GDKmalloc(sizeof(int));

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
#endif
	SOCKLEN length = 0;
	int on = 1;
	int i = 0;
	MT_Id pid, *pidp = &pid;
	int port;
	int maxusers;
	char msg[512], *cmd, *usockfile, host[512];

	port = *Port;
	if (Usockfile == NULL || *Usockfile == 0 || strcmp(*Usockfile, str_nil) == 0)
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(*Usockfile);
#else
		usockfile = NULL;
		throw(IO, "mserver.listen", "Unix domain sockets are not supported");
#endif
	}
	maxusers = *Maxusers;
	cmd = Cmd ? GDKstrdup(*Cmd) : NULL;

	maxusers = (maxusers ? maxusers : SERVERMAXUSERS);

	if (port < 0 && usockfile == NULL)
		throw(IO, "mserver.listen", "No port or socket file specified");

	if (port >= 0) {
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
			throw(IO, "mserver.listen",
					"Creation of stream socket failedi: %s",
					strerror(errno));

		/* In auto-sensing mode, start at the default */
		/* FIXME: should be configurable via the config file */
		if (*Port == 0)
			port = SERVERPORT;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		server.sin_family = AF_INET;
		/* FIXME: this should be configurable via the config file */
		server.sin_addr.s_addr = INADDR_ANY;
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;
		length = (SOCKLEN) sizeof(server);

		do {
			server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
			if (bind(sock, (SOCKPTR) &server, length) < 0) {
				/* FIXME: this should come from the config file */
				if (
#ifdef EADDRINUSE
errno == EADDRINUSE &&
#else 
#ifdef WSAEADDRINUSE 
errno == WSAEADDRINUSE &&
#endif
#endif
 					*Port == 0 && port < 60000) {
					port++;
					continue;
				}
				throw(IO, "mserver.listen",
						"Binding to stream socket port %d failed: %s",
						port, strerror(errno));
			} else {
				break;
			}
		} while (1);

		if (getsockname(sock, (SOCKPTR) &server, &length) < 0)
			throw(IO, "mserver.listen",
					"Failed getting socket name: %s",
					strerror(errno));
		listen(sock, maxusers);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock < 0) {
			unlink(usockfile);
			throw(IO, "mserver.listen",
					"Creation of Unix socket failed: %s",
					strerror(errno));
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (SOCKLEN) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			unlink(usockfile);
			throw(IO, "mserver.listen",
					"Binding to Unix socket file %s failed: %s",
					usockfile, strerror(errno));
		}
		listen(usock, maxusers);
	}
#endif

#ifdef DEBUG_SERVER
	THRprintf(GDKout, "#SERVERlisten:Network started at %d\n", port);
#endif
	threadcommand = cmd;
	*Sock = sock;

	if (MT_create_thread(pidp, (void (*)(void *)) SERVERlistenThread, Sock) < 0) {
		throw(MAL, "mserver.listen", "Starting thread failed");
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	gethostname(host, (int) 512);
	(void) msg;
#ifdef DEBUG_SERVER
	snprintf(msg, (int) 512, "#Ready to accept connections on %s:%d\n", host, port);
	stream_printf(GDKout, "%s", msg);
#endif
	SERVERannounce(server.sin_addr, port, 0);
	return MAL_SUCCEED;
}

#ifdef HAVE_OPENSSL
static char *
ssl_error(const char *name, int err, int ret)
{
	char *errstr, *s;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {	/* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0)
			errstr = ERR_error_string(e, buf);
		else {		/* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	s = (char*) GDKmalloc(strlen(errstr) + strlen(name) + 4);
	sprintf(s, "%s: %s\n", name, errstr);	/* we allocated enough, so it fits */
	return s;
}

static MT_Lock *mutex_buf;

static void
locking_function(int mode, int n, const char *file, int line)
{
	(void) file;
	(void) line;
	if (mode & CRYPTO_LOCK){
		MT_set_lock(mutex_buf[n], "locking_function");
	} else {
		MT_unset_lock(mutex_buf[n], "locking_function");
	}
}

static unsigned long
id_function(void)
{
	return (unsigned long) MT_getpid();
}
#endif /* HAVE_OPENSSL */

bat *
SERVERprelude(void)
{
#ifdef HAVE_OPENSSL
	int i, nlocks;

	nlocks = CRYPTO_num_locks();
	mutex_buf = GDKmalloc(nlocks * sizeof(*mutex_buf));
	if (mutex_buf == NULL) {
		GDKsyserror("SERVERprelude: failed to allocate %d mutexes\n", nlocks);
		return NULL;
	}
	for (i = 0; i < nlocks; i++)
		MT_lock_init(&mutex_buf[i]);
	CRYPTO_set_locking_callback(locking_function);
	CRYPTO_set_id_callback(id_function);
#endif
	return NULL;
}

void
SERVERepilogue(void)
{
#ifdef HAVE_OPENSSL
	if (mutex_buf) {
		int i, nlocks;

		nlocks = CRYPTO_num_locks();
		CRYPTO_set_id_callback(NULL);
		CRYPTO_set_locking_callback(NULL);
		for (i = 0; i < nlocks; i++)
			MT_destroy_lock(mutex_buf[i]);
		GDKfree(mutex_buf);
		mutex_buf = NULL;
	}
	/* callString(mal_clients, "sabaoth.retreatConnection(...);", 0); */
#endif /* HAVE_OPENSSL */
	/* callString(mal_clients, "sabaoth.retreatConnection(...);", 0); */
}

str
SERVERlistenSSL(int *Port, int *Maxusers, str keyfile, str certfile, str cmd)
{
#ifdef HAVE_OPENSSL
	struct sockaddr_in server;
	int sock = -1;
	SOCKLEN length = 0;
	int on = 1;
	int msgsock;
	int i = 0;

	int port = *Port;
	int maxusers = *Maxusers;
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;
	char *msg = NULL;

	if (!port)
		port = SERVERSSLPORT;
	if (!maxusers)
		maxusers = SERVERMAXUSERS;

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL) {
		msg = "creation of SSL context failed\n";
		goto fail;
	}
	if (SSL_CTX_set_cipher_list(ctx, "ALL:!LOW") == 0) {
		msg = "SSL_CTX_set_cipher_list failed\n";
		goto fail;
	}
	if (keyfile && *keyfile && certfile && *certfile) {
		if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) < 1) {
			msg = "SSL_CTX_use_PrivateKey_file failed\n";
			goto fail;
		}
		if (SSL_CTX_use_certificate_chain_file(ctx, certfile) < 1) {
			msg = "SSL_CTX_use_certificate_chain_file failed\n";
			goto fail;
		}
	}
	if (keyfile)
		GDKfree(keyfile);
	if (certfile)
		GDKfree(certfile);

	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("SERVERlistenSSL:creation of stream socket failed\n");
		goto fail;
	}
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;

	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR) & server, length) < 0) {
		GDKsyserror("SERVERlistenSSL:binding to stream socket (%d) failed\n", port);
		goto fail;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR) & server, &length) < 0) {
		msg = "getting socket name\n";
		goto fail;
	}
	listen(sock, maxusers);

#ifdef DEBUG_SERVER
	THRprintf(GDKout, "#SERVERlistenSSL:Network started at %d\n", port);
#endif
	do {
		int retval;
		struct timeval tv;
		fd_set fds;

		FD_ZERO(&fds);
		FD_SET(sock, &fds);
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		retval = select(sock + 1, &fds, &fds, &fds, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			GDKsyserror("SERVERlistenSSL:select failed\n");
			goto fail;
		}
		if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "Accept failed";
				goto fail;
			}
			continue;
		}
		if ((ssl = SSL_new(ctx)) == 0) {
			msg = "SSL_new failed";
			goto fail;
		}

		if (!SSL_set_fd(ssl, msgsock)) {
			msg = "SSL_set_fd failed";
			goto fail;
		}

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_accept(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				errstr = ssl_error("SERVERlistenSSL", err, ret);
				GDKsyserror(errstr);
				GDKfree(errstr);
				SSL_free(ssl);
				close(msgsock);
				goto end_loop;
			}
			break;
		}

		doChallenge(cmd, msgsock);
end_loop:;
	} while (1);
	SSL_CTX_free(ctx);
	close(sock);
	if (cmd)
		GDKfree(cmd);
	SERVERannounce(server.sin_addr, port, 1);
	return MAL_SUCCEED;
fail:;
	if (sock >= 0)
		close(sock);
	if (ctx)
		SSL_CTX_free(ctx);
	if (cmd)
		GDKfree(cmd);
	throw(IO, "mserver.listenSSL", msg);
#else
	(void) Port;
	(void) Maxusers;
	(void) keyfile;
	(void) certfile;
	(void) cmd;
	throw(MAL, "mserver.listenSSL", "No SSL support");
#endif /* HAVE_OPENSSL */
}

@- Wrappers
The MonetDB Version 5 wrappers are collected here
The latest port known to gain access is stored
in the database, so that others can more easily
be notified.
@c
str
SERVERlisten_default(int *ret)
{
	int port = SERVERPORT;
	str p;
	int maxusers = SERVERMAXUSERS;

	(void) ret;
	p = GDKgetenv("mapi_port");
	if (p)
		port = (int) strtol(p, NULL, 10);
	return SERVERlisten(&port, 0, &maxusers, 0);
}

str
SERVERlisten2(int *ret, int *port, int *maxusers)
{
	(void) ret;
	return SERVERlisten(port, 0, maxusers, 0);
}

str
SERVERlisten3(int *ret, int *port, int *maxusers, str *cmd)
{
	(void) ret;
	return SERVERlisten(port, 0, maxusers, cmd);
}

str
SERVERlisten_port(int *ret, int *pid)
{
	int port = *pid;
	int maxusers = SERVERMAXUSERS;

	(void) ret;
	return SERVERlisten(&port, 0, &maxusers, 0);
}
@-
The internet connection listener may be terminated from the server console,
or temporarily suspended to enable system maintenance.
It is advisable to trace the interactions of clients on the server
side. At least as far as it concerns requests received.
The kernel supports this 'spying' behavior with a file descriptor
field in the client record.
@c

str
SERVERstop(int *ret)
{
	int i;
	for( i=0; i< lastlistener; i++)
		MT_kill_thread(listener[i]);
	lastlistener = 0;
	(void) ret;		/* fool compiler */
	return MAL_SUCCEED;
}


str
SERVERsuspend(int *res)
{
	(void) res;
	serveractive= FALSE;
	return MAL_SUCCEED;
}

str
SERVERresume(int *res)
{
	serveractive= TRUE;
	(void) res;
	return MAL_SUCCEED;
}

str
SERVERclient(int *res, stream **In, stream **Out) 
{
	int i = 0;
	char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
	char *challenge;
	int blocked = 0;
	bstream *bs;
	stream *fdin = *In, *fdout = *Out;

	(void) res;
	assert(name);
	memset(name, 0, BLOCK);

	/* is this routine used?  Where? */
	assert(0);

	/* write challenge string, the challenge is currently empty (disabled) */
	challenge = "::mserver_mal:4\n";

	/* temporarily misuse name */
	snprintf(name, BLOCK, "%2u%s", (unsigned int) strlen(challenge), challenge);
	stream_write(fdout, name, strlen(name), 1);
	/* get user name */
	*user = 0;
	stream_read(fdin, user, 1, 1);
	for (i = 0; !stream_errnr(fdin) && i < BLOCK && *user != '\n'; i++) {
		user++;
		stream_read(fdin, user, 1, 1);
	}
	if (stream_errnr(fdin)) {
		throw(IO, "SERVERclient", "fdin write problems");
	}
	*user = 0;
	/* in embedded mode we allow just one client */
#ifdef DEBUG_SERVER
	printf("mserver:Client accepted %s\n", name);
	fflush(stdout);
#endif
	s = strrchr(name, ':');
	blocked = s && strncmp(s, ":blocked", 8) == 0;
	if (blocked) {
		/* printf("mserver:use blocked mode\n");fflush(stdout); */
		*s = 0;
		fdin = block_stream(stream_rstream(fdin));
		fdout = block_stream(stream_wstream(fdout));
	}
#ifdef DEBUG_SERVER
	THRprintf(GDKout, "#SERVERlisten:client accepted %d\n", msgsock);
	THRprintf(GDKout, "#SERVERlisten:client string %s\n", name);
#endif
	bs = bstream_create(fdin, blocked ? 128 * BLOCK : 0);

	if (blocked)
		bs->eof = 1;
	MSscheduleClient(name, challenge, bs, fdout);
	return MAL_SUCCEED;
}

void
SERVERexit(){
	int ret;
	SERVERstop(&ret);
	/* remove any port identity file */
	system("rm -rf .*_port");
}
@+ Remote Processing
The remainder of the file contains the wrappers around
the Mapi library used by application programmers.
Details on the functions can be found there.

Sessions have a lifetime different from dynamic scopes.
This means the  user should use a session identifier
to select the correct handle.
For the time being we use the index in the global
session table. The client pointer is retained to
perform access control. 

We use a single result set handle. All data should be
consumed before continueing.

A few extra routines should be defined to
dump and inspect the sessions table.
	
The remote site may return a single error
with a series of error lines. These contain
then a starting !. They are all stripped here.
@= catchErrors
{int rn;
	if ( ( (rn=mapi_error(mid)) == -4 && hdl && mapi_result_error(hdl))  || rn){
		str err,newerr;
		size_t l;
		char *e,*f;

		if( hdl && mapi_result_error(hdl))
			err= mapi_result_error(hdl);
		else err= mapi_result_error(SERVERsessions[i].hdl);
		l= 2*strlen(err)+8192;
		newerr= (str) alloca(l);

		if (err == NULL)
			err = "(no additional error message)";
		f= newerr; 
		for( e=err+1; *e && l>1; e++)
			if( *e== '!' && *(e-1)=='\n'){
				snprintf(f,l,"MALException:@1:remote error:");
				l-= strlen(f);
				while(*f) f++;
			} else{
				*f++ = *e;
				l--;
			}
		*f=0;
		throw(MAL, "@1", "remote error: %s", newerr);
	}
}
@c
#define MAXSESSIONS 32
struct{
	int key;
	str dbalias;	/* logical name of the session */
	Client c;
	Mapi mid;		/* communication channel */
	MapiHdl hdl;	/* result set handle */
} SERVERsessions[MAXSESSIONS];

static int sessionkey=0;

/* #define MAPI_TEST*/

str
SERVERconnectAll(int *key, str *host, int *port, str *username, str *password, str *lang, int ssl){
	Mapi mid;
	int i;

	mal_set_lock(mal_contextLock,"SERVERconnect");
	for(i=1; i< MAXSESSIONS; i++)
	if( SERVERsessions[i].c ==0 ) break;

	if( i==MAXSESSIONS){
		mal_unset_lock(mal_contextLock,"SERVERconnect");
		throw(IO, "mserver.connect", "Too many sessions");
	}
	SERVERsessions[i].c= MCgetClient();
	SERVERsessions[i].key= ++sessionkey;
	mal_unset_lock(mal_contextLock,"SERVERconnect");

	if (ssl)
		mid = mapi_connect_ssl(*host, *port, *username, *password, *lang, NULL);
	else
		mid = mapi_connect(*host, *port, *username, *password, *lang, NULL);

	if (mapi_error(mid)) {
		str err = mapi_error_str(mid);
		if (err == NULL)
			err = "(no reason given)";
		if (err[0] == '!')
			err = err + 1;
		SERVERsessions[i].c = NULL;
		throw(IO, "mserver.connect", "Could not connect: %s", err);
	}

#ifdef MAPI_TEST
	stream_printf(GDKout,"Succeeded to establish session\n");
#endif
	SERVERsessions[i].mid= mid;
	*key = SERVERsessions[i].key;
	return MAL_SUCCEED;
}

str
SERVERdisconnectALL(int *key){
	int i;

	mal_set_lock(mal_contextLock,"SERVERdisconnect");

	for(i=1; i< MAXSESSIONS; i++)
		if( SERVERsessions[i].c != 0 ) {
			SERVERsessions[i].c = 0;
			SERVERsessions[i].dbalias = NULL;
			*key = SERVERsessions[i].key;
			mapi_disconnect(SERVERsessions[i].mid);
		}

	mal_unset_lock(mal_contextLock,"SERVERdisconnect");

#ifdef MAPI_TEST
	stream_printf(GDKout,"Succeeded to close all session\n");
#endif
	return MAL_SUCCEED;
}

str
SERVERdisconnectWithAlias(int *key, str *dbalias){
	int i;

	mal_set_lock(mal_contextLock,"SERVERdisconnectWithAlias");

	for(i=0; i<MAXSESSIONS; i++)
		 if( SERVERsessions[i].dbalias &&
			 strcmp(SERVERsessions[i].dbalias, *dbalias)==0){
				SERVERsessions[i].c = NULL;
				*key = SERVERsessions[i].key;
				mapi_disconnect(SERVERsessions[i].mid);
				break;
		}

	if( i==MAXSESSIONS){
		mal_unset_lock(mal_contextLock,"SERVERdisconnectWithAlias");
		throw(IO, "mserver.disconnect", "Impossible to close session for db_alias: '%s'", dbalias);
	}

	mal_unset_lock(mal_contextLock,"SERVERdisconnectWithAlias");

#ifdef MAPI_TEST
	stream_printf(GDKout,"Succeeded to close all session\n");
#endif

	return MAL_SUCCEED;
}

str
SERVERconnect(int *key, str *host, int *port, str *username, str *password, str *lang){
	return SERVERconnectAll(key,host,port,username,password,lang, FALSE);
}
str
SERVERconnectssl(int *key, str *host, int *port, str *username, str *password, str *lang){
	return SERVERconnectAll(key,host,port,username,password,lang, TRUE);
}


str
SERVERreconnectAlias(int *key, str *host, int *port, str  * dbalias, str *username, str *password, str *lang){
	int i;
	str msg=MAL_SUCCEED;

	for(i=0; i<MAXSESSIONS; i++)
	 if( SERVERsessions[i].key && 
		 SERVERsessions[i].dbalias &&
		 strcmp(SERVERsessions[i].dbalias, *dbalias)==0){
			*key = SERVERsessions[i].key;
			return msg;
	}

	msg= SERVERconnectAll(key, host, port, username, password, lang, FALSE);
	if( msg == MAL_SUCCEED)
		msg = SERVERsetAlias(&i, key, dbalias);
	return msg;
}
str
SERVERreconnectWithoutAlias(int *key,str *host, int *port, str *username, str *password, str *lang){
	int i;
	str msg=MAL_SUCCEED, nme= "anonymous";

	for(i=0; i<MAXSESSIONS; i++)
	 if( SERVERsessions[i].key ){
			*key = SERVERsessions[i].key;
			return msg;
	}

	msg= SERVERconnectAll(key, host, port, username, password, lang, FALSE);
	if( msg == MAL_SUCCEED)
		msg = SERVERsetAlias(&i, key, &nme);
	return msg;
}
@-
@= accessTest
 for(i=0; i< MAXSESSIONS; i++)
 if( SERVERsessions[i].c &&
     SERVERsessions[i].key== @1 ) break;
 if( i== MAXSESSIONS)
	throw(MAL, "mserver.@2","Access violation,"
		" could not find matching session descriptor");
  mid= SERVERsessions[i].mid;
  (void) mid; /* silence compilers */
@c
str
SERVERsetAlias(int *ret, int *key, str *dbalias){
	int i;
	Mapi mid;
	@:accessTest(*key,setAlias)@
    SERVERsessions[i].dbalias= GDKstrdup(*dbalias);
	*ret = 0;
	return MAL_SUCCEED;
}
str
SERVERlookup(int *ret, str *dbalias)
{
	int i;
	for(i=0; i< MAXSESSIONS; i++)
	if( SERVERsessions[i].dbalias &&
		strcmp(SERVERsessions[i].dbalias, *dbalias)==0){
		*ret= SERVERsessions[i].key; 
		return MAL_SUCCEED;
	}
	throw(MAL, "mserver.lookup", "Could not find database connection");
}
str
SERVERtrace(int *ret, int *key, int *flag){
	(void )ret;
	mapi_trace(SERVERsessions[*key].mid,*flag);
	return MAL_SUCCEED;
}
str
SERVERdisconnect(int *ret, int *key){
	int i;
	Mapi mid;
	@:accessTest(*key,disconnect)@
	mapi_disconnect(mid);
	if( SERVERsessions[i].dbalias)
		GDKfree(SERVERsessions[i].dbalias);
	SERVERsessions[i].dbalias= 0;
	*ret = 0;
	return MAL_SUCCEED;
}
str
SERVERdestroy(int *ret, int *key){
	int i;
	Mapi mid;
	@:accessTest(*key,destroy)@
	mapi_destroy(mid);
	SERVERsessions[i].c= 0;
	if( SERVERsessions[i].dbalias)
		GDKfree(SERVERsessions[i].dbalias);
	SERVERsessions[i].dbalias= 0;
	*ret = 0;
	return MAL_SUCCEED;
}

str
SERVERreconnect(int *ret, int *key){
	int i;
	Mapi mid;
	@:accessTest(*key,destroy)@
	mapi_reconnect(mid);
	*ret = 0;
	return MAL_SUCCEED;
}
str
SERVERping(int *ret, int *key){
	int i;
	Mapi mid;
	@:accessTest(*key,destroy)@
	*ret= mapi_ping(mid);
	return MAL_SUCCEED;
}
str 
SERVERquery(int *ret, int *key, str *qry){
	Mapi mid;
	MapiHdl hdl=0;
	int i;
	@:accessTest(*key,query)@
	if( SERVERsessions[i].hdl)
		mapi_close_handle(SERVERsessions[i].hdl);
	SERVERsessions[i].hdl = mapi_query(mid, *qry);
	@:catchErrors(mserver.query)@
	*ret = *key;
	return MAL_SUCCEED;
}
str 
SERVERquery_handle(int *ret, int *key, str *qry){
	Mapi mid;
	MapiHdl hdl=0;
	int i;
	@:accessTest(*key,query_handle)@
	mapi_query_handle(SERVERsessions[i].hdl, *qry);
	@:catchErrors(mserver.query_handle)@
	*ret = *key;
	return MAL_SUCCEED;
}
str
SERVERquery_array(MalBlkPtr mb, MalStkPtr stk, InstrPtr pc){
	(void) mb; (void) stk; (void) pc;
	throw(MAL, "mserver.query_array","not yet implemented");
}
str 
SERVERprepare(int *ret, int *key, str *qry){
	Mapi mid;
	int i;
	@:accessTest(*key,prepare)@
	if( SERVERsessions[i].hdl)
		mapi_close_handle(SERVERsessions[i].hdl);
	SERVERsessions[i].hdl= mapi_prepare(mid, *qry);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.prepare",
			mapi_result_error(SERVERsessions[i].hdl));
	*ret = *key;
	return MAL_SUCCEED;
}
str 
SERVERexecute(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,execute)@
	mapi_execute(SERVERsessions[i].hdl);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.execute",
			mapi_result_error(SERVERsessions[i].hdl));
	*ret = *key;
	return MAL_SUCCEED;
}
str 
SERVERfinish(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,finish)@
	mapi_finish(SERVERsessions[i].hdl);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.finish",
			mapi_result_error(SERVERsessions[i].hdl));
	*ret = *key;
	return MAL_SUCCEED;
}
str 
SERVERget_row_count(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,get_row_count)@
	*ret= mapi_get_row_count(SERVERsessions[i].hdl);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.get_row_count",
			mapi_result_error(SERVERsessions[i].hdl));
	return MAL_SUCCEED;
}
str 
SERVERget_field_count(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,get_field_count)@
	*ret= mapi_get_field_count(SERVERsessions[i].hdl);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.get_field_count",
			mapi_result_error(SERVERsessions[i].hdl));
	return MAL_SUCCEED;
}
str 
SERVERrows_affected(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,rows_affected)@
	*ret= mapi_rows_affected(SERVERsessions[i].hdl);
	return MAL_SUCCEED;
}
str 
SERVERfetch_row(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,fetch_row)@
	*ret= mapi_fetch_row(SERVERsessions[i].hdl);
	return MAL_SUCCEED;
}
str 
SERVERfetch_all_rows(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,fetch_all_rows)@
	*ret= mapi_fetch_all_rows(SERVERsessions[i].hdl);
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_str(str *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	*ret= GDKstrdup(fld? fld: str_nil);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.fetch_field_str",
			mapi_result_error(SERVERsessions[i].hdl));
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_int(int *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	*ret= fld? (int) atol(fld): int_nil;
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.fetch_field_int",
			mapi_result_error(SERVERsessions[i].hdl));
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_lng(lng *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	*ret= fld? atol(fld): lng_nil;
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.fetch_field_lng",
			mapi_result_error(SERVERsessions[i].hdl));
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_sht(sht *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	*ret= fld? (sht) atol(fld): sht_nil;
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.fetch_field",
			mapi_result_error(SERVERsessions[i].hdl));
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_void(oid *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	@:accessTest(*key,fetch_field)@
	(void) fnr;
	*ret = oid_nil;
	throw(MAL, "mserver.fetch_field_void","defaults to nil");
}
str 
SERVERfetch_field_oid(oid *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.fetch_field_oid",
			mapi_result_error(SERVERsessions[i].hdl));
	if(fld==0 || strcmp(fld,"nil")==0)
		*(oid*) ret= void_nil;
	else *(oid*) ret = (oid) atol(fld);
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_chr(chr *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.fetch_field_chr",
			mapi_result_error(SERVERsessions[i].hdl));
	if(fld==0 || strcmp(fld,"nil")==0)
		*(chr*) ret= chr_nil;
	else *(chr*) ret = *fld;
	return MAL_SUCCEED;
}
str 
SERVERfetch_line(str *ret, int *key){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_line)@
	fld= mapi_fetch_line(SERVERsessions[i].hdl);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.fetch_line",
			mapi_result_error(SERVERsessions[i].hdl));
	*ret= GDKstrdup(fld? fld:str_nil);
	return MAL_SUCCEED;
}
str 
SERVERnext_result(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,next_result)@
	mapi_next_result(SERVERsessions[i].hdl);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.next_result",
			mapi_result_error(SERVERsessions[i].hdl));
	*ret= *key;
	return MAL_SUCCEED;
}
str 
SERVERfetch_reset(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,fetch_reset)@
	mapi_fetch_reset(SERVERsessions[i].hdl);
	if( mapi_error(mid) ) 
		throw(MAL, "mserver.fetch_reset",
			mapi_result_error(SERVERsessions[i].hdl));
	*ret= *key;
	return MAL_SUCCEED;
}
str
SERVERfetch_field_bat(int *bid, int *key){
	int i,j,cnt;
	Mapi mid;
	char *fld;
	int o=0; 
	BAT *b;

	@:accessTest(*key,rpc)@
	b= BATnew(TYPE_oid,TYPE_str,256);
	cnt= mapi_get_field_count(SERVERsessions[i].hdl);
	for(j=0; j< cnt; j++){
		fld= mapi_fetch_field(SERVERsessions[i].hdl,j);
		if( mapi_error(mid) ) {
			*bid = b->batCacheid;
			BBPkeepref(*bid);
			throw(MAL, "mserver.fetch_field_bat",
				mapi_result_error(SERVERsessions[i].hdl));
		}
		BUNins(b,&o,fld, FALSE);
		o++;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	*bid = b->batCacheid;
	BBPkeepref(*bid);
	return MAL_SUCCEED;
}
str
SERVERerror(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,error)@
	*ret= mapi_error(mid);
	return MAL_SUCCEED;
}
str
SERVERgetError(str *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,getError)@
	*ret= GDKstrdup(mapi_error_str(mid));
	return MAL_SUCCEED;
}

str 
SERVERexplain(str *ret, int *key){
	Mapi mid;
	int i;

	@:accessTest(*key,explain)@
	*ret= GDKstrdup(mapi_error_str(mid));
	return MAL_SUCCEED;
}
@-
The remainder should contain the wrapping of 
relevant SERVER functions. Furthermore, we 
should analyse the return value and update 
the stack trace.

Two routines should be 
mserver.rpc(key,"query") 
@-
The generic scheme for handling a remote MAL
procedure call with a single row answer.
@c
void SERVERfieldAnalysis(str fld, int tpe, ValPtr v){
	v->vtype= tpe;
	switch(tpe){
	case TYPE_void:
		v->val.oval = void_nil;
		break;
	case TYPE_oid:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.oval= void_nil;
		else v->val.oval = (oid) atol(fld);
		break;
	case TYPE_bit:
		if(fld== 0 || strcmp(fld,"nil")==0)
			v->val.cval[0]= bit_nil;
		else
		if(strcmp(fld,"true")==0)
			v->val.cval[0]= TRUE;
		if(strcmp(fld,"false")==0)
			v->val.cval[0]= FALSE;
		v->val.cval[1]= 0;
		v->val.cval[2]= 0;
		v->val.cval[3]= 0;
		break;
	case TYPE_chr:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.cval[0]= chr_nil;
		else
			v->val.cval[0]= *fld;
		v->val.cval[1]= 0;
		v->val.cval[2]= 0;
		v->val.cval[3]= 0;
		break;
	case TYPE_sht:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.shval = sht_nil;
		else v->val.shval= (sht)  atol(fld);
		break;
	case TYPE_int:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.ival = int_nil;
		else v->val.ival= (int)  atol(fld);
		break;
	case TYPE_lng:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.lval= lng_nil;
		else v->val.lval= (lng)  atol(fld);
		break;
	case TYPE_flt:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.fval= flt_nil;
		else v->val.fval= (flt)  atof(fld);
		break;
	case TYPE_dbl:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.dval= dbl_nil;
		else v->val.dval= (dbl)  atof(fld);
		break;
	case TYPE_str:
		if(fld==0 || strcmp(fld,"nil")==0){
			v->val.sval= GDKstrdup(str_nil);
			v->len= strlen(v->val.sval);
		} else {
			v->val.sval= GDKstrdup(fld);
			v->len= strlen(fld);
		}
		break;
	}
}
str
SERVERmapi_rpc_single_row(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int key,i,j;
	Mapi mid;
	MapiHdl hdl;
	char *s,*fld, *qry=0;

	key= * (int*) getArgReference(stk,pci,pci->retc);
	@:accessTest(key,rpc)@
#ifdef MAPI_TEST
	stream_printf(GDKout,"about to sent: %s\n",qry);
#endif
	/* glue all strings together */
	for(i= pci->retc+1; i<pci->argc; i++){
		fld= * (str*) getArgReference(stk,pci,i);
		if( qry == 0)
			qry= GDKstrdup(fld);
		else {	
			s= (char*) GDKmalloc(strlen(qry)+strlen(fld)+1);
			strcpy(s,qry);
			strcat(s,fld);
			GDKfree(qry);
			qry= s;
		}
	}
	hdl= mapi_query(mid, qry);
	@:catchErrors(mserver.rpc)@
	GDKfree(qry);

	i= 0;
	while( mapi_fetch_row(hdl)){
		for(j=0; j<pci->retc; j++){
			fld= mapi_fetch_field(hdl,j);
#ifdef MAPI_TEST
			stream_printf(GDKout,"Got: %s\n",fld);
#endif
			switch(getVarType(mb,getArg(pci,j)) ){
			case TYPE_void:
			case TYPE_oid:
			case TYPE_bit:
			case TYPE_chr:
			case TYPE_sht:
			case TYPE_int:
			case TYPE_lng:
			case TYPE_flt:
			case TYPE_dbl:
			case TYPE_str:
				SERVERfieldAnalysis(fld, 
					getVarType(mb,getArg(pci,j)),
					&stk->stk[getArg(pci,j)]);
				break;
			default:
				throw(MAL, "mapi.rpc",
						"Missing type implementation ");
			/* all the other basic types come here */
			}
		}
		i++;
	}
	if( i>1)
		throw(MAL, "mapi.rpc","Too many answers");
	return MAL_SUCCEED;
}
@-
Transport of the BATs is only slightly more complicated.
The generic implementation based on a pattern is the next
step. 
@c
str
SERVERmapi_rpc_bat(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *ret;
	int *key;
	str *qry,err= MAL_SUCCEED;
	int i;
	Mapi mid;
	MapiHdl hdl;
	char *fld1, *fld2;
	BAT *b;
	ValRecord hval,tval;
	int ht,tt;

	ret= (int*) getArgReference(stk,pci,0);
	key= (int*) getArgReference(stk,pci,pci->retc);
	qry= (str*) getArgReference(stk,pci,pci->retc+1);
	@:accessTest(*key,rpc)@
	ht= getHeadType(getVarType(mb,getArg(pci,0)));
	tt= getTailType(getVarType(mb,getArg(pci,0)));

	hdl= mapi_query(mid, *qry);
	@:catchErrors(mserver.rpc)@
	
	b= BATnew(ht,tt,256);
	i= 0;
	if ( mapi_fetch_row(hdl)){
		int oht = ht, ott = tt;

		fld1= mapi_fetch_field(hdl,0);
		fld2= mapi_fetch_field(hdl,1);
		if (fld1 && ht == TYPE_void) 
			ht = TYPE_oid;
		if (fld2 && tt == TYPE_void) 
			tt = TYPE_oid;
		SERVERfieldAnalysis(fld1, ht, &hval);
		SERVERfieldAnalysis(fld2, tt, &tval);
		if (oht != ht)
			BATseqbase(b, hval.val.oval);
		if (ott != tt)
			BATseqbase(BATmirror(b), tval.val.oval);
		BUNins(b,VALget(&hval),VALget(&tval), FALSE);
	}
	while( mapi_fetch_row(hdl)){
		fld1= mapi_fetch_field(hdl,0);
		fld2= mapi_fetch_field(hdl,1);
		SERVERfieldAnalysis(fld1, ht, &hval);
		SERVERfieldAnalysis(fld2, tt, &tval);
		BUNins(b,VALget(&hval),VALget(&tval), FALSE);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	*ret = b->batCacheid;
	BBPkeepref(*ret);

	return err;
}
str
SERVERput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *key;
	str *nme;
	ptr val;
	int i,tpe;
	Mapi mid;
	MapiHdl hdl=0;
	char *w=0, buf[BUFSIZ];

	key= (int*) getArgReference(stk,pci,pci->retc);
	nme= (str*) getArgReference(stk,pci,pci->retc+1);
	val= (ptr) getArgReference(stk,pci,pci->retc+2);
	@:accessTest(*key,put)@
	switch( (tpe=getArgType(mb,pci, pci->retc+2)) ){
	case TYPE_bat:
	case TYPE_ptr:
		throw(MAL, "mserver.glue","Unsupported type");
        case TYPE_str:
                snprintf(buf,BUFSIZ,"%s:=%s;",*nme,*(char**)val);
                break;
	default:
		ATOMformat(tpe,val,&w);
		snprintf(buf,BUFSIZ,"%s:=%s;",*nme,w);
		GDKfree(w);
		break;
	}
	if( SERVERsessions[i].hdl)
		mapi_close_handle(SERVERsessions[i].hdl);
	SERVERsessions[i].hdl= mapi_query(mid, buf);
	@:catchErrors(mserver.put)@
	return MAL_SUCCEED;
}
str
SERVERputLocal(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *ret, *nme;
	ptr val;
	int tpe;
	char *w=0, buf[BUFSIZ];

	ret= (str*) getArgReference(stk,pci,0);
	nme= (str*) getArgReference(stk,pci,pci->retc);
	val= (ptr) getArgReference(stk,pci,pci->retc+1);
	switch( (tpe=getArgType(mb,pci, pci->retc+1)) ){
	case TYPE_bat:
	case TYPE_ptr:
		throw(MAL, "mserver.glue","Unsupported type");
        case TYPE_str:
                snprintf(buf,BUFSIZ,"%s:=%s;",*nme,*(char**)val);
                break;
	default:
		ATOMformat(tpe,val,&w);
		snprintf(buf,BUFSIZ,"%s:=%s;",*nme,w);
		GDKfree(w);
		break;
	}
	*ret= GDKstrdup(buf);
	return MAL_SUCCEED;
}
str 
SERVERbindBAT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *key;
	str *nme,*tab,*col;
	int i;
	Mapi mid;
	MapiHdl hdl=0;
	char buf[BUFSIZ];
	key= (int*) getArgReference(stk,pci,pci->retc);
	nme= (str*) getArgReference(stk,pci,pci->retc+1);
	@:accessTest(*key,bind)@
	if( pci->argc == 6) {
		tab= (str*) getArgReference(stk,pci,pci->retc+2);
		col= (str*) getArgReference(stk,pci,pci->retc+3);
		i= *(int*) getArgReference(stk,pci,pci->retc+4);
		snprintf(buf,BUFSIZ,"%s:bat[:void,:%s]:=sql.bind(\"%s\",\"%s\",\"%s\",0,%d);",
			getVarName(mb,getDestVar(pci)),
			getTypeName(getTailType(getVarType(mb,getDestVar(pci)))),
			*nme, *tab,*col,i);
	} else if( pci->argc == 5) {
		tab= (str*) getArgReference(stk,pci,pci->retc+2);
		i= *(int*) getArgReference(stk,pci,pci->retc+3);
		snprintf(buf,BUFSIZ,"%s:bat[:void,:oid]:=sql.bind(\"%s\",\"%s\",0,%d);",
			getVarName(mb,getDestVar(pci)),*nme, *tab,i);
	} else {
		str hn,tn;
		int target= getArgType(mb,pci,0);
		hn= getTypeName(getHeadType(target));
		tn= getTypeName(getTailType(target));
		snprintf(buf,BUFSIZ,"%s:bat[%s,%s]:=bbp.bind(\"%s\");",
			getVarName(mb,getDestVar(pci)), hn,tn, *nme);
		GDKfree(hn);
		GDKfree(tn);
	}
	if( SERVERsessions[i].hdl)
		mapi_close_handle(SERVERsessions[i].hdl);
	SERVERsessions[i].hdl= mapi_query(mid, buf);
	@:catchErrors(mserver.bind)@
	return MAL_SUCCEED;
}
@}
