@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mserver
@a N.J. Nes P. Boncz, S. Mullender, M. Kersten
@v 1.1
@+ MonetDB's Internet Interface
This module contains a simple interface for setting up
internet connections and to initialize a client session.
Without loading this interface, Monet runs in administrator
mode. 

Clients may initialize a private listener to implement
specific services. For example, in an OLTP environment
it may make sense to have a listener for each transaction
type, which simply parses a sequence of transaction parameters.

The information about open listeners is maintain in global tables.
They behave as views on the actual state.
No protection is currently possible against malicious users changing them.

Authorization of access to the server is handled as part
of the client record initialization phase. Currently this part
is still lacking the necessary functionality.

The client can use between blocked and unblocked interaction.
The former is preferred, since it will give the best performance.
This property is indicated in the start-up sequence by passing
the authentiaction string  "<username>:<password>:lang:blocked".
An unblocked stream is obtained using "<username>:<password>:lang",
which is also backward compatible for older applications.
@mal
module mserver;

command listen():int
address SERVERlisten_default
comment "Start a Mapi server with the default settings.";
command listen(port:int):int
address SERVERlisten_port
comment "Start a Mapi server on the given port";
#command listen(open:bit):int
#address SERVERlisten_open
#comment "Start a Mapi server on the default port global bound or not";
command listen(port:int, maxusers:int):int
address SERVERlisten2
comment "Start a Mapi server.";

command listen(port:int, maxusers:int, cmd:str):int
address SERVERlisten3
comment "Start the Mapi listener on <port> for <maxusers>. 
	For a new client connection MAL procedure <cmd>(Stream s_in, Stream s_out)
	is called.If no <cmd> is specified a new client thread is forked.";

command listen_ssl(port:int, maxusers:int,
	keyfile:str,certfile:str, cmd:str):int
address SERVERlistenSSL
comment "Start the Mapi listener on <port> for <maxusers> using SSL. 
	<keyfile> and <certfile> give the path names for files with the 
	server key and certificates in PEM format. For a new client connection 
	MAL procedure <cmd>(Stream s_in, Stream s_out) is called.
	If no <cmd> is specified a new client thread is forked.";

command stop():void
address SERVERstop
comment "Terminate connection listeners"; 

command suspend():void
address SERVERsuspend
comment "Suspend accepting connections";

command resume():void
address SERVERresume
comment "Resume connection listeners";

command malclient(in:streams, out:streams):void
address SERVERclient
comment "Start a Mapi client.";

@-
The complete SERVER library is also available to setup
communication with another Mserver.
This library uses pointer handles, which we replace with
an index in a locally maintained table. It provides a handle
to easily detect havoq clients.
@mal
command connect(host:str, port:int, usr:str, passwd:str,lang:str):int
address SERVERconnect
comment "Establish connection with a remote mserver";

command error(mid:int):int
address SERVERerror
comment "Check for an error in the communication");

command explain(mid:int):str
address SERVERexplain
comment "Turn the error seen into a string";
@-
The remote procedure calls require the target type
to be known to enable proper parsing of the result
@mal
pattern rpc(key:int,qry:str):any
address SERVERmapi_rpc_single_row
comment "Sent a simple query for execution and fetch result";

command rpc(key:int,qry:str):bat[:oid,:int]
address SERVERmapi_rpc_oid_int;

mserver.listen();
@{
command prelude()
address SERVERprelude;
command epilogue()
address SERVERepilogue;

@h
#ifndef SERVER_H
#define SERVER_H
/* #define DEBUG_SERVER */

#include "mal_client.h"
#include "mal_session.h"
#include "mal_exception.h"
#include "mal_interpreter.h"
#include "Mapi.h"

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define SERVERPORT		50000
#define SERVERSSLPORT		40000
#define SERVERMAXUSERS 		5

mal_export str SERVERlistenThread(int *Sock);
mal_export str SERVERlisten(int *Port, str *Usockfile, int *Maxusers, str *Cmd);
mal_export bat * SERVERprelude(void);
mal_export void SERVERepilogue(void);
mal_export str SERVERlistenSSL(int *Port, int *Maxusers, str keyfile, str certfile, str cmd);
mal_export str SERVERlisten_default(int *ret);
mal_export str SERVERlisten2(int *ret, int *port, int *maxusers);
mal_export str SERVERlisten3(int *ret, int *port, int *maxusers, str *cmd);
mal_export str SERVERlisten_port(int *ret, int *pid);
mal_export str SERVERstop(int *ret);
mal_export str SERVERsuspend(int *ret);
mal_export str SERVERresume(int *ret);
mal_export void SERVERexit();

mal_export str SERVERconnect(int *ret, str *host, int *port, str *username, str *password, str *lang);
mal_export str SERVERerror(int *ret, int *idx);
mal_export str SERVERexplain(str *ret, int *idx);
mal_export str SERVERmapi_rpc_int(int *ret, int *key, str *qry);
mal_export str SERVERmapi_rpc_oid_int(int *ret, int *key, str *qry);
mal_export str SERVERmapi_rpc_single_row(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif /* SERVER_H */
@c
#include "mserver.h"

#include  <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef NATIVE_WIN32
#define s_close(s)	closesocket(s)
#else
#define s_close(s)	close(s)
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif


static char *threadcommand;
static int usock = -1;
static MT_Id listener[8]; 
static int lastlistener=0;
static int serveractive=TRUE;

str
SERVERlistenThread(int *Sock)
{
	char *msg = 0;
	char *cmd = threadcommand;

	if( lastlistener < 8 )
		listener[lastlistener++] = MT_getpid();
	(void)usock;
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		int sock = *Sock;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select(msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "select failed\n";
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR || serveractive==FALSE) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
#ifdef DEBUG_SERVER
		printf("server:accepted\n");
		fflush(stdout);
#endif
		if (cmd == NULL) {
			int i = 0;
			char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
			char *challenge;
			int blocked = 0;
			stream *fdin = socket_rastream(msgsock, "Server read");
			stream *fdout = socket_wastream(msgsock, "Server write");
			bstream *bs;

			assert(name);
			memset(name, 0, BLOCK);
			if (fdin == 0 || stream_errnr(fdin)) {
				GDKsyserror("SERVERlisten:fdin problems\n");
				continue;
			}
			/* write challenge string, the challenge is currently empty
			  (disabled), note that we claim to speak proto 5 here */
			challenge = "::mserver:5\n";
			/* temporarily misuse name */
			snprintf(name, BLOCK, "%2d%s", (unsigned int) strlen(challenge), challenge);
			stream_write(fdout, name, strlen(name), 1);
			/* get user name */
			*user = 0;
			stream_read(fdin, user, 1, 1);
			for (i = 0; !stream_errnr(fdin) && i < BLOCK && *user != '\n'; i++) {
				user++;
				stream_read(fdin, user, 1, 1);
			}
			if (stream_errnr(fdin)) {
				GDKsyserror("SERVERlisten: fdin problems\n");
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
			*user = 0;

			/* in embedded mode we allow just one client */
			if (GDKembedded && countClients() > 1) {
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
#ifdef DEBUG_SERVER
			printf("mserver:Client accepted %s\n", name);
			fflush(stdout);
#endif
			s = strchr(name, ':'); /* user */
			if (s) s = strchr(s + 1, ':'); /* password */
			if (s) s = strchr(s + 1, ':'); /* language */
			blocked = s && strncmp(s, ":blocked", 8) == 0;
			if (blocked) {
				/* printf("mserver:use blocked mode\n");fflush(stdout); */
				fdin = block_stream(stream_rstream(fdin));
				fdout = block_stream(socket_wstream(msgsock, "Server write"));
			} else {
				fdout = socket_wastream(msgsock, "Server write");
			}

			if (fdout == 0) {
				GDKsyserror("SERVERlisten:fdout problems\n");
				continue;
			}
#ifdef DEBUG_SERVER
			THRprintf(GDKerr, "SERVERlisten:client accepted %d\n", msgsock);
			THRprintf(GDKerr, "SERVERlisten:client string %s\n", name);
#endif
			bs = bstream_create(fdin, blocked ? 128 * BLOCK : 0);

			if (blocked)
				bs->eof = 1;
			scheduleClient(name, bs, fdout);
		} else {
			/* in M4 it is possible to execute a command directly */
		}
	} while (1);
error:
	return throwMessage("mserver.listen", msg);
}

str
SERVERlisten(int *Port, str *Usockfile, int *Maxusers, str *Cmd)
{
	struct sockaddr_in server;
	int sock = -1;
	int *Sock = GDKmalloc(sizeof(int));

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
#endif
	SOCKLEN length = 0;
	int on = 1;
	int i = 0;
	MT_Id pid, *pidp = &pid;
	int port;
	int maxusers;
	char msg[512], *cmd, *usockfile, host[512];

	port = *Port;
	if (Usockfile == NULL || *Usockfile == 0 || strcmp(*Usockfile, str_nil) == 0)
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(*Usockfile);
#else
		usockfile = NULL;
		GDKwarning("SERVERlisten: Unix domain sockets are not supported\n");
#endif
	}
	maxusers = *Maxusers;
	cmd = Cmd ? GDKstrdup(*Cmd) : NULL;

	port = (port ? port : SERVERPORT);
	maxusers = (maxusers ? maxusers : SERVERMAXUSERS);

	if (port <= 0 && usockfile == NULL)
		return throwMessage("mserver.listen", "no port or socket file specified\n");

	if (port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
			return throwMessage("mserver.listen", "creation of stream socket failed\n");
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = INADDR_ANY;
		server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (SOCKLEN) sizeof(server);
		if (bind(sock, (SOCKPTR) & server, length) < 0)
			return throwMessage("mserver.listen", "binding to stream socket failed\n");
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) & server, &length) < 0)
			return throwMessage("mserver.listen", "Failed getting socket name\n");
		listen(sock, maxusers);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock < 0) {
			unlink(usockfile);
			return throwMessage("mserver.listen", "creation of Unix socket failed\n");
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (SOCKLEN) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			unlink(usockfile);
			return throwMessage("mserver.listen", "binding to Unix socket file failed\n");
		}
		listen(usock, maxusers);
	}
#endif

#ifdef DEBUG_SERVER
	THRprintf(GDKerr, "SERVERlisten:Network started at %d\n", port);
#endif
	threadcommand = cmd;
	*Sock = sock;

	if (MT_create_thread(pidp, (void (*)(void *)) SERVERlistenThread, Sock) < 0) {
		return throwMessage("mserver.listen", "starting thread failed");
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	gethostname(host, (int) 512);
	(void) msg;
#ifdef DEBUG_SERVER
	snprintf(msg, (int) 512, "#Ready to accept connections on %s:%d\n", host, port);
	stream_printf(GDKout, "%s", msg);
#endif
	return MAL_SUCCEED;
}

#ifdef HAVE_OPENSSL
static char *
ssl_error(const char *name, int err, int ret)
{
	char *errstr, *s;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {	/* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0)
			errstr = ERR_error_string(e, buf);
		else {		/* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	s = GDKmalloc(strlen(errstr) + strlen(name) + 4);
	sprintf(s, "%s: %s\n", name, errstr);	/* we allocated enough, so it fits */
	return s;
}

static MT_Lock *mutex_buf;

static void
locking_function(int mode, int n, const char *file, int line)
{
	(void) file;
	(void) line;
	if (mode & CRYPTO_LOCK)
		MT_set_lock(mutex_buf[n], "locking_function");
	else
		MT_unset_lock(mutex_buf[n], "locking_function");
}

static unsigned long
id_function(void)
{
	return (unsigned long) MT_getpid();
}
#endif /* HAVE_OPENSSL */

bat *
SERVERprelude(void)
{
#ifdef HAVE_OPENSSL
	int i, nlocks;

	nlocks = CRYPTO_num_locks();
	mutex_buf = GDKmalloc(nlocks * sizeof(*mutex_buf));
	if (mutex_buf == NULL) {
		GDKsyserror("SERVERprelude: failed to allocate %d mutexes\n", nlocks);
		return NULL;
	}
	for (i = 0; i < nlocks; i++)
		mutex_buf[i] = MT_create_lock();
	CRYPTO_set_locking_callback(locking_function);
	CRYPTO_set_id_callback(id_function);
#endif
	return NULL;
}

void
SERVERepilogue(void)
{
#ifdef HAVE_OPENSSL
	if (mutex_buf) {
		int i, nlocks;

		nlocks = CRYPTO_num_locks();
		CRYPTO_set_id_callback(NULL);
		CRYPTO_set_locking_callback(NULL);
		for (i = 0; i < nlocks; i++)
			MT_destroy_lock(mutex_buf[i]);
		GDKfree(mutex_buf);
		mutex_buf = NULL;
	}
#endif /* HAVE_OPENSSL */
}

str
SERVERlistenSSL(int *Port, int *Maxusers, str keyfile, str certfile, str cmd)
{
#ifdef HAVE_OPENSSL
	struct sockaddr_in server;
	int sock = -1;
	SOCKLEN length = 0;
	int on = 1;
	int msgsock;
	int i = 0;

	int port;
	int maxusers;
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;
	char *msg;

	if (!port)
		port = SERVERSSLPORT;
	if (!maxusers)
		maxusers = SERVERMAXUSERS;

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL) {
		msg = "creation of SSL context failed\n";
		goto fail;
	}
	if (SSL_CTX_set_cipher_list(ctx, "ALL:!LOW") == 0) {
		msg = "SSL_CTX_set_cipher_list failed\n";
		goto fail;
	}
	if (keyfile && *keyfile && certfile && *certfile) {
		if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) < 1) {
			msg = "SSL_CTX_use_PrivateKey_file failed\n";
			goto fail;
		}
		if (SSL_CTX_use_certificate_chain_file(ctx, certfile) < 1) {
			msg = "SSL_CTX_use_certificate_chain_file failed\n";
			goto fail;
		}
	}
	if (keyfile)
		GDKfree(keyfile);
	if (certfile)
		GDKfree(certfile);

	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("SERVERlistenSSL:creation of stream socket failed\n");
		goto fail;
	}
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;

	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR) & server, length) < 0) {
		GDKsyserror("SERVERlistenSSL:binding to stream socket (%d) failed\n", port);
		goto fail;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR) & server, &length) < 0) {
		msg = "getting socket name\n";
		goto fail;
	}
	listen(sock, maxusers);

#ifdef DEBUG_SERVER
	THRprintf(GDKerr, "SERVERlistenSSL:Network started at %d\n", port);
#endif
	do {
		int retval;
		struct timeval tv;
		fd_set fds;

		FD_ZERO(&fds);
		FD_SET(sock, &fds);
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		retval = select(sock + 1, &fds, &fds, &fds, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			GDKsyserror("SERVERlistenSSL:select failed\n");
			goto fail;
		}
		if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "accept failed\n";
				goto fail;
			}
			continue;
		}
		if ((ssl = SSL_new(ctx)) == 0) {
			msg = "SSL_new failed\n";
			goto fail;
		}

		if (!SSL_set_fd(ssl, msgsock)) {
			msg = "SSL_set_fd failed\n";
			goto fail;
		}

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_accept(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				errstr = ssl_error("SERVERlistenSSL", err, ret);
				GDKsyserror(errstr);
				GDKfree(errstr);
				SSL_free(ssl);
				close(msgsock);
				goto end_loop;
			}
			break;
		}

		if (cmd == NULL) {
			int i = 0;
			char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
			char *mp;
			int blocked = 0;
			stream *fdin = ssl_rastream(ssl, "Server read");
			stream *fdout = NULL;
			Client c;

			assert(name);
			memset(name, 0, BLOCK);
			if (fdin == 0 || stream_errnr(fdin)) {
				GDKsyserror("SERVERlistenSSL:fdin problems\n");
				if (fdin)
					stream_destroy(fdin);
				continue;
			}
			/* get user name */
			stream_read(fdin, user, 1, 1);
			for (i = 0; i < BLOCK && *user != '\n' && !stream_errnr(fdin); i++) {
				user++;
				stream_read(fdin, user, 1, 1);
			}
			if (stream_errnr(fdin)) {
				GDKsyserror("SERVERlistenSSL: fdin problems\n");
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
			*user = 0;
#ifdef DEBUG_SERVER
			THRprintf(GDKerr, "mserver:Client accepted %s\n", name);
			fflush(stdout);
#endif
			s = strrchr(name, ':');
			blocked = s && strncmp(s, ":blocked", 8) == 0;
			if (blocked) {
				/* printf("mserver:use blocked mode\n");fflush(stdout); */
				*s = 0;
				fdin = block_stream(stream_rstream(fdin));
				fdout = block_stream(ssl_wstream(SSL_dup(ssl), "Server write"));
			} else {
				fdout = ssl_wastream(SSL_dup(ssl), "Server write");
			}

			if (fdout == 0) {
				GDKsyserror("SERVERlistenSSL:fdout problems\n");
				continue;
			}
			*user = 0;
#ifdef DEBUG_SERVER
			THRprintf(GDKerr, "SERVERlisten:client accepted %d\n", msgsock);
#endif
			bs = bstream_create(fdin, blocked ? 128 * BLOCK : 0);

			if (blocked)
				bs->eof = 1;
			scheduleClient(name, bs, fdout);
		}
end_loop:;
	} while (1);
	SSL_CTX_free(ctx);
	close(sock);
	if (cmd)
		GDKfree(cmd);
	return GDK_SUCCEED;
	  fail:;
	if (sock >= 0)
		close(sock);
	if (ctx)
		SSL_CTX_free(ctx);
	if (cmd)
		GDKfree(cmd);
	return throwMessage("SERVERlistenSSL", msg);
#else
	(void) Port;
	(void) Maxusers;
	(void) keyfile;
	(void) certfile;
	(void) cmd;
	return throwMessage("SERVERlistenSSL", "No SSL support\n");
#endif /* HAVE_OPENSSL */
}

int
stream_read_until(str *res, stream *S, str stop)
{
	stream *s = *(stream **) S;
	int slen = strlen(stop);
	int len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (stream_read(s, start, 1, 1) > 0) {
		if (start - buf >= slen - 1 && strncmp(start - slen + 1, stop, slen) == 0) {
/*
				start = start-slen+1;
*/
			start++;
			break;
		}
		start++;
	}

	if (stream_errnr(s))
		return GDK_FAIL;

	len = start - buf;
	if (len > 0) {
		*res = NEW_ARRAY(char, len + 1);

		buf[len] = '\0';
		memcpy(*res, buf, len + 1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}

@- Wrappers
The Monet Version 5 wrappers are collected here
The latest port known to gain access is stored
in the database, so that others can more easily
be notified.
@c
void SERVERannounce(str lang, int port){
	FILE *f;
	char buf[PATHLENGTH];
	snprintf(buf,PATHLENGTH,".%s.port",lang);
	f= fopen(buf,"w");
	if( f) {
		fprintf(f,"%d",port);
		(void)fclose(f);	
	}
}
str
SERVERlisten_default(int *ret)
{
	int port = SERVERPORT;
	str p;
	int maxusers = SERVERMAXUSERS;

	(void) ret;
	p = GDKgetenv("mapi_port");
	if( p )
		port = (int) strtol(p,NULL,10);
	if( port == 0)
		return throwMessage("mserver.listen","Illegal port");
	SERVERannounce("mal",port);
	return SERVERlisten(&port, 0, &maxusers, 0);
}

str
SERVERlisten2(int *ret, int *port, int *maxusers)
{
	(void) ret;
	SERVERannounce("mal",*port);
	return SERVERlisten(port, 0, maxusers, 0);
}

str
SERVERlisten3(int *ret, int *port, int *maxusers, str *cmd)
{
	(void) ret;
	SERVERannounce("mal",*port);
	return SERVERlisten(port, 0, maxusers, cmd);
}

str
SERVERlisten_port(int *ret, int *pid)
{
	int port = *pid;
	int maxusers = SERVERMAXUSERS;

	(void) ret;
	SERVERannounce("mal",port);
	return SERVERlisten(&port, 0, &maxusers, 0);
}
@-
The internet connection listener may be terminated from the server console,
or temporarily suspended to enable system maintenance.
It is advisable to trace the interactions of clients on the server
side. At least as far as it concerns requests received.
The kernel supports this 'spying' behavior with a file descriptor
field in the client record.
@c

str
SERVERstop(int *ret)
{
	int i;
	for( i=0; i< lastlistener; i++)
		MT_kill_thread(listener[i]);
	lastlistener = 0;
	(void) ret;		/* fool compiler */
	return MAL_SUCCEED;
}


str
SERVERsuspend(int *res)
{
	(void) res;
	serveractive= FALSE;
	return MAL_SUCCEED;
}

str
SERVERresume(int *res)
{
	serveractive= TRUE;
	(void) res;
	return MAL_SUCCEED;
}

str
SERVERclient(int *res, stream **In, stream **Out) 
{
	int i = 0;
	char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
	char *challenge;
	int blocked = 0;
	bstream *bs;
	stream *fdin = *In, *fdout = *Out;

	(void) res;
	assert(name);
	memset(name, 0, BLOCK);

	/* write challenge string, the challenge is currently empty (disabled) */
	challenge = "::mserver_mal:4\n";

	/* temporarily misuse name */
	snprintf(name, BLOCK, "%2d%s", (unsigned int) strlen(challenge), challenge);
	stream_write(fdout, name, strlen(name), 1);
	/* get user name */
	*user = 0;
	stream_read(fdin, user, 1, 1);
	for (i = 0; !stream_errnr(fdin) && i < BLOCK && *user != '\n'; i++) {
		user++;
		stream_read(fdin, user, 1, 1);
	}
	if (stream_errnr(fdin)) {
		return throwException(MALEXCEPTION, "SERVERclient",
			"fdin write problems\n");
	}
	*user = 0;
	/* in embedded mode we allow just one client */
#ifdef DEBUG_SERVER
	printf("mserver:Client accepted %s\n", name);
	fflush(stdout);
#endif
	s = strrchr(name, ':');
	blocked = s && strncmp(s, ":blocked", 8) == 0;
	if (blocked) {
		/* printf("mserver:use blocked mode\n");fflush(stdout); */
		*s = 0;
		fdin = block_stream(stream_rstream(fdin));
		fdout = block_stream(stream_wstream(fdout));
	}
#ifdef DEBUG_SERVER
	THRprintf(GDKerr, "SERVERlisten:client accepted %d\n", msgsock);
	THRprintf(GDKerr, "SERVERlisten:client string %s\n", name);
#endif
	bs = bstream_create(fdin, blocked ? 128 * BLOCK : 0);

	if (blocked)
		bs->eof = 1;
	scheduleClient(name, bs, fdout);
	return MAL_SUCCEED;
}

void
SERVERexit(){
	int ret;
	SERVERstop(&ret);
	/* remove any port identity file */
	system("rm -rf .*_port");
}
@-
The remainder of the file contains the wrapper around
the SERVER library used by application programmers.

Sessions have a lifetime different from dynamic scopes.
This means the  user should use a session identifier
to select the correct handle.
For the time being we use the index in the global
session table. The client pointer is retained to
perform access control. 

A few extra routines should be defined to
dump and inspect the sessions table.
@c
#define MAXSESSIONS 32
struct{
	int key;
	Client c;
	Mapi mid;
} SERVERsessions[MAXSESSIONS];

static int sessionkey=0;

#define MAPI_TEST

str
SERVERconnect(int *key, str *host, int *port, str *username, str *password, str *lang){
	Mapi mid;
	int i;

	mal_set_lock(mal_contextLock,"SERVERconnect");
	for(i=0; i< MAXSESSIONS; i++)
	if( SERVERsessions[i].c ==0 ) break;

	if( i==MAXSESSIONS){
		mal_unset_lock(mal_contextLock,"SERVERconnect");
		return throwMessage("mserver.connect","Too many sessions");
	}
	SERVERsessions[i].c= getClient();
	SERVERsessions[i].key= ++sessionkey;
	mal_unset_lock(mal_contextLock,"SERVERconnect");

	mid= mapi_connect(*host, *port, *username, *password, *lang);
	if( mapi_error(mid) ){
		SERVERsessions[i].c = NULL;
		return throwMessage("mserver.connect","Could not connect");
	}

#ifdef MAPI_TEST
	stream_printf(GDKout,"Succeeded to establish session\n");
#endif
	SERVERsessions[i].mid= mid;
	*key = SERVERsessions[i].key;
	return MAL_SUCCEED;
}

@-
@= accessTest
 for(i=0; i< MAXSESSIONS; i++)
 if( SERVERsessions[i].c && 
     SERVERsessions[i].key== @1 &&
     SERVERsessions[i].c == getClient()) break;
 if( i== MAXSESSIONS)
	return throwMessage("mserver.@2","Access violation");
  dbh= SERVERsessions[i].mid;
@c
str
SERVERerror(int *ret, int *key){
	Mapi dbh;
	int i;
	@:accessTest(*key,error)@
	*ret= mapi_error(dbh);
	return MAL_SUCCEED;
}

str 
SERVERexplain(str *ret, int *key){
	Mapi dbh;
	int i;

	@:accessTest(*key,explain)@
	*ret= GDKstrdup(mapi_error_str(dbh));
	return MAL_SUCCEED;
}
@-
The remainder should contain the wrapping of 
relevant SERVER functions. Furthermore, we 
should analyse the return value and update 
the stack trace.

Two routines should be 
mserver.rpc("malfunction", arguments) and
mserver.apc("malfunction", arguments.
@-
The generic scheme for handling a remote MAL
procedure call with a single row answer.
@c
str
SERVERmapi_rpc_single_row(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int key,i,j,cnt;
	Mapi dbh;
	MapiHdl hdl;
	char *fld, *qry;
	ptr val;

	key= * (int*) getArgReference(stk,pci,pci->retc);
	qry= * (str*) getArgReference(stk,pci,pci->retc+1);
	@:accessTest(key,rpc)@
#ifdef MAPI_TEST
	stream_printf(GDKout,"about to sent: %s\n",qry);
#endif
	hdl= mapi_query(dbh, qry);
	if( mapi_error(dbh) )
		return throwMessage("mapi.rpc",mapi_error_str(dbh));
	i= 0;
	if( (cnt= mapi_get_field_count(hdl)) != pci->retc)
		return throwMessage("mapi.rpc","Incompatible return value");
	while( mapi_fetch_row(hdl)){
		for(j=0; j<pci->retc; j++){
			fld= mapi_fetch_field(hdl,j);
#ifdef MAPI_TEST
			stream_printf(GDKout,"Got: %s\n",fld);
#endif
			val= (ptr) getArgReference(stk,pci,i);
			switch(getVarType(mb,getArg(pci,j)) ){
			case TYPE_void:
				*(oid*) val= void_nil;
				break;
			case TYPE_oid:
				if(fld==0 || strcmp(fld,"nil")==0)
					*(oid*) val= void_nil;
				else *(oid*) val = (oid) atol(fld);
				break;
			case TYPE_bit:
				if(fld== 0 || strcmp(fld,"nil")==0)
					stk->stk[getArg(pci,j)].val.cval[0]= bit_nil;
				else
				if(strcmp(fld,"true")==0)
					stk->stk[getArg(pci,j)].val.cval[0]= TRUE;
				if(strcmp(fld,"false")==0)
					stk->stk[getArg(pci,j)].val.cval[0]= FALSE;
				stk->stk[getArg(pci,j)].val.cval[1]= 0;
				stk->stk[getArg(pci,j)].val.cval[2]= 0;
				stk->stk[getArg(pci,j)].val.cval[3]= 0;
				break;
			case TYPE_chr:
				if(fld==0 || strcmp(fld,"nil")==0)
					stk->stk[getArg(pci,j)].val.cval[0]= chr_nil;
				else
					stk->stk[getArg(pci,j)].val.cval[0]= *fld;
				stk->stk[getArg(pci,j)].val.cval[1]= 0;
				stk->stk[getArg(pci,j)].val.cval[2]= 0;
				stk->stk[getArg(pci,j)].val.cval[3]= 0;
				break;
			case TYPE_sht:
				if(fld==0 || strcmp(fld,"nil")==0)
					*(sht*) val= (sht)  sht_nil;
				else *(sht*) val= (sht)  atol(fld);
				break;
			case TYPE_int:
				if(fld==0 || strcmp(fld,"nil")==0)
					*(int*) val= (int)  int_nil;
				else *(int*) val= (int)  atol(fld);
				break;
			case TYPE_lng:
				if(fld==0 || strcmp(fld,"nil")==0)
					*(lng*) val= (lng)  lng_nil;
				else *(lng*) val= (lng)  atol(fld);
				break;
			case TYPE_flt:
				if(fld==0 || strcmp(fld,"nil")==0)
					*(flt*) val= (flt)  flt_nil;
				else *(flt*) val= (flt)  atof(fld);
				break;
			case TYPE_dbl:
				if(fld==0 || strcmp(fld,"nil")==0)
					*(dbl*) val= (dbl)  dbl_nil;
				else *(dbl*) val= (dbl)  atof(fld);
				break;
			case TYPE_str:
				if(fld==0 || strcmp(fld,"nil")==0){
					stk->stk[getArg(pci,j)].val.sval= GDKstrdup(str_nil);
					stk->stk[getArg(pci,j)].len= strlen(str_nil);
				} else {
					stk->stk[getArg(pci,j)].val.sval= GDKstrdup(fld);
					stk->stk[getArg(pci,j)].len= strlen(fld);
				}
				break;
				return throwMessage("mapi.rpc","Missing type implementation ");
			/* all the other basic types come here */
			}
		}
		i++;
	}
	if( i>1)
		return throwMessage("mapi.rpc","Too many answers");
	return MAL_SUCCEED;
}
@-
Transport of the BATs is only slightly more complicated.
The generic implementation based on a pattern is the next
step. 
@= mapi_rpc_bat
str
SERVERmapi_rpc_oid_@1(int *ret, int *key, str *qry){
	int i;
	Mapi dbh;
	MapiHdl hdl;
	char *fld1, *fld2;
	oid o; 
	BAT *b;

	@:accessTest(*key,rpc)@
	b= BATnew(TYPE_oid,TYPE_@1,256);
	*ret = b->batCacheid;
	BBPkeepref(*ret);

#ifdef MAPI_TEST
	stream_printf(GDKout,"about to sent: %s\n",*qry);
#endif
	hdl= mapi_query(dbh, *qry);
	if( mapi_error(dbh) )
		return throwMessage("mapi.rpc",mapi_error_str(dbh));
	i= 0;
	while( mapi_fetch_row(hdl)){
		fld1= mapi_fetch_field(hdl,0);
		fld2= mapi_fetch_field(hdl,1);
#ifdef MAPI_TEST
		stream_printf(GDKout,"Got: %s %s \n",fld1,fld2);
#endif
		o= (oid) atol(fld1);
		i= (@1)atol(fld2);
		BUNins(b,&o,&i);
	}
	return MAL_SUCCEED;
}
@c
@:mapi_rpc_bat(int)@
@}
