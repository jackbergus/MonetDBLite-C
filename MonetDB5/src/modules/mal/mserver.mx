@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mserver
@a N.J. Nes P. Boncz, S. Mullender, M. Kersten
@v 1.1
@+ MonetDB's Internet Interface
This module contains a simple interface for setting up
internet connections and to initialize a client session.

Clients may initialize a private listener to implement
specific services. For example, in an OLTP environment
it may make sense to have a listener for each transaction
type, which simply parses a sequence of transaction parameters.

The information about open listeners is maintained in global tables.
They behave as views on the actual state.
No protection is currently possible against malicious users changing them.

Authorization of access to the server is handled as part
of the client record initialization phase.

@mal
module mserver;

command listen():int
address SERVERlisten_default
comment "Start a Mapi server with the default settings.";
command listen(port:int):int
address SERVERlisten_port
comment "Start a Mapi server on the given port";
#command listen(open:bit):int
#address SERVERlisten_open
#comment "Start a Mapi server on the default port global bound or not";
command listen(port:int, maxusers:int):int
address SERVERlisten2
comment "Start a Mapi server.";

command listen(port:int, maxusers:int, cmd:str):int
address SERVERlisten3
comment "Start the Mapi listener on <port> for <maxusers>. 
	For a new client connection MAL procedure <cmd>(Stream s_in, Stream s_out)
	is called.If no <cmd> is specified a new client thread is forked.";

command listen_ssl(port:int, maxusers:int,
	keyfile:str,certfile:str, cmd:str):int
address SERVERlistenSSL
comment "Start the Mapi listener on <port> for <maxusers> using SSL. 
	<keyfile> and <certfile> give the path names for files with the 
	server key and certificates in PEM format. For a new client connection 
	MAL procedure <cmd>(Stream s_in, Stream s_out) is called.
	If no <cmd> is specified a new client thread is forked.";

command stop():void
address SERVERstop
comment "Terminate connection listeners"; 

command suspend():void
address SERVERsuspend
comment "Suspend accepting connections";

command resume():void
address SERVERresume
comment "Resume connection listeners";

command malclient(in:streams, out:streams):void
address SERVERclient
comment "Start a Mapi client.";

@-
The complete Mapi library is available to setup
communication with another Mserver.
This library internally uses pointer handles, which we replace with
an index in a locally maintained table. It provides a handle
to easily detect havoc clients.
@mal
command reconnect(dbalias:str, host:str, port:int, usr:str, passwd:str,lang:str):int
address SERVERreconnectAlias
comment "Re-establish connection with a remote mserver";

command connect(host:str, port:int, usr:str, passwd:str,lang:str):int
address SERVERconnect
comment "Establish connection with a remote mserver";

command connect_ssl(host:str, port:int, usr:str, passwd:str,lang:str):int
address SERVERconnectssl
comment "Establish connection with a remote mserver using the
secure socket layer";

command setAlias(dbalias:str)
address SERVERsetAlias
comment "Give the channel a logical name";

command lookup(dbalias:str):int
address SERVERlookup
comment "Retrieve the connection identifier";

command disconnect(mid:int):void
address SERVERdisconnect
comment "Terminate the session";

command destroy(mid:int):void
address SERVERdestroy
comment "Destroy the handle";

command reconnect(mid:int):void
address SERVERreconnect
comment "Re-establish a connection";

command ping(mid:int):int
address SERVERping
comment "Test availability of server";

command query(mid:int, qry:str):int
address SERVERquery
comment "Sent the query for execution";

command query_handle(mid:int, qry:str):int
address SERVERquery_handle
comment "Sent the query for execution";

pattern query_array(mid:int, qry:str, arg:str...):int
address SERVERquery_array
comment "Sent the query for execution replacing '?' by arguments";

command prepare(mid:int, qry:str):int
address SERVERprepare
comment "Prepare a query for execution";

command finish(hdl:int):int
address SERVERfinish
comment "Remove all remaining answers";

command get_field_count(hdl:int):int
address SERVERget_field_count
comment "Return number of fields";

command get_row_count(hdl:int):int
address SERVERget_row_count
comment "Return number of rows";

command fetch_row(hdl:int):int
address SERVERrows_affected
comment "Return number of affected rows";

command fetch_row(hdl:int):int
address SERVERfetch_row
comment "Retrieve the next row for analysis";

command fetch_all_rows(hdl:int):int
address SERVERfetch_all_rows
comment "Retrieve all rows into the cache";

command fetch_field(hdl:int,fnr:int):str
address SERVERfetch_field_str
comment "Retrieve a single field";

command fetch_field(hdl:int,fnr:int):int
address SERVERfetch_field_int
comment "Retrieve a single int field";

command fetch_field(hdl:int,fnr:int):lng
address SERVERfetch_field_lng
comment "Retrieve a single lng field";

command fetch_field(hdl:int,fnr:int):sht
address SERVERfetch_field_sht
comment "Retrieve a single sht field";

command fetch_field(hdl:int,fnr:int):void
address SERVERfetch_field_void
comment "Retrieve a single void field";

command fetch_field(hdl:int,fnr:int):oid
address SERVERfetch_field_oid
comment "Retrieve a single void field";

command fetch_field(hdl:int,fnr:int):chr
address SERVERfetch_field_chr
comment "Retrieve a single chr field";

command fetch_field_array(hdl:int):bat[:int,:str]
address SERVERfetch_field_bat
comment "Retrieve all fields for a row";

command fetch_line(hdl:int):str
address SERVERfetch_line
comment "Retrieve a complete line";

command fetch_reset(hdl:int):int
address SERVERfetch_reset
comment "Reset the cache read line.";

command next_result(hdl:int):int
address SERVERnext_result
comment "Go to next result set";

command error(mid:int):int
address SERVERerror
comment "Check for an error in the communication");

command getError(mid:int):str
address SERVERgetError
comment "Get error message";

command explain(mid:int):str
address SERVERexplain
comment "Turn the error seen into a string";
@-
The remote procedure calls require the target type
to be known to enable proper parsing of the result
@mal
pattern put(mid:int, nme:str, val:any_1):void
address SERVERput
comment "Send a value to a remote site";

pattern put(nme:str, val:any_1):str
address SERVERputLocal
comment "Prepare sending a value to a remote site";

pattern rpc(key:int,qry:str...):any
address SERVERmapi_rpc_single_row
comment "Sent a simple query for execution and fetch result";

pattern rpc(key:int,qry:str):bat[:any_1,:any_2]
address SERVERmapi_rpc_bat;

command rpc(key:int,qry:str):void
address SERVERquery
comment "Sent a simple query for execution";

pattern bind(key:int,remoteName:str):bat[:any_1,:any_2]
address SERVERbindBAT
comment "Bind a remote variable to a local one";

#command receive(key:int,nme:str):bat[:any_1,:any_2]
#address SERVERreceive
#comment "Fetch a bat from a remote site";

#command send(key:int,nme:str, r:bat[:any_1,:any_2]):void
#address SERVERsend
#comment "Sent a bat to a remote site";

mserver.listen();
@{
command prelude()
address SERVERprelude;
command epilogue()
address SERVERepilogue;

@h
#ifndef SERVER_H
#define SERVER_H
/* #define DEBUG_SERVER */

#include "mal_client.h"
#include "mal_session.h"
#include "mal_exception.h"
#include "mal_interpreter.h"
#include "mal_authorize.h"
#include "Mapi.h"

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define SERVERPORT		50000
#define SERVERSSLPORT		40000
#define SERVERMAXUSERS 		5

mal_export str SERVERlistenThread(int *Sock);
mal_export str SERVERlisten(int *Port, str *Usockfile, int *Maxusers, str *Cmd);
mal_export bat * SERVERprelude(void);
mal_export void SERVERepilogue(void);
mal_export str SERVERlistenSSL(int *Port, int *Maxusers, str keyfile, str certfile, str cmd);
mal_export str SERVERlisten_default(int *ret);
mal_export str SERVERlisten2(int *ret, int *port, int *maxusers);
mal_export str SERVERlisten3(int *ret, int *port, int *maxusers, str *cmd);
mal_export str SERVERlisten_port(int *ret, int *pid);
mal_export str SERVERstop(int *ret);
mal_export str SERVERsuspend(int *ret);
mal_export str SERVERresume(int *ret);
mal_export void SERVERexit();

mal_export str SERVERconnect(int *ret, str *host, int *port, str *username, str *password, str *lang);
mal_export str SERVERreconnectAlias(int *ret, str *dbalias, str *host, int *port, str *username, str *password, str *lang);
mal_export str SERVERconnectssl(int *ret, str *host, int *port, str *username, str *password, str *lang);
mal_export str SERVERdisconnect(int *ret, int *mid);
mal_export str SERVERsetAlias(int *ret, int *mid, str *dbalias);
mal_export str SERVERlookup(int *ret, str *dbalias);
mal_export str SERVERdestroy(int *ret, int *mid);
mal_export str SERVERreconnect(int *ret, int *mid);
mal_export str SERVERping(int *ret, int *mid);
mal_export str SERVERquery(int *ret, int *mid, str *qry);
mal_export str SERVERquery_handle(int *ret, int *mid, str *qry);
mal_export str SERVERquery_array(MalBlkPtr mb, MalStkPtr stk, InstrPtr pc);
mal_export str SERVERprepare(int *ret, int *key, str *qry);
mal_export str SERVERexecute(int *ret, int *idx);
mal_export str SERVERfinish(int *ret, int *idx);
mal_export str SERVERrows_affected(int *ret, int *idx);
mal_export str SERVERget_row_count(int *ret, int *idx);
mal_export str SERVERget_field_count(int *ret, int *idx);
mal_export str SERVERfetch_row(int *ret, int *idx);
mal_export str SERVERfetch_all_rows(int *ret, int *idx);
mal_export str SERVERfetch_field_str(str *ret, int *idx, int *fnr);
mal_export str SERVERfetch_field_int(int *ret, int *idx, int *fnr);
mal_export str SERVERfetch_field_lng(lng *ret, int *idx, int *fnr);
mal_export str SERVERfetch_field_sht(sht *ret, int *idx, int *fnr);
mal_export str SERVERfetch_field_void(oid *ret, int *idx, int *fnr);
mal_export str SERVERfetch_field_oid(oid *ret, int *idx, int *fnr);
mal_export str SERVERfetch_field_chr(chr *ret, int *idx, int *fnr);
mal_export str SERVERfetch_line(str *ret, int *key);
mal_export str SERVERnext_result(int *ret, int *key);
mal_export str SERVERfetch_reset(int *ret, int *key);
mal_export str SERVERfetch_field_bat(int *bid, int *idx);
mal_export str SERVERerror(int *ret, int *idx);
mal_export str SERVERgetError(str *ret, int *idx);
mal_export str SERVERexplain(str *ret, int *idx);
mal_export str SERVERmapi_rpc_single_row(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str SERVERmapi_rpc_single_bat(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str SERVERput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str SERVERputLocal(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str SERVERbindBAT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif /* SERVER_H */
@c
#include "mserver.h"

#include  <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef NATIVE_WIN32
#define s_close(s)	closesocket(s)
#else
#define s_close(s)	close(s)
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif

static char seedChars[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
	'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
	'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
	'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'};


static void generateChallenge(str buf, int min, int max) {
	size_t size;
	size_t chr;
	int i;

	/* don't seed the randomiser, or you get the same challenge during
	 * the same second */
	/* srand(time(NULL)); */
	size = rand();
	size = (size % (max - min)) + min;
	for (i = 0; i < size; i++) {
		chr = rand();
		chr %= 62;
		buf[i] = seedChars[chr];
	}
	buf[i] = '\0';
}

static void 
doChallenge(str cmd, int msgsock) {
	if (cmd == NULL) {
		int i = 0;
		char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
		char *challenge;
		char *algos;
		int blocked = 0;
		stream *fdin = socket_rastream(msgsock, "Server read");
		stream *fdout = socket_wastream(msgsock, "Server write");
		bstream *bs;

		assert(name);
		memset(name, 0, BLOCK);
		if (fdin == 0 || stream_errnr(fdin)) {
			GDKsyserror("SERVERlisten:fdin problems\n");
			return;
		}
		/* generate the challenge string */
		challenge = alloca(sizeof(char) * (12 + 1));
		generateChallenge(challenge, 8, 12);
		if (AUTHgetHashAlgorithms(&algos) != MAL_SUCCEED) assert (0);
		/* temporarily misuse name
		   note that we claim to speak proto 6 here */
		snprintf(name, BLOCK, "%2d:%s:mserver:6:%s\n",
				(unsigned int) (strlen(challenge) + 13 + strlen(algos)),
				challenge, algos);
		stream_write(fdout, name, strlen(name), 1);
		/* get user name */
		*user = 0;
		stream_read(fdin, user, 1, 1);
		for (i = 0; !stream_errnr(fdin) && i < BLOCK && *user != '\n'; i++) {
			user++;
			stream_read(fdin, user, 1, 1);
		}
		if (stream_errnr(fdin)) {
			GDKsyserror("SERVERlisten: fdin problems\n");
			stream_close(fdin);
			stream_destroy(fdin);
			return;
		}
		*user = 0;

		/* in embedded mode we allow just one client */
		if (GDKembedded && MCcountClients() > 1) {
			stream_close(fdin);
			stream_destroy(fdin);
			return;
		}
#ifdef DEBUG_SERVER
		printf("mserver:Client accepted %s\n", name);
		fflush(stdout);
#endif
		s = strchr(name, ':'); /* user */
		if (s) s = strchr(s + 1, ':'); /* password */
		if (s) s = strchr(s + 1, ':'); /* language */
		blocked = s && strncmp(s, ":blocked", 8) == 0;
		if (blocked) {
			/* printf("mserver:use blocked mode\n");fflush(stdout); */
			fdin = block_stream(stream_rstream(fdin));
			fdout = block_stream(socket_wstream(msgsock, "Server write"));
		} else {
			fdout = socket_wastream(msgsock, "Server write");
		}

		if (fdout == 0) {
			GDKsyserror("SERVERlisten:fdout problems\n");
			return;
		}
#ifdef DEBUG_SERVER
		THRprintf(GDKerr, "SERVERlisten:client accepted %d\n", msgsock);
		THRprintf(GDKerr, "SERVERlisten:client string %s\n", name);
#endif
		bs = bstream_create(fdin, blocked ? 128 * BLOCK : 0);

		if (blocked)
			bs->eof = 1;
		MSscheduleClient(name, challenge, bs, fdout);
	} else {
		/* in M4 it is possible to execute a command directly */
	}
}

static char *threadcommand;
static int usock = -1;
static MT_Id listener[8]; 
static int lastlistener=0;
static int serveractive=TRUE;

str
SERVERlistenThread(int *Sock)
{
	char *msg = 0;
	char *cmd = threadcommand;

	if( lastlistener < 8 )
		listener[lastlistener++] = MT_getpid();
	(void)usock;
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		int sock = *Sock;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select(msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "select failed\n";
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR || serveractive==FALSE) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
#ifdef DEBUG_SERVER
		printf("server:accepted\n");
		fflush(stdout);
#endif
		doChallenge(cmd, msgsock);
	} while (1);
error:
	return throwMessage("mserver.listen", msg);
}


str
SERVERlisten(int *Port, str *Usockfile, int *Maxusers, str *Cmd)
{
	struct sockaddr_in server;
	int sock = -1;
	int *Sock = GDKmalloc(sizeof(int));

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
#endif
	SOCKLEN length = 0;
	int on = 1;
	int i = 0;
	MT_Id pid, *pidp = &pid;
	int port;
	int maxusers;
	char msg[512], *cmd, *usockfile, host[512];

	port = *Port;
	if (Usockfile == NULL || *Usockfile == 0 || strcmp(*Usockfile, str_nil) == 0)
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(*Usockfile);
#else
		usockfile = NULL;
		GDKwarning("SERVERlisten: Unix domain sockets are not supported\n");
#endif
	}
	maxusers = *Maxusers;
	cmd = Cmd ? GDKstrdup(*Cmd) : NULL;

	port = (port ? port : SERVERPORT);
	maxusers = (maxusers ? maxusers : SERVERMAXUSERS);

	if (port <= 0 && usockfile == NULL)
		return throwMessage("mserver.listen", "no port or socket file specified\n");

	if (port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
			return throwMessage("mserver.listen", "creation of stream socket failed\n");
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = INADDR_ANY;
		server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (SOCKLEN) sizeof(server);
		if (bind(sock, (SOCKPTR) & server, length) < 0)
			return throwMessage("mserver.listen", "binding to stream socket failed\n");
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) & server, &length) < 0)
			return throwMessage("mserver.listen", "Failed getting socket name\n");
		listen(sock, maxusers);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock < 0) {
			unlink(usockfile);
			return throwMessage("mserver.listen", "creation of Unix socket failed\n");
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (SOCKLEN) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			unlink(usockfile);
			return throwMessage("mserver.listen", "binding to Unix socket file failed\n");
		}
		listen(usock, maxusers);
	}
#endif

#ifdef DEBUG_SERVER
	THRprintf(GDKerr, "SERVERlisten:Network started at %d\n", port);
#endif
	threadcommand = cmd;
	*Sock = sock;

	if (MT_create_thread(pidp, (void (*)(void *)) SERVERlistenThread, Sock) < 0) {
		return throwMessage("mserver.listen", "starting thread failed");
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	gethostname(host, (int) 512);
	(void) msg;
#ifdef DEBUG_SERVER
	snprintf(msg, (int) 512, "#Ready to accept connections on %s:%d\n", host, port);
	stream_printf(GDKout, "%s", msg);
#endif
	return MAL_SUCCEED;
}

#ifdef HAVE_OPENSSL
static char *
ssl_error(const char *name, int err, int ret)
{
	char *errstr, *s;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {	/* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0)
			errstr = ERR_error_string(e, buf);
		else {		/* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	s = GDKmalloc(strlen(errstr) + strlen(name) + 4);
	sprintf(s, "%s: %s\n", name, errstr);	/* we allocated enough, so it fits */
	return s;
}

static MT_Lock *mutex_buf;

static void
locking_function(int mode, int n, const char *file, int line)
{
	(void) file;
	(void) line;
	if (mode & CRYPTO_LOCK)
		MT_set_lock(mutex_buf[n], "locking_function");
	else
		MT_unset_lock(mutex_buf[n], "locking_function");
}

static unsigned long
id_function(void)
{
	return (unsigned long) MT_getpid();
}
#endif /* HAVE_OPENSSL */

bat *
SERVERprelude(void)
{
#ifdef HAVE_OPENSSL
	int i, nlocks;

	nlocks = CRYPTO_num_locks();
	mutex_buf = GDKmalloc(nlocks * sizeof(*mutex_buf));
	if (mutex_buf == NULL) {
		GDKsyserror("SERVERprelude: failed to allocate %d mutexes\n", nlocks);
		return NULL;
	}
	for (i = 0; i < nlocks; i++)
		mutex_buf[i] = MT_create_lock();
	CRYPTO_set_locking_callback(locking_function);
	CRYPTO_set_id_callback(id_function);
#endif
	return NULL;
}

void
SERVERepilogue(void)
{
#ifdef HAVE_OPENSSL
	if (mutex_buf) {
		int i, nlocks;

		nlocks = CRYPTO_num_locks();
		CRYPTO_set_id_callback(NULL);
		CRYPTO_set_locking_callback(NULL);
		for (i = 0; i < nlocks; i++)
			MT_destroy_lock(mutex_buf[i]);
		GDKfree(mutex_buf);
		mutex_buf = NULL;
	}
#endif /* HAVE_OPENSSL */
}

str
SERVERlistenSSL(int *Port, int *Maxusers, str keyfile, str certfile, str cmd)
{
#ifdef HAVE_OPENSSL
	struct sockaddr_in server;
	int sock = -1;
	SOCKLEN length = 0;
	int on = 1;
	int msgsock;
	int i = 0;

	int port = *Port;
	int maxusers = *Maxusers;
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;
	char *msg;

	if (!port)
		port = SERVERSSLPORT;
	if (!maxusers)
		maxusers = SERVERMAXUSERS;

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL) {
		msg = "creation of SSL context failed\n";
		goto fail;
	}
	if (SSL_CTX_set_cipher_list(ctx, "ALL:!LOW") == 0) {
		msg = "SSL_CTX_set_cipher_list failed\n";
		goto fail;
	}
	if (keyfile && *keyfile && certfile && *certfile) {
		if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) < 1) {
			msg = "SSL_CTX_use_PrivateKey_file failed\n";
			goto fail;
		}
		if (SSL_CTX_use_certificate_chain_file(ctx, certfile) < 1) {
			msg = "SSL_CTX_use_certificate_chain_file failed\n";
			goto fail;
		}
	}
	if (keyfile)
		GDKfree(keyfile);
	if (certfile)
		GDKfree(certfile);

	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("SERVERlistenSSL:creation of stream socket failed\n");
		goto fail;
	}
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;

	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR) & server, length) < 0) {
		GDKsyserror("SERVERlistenSSL:binding to stream socket (%d) failed\n", port);
		goto fail;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR) & server, &length) < 0) {
		msg = "getting socket name\n";
		goto fail;
	}
	listen(sock, maxusers);

#ifdef DEBUG_SERVER
	THRprintf(GDKerr, "SERVERlistenSSL:Network started at %d\n", port);
#endif
	do {
		int retval;
		struct timeval tv;
		fd_set fds;

		FD_ZERO(&fds);
		FD_SET(sock, &fds);
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		retval = select(sock + 1, &fds, &fds, &fds, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			GDKsyserror("SERVERlistenSSL:select failed\n");
			goto fail;
		}
		if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "accept failed\n";
				goto fail;
			}
			continue;
		}
		if ((ssl = SSL_new(ctx)) == 0) {
			msg = "SSL_new failed\n";
			goto fail;
		}

		if (!SSL_set_fd(ssl, msgsock)) {
			msg = "SSL_set_fd failed\n";
			goto fail;
		}

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_accept(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				errstr = ssl_error("SERVERlistenSSL", err, ret);
				GDKsyserror(errstr);
				GDKfree(errstr);
				SSL_free(ssl);
				close(msgsock);
				goto end_loop;
			}
			break;
		}

		doChallenge(cmd, msgsock);
end_loop:;
	} while (1);
	SSL_CTX_free(ctx);
	close(sock);
	if (cmd)
		GDKfree(cmd);
	return MAL_SUCCEED;
	  fail:;
	if (sock >= 0)
		close(sock);
	if (ctx)
		SSL_CTX_free(ctx);
	if (cmd)
		GDKfree(cmd);
	return throwMessage("SERVERlistenSSL", msg);
#else
	(void) Port;
	(void) Maxusers;
	(void) keyfile;
	(void) certfile;
	(void) cmd;
	return throwMessage("SERVERlistenSSL", "No SSL support\n");
#endif /* HAVE_OPENSSL */
}

int
stream_read_until(str *res, stream *S, str stop)
{
	stream *s = *(stream **) S;
	int slen = strlen(stop);
	int len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (stream_read(s, start, 1, 1) > 0) {
		if (start - buf >= slen - 1 && strncmp(start - slen + 1, stop, slen) == 0) {
/*
				start = start-slen+1;
*/
			start++;
			break;
		}
		start++;
	}

	if (stream_errnr(s))
		return GDK_FAIL;

	len = start - buf;
	if (len > 0) {
		*res = NEW_ARRAY(char, len + 1);

		buf[len] = '\0';
		memcpy(*res, buf, len + 1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}

@- Wrappers
The Monet Version 5 wrappers are collected here
The latest port known to gain access is stored
in the database, so that others can more easily
be notified.
@c
void SERVERannounce(str lang, int port){
	FILE *f;
	char buf[PATHLENGTH];
	snprintf(buf,PATHLENGTH,".%s.port",lang);
	f= fopen(buf,"w");
	if( f) {
		fprintf(f,"%d",port);
		(void)fclose(f);	
	}
}
str
SERVERlisten_default(int *ret)
{
	int port = SERVERPORT;
	str p;
	int maxusers = SERVERMAXUSERS;

	(void) ret;
	p = GDKgetenv("mapi_port");
	if( p )
		port = (int) strtol(p,NULL,10);
	if( port == 0)
		return throwMessage("mserver.listen","Illegal port");
	SERVERannounce("mal",port);
	return SERVERlisten(&port, 0, &maxusers, 0);
}

str
SERVERlisten2(int *ret, int *port, int *maxusers)
{
	(void) ret;
	SERVERannounce("mal",*port);
	return SERVERlisten(port, 0, maxusers, 0);
}

str
SERVERlisten3(int *ret, int *port, int *maxusers, str *cmd)
{
	(void) ret;
	SERVERannounce("mal",*port);
	return SERVERlisten(port, 0, maxusers, cmd);
}

str
SERVERlisten_port(int *ret, int *pid)
{
	int port = *pid;
	int maxusers = SERVERMAXUSERS;

	(void) ret;
	SERVERannounce("mal",port);
	return SERVERlisten(&port, 0, &maxusers, 0);
}
@-
The internet connection listener may be terminated from the server console,
or temporarily suspended to enable system maintenance.
It is advisable to trace the interactions of clients on the server
side. At least as far as it concerns requests received.
The kernel supports this 'spying' behavior with a file descriptor
field in the client record.
@c

str
SERVERstop(int *ret)
{
	int i;
	for( i=0; i< lastlistener; i++)
		MT_kill_thread(listener[i]);
	lastlistener = 0;
	(void) ret;		/* fool compiler */
	return MAL_SUCCEED;
}


str
SERVERsuspend(int *res)
{
	(void) res;
	serveractive= FALSE;
	return MAL_SUCCEED;
}

str
SERVERresume(int *res)
{
	serveractive= TRUE;
	(void) res;
	return MAL_SUCCEED;
}

str
SERVERclient(int *res, stream **In, stream **Out) 
{
	int i = 0;
	char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
	char *challenge;
	int blocked = 0;
	bstream *bs;
	stream *fdin = *In, *fdout = *Out;

	(void) res;
	assert(name);
	memset(name, 0, BLOCK);

	/* write challenge string, the challenge is currently empty (disabled) */
	challenge = "::mserver_mal:4\n";

	/* temporarily misuse name */
	snprintf(name, BLOCK, "%2d%s", (unsigned int) strlen(challenge), challenge);
	stream_write(fdout, name, strlen(name), 1);
	/* get user name */
	*user = 0;
	stream_read(fdin, user, 1, 1);
	for (i = 0; !stream_errnr(fdin) && i < BLOCK && *user != '\n'; i++) {
		user++;
		stream_read(fdin, user, 1, 1);
	}
	if (stream_errnr(fdin)) {
		return throwException(MALEXCEPTION, "SERVERclient",
			"fdin write problems\n");
	}
	*user = 0;
	/* in embedded mode we allow just one client */
#ifdef DEBUG_SERVER
	printf("mserver:Client accepted %s\n", name);
	fflush(stdout);
#endif
	s = strrchr(name, ':');
	blocked = s && strncmp(s, ":blocked", 8) == 0;
	if (blocked) {
		/* printf("mserver:use blocked mode\n");fflush(stdout); */
		*s = 0;
		fdin = block_stream(stream_rstream(fdin));
		fdout = block_stream(stream_wstream(fdout));
	}
#ifdef DEBUG_SERVER
	THRprintf(GDKerr, "SERVERlisten:client accepted %d\n", msgsock);
	THRprintf(GDKerr, "SERVERlisten:client string %s\n", name);
#endif
	bs = bstream_create(fdin, blocked ? 128 * BLOCK : 0);

	if (blocked)
		bs->eof = 1;
	MSscheduleClient(name, challenge, bs, fdout);
	return MAL_SUCCEED;
}

void
SERVERexit(){
	int ret;
	SERVERstop(&ret);
	/* remove any port identity file */
	system("rm -rf .*_port");
}
@+ Remote Processing
The remainder of the file contains the wrappers around
the Mapi library used by application programmers.
Details on the functions can be found there.

Sessions have a lifetime different from dynamic scopes.
This means the  user should use a session identifier
to select the correct handle.
For the time being we use the index in the global
session table. The client pointer is retained to
perform access control. 

We use a single result set handle. All data should be
consumed before continueing.

A few extra routines should be defined to
dump and inspect the sessions table.
	
@c
#define MAXSESSIONS 32
struct{
	int key;
	str dbalias;	/* logical name of the session */
	Client c;
	Mapi mid;		/* communication channel */
	MapiHdl hdl;	/* result set handle */
} SERVERsessions[MAXSESSIONS];

static int sessionkey=0;

/* #define MAPI_TEST*/

str
SERVERconnectAll(int *key, str *host, int *port, str *username, str *password, str *lang, int ssl){
	Mapi mid;
	int i;

	mal_set_lock(mal_contextLock,"SERVERconnect");
	for(i=1; i< MAXSESSIONS; i++)
	if( SERVERsessions[i].c ==0 ) break;

	if( i==MAXSESSIONS){
		mal_unset_lock(mal_contextLock,"SERVERconnect");
		return throwMessage("mserver.connect","Too many sessions");
	}
	SERVERsessions[i].c= MCgetClient();
	SERVERsessions[i].key= ++sessionkey;
	mal_unset_lock(mal_contextLock,"SERVERconnect");

	if( ssl)
	mid= mapi_connect_ssl(*host, *port, *username, *password, *lang);
	else
	mid= mapi_connect(*host, *port, *username, *password, *lang);
	if( mapi_error(mid) ){
		SERVERsessions[i].c = NULL;
		throwMalf("mserver.connect","Could not connect: %s", mapi_error_str(mid));
	}

#ifdef MAPI_TEST
	stream_printf(GDKout,"Succeeded to establish session\n");
#endif
	SERVERsessions[i].mid= mid;
	*key = SERVERsessions[i].key;
	return MAL_SUCCEED;
}
str
SERVERconnect(int *key, str *host, int *port, str *username, str *password, str *lang){
	return SERVERconnectAll(key,host,port,username,password,lang, FALSE);
}
str
SERVERconnectssl(int *key, str *host, int *port, str *username, str *password, str *lang){
	return SERVERconnectAll(key,host,port,username,password,lang, TRUE);
}

str
SERVERreconnectAlias(int *key,str *dbalias, str *host, int *port, str *username, str *password, str *lang){
	int i;
	str msg=MAL_SUCCEED;

	for(i=0; i<MAXSESSIONS; i++)
	 if( SERVERsessions[i].key && 
		 SERVERsessions[i].dbalias &&
		 strcmp(SERVERsessions[i].dbalias, *dbalias)==0){
			*key = SERVERsessions[i].key;
			return msg;
	}

	msg= SERVERconnectAll(key,host,port,username,password,lang, FALSE);
	if( msg == MAL_SUCCEED)
		msg = SERVERsetAlias(&i, key, dbalias);
	return msg;
}
@-
@= accessTest
 for(i=0; i< MAXSESSIONS; i++)
 if( SERVERsessions[i].c && 
     SERVERsessions[i].key== @1 ) break;
 if( i== MAXSESSIONS)
	return throwMessage("mserver.@2","Access violation");
  mid= SERVERsessions[i].mid;
  (void) mid; /* silence compilers */
@c
str
SERVERsetAlias(int *ret, int *key, str *dbalias){
	int i;
	Mapi mid;
	@:accessTest(*key,setAlias)@
    SERVERsessions[i].dbalias= GDKstrdup(*dbalias);
	*ret = 0;
	return MAL_SUCCEED;
}
str
SERVERlookup(int *ret, str *dbalias)
{
	int i;
	for(i=0; i< MAXSESSIONS; i++)
	if( SERVERsessions[i].dbalias &&
		strcmp(SERVERsessions[i].dbalias, *dbalias)==0){
		*ret= SERVERsessions[i].key; 
		return MAL_SUCCEED;
	}
	return throwMessage("mserver.lookup","Could not find database connection");
}
str
SERVERdisconnect(int *ret, int *key){
	int i;
	Mapi mid;
	@:accessTest(*key,disconnect)@
	mapi_disconnect(mid);
	if( SERVERsessions[i].dbalias)
		GDKfree(SERVERsessions[i].dbalias);
	SERVERsessions[i].dbalias= 0;
	*ret = 0;
	return MAL_SUCCEED;
}
str
SERVERdestroy(int *ret, int *key){
	int i;
	Mapi mid;
	@:accessTest(*key,destroy)@
	mapi_destroy(mid);
	SERVERsessions[i].c= 0;
	if( SERVERsessions[i].dbalias)
		GDKfree(SERVERsessions[i].dbalias);
	SERVERsessions[i].dbalias= 0;
	*ret = 0;
	return MAL_SUCCEED;
}

str
SERVERreconnect(int *ret, int *key){
	int i;
	Mapi mid;
	@:accessTest(*key,destroy)@
	mapi_reconnect(mid);
	*ret = 0;
	return MAL_SUCCEED;
}
str
SERVERping(int *ret, int *key){
	int i;
	Mapi mid;
	@:accessTest(*key,destroy)@
	*ret= mapi_ping(mid);
	return MAL_SUCCEED;
}
str 
SERVERquery(int *ret, int *key, str *qry){
	Mapi mid;
	int i;
	@:accessTest(*key,query)@
	if( SERVERsessions[i].hdl)
		mapi_close_handle(SERVERsessions[i].hdl);
	SERVERsessions[i].hdl= mapi_query(mid, *qry);
	*ret = *key;
	return MAL_SUCCEED;
}
str 
SERVERquery_handle(int *ret, int *key, str *qry){
	Mapi mid;
	int i;
	@:accessTest(*key,query_handle)@
	mapi_query_handle(SERVERsessions[i].hdl, *qry);
	*ret = *key;
	return MAL_SUCCEED;
}
str
SERVERquery_array(MalBlkPtr mb, MalStkPtr stk, InstrPtr pc){
	(void) mb; (void) stk; (void) pc;
	return MAL_SUCCEED;
}
str 
SERVERprepare(int *ret, int *key, str *qry){
	Mapi mid;
	int i;
	@:accessTest(*key,prepare)@
	if( SERVERsessions[i].hdl)
		mapi_close_handle(SERVERsessions[i].hdl);
	SERVERsessions[i].hdl= mapi_prepare(mid, *qry);
	*ret = *key;
	return MAL_SUCCEED;
}
str 
SERVERexecute(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,execute)@
	mapi_execute(SERVERsessions[i].hdl);
	*ret = *key;
	return MAL_SUCCEED;
}
str 
SERVERfinish(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,finish)@
	mapi_finish(SERVERsessions[i].hdl);
	*ret = *key;
	return MAL_SUCCEED;
}
str 
SERVERget_row_count(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,get_row_count)@
	*ret= mapi_get_row_count(SERVERsessions[i].hdl);
	return MAL_SUCCEED;
}
str 
SERVERget_field_count(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,get_field_count)@
	*ret= mapi_get_field_count(SERVERsessions[i].hdl);
	return MAL_SUCCEED;
}
str 
SERVERrows_affected(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,rows_affected)@
	*ret= mapi_rows_affected(SERVERsessions[i].hdl);
	return MAL_SUCCEED;
}
str 
SERVERfetch_row(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,fetch_row)@
	*ret= mapi_fetch_row(SERVERsessions[i].hdl);
	return MAL_SUCCEED;
}
str 
SERVERfetch_all_rows(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,fetch_all_rows)@
	*ret= mapi_fetch_all_rows(SERVERsessions[i].hdl);
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_str(str *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	*ret= GDKstrdup(fld? fld: str_nil);
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_int(int *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	*ret= fld? (int) atol(fld): int_nil;
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_lng(lng *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	*ret= fld? atol(fld): lng_nil;
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_sht(sht *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	*ret= fld? (sht) atol(fld): sht_nil;
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_void(oid *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	@:accessTest(*key,fetch_field)@
	(void) fnr;
	*ret = oid_nil;
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_oid(oid *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	if(fld==0 || strcmp(fld,"nil")==0)
		*(oid*) ret= void_nil;
	else *(oid*) ret = (oid) atol(fld);
	return MAL_SUCCEED;
}
str 
SERVERfetch_field_chr(chr *ret, int *key, int *fnr){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_field)@
	fld= mapi_fetch_field(SERVERsessions[i].hdl,*fnr);
	if(fld==0 || strcmp(fld,"nil")==0)
		*(chr*) ret= chr_nil;
	else *(chr*) ret = *fld;
	return MAL_SUCCEED;
}
str 
SERVERfetch_line(str *ret, int *key){
	Mapi mid;
	int i;
	str fld;
	@:accessTest(*key,fetch_line)@
	fld= mapi_fetch_line(SERVERsessions[i].hdl);
	*ret= GDKstrdup(fld? fld:str_nil);
	return MAL_SUCCEED;
}
str 
SERVERnext_result(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,next_result)@
	mapi_next_result(SERVERsessions[i].hdl);
	*ret= *key;
	return MAL_SUCCEED;
}
str 
SERVERfetch_reset(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,fetch_reset)@
	mapi_fetch_reset(SERVERsessions[i].hdl);
	*ret= *key;
	return MAL_SUCCEED;
}
str
SERVERfetch_field_bat(int *bid, int *key){
	int i,j,cnt;
	Mapi mid;
	char *fld;
	int o=0; 
	BAT *b;

	@:accessTest(*key,rpc)@
	b= BATnew(TYPE_oid,TYPE_str,256);
	cnt= mapi_get_field_count(SERVERsessions[i].hdl);
	for(j=0; j< cnt; j++){
		fld= mapi_fetch_field(SERVERsessions[i].hdl,j);
		BUNins(b,&o,fld);
		o++;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	*bid = b->batCacheid;
	BBPkeepref(*bid);
	return MAL_SUCCEED;
}
str
SERVERerror(int *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,error)@
	*ret= mapi_error(mid);
	return MAL_SUCCEED;
}
str
SERVERgetError(str *ret, int *key){
	Mapi mid;
	int i;
	@:accessTest(*key,getError)@
	*ret= GDKstrdup(mapi_error_str(mid));
	return MAL_SUCCEED;
}

str 
SERVERexplain(str *ret, int *key){
	Mapi mid;
	int i;

	@:accessTest(*key,explain)@
	*ret= GDKstrdup(mapi_error_str(mid));
	return MAL_SUCCEED;
}
@-
The remainder should contain the wrapping of 
relevant SERVER functions. Furthermore, we 
should analyse the return value and update 
the stack trace.

Two routines should be 
mserver.rpc(key,"query") 
@-
The generic scheme for handling a remote MAL
procedure call with a single row answer.
@c
void SERVERfieldAnalysis(str fld, int tpe, ValPtr v){
	v->vtype= tpe;
	switch(tpe){
	case TYPE_void:
		v->val.oval = void_nil;
		break;
	case TYPE_oid:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.oval= void_nil;
		else v->val.oval = (oid) atol(fld);
		break;
	case TYPE_bit:
		if(fld== 0 || strcmp(fld,"nil")==0)
			v->val.cval[0]= bit_nil;
		else
		if(strcmp(fld,"true")==0)
			v->val.cval[0]= TRUE;
		if(strcmp(fld,"false")==0)
			v->val.cval[0]= FALSE;
		v->val.cval[1]= 0;
		v->val.cval[2]= 0;
		v->val.cval[3]= 0;
		break;
	case TYPE_chr:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.cval[0]= chr_nil;
		else
			v->val.cval[0]= *fld;
		v->val.cval[1]= 0;
		v->val.cval[2]= 0;
		v->val.cval[3]= 0;
		break;
	case TYPE_sht:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.shval = sht_nil;
		else v->val.shval= (sht)  atol(fld);
		break;
	case TYPE_int:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.ival = int_nil;
		else v->val.ival= (int)  atol(fld);
		break;
	case TYPE_lng:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.lval= lng_nil;
		else v->val.lval= (lng)  atol(fld);
		break;
	case TYPE_flt:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.fval= flt_nil;
		else v->val.fval= (flt)  atof(fld);
		break;
	case TYPE_dbl:
		if(fld==0 || strcmp(fld,"nil")==0)
			v->val.dval= dbl_nil;
		else v->val.dval= (dbl)  atof(fld);
		break;
	case TYPE_str:
		if(fld==0 || strcmp(fld,"nil")==0){
			v->val.sval= GDKstrdup(str_nil);
			v->len= strlen(str_nil);
		} else {
			v->val.sval= GDKstrdup(fld);
			v->len= strlen(fld);
		}
		break;
	}
}
str
SERVERmapi_rpc_single_row(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int key,i,j;
	Mapi mid;
	MapiHdl hdl;
	char *s,*fld, *qry=0;

	key= * (int*) getArgReference(stk,pci,pci->retc);
	@:accessTest(key,rpc)@
#ifdef MAPI_TEST
	stream_printf(GDKout,"about to sent: %s\n",qry);
#endif
	/* glue all strings together */
	for(i= pci->retc+1; i<pci->argc; i++){
		fld= * (str*) getArgReference(stk,pci,i);
		if( qry == 0)
			qry= GDKstrdup(fld);
		else {	
			s= (char*) GDKmalloc(strlen(qry)+strlen(fld)+1);
			strcpy(s,qry);
			strcat(s,fld);
			GDKfree(qry);
			qry= s;
		}
	}
	hdl= mapi_query(mid, qry);
	if( mapi_error(mid) )
		return throwMessage("mapi.rpc",mapi_error_str(mid));
	GDKfree(qry);

	i= 0;
	while( mapi_fetch_row(hdl)){
		for(j=0; j<pci->retc; j++){
			fld= mapi_fetch_field(hdl,j);
#ifdef MAPI_TEST
			stream_printf(GDKout,"Got: %s\n",fld);
#endif
			switch(getVarType(mb,getArg(pci,j)) ){
			case TYPE_void:
			case TYPE_oid:
			case TYPE_bit:
			case TYPE_chr:
			case TYPE_sht:
			case TYPE_int:
			case TYPE_lng:
			case TYPE_flt:
			case TYPE_dbl:
			case TYPE_str:
				SERVERfieldAnalysis(fld, 
					getVarType(mb,getArg(pci,j)),
					&stk->stk[getArg(pci,j)]);
				break;
			default:
				return throwMessage("mapi.rpc",
						"Missing type implementation ");
			/* all the other basic types come here */
			}
		}
		i++;
	}
	if( i>1)
		return throwMessage("mapi.rpc","Too many answers");
	return MAL_SUCCEED;
}
@-
Transport of the BATs is only slightly more complicated.
The generic implementation based on a pattern is the next
step. 
@c
str
SERVERmapi_rpc_bat(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *ret;
	int *key;
	str *qry;
	int i;
	Mapi mid;
	MapiHdl hdl;
	char *fld1, *fld2;
	BAT *b;
	ValRecord hval,tval;
	int ht,tt;

	ret= (int*) getArgReference(stk,pci,0);
	key= (int*) getArgReference(stk,pci,pci->retc);
	qry= (str*) getArgReference(stk,pci,pci->retc+1);
	@:accessTest(*key,rpc)@
	ht= getHeadType(getVarType(mb,getArg(pci,0)));
	tt= getTailType(getVarType(mb,getArg(pci,0)));

	hdl= mapi_query(mid, *qry);
	if( mapi_error(mid) )
		return throwMessage("mapi.rpc",mapi_error_str(mid));
	
	b= BATnew(ht,tt,256);
	i= 0;
	while( mapi_fetch_row(hdl)){
		fld1= mapi_fetch_field(hdl,0);
		fld2= mapi_fetch_field(hdl,1);
		SERVERfieldAnalysis(fld1, ht, &hval);
		SERVERfieldAnalysis(fld2, tt, &tval);
		BUNins(b,VALget(&hval),VALget(&tval));
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	*ret = b->batCacheid;
	BBPkeepref(*ret);

	return MAL_SUCCEED;
}
str
SERVERput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *key;
	str *nme;
	ptr val;
	int i,tpe;
	Mapi mid;
	char *w=0, buf[BUFSIZ];

	key= (int*) getArgReference(stk,pci,pci->retc);
	nme= (str*) getArgReference(stk,pci,pci->retc+1);
	val= (ptr) getArgReference(stk,pci,pci->retc+2);
	@:accessTest(*key,put)@
	switch( (tpe=getArgType(mb,pci, pci->retc+2)) ){
	case TYPE_bat:
	case TYPE_ptr:
		return throwMessage("mserver.glue","Unsupported type");
	default:
		ATOMformat(tpe,val,&w);
		snprintf(buf,BUFSIZ,"%s:=%s;",*nme,w);
		GDKfree(w);
		break;
	}
	if( SERVERsessions[i].hdl)
		mapi_close_handle(SERVERsessions[i].hdl);
	SERVERsessions[i].hdl= mapi_query(mid, buf);
	if( mapi_error(mid) )
		return throwMessage("mapi.put",mapi_error_str(mid));
	return MAL_SUCCEED;
}
str
SERVERputLocal(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *ret, *nme;
	ptr val;
	int tpe;
	char *w=0, buf[BUFSIZ];

	ret= (str*) getArgReference(stk,pci,0);
	nme= (str*) getArgReference(stk,pci,pci->retc);
	val= (ptr) getArgReference(stk,pci,pci->retc+1);
	switch( (tpe=getArgType(mb,pci, pci->retc+1)) ){
	case TYPE_bat:
	case TYPE_ptr:
		return throwMessage("mserver.glue","Unsupported type");
	default:
		ATOMformat(tpe,val,&w);
		snprintf(buf,BUFSIZ,"%s:=%s;",*nme,w);
		GDKfree(w);
		break;
	}
	*ret= GDKstrdup(buf);
	return MAL_SUCCEED;
}
str 
SERVERbindBAT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *key;
	str *nme;
	int i;
	Mapi mid;
	char buf[BUFSIZ];
	key= (int*) getArgReference(stk,pci,pci->retc);
	nme= (str*) getArgReference(stk,pci,pci->retc+1);
	@:accessTest(*key,bind)@
	snprintf(buf,BUFSIZ,"%s:=bbp.bind(\"%s\");",
		getVarName(mb,getDestVar(pci)),*nme);
	if( SERVERsessions[i].hdl)
		mapi_close_handle(SERVERsessions[i].hdl);
	SERVERsessions[i].hdl= mapi_query(mid, buf);
	if( mapi_error(mid) )
		return throwMessage("mapi.bind",mapi_error_str(mid));
	return MAL_SUCCEED;
}
@}
