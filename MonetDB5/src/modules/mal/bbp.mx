@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f bbp
@v 2.0
@a M.L.Kersten, P. Boncz
@+ BAT Buffer Pool
The BBP module implements a box interface over the BAT buffer pool.
It is primarilly meant to ease inspection of the BAT collection managed
by the server.

The two predominant approaches to use bbp is to access the BBP
with either @emph{bind} or @emph{take}. The former merely maps the BAT name
to the object in the bat buffer pool.  
A more controlled scheme is to @emph{ deposit}, @emph{take}, @emph{release}
and @emph{ discard} elements.
Any BAT B created can be brought under this scheme with the name N.
The association N->B is only maintained in the box administration
and not reflected in the BAT descriptor.
In particular, taking a  BAT object out of the box leads to a private 
copy to isolate the user from concurrent updates on the underlying store.
Upon releasing it, the updates are merged with the master copy [todo].

The remainder of this module contains operations that rely
on the MAL runtime setting, but logically belong to the kernel/bat
module.
@mal
module bbp;

command open():void		
address CMDbbpopen
comment "Locate the bbp box and open it.";
command close():void		
address CMDbbpclose
comment "Close the bbp box.";
command destroy():void		
address CMDbbpdestroy
comment "Destroy the box";
pattern take(name:str) :bat[:any_1,:any_2] 
address CMDbbptake
comment "Load a particular bat.";
pattern deposit(name:str,v:bat[:any_1,:any_2]) :void 			
address CMDbbpdeposit
comment "Enter a new bat into the bbp box.";
pattern deposit(name:str,loc:str) :bat[:any_1,:any_2]
address CMDbbpbindDefinition
comment "Relate a logical name to a physical BAT in the buffer pool.";
pattern commit():void 	
address CMDbbpReleaseAll
comment "Commit updates for this client.";
pattern releaseAll():void 	
address CMDbbpReleaseAll
comment "Commit updates for this client.";
pattern release(name:str,val:bat[:any_1,:any_2]) :void 			
address CMDbbprelease
comment "Commit updates and release this BAT.";
pattern release(b:bat[:any_1,:any_2]):void
address CMDbbpreleaseBAT
comment "Remove the BAT from further consideration";
pattern destroy(b:bat[:any_1,:any_2]):void
address CMDbbpdestroyBAT1
comment "Schedule a BAT for removal at session end.";
pattern destroy(b:bat[:any_1,:any_2],immediate:bit)
address CMDbbpdestroyBAT
comment "Schedule a BAT for removal at session end or immediately.";
pattern toString(name:str):str 	
address CMDbbptoStr
comment "Get the string representation of an element in the box.";
pattern discard(name:str):void 
address CMDbbpdiscard
comment "Remove the BAT from the box.";

pattern iterator(nme:str):lng 	
address CMDbbpiterator
comment "Locate the next element in the box.";

pattern prelude():void 
address CMDbbpprelude
comment "Initialize the bbp box.";

pattern bind(name:str):bat[:any_1,:any_2]
address CMDbbpbind
comment "Locate the BAT using its logical name";

pattern bind(head:str,tail:str):bat[:any_1,:any_2]
address CMDbbpbind2
comment "Locate the BAT using the head and tail names in the BAT buffer pool");

pattern bind(idx:int):bat[:any_1,:any_2] 
address CMDbbpbindindex
comment "Locate the BAT using its BBP index in the BAT buffer pool";

pattern getObjects():bat[:int,:str] 
address CMDbbpGetObjects
	comment "View of the box content.";

@{
@- Singleton Set management
Singleton sets are ideally not represented by BATs, but they
nevertheless emerge as the result of an operation.
They can be packed/unpacked easily.
@- BAT declarations
A pattern block may be required to make the proper translation to
the BAT library. In particular when the type information is needed
to steer the process. This means the code can not belong to the
kernel module, because MAL context knowledge is forbidden there.
The signatures are, however, moved into the proper place.
@- Algebraic operators
There are also a few algebraic operators that have to be defined here/
They rely on knowledge of the runtime environment
@mal
@+ BAT buffer pool
The following list of operations permits inspection of the
buffer pool
@}
@mal
command getHeadType() :bat[:int,:str]		
address CMDbbpHeadType
comment "Map a BAT into its head type";
command getTailType() :bat[:int,:str]		
address CMDbbpTailType
comment "Map a BAT into its tail type";
command getNames() :bat[:int,:str] 	
address CMDbbpNames
comment "Map BAT into its bbp name";
command getRNames() :bat[:int,:str] 	
address CMDbbpRNames
comment "Map a BAT into its bbp physical name";

command getName( b:bat[:any_1,:any_2]):str
address CMDbbpName
comment "Map a BAT into its internal name";
command getCount() :bat[:int,:lng] 	
address CMDbbpCount
comment "Create a BAT with the cardinalities of all known BATs";
command getRefCount() :bat[:int,:int] 	
address CMDbbpRefCount
comment "Create a BAT with the (hard) reference counts";
command getLRefCount() :bat[:int,:int] 	
address CMDbbpLRefCount
comment "Create a BAT with the logical reference counts";
command getLocation() :bat[:int,:str] 	
address CMDbbpLocation
comment "Create a BAT with their disk locations";
command getHeat() :bat[:int,:int] 	
address CMDbbpHeat
comment "Create a BAT with the heat values";
command getDirty() :bat[:int,:str] 	
address CMDbbpDirty
comment "Create a BAT with the dirty/ diffs/clean status";
command getStatus() :bat[:int,:str] 	
address CMDbbpStatus
comment "Create a BAT with the disk/load status";
command getKind():bat[:int,:str] 
address CMDbbpKind
comment "Create a BAT with the persistency status";
command getRefCount(b:bat[:any_1,:any_2]) :int
address CMDgetBATrefcnt
comment "Utility for debugging MAL interpreter";
command getLRefCount(b:bat[:any_1,:any_2]) :int
address CMDgetBATlrefcnt
comment "Utility for debugging MAL interpreter";
command getDiskSpace() :lng
address CMDbbpDiskSpace
comment "Estimate the amount of disk space occupied by dbfarm";
command getPageSize():int
address CMDgetPageSize
comment "Obtain the memory page size";

@-
@{
@include prelude.mx
@+ Implementation section
In most cases we pass a BAT identifier, which should be unified
with a BAT descriptor. Upon failure we can simply abort the function.

@c
#include "mal_config.h"
#include "mal_box.h"
#include "mal_client.h"
#include "mal_interpreter.h"
#include "mal_profiler.h"
#include "bat5.h"

#ifdef WIN32
#ifndef LIBBBP
#define bbp_export extern __declspec(dllimport)
#else
#define bbp_export extern __declspec(dllexport)
#endif
#else
#define bbp_export extern
#endif

#ifdef _MSC_VER
#define getcwd _getcwd
#endif

bbp_export str CMDbbpprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpopen(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpclose(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpdestroy(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpdeposit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpbindDefinition(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpbind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpbind2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
bbp_export str CMDbbpbindindex(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbptake(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbprelease(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpreleaseBAT(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpdestroyBAT(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpdestroyBAT1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpReleaseAll(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpdiscard(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbptoStr(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpiterator(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpGetObjects(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bbp_export str CMDbbpDiskSpace(lng *ret);
bbp_export str CMDbbpDiskReads(lng *ret);
bbp_export str CMDbbpDiskWrites(lng *ret);
bbp_export str CMDgetPageSize(int *ret);
bbp_export str CMDbbpNames(int *ret);
bbp_export str CMDbbpName(str *ret, int *bid);
bbp_export str CMDbbpRNames(int *ret);
bbp_export str CMDbbpCount(int *ret);
bbp_export str CMDbbpLocation(int *ret);
bbp_export str CMDbbpHeat(int *ret);
bbp_export str CMDbbpDirty(int *ret);
bbp_export str CMDbbpStatus(int *ret);
bbp_export str CMDbbpKind(int *ret);
bbp_export str CMDbbpRefCount(int *ret);
bbp_export str CMDbbpLRefCount(int *ret);
bbp_export str CMDgetBATrefcnt(int *res, int *bid);
bbp_export str CMDgetBATlrefcnt(int *res, int *bid);

@-
Access to a box calls for resolving the first parameter
to a named box. The bbp box is automatically opened.
@c
#define OpenBox(X) \
	box= findBox("bbp");\
	if(box == 0 )\
		box= openBox("bbp");\
	if( box ==0) \
		throw(MAL, "bbp." X,"box is not open");


str
CMDbbpprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	(void) cntxt;
	if (openBox("bbp"))
		return MAL_SUCCEED;
	throw(MAL, "bbp.prelude", "failed to open box");
}

@- Operator implementation
@c
str
CMDbbpopen(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	if (openBox("bbp") != 0)
		return MAL_SUCCEED;
	throw(MAL, "bbp.open", "failed to open box");
}

str
CMDbbpclose(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	OpenBox("close");
	if (closeBox("bbp", TRUE) == 0)
		return MAL_SUCCEED;
	throw(MAL, "bbp.close", "failed to close 'bbp' box");
}

str
CMDbbpdestroy(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	OpenBox("destroy");
	destroyBox("bbp");
	return MAL_SUCCEED;
}

@-
Beware that once you deposit a BAT into a box, it should
increment the reference count to assure it is not
garbage collected. Moreover, it should be done so only once.
@c
str
CMDbbpdeposit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	ValPtr v;
	Box box;
	int flg;

	(void) cntxt;
	(void) mb;		/* fool compiler */

	OpenBox("deposit");
	name = (str) getArgValue(stk, pci, 1);
	if (isIdentifier(name) < 0 )
		throw(MAL, "bbp.deposit", "identifier expected");
	v = getArgReference(stk,pci,2); 
	flg = findVariable(box->sym, name) >= 0;
	if (depositBox(box, name, v))
		throw(MAL, "bbp.deposit", "failed to deposit into box");
	if (!flg)
		BBPincref(v->val.bval, TRUE);
	return MAL_SUCCEED;
}

str
CMDbbpbindDefinition(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name, loc;
	Box box;

	(void) cntxt;
	(void) mb;		/* fool compiler */
	OpenBox("bind");
	name = (str) getArgValue(stk, pci, 1);
	loc = (str) getArgValue(stk, pci, 2);
	if (isIdentifier(name) < 0)
		throw(MAL, "bbp.bind", "identifier expected");
	if (bindBAT(box, name, loc))
		throw(MAL, "bbp.bind", "failed to bind name ");
	return MAL_SUCCEED;
}

str
CMDbbpbind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;
	ValPtr lhs, rhs;
	int i = -1;
	int ht,tt;
	BAT *b;

	(void) cntxt;
	(void) mb;		/* fool compiler */
	lhs = getArgReference(stk,pci,0); 
	name = (str) getArgValue(stk, pci, 1);
	if (isIdentifier(name) < 0)
		throw(MAL, "bbp.bind", "identifier expected");
	box = findBox("bbp");
	if (box && (i = findVariable(box->sym, name)) >= 0) {
		rhs = &box->val->stk[i];
		VALcopy(lhs, rhs);
		if (lhs->vtype == TYPE_bat) {
			BAT *b;

			b = (BAT *) BBPgetdesc(lhs->val.bval);
			if (b == NULL)
				throw(MAL, "bbp.bind", "can not access descriptor");
			BBPincref(b->batCacheid, TRUE);
		}
		return MAL_SUCCEED;
	}
	i = BBPindex(name);
	if (i == 0)
		throw(MAL, "bbp.bind", "failed to locate object in box");
	/* make sure you load the descriptors and heaps */
	b = (BAT *) BATdescriptor(i);
	if (b == 0)
		/* Simple ignore the binding if you can;t find the bat */
		throw(MAL, "bbp.bind", "failed to find object in box");

	/* check conformity of the actual type and the one requested */
	ht= getHeadType(getArgType(mb,pci,0));
	tt= getTailType(getArgType(mb,pci,0));
	if( b->htype == TYPE_void && ht== TYPE_oid) ht= TYPE_void;
	if( b->ttype == TYPE_void && tt== TYPE_oid) tt= TYPE_void;

	if( ht != b->htype || tt != b->ttype){
		BBPunfix(i);
		throw(MAL, "bbp.bind", "Actual type does not match required type");
	}
	/* make sure we are not dealing with an about to be deleted bat */
	if( BBP_refs(b->batCacheid) == 1 &&
		BBP_lrefs(b->batCacheid) == 0){
		BBPunfix(i);
		throw(MAL, "bbp.bind", "failed to find object in box");
	}

	BBPkeepref(b->batCacheid);
	lhs->vtype = TYPE_bat;
	lhs->val.bval = i;
	return MAL_SUCCEED;
}

str
CMDbbpbind2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *ret= (int*) getArgReference(stk,pci,0);
	str hnme = (str) getArgValue(stk, pci, 1);
	str tnme = (str) getArgValue(stk, pci, 2);
	int i,ht,tt;

	(void) cntxt;
	/* check conformity of the actual type and the one requested */
	ht= getHeadType(getArgType(mb,pci,0));
	tt= getTailType(getArgType(mb,pci,0));
	/* find a specific BAT in the buffer pool */
	BBPlock("CMDbbpbind2");
	for (i = 1; i < BBPsize; i++)
	if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
		BAT *b = (BAT *) BATdescriptor(i);
		if( b == 0 ) 
			continue;
		if( strcmp(b->hident,hnme)==0 &&
			strcmp(b->tident,tnme)==0 ){

			if( b->htype == TYPE_void && ht== TYPE_oid) ht= TYPE_void;
			if( b->ttype == TYPE_void && tt== TYPE_oid) tt= TYPE_void;

			if( ht != b->htype || tt != b->ttype){
				BBPunfix(i);
				throw(MAL, "bbp.bind", "Actual type does not match required type");
			}

			BBPkeepref(i);
			*ret = i;
			BBPunlock("CMDbbpbind2");
			return MAL_SUCCEED;
		}
		BBPreleaseref(i);
	}
	BBPunlock("CMDbbpbind2");
	throw(MAL, "bbp.find","BAT not found");
}
str
CMDbbpbindindex(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int ht,tt;
	int *ret= (int*) getArgReference(stk,pci,0);
	int *bid= (int*) getArgReference(stk,pci,1);

	(void) cntxt;
	/* check conformity of the actual type and the one requested */
	ht= getHeadType(getArgType(mb,pci,0));
	tt= getTailType(getArgType(mb,pci,0));

	if ( *bid  == bat_nil)
		throw(MAL, "bbp.bind", "can not access descriptor");
	b = (BAT *) BATdescriptor(*bid);
	if (b == 0)
		throw(MAL, "bbp.bind", "can not access descriptor");

	if( b->htype == TYPE_void && ht== TYPE_oid) ht= TYPE_void;
	if( b->ttype == TYPE_void && tt== TYPE_oid) tt= TYPE_void;

	if( ht != b->htype || tt != b->ttype){
		BBPunfix(b->batCacheid);
		throw(MAL, "bbp.bind", "Actual type does not match required type");
	}
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

@-
Moving BATs in/out of the box also involves
checking the type already known for possible misfits.
Therefore, we need access to the runtime context.
If the bat is not known in the box, we go to the bbp pool
and make an attempt to load it directly.
@c
str
CMDbbptake(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;
	ValPtr v;

	(void) cntxt;
	(void) mb;		/* fool compiler */
	OpenBox("take");
	name = (str) getArgValue(stk, pci, 1);
	if (isIdentifier(name)< 0)
		throw(MAL, "bbp.take", "identifier expected");
	if (strstr(name, "M5system_auth") == name)
		throw(MAL, "bbp.take", "access denied");
	v = getArgReference(stk,pci,0); 
	if (takeBox(box, name, v, (int) getArgType(mb, pci, 0))) {
		int bid = BBPindex(name);

		if (bid > 0 && (v->vtype == TYPE_any || v->vtype == TYPE_bat)) {
			/* adjust the types as well */
			v->vtype = TYPE_bat;
			v->val.ival = bid;
			BBPincref(bid, TRUE);
		} else
			throw(MAL, "bbp.take", "failed to take object from box");
	}
	/* make a private copy for this client session */
	/* use the cheapest copy method */
	/* printf("bbp.take not yet fully implemented\n"); */
	return MAL_SUCCEED;
}

str
CMDbbprelease(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) cntxt;		/* fool compiler */
	(void) mb;		/* fool compiler */
	OpenBox("release");
	name = (str) getArgValue(stk, pci, 1);
	releaseBox(box, name);
	/* merge the updates of this BAT with the master copy */
	/* printf("bbp.release not yet fully implemented\n"); */
	return MAL_SUCCEED;
}

@-
A BAT can be released to make room for others.
We decrease the reference count with one, but should not
immediately release it, because there may be aliases.
@c
str
CMDbbpreleaseBAT(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *bid;
	Box box;

	(void) cntxt;
	OpenBox("release");
	bid = (int *) getArgValue(stk, pci, 1);
	BBPdecref(*bid, TRUE);
	releaseBAT(mb, stk, *bid);
	*bid = 0;
	return MAL_SUCCEED;
}

@-
A BAT designated as garbage can be removed, provided we
do not keep additional references in the stack frame
Be careful here not to remove persistent BATs.
Note that we clear the dirty bit to ensure that
the BAT is not written back to store before being freed.
@c
str
CMDbbpgarbage(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *bid;
	Box box;
	BAT *b;

	(void) cntxt;
	(void) mb;
	OpenBox("release");
	bid = (int *) getArgValue(stk, pci, 1);
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bbp.garbage", "Cannot access descriptor");
	}

	b->batDirty= FALSE;
	if (BBP_lrefs(*bid) == 0) {
		BBPunfix(b->batCacheid);
		throw(MAL, "bbp.garbage", "Bat already gone");
	}
	if (BBP_lrefs(*bid) == 2 && b->batPersistence == PERSISTENT) {
		/* release BAT from pool altogether */
		BBPunfix(b->batCacheid);
		BBPdecref(*bid, TRUE);
		*bid = 0;
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	if (*bid)
		/* while( BBP_lrefs(*bid) > 1 ) */
		BBPdecref(*bid, TRUE);
	*bid = 0;
	return MAL_SUCCEED;
}

@-
A BAT can be removed forever immediately or at the end of
a session. The references within the current frame
should also be zapped.
@c
str
CMDbbpdestroyBAT(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit ret = 0;
	int *bid;
	bit *immediate;
	str msg;

	(void) cntxt;
	bid = (int *) getArgValue(stk, pci, 1);
	immediate = (bit *) getArgValue(stk, pci, 2);
	msg = CMDbbpreleaseBAT(cntxt,mb, stk, pci);
	if( *immediate) 
		msg = BKCdestroyImmediate(&ret, bid);
	else 
		msg = BKCdestroy(&ret, bid);
	*(int *) getArgValue(stk, pci, 1)  = 0;
	return msg;
}

str
CMDbbpdestroyBAT1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit ret = 0;
	int *bid;
	(void) cntxt;
	(void) mb;

	bid = (int *) getArgValue(stk, pci, 1);
	*(int *) getArgValue(stk, pci, 1)  = 0;
	return BKCdestroyImmediate(&ret, bid);
}

str
CMDbbpReleaseAll(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	OpenBox("releaseAll");
	releaseAllBox(box);
	/* merge the updates with the master copies */
	/* printf("bbp.releaseAll not yet fully implemented\n"); */
	throw(MAL, "bbp.commit","Not yet available");
}

str
CMDbbpdiscard(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) cntxt;
	(void) mb;		/* fool compiler */
	OpenBox("discard");
	name = (str) getArgValue(stk, pci, 1);
	if (discardBox(box, name))
		throw(MAL, "bbp.discard", "failed to discard object ");
	/*printf("bbp.discard not yet fully implemented\n"); */
	return MAL_SUCCEED;
}

str
CMDbbptoStr(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	int i;
	ValPtr v;
	str nme;

	(void) cntxt;
	(void) mb;		/* fool compiler */
	OpenBox("toString");
	nme = (str) getArgValue(stk, pci, 1);
	i = findVariable(box->sym, nme);
	if (i < 0)
		throw(MAL, "bbp.toString", "failed to take value from box");
	v = &box->val->stk[i];
	garbageElement(cntxt, getArgReference(stk,pci,0));
	if (VALconvert(TYPE_str, v) == ILLEGALVALUE)
		throw(MAL, "bbp.toString", "illegal value conversion");
	VALcopy( getArgReference(stk,pci,0), v);
	return MAL_SUCCEED;
}

str
CMDbbpiterator(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	lng *cursor;
	ValPtr v;

	(void) cntxt;
	(void) mb;		/* fool compiler */
	OpenBox("iterator");
	cursor = (lng *) getArgValue(stk, pci, 0);
	v = getArgReference(stk,pci,1);
	if (nextBoxElement(box, cursor, v))
		throw(MAL, "bbp.iterator", "failed");
	return MAL_SUCCEED;
}



@+ BBP status
The BAT buffer pool datastructures describe the memory resident information
on the whereabouts of the BATs. The three predominant tables are made accessible
for inspection. 

The most interesting system bat for end-users is the BID-> NAME mapping,
because it provides access to the system guaranteed persistent BAT identifier.
It may be the case that the user already introduced a BAT with this name,
it is simply removed first
@= Pseudo2
	if (BBPindex("@1_@2") > 0) 
		BATdelete(BBPdescriptor(BBPindex("@1_@2")));
	BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;
	BBPkeepref(*ret);
@c
str
CMDbbpGetObjects(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	int i;
	ValPtr v;
	Box box;
	int *ret;

	(void) cntxt;
	(void) mb;		/* fool compiler */
	OpenBox("getObjects");
	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		throw(MAL, "bbp.getObjects", "Cannot create BAT");
	for (i = 0; i < box->sym->vtop; i++) {
		v = &box->val->stk[i];
		BUNins(b, &v->val.bval, getVarName(box->sym, i), FALSE);
	}

	ret = (int *) getArgReference(stk, pci, 0);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo2(bbp,objects)@
	return MAL_SUCCEED;
}

str
CMDbbpNames(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		throw(MAL, "catalog.bbpNames", "failed to create BAT");

	BBPlock("CMDbbpNames");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid) {
			if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i)) ) {
				BUNins(b, &i, BBP_logical(i), FALSE);
				if (BBP_logical(-i) && (BBP_refs(-i) || BBP_lrefs(-i))) {
					int j = -i;

					BUNins(b, &j, BBP_logical(j), FALSE);
				}
			}
		}
	BBPunlock("CMDbbpNames");
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo2(bbp,name)@
	return MAL_SUCCEED;
}
str
CMDbbpDiskSpace(lng *ret)
{
	*ret=  getDiskSpace();
	return MAL_SUCCEED;
}
str
CMDgetPageSize(int *ret)
{
	*ret= (int)  MT_pagesize();
	return MAL_SUCCEED;
}

str
CMDbbpName(str *ret, int *bid)
{
	*ret = (str) GDKstrdup(BBP_logical(*bid));
	return MAL_SUCCEED;
}

str
CMDbbpRNames(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		throw(MAL, "bbp.getRNames", "failed to create BAT");

	BBPlock("CMDbbpRNames");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
			if (BBP_logical(-i)) {
				BUNins(b, &i, BBP_logical(-i), FALSE);
			} else
				BUNins(b, &i, BBP_logical(i), FALSE);
		}
	BBPunlock("CMDbbpRNames");
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo2(bbp,revname)@
	return MAL_SUCCEED;
}

str
CMDbbpCount(int *ret)
{
	BAT *b, *bn;
	int i;
	lng l;

	b = BATnew(TYPE_int, TYPE_lng, BBPsize);
	if (b == 0)
		throw(MAL, "catalog.bbpCount", "failed to create BAT");

	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid) {
			if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
				bn = BATdescriptor(i);
				if (bn) {
					l = BATcount(bn);
					BUNins(b, &i, &l, FALSE);
					BBPunfix(bn->batCacheid);
				}
			}
		}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo2(bbp,count)@
	return MAL_SUCCEED;
}

@-
The BAT status is redundantly stored in CMDbat_info.
@c
str
CMDbbpLocation(int *ret)
{
	BAT *b;
	int i;
	char buf[MAXPATHLEN];
	char cwd[MAXPATHLEN];

	if (getcwd(cwd, MAXPATHLEN) == NULL)
		throw(MAL, "catalog.bbpLocation", "cannot get current directory");

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		throw(MAL, "catalog.bbpLocation", "failed to create BAT");

	BBPlock("CMDbbpLocation");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid) {
			if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
				snprintf(buf,MAXPATHLEN,"%s/bat/%s",cwd,BBP_physical(i));
				BUNins(b, &i, buf, FALSE);
			}
		}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	BBPunlock("CMDbbpLocation");
	@:Pseudo2(bbp,location)@
	return MAL_SUCCEED;
}


#define monet_modulesilent (GDKdebug&4096)


str
CMDbbpHeat(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, BBPsize);
	if (b == 0)
		throw(MAL, "catalog.bbpHeat", "failed to create BAT");

	BBPlock("CMDbbpHeat");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid) {
			if (BBP_cache(i) && !monet_modulesilent) {
				int heat = BBP_lastused(i);

				BUNins(b, &i, &heat, FALSE);
			} else if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
				int zero = 0;

				BUNins(b, &i, &zero, FALSE);
			}
		}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	BBPunlock("CMDbbpHeat");
	@:Pseudo2(bbp,heat)@
	return MAL_SUCCEED;
}

@-
The BAT dirty status:dirty => (mem != disk); diffs = not-committed
@c
str
CMDbbpDirty(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		throw(MAL, "catalog.bbpDirty", "failed to create BAT");

	BBPlock("CMDbbpDirty");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid)
			if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
				BAT *bn = BBP_cache(i);

				BUNins(b, &i, bn ? BATdirty(bn) ? "dirty" : DELTAdirty(bn) ? "diffs" : "clean" : (BBP_status(i) & BBPSWAPPED) ? "diffs" : "clean", FALSE);
			}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	BBPunlock("CMDbbpDirty");
	@:Pseudo2(bbp,status)@
	return MAL_SUCCEED;
}

@-
The BAT status is redundantly stored in CMDbat_info.
@c
str
CMDbbpStatus(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		throw(MAL, "catalog.bbpStatus", "failed to create BAT");

	BBPlock("CMDbbpStatus");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid)
			if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
				char *loc = BBP_cache(i) ? "load" : "disk";

				BUNins(b, &i, loc, FALSE);
			}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	BBPunlock("CMDbbpStatus");
	@:Pseudo2(bbp,status)@
	return MAL_SUCCEED;
}

str
CMDbbpKind(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		throw(MAL, "catalog.bbpKind", "failed to create BAT");

	BBPlock("CMDbbpKind");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid)
			if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
				char *mode = NULL;

				if ((BBP_status(i) & BBPDELETED) || !(BBP_status(i) & BBPPERSISTENT))
					mode = "transient";
				else
					mode = "persistent";
				if (mode)
					BUNins(b, &i, mode, FALSE);
			}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	BBPunlock("CMDbbpKind");
	@:Pseudo2(bbp,kind)@
	return MAL_SUCCEED;
}

str
CMDbbpRefCount(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, BBPsize);
	if (b == 0)
		throw(MAL, "catalog.bbpRefCount", "failed to create BAT");

	BBPlock("CMDbbpRefCount");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
			int refs = BBP_refs(i);

			BUNins(b, &i, &refs, FALSE);
		}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	BBPunlock("CMDbbpRefCount");
	@:Pseudo2(bbp,refcnt)@
	return MAL_SUCCEED;
}

str
CMDbbpLRefCount(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, BBPsize);
	if (b == 0)
		throw(MAL, "catalog.bbpLRefCount", "failed to create BAT");

	BBPlock("CMDbbpLRefCount");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
			int refs = BBP_lrefs(i);

			BUNins(b, &i, &refs, FALSE);
		}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	BBPunlock("CMDbbpLRefCount");
	@:Pseudo2(bbp,lrefcnt)@
	return MAL_SUCCEED;
}

str
CMDgetBATrefcnt(int *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bbp.getRefCount", "Cannot access descriptor");
	}
	*res = BBP_refs(b->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CMDgetBATlrefcnt(int *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bbp.getLRefCount", "Cannot access descriptor");
	}
	*res = BBP_lrefs(b->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}


@-
@= headtailProperty
bbp_export str CMDbbp@2( int *ret);
str CMDbbp@2( int *ret){
	BAT	*b,*bn;
	int	i;

	b= BATnew(TYPE_int,TYPE_str,BBPsize);
	if (b == 0) 
		throw(MAL, "catalog.bbp@2", "failed to create BAT");

	for(i=1; i < BBPsize; i++) if (i != b->batCacheid) 
	if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
		bn= BATdescriptor(i);
		if(bn) BUNins(b, &i, BATatoms[BAT@1(bn)].name, FALSE);
		BBPunfix(bn->batCacheid);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo2(bbp,@2)@
	return MAL_SUCCEED;
}

@c
@:headtailProperty(htype,HeadType)@
@:headtailProperty(ttype,TailType)@
