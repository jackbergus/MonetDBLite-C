@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f mallist
@a Martin Kersten
@* list

@mal
atom list:ptr;

command new():list
address MALLISTnew
comment "Create a list of typed values.";

pattern append(l:list,v:any_1):list
address MALLISTappend
comment "Append an element to a list";

pattern glue(l:list):any_1
address MALLISTglue
comment "Drop the list elements";

pattern drop(l:list):void
address MALLISTdrop
comment "Drop the list elements";

pattern newIterator(l:list):any_1
address MALLISTnewIterator
comment "Open a new list iterator";
pattern hasMoreElements(l:list):any_1
address MALLISThasMore
comment "Fetch next element";

@-
A few aggregate functions are defined here
to ease execution.
@m
command count(l:list):lng
address MALLISTcount
comment "Count the total tuples in the list";
command sum(l:list):lng
address MALLISTsum
comment "Count the total tuples in the list";

command prelude()
address MALLISTprelude;
#list.prelude();
@h
#ifndef _MALLIST_H
#define _MALLIST_H

#ifdef WIN32
#ifndef LIBMALLIST
#define mallist extern __declspec(dllimport)
#else
#define mallist extern __declspec(dllexport)
#endif
#else
#define mallist extern
#endif

#endif /* _MALLIST_H */

@c
#include "mal_config.h"
#include "mal.h"
#include "mal_interpreter.h"
#include "mallist.h"

typedef struct MLIST{
	ValRecord val;
	struct MLIST *nxt, *lst;
} MList, *MListElm;

#define newElement() ((MListElm) GDKzalloc(sizeof(MList)))

str 
MALLISTprelude(ptr *res)
{
	(void) res;
	return MAL_SUCCEED;
}
str 
MALLISTnew(ptr *res)
{
	*res= (ptr) newElement();
	return MAL_SUCCEED;
}
str 
MALLISTappend(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	MList *l= (MList*) getArgReference(stk,pci,1);
	MListElm e= newElement();
	(void) mb;

	if( l->nxt)
		l->lst->nxt= e;
	else
		l->nxt= l->lst= e;
	VALcopy(&e->val, &stk->stk[getArg(pci,2)]);
	return MAL_SUCCEED;
}
	
str 
MALLISTdrop(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}
str 
MALLISTglue(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}
str 
MALLISTnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL,"list.newList","NYI");
}
str 
MALLISThasMore(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL,"list.hasMoreElements","NYI");
}
str 
MALLISTcount(lng *ret, ptr *list)
{
	(void) ret;
	(void) list;
	throw(MAL,"list.count","NYI");
}
str 
MALLISTsum(lng *ret, ptr *list)
{
	(void) ret;
	(void) list;
	throw(MAL,"list.sum","NYI");
}
