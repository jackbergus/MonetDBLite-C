@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f transaction
@a M.L. Kersten, P. Boncz
@+ Transaction management
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a module.
This code base is largely absolute and should be re-considered when
serious OLTP is being supported.
Note, however, the SQL front-end obeys transaction semantics.

@mal
module transaction;

command sync() :bit
address TRNglobal_sync
comment "Save all persistent BATs";
command commit() :bit
address TRNglobal_commit
comment "Global commit on all BATs";
command abort() :bit
address TRNglobal_abort
comment "Global abort on all BATs";
command subcommit(b:bat[:any_1,:str]):bit
address TRNsubcommit
comment "commit only a set of BATnames, passed in the tail 
(to which you must have exclusive access!)";

pattern commit(c:any...) 
address TRNtrans_commit
comment "Commit changes in certain BATs.";
pattern abort(c:any...) 
address TRNtrans_abort
comment "Abort changes in certain BATs.";
pattern clean(c:any...) 
address TRNtrans_clean
comment "Declare a BAT clean without flushing to disk.";

command prev(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address TRNtrans_prev
comment "The previous stae of this BAT";
command alpha(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address TRNtrans_alpha
comment	"List insertions since last commit.";
command delta(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address TRNtrans_delta
comment	"List deletions since last commit.";
@{
@+ Implementation Code 
@c
#include "gdk.h"
#include "mal.h"
#include "mal_interpreter.h"
#include "bat5.h"

#ifdef WIN32
#ifndef LIBTRANSACTION
#define transaction_export extern __declspec(dllimport)
#else
#define transaction_export extern __declspec(dllexport)
#endif
#else
#define transaction_export extern
#endif

transaction_export str TRNglobal_sync(int *ret);
transaction_export str TRNglobal_abort(int *ret);
transaction_export str TRNglobal_commit(int *ret);
transaction_export str TRNsub_commit(int *ret, int *bid);
transaction_export str TRNtrans_clean(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
transaction_export str TRNtrans_abort(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
transaction_export str TRNtrans_commit(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
transaction_export str TRNtrans_prev(int *ret, int *bid);
transaction_export str TRNtrans_alpha(int *ret, int *bid);
transaction_export str TRNtrans_delta(int *ret, int *bid);
transaction_export str TRNsubcommit(int *ret, int *bid);

int
global_sync(bit *ret)
{
	*ret = BBPsync(BBPsize, NULL)?FALSE:TRUE;
	return GDK_SUCCEED;
}

int
global_commit(bit *ret)
{
	*ret = TMcommit()?FALSE:TRUE;
	return GDK_SUCCEED;
}

int
global_abort(bit *ret)
{
	*ret = TMabort()?FALSE:TRUE;
	return GDK_SUCCEED;
}

int 
global_subcommit(bit* ret, BAT *bl)
{
	*ret = TMsubcommit(bl)?FALSE:TRUE;
	return GDK_SUCCEED;
}

int
trans_alpha(BAT **retval, BAT *b)
{
	*retval = BATalpha(b);
	return retval ? GDK_SUCCEED : GDK_FAIL;
}

int
trans_delta(BAT **retval, BAT *b)
{
	*retval = BATdelta(b);
	return retval ? GDK_SUCCEED : GDK_FAIL;
}

int
trans_prev(BAT **retval, BAT *b)
{
	*retval = BATprev(b);
	return retval ? GDK_SUCCEED : GDK_FAIL;
}

int
trans_commit(BAT *b, ...)
{
	va_list ap;

	va_start(ap, b);
	do {
		BATcommit(b);
	} while ((b = va_arg(ap, BAT *)) != 0);

	va_end(ap);
	return GDK_SUCCEED;
}

int
trans_abort(BAT *b, ...)
{
	va_list ap;

	va_start(ap, b);
	do {
		BATundo(b);
		if (b->batPersistence == PERSISTENT)
			BBPsave(b);
	} while ((b = va_arg(ap, BAT *)) != 0);

	va_end(ap);
	return GDK_SUCCEED;
}

int
trans_clean(BAT *b, ...)
{
	va_list ap;

	va_start(ap, b);
	do {
		BATfakeCommit(b);
	} while ((b = va_arg(ap, BAT *)) != 0);

	va_end(ap);
	return GDK_SUCCEED;
}
@
@include prelude.mx
@- Wrappers
The remainder contains the Monet 5 wrapper code to make this all work
@c
#include "mal_exception.h"
str
TRNglobal_sync(int *ret)
{
	*ret = BBPsync(BBPsize,NULL)?FALSE:TRUE;
	return MAL_SUCCEED;
}

str
TRNglobal_abort(int *ret)
{
	*ret = TMabort()?FALSE:TRUE;
	return MAL_SUCCEED;
}

str
TRNglobal_commit(int *ret)
{
	*ret = TMcommit()?FALSE:TRUE;
	return MAL_SUCCEED;
}
str
TRNsubcommit(int *ret, int *bid)
{
	BAT *b;
	b= BATdescriptor(*bid);
	if( b == NULL)
		return throwMessage("transaction.subcommit","BAT with commit list missing");
	*ret = TMsubcommit(b)?FALSE:TRUE;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
TRNtrans_clean(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, *bid;
	BAT *b;

	(void) mb;
	for (i = p->retc; i < p->argc; i++) {
		bid = (int *) getArgReference(stk, p, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			return throwMessage("transaction.commit", "Cannot access descriptor");
		}

		if (b)
			BATclear(b);
		else
			return throwMessage("trans_commit", "BAT not accessible");
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
TRNtrans_abort(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, *bid;
	BAT *b;

	(void) mb;
	for (i = p->retc; i < p->argc; i++) {
		bid = (int *) getArgReference(stk, p, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			return throwMessage("transaction.abort", "Cannot access descriptor");
		}
		if (b)
			BATundo(b);
		else
			return throwMessage("transaction.abort", "BAT not accessible");
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
TRNtrans_commit(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, *bid;
	BAT *b;

	(void) mb;
	for (i = p->retc; i < p->argc; i++) {
		bid = (int *) getArgReference(stk, p, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			return throwMessage("transaction.commit", "Cannot access descriptor");
		}
		if (b)
			BATcommit(b);
		else
			return throwMessage("transaction.commit", "BAT not accessible");
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
TRNtrans_prev(int *ret, int *bid)
{
	BAT *b,*bn= NULL;
	b= BATdescriptor(*bid);
	if (b  == NULL) 
		return throwMessage("transaction.prev", "Cannot access descriptor");
	trans_prev(&bn,b);
	BBPkeepref(*ret = bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
TRNtrans_alpha(int *ret, int *bid)
{
	return BKCgetAlpha(ret, bid);
}

str
TRNtrans_delta(int *ret, int *bid)
{
	return BKCgetDelta(ret, bid);
}
@}
