@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f transaction
@a M.L. Kersten, P. Boncz
@+ Transaction management
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a module.
This code base is largely absolute and should be re-considered when
serious OLTP is being supported.
Note, however, the SQL front-end obeys transaction semantics.

@mal
module transaction;

command sync() 
address TRNglobal_sync
comment "Save all persistent BATs";
command commit() 
address TRNglobal_commit
comment "Global commit on all BATs";
command abort() 
address TRNglobal_abort
comment "Global abort on all BATs";

pattern commit(c:any...) 
address TRNtrans_commit
comment "Commit changes in certain BATs.";
pattern abort(c:any...) 
address TRNtrans_abort
comment "Abort changes in certain BATs.";
pattern clean(c:any...) 
address TRNtrans_clean
comment "Declare a BAT clean without flushing to disk.";

command alpha(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address TRNtrans_alpha
comment	"List insertions since last commit.";
command delta(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address TRNtrans_delta
comment	"List deletions since last commit.";
@{
@+ Implementation Code 
@c
#include "gdk.h"
#include "mal.h"
#include "mal_interpreter.h"
#include "bat.h"

mal_export str TRNglobal_sync(int *ret);
mal_export str TRNglobal_abort(int *ret);
mal_export str TRNglobal_commit(int *ret);
mal_export str TRNtrans_clean(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str TRNtrans_abort(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str TRNtrans_commit(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str TRNtrans_alpha(int *ret, int *bid);
mal_export str TRNtrans_delta(int *ret, int *bid);

int
global_sync(void)
{
	BBPsync(TRUE, NULL);
	return GDK_SUCCEED;
}

int
global_commit(void)
{
	TMcommit();
	return GDK_SUCCEED;
}

int
global_abort(void)
{
	TMabort();
	return GDK_SUCCEED;
}

int
trans_alpha(BAT **retval, BAT *b)
{
	*retval = BATalpha(b);
	return retval ? GDK_SUCCEED : GDK_FAIL;
}

int
trans_delta(BAT **retval, BAT *b)
{
	*retval = BATdelta(b);
	return retval ? GDK_SUCCEED : GDK_FAIL;
}

int
trans_commit(BAT *b, ...)
{
	va_list ap;

	va_start(ap, b);
	do {
		BATcommit(b);
	} while ((b = va_arg(ap, BAT *)) != 0);

	va_end(ap);
	return GDK_SUCCEED;
}

int
trans_abort(BAT *b, ...)
{
	va_list ap;

	va_start(ap, b);
	do {
		BATundo(b);
		if (b->batPersistence == PERSISTENT)
			BBPsave(b);
	} while ((b = va_arg(ap, BAT *)) != 0);

	va_end(ap);
	return GDK_SUCCEED;
}

int
trans_clean(BAT *b, ...)
{
	va_list ap;

	va_start(ap, b);
	do {
		BATfakeCommit(b);
	} while ((b = va_arg(ap, BAT *)) != 0);

	va_end(ap);
	return GDK_SUCCEED;
}
@
@include prelude.mx
@- Wrappers
The remainder contains the Monet 5 wrapper code to make this all work
@c
#include "mal_exception.h"
str
TRNglobal_sync(int *ret)
{
	(void) ret;
	BBPsync(TRUE, NULL);
	return MAL_SUCCEED;
}

str
TRNglobal_abort(int *ret)
{
	(void) ret;
	TMabort();
	return MAL_SUCCEED;
}

str
TRNglobal_commit(int *ret)
{
	(void) ret;
	TMcommit();
	return MAL_SUCCEED;
}

str
TRNtrans_clean(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, *bid;
	BAT *b;

	(void) mb;
	for (i = p->retc; i < p->argc; i++) {
		bid = (int *) getArgReference(stk, p, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			return throwMessage("transaction.commit", "Cannot access descriptor");
		}

		if (b)
			BATclear(b);
		else
			return throwMessage("trans_commit", "BAT not accessible");
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
TRNtrans_abort(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, *bid;
	BAT *b;

	(void) mb;
	for (i = p->retc; i < p->argc; i++) {
		bid = (int *) getArgReference(stk, p, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			return throwMessage("transaction.abort", "Cannot access descriptor");
		}
		if (b)
			BATundo(b);
		else
			return throwMessage("transaction.abort", "BAT not accessible");
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
TRNtrans_commit(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, *bid;
	BAT *b;

	(void) mb;
	for (i = p->retc; i < p->argc; i++) {
		bid = (int *) getArgReference(stk, p, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			return throwMessage("transaction.commit", "Cannot access descriptor");
		}
		if (b)
			BATcommit(b);
		else
			return throwMessage("transaction.commit", "BAT not accessible");
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
TRNtrans_alpha(int *ret, int *bid)
{
	return BKCgetAlpha(ret, bid);
}

str
TRNtrans_delta(int *ret, int *bid)
{
	return BKCgetDelta(ret, bid);
}
@}
