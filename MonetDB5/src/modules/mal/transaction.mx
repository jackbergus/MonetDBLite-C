@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f transaction
@a M.L. Kersten, P. Boncz
@+ Transaction management
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a module.
This code base is largely absolute and should be re-considered when
serious OLTP is being supported.
Note, however, the SQL front-end obeys transaction semantics.

@mal
module transaction;

command sync():bit
address TRNglobal_sync
comment "Save all persistent BATs";
command commit():bit
address TRNglobal_commit
comment "Global commit on all BATs";
command abort():bit
address TRNglobal_abort
comment "Global abort on all BATs";
command subcommit(b:bat[:any_1,:str]):bit
address TRNsubcommit
comment "commit only a set of BATnames, passed in the tail 
(to which you must have exclusive access!)";

pattern commit(c:any...) 
address TRNtrans_commit
comment "Commit changes in certain BATs.";
pattern abort(c:any...) 
address TRNtrans_abort
comment "Abort changes in certain BATs.";
pattern clean(c:any...) 
address TRNtrans_clean
comment "Declare a BAT clean without flushing to disk.";

command prev(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address TRNtrans_prev
comment "The previous stae of this BAT";
command alpha(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address TRNtrans_alpha
comment	"List insertions since last commit.";
command delta(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address TRNtrans_delta
comment	"List deletions since last commit.";
@{
@+ Implementation Code 
@c
#include "mal_config.h"
#include "gdk.h"
#include "mal.h"
#include "mal_interpreter.h"
#include "bat5.h"

#ifdef WIN32
#ifndef LIBTRANSACTION
#define transaction_export extern __declspec(dllimport)
#else
#define transaction_export extern __declspec(dllexport)
#endif
#else
#define transaction_export extern
#endif

transaction_export str TRNglobal_sync(bit *ret);
transaction_export str TRNglobal_abort(bit *ret);
transaction_export str TRNglobal_commit(bit *ret);
transaction_export str TRNsub_commit(bit *ret, int *bid);
transaction_export str TRNtrans_clean(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
transaction_export str TRNtrans_abort(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
transaction_export str TRNtrans_commit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
transaction_export str TRNsubcommit(bit *ret, int *bid);
transaction_export str TRNtrans_prev(int *ret, int *bid);
transaction_export str TRNtrans_alpha(int *ret, int *bid);
transaction_export str TRNtrans_delta(int *ret, int *bid);

@
@include prelude.mx
@- Wrappers
The remainder contains the Monet 5 wrapper code to make this all work
@c
#include "mal_exception.h"
str
TRNglobal_sync(bit *ret)
{
	*ret = BBPsync(BBPsize,NULL)?FALSE:TRUE;
	return MAL_SUCCEED;
}

str
TRNglobal_abort(bit *ret)
{
	*ret = TMabort()?FALSE:TRUE;
	return MAL_SUCCEED;
}

str
TRNglobal_commit(bit *ret)
{
	*ret = TMcommit()?FALSE:TRUE;
	return MAL_SUCCEED;
}
str
TRNsubcommit(bit *ret, int *bid)
{
	BAT *b;
	b= BATdescriptor(*bid);
	if( b == NULL)
		throw(MAL, "transaction.subcommit", RUNTIME_OBJECT_MISSING);
	*ret = TMsubcommit(b)?FALSE:TRUE;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
TRNtrans_clean(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, *bid;
	BAT *b;

	(void) cntxt;
	(void) mb;
	for (i = p->retc; i < p->argc; i++) {
		bid = (int *) getArgReference(stk, p, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			throw(MAL, "transaction.commit",  RUNTIME_OBJECT_MISSING);
		}

		BATfakeCommit(b);
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
TRNtrans_abort(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, *bid;
	BAT *b;

	(void) cntxt;
	(void) mb;
	for (i = p->retc; i < p->argc; i++) {
		bid = (int *) getArgReference(stk, p, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			throw(MAL, "transaction.abort",  RUNTIME_OBJECT_MISSING);
		}
		BATundo(b);
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
TRNtrans_commit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, *bid;
	BAT *b;

	(void) cntxt;
	(void) mb;
	for (i = p->retc; i < p->argc; i++) {
		bid = (int *) getArgReference(stk, p, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			throw(MAL, "transaction.commit",  RUNTIME_OBJECT_MISSING);
		}
		BATcommit(b);
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
TRNtrans_prev(int *ret, int *bid)
{
	BAT *b,*bn= NULL;
	b= BATdescriptor(*bid);
	if (b  == NULL) 
		throw(MAL, "transaction.prev", RUNTIME_OBJECT_MISSING);
	bn = BATprev(b);
	BBPkeepref(*ret = bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
TRNtrans_alpha(int *ret, int *bid)
{
	return BKCgetAlpha(ret, bid);
}

str
TRNtrans_delta(int *ret, int *bid)
{
	return BKCgetDelta(ret, bid);
}
@}
