@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f factory
@a Martin Kersten
@v 1.0
@+ Factory management 
The factory infrastructure can be inspected and steered with 
the commands provided here.
@mal
module factory;

command getPlants()(mod:bat[:oid,:str], fcn:bat[:oid,:str])
address FCTgetPlants 
comment "Retrieve the names for all active factories";

command getCaller():int
address FCTgetCaller
comment "Retrieve the unique identity of the factory caller";

command getOwners():bat[:oid,:str]
address FCTgetOwners
comment "Retrieve the factory owners table";

command getArrival():bat[:oid,:timestamp]
address FCTgetArrival
comment "Retrieve the time stamp the last call was made";

command getDeparture():bat[:oid,:timestamp]
address FCTgetDeparture
comment "Retrieve the time stamp the last answer was returned";

command shutdown(m:str, f:str):void
address FCTshutdown
comment "Close a factory";
@-
@{
@include prelude.mx
@+ Implementation code 
@h
#ifndef _FACTORY_H
#define _FACTORY_H

#include "mal.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#ifdef WIN32
#ifndef LIBFACTORY
#define factory_export extern __declspec(dllimport)
#else
#define factory_export extern __declspec(dllexport)
#endif
#else
#define factory_export extern
#endif

factory_export str FCTgetPlants(int *ret, int *ret2);
factory_export str FCTgetCaller(int *ret);
factory_export str FCTgetOwners(int *ret);
factory_export str FCTgetArrival(int *ret);
factory_export str FCTgetDeparture(int *ret);
factory_export str FCTsetLocation(int *ret, str *loc);
factory_export str FCTgetLocations(int *ret);
factory_export str FCTshutdown(int *ret, str *mod, str *fcn);
#endif /* _FACTORY_H */
@c
#include "mal_config.h"
#include "factory.h"


@+ Inspection
@c
str
FCTgetPlants(int *ret, int *ret2)
{
	BAT *bmod, *bfcn;

	bmod = BATnew(TYPE_oid, TYPE_str, 256);
	if( bmod == NULL)
		throw(MAL, "factory.getPlants", "Failed to create BAT");
	if (!(bmod->batDirty&2)) bmod = BATsetaccess(bmod, BAT_READ);
    BBPkeepref(*ret= bmod->batCacheid);

	bfcn = BATnew(TYPE_oid, TYPE_str, 256);
	if( bfcn == NULL)
		throw(MAL, "factory.getPlants", "Failed to create BAT");
	if (!(bfcn->batDirty&2)) bfcn = BATsetaccess(bfcn, BAT_READ);
    BBPkeepref(*ret2= bfcn->batCacheid);
	return MAL_SUCCEED;
}

str
FCTgetCaller(int *ret)
{
	(void) ret;
	throw(MAL, "factory.getCaller", "not yet implemented");
}

str
FCTgetOwners(int *ret)
{
	BAT *b;

	(void) ret;
	b = BATnew(TYPE_oid, TYPE_str, 256);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
    *ret = b->batCacheid;
    BBPkeepref(*ret);
	throw(MAL, "factory.getOwner", "not yet implemented");
}

str
FCTgetArrival(int *ret)
{
	BAT *b;

	(void) ret;
	b = BATnew(TYPE_oid, TYPE_str, 256);
    *ret = b->batCacheid;
    BBPkeepref(*ret);
	throw(MAL, "factory.getArrival", "not yet implemented");
}

str
FCTgetDeparture(int *ret)
{
	BAT *b;

	(void) ret;
	b = BATnew(TYPE_oid, TYPE_str, 256);
    *ret = b->batCacheid;
    BBPkeepref(*ret);
	throw(MAL, "factory.getDeparture", "not yet implemented");
}

str
FCTsetLocation(int *ret, str *loc)
{
	(void) ret;
	(void) loc;
	throw(MAL, "factory.setLocation", "not yet implemented");
}

str
FCTgetLocations(int *ret)
{
	BAT *b;

	(void) ret;
	b = BATnew(TYPE_int, TYPE_str, 256);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(factory,plantid,location)@
	throw(MAL, "factory.getLocations", "not yet implemented");
}

str
FCTshutdown(int *ret, str *mod, str *fcn)
{
	Symbol s;
	(void) ret;
	s = findSymbol(getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == NULL)
		throw(MAL, "factory.shutdown", "Factory not found");
	shutdownFactory(s->def);
	return MAL_SUCCEED;
}
@}
