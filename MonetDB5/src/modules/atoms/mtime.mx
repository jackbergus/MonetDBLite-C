@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mtime
@a Peter Boncz, Martin van Dinther
@v 1.0

@* Temporal Module
@T
The goal of this module is to provide adequate functionality for storing
and manipulated time-related data. The minimum requirement is that data
can easily be imported from all common commercial RDBMS products.

This module supersedes the 'temporal' module that has a number of
conceptual problems and hard-to-solve bugs that stem from these problems.

The starting point of this module are SQL 92 and the ODBC time-related data types.
Also, some functionalities have been imported from the time classes of the Java
standard library.
@T
This module introduces four basic types and operations on them:
\begin{description}
\item[date] a date in the Gregorian calendar, e.g. 1999-JAN-31

\item[daytime] a time of day to the detail of milliseconds, e.g. 23:59:59:000

\item[timestamp] a combination of date and time, indicating an exact point in
time (GMT). GMT is the time at the Greenwich meridian without a daylight savings
time (DST) regime. Absence of DST means that hours are consecutive (no jumps) which
makes it easy to perform time difference calculations.
\item[timezone] the local time is often different from GMT (even at Greenwich in
summer, as the UK also has DST). Therefore, whenever a timestamp is composed
from a local daytime and date, a timezone should be specified in order to
translate the local daytime to GMT (and vice versa if a timestamp is to
be decomposed in a local date and daytime).

There is an additional atom {\bf rule} that is used to define when daylight
savings time in a timezone starts and ends. We provide predefined timezone
objects for a number of timezones below (see the init script of this module).
Also, there is one timezone called the {\bf local timezone}, which can be set
to one global value in a running Monet server, that is used if the timezone
parameter is omitted from a command that needs it (if not set, the default value
of the local timezone is plain GMT).
\end{description}

@+ Limitations
@T
The valid ranges of the various data types are as follows:
\begin{description}
\item[min and max year]
The maximum and minimum dates and timestamps that can be stored are in the years 5,867,411 and
-5,867,411, respectively. Interestingly, the year 0 is not a valid year. The year before 1 is
called -1.
\item[valid dates]
Fall in a valid year, and have a month and day that is valid in that year. The first day in the year
is January 1, the last December 31. Months with 31 days are January, March, May, July, August,
October, and December, while April, June, September and November have 30 days. February has 28
days, expect in a leap year, when it has 29. A leap year is a year that is an exact multiple of
4. Years that are a multiple of 100 but not of 400 are an exception; they are no leap years.
\item[valid daytime]
The smallest daytime is 00:00:00:000 and the largest 23:59:59:999 (the hours in a daytime
range between [0,23], minutes and seconds between [0,59] and milliseconds between [0:999]).
Daytime identifies a valid time-of-day, not an amount of time (for denoting amounts of time, or
time differences, we use here concepts like "number of days" or "number of milliseconds" denoted
by some value of a standard integer type).
\item[valid timestamp]
is formed by a combination of a valid date and valid daytime.
\item[difference in days]
For difference calculations between dates (in numbers of days) we use signed integers (the {\tt int}
Monet type), hence the valid range for difference calculations is between -2147483648 and
2147483647 days (which corresponds to roughly -5,867,411 and 5,867,411 years).
\item[difference in msecs]
For difference between timestamps (in numbers of milliseconds) we use 64-bit longs (the {\tt lng} Monet type).
These are large integers of maximally 19 digits, which therefore impose a limit of about 106,000,000,000 years
on the maximum time difference used in computations.
\end{description}

There are also conceptual limitations that are inherent to the time system itself:
\begin{description}
\item[Gregorian calendar]
The basics of the Gregorian calendar stem from the time of Julius Caesar,
when the concept of a solar year as consisting of 365.25 days (365 days plus once
in 4 years one extra day) was introduced. However, this Julian Calendar, made a year 11
minutes long, which subsequently accumulated over the ages, causing a shift in
seasons. In medieval times this was noticed, and in 1582 Pope Gregory XIII issued a
decree, skipped 11 days. This measure was not adopted in the whole of Europe immediately,
however.  For this reason, there were many regions in Europe that upheld different dates.

It was only on {\bf September 14, 1752} that some consensus was reached and more countries
joined the Gregorian Calendar, which also was last modified at that time. The modifications
were twofold: first, 12 more days were skipped. Second, it was determined that the
year starts on January 1 (in England, for instance, it had been starting on March 25).

Other parts of the world have adopted the Gregorian Calendar even later.

This module implements the Gregorian Calendar in all its regularity. This means
that values before the year 1752 probably do not correspond with the dates that
people really used in times before that (what they did use, however, was very vague
anyway, as explained above). In solar terms, however, this calendar is reasonably
accurate (see the "correction seconds" note below).

\item[timezones]
The basic timezone regime was established on {\bf November 1, 1884} in the {\em International
Meridian Conference} held in Greenwich (UK). Before that, a different time held in almost
any city. The conference established 24 different time zones defined by regular longitude intervals
that all differed by one hour.	Not for long it was that national and political interest started
to erode this nicely regular system.  Timezones now often follow country borders, and some regions
(like the Guinea areas in Latin America) have times that differ with a 15 minute grain from GMT
rather than an hour or even half-an-hour grain.

An extra complication became the introduction of daylight saving time (DST), which
causes a time jump in spring, when the clock is skips one hour and in autumn, when the
clock is set back one hour (so in a one hour span, the same times occur twice).
The DST regime is a purely political decision made on a country-by-country basis. Countries
in the same timezone can have different DST regimes. Even worse, some countries have DST in
some years, and not in other years.

To avoid confusion, this module stores absolute points of time in GMT only (GMT does not
have a DST regime). When storing local times in the database, or retrieving local times
from absolute timestamps, a correct timezone object should be used for the conversion.

Applications that do not make correct use of timezones, will produce irregular results
on e.g. time difference calculations.

\item[correction seconds]
Once every such hundred years, a correction second is added on new year's night.
As I do not know the rule, and this rule would seriously complicate this module
(as then the duration of a day, which is now the fixed number of 24*60*60*1000
milliseconds, becomes parametrized by the date), it is not implemented. Hence
these seconds are lost, so time difference calculations in milliseconds (rather than
in days) have a small error if the time difference spans many hundreds of years.
\end{description}

TODO: we cannot handle well changes in the timezone rules (e.g., DST only exists since
40 years, and some countries make frequent changes to the DST policy). To accommodate
this we should make timezone\_local a function with a year parameter. The tool should
maintain and access the timezone database stored in two bats [str,timezone],[str,year].
Lookup of the correct timezone would be dynamic in this structure. The timezone\_setlocal
would just set the string name of the timezone.

@+ Time/date comparison 

@= compareGrp
command ==(v:@1,w:@1):bit 
address MTIME@1_EQ
comment "Equality of two @1s";
command !=(v:@1,w:@1):bit 
address MTIME@1_NEQ
comment "Equality of two @1s";
command <(v:@1,w:@1):bit 
address MTIME@1_LT
comment "Equality of two @1s";
command <=(v:@1,w:@1):bit 
address MTIME@1_LE
comment "Equality of two @1s";
command >(v:@1,w:@1):bit 
address MTIME@1_GT
comment "Equality of two @1s";
command >=(v:@1,w:@1):bit 
address MTIME@1_GE
comment "Equality of two @1s";
command isnil(v:@1):bit 
address MTIME@1_isnil
comment "Nil test for @1 value";

module mtime;
command calc.==(v:@1,w:@1):bit 
address MTIME@1_EQ
comment "Equality of two @1s";
command calc.!=(v:@1,w:@1):bit 
address MTIME@1_NEQ
comment "Equality of two @1s";
command calc.<(v:@1,w:@1):bit 
address MTIME@1_LT
comment "Equality of two @1s";
command calc.<=(v:@1,w:@1):bit 
address MTIME@1_LE
comment "Equality of two @1s";
command calc.>(v:@1,w:@1):bit 
address MTIME@1_GT
comment "Equality of two @1s";
command calc.>=(v:@1,w:@1):bit 
address MTIME@1_GE
comment "Equality of two @1s";
command calc.isnil(v:@1):bit 
address MTIME@1_isnil
comment "Nil test for @1 value";
@mal

@+ Date atom
@T
Monet atoms can have multiple {\em parse formats}. One of these formats is
chosen as the {\em print format}.

To facilitate date descriptions, many formats are supported when parsing
date atoms from a string, as described by the below grammar.
{\small
\begin{verbatim}
print format: INT_YEAR '-' INT_MONTH '-' INT_DAY
parse format: INT_YEAR SEP1 INT_MONTH SEP1 INT_DAY
	  or: INT_YEAR SEP2 STR_MONTH SEP2 INT_DAY
	  or: STR_MONTH ' '+ INT_DAY ',' ' '* INT_YEAR

with:	INT_YEAR = integer between -5867411 and 5867411
	INT_DAY = integer between 1 and 31
	INT_MONTH = integer between 1 and 12
	STR_MONTH = 'JANUARI' or 'FEBRUARI' or 'MARCH' or 'APRIL' or 'MAY'
		    or 'JUNE' or 'JULI' or 'AUGUST' or 'SEPTEMBER' or 'OCTOBER' 
	                or 'NOVEMBER' or 'DECEMBER' (lowercase characters, and/or 
	                only the first three characters are also allowed)
	        SEP1 = '-' or '/' or '\' or (' ')+
	        SEP2 = SEP1 or ''
\end{verbatim}
}
Printing a date uses the 1999-01-31 format, as this is both language neutral
and the lexicografical string ordering of this representation respects the
actual date ordering.

Other print formats can be achieved by writing a customized MIL procedure
that extract year, month and day from a date as integers and formats those
in a string.
@mal
atom date :int;
command date(s:date):date
address MTIMEdate_date
comment "Noop routine.";
command fromstr() :date 
address date_fromstr;
command tostr() :str 
address date_tostr;

@:compareGrp(date)@
@+ Daytime atom
@T
A valid time of day to the detail of milliseconds, like 23:59:59:000
{\small
\begin{verbatim}
print format: HOUR ':' MIN ':' SEC '.' MSEC
parse format: HOUR ':' MIN ':' SEC SEP MSEC
	  or: HOUR ':' MIN ':' SEC
	  or: HOUR ':' MIN

with: HOUR = integer between 0 and 23
	   MIN = integer between 0 and 59
	   SEC = integer between 0 and 59 (default = 0)
	  MSEC = integer between 0 and 999 (default = 0)
	   SEP = '.' or ':'
\end{verbatim}
}
@mal
atom daytime :int;
command fromstr():daytime 
address daytime_tz_fromstr;
command tostr():str 
address daytime_tostr;

@:compareGrp(daytime)@

@+ Timestamp
@T
An absolute point of time, as formed by the combination of a date a daytime in GMT
e.g. 1999-01-31@23:59:59:000. GMT is the universal time at the Greenwich meridian,
without any daylight savings time (DST). As such GMT times are 'absolute' (continuous,
without hour jumps as in DST), so accurate time difference computations can be performed.
{\small
\begin{verbatim}
print format: DATE ' ' DAYTIME
parse format: DATE ' ' DAYTIME  ['GMT' ZONE ]

with:    DATE = a valid parse format of the date atom (as decribed earlier)
	  DAYTIME = a valid parse format of the daytime atom (as decribed earlier)
	     ZONE = ('+'|'-') HOUR ':' MIN [ 'DST' ]
\end{verbatim}
}
Though internally timestamps are stored in GMT, the printing and parsing of
timestamps is relative to the local timezone. That is, timestamps are
printed without GMT part, meaning that the time is relative to the local
timezone.   Also, if a timestamp is parsed from a string that does not have
an explicit GMT specifier, it is taken to be a timestamp in the local
timezone. The default local timezone is just GMT+00, but it can be set
arbitrarily.
@mal
atom timestamp :lng;# not stored as a lng !
command fromstr():timestamp 
address timestamp_fromstr;

command tostr():str 
address timestamp_tostr;
command unix_epoch():timestamp
address MTIMEunix_epoch
comment "The Unix epoch time (00:00:00 UTC on January 1, 1970)";
command epoch():timestamp
address MTIMEepoch
comment "unix-time (epoch) support: seconds since the Unix epoch";
command epoch(t:timestamp):lng 
address MTIMEepoch2lng
comment "unix-time (epoch) support: seconds since epoch";

@:compareGrp(timestamp)@

@T
When creating a timestamp from a date and daytime, a timezone should be specified
(if timezone is omitted, the local timezone is assumed). If a timezone is specified,
it is used to convert the date and time in that timezone to GMT, which is the internal
timestamp representation. One problem here is that the first hour after DST
has ended (some Sunday night in autumn, generally), the time is set back one hour, so
the same times occur twice. Hence two translations to a timestamp are possible for
such date and time combinations. In those case, we act as if it was the first
occurrence (still within DST).

@+ Tzone
@T
A timezone determines a {\em time offset} from GMT with format
[-] HOUR ':' MINUTES, with HOUR between [0:23] and MINUTES between [0:59].

Possibly, {\em Daylight Savings Time} (DST) is in force in a timezone, which means that
between a start and an end date, the clock is set back {\bf one hour}. The start and
end date of DST are determined by a {\em rule}. These rules (similar to the
Java Timezone class) are made up of 4 parameters: a month {\bf M}, a day number in the
month {\bf D}, a day-of-week (monday,..,sunday) denoted {\bf W}, and a daytime {\bf T}
(only to the minute detail).

Depending of the values of these parameters, five kinds of rules can be made
(similar to the Java TimeZone class):
\begin{itemize}
\item first {\bf D}th weekday {\bf W} from start of month {\bf M}.\\
iff {\bf D} in [1,..,5], {\bf W} in [1,..,7]

\item last {\bf D}th weekday {\bf W} from end of month {\bf M}.\\
iff {\bf D} in [-5,..,-1], {\bf W} in [1,..,7]

\item first weekday {\bf W} in month {\bf M} after exact {\bf D}th day of month.\\
iff {\bf D} in [1,..,31], {\bf W} in [-7,..,-1]

\item last weekday {\bf W} in month {\bf M} before exact {\bf D}th day of month.\\
iff {\bf D} in [-31,..,-1], {\bf W} in [-7,..,-1]

\item exact {\bf D}th day of month {\bf M}.\\
iff {\bf D} in [1,..,31], {\bf W}=0;

\end{itemize}
The parameters {\bf M} is a month number between 1 and 12, and {\bf T} is a time
to the minute detail just like the time offset of the timezone.

Other values of the rule parameters on creating a timezone will produce a
nil-timezone.

@mal
atom timezone :lng;
command fromstr():timezone 
address tzone_fromstr;
command tostr():str   
address tzone_tostr;
command str():str   
address MTIMEtzone_tostr;
command timestamp(s:str):timestamp
address MTIMEtimestamp_fromstr;
command timestamp(secs:int):timestamp
address MTIMEtimestamp
comment "Utility function to create a timestamp from a number of seconds since the Unix epoch";


atom zrule :int;
command fromstr():zrule 
address rule_fromstr;
command tostr():str 
address rule_tostr;
command define(m:int,d:int,w:int,h:int,min:int):zrule 
address MTIMEruleDef0
comment "Introduce a synomym timezone rule.";
command define(m:int,d:str,w:int,h:int,min:int):zrule 
address MTIMEruleDef1
comment "Introduce a synomym timezone rule.";
command define(m:int,d:str,w:int,min:int):zrule 
address MTIMEruleDef2
comment "Introduce a synomym timezone rule.";


module mtime;
command date_sub_sec_interval(t:date,s:int):date 
address MTIMEdate_sub_sec_interval_wrap
comment "Subtract seconds from a date";
command date_sub_sec_interval(t:date,s:lng):date 
address MTIMEdate_sub_sec_interval_lng_wrap;

command date_add_sec_interval(t:date,s:int):date 
address MTIMEdate_add_sec_interval_wrap
comment "Add seconds to a date";
command date_add_sec_interval(t:date,s:lng):date 
address MTIMEdate_add_sec_interval_lng_wrap;

command timestamp_sub_sec_interval(t:timestamp,s:lng):timestamp 
address MTIMEtimestamp_sub_sec_interval_lng_wrap;
command timestamp_add_sec_interval(t:timestamp,s:lng):timestamp 
address MTIMEtimestamp_add_sec_interval_lng_wrap;

command timestamp_sub_month_interval(t:timestamp,s:int):timestamp 
address MTIMEtimestamp_sub_month_interval_wrap
comment "Subtract months from a timestamp";
command timestamp_add_month_interval(t:timestamp,s:int):timestamp 
address MTIMEtimestamp_add_month_interval_wrap
comment "Add months to a timestamp";
command timestamp(t:timestamp):timestamp
address MTIMEtimestamp2timestamp;

command time_sub_sec_interval(t:daytime,s:lng):daytime 
address MTIMEtime_sub_sec_interval_wrap
comment "Subtract seconds from a time";
command time_add_sec_interval(t:daytime,s:lng):daytime 
address MTIMEtime_add_sec_interval_wrap
comment "Add seconds to a time";

command date_add_month_interval(t:date,s:int):date 
address MTIMEdate_add_month_interval_wrap
comment "Add months to a date";

#command int(d:date):int = MTIMEdate_2int;
#command int(d:daytime):int = MTIMEdaytime_2int;
#command lng(d:timestamp):int = MTIMEtimestamp_2lng;
#command lng(d:timezone):lng = MTIMEtzone_2lng;
#command int(d:zrule):int = MTIMErule_2int;

command date(:date):date
address MTIMEdate2date
comment "generate the nil date";
command date(:void):date
address MTIMEnil2date
comment "generate the nil date";

command local_timezone():lng 
address MTIMElocal_timezone 
comment "get the local timezone in seconds";

command timezone_local(t:timezone):void 
address MTIMEtzone_set_local 
comment "set the local timezone; which is used for printing timestamps";
command timezone_local() :timezone 
address MTIMEtzone_get_local 
comment "get the local timezone; which is used for printing timestamps";

@+ Time/date construction
Construct temporal values from simple(r) parameters.
Out-of range result values are represented by the nil.
@mal
command date(s:str):date 
address MTIMEdate_fromstr
comment "convert the string to a type date value";

command date(yr:int, mo:int, day:int):date 
address MTIMEdate_create 
comment "creates a date from (year,month,day).";

command daytime(s:str):daytime
address MTIMEdaytime_fromstr
comment "convert the string to a daytime value.";
command daytime(:daytime):daytime
address MTIMEdaytime2daytime;
command daytime(:lng):daytime
address MTIMEsecs2daytime;

command daytime(h:int,m:int,s:int,mi:int)
		:daytime 
address MTIMEdaytime_create 
comment "creates a time from (hours,minutes,
	seconds,milliseconds) parameters.";
command timestamp(d:date,dt:daytime,t:timezone) :timestamp 
address MTIMEtimestamp_create 
comment "creates a timestamp from (date, daytime,timezone) parameters.";
command timestamp(d:date,dt:daytime) :timestamp 
address MTIMEtimestamp_create_default 
comment "creates a timestamp from (d,dt) parameters (in the local timezone).";
command timestamp(d:date) :timestamp 
address MTIMEtimestamp_create_from_date 
comment "creates a timestamp from (d,00:00:00) parameters (in the local timezone).";

command rule(s:str):zrule
address MTIMErule_fromstr
comment "create a rule from a  string.";
command rule (mo:int,d:int,wkday:int,mi:int) :zrule 
address MTIMErule_create 
comment "create a DST start/end date rule.";

command timezone(s:str):timezone 
address MTIMEtzone_fromstr
comment "Convert the string to a timezone.";
command timezone(s:int):timezone 
address MTIMEtzone_create
comment "Convert the int to a timezone.";
command timezone(s:lng):timezone 
address MTIMEtzone_create
comment "Convert the int to a timezone.";
command timezone(mi:int,s:zrule,erule:zrule):timezone 
address MTIMEtzone_create_dst 
comment "create a timezone as an hour difference 
	from GMT and a DST.";

@- Time/date decomposition
@T
There are routines that decompose a date and routines that decompose a daytime.
For decomposing a timestamp, there are routines that decompose it in a date
and daytime. The bulk variants are also provided to simplify code
generation for SQL and to improve speed.
@mal
# date
command year(d:date) :int 
address MTIMEdate_extract_year 
comment "extracts year from date (nonzero 
	value between -5867411 and +5867411).";
command year(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdate_extract_year_bulk;

command month(d:date) :int 
address MTIMEdate_extract_month 
comment "extracts month from date";
command month(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdate_extract_month_bulk;

command day(d:date) :int 
address MTIMEdate_extract_day 
comment "extracts day from date ";
command day(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdate_extract_day_bulk;

# daytime
command hours(h:daytime) :int 
address MTIMEdaytime_extract_hours 
comment "extracts hour from daytime";
command hours(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdaytime_extract_hours_bulk;

command minutes(d:daytime) :int 
address MTIMEdaytime_extract_minutes 
comment "extracts minutes from daytime";
command minutes(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdaytime_extract_minutes_bulk;

command seconds(d:daytime) :int 
address MTIMEdaytime_extract_seconds 
comment "extracts seconds from daytime";
command seconds(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdaytime_extract_seconds_bulk;

command milliseconds(d:daytime) :int 
address MTIMEdaytime_extract_milliseconds 
comment "extracts milliseconds from daytime";
command milliseconds(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdaytime_extract_milliseconds_bulk;

# timestamp
command daytime(t:timestamp) :daytime 
address MTIMEtimestamp_extract_daytime_default 
comment "extracts daytime from timestamp 
	in the local timezone.";
command daytime(t:timestamp, v:timezone) :daytime 
address MTIMEtimestamp_extract_daytime 
comment "extracts daytime from timestamp 
	in a specific timezone.";

command date(t:timestamp) :date 
address MTIMEtimestamp_extract_date_default 
comment "extracts date from timestamp 
	in the local timezone.";
command date(t:timestamp,v:timezone) :date 
address MTIMEtimestamp_extract_date 
comment "extracts date from timestamp in a 
	specific timezone.";

# timezone
command setTimezone(name:str):timezone 
address MTIMEtimezone
comment "Test and set the timezone.";

command start_dst(t:timezone) :zrule 
address MTIMEtzone_extract_start 
comment "extract rule that determines 
	start of DST from timezone.";
command end_dst(t:timezone) :zrule 
address MTIMEtzone_extract_end 
comment "extract rule that determines 
	end of DST from timezone.";
command minutes(t:timezone) :int 
address MTIMEtzone_extract_minutes 
comment "extract number of minutes that 
	time zone is offset wrt GMT.";

# rule
command month(t:zrule) :int 
address MTIMErule_extract_month 
comment "extract month from rule.";
command day(t:zrule) :int 
address MTIMErule_extract_day 
comment "extract day from rule.";
command weekday(t:zrule) :int 
address MTIMErule_extract_weekday 
comment "extract weekday from rule.";
command minutes(t:zrule) :int 
address MTIMErule_extract_minutes 
comment "extract minutes from rule.";

@+ Time/date arithmetic
@T
We choose to represent intervals of time as numbers of days (as int, a 32-bits integer)
and numbers of milliseconds (as lng, a 64-bits integer). Using standard integer types
facilitates computation with these amounts of time (you can use all normal integer
arithmetic operators).

Arithmetic overflow returns the nil atom (no error messages). For all commands in
this modules it holds that if one of the parameters is nil, the result is also nil
(nil has the don't know semantics in MIL).
@mal
command addyears(value:date, years:int) :date 
address MTIMEdate_addyears 
comment "returns the date after a number 
	of years (possibly negative).";
command addmonths(value:date, months:int) :date 
address MTIMEdate_addmonths 
comment "returns the date after a number of 
	months (possibly negative).";
command adddays(value:date, days:int) :date 
address MTIMEdate_adddays 
comment "returns the date after a number 
	of days (possibly negative).";
command diff(val1:date, val2:date) :int 
address MTIMEdate_diff 
comment "returns the number of days 
	between 'val1' and 'val2'.";

command dayofyear(d:date) :int 
address MTIMEdate_extract_dayofyear 
comment "Returns N where d is the Nth day 
	of the year (january 1 returns 1)";
command weekofyear(d:date) :int 
address MTIMEdate_extract_weekofyear 
comment "Returns the week number in the year.";
command dayofweek(d:date) :int 
address MTIMEdate_extract_dayofweek 
comment "Returns the current day of the week 
	where 1=sunday, .., 7=saturday";

command add(v:timestamp, msecs:lng) :timestamp 
address MTIMEtimestamp_add 
comment "returns the timestamp that comes 'msecs' 
	(possibly negative) after 'value'.";
command diff(val1:timestamp, val2:timestamp) :lng 
address MTIMEtimestamp_diff 
comment "returns the number of milliseconds 
	between 'val1' and 'val2'.";

command dst(t:timestamp,v:timezone) :bit 
address MTIMEtimestamp_inside_dst 
comment "return whether DST holds in the 
	timezone at a certain point of time.";

command compute(r:zrule, year:int) :date 
address MTIMEcompute_rule_foryear 
comment "compute the date from a rule in a given year";

@- Day and month names
One day we should introduce the concept of locale, and hook here.
@mal
command monthnum(month:str) :int 
address MTIMEmonth_from_str 
comment "Returns month number [1-12] from a string
	 or nil if does not match any.";
command monthname(month:int) :str 
address MTIMEmonth_to_str 
comment "Returns month name from a number 
	between [1-12], str(nil) otherwise.";
command daynum(day:str) :int 
address MTIMEday_from_str 
comment "Returns number of day [1-7] from a 
	string or nil if does not match any.";
command dayname(day:int) :str 
address MTIMEday_to_str 
comment "Returns day name from a number 
	between [1-7], str(nil) otherwise.";

command time_synonyms(allow:bit) 
address MTIMEsynonyms 
comment "Allow synonyms for the parse format of 
	date/timestamp.";

command olddate (format:str) :date 
address MTIMEolddate 
comment "create a date from the old instant 
	format.";
command oldduration(format:str) :int 
address MTIMEoldduration 
comment "parse the old duration format and 
	return an (estimated) number of days.";

@+ Utilities
The Monet V4 procs are converted into functions.
@mal

command msecs(d:int,h:int,m:int,s:int,ms:int):lng
address MTIMEmsecs
comment "convert date components to milliseconds";

command daytime(h:int):daytime 
address MTIMEdaytime1
comment "default time with zeroed components";
command daytime(h:int,m:int):daytime 
address MTIMEdaytime2
comment "default time with zeroed components";
command daytime(h:int,m:int,s:int):daytime 
address MTIMEdaytime3
comment "default time with zeroed components";

#SQL utility functions
command current_timestamp():timestamp
address MTIMEcurrent_timestamp;
command current_date():date
address MTIMEcurrent_date;
command current_time():daytime
address MTIMEcurrent_time;

command year(t:timestamp):int 
address MTIMEtimestamp_year;
command month(t:timestamp):int
address MTIMEtimestamp_month;
command day(t:timestamp):int
address MTIMEtimestamp_day;
command hours(t:timestamp):int
address MTIMEtimestamp_hours;
command minutes(t:timestamp):int
address MTIMEtimestamp_minutes;
command seconds(t:timestamp):int
address MTIMEtimestamp_seconds;
command milliseconds(t:timestamp):int
address MTIMEtimestamp_milliseconds;

command year(months:int):int
address MTIMEsql_year;
command month(months:int):int
address MTIMEsql_month;
command day(secs:lng):int
address MTIMEsql_day;
command hours(secs:lng):int
address MTIMEsql_hours;
command minutes(secs:lng):int
address MTIMEsql_minutes;
command seconds(secs:lng):int
address MTIMEsql_seconds;

command msec():lng 
address MTIMEmsec
comment "get time of day in msec since 1-1-1970.";

@{
@+ Prelude section
Upon intialization of the time module, we have to
initialize some variables, e.g. nils and the box with predefined
constants.
These actions are captured in a single function activated directly after
parsing of the signatures. 
@mal
command prelude()
address MTIMEprelude;

command epilogue()
address MTIMEepilogue;

mtime.prelude();

@* Implementation

@+ Atoms

@- date
Internally, we store date as the (possibly negative) number of
days since the start of the calendar. Oddly, since I (later) learned
that the year 0 did no exist, this defines the start of the calendar to
be Jan 1 of the year -1 (in other words, a -- positive -- year component
of a date is equal to the number of years that have passed since the start
of the calendar).
@h
#ifndef _MONETTIME_H_
#define _MONETTIME_H_

#include <gdk.h>
#include <mal.h>

#ifdef WIN32
#ifndef LIBMTIME
#define mtime_export extern __declspec(dllimport)
#else
#define mtime_export extern __declspec(dllexport)
#endif
#else
#define mtime_export extern
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

typedef int date;
#define date_nil ((date) int_nil)
@c
#include "mtime.h"

@- daytime
Daytime values are also stored as the number of milliseconds that passed since
the start of the day (i.e. midnight).
@h
typedef int daytime;
#define daytime_nil ((daytime) int_nil)

@- timestamp
Timestamp is implemented as a record that contains a date and a time (GMT).
@h
typedef struct {
#ifndef WORDS_BIGENDIAN
	daytime msecs;
	date days;
#else
	date days;
	daytime msecs;
#endif
} timestamp;

@- rule
rules are used to define the start and end of DST. It uses the 25 lower bits of an int.
@h
typedef union {
	struct {
		unsigned int month:4,	/* values: [1..12] */
		 minutes:11,	/* values: [0:1439] */
		 day:6,		/* values: [-31..-1,1..31] */
		 weekday:4,	/* values: [-7..-1,1..7] */
		 empty:7;	/* rule uses just 32-7=25 bits */
	} s;
	int asint;		/* the same, seen as single value */
} rule;
@c
#define get_rule(r)	((r).s.weekday | ((r).s.day<<6) | ((r).s.minutes<<10) | ((r).s.month<<21))
#define set_rule(r,i) { (r).s.weekday = (i)&15;\
			(r).s.day = ((i)&(63<<6))>>6;\
			(r).s.minutes = ((i)&(2047<<10))>>10;\
			(r).s.month = ((i)&(15<<21))>>21; \
			(r).s.empty = 0; /* to please valgrind */ }

/* phony zero values, used to get negative numbers from unsigned sub-integers in rule */
#define WEEKDAY_ZERO	8
#define DAY_ZERO	32
#define OFFSET_ZERO	4096

@- timezone
A timezone consists of an offset and two DST rules, all crammed into one lng.
@h
typedef struct {
	/* we had this as bitfields in one unsigned long long, but native sun CC does not eat that.  */
	unsigned int dst:1, off1:6, dst_start:25;
	unsigned int off2:7, dst_end:25;
} tzone;
@c
/* as the offset field got split in two, we need macros to get and set them */
#define get_offset(z)	(((int) (((z)->off1 << 7) + (z)->off2)) - OFFSET_ZERO)
#define set_offset(z,i)	{ (z)->off1 = (((i)+4096)&8064) >> 7; (z)->off2 = ((i)+OFFSET_ZERO)&127; }

tzone tzone_local;
@h
mtime_export tzone tzone_local;

mtime_export void fromdate(int n, int *d, int *m, int *y);
mtime_export void fromtime(int n, int *hour, int *min, int *sec, int *msec);
mtime_export int daytime_tz_fromstr(str buf, int *len, daytime **ret);
mtime_export str MTIMEcurrent_timestamp(timestamp *t);
mtime_export str MTIMEcurrent_date(date *d);
mtime_export str MTIMEcurrent_time(daytime *t);
mtime_export int timestamp_tostr(str *buf, int *len, timestamp *val);
mtime_export int timestamp_diff(lng *ret, timestamp *v1, timestamp *v2);
mtime_export str MTIMEnil2date(date *ret, int *src);
mtime_export str MTIMEdate2date(date *ret, date *src);
mtime_export str MTIMEdaytime2daytime(daytime *ret, daytime *src);
mtime_export str MTIMEsecs2daytime(daytime *ret, lng *src);
mtime_export str MTIMEtimestamp2timestamp(timestamp *ret, timestamp *src);
mtime_export str MTIMErule_fromstr(rule *ret, str *s);
mtime_export str MTIMEprelude(void);
mtime_export str MTIMEepilogue(void);
mtime_export str MTIMEsynonyms(bit *allow);
mtime_export str MTIMEoldduration(int *ndays, str *s);
mtime_export str MTIMEolddate(date *d, str *buf);
mtime_export str MTIMEtimezone(tzone *z, str *name);
mtime_export str MTIMElocal_timezone(lng *res);
mtime_export str MTIMEtzone_set_local(int res, tzone *z);
mtime_export str MTIMEtzone_get_local(tzone *z);
mtime_export str MTIMEmonth_from_str(int *ret, str *month);
mtime_export str MTIMEmonth_to_str(str *ret, int *month);
mtime_export str MTIMEday_from_str(int *ret, str *day);
mtime_export str MTIMEday_to_str(str *ret, int *day);
mtime_export str MTIMEdate_date(date *d, date *s);
mtime_export str MTIMEdate_tostr(str *ret, date *d);
mtime_export str MTIMEdate_fromstr(date *ret, str *s);
mtime_export str MTIMEdate_create(date *ret, int *year, int *month, int *day);
mtime_export str MTIMEdaytime_tostr(str *ret, daytime *d);
mtime_export str MTIMEdaytime_create(daytime *ret, int *hour, int *min, int *sec, int *msec);
mtime_export str MTIMEtimestamp_fromstr(timestamp *ret, str *d);
mtime_export str MTIMEtimestamp_timestamp(timestamp *d, timestamp *s);
mtime_export str MTIMEtimestamp_create(timestamp *ret, date *d, daytime *t, tzone *z);
mtime_export str MTIMEtimestamp_create_default(timestamp *ret, date *d, daytime *t);
mtime_export str MTIMEtimestamp_create_from_date(timestamp *ret, date *d);
mtime_export str MTIMEdate_extract_year(int *ret, date *v);
mtime_export str MTIMEdate_extract_month(int *ret, date *v);
mtime_export str MTIMEdate_extract_day(int *ret, date *v);
mtime_export str MTIMEdate_extract_dayofyear(int *ret, date *v);
mtime_export str MTIMEdate_extract_weekofyear(int *ret, date *v);
mtime_export str MTIMEdate_extract_dayofweek(int *ret, date *v);
mtime_export str MTIMEdaytime_extract_hours(int *ret, daytime *v);
mtime_export str MTIMEdaytime_extract_minutes(int *ret, daytime *v);
mtime_export str MTIMEdaytime_extract_seconds(int *ret, daytime *v);
mtime_export str MTIMEdaytime_extract_milliseconds(int *ret, daytime *v);
mtime_export str MTIMEtimestamp_extract_daytime(daytime *ret, timestamp *t, tzone *z);
mtime_export str MTIMEtimestamp_extract_daytime_default(daytime *ret, timestamp *t);
mtime_export str MTIMEtimestamp_extract_date(date *ret, timestamp *t, tzone *z);
mtime_export str MTIMEtimestamp_extract_date_default(date *ret, timestamp *t);
mtime_export str MTIMEdate_addyears(date *ret, date *v, int *delta);
mtime_export str MTIMEdate_adddays(date *ret, date *v, int *delta);
mtime_export str MTIMEdate_addmonths(date *ret, date *v, int *delta);
mtime_export str MTIMEdate_diff(int *ret, date *v1, date *v2);
mtime_export str MTIMEtimestamp_add(timestamp *ret, timestamp *v, lng *msecs);
mtime_export str MTIMEtimestamp_diff(lng *ret, timestamp *v1, timestamp *v2);
mtime_export str MTIMEtimestamp_inside_dst(bit *ret, timestamp *p, tzone *z);
mtime_export str MTIMEtimestamp_isnil(bit *retval, timestamp *val);
mtime_export str MTIMEtimestamp_EQ(bit *retval, timestamp *val1, timestamp *val2);
mtime_export str MTIMEtimestamp_NEQ(bit *retval, timestamp *val1, timestamp *val2);

mtime_export str MTIMEtimestamp_year(int *ret, timestamp *t);
mtime_export str MTIMEtimestamp_month(int *ret, timestamp *t);
mtime_export str MTIMEtimestamp_day(int *ret, timestamp *t);
mtime_export str MTIMEtimestamp_hours(int *ret, timestamp *t);
mtime_export str MTIMEtimestamp_minutes(int *ret, timestamp *t);
mtime_export str MTIMEtimestamp_seconds(int *ret, timestamp *t);
mtime_export str MTIMEtimestamp_milliseconds(int *ret, timestamp *t);
mtime_export str MTIMEsql_year(int *ret, int *t);
mtime_export str MTIMEsql_month(int *ret, int *t);
mtime_export str MTIMEsql_day(int *ret, lng *t);
mtime_export str MTIMEsql_hours(int *ret, lng *t);
mtime_export str MTIMEsql_minutes(int *ret, lng *t);
mtime_export str MTIMEsql_seconds(int *ret, lng *t);


mtime_export str MTIMEtimestamp_LT(bit *retval, timestamp *val1, timestamp *val2);
mtime_export str MTIMEtimestamp_LE(bit *retval, timestamp *val1, timestamp *val2);
mtime_export str MTIMEtimestamp_GT(bit *retval, timestamp *val1, timestamp *val2);
mtime_export str MTIMEtimestamp_GE(bit *retval, timestamp *val1, timestamp *val2);
mtime_export str MTIMErule_tostr(str *s, rule *r);
mtime_export str MTIMErule_fromstr(rule *ret, str *s);
mtime_export str MTIMErule_create(rule *ret, int *month, int *day, int *weekday, int *minutes);
mtime_export str MTIMEtzone_create_dst(tzone *ret, int *minutes, rule *start, rule *end);
mtime_export str MTIMEtzone_create(tzone *ret, int *minutes);
mtime_export str MTIMErule_extract_month(int *ret, rule *r);
mtime_export str MTIMErule_extract_day(int *ret, rule *r);
mtime_export str MTIMErule_extract_weekday(int *ret, rule *r);
mtime_export str MTIMErule_extract_minutes(int *ret, rule *r);
mtime_export str MTIMEtzone_extract_start(rule *ret, tzone *t);
mtime_export str MTIMEtzone_extract_end(rule *ret, tzone *t);
mtime_export str MTIMEtzone_extract_minutes(int *ret, tzone *t);
mtime_export str MTIMEdate_sub_sec_interval_wrap(date *ret, date *t, int *sec);
mtime_export str MTIMEdate_sub_sec_interval_lng_wrap(date *ret, date *t, lng *sec);
mtime_export str MTIMEdate_add_sec_interval_wrap(date *ret, date *t, int *sec);
mtime_export str MTIMEdate_add_sec_interval_lng_wrap(date *ret, date *t, lng *sec);
mtime_export str MTIMEdate_add_month_interval_wrap(date *ret, date *t, int *months);
mtime_export str MTIMEtimestamp_add_sec_interval_lng_wrap(timestamp *ret, timestamp *t, lng *sec);
mtime_export str MTIMEtimestamp_sub_sec_interval_lng_wrap(timestamp *ret, timestamp *t, lng *sec);
mtime_export str MTIMEtimestamp_sub_month_interval_wrap(timestamp *ret, timestamp *t, int *months);
mtime_export str MTIMEtimestamp_add_month_interval_wrap(timestamp *ret, timestamp *t, int *months);
mtime_export str MTIMEtime_sub_sec_interval_wrap(daytime *ret, daytime *t, lng *sec);
mtime_export str MTIMEtime_add_sec_interval_wrap(daytime *ret, daytime *t, lng *sec);
mtime_export str MTIMEcompute_rule_foryear(date *ret, rule *val, int *year);
mtime_export str MTIMEtzone_tostr(str *s, tzone *ret);
mtime_export str MTIMEtzone_fromstr(tzone *ret, str *s);
mtime_export str MTIMEdaytime_fromstr(daytime *ret, str *s);
mtime_export str MTIMEmsecs(lng *ret, int *d, int *h, int *m, int *s, int *ms);
mtime_export str MTIMEdaytime1(daytime *ret, int *h);
mtime_export str MTIMEdaytime2(daytime *ret, int *h, int *m);
mtime_export str MTIMEdaytime3(daytime *ret, int *h, int *m, int *s);
mtime_export str MTIMEunix_epoch(timestamp *ret);
mtime_export str MTIMEepoch(timestamp *ret);
mtime_export str MTIMEepoch2lng(lng *ret, timestamp *t);
mtime_export str MTIMEtimestamp(timestamp *ret, int *sec);
mtime_export str MTIMEruleDef0(rule *ret, int *m, int *d, int *w, int *h, int *mint);
mtime_export str MTIMEruleDef1(rule *ret, int *m, str *dnme, int *w, int *h, int *mint);
mtime_export str MTIMEruleDef2(rule *ret, int *m, str *dnme, int *w, int *mint);
mtime_export str MTIMEcurrent_timestamp(timestamp *t);
mtime_export str MTIMEcurrent_date(date *d);
mtime_export str MTIMEcurrent_time(daytime *t);
mtime_export int date_fromstr(str buf, int *len, date **d);
mtime_export int date_tostr(str *buf, int *len, date *val);
mtime_export int daytime_fromstr(str buf, int *len, daytime **ret);
mtime_export int daytime_tostr(str *buf, int *len, daytime *val);
mtime_export int timestamp_fromstr(str buf, int *len, timestamp **ret);
mtime_export int timestamp_tostr(str *buf, int *len, timestamp *val);
mtime_export int tzone_fromstr(str buf, int *len, tzone **d);
mtime_export int tzone_tostr(str *buf, int *len, tzone *z);
mtime_export int rule_fromstr(str buf, int *len, rule **d);
mtime_export int rule_tostr(str *buf, int *len, rule *r);
mtime_export int tzone_fromstr(str buf, int *len, tzone **d);

mtime_export int TYPE_date;
mtime_export int TYPE_daytime;
mtime_export int TYPE_timestamp;
mtime_export int TYPE_tzone;
mtime_export int TYPE_rule;

@+ Defines
@c
str MONTHS[13] = { NULL, "january", "february", "march", "april", "may", "june",
	"july", "august", "september", "october", "november", "december"
};
str DAYS[8] = { NULL, "sunday", "monday", "tuesday", "wednesday", "thursday",
	"friday", "saturday"
};
str COUNT1[7] = { NULL, "first", "second", "third", "fourth", "fifth", "last" };
str COUNT2[7] = { NULL, "1st", "2nd", "3rd", "4th", "5th", "last" };
int NODAYS[13] = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

date DATE_MAX, DATE_MIN;	/* often used dates; computed once */

#define YEAR_MAX	5867411
#define YEAR_MIN	-YEAR_MAX
#define MONTHDAYS(m,y)	(((m)!=2)?NODAYS[m]:leapyear(y)?29:28)
#define YEARDAYS(y)	(leapyear(y)?366:365)
#define LEAPYEARS(y)	(leapyears(y)+((y)>=0))
#define DATE(d,m,y)	((m)>0&&(m)<=12&&(d)>0&&(y)!=0&&(y)>=YEAR_MIN&&(y)<=YEAR_MAX&&(d)<=MONTHDAYS(m,y))
#define TIME(h,m,s,x)	((h)>=0&&(h)<24&&(m)>=0&&(m)<60&&(s)>=0&&(s)<60&&(x)>=0 &&(x)<1000)
#define LOWER(c)	(((c) >= 'A' && (c) <= 'Z') ? (c)+'a'-'A' : (c))

@+ auxiliary functions
@c

#define tz_isnil(z)   (get_offset(&(z)) == get_offset(tz_nilptr))
#define ts_isnil(t)   ((t).days == ts_nilptr->days && (t).msecs == ts_nilptr->msecs)

static union {
	timestamp ts;
	lng nilval;
} ts_nil;
static union {
	tzone tz;
	lng nilval;
} tz_nil;
static timestamp *ts_nilptr = NULL;
static tzone *tz_nilptr = NULL;

static void date_prelude(void);

int TYPE_date;
int TYPE_daytime;
int TYPE_timestamp;
int TYPE_tzone;
int TYPE_rule;

bat *
monettime_prelude(void)
{
	ts_nil.nilval = lng_nil;
	tz_nil.nilval = lng_nil;

	ts_nilptr = &ts_nil.ts;
	tz_nilptr = &tz_nil.tz;

	TYPE_date = ATOMindex("date");
	TYPE_daytime = ATOMindex("daytime");
	TYPE_timestamp = ATOMindex("timestamp");
	TYPE_tzone = ATOMindex("timezone");
	TYPE_rule = ATOMindex("rule");
	date_prelude();
	return NULL;
}

void
monettime_epilogue(void)
{
}

timestamp *
timestamp_null(void)
{
	return (ts_nilptr);
}

tzone *
tzone_null(void)
{
	return (tz_nilptr);
}

static int synonyms = TRUE;

int
monettime_synonyms(bit *allow)
{
	if (*allow != bit_nil)
		synonyms = *allow;
	return GDK_SUCCEED;
}

static INLINE int
leapyear(int year)
{
	return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
}

static INLINE int
leapyears(int year)
{
	/* count the 4-fold years that passed since jan-1-0 */
	int y4 = year / 4;

	/* count the 100-fold years */
	int y100 = year / 100;

	/* count the 400-fold years */
	int y400 = year / 400;

	return y4 + y400 - y100;	/* may be negative */
}

static INLINE date
todate(int day, int month, int year)
{
	date n = date_nil;

	if (DATE(day, month, year)) {
		if (year < 0)
			year++;	/* HACK: hide year 0 */
		for (n = (date) (day - 1); --month > 0; n += MONTHDAYS(month, year))
			;
		/* current year does not count as leapyear */
		n += 365 * year + LEAPYEARS(year >= 0 ? year - 1 : year);
	}
	return n;
}

void
fromdate(int n, int *d, int *m, int *y)
{
	int month, year = n / 365;
	int day = (n - year * 365) - LEAPYEARS(year >= 0 ? year - 1 : year);

	if (n < 0) {
		year--;
		while (day >= 0) {
			year++;
			day -= YEARDAYS(year);
		}
		day = YEARDAYS(year) + day;
	} else {
		while (day < 0) {
			year--;
			day += YEARDAYS(year);
		}
	}
	day++;
	for (month = 1; month <= 12; month++) {
		int days = MONTHDAYS(month, year);

		if (day <= days)
			break;
		day -= days;
	}
	if (n != int_nil) {
		*d = day;
		*m = month;
		*y = (year <= 0) ? year - 1 : year;	/* HACK: hide year 0 */
	} else {
		*d = *m = *y = int_nil;
	}
}

static INLINE daytime
totime(int hour, int min, int sec, int msec)
{
	if (TIME(hour, min, sec, msec)) {
		return (daytime) (((((hour * 60) + min) * 60) + sec) * 1000 + msec);
	}
	return daytime_nil;
}

void
fromtime(int n, int *hour, int *min, int *sec, int *msec)
{
	if (n != int_nil) {
		*hour = n / 3600000;
		n -= (*hour) * 3600000;
		*min = n / 60000;
		n -= (*min) * 60000;
		*sec = n / 1000;
		n -= (*sec) * 1000;
		*msec = n;
	} else {
		*hour = *min = *sec = *msec = int_nil;
	}
}

/* matches regardless of case and extra spaces */
static INLINE int
fleximatch(str s, str pat, int min)
{
	int hit, spacy = 0;

	if (min == 0) {
		min = (int) strlen(pat);	/* default mininum required hits */
	}
	for (hit = 0; *pat; s++, hit++) {
		if (LOWER(*s) != *pat) {
			if (GDKisspace(*s) && spacy) {
				min++;
				continue;	/* extra spaces */
			}
			break;
		}
		spacy = GDKisspace(*pat);
		pat++;
	}
	return (hit >= min) ? hit : 0;
}

static INLINE int
parse_substr(int *ret, str s, int min, str list[], int size)
{
	int j = 0, i = 0;

	*ret = int_nil;
	while (++i <= size) {
		if ((j = fleximatch(s, list[i], min)) > 0) {
			*ret = i;
			break;
		}
	}
	return j;
}

static INLINE int
date_dayofweek(date v)
{
	v %= 7;
	return (v <= 0) ? v + 7 : v;
}

#define SKIP_DAYS(d,w,i) d += i; w = (w + i)%7; if (w <= 0) w += 7;

static INLINE date
compute_rule(rule *val, int y)
{
	int m = val->s.month, cnt = ABS(val->s.day - DAY_ZERO);
	date d = todate(1, m, y);
	int dayofweek = date_dayofweek(d);
	int w = ABS(val->s.weekday - WEEKDAY_ZERO);

	if (val->s.weekday == WEEKDAY_ZERO) {
		/* cnt-th of month */
		d += cnt - 1;
	} else if (val->s.day > DAY_ZERO) {
		if (val->s.weekday < WEEKDAY_ZERO) {
			/* first weekday on or after cnt-th of month */
			SKIP_DAYS(d, dayofweek, cnt - 1);
			cnt = 1;
		}		/* ELSE cnt-th weekday of month */
		while (dayofweek != w || --cnt > 0) {
			if (++dayofweek == 8)
				dayofweek = 1;
			d++;
		}
	} else {
		if (val->s.weekday > WEEKDAY_ZERO) {
			/* cnt-last weekday from end of month */
			SKIP_DAYS(d, dayofweek, MONTHDAYS(m, y) - 1);
		} else {
			/* first weekday on or before cnt-th of month */
			SKIP_DAYS(d, dayofweek, cnt - 1);
			cnt = 1;
		}
		while (dayofweek != w || --cnt > 0) {
			if (--dayofweek == 0)
				dayofweek = 7;
			d--;
		}
	}
	return d;
}

static int dummy;

#define BEFORE(d1,m1,d2,m2) (d1 < d2 || (d1 == d2 && m1 <= m2))

int timestamp_add(timestamp *ret, timestamp *v, lng *msecs);
static INLINE int
timestamp_inside(timestamp *ret, timestamp *t, tzone *z, lng offset)
{
	/* starts with GMT time t, and returns whether it is in the DST for z */
	lng add = (offset != (lng) 0) ? offset : (get_offset(z)) * (lng) 60000;
	int start_days, start_msecs, end_days, end_msecs, year;
	rule start, end;

	timestamp_add(ret, t, &add);

	if (ts_isnil(*ret) || z->dst == 0) {
		return 0;
	}
	set_rule(start, z->dst_start);
	set_rule(end, z->dst_end);

	start_msecs = start.s.minutes * 60000;
	end_msecs = end.s.minutes * 60000;

	fromdate((int) ret->days, &dummy, &dummy, &year);
	start_days = compute_rule(&start, year);
	end_days = compute_rule(&end, year);

	return BEFORE(start_days, start_msecs, end_days, end_msecs) ? (BEFORE(start_days, start_msecs, ret->days, ret->msecs) && 
		BEFORE(ret->days, ret->msecs, end_days, end_msecs)) : (BEFORE(start_days, start_msecs, ret->days, ret->msecs) || 
		BEFORE(ret->days, ret->msecs, end_days, end_msecs));
}


@+ ADT implementations
@- date
@c
int
date_fromstr(str buf, int *len, date **d)
{
	int day = 0, month = int_nil, year = 0, yearneg = (buf[0] == '-'), yearlast = 0, pos = 0, sep;
	if (*len < (int) sizeof(date)) {
		if (*d)
			GDKfree(*d);
		*d = (date *) GDKmalloc(*len = sizeof(date));
	}
	**d = date_nil;
	if (yearneg == 0 && !GDKisdigit(buf[0])) {
		if (synonyms == 0)
			return 0;
		yearlast = 1;
		sep = ' ';
	} else {
		for (pos = yearneg; GDKisdigit(buf[pos]); pos++) {
			year = (buf[pos] - '0') + year * 10;
			if (year > YEAR_MAX)
				break;
		}
		sep = buf[pos++];
		if (synonyms == 0 && sep != '-') {
			return 0;
		}
		sep = LOWER(sep);
		if (sep >= 'a' && sep <= 'z') {
			sep = 0;
		} else if (sep == ' ') {
			while (buf[pos] == ' ')
				pos++;
		} else if (sep != '-' && sep != '/' && sep != '\\') {
			return 0;	/* syntax error */
		}
	}
	if (GDKisdigit(buf[pos])) {
		month = buf[pos++] - '0';
		if (GDKisdigit(buf[pos])) {
			month = (buf[pos++] - '0') + month * 10;
		}
	} else if (synonyms == 0) {
		return 0;
	} else {
		pos += parse_substr(&month, buf + pos, 3, MONTHS, 12);
	}
	if (month == int_nil || (sep && buf[pos++] != sep)) {
		return 0;	/* syntax error */
	}
	if (sep == ' ') {
		while (buf[pos] == ' ')
			pos++;
	}
	if (!GDKisdigit(buf[pos])) {
		return 0;	/* syntax error */
	}
	while (GDKisdigit(buf[pos])) {
		day = (buf[pos++] - '0') + day * 10;
		if (day > 31)
			break;
	}
	if (yearlast && buf[pos] == ',') {
		while (buf[++pos] == ' ')
			;
		if (buf[pos] == '-') {
			yearneg = 1;
			pos++;
		}
		while (GDKisdigit(buf[pos])) {
			year = (buf[pos++] - '0') + year * 10;
			if (year > YEAR_MAX)
				break;
		}
	}
	/* handle semantic error here (returns nil in that case) */
	**d = todate(day, month, yearneg ? -year : year);
	return pos;
}

int
date_tostr(str *buf, int *len, date *val)
{
	int day, month, year;

	fromdate((int) *val, &day, &month, &year);
	/* longest possible string: "-5867411-01-01" i.e. 14 chars
	   without NUL (see definition of YEAR_MIN/YEAR_MAX above) */
	if (*len < 15) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 15);
	}
	if (*val == date_nil || !DATE(day, month, year)) {
		strcpy(*buf, "nil");
		return 3;
	}
	sprintf(*buf, "%d-%02d-%02d", year, month, day);
	return (int) strlen(*buf);
}

@- daytime
@c
int
daytime_fromstr(str buf, int *len, daytime **ret)
{
	int hour, min, sec = 0, msec = 0, pos = 0;

	if (*len < (int) sizeof(daytime)) {
		if (*ret)
			GDKfree(*ret);
		*ret = (daytime *) GDKmalloc(*len = sizeof(daytime));
	}
	**ret = daytime_nil;
	if (!GDKisdigit(buf[pos])) {
		return 0;	/* syntax error */
	}
	for (hour = 0; GDKisdigit(buf[pos]); pos++) {
		if (hour <= 24)
			hour = (buf[pos] - '0') + hour * 10;
	}
	if ((buf[pos++] != ':') || !GDKisdigit(buf[pos])) {
		return 0;	/* syntax error */
	}
	for (min = 0; GDKisdigit(buf[pos]); pos++) {
		if (min <= 60)
			min = (buf[pos] - '0') + min * 10;
	}
	if ((buf[pos] == ':') && GDKisdigit(buf[pos + 1])) {
		for (pos++, sec = 0; GDKisdigit(buf[pos]); pos++) {
			if (sec <= 60)
				sec = (buf[pos] - '0') + sec * 10;
		}
		if ((buf[pos] == '.' || (synonyms && buf[pos] == ':')) && GDKisdigit(buf[pos + 1])) {
			int fac = 100;

			for (pos++, msec = 0; GDKisdigit(buf[pos]); pos++) {
				msec += (buf[pos] - '0') * fac;
				fac /= 10;
			}
		}
	}
	/* handle semantic error here (returns nil in that case) */
	**ret = totime(hour, min, sec, msec);
	return pos;
}

int
daytime_tz_fromstr(str buf, int *len, daytime **ret)
{
	str s = buf;
	int pos = daytime_fromstr(s, len, ret);
	lng val, offset = 0;
	daytime mtime = 24 * 60 * 60 * 1000;

	if (!*ret || **ret == daytime_nil)
		return pos;

	s = buf + pos;
	pos = 0;
	while (GDKisspace(*s))
		s++;
	/* incase of gmt we need to add the time zone */
	if (fleximatch(s, "gmt", 0) == 3) {
		s += 3;
	}
	if ((s[0] == '-' || s[0] == '+') && GDKisdigit(s[1]) && GDKisdigit(s[2]) && GDKisdigit(s[pos = 4]) && ((s[3] == ':' && GDKisdigit(s[5])) || GDKisdigit(s[pos = 3]))) {
		offset = (((s[1] - '0') * (lng) 10 + (s[2] - '0')) * (lng) 60 + (s[pos] - '0') * (lng) 10 + (s[pos + 1] - '0')) * (lng) 60000;
		pos++;
		if (s[0] != '-')
			offset = -offset;
		s += pos;
	} else {
		/* if no tzone is specified; work with the local */
		offset = get_offset(&tzone_local) * (lng) -60000;
	}
	val = **ret + offset;
	if (val < 0)
		val = mtime + val;
	if (val >= mtime)
		val = val - mtime;
	**ret = (daytime) val;
	return (int) (s - buf);
}

int
daytime_tostr(str *buf, int *len, daytime *val)
{
	int hour, min, sec, msec;

	fromtime((int) *val, &hour, &min, &sec, &msec);
	if (*len < 12) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 13);
	}
	if (*val == daytime_nil || !TIME(hour, min, sec, msec)) {
		strcpy(*buf, "nil");
		return 3;
	}
	sprintf(*buf, "%02d:%02d:%02d.%03d", hour, min, sec, msec);
	return 12;
}

@- timestamp
@c
int
timestamp_fromstr(str buf, int *len, timestamp **ret)
{
	str s = buf;
	int pos;
	date *d;
	daytime *t;

	if (*len < (int) sizeof(timestamp)) {
		if (*ret)
			GDKfree(*ret);
		*ret = (timestamp *) GDKmalloc(*len = sizeof(timestamp));
	}
	d = &(*ret)->days;
	t = &(*ret)->msecs;
	s += date_fromstr(buf, len, &d);
	if (s > buf && (*(s) == '@' || *s == ' ' || *s == '-')) {
		while (*(++s) == ' ')
			;
		pos = daytime_fromstr(s, len, &t);
		s = pos ? s + pos : buf;
	} else {
		(*ret)->msecs = daytime_nil;
	}
	if (s <= buf || (*ret)->days == date_nil || (*ret)->msecs == daytime_nil) {
		**ret = *ts_nilptr;
	} else {
		lng offset = 0;

		while (GDKisspace(*s))
			s++;
		/* incase of gmt we need to add the time zone */
		if (fleximatch(s, "gmt", 0) == 3) {
			s += 3;
		}
		if ((s[0] == '-' || s[0] == '+') && GDKisdigit(s[1]) && GDKisdigit(s[2]) && GDKisdigit(s[pos = 4]) && ((s[3] == ':' && GDKisdigit(s[5])) || GDKisdigit(s[pos = 3]))) {
			offset = (((s[1] - '0') * (lng) 10 + (s[2] - '0')) * (lng) 60 + (s[pos] - '0') * (lng) 10 + (s[pos + 1] - '0')) * (lng) 60000;
			pos++;
			if (s[0] != '-')
				offset = -offset;
			s += pos;
		} else {
			/* if no tzone is specified; work with the local */
			timestamp tmp = **ret;

			offset = get_offset(&tzone_local) * (lng) -60000;
			if (timestamp_inside(&tmp, &tmp, &tzone_local, (lng) -3600000)) {
				**ret = tmp;
			}
		}
		timestamp_add(*ret, *ret, &offset);
	}
	return (int) (s - buf);
}

int
timestamp_tostr(str *buf, int *len, timestamp *val)
{
	int len1, len2, big = 128, off = get_offset(&tzone_local);
	char buf1[128], buf2[128], *s, *s1 = buf1, *s2 = buf2;
	timestamp tmp = *val;

	if (!ts_isnil(tmp) && timestamp_inside(&tmp, val, &tzone_local, (lng) 0)) {
		lng add = (lng) 3600000;

		timestamp_add(&tmp, &tmp, &add);
		off += 60;
	}
	len1 = date_tostr(&s1, &big, &tmp.days);
	len2 = daytime_tostr(&s2, &big, &tmp.msecs);

	if (*len < 2 + len1 + len2) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1 + len2 + 2);
	}
	s = *buf;
	if (ts_isnil(tmp)) {
		strcpy(s, "nil");
		return 3;
	}
	strcpy(s, buf1);
	s += len1;
	*s++ = ' ';
	strcpy(s, buf2);
	s += len2;
/* omit GMT distance in order not to cinfuse the confused user
	strcpy(s, "GMT"); s += 3;
	if (off) {
		*s++ = (off>=0)?'+':'-';
		sprintf(s, "%02d%02d", ABS(off)/60, ABS(off)%60);
		s += 4;
	}
 */
	return (int) (s - *buf);
}

str
count1(int i)
{
	static char buf[16];

	if (i <= 0) {
		return "(illegal number)";
	} else if (i < 6) {
		return COUNT1[i];
	}
	sprintf(buf, "%dth", i);
	return buf;
}

@- rule
@c
int
rule_tostr(str *buf, int *len, rule *r)
{
	int hours = r->s.minutes / 60;
	int minutes = r->s.minutes % 60;

	if (*len < 64) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 64);
	}
	if (r->asint == int_nil) {
		strcpy(*buf, "nil");
	} else if (r->s.weekday == WEEKDAY_ZERO) {
		sprintf(*buf, "%s %d\@%02d:%02d", MONTHS[r->s.month], r->s.day - DAY_ZERO, hours, minutes);
	} else if (r->s.weekday > WEEKDAY_ZERO && r->s.day > DAY_ZERO) {
		sprintf(*buf, "%s %s from start of %s\@%02d:%02d", count1(r->s.day - DAY_ZERO), DAYS[r->s.weekday - WEEKDAY_ZERO], MONTHS[r->s.month], hours, minutes);
	} else if (r->s.weekday > WEEKDAY_ZERO && r->s.day < DAY_ZERO) {
		sprintf(*buf, "%s %s from end of %s\@%02d:%02d", count1(DAY_ZERO - r->s.day), DAYS[r->s.weekday - WEEKDAY_ZERO], MONTHS[r->s.month], hours, minutes);
	} else if (r->s.day > DAY_ZERO) {
		sprintf(*buf, "first %s on or after %s %d\@%02d:%02d", DAYS[WEEKDAY_ZERO - r->s.weekday], MONTHS[r->s.month], r->s.day - DAY_ZERO, hours, minutes);
	} else {
		sprintf(*buf, "last %s on or before %s %d\@%02d:%02d", DAYS[WEEKDAY_ZERO - r->s.weekday], MONTHS[r->s.month], DAY_ZERO - r->s.day, hours, minutes);
	}
	return (int) strlen(*buf);
}

int
rule_fromstr(str buf, int *len, rule **d)
{
	int day = 0, month = 0, weekday = 0, hours = 0, minutes = 0;
	int neg_day = 0, neg_weekday = 0, pos;
	str cur = buf;

	if (*len < (int) sizeof(rule)) {
		if (*d)
			GDKfree(*d);
		*d = (rule *) GDKmalloc(*len = sizeof(rule));
	}
	(*d)->asint = int_nil;

	/* start parsing something like "first", "second", .. etc */
	pos = parse_substr(&day, cur, 0, COUNT1, 6);
	if (pos == 0) {
		pos = parse_substr(&day, cur, 0, COUNT2, 6);
	}
	if (pos && cur[pos++] == ' ') {
		/* now we must see a weekday */
		cur += pos;
		cur += parse_substr(&weekday, cur, 3, DAYS, 7);
		if (weekday == int_nil) {
			return 0;	/* syntax error */
		}
		pos = fleximatch(cur, " from start of ", 0);
		if (pos == 0) {
			pos = fleximatch(cur, " from end of ", 0);
			if (pos)
				neg_day = 1;
		}
		if (pos && day < 6) {
			/* RULE 1+2: X-th weekday from start/end of month */
			pos = parse_substr(&month, cur += pos, 3, MONTHS, 12);
		} else if (day == 1) {
			/* RULE 3: first weekday on or after-th of month */
			pos = fleximatch(cur, " on or after ", 0);
			neg_weekday = 1;
			day = int_nil;	/* re-read below */
		} else if (day == 6) {
			/* RULE 4: last weekday on or before X-th of month */
			pos = fleximatch(cur, " on or before ", 0);
			neg_weekday = neg_day = 1;
			day = int_nil;	/* re-read below */
		}
		if (pos == 0) {
			return 0;	/* syntax error */
		}
		cur += pos;
	}
	if (day == int_nil) {
		/* RULE 5:  X-th of month */
		cur += parse_substr(&month, cur, 3, MONTHS, 12);
		if (month == int_nil || *cur++ != ' ' || !GDKisdigit(*cur)) {
			return 0;	/* syntax error */
		}
		day = 0;
		while (GDKisdigit(*cur) && day < 31) {
			day = (*(cur++) - '0') + day * 10;
		}
	}

	/* parse hours:minutes */
	if (*cur++ != '\@' || !GDKisdigit(*cur)) {
		return 0;	/* syntax error */
	}
	while (GDKisdigit(*cur) && hours < 24) {
		hours = (*(cur++) - '0') + hours * 10;
	}
	if (*cur++ != ':' || !GDKisdigit(*cur)) {
		return 0;	/* syntax error */
	}
	while (GDKisdigit(*cur) && minutes < 60) {
		minutes = (*(cur++) - '0') + minutes * 10;
	}

	/* assign if semantically ok */
	if (day >= 1 && day <= NODAYS[month] && hours >= 0 && hours < 60 && minutes >= 0 && minutes < 60) {
		(*d)->s.month = month;
		(*d)->s.weekday = WEEKDAY_ZERO + (neg_weekday ? -weekday : weekday);
		(*d)->s.day = DAY_ZERO + (neg_day ? -day : day);
		(*d)->s.minutes = hours * 60 + minutes;
	}
	return (int) (cur - buf);
}

@- tzone
@c
int
tzone_fromstr(str buf, int *len, tzone **d)
{
	int hours = 0, minutes = 0, neg_offset = 0, pos = 0;
	rule r1, *rp1 = &r1, r2, *rp2 = &r2;
	str cur = buf;

	rp1->asint = rp2->asint = 0;
	if (*len < (int) sizeof(tzone)) {
		if (*d)
			GDKfree(*d);
		*d = (tzone *) GDKmalloc(*len = sizeof(tzone));
	}
	**d = *tz_nilptr;

	/* syntax checks */
	if (fleximatch(cur, "gmt", 0) == 0) {
		return 0;	/* syntax error */
	}
	cur += 3;
	if (*cur == '-' || *cur == '+') {
		str bak = cur + 1;

		neg_offset = (*cur++ == '-');
		if (!GDKisdigit(*cur)) {
			return 0;	/* syntax error */
		}
		while (GDKisdigit(*cur) && hours < 9999) {
			hours = (*(cur++) - '0') + hours * 10;
		}
		if (*cur == ':' && GDKisdigit(cur[1])) {
			cur++;
			do {
				minutes = (*(cur++) - '0') + minutes * 10;
			} while (GDKisdigit(*cur) && minutes < 60);
		} else if (*cur != ':' && (cur - bak) == 4) {
			minutes = hours % 100;
			hours = hours / 100;
		} else {
			return 0;	/* syntax error */
		}
	}
	if (fleximatch(cur, "-dst[", 0)) {
		pos = rule_fromstr(cur += 5, len, &rp1);
		if (pos == 0 || cur[pos++] != ',') {
			return 0;	/* syntax error */
		}
		pos = rule_fromstr(cur += pos, len, &rp2);
		if (pos == 0 || cur[pos++] != ']') {
			return 0;	/* syntax error */
		}
		cur += pos;
	}
	/* semantic check */
	if (hours < 24 && minutes < 60 && rp1->asint != int_nil && rp2->asint != int_nil) {
		minutes += hours * 60;
		set_offset(*d, neg_offset ? -minutes : minutes);
		if (pos) {
			(*d)->dst = TRUE;
			(*d)->dst_start = get_rule(r1);
			(*d)->dst_end = get_rule(r2);
		} else {
			(*d)->dst = FALSE;
		}
	}
	return (int) (cur - buf);
}

int
tzone_tostr(str *buf, int *len, tzone *z)
{
	str s;

	if (*len < 160) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 160);
	}
	s = *buf;
	if (tz_isnil(*z)) {
		strcpy(s, "nil");
		s += 3;
	} else {
		rule dst_start, dst_end;
		int mins = get_offset(z);

		set_rule(dst_start, z->dst_start);
		set_rule(dst_end, z->dst_end);

		strcpy(*buf, "GMT");
		s += 3;
		if (mins > 0) {
			sprintf(s, "+%02d:%02d", mins / 60, mins % 60);
			s += 6;
		} else if (mins < 0) {
			sprintf(s, "-%02d:%02d", (-mins) / 60, (-mins) % 60);
			s += 6;
		}
		if (z->dst) {
			strcpy(s, "-DST[");
			s += 5;
			s += rule_tostr(&s, len, &dst_start);
			*s++ = ',';
			s += rule_tostr(&s, len, &dst_end);
			*s++ = ']';
			*s = 0;
		}
	}
	return (int) (s - *buf);
}

@+ operator implementations
@c
static void
date_prelude(void)
{
	MONTHS[0] = (str)str_nil;
	DAYS[0] = (str)str_nil;
	NODAYS[0] = int_nil;
	DATE_MAX = todate(31, 12, YEAR_MAX);
	DATE_MIN = todate(1, 1, YEAR_MIN);
	tzone_local.dst = 0;
	set_offset(&tzone_local, 0);
}

int
oldduration(int *ndays, str s)
{
	int year = 0, month = 0, day = 0;
	int hour = 0 /*, min=0 */ ;
	char *snew = s;
	int v = 0;

	while (*snew != '\0') {
		if (GDKisdigit(*snew)) {
			v = 0;
			while (GDKisdigit(*snew)) {
				v = v * 10 + (*snew) - '0';
				snew++;
			}
		} else if (isupper((int) (*snew)) || islower((int) (*snew))) {
			switch (*snew++) {
			case 'y':
			case 'Y':
				year = v;
				v = 0;
				break;
			case 'm':
			case 'M':
				if (month || day || hour)	/*min = v */
					;
				else
					month = v;
				v = 0;
				break;
			case 'd':
			case 'D':
				day = v;
				v = 0;
				break;
			case 'h':
			case 'H':
				hour = v;
				v = 0;
				break;
			case 's':
			case 'S':
				v = 0;
				break;
			default:	/* GDKerror("duration_fromstr: wrong duration '%s'!\n",s); */
				*ndays = int_nil;
				return GDK_SUCCEED;
			}
		} else {
			snew++;
		}
	}
	*ndays = year * 365 + month * 30 + day;
	return GDK_SUCCEED;
}

int
olddate(date *d, str buf)
{
	int day = 0, month, year, yearneg = (buf[0] == '-'), pos = yearneg;

	*d = date_nil;
	if (!GDKisdigit(buf[pos])) {
		return GDK_FAIL;	/* syntax error */
	}
	for (year = 0; GDKisdigit(buf[pos]); pos++) {
		year = (buf[pos] - '0') + year * 10;
		if (year > YEAR_MAX)
			break;
	}
	pos += parse_substr(&month, buf + pos, 3, MONTHS, 12);
	if (month == int_nil) {
		return GDK_FAIL;	/* syntax error */
	}
	if (!GDKisdigit(buf[pos])) {
		return GDK_FAIL;	/* syntax error */
	}
	while (GDKisdigit(buf[pos])) {
		day = (buf[pos] - '0') + day * 10;
		pos++;
		if (day > 31)
			break;
	}
	/* handle semantic error here (returns nil in that case) */
	*d = todate(day, month, yearneg ? -year : year);
	return GDK_SUCCEED;
}

int
tzone_set_local(tzone *z)
{
	tzone_local = *z;
	return GDK_SUCCEED;
}

int
tzone_get_local(tzone *z)
{
	*z = tzone_local;
	return GDK_SUCCEED;
}

/* Returns month number [1-12] from a string (or nil if does not match any). */
int
month_from_str(int *ret, str month)
{
	parse_substr(ret, month, 3, MONTHS, 12);
	return GDK_SUCCEED;
}

/* Returns month name from a number between [1-7], str(nil) otherwise. */
int
month_to_str(str *ret, int *month)
{
	*ret = GDKstrdup(MONTHS[(*month < 1 || *month > 12) ? 0 : *month]);
	return GDK_SUCCEED;
}

/* Returns number of day [1-7] from a string (or nil if does not match any). */
int
day_from_str(int *ret, str day)
{
	parse_substr(ret, day, 3, DAYS, 7);
	return GDK_SUCCEED;
}

/* Returns day name from a number between [1-7], str(nil) otherwise. */
int
day_to_str(str *ret, int *day)
{
	*ret = GDKstrdup(DAYS[(*day < 1 || *day > 7) ? 0 : *day]);
	return GDK_SUCCEED;
}

/* creates a date from (day,month,year) parameters */
int
date_create(date *ret, int *year, int *month, int *day)
{
	*ret = todate(*day, *month, *year);
	return GDK_SUCCEED;
}

/* creates a daytime from (hours,minutes,seconds,milliseconds) parameters */
int
daytime_create(daytime *ret, int *hour, int *min, int *sec, int *msec)
{
	*ret = totime(*hour, *min, *sec, *msec);
	return GDK_SUCCEED;
}

/* creates a timestamp from (date,daytime) parameters */
int
timestamp_create(timestamp *ret, date *d, daytime *t, tzone *z)
{
	if (*d == date_nil || *t == daytime_nil || tz_isnil(*z)) {
		*ret = *ts_nilptr;
	} else {
		lng add = get_offset(z) * (lng) -60000;

		ret->days = *d;
		ret->msecs = *t;
		if (z->dst) {
			timestamp tmp;

			if (timestamp_inside(&tmp, ret, z, (lng) -3600000)) {
				*ret = tmp;
			}
		}
		timestamp_add(ret, ret, &add);
	}
	return GDK_SUCCEED;
}

int
timestamp_create_default(timestamp *ret, date *d, daytime *t)
{
	return timestamp_create(ret, d, t, &tzone_local);
}

int
timestamp_create_from_date(timestamp *ret, date *d)
{
	daytime t = totime(0,0,0,0);
	return timestamp_create(ret, d, &t, &tzone_local);
}

/* extracts year from date (value between -5867411 and +5867411). */
int
date_extract_year(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		fromdate((int) *v, &dummy, &dummy, ret);
	}
	return GDK_SUCCEED;
}

/* extracts month from date (value between 1 and 12) */
int
date_extract_month(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		fromdate((int) *v, &dummy, ret, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts day from date (value between 1 and 31)*/
int
date_extract_day(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		fromdate((int) *v, ret, &dummy, &dummy);
	}
	return GDK_SUCCEED;
}

/* Returns N where d is the Nth day of the year (january 1 returns 1). */
int
date_extract_dayofyear(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		int year;

		fromdate((int) *v, &dummy, &dummy, &year);
		*ret = (int) (1 + *v - todate(1, 1, year));
	}
	return GDK_SUCCEED;
}

/* Returns the week number */
int
date_extract_weekofyear(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		int year, dayofweek;
		date year_jan_1;

		fromdate((int) *v, &dummy, &dummy, &year);
		dayofweek = date_dayofweek(year_jan_1 = todate(1, 1, year));

		if (dayofweek <= 4) {
			/* week of jan 1 belongs to this year */
			*ret = (int) (1 + (*v - year_jan_1 + dayofweek - 1) / 7);
		} else if (*v - year_jan_1 > 7 - dayofweek) {
			/* week of jan 1 belongs to last year; but this is a later week */
			*ret = (int) ((*v - year_jan_1 + dayofweek - 1) / 7);
		} else {
			/* recurse to get last weekno of previous year (it is 52 or 53) */
			date lastyear_dec_31 = todate(31, 12, (year == 1) ? -1 : year - 1);

			return date_extract_weekofyear(ret, &lastyear_dec_31);
		}
	}
	return GDK_SUCCEED;
}

/* Returns the current day  of the week where 1=monday, .., 7=sunday */
int
date_extract_dayofweek(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		*ret = date_dayofweek(*v);
	}
	return GDK_SUCCEED;
}

/* extracts hour from daytime (value between 0 and 23) */
int
daytime_extract_hours(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, ret, &dummy, &dummy, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts minutes from daytime (value between 0 and 59) */
int
daytime_extract_minutes(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, &dummy, ret, &dummy, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts seconds from daytime (value between 0 and 59) */
int
daytime_extract_seconds(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, &dummy, &dummy, ret, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts milliseconds from daytime (value between 0 and 999) */
int
daytime_extract_milliseconds(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, &dummy, &dummy, &dummy, ret);
	}
	return GDK_SUCCEED;
}

int
daytime_add(daytime *ret, daytime *v, lng *msec)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		*ret = *v + (daytime) (*msec);
	}
	return GDK_SUCCEED;
}

/* extracts daytime from timestamp */
int
timestamp_extract_daytime(daytime *ret, timestamp *t, tzone *z)
{
	if (ts_isnil(*t) || tz_isnil(*z)) {
		*ret = daytime_nil;
	} else {
		timestamp tmp;

		if (timestamp_inside(&tmp, t, z, (lng) 0)) {
			lng add = (lng) 3600000;

			timestamp_add(&tmp, &tmp, &add);
		}
		if (ts_isnil(tmp)) {
			*ret = daytime_nil;
		} else {
			*ret = tmp.msecs;
		}
	}
	return GDK_SUCCEED;
}

int
timestamp_extract_daytime_default(daytime *ret, timestamp *t)
{
	return timestamp_extract_daytime(ret, t, &tzone_local);
}

/* extracts date from timestamp */
int
timestamp_extract_date(date *ret, timestamp *t, tzone *z)
{
	if (ts_isnil(*t) || tz_isnil(*z)) {
		*ret = date_nil;
	} else {
		timestamp tmp;

		if (timestamp_inside(&tmp, t, z, (lng) 0)) {
			lng add = (lng) 3600000;

			timestamp_add(&tmp, &tmp, &add);
		}
		if (ts_isnil(tmp)) {
			*ret = date_nil;
		} else {
			*ret = tmp.days;
		}
	}
	return GDK_SUCCEED;
}

int
timestamp_extract_date_default(date *ret, timestamp *t)
{
	return timestamp_extract_date(ret, t, &tzone_local);
}

int date_adddays(date *ret, date *v, int *delta);

/* returns the date that comes a number of years after 'v' (or before iff *delta < 0). */
int
date_addyears(date *ret, date *v, int *delta)
{
	if (*v == date_nil || *delta == int_nil) {
		*ret = date_nil;
	} else {
		int d, m, y, x, z = *delta;

		fromdate((int) *v, &d, &m, &y);
		if (m >= 3) {
			y++;
		}
		*ret = *v;
		while (z > 0) {
			x = YEARDAYS(y);
			date_adddays(ret, ret, &x);
			z--;
			y++;
		}
		while (z < 0) {
			z++;
			y--;
			x = -YEARDAYS(y);
			date_adddays(ret, ret, &x);
		}
	}
	return GDK_SUCCEED;
}

/* returns the date that comes a number of months after 'v' (or before iff *delta < 0). */
int
date_addmonths(date *ret, date *v, int *delta)
{
	if (*v == date_nil || *delta == int_nil) {
		*ret = date_nil;
	} else {
		int d, m, y, x, z = *delta;

		fromdate((int) *v, &d, &m, &y);
		*ret = *v;
		while (z > 0) {
			z--;
			x = MONTHDAYS(m, y);
			if (++m == 13)
				m = 1;
			date_adddays(ret, ret, &x);
		}
		while (z < 0) {
			z++;
			if (--m == 0)
				m = 12;
			x = -MONTHDAYS(m, y);
			date_adddays(ret, ret, &x);
		}
	}
	return GDK_SUCCEED;
}

/* returns the date that comes a number of day after 'v' (or before iff *delta < 0). */
int
date_adddays(date *ret, date *v, int *delta)
{
	lng min = DATE_MIN, max = DATE_MAX;
	lng cur = (lng) *v, inc = *delta;

	if (cur == int_nil || inc == int_nil || (inc > 0 && (max - cur) < inc) || (inc < 0 && (min - cur) > inc)) {
		*ret = date_nil;
	} else {
		*ret = *v + *delta;
	}
	return GDK_SUCCEED;
}




/* returns the number of days between 'val1' and 'val2'. */
int
date_diff(int *ret, date *v1, date *v2)
{
	if (*v1 == date_nil || *v2 == date_nil) {
		*ret = int_nil;
	} else {
		*ret = (int) (*v1 - *v2);
	}
	return GDK_SUCCEED;
}

/* returns the timestamp that comes 'milliseconds' after 'value'. */
int
timestamp_add(timestamp *ret, timestamp *v, lng *msecs)
{
	if (!ts_isnil(*v) && *msecs != lng_nil) {
		int days = (int) (*msecs / (24 * 60 * 60 * 1000));

		ret->msecs = (int) (v->msecs + (*msecs - ((lng) days) * (24 * 60 * 60 * 1000)));
		ret->days = v->days;
		if (ret->msecs >= (24 * 60 * 60 * 1000)) {
			days++;
			ret->msecs -= (24 * 60 * 60 * 1000);
		} else if (ret->msecs < 0) {
			days--;
			ret->msecs += (24 * 60 * 60 * 1000);
		}
		if (days) {
			date_adddays(&ret->days, &ret->days, &days);
			if (ret->days == int_nil) {
				*ret = *ts_nilptr;
			}
		}
	} else {
		*ret = *ts_nilptr;
	}
	return GDK_SUCCEED;
}


/* returns the number of milliseconds between 'val1' and 'val2'. */
int
timestamp_diff(lng *ret, timestamp *v1, timestamp *v2)
{
	if (ts_isnil(*v1) || ts_isnil(*v2)) {
		*ret = lng_nil;
	} else {
		*ret = ((lng) (v1->days - v2->days)) * ((lng) 24 * 60 * 60 * 1000) + ((lng) (v1->msecs - v2->msecs));
	}
	return GDK_SUCCEED;
}


/* return whether DST holds in the tzone at a certain point of time. */
int
timestamp_inside_dst(bit *ret, timestamp *p, tzone *z)
{
	*ret = FALSE;

	if (tz_isnil(*z)) {
		*ret = bit_nil;
	} else if (z->dst) {
		timestamp tmp;

		if (timestamp_inside(&tmp, p, z, (lng) 0)) {
			*ret = TRUE;
		}
	}
	return GDK_SUCCEED;
}

/* create a DST start/end date rule. */
int
rule_create(rule *ret, int *month, int *day, int *weekday, int *minutes)
{
	ret->asint = int_nil;
	if (*month >= 1 && *month <= 12 && ABS(*weekday) <= 7 && *minutes >= 0 && *minutes < 24 * 60 && ABS(*day) >= 1 && ABS(*day) <= NODAYS[*month] && (*weekday || *day > 0)) {
		ret->s.month = *month;
		ret->s.day = DAY_ZERO + *day;
		ret->s.weekday = WEEKDAY_ZERO + *weekday;
		ret->s.minutes = *minutes;
	}
	return GDK_SUCCEED;
}

/* create a tzone as a simple hour difference from GMT. */
int
tzone_create_dst(tzone *ret, int *minutes, rule *start, rule *end)
{
	*ret = *tz_nilptr;
	if (*minutes != int_nil && ABS(*minutes) < 24 * 60 && start->asint != int_nil && end->asint != int_nil) {
		set_offset(ret, *minutes);
		ret->dst = TRUE;
		ret->dst_start = get_rule(*start);
		ret->dst_end = get_rule(*end);
	}
	return GDK_SUCCEED;
}

/* create a tzone as an hour difference from GMT and a DST. */
int
tzone_create(tzone *ret, int *minutes)
{
	*ret = *tz_nilptr;
	if (*minutes != int_nil && ABS(*minutes) < 24 * 60) {
		set_offset(ret, *minutes);
		ret->dst = FALSE;
	}
	return GDK_SUCCEED;
}

/* extract month from rule. */
int
rule_extract_month(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.month;
	return GDK_SUCCEED;
}

/* extract day from rule. */
int
rule_extract_day(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.day - DAY_ZERO;
	return GDK_SUCCEED;
}

/* extract weekday from rule. */
int
rule_extract_weekday(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.weekday - WEEKDAY_ZERO;
	return GDK_SUCCEED;
}

/* extract minutes from rule. */
int
rule_extract_minutes(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.minutes;
	return GDK_SUCCEED;
}

/* extract rule that determines start of DST from tzone. */
int
tzone_extract_start(rule *ret, tzone *t)
{
	if (tz_isnil(*t) || !t->dst) {
		ret->asint = int_nil;
	} else {
		set_rule(*ret, t->dst_start);
	}
	return GDK_SUCCEED;
}

/* extract rule that determines end of DST from tzone. */
int
tzone_extract_end(rule *ret, tzone *t)
{
	if (tz_isnil(*t) || !t->dst) {
		ret->asint = int_nil;
	} else {
		set_rule(*ret, t->dst_end);
	}
	return GDK_SUCCEED;
}

/* extract number of minutes that tzone is offset wrt GMT. */
int
tzone_extract_minutes(int *ret, tzone *t)
{
	*ret = (tz_isnil(*t)) ? int_nil : get_offset(t);
	return GDK_SUCCEED;
}

int
date_sub_sec_interval_wrap(date *ret, date *t, int *sec)
{
	if (*sec > 0) {
		int delta = -1 * *sec / 86400;

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}
int
date_sub_sec_interval_lng_wrap(date *ret, date *t, lng *sec)
{
	if (*sec > 0) {
		int delta = -1 * *sec / 86400;

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}

int
date_add_sec_interval_wrap(date *ret, date *t, int *sec)
{
	if (*sec > 0) {
		int delta = *sec / 86400;

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}
int
date_add_sec_interval_lng_wrap(date *ret, date *t, lng *sec)
{
	if (*sec > 0) {
		int delta = *sec / 86400;

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}

int
date_sub_month_interval_wrap(date *ret, date *t, int *months)
{
	return date_addmonths(ret, t, months);
}

/* compute the date from a rule in a certain year. */
int
compute_rule_foryear(date *ret, rule *val, int *year)
{
	if (*(int *) val == int_nil || *year < YEAR_MIN || *year > YEAR_MAX) {
		*ret = date_nil;
	} else {
		*ret = compute_rule(val, *year);
	}
	return GDK_SUCCEED;
}

@= compare
int @1_comp_@2(bit *retval, @1 *val1, @1 *val2)
{
	if (*val1 == @1_nil || *val2 == @1_nil)
		*retval = bit_nil;
	else
		*retval = *val1 @3 *val2;
	return GDK_SUCCEED;
}
@c
@:compare(date,EQ,==)@
@:compare(date,NE,!=)@
@:compare(date,LT,<)@
@:compare(date,GT,>)@
@:compare(date,LE,<=)@
@:compare(date,GE,>=)@
@:compare(daytime,EQ,==)@
@:compare(daytime,NE,!=)@
@:compare(daytime,LT,<)@
@:compare(daytime,GT,>)@
@:compare(daytime,LE,<=)@
@:compare(daytime,GE,>=)@

int
timestamp_isnil(bit *retval, timestamp *val)
{
	*retval = ts_isnil(*val);
	return GDK_SUCCEED;
}

int
timestamp_comp_EQ(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days == val2->days && val1->msecs == val2->msecs;
	return GDK_SUCCEED;
}

int
timestamp_comp_NE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days != val2->days || val1->msecs != val2->msecs;
	return GDK_SUCCEED;
}

int
timestamp_comp_LT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs < val2->msecs);
	return GDK_SUCCEED;
}

int
timestamp_comp_LE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs <= val2->msecs);
	return GDK_SUCCEED;
}

int
timestamp_comp_GT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs > val2->msecs);
	return GDK_SUCCEED;
}

int
timestamp_comp_GE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs >= val2->msecs);
	return GDK_SUCCEED;
}

int
CMDmsec(lng *r)
{
#ifdef HAVE_GETTIMEOFDAY
        struct timeval tp;

        gettimeofday(&tp, NULL);
        *r = ((lng) (tp.tv_sec)) * LL_CONSTANT(1000) + (lng) tp.tv_usec / LL_CONSTANT(1000);
#else
#ifdef HAVE_FTIME
        struct timeb tb;

        ftime(&tb);
        *r = ((lng) (tb.time)) * LL_CONSTANT(1000) + ((lng) tb.millitm);
#endif
#endif
	return GDK_SUCCEED;
}

union lng_tzone {
	lng lval;
	tzone tzval;
};

@- Wrapper
The Monet V5 API interface is defined here
@= TIMEZONES
	ticks = @2;
	tzone_create(&(ltz.tzval), &ticks);
	vr.val.lval = ltz.lval;
	tzbat = BUNins(tzbat,@1,&vr.val.lval,FALSE);
@= TIMEZONES2
	ticks = @2;
	tzone_create_dst(&(ltz.tzval), &ticks,&@3,&@4);
	vr.val.lval = ltz.lval;
	tzbat = BUNins(tzbat,@1,&vr.val.lval,FALSE);
@-
Include BAT macros
@c
#include "mal.h"
#include "mal_exception.h"
#include <mal_box.h>
@-
@= coerce
str MTIME@1_2@2(@2 *ret,@1 *src){
	*ret= *src;
	return MAL_SUCCEED;
}
@c
@:coerce(date,lng)@
@:coerce(daytime,lng)@

str
MTIMEnil2date(date *ret, int *src)
{
	(void) src;
	*ret = date_nil;
	return MAL_SUCCEED;
}

str
MTIMEdate2date(date *ret, date *src)
{
	*ret = *src;
	return MAL_SUCCEED;
}
str
MTIMEdaytime2daytime(daytime *ret, daytime *src)
{
	*ret = *src;
	return MAL_SUCCEED;
}

str
MTIMEtimestamp2timestamp(timestamp *ret, timestamp *src)
{
	*ret = *src;
	return MAL_SUCCEED;
}

@-
The comparison implementations are relatively straightforward.
@= compareDef
mtime_export str MTIME@3_@1(bit *ret, @3 *v, @3 *w);
@= compareImpl
str MTIME@3_@1(bit *ret, @3 *v, @3 *w){
	    if( *v== @3_nil || *w== @3_nil)
	            *ret= bit_nil;
	    else    *ret = *v @2 *w;
	return MAL_SUCCEED;
}
@= compareDefAll
mtime_export str MTIME@1_isnil(bit *ret, @1 *v);
	    @:compareDef(EQ,==,@1)@
	    @:compareDef(NEQ,!=,@1)@
	    @:compareDef(LT,<,@1)@
	    @:compareDef(LE,<=,@1)@
	    @:compareDef(GT,>,@1)@
	    @:compareDef(GE,>=,@1)@
@= compareAll
str MTIME@1_isnil(bit *ret, @1 *v){
	*ret= *v == @1_nil;
	return MAL_SUCCEED;
}
	    @:compareImpl(EQ,==,@1)@
	    @:compareImpl(NEQ,!=,@1)@
	    @:compareImpl(LT,<,@1)@
	    @:compareImpl(LE,<=,@1)@
	    @:compareImpl(GT,>,@1)@
	    @:compareImpl(GE,>=,@1)@
@h
@:compareDefAll(date)@
@:compareDefAll(daytime)@

#endif /* _MONETTIME_H_ */
@c
@:compareAll(date)@
@:compareAll(daytime)@


static BAT *timezones = NULL;

str
MTIMEprelude()
{
	char *msg = NULL;
	Box box;
	ValRecord vr;
	int ticks;
	union lng_tzone ltz;
	rule RULE_MAR, RULE_OCT;
	str s1 = "first sunday from end of march@02:00";
	str s2 = "first sunday from end of october@02:00";
	tzone tz;

	monettime_prelude();
	tz = *tz_nilptr; /* to ensure initialized variables */

	/* here we should initialize the time box as well */
	box = openBox("time");
	if (box == 0)
		return throwMessage("time.prelude", "failed to open box");
	/* if the box was already filled we can skip initialization */
	if (box->sym->vtop == 0) {
		BAT *tzbat = BATnew(TYPE_str, ATOMindex("timezone"), 30);

		if (tzbat == NULL)
			return throwMessage("time.prelude", "failed to create box");
		BBPrename(tzbat->batCacheid, "timezones");
		timezones = tzbat;
		newVariable(box->sym, GDKstrdup("timezones"), newBatType(TYPE_str, ATOMindex("timezone")));
		if (bindBAT(box, "timezones", "timezones")) {
			return throwMessage("time.prelude", "could not bind timezones");
		}
		vr.vtype = ATOMindex("timezone");
		@:TIMEZONES("Wake Island", 12 * 60)@
		@:TIMEZONES("Melbourne/Australia", 11 * 60)@
		@:TIMEZONES("Brisbane/Australia", 10 * 60)@
		@:TIMEZONES("Japan", 9 * 60)@
		@:TIMEZONES("Singapore", 8 * 60)@
		@:TIMEZONES("Thailand", 7 * 60)@
		@:TIMEZONES("Pakistan", 5 * 60)@
		@:TIMEZONES("United Arab Emirates", 4 * 60)@
		@:TIMEZONES("GMT", 0 * 0)@
		@:TIMEZONES("Azore Islands", -1 * 60)@
		@:TIMEZONES("Hawaii/USA", -10 * 60)@
		@:TIMEZONES("American Samoa", -11 * 60)@
		MTIMErule_fromstr(&RULE_MAR, &s1);
		MTIMErule_fromstr(&RULE_OCT, &s2);
		@:TIMEZONES2("Kazakhstan", 6 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Moscow/Russia", 3 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("East/Europe", 2 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("West/Europe", 1 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("UK", 0 * 0, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Eastern/Brazil", -2 * 60, RULE_OCT, RULE_MAR)@
		@:TIMEZONES2("Western/Brazil", -3 * 60, RULE_OCT, RULE_MAR)@
		@:TIMEZONES2("Andes/Brazil", -4 * 60, RULE_OCT, RULE_MAR)@
		@:TIMEZONES2("East/USA", -5 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Central/USA", -6 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Mountain/USA", -7 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Alaska/USA", -9 * 60, RULE_MAR, RULE_OCT)@
	}
	msg = "West/Europe";
	if ((msg = MTIMEtimezone(&tz, &msg)) != MAL_SUCCEED)
		return msg;
	tzone_set_local(&tz);
	return MAL_SUCCEED;
}


str
MTIMEepilogue()
{
	closeBox("time", 0);
	return MAL_SUCCEED;
}

str
MTIMEsynonyms(bit *allow)
{
	monettime_synonyms(allow);
	return MAL_SUCCEED;
}

str
MTIMEoldduration(int *ndays, str *s)
{
	oldduration(ndays, *s);
	return MAL_SUCCEED;
}

str
MTIMEolddate(date *d, str *buf)
{
	olddate(d, *buf);
	return MAL_SUCCEED;
}

str
MTIMEtimezone(tzone *z, str *name)
{
	BUN p;
	str s = *name;

	if (BUNfnd(timezones, s) == 0)
		s = "GMT";
	if ((p = BUNfnd(timezones, s)) != NULL){
		z = (tzone*)BUNtail(timezones,p);
		tzone_set_local(z);
	}
	return MAL_SUCCEED;
}

str
MTIMEtzone_set_local(int res, tzone *z)
{
	(void) res;		/* fool compilers */
	tzone_set_local(z);
	return MAL_SUCCEED;
}

str
MTIMEtzone_get_local(tzone *z)
{
	tzone_get_local(z);
	return MAL_SUCCEED;
}

str 
MTIMElocal_timezone(lng *res)
{
	tzone z;

	tzone_get_local(&z);
	*res = get_offset((&z));
	return MAL_SUCCEED;
}

str
MTIMEmonth_from_str(int *ret, str *month)
{
	month_from_str(ret, *month);
	return MAL_SUCCEED;
}

str
MTIMEmonth_to_str(str *ret, int *month)
{
	month_to_str(ret, month);
	return MAL_SUCCEED;
}

str
MTIMEday_from_str(int *ret, str *day)
{
	day_from_str(ret, *day);
	return MAL_SUCCEED;
}

str
MTIMEday_to_str(str *ret, int *day)
{
	day_to_str(ret, day);
	return MAL_SUCCEED;
}

str
MTIMEdate_date(date *d, date *s)
{
	*d = *s;
	return MAL_SUCCEED;
}

str
MTIMEdate_tostr(str *ret, date *d)
{
	int big = 128;
	char buf[128], *s1 = buf;

	*s1 = 0;
	date_tostr(&s1, &big, d);
	*ret = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMEdate_fromstr(date *ret, str *s)
{
	int len = 0;
	date *d = 0;

	date_fromstr(*s, &len, &d);
	*ret = *d;
	return MAL_SUCCEED;
}

str
MTIMEdate_create(date *ret, int *year, int *month, int *day)
{
	date_create(ret, year, month, day);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_tostr(str *ret, daytime *d)
{
	char buf[128], *s = buf;
	int len = 128;

	*s = 0;
	daytime_tostr(&s, &len, d);
	*ret = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_create(daytime *ret, int *hour, int *min, int *sec, int *msec)
{
	daytime_create(ret, hour, min, sec, msec);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_tostr(str *s, timestamp *d)
{
	char buf[128], *s1 = buf;
	int len = 128;

	*s1 = 0;
	timestamp_tostr(&s1, &len, d);
	*s = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_fromstr(timestamp *ret, str *d)
{
	int len = strlen(*d);

	timestamp_fromstr(*d, &len, &ret);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_timestamp(timestamp *d, timestamp *s)
{
	*d = *s;
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_create(timestamp *ret, date *d, daytime *t, tzone *z)
{
	timestamp_create(ret, d, t, z);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_create_default(timestamp *ret, date *d, daytime *t)
{
	return MTIMEtimestamp_create(ret, d, t, &tzone_local);
}

str
MTIMEtimestamp_create_from_date(timestamp *ret, date *d)
{
	daytime t = totime(0,0,0,0);
	return MTIMEtimestamp_create(ret, d, &t, &tzone_local);
}

str
MTIMEdate_extract_year(int *ret, date *v)
{
	date_extract_year(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_month(int *ret, date *v)
{
	date_extract_month(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_day(int *ret, date *v)
{
	date_extract_day(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_dayofyear(int *ret, date *v)
{
	date_extract_dayofyear(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_weekofyear(int *ret, date *v)
{
	date_extract_weekofyear(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_dayofweek(int *ret, date *v)
{
	date_extract_dayofweek(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_extract_hours(int *ret, daytime *v)
{
	daytime_extract_hours(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_extract_minutes(int *ret, daytime *v)
{
	daytime_extract_minutes(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_extract_seconds(int *ret, daytime *v)
{
	daytime_extract_seconds(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_extract_milliseconds(int *ret, daytime *v)
{
	daytime_extract_milliseconds(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_extract_daytime(daytime *ret, timestamp *t, tzone *z)
{
	timestamp_extract_daytime(ret, t, z);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_extract_daytime_default(daytime *ret, timestamp *t)
{
	return MTIMEtimestamp_extract_daytime(ret, t, &tzone_local);
}

str
MTIMEtimestamp_extract_date(date *ret, timestamp *t, tzone *z)
{
	timestamp_extract_date(ret, t, z);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_extract_date_default(date *ret, timestamp *t)
{
	return MTIMEtimestamp_extract_date(ret, t, &tzone_local);
}

str
MTIMEdate_addyears(date *ret, date *v, int *delta)
{
	date_addyears(ret, v, delta);
	return MAL_SUCCEED;
}

str
MTIMEdate_adddays(date *ret, date *v, int *delta)
{
	date_adddays(ret, v, delta);
	return MAL_SUCCEED;
}

str
MTIMEdate_addmonths(date *ret, date *v, int *delta)
{
	date_addmonths(ret, v, delta);
	return MAL_SUCCEED;
}

str
MTIMEdate_diff(int *ret, date *v1, date *v2)
{
	date_diff(ret, v1, v2);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_add(timestamp *ret, timestamp *v, lng *msecs)
{
	timestamp_add(ret, v, msecs);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_diff(lng *ret, timestamp *v1, timestamp *v2)
{
	timestamp_diff(ret, v1, v2);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_inside_dst(bit *ret, timestamp *p, tzone *z)
{
	timestamp_inside_dst(ret, p, z);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_isnil(bit *retval, timestamp *val)
{
	*retval = ts_isnil(*val);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_EQ(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days == val2->days && val1->msecs == val2->msecs;
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_NEQ(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days != val2->days || val1->msecs != val2->msecs;
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_LT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs < val2->msecs);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_LE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs <= val2->msecs);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_GT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs > val2->msecs);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_GE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs >= val2->msecs);
	return MAL_SUCCEED;
}

str
MTIMErule_tostr(str *s, rule *r)
{
	char buf[128], *s1 = buf;
	int len = 128;

	*s1 = 0;
	rule_tostr(&s1, &len, r);
	*s = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMErule_fromstr(rule *ret, str *s)
{
	int len = 0;
	rule *d = 0;

	rule_fromstr(*s, &len, &d);
	*ret = *d;
	GDKfree(d);
	return MAL_SUCCEED;
}

str
MTIMErule_create(rule *ret, int *month, int *day, int *weekday, int *minutes)
{
	rule_create(ret, month, day, weekday, minutes);
	return MAL_SUCCEED;
}

str
MTIMEtzone_create_dst(tzone *ret, int *minutes, rule *start, rule *end)
{
	tzone_create_dst(ret, minutes, start, end);
	return MAL_SUCCEED;
}

str
MTIMEtzone_create(tzone *ret, int *minutes)
{
	tzone_create(ret, minutes);
	return MAL_SUCCEED;
}

str
MTIMErule_extract_month(int *ret, rule *r)
{
	rule_extract_month(ret, r);
	return MAL_SUCCEED;
}

str
MTIMErule_extract_day(int *ret, rule *r)
{
	rule_extract_day(ret, r);
	return MAL_SUCCEED;
}

str
MTIMErule_extract_weekday(int *ret, rule *r)
{
	rule_extract_weekday(ret, r);
	return MAL_SUCCEED;
}

str
MTIMErule_extract_minutes(int *ret, rule *r)
{
	rule_extract_minutes(ret, r);
	return MAL_SUCCEED;
}

str
MTIMEtzone_extract_start(rule *ret, tzone *t)
{
	tzone_extract_start(ret, t);
	return MAL_SUCCEED;
}

str
MTIMEtzone_extract_end(rule *ret, tzone *t)
{
	tzone_extract_end(ret, t);
	return MAL_SUCCEED;
}

str
MTIMEtzone_extract_minutes(int *ret, tzone *t)
{
	tzone_extract_minutes(ret, t);
	return MAL_SUCCEED;
}

str
MTIMEdate_sub_sec_interval_wrap(date *ret, date *t, int *sec)
{
	date_sub_sec_interval_wrap(ret, t, sec);
	return MAL_SUCCEED;
}
str
MTIMEdate_sub_sec_interval_lng_wrap(date *ret, date *t, lng *sec)
{
	date_sub_sec_interval_lng_wrap(ret, t, sec);
	return MAL_SUCCEED;
}

str
MTIMEdate_add_sec_interval_wrap(date *ret, date *t, int *sec)
{
	date_add_sec_interval_wrap(ret, t, sec);
	return MAL_SUCCEED;
}
str
MTIMEdate_add_sec_interval_lng_wrap(date *ret, date *t, lng *sec)
{
	date_add_sec_interval_lng_wrap(ret, t, sec);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_add_sec_interval_lng_wrap(timestamp *ret, timestamp *t, lng *sec)
{
	lng msec= *sec *1000;
	timestamp_add(ret, t, &msec);
	return MAL_SUCCEED;
}
str
MTIMEtimestamp_sub_sec_interval_lng_wrap(timestamp *ret, timestamp *t, lng *sec)
{
	lng msec= *sec * -1000;
	timestamp_add(ret, t, &msec);
	return MAL_SUCCEED;
}
str
MTIMEtimestamp_add_month_interval_wrap(timestamp *ret, timestamp *v, int *months)
{
	daytime t;
	date d;
	timestamp_extract_daytime(&t, v, &tzone_local);
	timestamp_extract_date(&d, v, &tzone_local);
	date_addmonths(&d, &d, months);
	timestamp_create(ret, &d, &t, &tzone_local);
	return MAL_SUCCEED;
}
str
MTIMEtimestamp_sub_month_interval_wrap(timestamp *ret, timestamp *v, int *months)
{
	daytime t;
	date d;
	int m = 0 - *months;
	timestamp_extract_daytime(&t, v, &tzone_local);
	timestamp_extract_date(&d, v, &tzone_local);
	date_addmonths(&d, &d, &m);
	timestamp_create(ret, &d, &t, &tzone_local);
	return MAL_SUCCEED;
}

str
MTIMEtime_add_sec_interval_wrap(daytime *ret, daytime *t, lng *seconds)
{
	lng s= 1000 * *seconds;
	daytime_add(ret, t, &s);
	return MAL_SUCCEED;
}
str
MTIMEtime_sub_sec_interval_wrap(daytime *ret, daytime *t, lng *seconds)
{
	lng s= -1000 * *seconds;
	daytime_add(ret, t, &s);
	return MAL_SUCCEED;
}

str
MTIMEdate_add_month_interval_wrap(date *ret, date *t, int *months)
{
	return MTIMEdate_addmonths(ret, t, months);
}

str
MTIMEcompute_rule_foryear(date *ret, rule *val, int *year)
{
	compute_rule_foryear(ret, val, year);
	return MAL_SUCCEED;
}

str
MTIMEtzone_tostr(str *s, tzone *ret)
{
	char buf[128], *s1 = buf;
	int len = 128;

	*s1 = 0;
	tzone_tostr(&s1, &len, ret);
	*s = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMEtzone_fromstr(tzone *ret, str *s)
{
	int len = 0;
	tzone *d = 0;

	tzone_fromstr(*s, &len, &d);
	*ret = *d;
	return MAL_SUCCEED;
}

str
MTIMEdaytime_fromstr(daytime *ret, str *s)
{
	int len = 0;
	daytime *d = 0;

	daytime_fromstr(*s, &len, &d);
	*ret = *d;
	return MAL_SUCCEED;
}

@-
The utilities from Monet V4
@c
str
MTIMEmsecs(lng *ret, int *d, int *h, int *m, int *s, int *ms)
{
	*ret = ((lng) *ms) + 1000 * (*s + 60 * (*m + 60 * (*h + 24 * *d)));
	return MAL_SUCCEED;
}

str
MTIMEdaytime1(daytime *ret, int *h)
{
	int m = 0, s = 0, ms = 0;

	daytime_create(ret, h, &m, &s, &ms);
	return MAL_SUCCEED;
}

str
MTIMEsecs2daytime(daytime *ret, lng *s)
{
	*ret = (daytime)((*s)*1000);
	return MAL_SUCCEED;
}

str
MTIMEdaytime2(daytime *ret, int *h, int *m)
{
	int s = 0, ms = 0;

	daytime_create(ret, h, m, &s, &ms);
	return MAL_SUCCEED;
}

str
MTIMEdaytime3(daytime *ret, int *h, int *m, int *s)
{
	int ms = 0;

	daytime_create(ret, h, m, s, &ms);
	return MAL_SUCCEED;
}

str
MTIMEunix_epoch(timestamp *ret)
{
	date d0 = todate(1, 1, 1970);
	int zero = 0;
	str s = "GMT";
	daytime d1;
	tzone d2;

	daytime_create(&d1, &zero, &zero, &zero, &zero);
	MTIMEtzone_fromstr(&d2, &s);
	timestamp_create(ret, &d0, &d1, &d2);
	return MAL_SUCCEED;
}

str
MTIMEepoch(timestamp *ret)
{
	timestamp ts;
	lng t = ((lng) time(0)) * 1000;
	str e;

	/* convert number of seconds into a timestamp */
	if ((e = MTIMEunix_epoch(&ts)) == MAL_SUCCEED)
			e = MTIMEtimestamp_add(ret, &ts, &t);
	return (e);
}

str
MTIMEepoch2lng(lng *ret, timestamp *t)
{
	timestamp e;
	lng v;

	MTIMEunix_epoch(&e);
	timestamp_diff(&v, &e, t);
	*ret = v / 1000;
	return MAL_SUCCEED;
}

str
MTIMEtimestamp(timestamp *ret, int *sec)
{
	timestamp e;
	lng l = *sec * 1000;

	MTIMEunix_epoch(&e);
	timestamp_add(ret, &e, &l);
	return MAL_SUCCEED;
}

str
MTIMEruleDef0(rule *ret, int *m, int *d, int *w, int *h, int *mint)
{
	int d0 = 60 * *h;
	int d1 = d0 + *mint;

	rule_create(ret, m, d, w, &d1);
	return MAL_SUCCEED;
}

str
MTIMEruleDef1(rule *ret, int *m, str *dnme, int *w, int *h, int *mint)
{
	int d;
	int d0 = 60 * *h;
	int d1 = d0 + *mint;

	day_from_str(&d, *dnme);
	rule_create(ret, m, &d, w, &d1);
	return MAL_SUCCEED;
}

str
MTIMEruleDef2(rule *ret, int *m, str *dnme, int *w, int *mint)
{
	int d;

	day_from_str(&d, *dnme);
	rule_create(ret, m, &d, w, mint);
	return MAL_SUCCEED;
}

str
MTIMEcurrent_timestamp(timestamp *t)
{
	MTIMEepoch(t);
	return MAL_SUCCEED;
}

str
MTIMEcurrent_date(date *d)
{
	timestamp stamp;

	MTIMEcurrent_timestamp(&stamp);
	MTIMEtimestamp_extract_date_default(d, &stamp);
	return MAL_SUCCEED;
}

str
MTIMEcurrent_time(daytime *t)
{
	timestamp stamp;

	MTIMEcurrent_timestamp(&stamp);
	MTIMEtimestamp_extract_daytime_default(t, &stamp);
	return MAL_SUCCEED;
}
/* more SQL extraction utilities */
str
MTIMEtimestamp_year(int *ret, timestamp *t)
{
	date d;
	timestamp_extract_date(&d, t, &tzone_local);
	date_extract_year(ret, &d);
	return MAL_SUCCEED;
}
str
MTIMEtimestamp_month(int *ret, timestamp *t)
{
	date d;
	timestamp_extract_date(&d, t, &tzone_local);
	date_extract_month(ret, &d);
	return MAL_SUCCEED;
}
str
MTIMEtimestamp_day(int *ret, timestamp *t)
{
	date d;
	timestamp_extract_date(&d, t, &tzone_local);
	date_extract_day(ret, &d);
	return MAL_SUCCEED;
}
str
MTIMEtimestamp_hours(int *ret, timestamp *t)
{
	daytime d;
	timestamp_extract_daytime(&d, t, &tzone_local);
	daytime_extract_hours(ret, &d);
	return MAL_SUCCEED;
}
str
MTIMEtimestamp_minutes(int *ret, timestamp *t)
{
	daytime d;
	timestamp_extract_daytime(&d, t, &tzone_local);
	daytime_extract_minutes(ret, &d);
	return MAL_SUCCEED;
}
str
MTIMEtimestamp_seconds(int *ret, timestamp *t)
{
	daytime d;
	timestamp_extract_daytime(&d, t, &tzone_local);
	daytime_extract_seconds(ret, &d);
	return MAL_SUCCEED;
}
str
MTIMEtimestamp_milliseconds(int *ret, timestamp *t)
{
	daytime d;
	timestamp_extract_daytime(&d, t, &tzone_local);
	daytime_extract_milliseconds(ret, &d);
	return MAL_SUCCEED;
}

str
MTIMEsql_year(int *ret, int *t)
{
	*ret= *t/12;
	return MAL_SUCCEED;
}
str
MTIMEsql_month(int *ret, int *t)
{
	*ret= *t%12;
	return MAL_SUCCEED;
}
str
MTIMEsql_day(int *ret, lng *t)
{
	*ret= *t/86400;
	return MAL_SUCCEED;
}
str
MTIMEsql_hours(int *ret, lng *t)
{
	*ret= (*t % 86400)/3600;
	return MAL_SUCCEED;
}
str
MTIMEsql_minutes(int *ret, lng *t)
{
	*ret= (*t %3600)/60;
	return MAL_SUCCEED;
}
str
MTIMEsql_seconds(int *ret, lng *t)
{
	*ret= *t %60;
	return MAL_SUCCEED;
}



@-
The BAT equivalents for these functions provide
speed.
@= Extract
str MTIME@1_extract_@2_bulk(int *ret, int *bid)
{       BAT *b,*bn;
	int s1,xx;
	@3 v;
	date d;
	ptr p1;
	BUN p,q;

	if( (b= BATdescriptor(*bid)) == NULL ){
		 return throwMessage("bbp.get@1", "Cannot access descriptor");
	}


	bn= BATnew(BAThtype(b),TYPE_@3, BATcount(b));

	s1= BUNsize(bn);
	p1= BUNfirst(bn);

	BATloopFast(b,p,q,xx){
		ptr h= BUNhead(b,p);
		d= *(date*) BUNtail(b,p);
		MTIME@1_extract_@2(&v,&d);
		bunfastins_nocheck(bn,p1,h,&v,s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
bunins_failed:
	BBPfix(*ret = bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@c
str
MTIMEmsec(lng *r)
{
	(void)CMDmsec(r);
	return MAL_SUCCEED;
}

@-
@c
@:Extract(date,year,int)@
@:Extract(date,month,int)@
@:Extract(date,day,int)@
@:Extract(daytime,hours,int)@
@:Extract(daytime,minutes,int)@
@:Extract(daytime,seconds,int)@
@:Extract(daytime,milliseconds,int)@
@}
