@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f streams
@a Niels Nes
@* A simple interface to IO streams
All file IO is funneled through the stream library, which
guarantees cross-platform capabilities.
Several protocols are provided, e.g. it can be used to 
open 'non compressed, gzipped, bzipped' data files. 
It encapsulates the corresponding library managed in
.../stream.

@mal
module streams;

atom streams:ptr;

command openReadBytes{unsafe}( filename:str ) :streams
address mnstr_open_rstreamwrap
comment "open a file stream for reading";
command openWriteBytes{unsafe}( filename:str ) :streams
address mnstr_open_wstreamwrap
comment "open a file stream for writing";

command openRead{unsafe}( filename:str ) :streams
address mnstr_open_rastreamwrap
comment "open ascii file stream for reading";
command openWrite{unsafe}( filename:str ) :streams
address mnstr_open_wastreamwrap
comment "open ascii file stream for writing";

command openRead{unsafe}(s:streams):streams
address mnstr_stream_rstreamwrap
comment "convert an ascii stream to binary";
command openWrite{unsafe}(s:streams):streams
address mnstr_stream_wstreamwrap
comment "convert an ascii stream to binary";

command socketReadBytes{unsafe}(skt:int,name:str):streams
address mnstr_socket_rstreamwrap
comment "open a socket stream for reading";
command socketWriteBytes{unsafe}(skt:int,name:str):streams
address mnstr_socket_wstreamwrap
comment "open a socket stream for writing";
command socketRead{unsafe}(skt:int,name:str):streams
address mnstr_socket_rastreamwrap
comment "open ascii socket stream for reading";
command socketWrite{unsafe}(skt:int,name:str):streams
address mnstr_socket_wastreamwrap
comment "open ascii socket stream for writing";

command blocked{unsafe}( s:streams ) :streams
address open_block_streamwrap
comment "open a block based stream";

command writeStr{unsafe}( s:streams, data:str ):void
address mnstr_write_stringwrap
comment "write data on the stream";
command writeInt{unsafe}( s:streams, data:int ):void
address mnstr_writeIntwrap
comment "write data on the stream";
command readStr{unsafe}( s:streams):str
address mnstr_read_stringwrap
comment "read string data from the stream";
command readInt{unsafe}( s:streams):int
address mnstr_readIntwrap
comment "read integer data from the stream";

command flush{unsafe}( s:streams )
address mnstr_flush_streamwrap
comment "flush the stream";

command close{unsafe}( s:streams )
address mnstr_close_streamwrap
comment "close and destroy the stream s";

atom bstream:ptr;
command create{unsafe}(s:streams, bufsize:int):bstream
address bstream_create_wrapwrap
comment "create a buffered stream";

command destroy{unsafe}(s:bstream)
address bstream_destroy_wrapwrap
comment "destroy bstream";

command read{unsafe}(s:bstream,size:int):int
address bstream_read_wrapwrap
comment "read at least size bytes into the buffer of s";

@-
@{
The implementation follows and should be self-documenting
@h
#ifndef _STREAMS_H_
#define _STREAMS_H_

#include <gdk.h>
#include <blob.h>

typedef ptr Stream;
typedef ptr Bstream;

#endif /*_STREAMS_H_*/
@c
#include "mal_config.h"
#include <mal.h>
#include "streams.h"
#include <stdio.h>
#include <stream_socket.h>

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define streams_export extern __declspec(dllimport)
#else
#define streams_export extern __declspec(dllexport)
#endif
#else
#define streams_export extern
#endif

streams_export int mnstr_write_string(Stream *S, str data);
streams_export int mnstr_writeInt_wrap(Stream *S, int *data);
streams_export int mnstr_readInt_wrap(int *data, Stream *S);
streams_export int mnstr_read_string(str *res, Stream *S);
streams_export int mnstr_flush_stream(Stream *S);
streams_export int mnstr_close_stream(Stream *S);
streams_export int open_block_stream(Stream *S, Stream *is);
streams_export int bstream_create_wrap(Bstream *BS, Stream *S, int *bufsize);
streams_export int bstream_destroy_wrap(Bstream *BS);
streams_export int bstream_read_wrap(int *res, Bstream *BS, int *size);
streams_export str mnstr_write_stringwrap(int *ret, Stream *S, str *data);
streams_export str mnstr_writeIntwrap(int *ret, Stream *S, int *data);
streams_export str mnstr_readIntwrap(int *ret, Stream *S);
streams_export str mnstr_read_stringwrap(str *res, Stream *s);
streams_export str mnstr_flush_streamwrap(int *ret, Stream *s);
streams_export str mnstr_close_streamwrap(int *ret, Stream *s);
streams_export str open_block_streamwrap(Stream *S, Stream *is);
streams_export str bstream_create_wrapwrap(Bstream *Bs, Stream *S, int *bufsize);
streams_export str bstream_destroy_wrapwrap(int *ret, Bstream *BS);
streams_export str bstream_read_wrapwrap(int *res, Bstream *BS, int *size);
streams_export str mnstr_readIntwrap(int *ret, Stream *S);
streams_export str mnstr_read_stringwrap(str *res, Stream *s);

@= open_stream
streams_export int mnstr_open_@1(Stream *S, str filename);
int
mnstr_open_@1(Stream *S, str filename)
{
	stream *s;

	if ((s = open_@1( filename )) == NULL || mnstr_errnr(s)) {
		if (s)
			mnstr_destroy(s);
		GDKerror("mnstr_open: could not open file '%s'\n", filename);
		return GDK_FAIL;
	} else {
		*(stream**)S = s;
		return GDK_SUCCEED;
	}
}
@c
@:open_stream(rstream)@
@:open_stream(wstream)@
@:open_stream(rastream)@
@:open_stream(wastream)@

@= mnstr_stream
streams_export int mnstr_stream_@1(Stream *Sout, Stream *Sin);
int
mnstr_stream_@1(Stream *Sout, Stream *Sin)
{
	*(stream**)Sout = mnstr_@1(*(stream**)Sin);
	return GDK_SUCCEED;
}
@c
@:mnstr_stream(rstream)@
@:mnstr_stream(wstream)@

@= open_socket
streams_export int mnstr_socket_@1(Stream *S, int *socket, str name);
int
mnstr_socket_@1(Stream *S, int *socket, str name)
{
	stream *s;

	if ((s = socket_@1( *socket, name )) == NULL || mnstr_errnr(s)) {
		if (s)
			mnstr_destroy(s);
		GDKerror("Could not open socket %s\n", name );
		return GDK_FAIL;
	} else {
		*(stream**)S = s;
		return GDK_SUCCEED;
	}
}
@c
@:open_socket(rstream)@
@:open_socket(wstream)@
@:open_socket(rastream)@
@:open_socket(wastream)@

@c
int
mnstr_write_string(Stream *S, str data)
{
	stream *s = *(stream **) S;

	return mnstr_write(s, data, 1, strlen(data)) < 0 ? GDK_FAIL : GDK_SUCCEED;
}

int
mnstr_writeInt_wrap(Stream *S, int *data)
{
	stream *s = *(stream **) S;

	return mnstr_writeInt(s, *data) ? GDK_SUCCEED : GDK_FAIL;
}

int
mnstr_readInt_wrap(int *data, Stream *S)
{
	stream *s = *(stream **) S;

	return mnstr_readInt(s, data) ? GDK_SUCCEED : GDK_FAIL;
}

#define CHUNK (64*1024)
int
mnstr_read_string(str *res, Stream *S)
{
	stream *s = *(stream **) S;
	ssize_t len = 0;
	size_t size = CHUNK +1;
	char *buf = GDKmalloc(size), *start = buf;

	while ((len = mnstr_read(s, start, 1, CHUNK)) > 0) {
		size += len;
		buf = GDKrealloc(buf, size);
		start = buf + size - CHUNK -1;

		*start = '\0';
	}
	if (len < 0)
		return GDK_FAIL;
	start += len;
	*start = '\0';
	*res = buf;
	return GDK_SUCCEED;
}

int
mnstr_flush_stream(Stream *S)
{
	stream *s = *(stream **) S;

	if (mnstr_flush(s))
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mnstr_close_stream(Stream *S)
{
	close_stream(*(stream **) S);
	return GDK_SUCCEED;
}

int
open_block_stream(Stream *S, Stream *is)
{
	if ((*(stream **) S = block_stream(*(stream **) is)) == NULL) {
		return GDK_FAIL;
	} else {
		return GDK_SUCCEED;
	}
}

int
bstream_create_wrap(Bstream *BS, Stream *S, int *bufsize)
{
	if ((*(bstream **) BS = bstream_create(*(stream **) S, (size_t) * bufsize)) == NULL) {
		return GDK_FAIL;
	} else {
		return GDK_SUCCEED;
	}
}

int
bstream_destroy_wrap(Bstream *BS)
{
	bstream_destroy(*(bstream **) BS);
	return GDK_SUCCEED;
}

int
bstream_read_wrap(int *res, Bstream *BS, int *size)
{
	*res = (int) bstream_read(*(bstream **) BS, (size_t) * size);
	return GDK_SUCCEED;
}

@- Wrapper
The remainder is the version 5 wrapper
@= open_streamwrap
streams_export str mnstr_open_@1wrap( Stream *S, str *filename );
str mnstr_open_@1wrap( Stream *S, str *filename ){
	if( mnstr_open_@1(S, *filename)== GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "streams.open", "Could not open file");
}
@}
@c
#include "mal_exception.h"

@:open_streamwrap(rstream)@
@:open_streamwrap(wstream)@
@:open_streamwrap(rastream)@
@:open_streamwrap(wastream)@

@-
@= mnstr_streamwrap
streams_export str mnstr_stream_@1wrap(Stream *sout, Stream *sin);
str mnstr_stream_@1wrap(Stream *sout, Stream *sin){
	*(stream**)sout = mnstr_@1(*(stream**)sin);
	return MAL_SUCCEED;
}
@c
@:mnstr_streamwrap(rstream)@
@:mnstr_streamwrap(wstream)@
@-
@= open_socketwrap
streams_export str mnstr_socket_@1wrap( Stream *S, int *socket, str *name );
str mnstr_socket_@1wrap( Stream *S, int *socket, str *name ){
	if( mnstr_socket_@1(S,socket,*name) == GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "streams.socket","Could not open socket");
}
@c
@:open_socketwrap(rstream)@
@:open_socketwrap(wstream)@
@:open_socketwrap(rastream)@
@:open_socketwrap(wastream)@

str
mnstr_write_stringwrap(int *ret, Stream *S, str *data)
{
	(void) ret;
	if (mnstr_write_string(S, *data) == GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "streams.writeStr", "Failed to write string");
}

str
mnstr_writeIntwrap(int *ret, Stream *S, int *data)
{
	(void) ret;
	if (mnstr_writeInt_wrap(S, data) == GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "streams.writeInt", "Failed to write int");
}

str
mnstr_readIntwrap(int *ret, Stream *S)
{
	if (mnstr_readInt_wrap(ret, S) == GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "streams.readInt", "Failed to read int");
}

str
mnstr_read_stringwrap(str *res, Stream *s)
{
	if (mnstr_read_string(res, s) == GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "streams.readStr", "Failed to read string");
}

str
mnstr_flush_streamwrap(int *ret, Stream *s)
{
	(void) ret;
	if (mnstr_flush_stream(s) == GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "streams.flush", "Failed to flush a stream");
}

str
mnstr_close_streamwrap(int *ret, Stream *s)
{
	(void) ret;
	if (mnstr_close_stream(s) == GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "streams.close", "Failed to close a stream");
}

str
open_block_streamwrap(Stream *S, Stream *is)
{
	if (open_block_stream(S, is) == GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "bstreams.open", "Failed to open a blocked stream");
}

str
bstream_create_wrapwrap(Bstream *Bs, Stream *S, int *bufsize)
{
	if (bstream_create_wrap(Bs, S, bufsize) == GDK_SUCCEED)
		return MAL_SUCCEED;
	throw(IO, "bstreams.create", "Failed to create a blocked stream");
}

str
bstream_destroy_wrapwrap(int *ret, Bstream *BS)
{
	(void) ret;
	bstream_destroy_wrap(BS);
	return MAL_SUCCEED;
}

str
bstream_read_wrapwrap(int *res, Bstream *BS, int *size)
{
	bstream_read_wrap(res, BS, size);
	return MAL_SUCCEED;
}
