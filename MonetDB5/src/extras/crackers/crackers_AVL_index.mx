@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f crackers_AVL_index
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* AVL Index

Comparison with AVL-tree index

Implement an AVL index on top of a BAT for comparison against cracking


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@


@- Header file

@h
#ifndef _CRACKERS_AVL_INDEX_H_
#define _CRACKERS_AVL_INDEX_H_

/* Exported signatures */
@:TypeSwitch(AVLindexFunctions_decl)@

#endif /* _CRACKERS_AVL_INDEX_H */
@


@- Exported signatures

@= AVLindexFunctions_decl
crackers_export str CRKmakeAVLIndex_@1(int *k, int *bid);
crackers_export str CRKInsertAVLIndex_@1(int *k, int *bid, int *uid);
crackers_export str CRKAVLIndexSelectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKdeleteFromAVL_@1(int *k, int *bid, int *uid);
@


@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

static int maxAVLIndices = 0;

typedef struct {
	int		bid;
	struct Node 	*Tree;	
} AVLIndexNode;

static AVLIndexNode *AVLIndex;

/* Local support functions and macros */

static int
existsAVLIndex(int bid){
        int i;

        for (i = 0; i < maxAVLIndices; i++)
                if (AVLIndex[i].bid == bid)
                        return i;
        return -1;
}


@:NewAVLIndex@
@:TypeSwitch(AVLIndexOperations)@

/* Exported functions */
@:TypeSwitch(AVLindexFunctions_impl)@
@


@- Exported functions

@= AVLindexFunctions_impl
str
CRKmakeAVLIndex_@1(int *k, int *bid){
	BUN last, cur;
	int indexPos;
	oid curPos;
	BAT *b;

	(void) k;
        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.make AVL index", "Cannot access descriptor");

	indexPos = newAVLIndex(*bid);
	cur = BUNfirst(b);
	last = BUNlast(b);
	curPos = 0;
	while (cur < last){
		addAVLIndex_@1(indexPos,curPos,b);
		cur++;
		curPos++;
	}
	
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CRKInsertAVLIndex_@1(int *k, int *bid, int *uid){
	BUN last, cur;
	int indexPos;
	oid curPos;
	BAT *b, *u;

	(void) k;
	indexPos = existsAVLIndex(*bid);
	if (indexPos == -1)	
		throw(MAL, "crackers.insert AVL index", "No AVL index present for this BAT");

        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access descriptor");

        if ((u = BATdescriptor(*uid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access update descriptor");

	cur = BUNfirst(u);
	last = BUNlast(u);
	curPos = BATcount(b)-BATcount(u);
	while (cur < last){
		addAVLIndex_@1(indexPos,curPos,b);
		cur++;
		curPos++;
	}
	
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);
	return MAL_SUCCEED;
}

str
CRKAVLIndexSelectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	BAT *b, *result;
	int indexPos;
	struct Node *cur;
	oid  resSize;
	BUN first; 
	oid *resh;
	@1 *rest;

	indexPos = existsAVLIndex(*bid);
        if (indexPos == -1)
                throw(MAL, "crackers.insert AVL index", "No AVL index present for this BAT");
	
        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access descriptor");

	result = BATnew(TYPE_oid, TYPE_@1, (BUN)(*(@1*)hgh-*(@1*)low)*2);

	/* find the node that we should start searching from */
	cur = AVLIndex[indexPos].Tree;
	first = BUNfirst(b);

	while( cur != NULL ){		
		if (@2_LT(Tloc(b,first+cur->position),low,@3@1))
			cur = cur->right;
		else
			break;
	}

	resSize = 0;
	/*if NULL then result is empty */
	if (cur == NULL){
                BATsetcount(result, 0);
		BBPkeepref(result->batCacheid);
		*vid = result->batCacheid;
		BBPunfix(b->batCacheid);

		return MAL_SUCCEED;
	}

	resh = (oid*)Hloc(result, BUNfirst(result));
	rest = (@1 *)Tloc(result, BUNfirst(result));
	if (@2_EQ(low,Tloc(b,first+cur->position),@3@1) && *inclusiveLow == TRUE){
		while (cur != NULL){
			if (@2_EQ(low,Tloc(b,first+cur->position),@3@1) ){
				if (cur->deleted == FALSE){
					*(oid*)resh = (oid)cur->position;
					*(@1 *)rest = *(@1 *)Tloc(b,first+cur->position);
					resh++; rest++;
					resSize++;
				}
				cur = cur->right;
			}
			else	
				break;
		}
	} else
	if (@2_EQ(low,Tloc(b,first+cur->position),@3@1) && *inclusiveLow == FALSE){
		while( cur != NULL){
			if (@2_EQ(low,Tloc(b,first+cur->position),@3@1))
				cur = cur->right;
			else
				break;
		}
	} 

	if (cur != NULL)       
		resSize = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, resSize, b, first, cur, resh, rest, *(@1*)Tloc(b,first+cur->position));

        BATsetcount(result, resSize);
        BBPkeepref(result->batCacheid);
        *vid = result->batCacheid;
        BBPunfix(b->batCacheid);

	return MAL_SUCCEED;
}
@


@- Local support functions and macros

@= NewAVLIndex
static int
newAVLIndex(int bid){
        int i, freemap = -1, units = 1024;

        for (i = 0; i < maxAVLIndices; i++)
                if (AVLIndex[i].bid == -1)
                        freemap = i;

        if (freemap != -1) {
                AVLIndex[freemap].bid = bid;
                return freemap;
        }

        if (i == maxAVLIndices) {
                AVLIndexNode *x;

                if (maxAVLIndices > 0)
                        units = (int) (1.2 * maxAVLIndices);
                x = (AVLIndexNode *) GDKmalloc(sizeof(AVLIndexNode) * units);
                memset(x, 0, sizeof(AVLIndexNode) * units);
                if (AVLIndex) {
                        fprintf(stderr, "reallocate index \n");
                        memcpy(x, AVLIndex, sizeof(AVLIndexNode) * i);
                        GDKfree(AVLIndex);
                }
                AVLIndex = x;
                maxAVLIndices = units;
        }

        AVLIndex[i].bid = bid;
        AVLIndex[i].Tree = NULL;
        return i;
}
@

@= AVLIndexOperations
static struct Node *
InsertAVLIndex_@1(int m, oid indexPosition, @1 value,  struct Node * current, BAT * b, BUN base){	
	BUN cur, Lchild, Rchild;
	int lh, rh;
	struct Node *temp;
	ptr curValue, LchildValue, RchildValue;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
                current->position = indexPosition;
                current->inclusive = TRUE;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		current->hols = 0;
		current->slice= -1;
		goto end;
        }

	cur = base + current->position;
        curValue = Tloc(b, cur);

        if ( @2_LT(&value,curValue,@3@1) || @2_EQ(&value,curValue,@3@1) ){
		if ( (temp = InsertAVLIndex_@1(m, indexPosition, value,  current->left, b, base)) == NULL )
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + current->left->position;
        		LchildValue = Tloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || @2_EQ(&value,LchildValue,@3@1) )
                        	current = SingleRotateLeft(&(CrackerIndex[m].Tree), current);
                    	else
                        	current = DoubleRotateLeft(&(CrackerIndex[m].Tree), current);
		}
        } else {
		if ( (temp = InsertAVLIndex_@1(m, indexPosition, value, current->right, b, base)) == NULL )
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;


                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + current->right->position;
                        RchildValue = Tloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) )
                        	current = SingleRotateRight(&(CrackerIndex[m].Tree), current);
                    	else
                        	current = DoubleRotateRight(&(CrackerIndex[m].Tree), current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

static void
addAVLIndex_@1(int m,  oid position, BAT * b){
        BUN base;

        if (position == 0){
                AVLIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                AVLIndex[m].Tree->position = position;
                AVLIndex[m].Tree->inclusive = TRUE;
                AVLIndex[m].Tree->height = 0;
                AVLIndex[m].Tree->left = NULL;
                AVLIndex[m].Tree->right = NULL;
                AVLIndex[m].Tree->head = TRUE;
                AVLIndex[m].Tree->deleted = FALSE;
                AVLIndex[m].Tree->previous = NULL;
                AVLIndex[m].Tree->hols = 0;
                AVLIndex[m].Tree->slice= -1;

                return;
        }

        base = BUNfirst(b);
        InsertAVLIndex_@1(m, position, *(@1*)Tloc(b,base+position), AVLIndex[m].Tree, b, base);
}

static oid 
findQualifyingValuesAVLIndex_@1(@1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, oid resSize, BAT *b, BUN first, struct Node * cur, oid *resh, @1 *rest, @1 prevL){
	oid *rh = resh;
	@1  *rt = rest;
	oid size = resSize;
	
	@1 value = *(@1*)Tloc(b,first+cur->position);
	if (cur->deleted == FALSE){
		if ( (@2_GT(&value,low,@3@1) && @2_LT(&value,hgh,@3@1)) ||
		     (@2_EQ(&value,low,@3@1) && *inclusiveLow == TRUE) ||	
		     (@2_EQ(&value,hgh,@3@1) && *inclusiveHgh == TRUE) ){
			*(oid*)rh = (oid)cur->position;
       	         	*(@1 *)rt = *(@1*)Tloc(b,first+cur->position);
	       	        rh++; 
			rt++;
        	        size++;	
		}
	}

	if (cur->left != NULL &&  @2_GT(&value,low,@3@1) && @2_LT(&prevL,hgh,@3@1) )
		size = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, size, b, first, cur->left, rh, rt, prevL);

	if (cur->right != NULL && (@2_LT(&value,hgh,@3@1) || (@2_EQ(&value,hgh,@3@1) && *inclusiveHgh == TRUE)))
		size = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, size, b, first, cur->right, rh, rt, value);

	return size;
}

/* Locate and mark as deleted a node in the AVL tree, starting from a given node */
static struct Node *
LocateDelete_@1(struct Node *cur, oid id, @1 *value, BAT *b, BUN first){
	struct Node * current = cur;
	if ( @2_GT(Tloc(b, first + current->position),value,@3@1) )
		return current->right != NULL ? LocateDelete_@1(current->right, id, value, b, first): NULL;	
	else
	if ( @2_LT(Tloc(b, first + current->position),value,@3@1) )
		return current->left != NULL ? LocateDelete_@1(current->left, id, value, b, first): NULL;	
	else
	if ( @2_EQ(Tloc(b, first + current->position),value,@3@1) ){
		if ( (oid)current->position ==  id ){
			current->deleted = TRUE;
			return current;
		}
		else {
			while(1){
				if (current->right != NULL)
					current= current->right;
				if ( @2_EQ(Tloc(b, first + current->position),value,@3@1) ){
			                if ( (oid)current->position ==  id ){
						current->deleted = TRUE;
               		 		        return current;
					} else
						continue;
				} else 
					return current;
			}
		}
	}

	return NULL;
}

/* delete from the AVL tree a collection of values */
str
CRKdeleteFromAVL_@1(int *k, int *bid, int *uid){
	BAT *b, *u;
	lng indexPos;
	BUN first;
	@1 *delt, *delLast;
	oid *delh;
	(void)k;
	
	indexPos = existsAVLIndex(*bid);
        if (indexPos == -1)
                throw(MAL, "crackers.delete from AVL index", "No AVL index present for this BAT");

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.delete from AVL index", "Cannot access descriptor");

	if ((u = BATdescriptor(*uid)) == NULL)
                throw(MAL, "crackers.delete from AVL index", "Cannot access deletions BAT");

        if (BATcount(u) == 0){
                BBPunfix(u->batCacheid);
                return MAL_SUCCEED; /* no qualifying values in the insertions */
        }

        /* if necessary, sort in place the insertions bat */
        if (u->tsorted == FALSE){
                u->batRestricted = BAT_WRITE;
                BATmirror(BATorder(BATmirror(u)));
        }

	first   = BUNfirst(b);

	delt    = (@1 *)Tloc(u, BUNfirst(u));
	delh    = (oid*)Hloc(u, BUNfirst(u));
	delLast = (@1 *)Tloc(u, BUNlast(u));

	while (delt < delLast){
		LocateDelete_@1(AVLIndex[indexPos].Tree, *delh, delt, b, first);
		delt++; delh++;
	}
	
	BATmode(u, TRANSIENT);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);
	
	return MAL_SUCCEED;
}
@

@}
