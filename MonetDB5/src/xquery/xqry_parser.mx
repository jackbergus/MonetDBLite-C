@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f xqry_parser
@a M. L. Kersten
@v 0.1
@+ XQuery Compilation
MonetDB supports several front-ends. One of those is XQuery
as defined by W3C. 
The version shipped with MonetDB Version 4 is based on the seminal
work at Konstanz and Munich, which use a schema agnostic approach
to prepresent the document and derive query plans.

The 'older' method designed and used in conjunction with the XMark
benchmark worked with path summaries. This provides an extreme
partitioning scheme of the database.

The sample compilation shown below has been designed as a proof
of concept that compilation of valid xqueries of the complexity
of the XMark benchmark can indeed be processed using the MonetDB
guide.

@{
@+ Implementation notes
The XQuery parser is a recursive-descend implementation.
The parser produced follows the structure of the MAL parser
and produces a MAL block for direct execution.

The grammar is taken from W3C website.
@}
@+ Conversion Pitfalls
In this section we summarize the pitfalls and limitations encountered
in using the XQuery to MAL compiler.
The grammar is spread over a large code base, but the naming is kept
close to its use in the W3C documents.
@{
@+ The lexical analyzer
It uses the features offered by the MAL parser.
The key structured is a XML context descriptor,
which keeps track of all retrictics made sofar
on the document tree.
@h
#ifndef _XQRY_PARSER_H
#define _XQRY_PARSER_H

#define STATIC static

#include "xqry_gencode.h"

#define PARSE_OK 0
#define PARSE_ERR -1

#define NO_TOKEN -2

xqry_export str XQRYcompile(str qry);
xqry_export str XQRYexec(int ret, str qry);

xqry_export int parseXQuery(Client cntxt);

#define _XQRY_DEBUG 1	/* debugging option */

#endif /* _XQRY_PARSER_H */
@-
It helps during development to trace the parser actions.
It can be extended with relevant Xbackend dumps.
@= ptrace
#ifdef _XQRY_DEBUG
{ 	
	if (xb->token < 0)
		stream_printf(cntxt->fdout,"@1[ ");
	else if (xb->token < 255)
		stream_printf(cntxt->fdout,"@1[%c ",(char)xb->token);
	else
		stream_printf(cntxt->fdout,"@1[%s ",XT2string(xb->token));
	oldtrace = xb->xs->yycur;
}
#endif
@= etrace
#ifdef _XQRY_DEBUG
{ 	
	if (xb->token < 0)
		stream_printf(cntxt->fdout,"@1]\n");
	else if (xb->token < 255)
		stream_printf(cntxt->fdout,"@1] %c\n",(char)xb->token);
	else
		stream_printf(cntxt->fdout,"@1] %s\n",XT2string(xb->token));
}
#endif
@c
#include "xqry_parser.h"
#include "xqry_backend.h"
#include <mal_interpreter.h>
#include <mal_parser.h>
#include <mal_builder.h>
#include <mal_client.h>

#define BE(X) ((Xbackend)(X->state[PARSER]))
#define nextToken(xb) (xb->token = xscanner_lex(xb->xs, &xb->sval))
#define curToken(xb)  ((xb->token == NO_TOKEN)?nextToken(xb):xb->token)

#define XPATHLENGTH 1024

int oldtrace=0;

extern int xqryError(Client cntxt, str msg);

@-
The XQuery parser may request for more information to 
complete a parsing request.
@c

@+ The Parser
Unlike MonetDB V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

@+ The parser
The Xquery parser uses the recursive descent method,
producing MAL code on the fly as needed.
Given the FLWOR expression this might not be optimal,
but further tuning is left to the backend.
@c
STATIC int parseIfExpr(Client cntxt, Xbackend xb);
STATIC int parseReturnExprSingle(Client cntxt, Xbackend xb);
STATIC int parseFLWORExpr(Client cntxt, Xbackend xb);
STATIC int parseTypeswitchExpr(Client cntxt, Xbackend xb);
STATIC int parseExpr(Client cntxt, Xbackend xb);
STATIC int parseExprSingle(Client cntxt, Xbackend xb);
STATIC int parseDirectConstructor(Client cntxt, Xbackend xb);


STATIC int
parseQName_(Xbackend xb)
{
	if (curToken(xb) == XT_NCNAME) {
		xb->token = NO_TOKEN;
		return PARSE_OK;
	}
	if (curToken(xb) == XT_QNAME) {
		xb->token = NO_TOKEN;
		return PARSE_OK;
	}
	return PARSE_ERR;
}

STATIC int
parseQName__(Client cntxt, Xbackend xb)
{
	int ret, id = -1, l;

	ret = parseQName_(xb);
	if( ret == PARSE_ERR) 
		return ret;
	for(l=0; l <xb->vtop; l++)
		if( xb->vars[l].nme && 
			strcmp(xb->sval, xb->vars[l].nme)==0 ){
			id = xb->vars[l].tmpid; 
			return ret;
		}
	if( xb->vtop == MAXXVARS){
		xqryError(cntxt,"Too many variables");
		xb->vtop --;
	}
	if( id < 0) 
		id = newVariable(xb->mb, _strdup(xb->sval), TYPE_any);
	xb->vars[xb->vtop].nme = xb->mb->var[id]->name;
#ifdef _XQRY_DEBUG
		stream_printf(GDKout,"#NCName %d %d %s\n", xb->vtop, id, xb->sval);
#endif
	xb->vars[xb->vtop++].tmpid = id;
	return ret;
}

STATIC int
parseQName(Client cntxt, Xbackend xb)
{
	int res = parseQName_(xb);
	(void)cntxt;
#ifdef _XQRY_DEBUG
	stream_printf(GDKout,"#QName %s %d\n", xb->sval, res);
#endif
	return res;
}

STATIC int
parseVarQName(Client cntxt, Xbackend xb)
{
	int l, res = parseQName_(xb);
	if (res == PARSE_ERR)
		return PARSE_ERR;
	for(l=0; l <xb->vtop; l++)
		if(xb->vars[l].nme && strcmp(xb->sval, xb->vars[l].nme)==0 )
			return PARSE_OK;
	if( xb->vtop == MAXXVARS){
		xqryError(cntxt,"Too many variables");
		xb->vtop --;
	}
#ifdef _XQRY_DEBUG
		stream_printf(GDKout,"#QName %d -1 %s\n", xb->vtop, xb->sval);
#endif
	xb->vars[xb->vtop].tmpid = -1;
	xb->vars[xb->vtop++].nme = _strdup(xb->sval);
	return PARSE_OK;
}
@-
The string literals may contain escapes to XQuery expressions.
They should be evaluated in place
@c
STATIC int 
parseEnclosedExpr(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != '{')
		return PARSE_ERR;
	@:ptrace(parseEnclosedExpr)@
	nextToken(xb);
	parseExpr(cntxt,xb);
	if (curToken(xb) != '}')
		return xqryError(cntxt,"'}' expected in EnclosedExpr\n");
	xb->token = NO_TOKEN;
	@:etrace(parseEnclosedExpr)@
	return PARSE_OK;
}

@-
The key of the problem is to deal with path expressions.
@c
#define CHILD 1
#define DESCENDANT 2
#define ATTRIBUTE 3
#define SELF 4
#define DESCENDANT_OR_SELF 5
#define FOLLOWING 6
#define FOLLOWING_SIBLING 7

#define PARENT 8
#define ANCESTOR 9
#define PRECEDING 10
#define ANCESTOR_OR_SELF  11
#define PRECEDING_SIBLING 12

#define ITEM_TEST 19
#define NODE_TEST	20
#define TEXT_TEST 	21
#define COMMENT_TEST 22
#define EMPTY_SEQUENCE_TEST 23

STATIC int
parseElementName(Client cntxt, Xbackend xb)
{
	@:ptrace(parseElementName)@
	if (parseQName(cntxt,xb) == PARSE_ERR)
		return PARSE_ERR;
	@:etrace(parseElementName)@
	return PARSE_OK;
}

STATIC int
parseTypeName(Client cntxt, Xbackend xb)
{
	@:ptrace(parseTypeName)@
	if (parseQName(cntxt,xb) == PARSE_ERR)
		return PARSE_ERR;
	@:etrace(parseTypeName)@
	return PARSE_OK;
}

STATIC int
parseAttributeName(Client cntxt, Xbackend xb)
{
	@:ptrace(parseAttributeName)@
	if (parseQName(cntxt,xb) == PARSE_ERR)
		return PARSE_ERR;
	@:etrace(parseAttributeName)@
	return PARSE_OK;
}

STATIC int 
parseSchemaElementTest(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_schema_element)
		return PARSE_ERR;
	@:ptrace(parseSchemaElementTest)@
	if (nextToken(xb) != '(')
		return xqryError(cntxt,"'(' expected in SchemaElementTest\n");
	nextToken(xb);
	if (parseQName(cntxt,xb) == PARSE_ERR)
		return xqryError(cntxt,"<ElementName> expected in SchemaElementTest\n");
	if (curToken(xb) != ')')
		return xqryError(cntxt,"')' expected in SchemaElementTest\n");
	xb->token = NO_TOKEN;
	@:etrace(parseSchemaElementTest)@
	return PARSE_OK;
}

STATIC int 
parseElementTest(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_element)
		return PARSE_ERR;
	@:ptrace(parseElementTest)@
	if (nextToken(xb) != '(')
		return xqryError(cntxt,"'(' expected in ElementTest\n");
	if (nextToken(xb) == '*'){
		nextToken(xb);
	} else
		parseElementName(cntxt,xb);
	
	if (curToken(xb) == ','){
		nextToken(xb);
		if( parseTypeName(cntxt,xb)== PARSE_ERR )
			return xqryError(cntxt,"<TypeName> expected in ElementTest\n");
		if (curToken(xb) == '?')
			nextToken(xb);
	}

	if (curToken(xb) != ')')
		return xqryError(cntxt,"')' expected in ElementTest\n");
	xb->token = NO_TOKEN;
	@:etrace(parseElementTest)@
	return PARSE_OK;
}


STATIC int 
parseSchemaAttributeTest(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_schema_attribute)
		return PARSE_ERR;
	@:ptrace(parseSchemaAttributeTest)@
	if (nextToken(xb) != '(')
		return xqryError(cntxt,"'(' expected in SchemaAttributeTest\n");
	nextToken(xb);
	if (parseAttributeName(cntxt,xb)== PARSE_ERR )
		return PARSE_ERR;

	if (curToken(xb) != ')')
		return xqryError(cntxt,"')' expecteSchemaAttributeTest\n");
	xb->token = NO_TOKEN;
	@:etrace(parseSchemaAttributeTest)@
	return PARSE_OK;
}


STATIC int 
parseAttributeTest(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_attribute)
		return PARSE_ERR;
	@:ptrace(parseAttributeTest)@
	if (nextToken(xb) != '(')
		return xqryError(cntxt,"'(' expecte AttributeTest\n");
	if (nextToken(xb) == '*'){
		nextToken(xb);
	} else
		parseElementName(cntxt,xb);
	if (curToken(xb) == ','){
		nextToken(xb);
		if( parseTypeName(cntxt,xb)== PARSE_ERR )
			return PARSE_ERR;
	}
	if (curToken(xb) != ')')
		return xqryError(cntxt,"')' expected in AttributeTest\n");
	xb->token = NO_TOKEN;
	@:etrace(parseAttributeTest)@
	return PARSE_OK;
}

STATIC int
parseDocumentTest(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_document_node)
		return PARSE_ERR;
	@:ptrace(parseDocumentTest)@
	if (nextToken(xb) != '(')
		return xqryError(cntxt,"'(' expected in DocumentTest\n");
	nextToken(xb);
	if (parseElementTest(cntxt,xb) == PARSE_ERR ||
	    parseSchemaElementTest(cntxt,xb) == PARSE_ERR) {
		/* optional */
	}
	if( curToken(xb) != ')')
		return xqryError(cntxt,"')' expected in DocumentTest\n");
	xb->token = NO_TOKEN;
	@:etrace(parseDocumentTest)@
	return PARSE_OK;
}

STATIC int
parsePITest(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_pi)
		return PARSE_ERR;
	@:ptrace(parsePITest)@
	if (nextToken(xb) != '(')
		return xqryError(cntxt,"'(' expected in PITest\n");
	if (nextToken(xb) != XT_NCNAME) {
		if (nextToken(xb) == XT_STR) 
			nextToken(xb);
	}
	if (curToken(xb) != ')')
		return xqryError(cntxt,"')' expected in PITest\n");
	xb->token = NO_TOKEN;
	@:etrace(parsePITest)@
	return PARSE_OK;
}

STATIC int
parseKindTest(Client cntxt, Xbackend xb)
{
	int kind=0;

	@:ptrace(parseKindTest)@
	(void) kind;
	if( parseSchemaElementTest(cntxt,xb)== PARSE_OK ||
	    parseAttributeTest(cntxt,xb)== PARSE_OK ||
	    parseSchemaAttributeTest(cntxt,xb)== PARSE_OK ||
	    parseElementTest(cntxt,xb)== PARSE_OK ||
	    parseDocumentTest(cntxt,xb)== PARSE_OK ||
	    parsePITest(cntxt,xb)== PARSE_OK) {
		@:etrace(parseKindTest)@
		return PARSE_OK;
	}

	if( curToken(xb) == XT_node) 
		kind= NODE_TEST; 
	else if( curToken(xb) == XT_text) {
		kind= TEXT_TEST; 
		xqryPushText(xb);
	} else if( curToken(xb) == XT_comment)
		kind= COMMENT_TEST; 
	else 
		return PARSE_ERR;
	if( nextToken(xb) != '(') 
		return xqryError(cntxt,"'(' expected in KindTest\n");
	if( nextToken(xb) != ')') 
		return xqryError(cntxt,"')' expected in KindTest\n");
	xb->token = NO_TOKEN;
	@:etrace(parseKindTest)@
	return PARSE_OK;
}

STATIC int
parseItemType(Client cntxt, Xbackend xb)
{
	@:ptrace(parseItemType)@
	if (curToken(xb) == XT_item) {
		int i;
		if (nextToken(xb) != '(')
			return xqryError(cntxt,"'(' expected in ItemType\n");
		if (nextToken(xb) != ')')
			return xqryError(cntxt,"')' expected in ItemType\n");
		i = ITEM_TEST; 
		(void)i;
		@:etrace(parseItemType)@
		xb->token = NO_TOKEN;
		return PARSE_OK;
	}
	if (parseKindTest(cntxt,xb) == PARSE_OK) 
		return PARSE_OK;
	/* AtomicType */
	if (parseQName(cntxt,xb) == PARSE_ERR) 
		return xqryError(cntxt,"<AtomicType> expected in ItemType\n");
	@:etrace(parseItemType)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int
parseSequenceType(Client cntxt, Xbackend xb)
{
	@:ptrace(parseSequenceType)@
	if (curToken(xb) == XT_empty_sequence) {
		if (nextToken(xb) != '(') 
			return xqryError(cntxt,"'(' expected in SequenceType\n");
		if (nextToken(xb) != ')')
			return xqryError(cntxt,"')' expected in SequenceType\n");
		xb->token = NO_TOKEN;
		@:etrace(parseSequenceType)@
		return PARSE_OK;
	}
	if( parseItemType(cntxt,xb) == PARSE_ERR)
		return PARSE_ERR;
	/* ItemType OccurrenceIndicator */
	switch(curToken(xb)){
	case '?':
	case '+':
	case '*':
		xb->token = NO_TOKEN;
		break;
	}
	@:etrace(parseSequenceType)@
	return PARSE_OK;
}

STATIC int
parseTypeDeclaration(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_as)
		return PARSE_ERR;
	nextToken(xb);
	@:ptrace(parseTypeDeclaration)@
	return parseSequenceType(cntxt,xb);
}

STATIC int
parseCompPIConstructor(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_pi)
		return PARSE_ERR;
	@:ptrace(parseCompPIConstructor)@
	if (nextToken(xb) != XT_NCNAME) {
		if (curToken(xb) != '{')
			return xqryError(cntxt,"'{' expected in PIConstructor\n");
		nextToken(xb);
		parseExpr(cntxt,xb);
		if (curToken(xb) != '}')
			return xqryError(cntxt,"'}' expected in PIConstructor\n");
		nextToken(xb);
	}

	if (curToken(xb) != '{')
		return xqryError(cntxt,"'{' expected in PIConstructor\n");
	nextToken(xb);
	parseExpr(cntxt,xb);
	if (curToken(xb) != '}')
		return xqryError(cntxt,"'}' expected in PIConstructor\n");
	xb->token = NO_TOKEN;
	@:etrace(parseCompPIConstructor)@
	return PARSE_OK;
}


STATIC int
parseCompCommentConstructor(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_comment)
		return PARSE_ERR;
	@:ptrace(parseCompCommentConstructor)@
	if (nextToken(xb) != '{')
		return xqryError(cntxt,"'{' expected in CompCommentConstructor\n");
	nextToken(xb);
	parseExpr(cntxt,xb);
	if (curToken(xb) != '}')
		return xqryError(cntxt,"'}' expected in CompCommentConstructor\n");
	xb->token = NO_TOKEN;
	@:etrace(parseCompCommentConstructor)@
	return PARSE_OK;
}

STATIC int
parseCompTextConstructor(Client cntxt, Xbackend xb)
{
	/* TODO: problably all x { need special care */
	if (curToken(xb) != XT_text_constructor) 
		return PARSE_ERR;
	@:ptrace(parseCompTextConstructor)@
	nextToken(xb);
	parseExpr(cntxt,xb);
	if (curToken(xb) != '}')
		return xqryError(cntxt,"'}' expected in CompTextConstructor\n");
	xb->token = NO_TOKEN;
	@:etrace(parseCompTextConstructor)@
	return PARSE_OK;
}

STATIC int
parseCompAttrConstructor(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_attribute)
		return PARSE_ERR;
	@:ptrace(parseCompAttrConstructor)@
	nextToken(xb);
	if (parseQName(cntxt,xb) == PARSE_ERR) {
		if (curToken(xb) != '{')
			return xqryError(cntxt,"'{' expected in CompAttrConstructor\n");
		nextToken(xb);
		parseExpr(cntxt,xb);
		if (curToken(xb) != '}')
			return xqryError(cntxt,"'}' expected in CompAttrConstructor\n");
		nextToken(xb);
	}

	if (curToken(xb) != '{')
		return xqryError(cntxt,"'{' expected in CompAttrConstructor\n");
	nextToken(xb);
	parseExpr(cntxt,xb);
	if (curToken(xb) != '}')
		return xqryError(cntxt,"'}' expected in CompAttrConstructor\n");
	xb->token = NO_TOKEN;
	@:etrace(parseCompAttrConstructor)@
	return PARSE_OK;
}

STATIC int
parseCompElemConstructor(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_element)
		return PARSE_ERR;
	@:ptrace(parseCompElemConstructor)@
	nextToken(xb);
	if (parseQName(cntxt,xb) == PARSE_ERR) {
		if (curToken(xb) != '{')
			return xqryError(cntxt,"'{' expected in CompElemConstructor\n");
		nextToken(xb);
		parseExpr(cntxt,xb);
		if (curToken(xb) != '}')
			return xqryError(cntxt,"'}' expected in CompElemConstructor\n");
		nextToken(xb);
	}
	if (curToken(xb) != '{')
		return xqryError(cntxt,"'{' expected in CompElemConstructor\n");
	nextToken(xb);
	parseExpr(cntxt,xb);
	if (curToken(xb) != '}')
		return xqryError(cntxt,"'}' expected in CompElemConstructor\n");
	xb->token = NO_TOKEN;
	@:etrace(parseCompElemConstructor)@
	return PARSE_OK;
}

STATIC int
parseCompDocConstructor(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_document)
		return PARSE_ERR;
	@:ptrace(parseCompDocConstructor)@
	if (nextToken(xb) != '{')
		return xqryError(cntxt,"'{' expected in CompDocConstructor\n");
	nextToken(xb);
	parseExpr(cntxt,xb);
	if (curToken(xb) != '}')
		return xqryError(cntxt,"'}' expected in CompDocConstructor\n");
	xb->token = NO_TOKEN;
	@:etrace(parseCompDocConstructor)@
	return PARSE_OK;
}

STATIC int
parseComputedConstructor(Client cntxt, Xbackend xb)
{
	int ret;
	@:ptrace(parseComputedConstructor)@
	if( parseCompDocConstructor(cntxt,xb)== PARSE_OK ||
	    parseCompElemConstructor(cntxt,xb)== PARSE_OK ||
	    parseCompAttrConstructor(cntxt,xb)== PARSE_OK ||
	    parseCompTextConstructor(cntxt,xb)== PARSE_OK ||
	    parseCompCommentConstructor(cntxt,xb)== PARSE_OK){
		@:etrace(parseComputedConstructor)@
		return PARSE_OK;
	}
	ret = parseCompPIConstructor(cntxt,xb);
	@:etrace(parseComputedConstructor)@
	return ret;
}

STATIC int
parseDirPIConstructor(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_piconstructor_start)
		return PARSE_ERR;
	@:ptrace(parseDirPIConstructor)@
	/* PItarget */
	/* TODO parse pi target (scan all until ?>) */
	if (nextToken(xb) != XT_STR)
		return PARSE_ERR;
	if (nextToken(xb) != XT_piconstructor_end)
		return xqryError(cntxt,"'?>' expected in DirPIConstructor\n");
	xb->token = NO_TOKEN;
	@:etrace(parseDirPIConstructor)@
	return PARSE_OK;
}

/* do we need to keep comments ? */
STATIC int
parseDirCommentConstructor(Client cntxt, Xbackend xb)
{
	if (curToken(xb) != XT_commentconstructor_start)
		return PARSE_ERR;
	@:ptrace(parseCommentConstructor)@
	/* comment */
	/* TODO parse comment (scan all until ?>) */
	if (nextToken(xb) != XT_STR)
		return PARSE_ERR;
	if (nextToken(xb) != XT_commentconstructor_end)
		return xqryError(cntxt,"'-->' expected in DirCommentConstructor\n");
	@:etrace(parseCommentConstructor)@
	return PARSE_OK;
}

STATIC int
parseDirAttributeValue(Client cntxt, Xbackend xb)
{

/* need special work, is a string now 
	if (curToken(xb)== '"'){
		@:ptrace(parseDirAttributeValue)@
		nextToken(xb);
		while( curToken(cntxt) && curToken(cntxt)!= '"')
		if( curToken(cntxt)=='"' && i){
			nextToken(cntxt); i=0;
		} else
		if( curToken(cntxt)=='"'){
			nextToken(cntxt); i=1;
		} else
		if( curToken(cntxt)=='{'){
			if( parseEnclosedExpr(cntxt,xb)== PARSE_ERR)
				nextToken(cntxt); i=0;
		} else{
			nextToken(cntxt); i=0;
		}
		if( curToken(cntxt)== '"') nextToken(cntxt);
	}  else
	if( curToken(xb)== '\'') {
		@:ptrace(parseDirAttributeValue)@
		while (nextToken(xb) != '\'') ;
		if (curToken(cntxt) == '\'' && i) {
			nextToken(cntxt);
			i = 0;
		} else if (curToken(cntxt) == '\'') {
			nextToken(cntxt);
			i = 1;
		} else if( curToken(cntxt)=='{'){
			if( parseEnclosedExpr(cntxt,xb)== PARSE_ERR)
				nextToken(cntxt); i=0;
		} else {
			nextToken(cntxt);
			i = 0;
		}
		if (curToken(cntxt) == '\'')
			nextToken(cntxt);
	} else
*/
	@:ptrace(parseDirAttributeValue)@
	if ( curToken(xb) != XT_STR)
		return xqryError(cntxt,"  DirAttributeValue\n");
	xb->token = NO_TOKEN;
	@:etrace(parseDirAttributeValue)@
	return PARSE_OK;
}

STATIC int 
parseDirAttributeList(Client cntxt, Xbackend xb) 
{
	int res = PARSE_OK;

	@:ptrace(parseDirAttributeList)@
	do {
		if (parseQName(cntxt,xb) == PARSE_ERR) 
			break;
		if (curToken(xb) != XT_eq){
			return PARSE_ERR;
		}
		nextToken(xb);
	} while ((res = parseDirAttributeValue(cntxt,xb)) == PARSE_OK);
	@:etrace(parseDirAttributeList)@
	return PARSE_OK;
}

STATIC int 
parseCDataSection(Client cntxt, Xbackend xb) 
{
/* needs a special scan function */
	if (curToken(xb) != XT_cdata_start)
		return PARSE_ERR;
	@:ptrace(parseCDataSection)@
	while (nextToken(xb) != XT_cdata_end);

	@:etrace(parseCDataSection)@
	return PARSE_OK;
}

STATIC int 
parseCommonContent(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseCommonContent)@
	if (curToken(xb) == XT_2open || curToken(xb) == XT_2close ||
		parseEnclosedExpr(cntxt,xb) == PARSE_OK){
		@:etrace(parseCommonContent)@
		return PARSE_OK;
	}
	/* check PredefinedEntityRef */
	/* and the rest */
	if (curToken(xb) != XT_STR) 
		return xqryError(cntxt,"<CharRef> expected in CommonContent\n");
	@:etrace(parseCommonContent)@
	return PARSE_OK;
}

STATIC int 
parseElementContentChar(Client cntxt, Xbackend xb) 
{
	(void)cntxt;
	switch (curToken(xb)) {
	case '{':
	case '}':
	case XT_lt:
	case '&':
		return PARSE_ERR;
	}
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parsePredefinedEntityRef(Client cntxt, Xbackend xb) 
{
	if (curToken(xb) != '&')
		return PARSE_ERR;
	@:ptrace(parsePredefinedEntityRef)@
	if (nextToken(xb) == XT_gt) {
	} else if (curToken(xb) == XT_lt) {
	} else if (curToken(xb) == XT_amp) {
	} else if (curToken(xb) == XT_quot) {
	} else if (curToken(xb) == XT_apos) {
	} else {
		return xqryError(cntxt,"<PredefinedEntity> expected in PredefinedEntityRef\n");
	}
	if (nextToken(xb) != ';')
		return xqryError(cntxt,"';' expected in PredefinedEntityRef\n");
	xb->token = NO_TOKEN;
	@:etrace(parsePredefinedEntityRef)@
	return PARSE_OK;
}

STATIC int 
parseDirElementContent(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseDirElementContent)@
	do{
		if( !(
			parseEnclosedExpr(cntxt,xb)== PARSE_OK ||
			parseDirectConstructor(cntxt, xb)== PARSE_OK ||
			parseCDataSection(cntxt, xb)== PARSE_OK ||
			parseCommonContent(cntxt, xb) == PARSE_OK ||
			parseElementContentChar(cntxt, xb)== PARSE_OK
		) )
			return PARSE_ERR;
	} while(1);
	@:etrace(parseDirElementContent)@
	return PARSE_OK;
}

STATIC int 
parseDirElementConstructor(Client cntxt, Xbackend xb) 
{
	int state = xb->xs->state;

	if (curToken(xb) != XT_lt)
		return PARSE_ERR;
	@:ptrace(parseDirElementConstructor)@
	xb->xs->state = XS_XML;
	nextToken(xb);
	if (parseQName(cntxt,xb) == PARSE_ERR) 
		return xqryError(cntxt,"<Qname> expected in DirElementConstructor\n");
	parseDirAttributeList(cntxt, xb);

	if (curToken(xb) == XT_elementconstructor_end) {
		xb->token = NO_TOKEN;
		@:etrace(parseDirElementConstructor)@
		xb->xs->state = state;
		return PARSE_OK;
	}

	if (curToken(xb) != '>') 
		return xqryError(cntxt,"'>' expected in DirElementConstructor\n");
	nextToken(xb);
	parseDirElementContent(cntxt, xb);
	if (curToken(xb) != XT_elementconstructor_start)
		return xqryError(cntxt,"'</' expected in DirElementConstructor\n");

	if (parseQName(cntxt,xb) == PARSE_ERR) 
		return xqryError(cntxt,"<Qname> expected in DirElementConstructor\n");

	if (curToken(xb) != XT_gt)
		return xqryError(cntxt,"'>' expected in DirElementConstructor\n");

	xb->token = NO_TOKEN;
	@:etrace(parseDirElementConstructor)@
	xb->xs->state = state;
	return PARSE_OK;
}

STATIC int 
parseDirectConstructor(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseDirConstructor)@
	if (parseDirElementConstructor(cntxt, xb) == PARSE_OK ){
		@:etrace(parseDirConstructor)@
		return PARSE_OK;
	}
	if (parseDirCommentConstructor(cntxt, xb) == PARSE_OK ){
		@:etrace(parseDirConstructor)@
		return PARSE_OK;
	}
	if (parseDirPIConstructor(cntxt, xb) == PARSE_OK ){
		@:etrace(parseDirConstructor)@
		return PARSE_OK;
	}
	return PARSE_ERR;
}

STATIC int 
parseConstructor(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseConstructor)@
	if (parseDirectConstructor(cntxt, xb) == PARSE_OK ){
		@:etrace(parseConstructor direct)@
		return PARSE_OK;
	}
	if (parseComputedConstructor(cntxt, xb) == PARSE_OK){
		@:etrace(parseConstructor computed)@
		return PARSE_OK;
	}
	return PARSE_ERR;
}

STATIC int
parseNonReservedKeyword(Xbackend xb)
{
	switch(curToken(xb)){
	case XT_encoding:
		xb->token = NO_TOKEN;
		return PARSE_OK;
	default:
		return PARSE_ERR;
	}
}

STATIC int 
parseNameTest(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseNameTest)@
	if (parseQName(cntxt,xb) == PARSE_OK || parseNonReservedKeyword(xb) == PARSE_OK) { 
		char *name = xb->sval;
		if (curToken(xb) == ':') {
			if (nextToken(xb) != '*') 
				return xqryError(cntxt,"'*' expected in NameTest\n");
			xb->token = NO_TOKEN;
		} else {
			xqryPushNameTest(xb, name);
		}
		@:etrace(parseNameTest)@
		return PARSE_OK;
	}
	if (curToken(xb) == '*') {
		if (nextToken(xb) == ':') {
			if (nextToken(xb) != XT_NCNAME) 
				return xqryError(cntxt,"<NCname> expected in NameTest\n");
		}
	} else 
		return PARSE_ERR;
	@:etrace(parseNameTest)@
	return PARSE_OK;
}

/* we need readahead here */
STATIC int 
parseFunctionCall(Client cntxt, Xbackend xb) 
{
	int argc = 0;
	char *fname = NULL;

	@:ptrace(parseFunctionCall)@
	if (curToken(xb) != XT_FNAME) 
		return PARSE_ERR;
	fname = xb->sval;
	nextToken(xb);
	do {
		if (curToken(xb) == ')')
			break;
		if (argc && curToken(xb) != ',') {
			return xqryError(cntxt,"',' expected in FunctionCall\n");
		}
		if (argc)
			nextToken(xb);
		argc++;
	} while (parseExprSingle(cntxt, xb) == PARSE_OK);
	if (curToken(xb) != ')') {
		return xqryError(cntxt,"')' expected in FunctionCall\n");
	}
	@:etrace(parseFunctionCall)@
	xqryStatement(xb,"xqry",fname,argc);
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parsePrimaryExpr(Client cntxt, Xbackend xb) 
{
	InstrPtr p;

	@:ptrace(parsePrimaryExpr)@
	if (curToken(xb) == XT_STR) {
		ValRecord val;
		val.vtype = TYPE_str;
		val.val.sval = _strdup(xb->sval);
		p= newAssignment(xb->mb);
		getArg(p,0) = pushXvar(xb);
		pushArgument(xb->mb, p, defConstant(xb->mb, val.vtype,&val));
		xb->token = NO_TOKEN;
		@:etrace(parsePrimaryExpr)@
		return PARSE_OK;
	}
	if (curToken(xb) == XT_INT || curToken(xb) == XT_DEC || 
	    curToken(xb) == XT_DBL) {
		ValRecord val;
		if (curToken(xb) == XT_INT) {
			val.vtype = TYPE_lng;
			val.val.lval = strtoll(xb->sval,NULL,0);
		} else {
			val.vtype = TYPE_dbl;
			val.val.dval = (dbl) strtod(xb->sval,NULL);
		}
		p= newAssignment(xb->mb);
		getArg(p,0) = pushXvar(xb);
		pushArgument(xb->mb, p, defConstant(xb->mb, val.vtype,&val));
		xb->token = NO_TOKEN;
		@:etrace(parsePrimaryExpr)@
		return PARSE_OK;
	}
	if (curToken(xb) == '$') {
		nextToken(xb);
		if (parseQName(cntxt,xb) == PARSE_ERR) 
			return xqryError(cntxt,"<VarRef> expected in PrimaryExpr\n");
		p= newAssignment(xb->mb);
		getArg(p,0) = pushXvar(xb);
		pushArgument(xb->mb, p, XfindId(xb, xb->sval));
		@:etrace(parsePrimaryExpr)@
		return PARSE_OK;
	}
	/* ContextItemExpr */
	if (curToken(xb) == '.') {
		xb->token = NO_TOKEN;
		@:etrace(parsePrimaryExpr)@
		return PARSE_OK;
	} 
	/* ParenthesizedExpr */
	if (curToken(xb) == '(') {
		nextToken(xb);
		parseExpr(cntxt, xb);
		if (curToken(xb) != ')')
			return xqryError(cntxt,"')' expected in PrimaryExpr\n");
		@:etrace(parsePrimaryExpr)@
		xb->token = NO_TOKEN;
		@:etrace(parsePrimaryExpr)@
		return PARSE_OK;
	} 
	/* OrderedExpr */
	if (curToken(xb) == XT_ordered) {
		if (nextToken(xb) != '{')
			return xqryError(cntxt,"'{' expected in PrimaryExpr\n");
		nextToken(xb);
		if (parseExpr(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<Expr> expected in PrimaryExpr\n");
		if (curToken(xb) != '}')
			return xqryError(cntxt,"'}' expected in PrimaryExpr\n");
		xb->token = NO_TOKEN;
	} else if (curToken(xb) == XT_unordered) {
		if (nextToken(xb) != '{')
			return xqryError(cntxt,"'{' expected in PrimaryExpr\n");
		nextToken(xb);
		if (parseExpr(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<Expr> expected in PrimaryExpr\n");
		if (curToken(xb) != '}')
			return xqryError(cntxt,"'}' expected in PrimaryExpr\n");
		xb->token = NO_TOKEN;
	}
	if (parseConstructor(cntxt, xb) == PARSE_OK ){
		@:etrace(parsePrimaryExpr Constructor)@
		return PARSE_OK;
	}
	if( parseFunctionCall(cntxt, xb) == PARSE_OK){
		@:etrace(parsePrimaryExpr)@
		return PARSE_OK;
	}
	@:etrace(parsePrimaryExpr failed)@
	return PARSE_ERR;
}

STATIC int 
parsePredicate(Client cntxt, Xbackend xb) 
{
	if (curToken(xb) != '[')
		return PARSE_ERR;
	@:ptrace(parsePredicate)@
	xqryPushPredicate(xb);
	nextToken(xb);
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in Predicate\n");
	if (curToken(xb) != ']')
		return xqryError(cntxt,"']' expected in Predicate\n");
	nextToken(xb);
	@:etrace(parsePredicate)@
	return PARSE_OK;

}

STATIC int 
parsePredicateList(Client cntxt, Xbackend xb) 
{
	@:ptrace(parsePredicateList)@
	do {
	} while (parsePredicate(cntxt, xb) == PARSE_OK);
	@:etrace(parsePredicateList)@
	return PARSE_OK;
}

STATIC int 
parseFilterExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseFilter)@
	if (parsePrimaryExpr(cntxt, xb) != PARSE_OK ){
		@:etrace(parseFilter)@
		return PARSE_ERR;
	}
	parsePredicateList(cntxt, xb);
	@:etrace(parseFilter)@
	return PARSE_OK;
}

STATIC int 
parseNodeTest(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseNodeTest)@
	if (parseKindTest(cntxt, xb) == PARSE_OK){
		@:etrace(parseNodeTest)@
		return PARSE_OK;
	}
	return parseNameTest(cntxt, xb);
}

STATIC int 
parseAbbrevReverseStep(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseAbbrevReverseStep)@
	if (curToken(xb) == XT_dotdot) {
		@:etrace(parseAbbrevReverseStep)@
		return PARSE_OK;
	}
	return PARSE_ERR;
}

STATIC int 
parseReverseAxis(Client cntxt, Xbackend xb) 
{
	int ret;

	@:ptrace(parseReverseAxis)@
	if (curToken(xb) == XT_parent)
		ret = PARENT;
	else if (curToken(xb) == XT_ancestor)
		ret = ANCESTOR;
	else if (curToken(xb) == XT_preceding)
		ret = PRECEDING;
	else if (curToken(xb) == XT_preceding_sibling)
		ret = PRECEDING_SIBLING;
	else if (curToken(xb) == XT_ancestor_or_self)
		ret = ANCESTOR_OR_SELF;
	else
		return PARSE_ERR;
	@:ptrace(parseReverseAxis)@
	if (nextToken(xb) != ':' || nextToken(xb) != ':') 
		return xqryError(cntxt,"'::' expected in ReverseAxis\n");
	(void) ret;
	@:etrace(parseReverseAxis)@
	return PARSE_OK;
}

STATIC int 
parseReverseStep(Client cntxt, Xbackend xb) 
{
	int ret;

	@:ptrace(parseReverseStep)@
	if (parseReverseAxis(cntxt, xb) == PARSE_OK) {
		ret= parseNodeTest(cntxt, xb);
	} else
		ret= parseAbbrevReverseStep(cntxt, xb);
	@:etrace(parseReverseStep)@
	return ret;
}

STATIC int 
parseAbbrevForwardStep(Client cntxt, Xbackend xb) 
{
	int ret;
	int at = 0;

	@:ptrace(parseAbbrevForwardStep)@
	if (curToken(xb) == '@') {
		nextToken(xb);
		xqryPushAttribute(xb);
		at = 1;
	}
	ret = parseNodeTest(cntxt, xb);
	if (at) {
		InstrPtr p;
		ValRecord val;

		val.vtype = TYPE_str;
		val.val.sval = xqryXpathFlatten(xb);
		p = newAssignment(xb->mb);
		getArg(p,0) = pushXvar(xb);
		pushArgument(xb->mb, p, defConstant(xb->mb, val.vtype, &val));
		xqryStatement(xb,"xqry","bind",2);
	}
	@:etrace(parseAbbrevForwardStep)@
	return ret;
}

STATIC int 
parseForwardAxis(Client cntxt, Xbackend xb) 
{
	int ret;

	@:ptrace(parseForwardAxis)@
	if (curToken(xb) == XT_child)
		ret = CHILD;
	else if (curToken(xb) == XT_descendant)
		ret = DESCENDANT;
	else if (curToken(xb) == XT_attribute)
		ret = ATTRIBUTE;
	else if (curToken(xb) == XT_following)
		ret = FOLLOWING;
	else if (curToken(xb) == XT_following_sibling)
		ret = FOLLOWING;
	else if (curToken(xb) == XT_self)
		ret = SELF;
	else if (curToken(xb) == XT_descendant_or_self)
		ret = DESCENDANT_OR_SELF;
	else
		return PARSE_ERR;
	if (nextToken(xb) != ':' || nextToken(xb) != ':') 
		return xqryError(cntxt,"'::' expectedin ForwardAxis\n");
	(void) ret;
	@:etrace(parseForwardAxis)@
	return PARSE_OK;
}

STATIC int 
parseForwardStep(Client cntxt, Xbackend xb) 
{
	int ret=PARSE_OK;
	@:ptrace(parseForwardStep)@
	if (parseForwardAxis(cntxt, xb) == PARSE_OK) {
		ret= parseNodeTest(cntxt, xb);
	} else if( parseNodeTest(cntxt, xb)== PARSE_OK){
	} else {
		ret= parseAbbrevForwardStep(cntxt, xb);
	}
	@:etrace(parseForwardStep)@
	return ret;
}

STATIC int 
parseAxisStep(Client cntxt, Xbackend xb) 
{
	int ret;
	@:ptrace(parseAxisStep)@
	if (parseReverseStep(cntxt, xb) == PARSE_ERR &&
	    parseForwardStep(cntxt, xb) == PARSE_ERR )
		return PARSE_ERR;
	ret = parsePredicateList(cntxt, xb);
	@:etrace(parseAxisStep)@
	return ret;
}

STATIC int 
parseStepExpr(Client cntxt, Xbackend xb) 
{
	int ret;
	@:ptrace(parseStepExpr)@
	if (parseFilterExpr(cntxt, xb) == PARSE_OK){
		@:etrace(parseStepExpr)@
		return PARSE_OK;
	}
	ret = parseAxisStep(cntxt, xb);
	@:etrace(parseStepExpr)@
	return ret;
}

STATIC int 
parseRelativePathExpr(Client cntxt, Xbackend xb) 
{
	int res = PARSE_OK;
	int slash = 0;

	@:ptrace(parseRelativePathExpr)@
	res = parseStepExpr(cntxt, xb);
	while (res == PARSE_OK && curToken(xb) == '/') {
		slash++;
		if (nextToken(xb) == '/') {
			slash++;
			nextToken(xb);
		}
		if (slash == 1)
			xqryPushChild(xb);
		else
			xqryPushDescendant(xb);
		slash = 0;
		res = parseStepExpr(cntxt, xb);
	}
	@:etrace(parseRelativePathExpr)@
	return res;
}

STATIC int 
parsePathExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parsePathExpr)@
	if (curToken(xb) == '/') {
		if (nextToken(xb) == '/'){
			nextToken(xb);
		} else{
			parseRelativePathExpr(cntxt, xb);
			@:etrace(parsePathExpr)@
			return PARSE_OK;
		}
	}
	return parseRelativePathExpr(cntxt, xb);
}

@-
Variables are declared and stored on the top
of the variable stack.
@c 

STATIC int 
parseVarName(Client cntxt, Xbackend xb) 
{
	if (curToken(xb) != '$')
		return PARSE_ERR;
	@:ptrace(parseVarName)@
	xb->token = NO_TOKEN;
	if (parseVarQName(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<QName> expected in VarName\n");
	/* has optional type? */
#ifdef _XQRY_DEBUG
	stream_printf(cntxt->fdout, "parseVarName %s\n",
		      xb->vars[xb->vtop - 1].nme);
#endif
	@:etrace(parseVarName)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parsePositionalVar(Client cntxt, Xbackend xb) 
{
	int res = PARSE_OK;

	if (curToken(xb) != XT_at)
		return PARSE_ERR;
	@:ptrace(parsePositionalVar)@
	res = parseVarName(cntxt, xb);
	@:etrace(parsePositionalVar)@
	return res;
}


STATIC int 
parsePragma(Client cntxt, Xbackend xb) 
{
	int i;
	if (curToken(xb) != '(')
		return PARSE_ERR;
	if (nextToken(xb) != '#') /* (# probably needs lexer support */
		return PARSE_ERR;
	@:ptrace(parsePragma)@
	if (parseQName(cntxt,xb) == PARSE_ERR) 
		return xqryError(cntxt,"<QName> expected in Pragma\n");
	i = 0;
	do {
		if (curToken(xb) == ')' && i)
			break;
		if (curToken(xb) == '#')
			i++;
		else
			i = 0;
		nextToken(xb);
	} while (curToken(xb));
	@:etrace(parsePragma)@
	if (i) {
		xb->token = NO_TOKEN;
		return PARSE_OK;
	}
	return PARSE_ERR;
}

STATIC int 
parseExtensionExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseExtensionExpr)@
	do {
	} while (parsePragma(cntxt, xb) == PARSE_OK);
	if (curToken(xb) != '(')
		return xqryError(cntxt,"'(' expected in ExtensionExpr\n");
	nextToken(xb);
	parseExpr(cntxt, xb);
	if (curToken(xb) != ')')
		return xqryError(cntxt,"')' expected in ExtensionExpr\n");
	@:etrace(parseExtensionExpr)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseValidateExpr(Client cntxt, Xbackend xb) 
{
	if (curToken(xb) != XT_validate)
		return PARSE_ERR;
	@:ptrace(parseValidateExpr)@
	if (nextToken(xb) == XT_lax) {
	} else if (curToken(xb) == XT_strip) {
	}
	if (nextToken(xb) != '(')
		return xqryError(cntxt,"'(' expected in ValidateExpr\n");
	xb->token = NO_TOKEN;
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in ValidateExpr\n");
	if (curToken(xb) != ')')
		return xqryError(cntxt,"')' expected in ValidateExpr\n");
	@:etrace(parseValidateExpr)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseSingleType(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseSingleType)@
	if (parseQName(cntxt,xb) == PARSE_ERR)
		return xqryError(cntxt,"<AtomicType> expected in SingleType\n");
	if (curToken(xb) == '?')
		nextToken(xb);
	@:etrace(parseSingleType)@
	return PARSE_OK;
}

STATIC int 
parseValueExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseValueExpr)@
	if (parsePathExpr(cntxt, xb) == PARSE_OK ||
	    parseValidateExpr(cntxt, xb) == PARSE_OK ||
	    parseExtensionExpr(cntxt, xb) == PARSE_OK) {
		@:etrace(parseValueExpr)@
		return PARSE_OK;
	}
	return PARSE_ERR;
}

STATIC int 
parseUnaryExpr(Client cntxt, Xbackend xb) 
{
	char *op = NULL;
	int r1;
	ValRecord cst;
	InstrPtr p;

	@:ptrace(parseUnaryExpr)@
	if (curToken(xb) == '+' ){
		op = "+";
		nextToken(xb);
	} else if (curToken(xb) == '-'){
		op= "-";
		nextToken(xb);
	}
	if( parseValueExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (op && *op == '-'){
		r1=popXvar(xb);
		cst.vtype= TYPE_int;
		cst.val.ival= 0;
		p= newStmt(xb->mb,calcRef, putName("-",1));
		pushArgument(xb->mb,p, defConstant(xb->mb, cst.vtype,&cst));
		pushArgument(xb->mb,p, r1);
		getArg(p,0)= pushXvar(xb);
	}
	@:etrace(parseUnaryExpr)@
	return PARSE_OK;
}

STATIC int 
parseCastExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseCastExpr)@
	if (parseUnaryExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (curToken(xb) != XT_cast)
		return PARSE_ERR;
	if (nextToken(xb) != XT_as)
		return xqryError(cntxt,"'as' expected in CastExpr\n");
	xb->token = NO_TOKEN;
	return parseSingleType(cntxt, xb);
}

STATIC int 
parseCastableExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseCastableExpr)@
	if (parseCastExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (curToken(xb) != XT_castable)
		return PARSE_ERR;
	if (nextToken(xb) != XT_as)
		return xqryError(cntxt,"'as' expected in CatableExpr\n");
	xb->token = NO_TOKEN;
	return parseSingleType(cntxt, xb);
}

STATIC int 
parseTreatExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseTreatExpr)@
	if (parseCastableExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (curToken(xb) != XT_treat)
		return PARSE_ERR;
	if (nextToken(xb) != XT_as)
		return xqryError(cntxt,"'as' expected in TreatExpr\n");
	xb->token = NO_TOKEN;
	return parseSequenceType(cntxt, xb);
}

STATIC int 
parseInstanceOfExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseInstanceOfExpr)@
	if (parseTreatExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (curToken(xb) != XT_instance)
		return PARSE_ERR;
	if (nextToken(xb) != XT_of)
		return xqryError(cntxt,"'of' expected in InstanceOfExpr\n");
	xb->token = NO_TOKEN;
	return parseSequenceType(cntxt, xb);
}

STATIC int 
parseIntersectExceptExpr(Client cntxt, Xbackend xb) 
{
	int res = PARSE_OK;

	@:ptrace(parseIntersectExceptExpr)@
	if ((res = parseInstanceOfExpr(cntxt, xb)) != PARSE_OK)
		return res;
	do {
		if (curToken(xb) == XT_intersect) {
		} else if (curToken(xb) == XT_except) {
		} else 
			break;
		xb->token = NO_TOKEN;
	} while ((res = parseInstanceOfExpr(cntxt, xb)) == PARSE_OK);
	@:etrace(parseIntersectExceptExpr)@
	return res;
}

STATIC int 
parseUnionExpr(Client cntxt, Xbackend xb) 
{
	int res = PARSE_OK;

	@:ptrace(parseUnion)@
	if ((res = parseIntersectExceptExpr(cntxt, xb)) != PARSE_OK)
		return res;
	do {
		if (curToken(xb) == '|') {
		} else if (curToken(xb) == XT_union) {
		} else
			break;
		xb->token = NO_TOKEN;
	} while ((res = parseIntersectExceptExpr(cntxt, xb)) == PARSE_OK);
	@:etrace(parseUnion)@
	return res;
}

STATIC int 
parseMultiplicativeExpr(Client cntxt, Xbackend xb) 
{
	int res = PARSE_OK;
	str op;

	@:ptrace(parseMultiplicativeExpr)@
	if ((res = parseUnionExpr(cntxt, xb)) != PARSE_OK)
		return res;
	do {
		if (curToken(xb) == '*') {
			nextToken(xb);
			op="*";
		} else if (curToken(xb) == XT_div) {
			op= "/";
		} else if (curToken(xb) == XT_idiv) {
			op= "/";
		} else if (curToken(xb) == XT_mod) {
			op= "%";
		} else
			break;
		xb->token = NO_TOKEN;
		res= parseUnionExpr(cntxt, xb);
		if( res == PARSE_OK){
			xqryCoercion(xb);
			xqryStatement(xb,"calc",op,2);
		}
	} while (res == PARSE_OK);
	@:etrace(parseMultiplicativeExpr)@
	return res;
}

STATIC int 
parseAdditiveExpr(Client cntxt, Xbackend xb) 
{
	int res = PARSE_OK;
	char op[2]={0,0};

	@:ptrace(parseAdditiveExpr)@
	if ((res = parseMultiplicativeExpr(cntxt, xb)) != PARSE_OK)
		return res;
	do {
		if (curToken(xb) == '+' || curToken(xb) == '-') {
			op[0] = (char) curToken(xb);
			nextToken(xb);
		} else
			break;
		res = parseMultiplicativeExpr(cntxt, xb);
		if( res== PARSE_OK){
			/* we have two variables on the stack */
			xqryCoercion(xb);
			xqryStatement(xb,"calc",(str)op,2);
		}
	} while(res == PARSE_OK);
	@:etrace(parseAdditiveExpr)@
	return res;
}

STATIC int 
parseRangeExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseRangeExpr)@
	if (parseAdditiveExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (curToken(xb) == XT_to)
		return parseRangeExpr(cntxt, xb);
	return PARSE_ERR;
}

STATIC int 
parseComparisonExpr(Client cntxt, Xbackend xb) 
{
	str op="unknown", mod="calc";
	int ret;

	(void) op; (void) mod;
	@:ptrace(parseComparisonExpr)@
	if (parseRangeExpr(cntxt, xb) == PARSE_OK) {
		/* NodeComp */
		if (curToken(xb) == XT_ltlt) {
			op= "<<"; mod="mguide";
		} else if (curToken(xb) == XT_gtgt) {
			op= ">>"; mod="mguide";
		} else if (curToken(xb) == XT_is) {
			op= "is"; mod="mguide";
		} else
		/* ValueComp | GeneralComp | NodeComp) RangeExpr)? */
		if (curToken(xb) == XT_eq) {
			op= "="; mod="xqry";
		} else if (curToken(xb) == XT_ne) {
			op= "!="; mod="batcalc";
		} else if (curToken(xb) == XT_le) {
			op= "<="; mod="batcalc";
		} else if (curToken(xb) == XT_ge) {
			op= ">="; mod="batcalc";
		} else if (curToken(xb) == XT_gt) {
			op= ">"; mod="batcalc";
		} else if (curToken(xb) == XT_lt) {
			op= "<"; mod="batcalc";
		} else {
			@:etrace(parseComparisonExpr)@
			return PARSE_OK;
		}
		nextToken(xb);
		ret = parseRangeExpr(cntxt, xb);
		if( ret == PARSE_OK){
			xqryCoercion(xb);
			xqryStatement(xb,mod,op,2);
		}
		@:etrace(parseComparisonExpr)@
		return ret;
	}
	return xqryError(cntxt,"<ComparisonOperator> expected\n");
}

STATIC int 
parseAndExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseAndExpr)@
	if (parseComparisonExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (curToken(xb) != XT_and) 
		return PARSE_OK;
	return parseAndExpr(cntxt, xb);
}

STATIC int 
parseOrExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseOrExpr)@
	if (parseAndExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (curToken(xb) != XT_or) 
		return PARSE_OK;
	return parseOrExpr(cntxt, xb);
}

STATIC int 
parseQuantifiedExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseQuantifiedExpr)@
	if (curToken(xb) != XT_some && curToken(xb) != XT_every)
		return PARSE_ERR;
	do {
		if (curToken(xb) == ',')
			nextToken(xb);
		if (parseVarName(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		parseTypeDeclaration(cntxt, xb);
		if (curToken(xb) == XT_in)
			return PARSE_ERR;
		xb->token = NO_TOKEN;
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		/* clean up */
		xqryNew(xb);
	} while (curToken(xb) == ',');
	if (curToken(xb) != XT_satisfies)
		return xqryError(cntxt,"'satisfies' expected\n");
	xb->token = NO_TOKEN;
	if (parseExprSingle(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	@:etrace(parseQuantifiedExpr)@
	return PARSE_OK;
}

STATIC int 
parseExprSingle(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseExprSingle)@
	if (curToken(xb) == XT_for || curToken(xb) == XT_let) 
		return parseFLWORExpr(cntxt, xb);
	if (parseIfExpr(cntxt, xb) == PARSE_OK ||
	    parseTypeswitchExpr(cntxt, xb) == PARSE_OK ||
	    parseQuantifiedExpr(cntxt, xb) == PARSE_OK ||
	    parseEnclosedExpr(cntxt,xb) == PARSE_OK ||
	    parseOrExpr(cntxt,xb)== PARSE_OK){
		@:etrace(parseExprSingle)@
		return PARSE_OK;
	}
	return parseOrExpr(cntxt, xb);
}

STATIC
int parseExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseExpr)@
	do {
		if (curToken(xb) == ',')
			nextToken(xb);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
	} while (curToken(xb) == ',');
	@:etrace(parseExpr)@
	return PARSE_OK;
}

STATIC int 
parseCaseClause(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseCaseClause)@
	if (curToken(xb) != XT_case)
		return PARSE_ERR;
	xb->token = NO_TOKEN;
	if (parseVarName(cntxt, xb) == PARSE_OK) {
		if (curToken(xb) != XT_as)
			return xqryError(cntxt,"'as' expected in CaseClause\n");
		xb->token = NO_TOKEN;
	}
	if (parseSequenceType(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	return parseReturnExprSingle(cntxt, xb);
}

STATIC int 
parseTypeswitchExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseTypeSwitch)@
	if (curToken(xb) != XT_typeswitch)
		return PARSE_ERR;
	if (nextToken(xb) != '(') 
		return xqryError(cntxt,"'(' expected in TypeswitchExpr\n");
	xb->token = NO_TOKEN;
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in TypeswitchExpr\n");
	if (curToken(xb) != ')')
		return xqryError(cntxt,"')' expected in TypeswitchExpr\n");
	xb->token = NO_TOKEN;
	while (parseCaseClause(cntxt, xb) == PARSE_OK);
	if (curToken(xb) != XT_default)
		return xqryError(cntxt,"'default' expected in TypeswitchExpr\n");
	xb->token = NO_TOKEN;
	return parseReturnExprSingle(cntxt, xb);
}

STATIC int 
parseIfExpr(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseIfExpr)@
	if (curToken(xb) != XT_if)
		return PARSE_ERR;
	if (nextToken(xb) != '(') 
		return xqryError(cntxt,"'(' expected in IfExpr\n");
	xb->token = NO_TOKEN;
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in IfExpr\n");
	if (curToken(xb) != ')') 
		return xqryError(cntxt,"')' expected in IfExpr\n");
		
	if (nextToken(xb) != XT_then)
		return xqryError(cntxt,"'then' expected in IfExpr\n");
	xb->token = NO_TOKEN;
	if (parseExprSingle(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in IfExpr\n");
	if (nextToken(xb) != XT_else) /* else isn't optional */
		return xqryError(cntxt,"'else' expected in IfExpr\n");
	xb->token = NO_TOKEN;
	return parseExprSingle(cntxt, xb);
}

STATIC int 
parseReturnExprSingle(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseReturnExprSingle)@
	if (curToken(xb) != XT_return)
		return PARSE_ERR;
	xb->token = NO_TOKEN;
	return parseExprSingle(cntxt, xb);
}

STATIC int 
parseOrderByClause(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseOrderByClause)@
	if (curToken(xb) == XT_stable) {
		nextToken(xb);
	}
		
	if (curToken(xb) != XT_order)
		return xqryError(cntxt,"'order' expected in OrderByClause\n");
	if (nextToken(xb) != XT_by)
		return xqryError(cntxt,"'by' expected in OrderByClause\n");
	xb->token = NO_TOKEN;
	do {
		if (curToken(xb) == ',')
			nextToken(xb);
		if (parseExprSingle(cntxt, xb) == PARSE_OK) {
			/* TODO check order modifier */
			if (curToken(xb) == XT_ascending) {
			} else if (curToken(xb) == XT_descending) {
			} else if (curToken(xb) == XT_empty) {
			} else if (curToken(xb) == XT_greatest) {
			} else if (curToken(xb) == XT_least) {
			} else if (curToken(xb) == XT_collation) {
				xb->token = NO_TOKEN;
				/* parse URILiteral */
				if (curToken(xb) == XT_STR) {
				}
			}
		} else {
			return PARSE_ERR;
		}
	} while (curToken(xb) == ',');
	@:etrace(parseOrderByClause)@
	return PARSE_OK;
}

STATIC int 
parseForClause(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseForClause)@
	do {
		InstrPtr p;
		int l,r;
		char *vname = NULL;

		if (curToken(xb) == ',')
			nextToken(xb);
		if (parseVarName(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<VarName> expected in ForClause\n");
		vname = xb->sval;
		if (curToken(xb) != XT_in) {
			parseTypeDeclaration(cntxt, xb);
			parsePositionalVar(cntxt, xb);
		}
		if (curToken(xb) != XT_in)
			return xqryError(cntxt,"'in' expected in ForClause\n");
		nextToken(xb);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<ExprSingle> expected in ForClause\n");
		l = newVariable(xb->mb, _strdup(vname), TYPE_any);
		XsetId(xb, vname, l);
		r = popXvar(xb);
 		p = newAssignment(xb->mb);
		getArg(p,0) = l;
		pushArgument(xb->mb, p, r);
		/* clean up */
		xqryNew(xb);
	} while (curToken(xb) == ',');
	@:etrace(parseForClause done)@
	return PARSE_OK;
}

STATIC int 
parseLetClause(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseLetClause)@
	do {
		InstrPtr p;
		int l,r;
		char *vname = NULL;

		if (curToken(xb) == ',')
			nextToken(xb);
		if (parseVarName(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<VarName> expected in LetClause\n");
		vname = xb->sval;
		parseTypeDeclaration(cntxt, xb);
		if (curToken(xb) != XT_ASSIGN)
			return xqryError(cntxt,"':=' expected in LetClause\n");
		xb->token = NO_TOKEN;
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<ExprSingle> expected in LetClause\n");
		l = newVariable(xb->mb, _strdup(vname), TYPE_any);
		XsetId(xb, vname, l);
		r = popXvar(xb);
 		p = newAssignment(xb->mb);
		getArg(p,0) = l;
		pushArgument(xb->mb, p, r);
		/* clean up */
		xqryNew(xb);
		
	} while (curToken(xb) == ',');
	@:etrace(parseLetClause done)@
	return PARSE_OK;
}

STATIC int 
parseFLWORExpr(Client cntxt, Xbackend xb) 
{
	int ret = PARSE_OK;
	@:ptrace(parseFLWORExpr)@
	do {
		if (curToken(xb) == XT_for) {
			xb->token = NO_TOKEN;
			ret = parseForClause(cntxt, xb);
		} else if (curToken(xb) == XT_let) {
			xb->token = NO_TOKEN;
			ret = parseLetClause(cntxt, xb);
		} else {
			break;
		}
	} while (ret == PARSE_OK);
	if (ret == PARSE_ERR)
		return PARSE_ERR;
	if (curToken(xb) == XT_where) {
		xb->token = NO_TOKEN;
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<ExprSingle> expected in FLWORExpr\n");
	}
	if (curToken(xb) == XT_order || curToken(xb) == XT_stable) 
		if (parseOrderByClause(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
	ret = parseReturnExprSingle(cntxt, xb);
	if (ret == PARSE_OK) {
		if (xb->X.h) {
			InstrPtr p;
			ValRecord val;
	
			val.vtype = TYPE_str;
			val.val.sval = xqryXpathFlatten(xb);
			p = newAssignment(xb->mb);
			getArg(p,0) = pushXvar(xb);
			pushArgument(xb->mb, p, defConstant(xb->mb, val.vtype, &val));
			xqryStatement(xb,"xqry","bind",2);
		}
	}
	return ret;
}

STATIC int 
parseParam(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseParam)@
	if (curToken(xb) != '$')
		return PARSE_ERR;
	nextToken(xb);
	if (parseQName(cntxt,xb) == PARSE_ERR) 
		return xqryError(cntxt,"<QName> expected in Param\n");
	parseTypeDeclaration(cntxt, xb);
	return PARSE_OK;
}

STATIC int 
parseParamList(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseParamList)@
	if (parseParam(cntxt, xb) == PARSE_OK)
	do {
		if (curToken(xb) != ','){
			@:etrace(parseParamList)@
			return PARSE_OK;
		}
		xb->token = NO_TOKEN;
	} while (parseParam(cntxt, xb));
	return PARSE_ERR;
}

STATIC int 
parseFunctionDecl(Client cntxt, Xbackend xb, int declare) 
{
	@:ptrace(parseFunctionDecl)@
	if (declare) {
		if (curToken(xb) != XT_declare) 
			return PARSE_ERR; 
		else
			nextToken(xb);
	}
	if (curToken(xb) != XT_function)
		return PARSE_ERR;
	if (nextToken(xb) != XT_FNAME) 
		return xqryError(cntxt,"<Qname> expected in FunctionDecl\n");
	nextToken(xb);
	parseParamList(cntxt, xb);
	if (curToken(xb) != ')')
		return xqryError(cntxt,"')' expected in FunctionDecl\n");
	if (nextToken(xb) == XT_as) {
		nextToken(xb);
		parseSequenceType(cntxt, xb);
	}
	if (curToken(xb) == XT_external) {
		xb->token = NO_TOKEN;
		return PARSE_OK;
	}
	@:etrace(parseFunctionDecl)@
	return parseEnclosedExpr(cntxt, xb);
}

STATIC int 
parseConstructionDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseConstructionDecl)@
	if (curToken(xb) != XT_construction)
		return PARSE_ERR;
	if (nextToken(xb) == XT_strip || xb->token == XT_preserve) {
		@:etrace(parseConstructionDecl)@
		xb->token = NO_TOKEN;
		return PARSE_OK;
	}
	return xqryError(cntxt,"'strip' or 'preserve' expected in ConstructionDecl\n");
}

STATIC int 
parseVarDecl(Client cntxt, Xbackend xb, int declare) 
{
	@:ptrace(parseVarDecl)@
	if (declare) {
		if (curToken(xb) != XT_declare) 
			return PARSE_ERR; 
		else	 
			nextToken(xb);
	}
	if (curToken(xb) != XT_variable)
		return PARSE_ERR;
	if (nextToken(xb) != '$')
		return PARSE_ERR;
	nextToken(xb);
	if (parseQName(cntxt,xb) == PARSE_ERR) 
		return xqryError(cntxt,"<QName> expected in VarDecl\n");
	parseTypeDeclaration(cntxt, xb);

	if (curToken(xb) == XT_external) {
		xb->token = NO_TOKEN;
		return PARSE_OK;
	}
	if (curToken(xb) == XT_ASSIGN) {
		nextToken(xb);
		return parseExprSingle(cntxt, xb);
	}
	return xqryError(cntxt,"'external' or ':=' expected in VarDecl\n");
}

STATIC int 
parseModuleImport(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseModuleImport)@
	if (curToken(xb) != XT_module)
		return xqryError(cntxt,"'module' expected in ModuleImport\n");

	if (nextToken(xb) ==  XT_namespace) {
		if (nextToken(xb) != XT_eq)
			return xqryError(cntxt,"'=' expected in ModuleImport\n");
	}
	if (nextToken(xb) != XT_STR)
		return xqryError(cntxt,"<URIliteral> expected in ModuleImport\n");
	if (nextToken(xb) != XT_at)
		return xqryError(cntxt,"'at' expected in ModuleImport\n");
	if (nextToken(xb) != XT_STR)
		return xqryError(cntxt,"<URIliteral> expected in ModuleImport\n");
	while (nextToken(xb) == ',') {
		if (nextToken(xb) != XT_STR)
			return xqryError(cntxt,"<URIliteral> expected in ModuleImport\n");
	}
	@:etrace(parseModuleImport)@
	return PARSE_OK;
}

STATIC int 
parseSchemaPrefix(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseSchemaPrefix)@
	if( curToken(xb) == XT_namespace) {
		if (nextToken(xb) != XT_NCNAME) 
			return xqryError(cntxt,"<NCName> expected in SchemaPrefix\n");
		if (nextToken(xb) != XT_eq)
			return xqryError(cntxt,"'=' expected in SchemaPrefix\n");
		@:etrace(parseSchemaPrefix)@
		xb->token = NO_TOKEN;
		return PARSE_OK;
	} else if (xb->token == XT_default) {
		if (nextToken(xb) == XT_element && 
		    nextToken(xb) ==  XT_namespace) {
			@:etrace(parseSchemaPrefix)@
			xb->token = NO_TOKEN;
			return PARSE_OK;
		}
		return xqryError(cntxt,"'element' 'namespace' expected in SchemaPrefix\n");
	}
	/* parseSchemaPrefix is optional */
	@:etrace(parseSchemaPrefix)@
	return PARSE_ERR;
}

STATIC int 
parseSchemaImport(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseSchemaImport)@
	if (curToken(xb) != XT_schema)
		return PARSE_ERR;
	nextToken(xb);
	parseSchemaPrefix(cntxt, xb);
	if (curToken(xb) != XT_STR)
		return xqryError(cntxt,"<URIliteral> expected in SchemaImport\n");
	if (nextToken(xb) != XT_at)
		return xqryError(cntxt,"'at' expected in SchemaImport\n");
	if (nextToken(xb) != XT_STR)
		return xqryError(cntxt,"<URIliteral> expected in SchemaImport\n");
	while (nextToken(xb) == ',') {
		if (nextToken(xb) != XT_STR)
			return xqryError(cntxt,"<URIliteral> expected in SchemaImport\n");
	}
	@:etrace(parseSchemaImport)@
	return PARSE_OK;
}

STATIC int 
parseBaseURIDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseBaseURIDecl)@
	if (curToken(xb) != XT_base_uri)
		return PARSE_ERR;
	if (nextToken(xb) != XT_STR)
		return xqryError(cntxt,"<URIliteral> expected in BaseURIDecl\n");
	@:etrace(parseBaseURIDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseDefaultCollationDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseDefaultCollationDecl)@
	if (curToken(xb) != XT_collation)
		return xqryError(cntxt,"'collation' expected in DefaultCollationDecl\n");
	if (nextToken(xb) != XT_STR)
		return xqryError(cntxt,"<URIliteral> expected in DefaultCollationDecl\n");
	@:etrace(parseDefaultCollationDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

/* pathfinder doesn't have copy-namespaces but xmlspace, for compatibility  */
STATIC int 
parseXmlspace(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseXmlspace)@
	if (curToken(xb) != XT_xmlspace)
		return PARSE_ERR;
	if (nextToken(xb) != XT_preserve && curToken(xb) != XT_inherit && curToken(xb) != XT_strip) 
		return xqryError(cntxt,"'preserve', 'inherit' or 'strip' expected in Xmlspace\n");
	xb->token = NO_TOKEN;
	@:etrace(parseXmlspace)@
	return PARSE_OK;
}
/* pathfinder has short hand for copy-namespaces inherit, compatibility  */
STATIC int 
parseInheritNamespaces(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseInheritNamespaces)@
	if (curToken(xb) != XT_inherit_namespaces)
		return PARSE_ERR;
	if (nextToken(xb) != XT_yes) 
		return xqryError(cntxt,"'yes' expected in InheritNamespaces\n");
	xb->token = NO_TOKEN;
	@:etrace(parseInheritNamespaces)@
	return PARSE_OK;
}

STATIC int 
parseCopyNamespacesDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseCopyNamespacesDecl)@
	if (curToken(xb) != XT_copy_namespaces)
		return PARSE_ERR;
	if (nextToken(xb) != XT_preserve && curToken(xb) != XT_no_preserve) 
		return xqryError(cntxt,"'preserve' or 'no-preserve' expected in CopyNamespacesDecl\n");
	if (nextToken(xb) != ',')
		return xqryError(cntxt,"',' expected in CopyNamespacesDecl\n");
	if (nextToken(xb) != XT_inherit && curToken(xb) != XT_no_inherit) 
		return xqryError(cntxt,"'inherit' or 'no-inherit' expected in CopyNamespacesDecl\n");
	@:etrace(parseCopyNamespacesDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseEmptyOrderDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseEmptyOrderDecl)@
	if (curToken(xb) != XT_order)
		return PARSE_ERR;
	if (nextToken(xb) != XT_empty)
		return xqryError(cntxt,"'empty' expected in EmptyOrderDecl\n");
	if (nextToken(xb) != XT_greatest && xb->token != XT_least)
		return xqryError(cntxt,"'greatest' or 'least' expected in EmptyOrderDecl\n");
	xb->token = NO_TOKEN;
	@:etrace(parseEmptyOrderDecl)@
	return PARSE_OK;
}

STATIC int 
parseOrderingModeDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseOrderingModeDecl)@
	if (curToken(xb) != XT_ordering)
		return PARSE_ERR;
	if (nextToken(xb) != XT_ordered  && xb->token != XT_unordered)
		return xqryError(cntxt,"'ordered' or 'unordered' expected in OrderingModuleDecl\n");
	@:etrace(parseOrderingModeDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseOptionDecl(Client cntxt, Xbackend xb, int declare) 
{
	@:ptrace(parseOptionDecl)@
	if (declare) {
		if (curToken(xb) != XT_declare) 
			return PARSE_ERR; 
		else
			nextToken(xb);
	}
	if (curToken(xb) != XT_option)
		return PARSE_ERR;
	nextToken(xb);
	if (parseQName(cntxt,xb) == PARSE_ERR) 
		return xqryError(cntxt,"<QName> expected in OptionDecl\n");
	if (curToken(xb) != XT_STR)
		return xqryError(cntxt,"<URIliteral> expecte in OptionDecld\n");
	@:etrace(parseOptionDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseDefaultNamespaceDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseDefaultNamespaceDecl)@
	if (curToken(xb) != XT_element && curToken(xb) != XT_function)
		return PARSE_ERR;
	if (nextToken(xb) != XT_namespace)
		return xqryError(cntxt,"'namespace' expected in DefaultNamespaceDecl\n");
	if (nextToken(xb) != XT_STR)
		return xqryError(cntxt,"<URIliteral> expected in DefaultNamespaceDecl\n");
	/* TODO: use default namespace URI */
	@:etrace(parseDefaultNamespaceDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseNamespaceDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseNamespaceDecl)@
	if (curToken(xb) != XT_namespace)
		return PARSE_ERR;
	if (nextToken(xb) != XT_NCNAME) 
		return xqryError(cntxt,"<NCName> expected in NamespaceDecl\n");
	/* TODO: save namespace name */
	if (nextToken(xb) != XT_eq)
		return xqryError(cntxt,"'=' expected in NamespaceDecl\n");
	if (nextToken(xb) != XT_STR)
		return xqryError(cntxt,"<URIliteral> expected in NamespaceDecl\n");
	/* TODO: use namespace URI */
	@:etrace(parseNamespaceDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseBoundarySpaceDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseBoundarySpaceDecl)@
	if (curToken(xb) != XT_boundary_space)
		return PARSE_ERR;
	if (nextToken(xb) != XT_preserve && xb->token != XT_strip)
		return xqryError(cntxt,"'preserve' or 'strip' expected in BoundarySpaceDecl\n");
	@:etrace(parseBoundarySpaceDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseImport(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseImport)@
	if( curToken(xb) != XT_import) 
		return PARSE_ERR; 
	nextToken(xb);
	if (parseSchemaImport(cntxt, xb) != PARSE_OK &&
	    parseModuleImport(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

STATIC int 
parseSetter(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseSetter)@
	if (parseBoundarySpaceDecl(cntxt, xb) != PARSE_OK &&
	    parseBaseURIDecl(cntxt, xb) != PARSE_OK &&
	    parseConstructionDecl(cntxt, xb) != PARSE_OK &&
	    parseOrderingModeDecl(cntxt, xb) != PARSE_OK &&
	    parseCopyNamespacesDecl(cntxt, xb) != PARSE_OK &&
	    parseXmlspace(cntxt, xb) != PARSE_OK &&
	    parseInheritNamespaces(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	@:etrace(parseSetter)@
	return PARSE_OK;
}

STATIC int 
parseProlog(Client cntxt, Xbackend xb) 
{
	int declare = 1;
	@:ptrace(parseProlog)@
	do {
		if (curToken(xb) == XT_declare) {
			nextToken(xb);
			if (curToken(xb) == XT_default) {
				nextToken(xb);
				if (parseDefaultNamespaceDecl(cntxt, xb) != PARSE_OK && 
	    			    parseEmptyOrderDecl(cntxt, xb) != PARSE_OK &&
	    			    parseDefaultCollationDecl(cntxt, xb) != PARSE_OK) {
					declare = 0;
					break;
				}
			} else if (parseSetter(cntxt, xb) != PARSE_OK &&
			           parseNamespaceDecl(cntxt, xb) != PARSE_OK) {
				declare = 0;
				break;
			}
		} else if (parseImport(cntxt, xb) == PARSE_ERR)
			break;
		if (curToken(xb) != ';')
			break;
		nextToken(xb);
	} while (1);

	do {
		if (parseVarDecl(cntxt, xb, declare) != PARSE_OK &&
		    parseFunctionDecl(cntxt, xb, declare) != PARSE_OK &&
		    parseOptionDecl(cntxt, xb, declare) != PARSE_OK)
			break;
		declare = 1;
		if (curToken(xb) != ';')
			break;
		nextToken(xb);
	} while (1);
	@:etrace(parseProlog)@
	return PARSE_OK;
}

STATIC int 
parseModuleDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseModuleDecl)@
	if (curToken(xb) != XT_module) 
		return PARSE_ERR;
	if (nextToken(xb) != XT_namespace)
		return xqryError(cntxt,"'namespace' expected in ModuleDecl\n");
	if (nextToken(xb) != XT_NCNAME)
		return xqryError(cntxt,"<NCName> expected in ModuleDecl\n");
	if (nextToken(xb) != XT_eq)
		return xqryError(cntxt,"'=' expected in ModuleDecl\n");

	/* TODO: add URI parsing */
	if (nextToken(xb) != XT_STR) 
		return xqryError(cntxt,"<URILiteral> expected in ModuleDecl\n");
	if (nextToken(xb) != ';') 
		return xqryError(cntxt,"';' expected in ModuleDecl\n");
	@:etrace(parseModuleDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseLibraryModule(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseLibraryModule)@
	if (parseModuleDecl(cntxt, xb) != PARSE_OK) 
		return PARSE_ERR;
	if (parseProlog(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	@:etrace(parseLibraryModule)@
	return PARSE_OK;
}

STATIC int 
parseMainModule(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseMainModule)@
	parseProlog(cntxt, xb);
	/* QueryBody */
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	@:etrace(parseMainModule)@
	return PARSE_OK;
}

STATIC int 
parseVersionDecl(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseVersionDecl)@
	if (curToken(xb) != XT_xquery) 
		return PARSE_ERR;
	if (nextToken(xb) != XT_version)
		return xqryError(cntxt,"'version' expected in VersionDecl\n");
	if (nextToken(xb) != XT_STR)
		return xqryError(cntxt,"<StringLiteral> expected in VersionDecl\n");
	/* TODO: use the version string */
	/* optional encoding string */
	if (nextToken(xb) == XT_encoding) {
		if (nextToken(xb) != XT_STR) {
			return xqryError(cntxt,"<StringLiteral> expected in VersionDecl\n");
		} else {
			/* TODO: use the encoding string */
			nextToken(xb);
		}
	}
	if (curToken(xb) != ';')
		return xqryError(cntxt,"';' expected in VersionDecl\n");
	@:etrace(parseVersionDecl)@
	xb->token = NO_TOKEN;
	return PARSE_OK;
}

STATIC int 
parseXQueryModule(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseModule)@
	parseVersionDecl(cntxt, xb);
	if (parseLibraryModule(cntxt, xb) != PARSE_OK &&
	    parseMainModule(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	@:etrace(parseModule)@
	return PARSE_OK;
}

int 
parseXQuery(Client cntxt) 
{
	Xbackend xb = BE(cntxt);
	int ret = PARSE_OK;

	xb->token = NO_TOKEN;
	if (nextToken(xb) == XT_explain)
		xb->mode= xqry_explain;
	else if (curToken(xb) == XT_debug)
		xb->mode= xqry_debug;
	else if (curToken(xb) == XT_trace)
		xb->mode= xqry_trace;
	else if (curToken(xb) == XT_quit) {
		cntxt->mode = FINISHING;
		return 0;
	}

	/* leading whitespace and comments are skipped */
	if (curToken(xb) == EOF)
		return (xb->xs->started)?PARSE_ERR:PARSE_OK;

	ret = parseXQueryModule(cntxt, xb);
#ifdef _XQRY_DEBUG
		stream_printf(cntxt->fdout, "PARSE %s\n",
				  ret == PARSE_OK ? "OK" : "ERR");
		stream_flush(cntxt->fdout);
#endif
	return ret;
}

@-
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input .
This code fragment is largely copied from the MAL parser, which also
included an automatic skiptoend not required here.
@c
int
xqryError(Client cntxt, str msg)
{
	Xbackend xb = BE(cntxt);
	Symbol curPrg;
	MalBlkPtr curBlk;
	char buf[10 * 1024];
	char *s = buf, *t, *l = lastline(cntxt);
	long i;
#ifdef _XQRY_DEBUG
	stream_printf(GDKout,"!ERROR: curToken= %s\n",XT2string(curToken(xb)));
#endif

	xb->token = NO_TOKEN;
	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	if (curBlk)
		curBlk->errors++;

	/* accidental %s directives in the lastline can
	   crash the vfsprintf later => escape them */
	for (t = l; *t && *t != '\n'; t++) {
		if (*t == '%')
			*s++ = '%';
		*s++ = *t;
	}
	*s++ = '\n';
	*s++ = '!';
	/* produce the position marker */
	i = position(cntxt) + strlen(GDKERROR) - 1;
	for (; i > 0; i--) {
		*s++ = ((l && *(l + 1) && *l++ != '\t')) ? ' ' : '\t';
	}
	*s++ = '^';
	*s = 0;

	if (msg == 0)
		msg = "can't help you here, sorry.\n";
	if (strlen(msg) + strlen(buf) < 1020)
		snprintf(s, 1020, "%s", msg);
	GDKerror(buf);
#ifdef _XQRY_DEBUG
	stream_printf(GDKout,"%s",buf);
#endif
	return PARSE_ERR;
}


@}
