@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f xqry_parser
@a M. L. Kersten
@v 0.1
@+ XQuery Compilation
MonetDB supports several front-ends. One of those is XQuery
as defined by W3C. 
The version shipped with MonetDB Version 4 is based on the seminal
work at Konstanz and Munich, which use a schema agnostic approach
to prepresent the document and derive query plans.

The 'older' method designed and used in conjunction with the XMark
benchmark worked with path summaries. This provides an extreme
partitioning scheme of the database.

The sample compilation shown below has been designed as a proof
of concept that compilation of valid xqueries of the complexity
of the XMark benchmark can indeed be processed using the MonetDB
guide.

@{
@+ Implementation notes
The XQuery parser is a recursive-descend implementation.
The parser produced follows the structure of the MAL parser
and produces a MAL block for direct execution.

The grammar is taken from W3C website.
@}
@+ Conversion Pitfalls
In this section we summarize the pitfalls and limitations encountered
in using the XQuery to MAL compiler.
The grammar is spread over a large code base, but the naming is kept
close to its use in the W3C documents.
@{
@+ The lexical analyzer
It uses the features offered by the MAL parser.
The key structured is a XML context descriptor,
which keeps track of all retrictics made sofar
on the document tree.
@h
#ifndef _XQRY_PARSER_H
#define _XQRY_PARSER_H

#define STATIC static

#include "xqry.h"
#include "xqry_gencode.h"

#include "mal_builder.h"
#include "mal_parser.h"
#include <mal_prelude.h>

#undef currChar

#define PARSE_OK 0
#define PARSE_ERR -1

xqry_export str XQRYcompile(str qry);
xqry_export str XQRYexec(int ret, str qry);

xqry_export void XQRYinit();
xqry_export int parseXQuery(Client cntxt);

#define _XQRY_DEBUG 1	/* debugging option */

#endif /* _XQRY_PARSER_H */
@-
It helps during development to trace the parser actions.
It can be extended with relevant Xbackend dumps.
@= ptrace
#ifdef _XQRY_DEBUG
{ 	str dummy = GDKstrdup(CURRENT(cntxt));
	if( strlen(dummy) >25) strcpy(dummy+25,"...\n");
	if( strlen(dummy) == 0){
		dummy[0] = '\n';
		dummy[1] = 0;
	}
	if( oldtrace==0 || strcmp(oldtrace,dummy))
		stream_printf(cntxt->fdout,"@1[%s",dummy);
	if( oldtrace)
		GDKfree(oldtrace);
	oldtrace= dummy;
}
#endif
@= etrace
#ifdef _XQRY_DEBUG
{ 	str dummy = GDKstrdup(CURRENT(cntxt));
	if( strlen(dummy) >25) strcpy(dummy+25,"...\n");
	if( strlen(dummy) == 0){
		dummy[0] = '\n';
		dummy[1] = 0;
	}
	stream_printf(cntxt->fdout,"@1]%s",dummy);
	GDKfree(dummy);
}
#endif
@c
#include "xqry_parser.h"
#include "mal_interpreter.h"

#define BE(X) ((Xbackend)(X->state[PARSER]))
#define needMore(X)  currChar(X)	/* need at least one more character */
#define advanceMore(X,Y) {advance(X,Y); needMore(X);}

#define XPATHLENGTH 1024

str oldtrace=0;

extern int xqryError(Client cntxt, str msg);

@-
The XQuery parser may request for more information to 
complete a parsing request.
@c

char
currChar(Client c)
{
	if (*CURRENT(c) == 0) {
		MALreader(c);
		c->yycur = 0;
	}
	return *CURRENT(c);
}




@+ The Parser
Unlike MonetDB V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

@+ The parser
The Xquery parser uses the recursive descent method,
producing MAL code on the fly as needed.
Given the FLWOR expression this might not be optimal,
but further tuning is left to the backend.
@c
STATIC int parseIfExpr(Client cntxt, Xbackend xb);
STATIC int parseReturnExprSingle(Client cntxt, Xbackend xb);
STATIC int parseFLWORExpr(Client cntxt, Xbackend xb);
STATIC int parseTypeswitchExpr(Client cntxt, Xbackend xb);
STATIC int parseExpr(Client cntxt, Xbackend xb);
STATIC int parseExprSingle(Client cntxt, Xbackend xb);
STATIC int parseDirectConstructor(Client cntxt, Xbackend xb);

STATIC short idCharacter[256];
STATIC short idCharacter2[256];

void 
XQRYinit()
{
	int i;

	for (i = 0; i < 256; i++){
		idCharacter2[i]= isalpha(i) || isdigit(i);
		idCharacter[i] = isalpha(i);
	}
	idCharacter[(int)'_'] = 1;
	idCharacter2[(int)'_'] = 1;
	idCharacter2[(int)'-'] = 1;
	idCharacter2[(int)'.'] = 1;
}

INLINE void
xqrySkipSpace(Client cntxt)
{
    char *s= CURRENT(cntxt);
    for (;;) {
        switch (*s++) {
        case ' ':
        case '\t':
        case '\n':
        case '\r':
            nextChar(cntxt);
            break;
        default:
            return;
        }
    }
}

int
xqryLookahead(Client cntxt, str kw, int length)
{
    int i;

    xqrySkipSpace(cntxt);
    /* avoid double test or use lowercase only. */
    if (currChar(cntxt) == *kw &&
        strncmp(CURRENT(cntxt), kw, length) == 0 &&
        !idCharacter[(int) (CURRENT(cntxt)[length])] &&
        !isdigit((int) (CURRENT(cntxt)[length])) ) {
        return 1;
    }
     /* check for captialized versions */
    for (i = 0; i < length; i++)
        if (tolower(CURRENT(cntxt)[i]) != kw[i])
            return 0;
    if (!idCharacter[(int) (CURRENT(cntxt)[length])] &&
        !isdigit((int) (CURRENT(cntxt)[length])) ) {
        return 1;
    }
    return 0;
}

int
xqryKeyword(Client cntxt, str kw, int length)
{
    xqrySkipSpace(cntxt);
    if (xqryLookahead(cntxt, kw, length)) {
        advance(cntxt, length);
        return 1;
    }
    return 0;
}
INLINE int
xqryKeyphrase1(Client cntxt, str kw)
{
    xqrySkipSpace(cntxt);
    if (currChar(cntxt) == *kw) {
        advance(cntxt,1);
        return 1;
    }
    return 0;
}

INLINE int
xqryKeyphrase2(Client cntxt, str kw)
{
    xqrySkipSpace(cntxt);
    if (CURRENT(cntxt)[0] == kw[0] && CURRENT(cntxt)[1] == kw[1]) {
        advance(cntxt,2);
        return 1;
    }
    return 0;
}
INLINE int
xqryKeyphrase(Client cntxt, str kw,int length)
{
    xqrySkipSpace(cntxt);
    if( strncmp(CURRENT(cntxt),kw,length)== 0){
        advance(cntxt,length);
        return 1;
    }
    return 0;
}

/* todo QName is [{prefix}':']?(name) */
STATIC int
parseQName_(Client cntxt, Xbackend xb, str *S){
	int l;
	str s,t;

	(void)xb;
	xqrySkipSpace(cntxt);
	s = CURRENT(cntxt);
	t=s;

	if (!idCharacter[(int) (*s)])
		return 0;
	s++;
	while (idCharacter2[(int) (*s)] ) 
		s++;
	l = s-t;
	if( l == 0)
		return PARSE_ERR;
	*S = idCopy(cntxt,l);
	return l;
}

/* lazy implementation ;-))) */
#define parseNCName parseQName
STATIC int
parseQName(Client cntxt, Xbackend xb)
{
	str s;
	int ret, id = -1, l;

	ret = parseQName_(cntxt, xb, &s);
	if( ret == PARSE_ERR) 
		return ret;
	for(l=0; l <xb->vtop; l++)
		if( xb->vars[l].nme && strcmp(s, xb->vars[l].nme)==0 ){
			id= xb->vars[l].tmpid; 
			break;
		}
	if( xb->vtop == MAXXVARS){
		xqryError(cntxt,"Too many variables");
		xb->vtop --;
	}
	xb->vars[xb->vtop].nme = s;
	if( id < 0)
		id= newVariable(xb->mb,GDKstrdup(s),TYPE_any);
#ifdef _XQRY_DEBUG
		stream_printf(GDKout,"#NCName %d %d %s\n", xb->vtop, id,s);
#endif
	xb->vars[xb->vtop++].tmpid = id;
	return ret;
}

STATIC int
parseVarQName(Client cntxt, Xbackend xb){
	int l;
	str s;

	l = parseQName_(cntxt, xb, &s);
	for(l=0; l <xb->vtop; l++)
		if(xb->vars[l].nme && strcmp(s, xb->vars[l].nme)==0 ){
			GDKfree(s);
			return PARSE_OK;
		}
	if( xb->vtop == MAXXVARS){
		xqryError(cntxt,"Too many variables");
		xb->vtop --;
	}
#ifdef _XQRY_DEBUG
		stream_printf(GDKout,"#QName %d -1 %s\n", xb->vtop, s);
#endif
	xb->vars[xb->vtop].tmpid = -1;
	xb->vars[xb->vtop++].nme = s;
	return PARSE_OK;
}
@-
The string literals may contain escapes to XQuery expressions.
They should be evaluated in place
@c
STATIC int 
parseEnclosedExpr(Client cntxt, Xbackend xb){
	if( currChar(cntxt) != '{')
		return PARSE_ERR;
	nextChar(cntxt);
	@:ptrace(parseEnclosedExpr)@
	parseExpr(cntxt,xb);
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return xqryError(cntxt,"'}' expected in EnclosedExpr\n");
	nextChar(cntxt);
	@:etrace(parseEnclosedExpr)@
	return PARSE_OK;
}
STATIC int
parseStringLiteral(Client cntxt, Xbackend xb){
	int before = cntxt->yycur, enclosures=0;
	if( currChar(cntxt) != '"')
		return PARSE_ERR;
	do{
		nextChar(cntxt);
		if( currChar(cntxt)== '"'){
			if( *(CURRENT(cntxt)+1)!='"') 
				break;
			nextChar(cntxt);
		}
		if( currChar(cntxt) == '{'){
			enclosures++;
			parseEnclosedExpr(cntxt,xb);
		}
	} while( currChar(cntxt));
	if( currChar(cntxt) == 0)
		return PARSE_ERR;
	if( enclosures == 0){
	 	cntxt->yycur = before; /* lookahead HACK */
		return PARSE_ERR;
	}
	return PARSE_OK;
}
@-
The key of the problem is to deal with path expressions.
@c
#define CHILD 1
#define DESCENDANT 2
#define ATTRIBUTE 3
#define SELF 4
#define DESCENDANT_OR_SELF 5
#define FOLLOWING 6
#define FOLLOWING_SIBLING 7

#define PARENT 8
#define ANCESTOR 9
#define PRECEDING 10
#define ANCESTOR_OR_SELF  11
#define PRECEDING_SIBLING 12

#define ITEM_TEST 19
#define NODE_TEST	20
#define TEXT_TEST 	21
#define COMMENT_TEST 22
#define EMPTY_SEQUENCE_TEST 23

STATIC int
parseElementName(Client cntxt, Xbackend xb){
	int i;
	@:ptrace(parseElementName)@
	if ( (i=parseQName(cntxt,xb)) <= 0)
		return PARSE_ERR;
	@:etrace(parseElementName)@
	return PARSE_OK;
}

STATIC int
parseTypeName(Client cntxt, Xbackend xb){
	int i;
	@:ptrace(parseTypeName)@
	if ( (i=parseQName(cntxt,xb)) <= 0)
		return PARSE_ERR;
	@:etrace(parseTypeName)@
	return PARSE_OK;
}

STATIC int
parseAttributeName(Client cntxt, Xbackend xb){
	int i;
	@:ptrace(parseAttributeName)@
	if ( (i=parseQName(cntxt,xb)) <= 0)
		return PARSE_ERR;
	@:etrace(parseAttributeName)@
	return PARSE_OK;
}

STATIC int 
parseSchemaElementTest(Client cntxt, Xbackend xb){
	int i;

	if( !xqryKeyword(cntxt,"schema-element",14))
		return PARSE_ERR;
	@:ptrace(parseSchemaElementTest)@
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected in SchemaElementTest\n");
	nextChar(cntxt);
	if ( (i=parseQName(cntxt,xb)) <= 0)
		return xqryError(cntxt,"<ElementName> expected in SchemaElementTest\n");
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected in SchemaElementTest\n");
	@:etrace(parseSchemaElementTest)@
	return PARSE_OK;
}

STATIC int 
parseElementTest(Client cntxt, Xbackend xb){
	if( !xqryKeyword(cntxt,"element",7))
		return PARSE_ERR;
	@:ptrace(parseElementTest)@
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected in ElementTest\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);

	if( currChar(cntxt) == '*'){
		nextChar(cntxt);
	} else
		parseElementName(cntxt,xb);
	
	xqrySkipSpace(cntxt);
	
	if( currChar(cntxt) != ','){
		if( parseTypeName(cntxt,xb)== PARSE_ERR )
			return xqryError(cntxt,"<TypeName> expected in ElementTest\n");
		xqrySkipSpace(cntxt);
		if( currChar(cntxt)== '?')
			nextChar(cntxt);
	}

	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected in ElementTest\n");
	nextChar(cntxt);
	@:etrace(parseElementTest)@
	return PARSE_OK;
}


STATIC int 
parseSchemaAttributeTest(Client cntxt, Xbackend xb){
	if( !xqryKeyword(cntxt,"schema-attribute",16))
		return PARSE_ERR;
	@:ptrace(parseSchemaAttributeTest)@
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected in SchemaAttributeTest\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);

	if( parseAttributeName(cntxt,xb)== PARSE_ERR )
		return PARSE_ERR;
	xqrySkipSpace(cntxt);

	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expecteSchemaAttributeTest\n");
	nextChar(cntxt);
	@:etrace(parseSchemaAttributeTest)@
	return PARSE_OK;
}


STATIC int 
parseAttributeTest(Client cntxt, Xbackend xb){
	if( !xqryKeyword(cntxt,"attribute",9))
		return PARSE_ERR;
	@:ptrace(parseAttributeTest)@
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expecte AttributeTest\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);

	if( currChar(cntxt) == '*'){
		nextChar(cntxt);
	} else
		parseElementName(cntxt,xb);
	
	xqrySkipSpace(cntxt);
	
	if( currChar(cntxt) != ','){
		if( parseTypeName(cntxt,xb)== PARSE_ERR )
			return PARSE_ERR;
		xqrySkipSpace(cntxt);
	}

	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected in AttributeTest\n");
	nextChar(cntxt);
	@:etrace(parseAttributeTest)@
	return PARSE_OK;
}

STATIC int
parseDocumentTest(Client cntxt, Xbackend xb){
	if( !xqryKeyword(cntxt,"document-node",13))
		return PARSE_ERR;
	@:ptrace(parseDocumentTest)@
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected in DocumentTest\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);
	if( parseElementTest(cntxt,xb) == PARSE_ERR ||
		parseSchemaElementTest(cntxt,xb) ){
	}
	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected in DocumentTest\n");
	nextChar(cntxt);
	@:etrace(parseDocumentTest)@
	return PARSE_OK;
}

STATIC int
parsePITest(Client cntxt, Xbackend xb){
	int i;

	if( !xqryKeyword(cntxt,"processing-instruction",13))
		return PARSE_ERR;
	@:ptrace(parsePITest)@
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected in PITest\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);
	if ((i=parseNCName(cntxt,xb)) <= 0) {
		i= stringLength(cntxt);
		if( i>0)
			strCopy(cntxt,i);
	}

	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected in PITest\n");
	nextChar(cntxt);
	@:etrace(parsePITest)@
	return PARSE_OK;
}

STATIC int
parseKindTest(Client cntxt, Xbackend xb){
	int kind=0;

	@:ptrace(parseKindTest)@
	(void) xb; (void) kind;
	if( parseSchemaElementTest(cntxt,xb)== PARSE_OK ||
		parseAttributeTest(cntxt,xb)== PARSE_OK ||
		parseSchemaAttributeTest(cntxt,xb)== PARSE_OK ||
		parseElementTest(cntxt,xb)== PARSE_OK ||
		parseDocumentTest(cntxt,xb)== PARSE_OK ||
		parsePITest(cntxt,xb)== PARSE_OK) {
			@:etrace(parseKindTest)@
			return PARSE_OK;
	}

	if( xqryKeyword(cntxt,"node",4) ) kind= NODE_TEST; else
	if( xqryKeyword(cntxt,"text",4) ) kind= TEXT_TEST; else
	if( xqryKeyword(cntxt,"comment",7) ) kind= COMMENT_TEST; 
		else return PARSE_ERR;
	if( !xqryKeyphrase1(cntxt,"(") ) 
		return xqryError(cntxt,"'(' expected in KindTest\n");
	if( !xqryKeyphrase1(cntxt,")") ) 
		return xqryError(cntxt,"')' expected in KindTest\n");
	@:etrace(parseKindTest)@
	return PARSE_OK;
}

STATIC int
parseItemType(Client cntxt, Xbackend xb){
	int i;
	@:ptrace(parseItemType)@
	if( parseKindTest(cntxt,xb) == PARSE_OK) return PARSE_OK;
	if( xqryKeyword(cntxt,"item",4) ) {
		if( !xqryKeyphrase1(cntxt,"(") )
			return xqryError(cntxt,"'(' expected in ItemType\n");
		if( !xqryKeyphrase1(cntxt,")") ) 
			return xqryError(cntxt,"')' expected in ItemType\n");
		i = ITEM_TEST; 
		@:etrace(parseItemType)@
		return PARSE_OK;
	}
	/* AtomicType */
	i = idLength(cntxt);
	(void) i;
	if( i== 0)
			return xqryError(cntxt,"<AtomicType> expected in ItemType\n");
	@:etrace(parseItemType)@
	return PARSE_OK;
}

STATIC int
parseSequenceType(Client cntxt, Xbackend xb){
	@:ptrace(parseSequenceType)@
	if( xqryKeyword(cntxt,"empty-sequence",13) ) {
		if( !xqryKeyphrase1(cntxt,"(") ) 
			return xqryError(cntxt,"'(' expected in SequenceType\n");
		if( !xqryKeyphrase1(cntxt,")") )
			return xqryError(cntxt,"')' expected in SequenceType\n");
		@:etrace(parseSequenceType)@
		return PARSE_OK;
	}
	if( parseItemType(cntxt,xb) == PARSE_ERR)
		return PARSE_ERR;
	/* ItemType OccurrenceIndicator */
	switch(currChar(cntxt)){
	case '?':
	case '+':
	case '*':
		nextChar(cntxt);
	default:
		xqryError(cntxt,"'?', '+', '*' expected in SequenceType\n");
	}
	@:etrace(parseSequenceType)@
	return PARSE_OK;
}

STATIC int
parseTypeDeclaration(Client cntxt, Xbackend xb){
	if( !xqryKeyword(cntxt,"as",2) )
		return PARSE_ERR;
	@:ptrace(parseTypeDeclaration)@
	return parseSequenceType(cntxt,xb);
}
STATIC int
parseCompPIConstructor(Client cntxt, Xbackend xb){
	int i;

	if( !xqryKeyword(cntxt,"processing-instruction",22))
		return PARSE_ERR;
	@:ptrace(parseCompPIConstructor)@
	if ((i=parseNCName(cntxt,xb)) > 0) {
		xqrySkipSpace(cntxt);
	} else{
		if( currChar(cntxt) != '{')
			return xqryError(cntxt,"'{' expected in PIConstructor\n");
		nextChar(cntxt);
		parseExpr(cntxt,xb);
		xqrySkipSpace(cntxt);
		if( currChar(cntxt) != '}')
			return xqryError(cntxt,"'}' expected in PIConstructor\n");
		nextChar(cntxt);
	}

	if( currChar(cntxt) != '{')
		return xqryError(cntxt,"'{' expected in PIConstructor\n");
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return xqryError(cntxt,"'}' expected in PIConstructor\n");
	nextChar(cntxt);
	@:etrace(parseCompPIConstructor)@
	return PARSE_OK;
}


STATIC int
parseCompCommentConstructor(Client cntxt, Xbackend xb){
	if( !xqryKeyword(cntxt,"comment",7) )
		return PARSE_ERR;
	@:ptrace(parseCompCommentConstructor)@
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '{')
		return xqryError(cntxt,"'{' expected in CompCommentConstructor\n");
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return xqryError(cntxt,"'}' expected in CompCommentConstructor\n");
	nextChar(cntxt);
	@:etrace(parseCompCommentConstructor)@
	return PARSE_OK;
}

STATIC int
parseCompTextConstructor(Client cntxt, Xbackend xb){
	int before = cntxt->yycur;
	if( !xqryKeyword(cntxt,"text",4) )
		return PARSE_ERR;
	@:ptrace(parseCompTextConstructor)@
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '{') {
	 	cntxt->yycur = before; /* lookahead HACK */
		return PARSE_ERR;
	}
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return xqryError(cntxt,"'}' expected in CompTextConstructor\n");
	nextChar(cntxt);
	@:etrace(parseCompTextConstructor)@
	return PARSE_OK;
}

STATIC int
parseCompAttrConstructor(Client cntxt, Xbackend xb){
	int i;
	if( !xqryKeyword(cntxt,"attribute",9))
		return PARSE_ERR;
	@:ptrace(parseCompAttrConstructor)@
	if ( (i=parseQName(cntxt,xb)) > 0) {
		xqrySkipSpace(cntxt);
	} else{
		if( currChar(cntxt) != '{')
			return xqryError(cntxt,"'{' expected in CompAttrConstructor\n");
		nextChar(cntxt);
		parseExpr(cntxt,xb);
		xqrySkipSpace(cntxt);
		if( currChar(cntxt) != '}')
			return xqryError(cntxt,"'}' expected in CompAttrConstructor\n");
		nextChar(cntxt);
	}

	if( currChar(cntxt) != '{')
		return xqryError(cntxt,"'{' expected in CompAttrConstructor\n");
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return xqryError(cntxt,"'}' expected in CompAttrConstructor\n");
	nextChar(cntxt);
	@:etrace(parseCompAttrConstructor)@
	return PARSE_OK;
}

STATIC int
parseCompElemConstructor(Client cntxt, Xbackend xb){
	int i;
	if( !xqryKeyword(cntxt,"element",7))
		return PARSE_ERR;
	@:ptrace(parseCompElemConstructor)@
	if ( (i=parseQName(cntxt,xb)) <= 0) {
		if( currChar(cntxt) != '{')
			return xqryError(cntxt,"'{' expected in CompElemConstructor\n");
		nextChar(cntxt);
		parseExpr(cntxt,xb);
		xqrySkipSpace(cntxt);
		if( currChar(cntxt) != '}')
			return xqryError(cntxt,"'}' expected in CompElemConstructor\n");
		nextChar(cntxt);
	}
	xqrySkipSpace(cntxt);

	if( currChar(cntxt) != '{')
		return xqryError(cntxt,"'{' expected in CompElemConstructor\n");
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return xqryError(cntxt,"'}' expected in CompElemConstructor\n");
	nextChar(cntxt);
	@:etrace(parseCompElemConstructor)@
	return PARSE_OK;
}

STATIC int
parseCompDocConstructor(Client cntxt, Xbackend xb){
	if( !xqryKeyword(cntxt,"document",8))
		return PARSE_ERR;
	@:ptrace(parseCompDocConstructor)@
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '{')
		return xqryError(cntxt,"'{' expected in CompDocConstructor\n");
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	xqrySkipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return xqryError(cntxt,"'}' expected in CompDocConstructor\n");
	nextChar(cntxt);
	@:etrace(parseCompDocConstructor)@
	return PARSE_OK;
}

STATIC int
parseComputedConstructor(Client cntxt, Xbackend xb){
	int ret;
	@:ptrace(parseComputedConstructor)@
	if( parseCompDocConstructor(cntxt,xb)== PARSE_OK ||
		parseCompElemConstructor(cntxt,xb)== PARSE_OK ||
		parseCompAttrConstructor(cntxt,xb)== PARSE_OK ||
		parseCompTextConstructor(cntxt,xb)== PARSE_OK ||
		parseCompCommentConstructor(cntxt,xb)== PARSE_OK){
			@:etrace(parseComputedConstructor)@
			return PARSE_OK;
		}
	ret= parseCompPIConstructor(cntxt,xb);
	@:etrace(parseComputedConstructor)@
	return ret;
}

STATIC int
parseDirPIConstructor(Client cntxt, Xbackend xb){
	int i;
	(void) xb;

	xqrySkipSpace(cntxt);
	if( !xqryKeyphrase2(cntxt,"<?") )
		return PARSE_ERR;
	@:ptrace(parseDirPIConstructor)@
	/* PItarget */
	i= idLength(cntxt);
	if(i== 0)
		return PARSE_ERR;
	idCopy(cntxt,i);

	while( currChar(cntxt) != '?' && currChar(cntxt))
		nextChar(cntxt);
	if( !xqryKeyphrase2(cntxt,"?>") )
		return xqryError(cntxt,"'?>' expected in DirPIConstructor\n");
	@:etrace(parseDirPIConstructor)@
	return PARSE_OK;
}

STATIC int
parseDirCommentConstructor(Client cntxt, Xbackend xb){
	int i =0;

	(void) xb;
	if( !xqryKeyphrase(cntxt,"<!--",4) )
		return PARSE_ERR;
	@:ptrace(parseCommentConstructor)@
	do{
		if(currChar(cntxt)=='-' && i) break;
		if(currChar(cntxt)=='-') i++; else i= 0;
		nextChar(cntxt);
	} while(currChar(cntxt));
	if( !xqryKeyphrase1(cntxt,">") )
		return xqryError(cntxt,"'>' expected in DirCommentConstructor\n");
	@:etrace(parseCommentConstructor)@
	return PARSE_OK;
}

STATIC int
parseDirAttributeValue(Client cntxt, Xbackend xb){
	int i=0;
	(void) xb;
	if( currChar(cntxt)== '"'){
		@:ptrace(parseDirAttributeValue)@
		nextChar(cntxt);
		while( currChar(cntxt) && currChar(cntxt)!= '"')
		if( currChar(cntxt)=='"' && i){
			nextChar(cntxt); i=0;
		} else
		if( currChar(cntxt)=='"'){
			nextChar(cntxt); i=1;
		} else
		if( currChar(cntxt)=='{'){
			if( parseEnclosedExpr(cntxt,xb)== PARSE_ERR)
				nextChar(cntxt); i=0;
		} else{
			nextChar(cntxt); i=0;
		}
		if( currChar(cntxt)== '"') nextChar(cntxt);
	} else
	if( currChar(cntxt)== '\'') {
		@:ptrace(parseDirAttributeValue)@
		nextChar(cntxt);
		while (currChar(cntxt) && currChar(cntxt) != '\'')
			if (currChar(cntxt) == '\'' && i) {
				nextChar(cntxt);
				i = 0;
			} else if (currChar(cntxt) == '\'') {
				nextChar(cntxt);
				i = 1;
			} else
			if( currChar(cntxt)=='{'){
				if( parseEnclosedExpr(cntxt,xb)== PARSE_ERR)
					nextChar(cntxt); i=0;
			} else {
				nextChar(cntxt);
				i = 0;
			}
		if (currChar(cntxt) == '\'')
			nextChar(cntxt);
	}
	else return PARSE_ERR;

	@:etrace(parseDirAttributeValue)@
	return PARSE_OK;
}

STATIC int parseDirAttributeList(Client cntxt, Xbackend xb) {
	int i;
	int res = PARSE_OK;

	@:ptrace(parseDirAttributeList)@
	(void) xb;
	do {
		if ( (i=parseQName(cntxt,xb)) <= 0) 
			break;
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != '=')
			return PARSE_ERR;
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
	} while ((res = parseDirAttributeValue(cntxt,xb)) == PARSE_OK);
	@:etrace(parseDirAttributeList)@
	return res;
}

STATIC int parseCDataSection(Client cntxt, Xbackend xb) {
	(void) xb;
	if (!xqryKeyphrase(cntxt, "<![CDATA[", 9))
		return PARSE_ERR;
	@:ptrace(parseCDataSection)@
	while (!xqryKeyphrase(cntxt, "]]>", 3))
		nextChar(cntxt);
	@:etrace(parseCDataSection)@
	return PARSE_OK;
}

STATIC int parseCommonContent(Client cntxt, Xbackend xb) {
	ValRecord val;
	int i;

	@:ptrace(parseCommonContent)@
	if (xqryKeyphrase2(cntxt, "{{") ||
		xqryKeyphrase2(cntxt, "}}") ||
		parseEnclosedExpr(cntxt,xb) == PARSE_OK){
			@:etrace(parseCommonContent)@
			return PARSE_OK;
		}
	/* check PredefinedEntityRef */
	/* and the rest */
	i = cstToken(cntxt, &val);
	if (i == 0 || val.vtype != TYPE_chr)
		return xqryError(cntxt,"<CharRef> expected in CommonContent\n");
	advance(cntxt, i);
	@:etrace(parseCommonContent)@
	return PARSE_OK;
}

STATIC int parseElementContentChar(Client cntxt, Xbackend xb) {
	(void) xb;
	switch (currChar(cntxt)) {
	case '{':
	case '}':
	case '<':
	case '&':
		return PARSE_ERR;
	}
	nextChar(cntxt);
	return PARSE_OK;
}

STATIC int parsePredefinedEntityRef(Client cntxt, Xbackend xb) {
	(void) xb;
	if (currChar(cntxt) != '&')
		return PARSE_ERR;
	nextChar(cntxt);
	@:ptrace(parsePredefinedEntityRef)@
	if (xqryKeyword(cntxt, "gt", 2));
	else if (xqryKeyword(cntxt, "lt", 2));
	else if (xqryKeyword(cntxt, "amp", 3));
	else if (xqryKeyword(cntxt, "quot", 4));
	else if (xqryKeyword(cntxt, "apos", 4));
	else
		return xqryError(cntxt,"<PredefinedEntity> expected in PredefinedEntityRef\n");
	if (currChar(cntxt) != ';')
		return xqryError(cntxt,"';' expected in PredefinedEntityRef\n");
	nextChar(cntxt);
	@:etrace(parsePredefinedEntityRef)@
	return PARSE_OK;
}

STATIC int parseDirElementContent(Client cntxt, Xbackend xb) {
	@:ptrace(parseDirElementContent)@
	while( currChar(cntxt) && currChar(cntxt) != '<' && 
			(parseEnclosedExpr(cntxt,xb)== PARSE_OK ||
			parseDirectConstructor(cntxt, xb)== PARSE_OK ||
			parseCDataSection(cntxt, xb)== PARSE_OK ||
			parseCommonContent(cntxt, xb) == PARSE_OK ||
			parseElementContentChar(cntxt, xb)== PARSE_OK ))
		;
	@:etrace(parseDirElementContent)@
	return PARSE_OK;
}

STATIC int parseDirElementConstructor(Client cntxt, Xbackend xb) {
	int i;

	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '<')
		return PARSE_ERR;
	@:ptrace(parseDirElementConstructor)@
	nextChar(cntxt);
	if ( (i=parseQName(cntxt,xb)) <= 0) 
		return xqryError(cntxt,"<Qname> expected in DirElementConstructor\n");
	parseDirAttributeList(cntxt, xb);

	if (xqryKeyphrase2(cntxt, "/>")){
		@:etrace(parseDirElementConstructor)@
		return PARSE_OK;
	}

	if (currChar(cntxt) != '>')
		return xqryError(cntxt,"'>' expected in DirElementConstructor\n");
	nextChar(cntxt);

	parseDirElementContent(cntxt, xb);

	if (!xqryKeyphrase2(cntxt, "</"))
		return xqryError(cntxt,"'</' expected in DirElementConstructor\n");

	xqrySkipSpace(cntxt);
	if ( (i=parseQName(cntxt,xb)) <= 0) 
		return xqryError(cntxt,"<Qname> expected in DirElementConstructor\n");

	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '>')
		return xqryError(cntxt,"'>' expected in DirElementConstructor\n");
	nextChar(cntxt);

	@:etrace(parseDirElementConstructor)@
	return PARSE_OK;
}

int parseDirectConstructor(Client cntxt, Xbackend xb) {
	int ret;
	@:ptrace(parseDirConstructor)@
	if ((ret= parseDirElementConstructor(cntxt, xb)) == PARSE_OK ){
			@:etrace(parseDirConstructor)@
			return PARSE_OK;
	}
	if(	(ret= parseDirCommentConstructor(cntxt, xb)) == PARSE_OK ){
			@:etrace(parseDirConstructor)@
			return PARSE_OK;
	}
	if( (ret= parseDirPIConstructor(cntxt, xb))== PARSE_OK ){
			@:etrace(parseDirConstructor)@
			return PARSE_OK;
	}
	return PARSE_ERR;
}

STATIC int parseConstructor(Client cntxt, Xbackend xb) {
	@:ptrace(parseConstructor)@
	if (parseDirectConstructor(cntxt, xb) == PARSE_OK ){
			@:etrace(parseConstructor direct)@
			return PARSE_OK;
	}
	if (parseComputedConstructor(cntxt, xb) == PARSE_OK){
			@:etrace(parseConstructor computed)@
			return PARSE_OK;
	}
	return PARSE_ERR;
}

STATIC int parseNameTest(Client cntxt, Xbackend xb) {
	int i = 0;
	@:ptrace(parseNameTest)@
	(void) xb;
	i = idLength(cntxt);
	if ( (i=parseQName(cntxt,xb)) > 0) { 
		if (currChar(cntxt) == ':') {
			nextChar(cntxt);
			if (currChar(cntxt) != '*') {
				return xqryError(cntxt,"'*' expected in NameTest\n");
			}
			nextChar(cntxt);
		} 
		@:etrace(parseNameTest)@
		return PARSE_OK;
	}
	if (currChar(cntxt) == '*') {
		nextChar(cntxt);
		if (currChar(cntxt) == ':') {
			nextChar(cntxt);
			if ( (i=parseNCName(cntxt,xb)) <= 0) 
				return xqryError(cntxt,"<NCname> expected in NameTest\n");
		}
	} else 
		return PARSE_ERR;
	@:etrace(parseNameTest)@
	return PARSE_OK;
}

/* we need readahead here */
STATIC int parseFunctionCall(Client cntxt, Xbackend xb) {
	int before = cntxt->yycur;
	int i;
	int argc = 0;

	@:ptrace(parseFunctionCall)@
	if ( (i=parseQName(cntxt,xb)) <= 0) 
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '(') {
		cntxt->yycur = before; /* HACK */
		return PARSE_ERR;
	}
	nextChar(cntxt);
	do {
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) == ')')
			break;
		if (argc && currChar(cntxt) != ',') 
			return xqryError(cntxt,"',' expected in FunctionCall\n");
		if( argc)
			nextChar(cntxt);
		argc++;
		xqrySkipSpace(cntxt);
	} while (parseExprSingle(cntxt, xb) == PARSE_OK);
	if (currChar(cntxt) != ')') 
		return xqryError(cntxt,"')' expected in FunctionCall\n");
	nextChar(cntxt);
	@:etrace(parseFunctionCall)@
	return PARSE_OK;
}
STATIC int parsePrimaryExpr(Client cntxt, Xbackend xb) {
	int i;
	ValRecord val;
	InstrPtr p;

	@:ptrace(parsePrimaryExpr)@
	xqrySkipSpace(cntxt);
	if( parseStringLiteral(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if ((i = cstToken(cntxt, &val)) != 0) {
		p= newAssignment(xb->mb);
		getArg(p,0)= pushXvar(xb);
		pushArgument(xb->mb,p, defConstant(xb->mb, val.vtype,&val));
		advance(cntxt, i);
		@:etrace(parsePrimaryExpr)@
		return PARSE_OK;
	}
	if (currChar(cntxt) == '$') {
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
		if ( (i=parseQName(cntxt,xb)) <= 0) 
			return xqryError(cntxt,"<VarRef> expected in PrimaryExpr\n");
		@:etrace(parsePrimaryExpr)@
		return PARSE_OK;
	}
	/* ContextItemExpr */
	if (currChar(cntxt) == '.') {
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
		return PARSE_OK;
	} 
	/* ParenthesizedExpr */
	if (currChar(cntxt) == '(') {
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
		parseExpr(cntxt, xb);
		if (currChar(cntxt) != ')')
			return xqryError(cntxt,"')' expected in PrimaryExpr\n");
		@:etrace(parsePrimaryExpr)@
		nextChar(cntxt);
		return PARSE_OK;
	} 
	/* OrderedExpr */
	if (xqryKeyword(cntxt, "ordered", 7)) {
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != '{')
			return xqryError(cntxt,"'{' expected in PrimaryExpr\n");
		nextChar(cntxt);
		if (parseExpr(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<Expr> expected in PrimaryExpr\n");
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != '}')
			return xqryError(cntxt,"'}' expected in PrimaryExpr\n");
	} else
	/* UnorderedExpr */
	if (xqryKeyword(cntxt, "unordered", 9)) {
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != '{')
			return xqryError(cntxt,"'{' expected in PrimaryExpr\n");
		nextChar(cntxt);
		if (parseExpr(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<Expr> expected in PrimaryExpr\n");
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != '}')
			return xqryError(cntxt,"'}' expected in PrimaryExpr\n");
	}
	if (parseConstructor(cntxt, xb) == PARSE_OK ){
			@:etrace(parsePrimaryExpr Constructor)@
			return PARSE_OK;
		}
	if( parseFunctionCall(cntxt, xb) == PARSE_OK){
			@:etrace(parsePrimaryExpr)@
			return PARSE_OK;
	}
	@:etrace(parsePrimaryExpr failed)@
	return PARSE_ERR;
}

STATIC int parsePredicate(Client cntxt, Xbackend xb) {
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '[')
		return PARSE_ERR;
	nextChar(cntxt);
	@:ptrace(parsePredicate)@
	xqrySkipSpace(cntxt);
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in Predicate\n");
	if (currChar(cntxt) != ']')
		return xqryError(cntxt,"']' expected in Predicate\n");
	nextChar(cntxt);
	@:etrace(parsePredicate)@
	return PARSE_OK;

}
STATIC int parsePredicateList(Client cntxt, Xbackend xb) {
	@:ptrace(parsePredicateList)@
	do {
		xqrySkipSpace(cntxt);
	} while (parsePredicate(cntxt, xb) == PARSE_OK);
	@:etrace(parsePredicateList)@
	return PARSE_OK;
}

STATIC int parseFilterExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseFilter)@
	xqrySkipSpace(cntxt);
	if (parsePrimaryExpr(cntxt, xb) != PARSE_OK ){
		@:etrace(parseFilter)@
		return PARSE_ERR;
	}
	parsePredicateList(cntxt, xb);
	@:etrace(parseFilter)@
	return PARSE_OK;
}

STATIC int parseNodeTest(Client cntxt, Xbackend xb) {
	@:ptrace(parseNodeTest)@
	if (parseKindTest(cntxt, xb) == PARSE_OK){
		@:etrace(parseNodeTest)@
		return PARSE_OK;
	}
	return parseNameTest(cntxt, xb);
}

STATIC int parseAbbrevReverseStep(Client cntxt, Xbackend xb) {
	@:ptrace(parseAbbrevReverseStep)@
	(void) xb;
	if (xqryKeyword(cntxt, "..", 2)) {
		return PARSE_OK;
	}
	return PARSE_ERR;
}

STATIC int parseReverseAxis(Client cntxt, Xbackend xb) {
	int ret;

	@:ptrace(parseReverseAxis)@
	(void) xb;
	if (xqryKeyword(cntxt, "parent", 6))
		ret = PARENT;
	else if (xqryKeyword(cntxt, "ancestor", 8))
		ret = ANCESTOR;
	else if (xqryKeyword(cntxt, "preceding", 9))
		ret = PRECEDING;
	else if (xqryKeyword(cntxt, "preceding-sibling", 17))
		ret = PRECEDING_SIBLING;
	else if (xqryKeyword(cntxt, "ancestor-or-self", 16))
		ret = ANCESTOR_OR_SELF;
	else
		return PARSE_ERR;
	@:ptrace(parseReverseAxis)@
	if (!xqryKeyphrase2(cntxt, "::"))
		return xqryError(cntxt,"'::' expected in ReverseAxis\n");
	(void) ret;
	@:etrace(parseReverseAxis)@
	return PARSE_OK;
}

STATIC int parseReverseStep(Client cntxt, Xbackend xb) {
	int ret;
	@:ptrace(parseReverseStep)@
	xqrySkipSpace(cntxt);
	if (parseReverseAxis(cntxt, xb) == PARSE_OK) {
		ret= parseNodeTest(cntxt, xb);
	} else
		ret= parseAbbrevReverseStep(cntxt, xb);
	@:etrace(parseReverseStep)@
	return ret;
}

STATIC int parseAbbrevForwardStep(Client cntxt, Xbackend xb) {
	int ret;
	@:ptrace(parseAbbrevForwardStep)@
	(void) xb;
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) == '@') {
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
	}
	ret= parseNodeTest(cntxt, xb);
	@:etrace(parseAbbrevForwardStep)@
	return ret;
}

STATIC int parseForwardAxis(Client cntxt, Xbackend xb) {
	int ret;

	@:ptrace(parseForwardAxis)@
	(void) xb;
	if (xqryKeyword(cntxt, "child", 5))
		ret = CHILD;
	else if (xqryKeyword(cntxt, "descendant", 10))
		ret = DESCENDANT;
	else if (xqryKeyword(cntxt, "attribute", 9))
		ret = ATTRIBUTE;
	else if (xqryKeyword(cntxt, "following", 9))
		ret = FOLLOWING;
	else if (xqryKeyword(cntxt, "following-sibling", 17))
		ret = FOLLOWING;
	else if (xqryKeyword(cntxt, "self", 4))
		ret = SELF;
	else if (xqryKeyword(cntxt, "descendant-or-self", 18))
		ret = DESCENDANT_OR_SELF;
	else
		return PARSE_ERR;
	if (!xqryKeyphrase2(cntxt, "::"))
		return xqryError(cntxt,"'::' expectedin ForwardAxis\n");
	(void) ret;
	@:etrace(parseForwardAxis)@
	return PARSE_OK;
}

STATIC int parseForwardStep(Client cntxt, Xbackend xb) {
	int ret=PARSE_OK;
	@:ptrace(parseForwardStep)@
	xqrySkipSpace(cntxt);
	if (parseForwardAxis(cntxt, xb) == PARSE_OK) {
		ret= parseNodeTest(cntxt, xb);
	} else
	if( parseNodeTest(cntxt, xb)== PARSE_OK){
	} else
		ret= parseAbbrevForwardStep(cntxt, xb);
	@:etrace(parseForwardStep)@
	return ret;
}

STATIC int parseAxisStep(Client cntxt, Xbackend xb) 
{
	int ret;
	@:ptrace(parseAxisStep)@
	(	parseReverseStep(cntxt, xb) == PARSE_OK ||
		parseForwardStep(cntxt, xb) == PARSE_OK );
	ret= parsePredicateList(cntxt, xb);
	@:etrace(parseAxisStep)@
	return ret;
}

STATIC int parseStepExpr(Client cntxt, Xbackend xb) {
	int ret;
	@:ptrace(parseStepExpr)@
	if (parseFilterExpr(cntxt, xb) == PARSE_OK){
		@:etrace(parseStepExpr)@
		return PARSE_OK;
	}
	ret= parseAxisStep(cntxt, xb);
	@:etrace(parseStepExpr)@
	return ret;
}

int parseRelativePathExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	@:ptrace(parseRelativePathExpr)@
	xqrySkipSpace(cntxt);
	res = parseStepExpr(cntxt, xb);
	xqrySkipSpace(cntxt);
	while (res == PARSE_OK && currChar(cntxt) == '/') {
		nextChar(cntxt);
		if (currChar(cntxt) == '/')
			nextChar(cntxt);
		xqrySkipSpace(cntxt);
		res = parseStepExpr(cntxt, xb);
		xqrySkipSpace(cntxt);
	}
	@:etrace(parseRelativePathExpr)@
	return res;
}

STATIC int parsePathExpr(Client cntxt, Xbackend xb) {
	str op="/";
	(void) op;
	@:ptrace(parsePathExpr)@
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) == '/') {
		nextChar(cntxt);
		if (currChar(cntxt) == '/'){
			op="//";
			nextChar(cntxt);
		} else{
			parseRelativePathExpr(cntxt, xb);
			@:etrace(parsePathExpr)@
			return PARSE_OK;
		}
	}
	return parseRelativePathExpr(cntxt, xb);
}

@-
Variables are declared and stored on the top
of the variable stack.
@c 
STATIC int parseVarName(Client cntxt, Xbackend xb);

STATIC int parsePositionalVar(Client cntxt, Xbackend xb) {
	int i = xb->vtop - 1;	/* last defined one */
	(void) i;
	if (!xqryKeyword(cntxt, "at", 2))
		return PARSE_ERR;
	@:ptrace(parsePositionalVar)@
	parseVarName(cntxt, xb);
	@:etrace(parsePositionalVar)@
	return PARSE_OK;
}

int parseVarName(Client cntxt, Xbackend xb) {
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '$')
		return PARSE_ERR;
	@:ptrace(parseVarName)@
	nextChar(cntxt);
	xqrySkipSpace(cntxt);
	if (parseVarQName(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<QName> expected in VarName\n");
	/* has optional type? */

#ifdef _XQRY_DEBUG
	stream_printf(cntxt->fdout, "parseVarName %s\n",
		      xb->vars[xb->vtop - 1].nme);
#endif
	@:etrace(parseVarName)@
	return PARSE_OK;
}

STATIC int parsePragma(Client cntxt, Xbackend xb) {
	int i;
	(void) xb;
	if (!xqryKeyphrase2(cntxt, "(#"))
		return PARSE_ERR;
	@:ptrace(parsePragma)@
	if ( (i=parseQName(cntxt,xb)) <= 0) 
		return xqryError(cntxt,"<QName> expected in Pragma\n");
	i = 0;
	do {
		if (currChar(cntxt) == ')' && i)
			break;
		if (currChar(cntxt) == '#')
			i++;
		else
			i = 0;
		nextChar(cntxt);
	} while (currChar(cntxt));
	@:etrace(parsePragma)@
	return PARSE_OK;
}

STATIC int parseExtensionExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseExtensionExpr)@
	do {
		xqrySkipSpace(cntxt);
	} while (parsePragma(cntxt, xb) == PARSE_OK);
	if (currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected in ExtensionExpr\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);
	parseExpr(cntxt, xb);
	if (currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected in ExtensionExpr\n");
	nextChar(cntxt);
	@:etrace(parseExtensionExpr)@
	return PARSE_OK;
}

STATIC int parseValidateExpr(Client cntxt, Xbackend xb) {
	if (!xqryKeyword(cntxt, "validate", 8))
		return PARSE_ERR;
	@:ptrace(parseValidateExpr)@
	if (xqryKeyword(cntxt, "lax", 3)) {
	} else if (xqryKeyword(cntxt, "strict", 6)) {
	}
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected in ValidateExpr\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in ValidateExpr\n");
	if (currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected in ValidateExpr\n");
	nextChar(cntxt);
	@:etrace(parseValidateExpr)@
	return PARSE_OK;
}

STATIC int parseSingleType(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseSingleType)@
	if ( (i=parseQName(cntxt,xb)) <= 0)
		return xqryError(cntxt,"<AtomicType> expected in SingleType\n");
	if (currChar(cntxt) == '?')
		nextChar(cntxt);
	@:etrace(parseSingleType)@
	return PARSE_OK;
}

STATIC int parseValueExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseValueExpr)@
	xqrySkipSpace(cntxt);
	if (parsePathExpr(cntxt, xb) == PARSE_OK ||
		parseValidateExpr(cntxt, xb) == PARSE_OK ||
		parseExtensionExpr(cntxt, xb) == PARSE_OK) {
			@:etrace(parseValueExpr)@
			return PARSE_OK;
		}
	return PARSE_ERR;
}

STATIC int parseUnaryExpr(Client cntxt, Xbackend xb) {
	str op="+";
	int r1;
	ValRecord cst;
	InstrPtr p;

	@:ptrace(parseUnaryExpr)@
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) == '+' ){
		op= "+";
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
	} else if (currChar(cntxt) == '-'){
		op= "-";
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
	}
	if( parseValueExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if( *op== '-'){
		r1=popXvar(xb);
		cst.vtype= TYPE_int;
		cst.val.ival= 0;
		p= newStmt(xb->mb,calcRef, putName("-",1));
		pushArgument(xb->mb,p, defConstant(xb->mb, cst.vtype,&cst));
		pushArgument(xb->mb,p, r1);
		getArg(p,0)= pushXvar(xb);
	}
	@:etrace(parseUnaryExpr)@
	return PARSE_OK;
}

STATIC int parseCastExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseCastExpr)@
	xqrySkipSpace(cntxt);
	if (parseUnaryExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (!xqryKeyword(cntxt, "cast", 4))
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "as", 2))
		return xqryError(cntxt,"'as' expected in CastExpr\n");
	return parseSingleType(cntxt, xb);
}

STATIC int parseCastableExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseCastableExpr)@
	xqrySkipSpace(cntxt);
	if (parseCastExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (!xqryKeyword(cntxt, "castable", 8))
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "as", 2))
		return xqryError(cntxt,"'as' expected in CatableExpr\n");
	return parseSingleType(cntxt, xb);
}

STATIC int parseTreatExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseTreatExpr)@
	xqrySkipSpace(cntxt);
	if (parseCastableExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (!xqryKeyword(cntxt, "treat", 5))
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "as", 2))
		return xqryError(cntxt,"'as' expected in TreatExpr\n");
	return parseSequenceType(cntxt, xb);
}

STATIC int parseInstanceOfExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseInstanceOfExpr)@
	xqrySkipSpace(cntxt);
	if (parseTreatExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (!xqryKeyword(cntxt, "instance", 7))
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "of", 2))
		return xqryError(cntxt,"'of' expected in InstanceOfExpr\n");
	return parseSequenceType(cntxt, xb);
}

STATIC int parseIntersectExceptExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	@:ptrace(parseIntersectExceptExpr)@
	xqrySkipSpace(cntxt);
	if ((res = parseInstanceOfExpr(cntxt, xb)) != PARSE_OK)
		return res;
	do {
		xqrySkipSpace(cntxt);
		if (xqryKeyword(cntxt, "intersect", 9)) {
		} else if (xqryKeyword(cntxt, "except", 6)) {
		} else 
			break;
	} while ((res = parseInstanceOfExpr(cntxt, xb)) == PARSE_OK);
	@:etrace(parseIntersectExceptExpr)@
	return res;
}

STATIC int parseUnionExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	@:ptrace(parseUnion)@
	xqrySkipSpace(cntxt);
	if ((res = parseIntersectExceptExpr(cntxt, xb)) != PARSE_OK)
		return res;
	do {
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) == '|') {
			nextChar(cntxt);
		} else if (xqryKeyword(cntxt, "union", 5)) {
		} else
			break;
	} while ((res = parseIntersectExceptExpr(cntxt, xb)) == PARSE_OK);
	@:etrace(parseUnion)@
	return res;
}

STATIC int parseMultiplicativeExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	str op;
	@:ptrace(parseMultiplicativeExpr)@
	xqrySkipSpace(cntxt);
	if ((res = parseUnionExpr(cntxt, xb)) != PARSE_OK)
		return res;
	do {
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) == '*') {
			nextChar(cntxt);
			op="*";
		} else if (xqryKeyword(cntxt, "div", 3)) {
			op= "/";
		} else if (xqryKeyword(cntxt, "idiv", 4)) {
			op= "/";
		} else if (xqryKeyword(cntxt, "mod", 3)) {
			op= "%";
		} else
			break;
		xqrySkipSpace(cntxt);
		res= parseUnionExpr(cntxt, xb);
		if( res == PARSE_OK){
			xqryCoercion(xb);
			xqryStatement(xb,"calc",op,2);
		}
	} while (res == PARSE_OK);
	@:etrace(parseMultiplicativeExpr)@
	return res;
}

STATIC int parseAdditiveExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	char op[2]={0,0};

	@:ptrace(parseAdditiveExpr)@
	xqrySkipSpace(cntxt);
	if ((res = parseMultiplicativeExpr(cntxt, xb)) != PARSE_OK)
		return res;
	do {
		xqrySkipSpace(cntxt);
		op[0]= currChar(cntxt);
		if (op[0] == '+' || op[0] == '-')
			nextChar(cntxt);
		else
			break;
		res = parseMultiplicativeExpr(cntxt, xb);
		if( res== PARSE_OK){
			/* we have two variables on the stack */
			xqryCoercion(xb);
			xqryStatement(xb,"calc",(str)op,2);
		}
	} while(res == PARSE_OK);
	@:etrace(parseAdditiveExpr)@
	return res;
}
STATIC int parseRangeExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseRangeExpr)@
	xqrySkipSpace(cntxt);
	if (parseAdditiveExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (xqryKeyword(cntxt, "to", 2))
		return parseRangeExpr(cntxt, xb);
	return PARSE_ERR;
}

STATIC int parseComparisonExpr(Client cntxt, Xbackend xb) {
	str op="unknown", mod="calc";
	int ret;
	/* int before = cntxt->yycur;*/
	@:ptrace(parseComparisonExpr)@
	xqrySkipSpace(cntxt);
	if (parseRangeExpr(cntxt, xb) == PARSE_OK) {
		/* NodeComp */
		xqrySkipSpace(cntxt);
		if (xqryKeyphrase2(cntxt, "<<")) {
			op= "<<"; mod="mguide";
		} else if (xqryKeyphrase2(cntxt, ">>")) {
			op= ">>"; mod="mguide";
		} else if (xqryKeyword(cntxt, "is", 2)) {
			op= "is"; mod="mguide";
		} else
		/* ValueComp | GeneralComp | NodeComp) RangeExpr)? */
		if (xqryKeyphrase1(cntxt, "=")) {
			op= "=="; mod="batcalc";
		} else if (xqryKeyphrase2(cntxt, "!=")) {
			op= "!="; mod="batcalc";
		} else if (xqryKeyphrase2(cntxt, "<=")) {
			op= "<="; mod="batcalc";
		} else if (xqryKeyphrase2(cntxt, ">=")) {
			op= ">="; mod="batcalc";
		} else if (xqryKeyphrase1(cntxt, ">")) {
			op= ">"; mod="batcalc";
		} else if (xqryKeyphrase1(cntxt, "<")) {
			op= "<"; mod="batcalc";
		} else
			/* ValueComp */
		if (xqryKeyword(cntxt, "eq", 2)) {
			op= "==";
		} else if (xqryKeyword(cntxt, "ne", 2)) {
			op= "!=";
		} else if (xqryKeyword(cntxt, "lt", 2)) {
			op= "<";
		} else if (xqryKeyword(cntxt, "le", 2)) {
			op= "<=";
		} else if (xqryKeyword(cntxt, "gt", 2)) {
			op= ">";
		} else if (xqryKeyword(cntxt, "ge", 2)) {
			op= ">=";
		} else{
			@:etrace(parseComparisonExpr)@
			return PARSE_OK;
		}

		ret= parseRangeExpr(cntxt, xb);
		if( ret == PARSE_OK){
			xqryCoercion(xb);
			xqryStatement(xb,calcRef,op,2);
		}
		@:etrace(parseComparisonExpr)@
		return ret;
	}
	return xqryError(cntxt,"<ComparisonOperator> expected\n");
}

STATIC int parseAndExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseAndExpr)@
	xqrySkipSpace(cntxt);
	if (parseComparisonExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "and", 3)) {
		return PARSE_OK;
	}
	return parseAndExpr(cntxt, xb);
}

STATIC int parseOrExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseOrExpr)@
	xqrySkipSpace(cntxt);
	if (parseAndExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "or", 2)) {
		return PARSE_OK;
	}
	return parseOrExpr(cntxt, xb);
}

STATIC int parseQuantifiedExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseQuantifiedExpr)@
	if (!xqryKeyword(cntxt, "some", 4) &&
	    !xqryKeyword(cntxt, "every", 5))
		return PARSE_ERR;
	do {
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		xqrySkipSpace(cntxt);
		if (parseVarName(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		xqrySkipSpace(cntxt);
		parseTypeDeclaration(cntxt, xb);
		if (!xqryKeyword(cntxt, "in", 2))
			return PARSE_ERR;
		xqrySkipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
	} while (currChar(cntxt) == ',');
	if (!xqryKeyword(cntxt, "satisfies", 9))
		return xqryError(cntxt,"'satisfies' expected\n");
	if (parseExprSingle(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	@:etrace(parseQuantifiedExpr)@
	return PARSE_OK;
}
STATIC int parseExprSingle(Client cntxt, Xbackend xb) {
	@:ptrace(parseExprSingle)@
	if (MALlookahead(cntxt, "for", 3) || 
	    MALlookahead(cntxt, "let", 3)) 
		return parseFLWORExpr(cntxt, xb);
	if (parseIfExpr(cntxt, xb) == PARSE_OK ||
		parseTypeswitchExpr(cntxt, xb) == PARSE_OK ||
		parseQuantifiedExpr(cntxt, xb) == PARSE_OK ||
		parseEnclosedExpr(cntxt,xb) == PARSE_OK ||
		parseOrExpr(cntxt,xb)== PARSE_OK){
			@:etrace(parseExprSingle)@
			return PARSE_OK;
		}
	return parseOrExpr(cntxt, xb);
}

int parseExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseExpr)@
	do {
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		xqrySkipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
	} while (currChar(cntxt) == ',');
	@:etrace(parseExpr)@
	return PARSE_OK;
}

STATIC int parseCaseClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseCaseClause)@
	xqrySkipSpace(cntxt);
	if (!xqryKeyword(cntxt, "case", 4))
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if (parseVarName(cntxt, xb) == PARSE_ERR) {
		if (!xqryKeyword(cntxt, "as", 2))
			return xqryError(cntxt,"'as' expected in CaseClause\n");
	}
	if (parseSequenceType(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	return parseReturnExprSingle(cntxt, xb);
}

STATIC int parseTypeswitchExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseTypeSwitch)@
	xqrySkipSpace(cntxt);
	if (!xqryKeyword(cntxt, "typeswitch", 10))
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) == '(') {
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
	} else
		return xqryError(cntxt,"'(' expected in TypeswitchExpr\n");
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in TypeswitchExpr\n");
	if (currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected in TypeswitchExpr\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);
	while (parseCaseClause(cntxt, xb) == PARSE_OK);
	if (!xqryKeyword(cntxt, "default", 7))
		return xqryError(cntxt,"'default' expected in TypeswitchExpr\n");
	return parseReturnExprSingle(cntxt, xb);
}

STATIC int parseIfExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseIfExpr)@
	if (!xqryKeyword(cntxt, "if", 2))
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '(') 
		return xqryError(cntxt,"'(' expected in IfExpr\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in IfExpr\n");
	if (currChar(cntxt) != ')') 
		return xqryError(cntxt,"')' expected in IfExpr\n");
	nextChar(cntxt);
		
	if (!xqryKeyword(cntxt, "then", 4))
		return xqryError(cntxt,"'then' expected in IfExpr\n");
	if (parseExprSingle(cntxt, xb) == PARSE_ERR)
		return xqryError(cntxt,"<Expr> expected in IfExpr\n");
	if (!xqryKeyword(cntxt, "else", 4))
		return xqryError(cntxt,"'else' expected in IfExpr\n");
	return parseExprSingle(cntxt, xb);
}

int parseReturnExprSingle(Client cntxt, Xbackend xb) {
	@:ptrace(parseReturnExprSingle)@
	(void) xb;
	if (!xqryKeyword(cntxt, "return", 6))
		return PARSE_ERR;
	return parseExprSingle(cntxt, xb);
}

STATIC int parseOrderByClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseOrderByClause)@
	xqryKeyword(cntxt, "stable", 6);
	if (!xqryKeyword(cntxt, "order", 5))
		return xqryError(cntxt,"'order' expected in OrderByClause\n");
	if (!xqryKeyword(cntxt, "by", 2))
		return xqryError(cntxt,"'by' expected in OrderByClause\n");
	xqrySkipSpace(cntxt);
	do {
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		xqrySkipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_OK) {
			/* check order modifier */
			if (xqryKeyword(cntxt, "ascending", 9));
			else if (xqryKeyword(cntxt, "descending", 10));
			else if (xqryKeyword(cntxt, "empty", 5));
			else if (xqryKeyword(cntxt, "greatest", 8));
			else if (xqryKeyword(cntxt, "least", 5));
			else if (xqryKeyword(cntxt, "collation", 5)) {
				/* parse URILiteral */
			} else
				return PARSE_ERR;
		} else
			return PARSE_ERR;
	} while (currChar(cntxt) == ',');
	@:etrace(parseOrderByClause)@
	return PARSE_OK;
}

STATIC int parseWhereClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseWhereClause)@
	    if (!xqryKeyword(cntxt, "where", 5))
		return PARSE_ERR;
	return parseExprSingle(cntxt, xb);
}

STATIC int parseForClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseForClause)@
	do {
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		xqrySkipSpace(cntxt);
		if (parseVarName(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<VarName> expected in ForClause\n");
		xqrySkipSpace(cntxt);
		parseTypeDeclaration(cntxt, xb);
/* should be optional
		if (parsePositionalVar(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
*/
		xqrySkipSpace(cntxt);
		if (!xqryKeyword(cntxt, "in", 2))
			return xqryError(cntxt,"'in' expected in ForClause\n");
		xqrySkipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<ExprSingle> expected in ForClause\n");
	} while (currChar(cntxt) == ',');
	@:etrace(parseForClause done)@
	return PARSE_OK;
}

STATIC int parseLetClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseLetClause)@
	do {
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		xqrySkipSpace(cntxt);
		if (parseVarName(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<VarName> expected in LetClause\n");
		xqrySkipSpace(cntxt);
		parseTypeDeclaration(cntxt, xb);
		if (!xqryKeyphrase2(cntxt, ":="))
			return xqryError(cntxt,"':=' expected in LetClause\n");
		xqrySkipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<ExprSingle> expected in LetClause\n");
		xqrySkipSpace(cntxt);
	} while (currChar(cntxt) == ',');
	@:etrace(parseLetClause done)@
	return PARSE_OK;
}

int parseFLWORExpr(Client cntxt, Xbackend xb) {
	int ret = PARSE_OK;
	@:ptrace(parseFLWORExpr)@
	do {
		xqrySkipSpace(cntxt);
		if (xqryKeyword(cntxt, "for", 3)) {
			ret = parseForClause(cntxt, xb);
		} else if (xqryKeyword(cntxt, "let", 3)) {
			ret = parseLetClause(cntxt, xb);
		} else {
			break;
		}
	} while (ret == PARSE_OK);
	if (ret == PARSE_ERR)
		return PARSE_ERR;
	if (xqryKeyword(cntxt, "where", 5)) {
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return xqryError(cntxt,"<ExprSingle> expected in FLWORExpr\n");
	}
	if (xqryKeyword(cntxt, "order", 5))
		return parseOrderByClause(cntxt, xb);

	xqrySkipSpace(cntxt);
	return parseReturnExprSingle(cntxt, xb);
}

STATIC int parseParam(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseParam)@
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '$')
		return PARSE_ERR;
	nextChar(cntxt);
	xqrySkipSpace(cntxt);
	if ( (i=parseQName(cntxt,xb)) <= 0) 
		return xqryError(cntxt,"<QName> expected in Param\n");
	parseTypeDeclaration(cntxt, xb);
	return PARSE_OK;
}

STATIC int parseParamList(Client cntxt, Xbackend xb) {
	@:ptrace(parseParamList)@
	if (parseParam(cntxt, xb) == PARSE_OK)
	do {
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != ','){
			@:etrace(parseParamList)@
			return PARSE_OK;
		}
		nextChar(cntxt);
	} while (parseParam(cntxt, xb));
	return PARSE_ERR;
}

STATIC int parseFunctionDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseFunctionDecl)@
	    /* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	    if (!xqryKeyword(cntxt, "function", 8))
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if ( (i=parseQName(cntxt,xb)) <= 0) 
		return xqryError(cntxt,"<Qname> expected in FunctionDecl\n");
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected in FunctionDecl\n");
	nextChar(cntxt);
	parseParamList(cntxt, xb);
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected in FunctionDecl\n");
	nextChar(cntxt);

	if (xqryKeyword(cntxt, "as", 2))
		parseSequenceType(cntxt, xb);
	if (xqryKeyword(cntxt, "external", 8))
		return PARSE_OK;

	if (currChar(cntxt) != '{')
		return xqryError(cntxt,"'{' expected in FunctionDecl\n");
	nextChar(cntxt);
	parseExpr(cntxt, xb);
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '}')
		return xqryError(cntxt,"'}' expected in FunctionDecl\n");
	nextChar(cntxt);
	@:etrace(parseFunctionDecl)@
	return PARSE_OK;
}

STATIC int parseConstructionDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseConstructionDecl)@
	(void) xb;
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (xqryKeyword(cntxt, "construction", 12))
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if (xqryKeyword(cntxt, "strict", 6)
	    || xqryKeyword(cntxt, "preserve", 8)){
			@:etrace(parseConstructionDecl)@
			return PARSE_OK;
		}
	return xqryError(cntxt,"'strict' or 'preserve' expected in ConstructionDecl\n");
}

STATIC int parseVarDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseVarDecl)@
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "variable", 8))
	return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '$')
		return PARSE_ERR;
	nextChar(cntxt);
	if ( (i=parseQName(cntxt,xb)) <= 0) 
		return xqryError(cntxt,"<QName> expected in VarDecl\n");
	xqrySkipSpace(cntxt);
	parseTypeDeclaration(cntxt, xb);

	xqrySkipSpace(cntxt);
	if (xqryKeyword(cntxt, "external", 8))
		return PARSE_OK;
	xqrySkipSpace(cntxt);
	if (xqryKeyphrase2(cntxt, ":=")) {
		xqrySkipSpace(cntxt);
		return parseSequenceType(cntxt, xb);
	}
	return xqryError(cntxt,"'external' or ':=' expected in VarDecl\n");
}

STATIC int parseModuleImport(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseModuleImport)@
	(void) xb;
	if (!xqryKeyword(cntxt, "import", 6))
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "module", 6))
		return xqryError(cntxt,"'module' expected in ModuleImport\n");

	if (xqryKeyword(cntxt, "namespace", 9)) {
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != '=')
			return xqryError(cntxt,"'=' expected in ModuleImport\n");
	}
	i = stringLength(cntxt);
	if (i)
		strCopy(cntxt, i);
	else
		return xqryError(cntxt,"<URIliteral> expected in ModuleImport\n");
	if (!xqryKeyword(cntxt, "at", 2))
		return xqryError(cntxt,"'at' expected in ModuleImport\n");
	xqrySkipSpace(cntxt);
	i = stringLength(cntxt);
	if (i)
		strCopy(cntxt, i);
	else
		return xqryError(cntxt,"<URIliteral> expected in ModuleImport\n");

	xqrySkipSpace(cntxt);
	while (currChar(cntxt) == ',') {
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
		if (i)
			strCopy(cntxt, i);
		else
			return xqryError(cntxt,"<URIliteral> expected in ModuleImport\n");
		xqrySkipSpace(cntxt);
	}
	@:etrace(parseModuleImport)@
	return PARSE_OK;
}

STATIC int parseSchemaPrefix(Client cntxt, Xbackend xb) {
	@:ptrace(parseSchemaPrefix)@
	(void) xb;
	if (xqryKeyword(cntxt, "namespace", 9)) {
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != '=')
			return xqryError(cntxt,"=' expected in SchemaPrefix\n");
		nextChar(cntxt);
		@:etrace(parseSchemaPrefix)@
		return PARSE_OK;
	} else if (xqryKeyword(cntxt, "default", 7)) {
		if (xqryKeyword(cntxt, "element", 7)) {
			if (xqryKeyword(cntxt, "namespace", 9)) {
				@:etrace(parseSchemaPrefix)@
				return PARSE_OK;
			}
		}
	}
	return xqryError(cntxt,"'element' 'namespace' expected in SchemaPrefix\n");
}

STATIC int parseSchemaImport(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseSchemaImport)@
	    if (!xqryKeyword(cntxt, "import", 6))
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if (!xqryKeyword(cntxt, "schema", 6))
		return PARSE_ERR;
	parseSchemaPrefix(cntxt, xb);
	i = stringLength(cntxt);
	if (i)
		strCopy(cntxt, i);
	else return xqryError(cntxt,"<URIliteral> expected in SchemaImport\n");

	if (!xqryKeyword(cntxt, "at", 2))
		return xqryError(cntxt,"'at' expected in SchemaImport\n");
	xqrySkipSpace(cntxt);
	if (i)
		strCopy(cntxt, i);
	else return xqryError(cntxt,"<URIliteral> expected in SchemaImport\n");

	xqrySkipSpace(cntxt);
	while (currChar(cntxt) == ',') {
		nextChar(cntxt);
		xqrySkipSpace(cntxt);
		if (i)
			strCopy(cntxt, i);
		else return xqryError(cntxt,"<URIliteral> expected in SchemaImport\n");
		xqrySkipSpace(cntxt);
	}
	@:etrace(parseSchemaImport)@
	return PARSE_OK;
}

STATIC int parseBaseURIDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseBaseURIDecl)@
	(void) xb;
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "base-url", 8))
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	i = stringLength(cntxt);
	if (i)
		strCopy(cntxt, i);
	else return xqryError(cntxt,"<URIliteral> expected in BaseURIDecl\n");
	@:etrace(parseBaseURIDecl)@
	return PARSE_OK;
}

STATIC int parseDefaultCollationDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseeDefaultCollationDecl)@
	(void) xb;
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "default", 7))
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "collation", 9))
		return xqryError(cntxt,"'collation' expected in DefaultCollationDecl\n");
	xqrySkipSpace(cntxt);
	i = stringLength(cntxt);
	if (i)
		strCopy(cntxt, i);
	else return xqryError(cntxt,"<URIliteral> expected in DefaultCollationDecl\n");
	@:etrace(parseeDefaultCollationDecl)@
	return PARSE_OK;
}

STATIC int parseCopyNamespacesDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseCopyNamespacesDecl)@
	(void) xb;
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "copy-namespaces", 15))
		return PARSE_ERR;
	if (xqryKeyword(cntxt, "preserve", 8) != PARSE_OK &&
	    xqryKeyword(cntxt, "no-preserve", 11) != PARSE_OK)
		return xqryError(cntxt,"'preserve' or 'no-preserve' expected in CopyNamespacesDecl\n");
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != ',')
		return xqryError(cntxt,"',' expected in CopyNamespacesDecl\n");
	if (xqryKeyword(cntxt, "inherit", 7) != PARSE_OK &&
	    xqryKeyword(cntxt, "no-inherit", 10) != PARSE_OK)
		return xqryError(cntxt,"'inherit' or 'no-inherit' expected in CopyNamespacesDecl\n");
	@:etrace(parseCopyNamespacesDecl)@
	return PARSE_OK;
}

STATIC int parseEmptyOrderDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseEmptyOrderDecl)@
	(void) xb;
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "default", 7))
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "order", 5))
		return xqryError(cntxt,"'order' expected in EmptyOrderDecl\n");
	if (!xqryKeyword(cntxt, "empty", 5))
		return xqryError(cntxt,"'empty' expected in EmptyOrderDecl\n");
	if (xqryKeyword(cntxt, "greatest", 8) != PARSE_OK &&
	    xqryKeyword(cntxt, "least", 5) != PARSE_OK)
		return xqryError(cntxt,"'greatest' or 'least' expected in EmptyOrderDecl\n");
	@:etrace(parseEmptyOrderDecl)@
	return PARSE_OK;
}

STATIC int parseOrderingModeDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseOrderingModeDecl)@
	(void) xb;
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "ordening", 8))
		return PARSE_ERR;
	if (xqryKeyword(cntxt, "ordered", 7) != PARSE_OK &&
	    xqryKeyword(cntxt, "unordered", 9) != PARSE_OK)
		return xqryError(cntxt,"'orderedd' or 'unordered' expected in OrderingModuleDecl\n");
	@:etrace(parseOrderingModeDecl)@
	return PARSE_OK;
}

STATIC int parseOptionDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseOptionDecl)@
	(void) xb;
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "option", 6))
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if ( (i=parseQName(cntxt,xb)) <= 0) 
		return xqryError(cntxt,"<QName> expected in OptionDecl\n");
	xqrySkipSpace(cntxt);
	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return xqryError(cntxt,"<URIliteral> expecte in OptionDecld\n");
	@:etrace(parseOptionDecl)@
	return PARSE_OK;
}

STATIC int parseDefaultNamespaceDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseDefaultNamespaceDecl)@
	(void) xb;
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "default", 7))
		return PARSE_ERR;
	if (xqryKeyword(cntxt, "element", 7) != PARSE_OK &&
	    xqryKeyword(cntxt, "function", 8) != PARSE_OK)
		return xqryError(cntxt,"'element' or 'function' expected in DefaultNamespaceDecl\n");
	if (!xqryKeyword(cntxt, "namespace", 9))
		return xqryError(cntxt,"'namespace' expected in DefaultNamespaceDecl\n");
	xqrySkipSpace(cntxt);
	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return xqryError(cntxt,"<URIliteral> expected in DefaultNamespaceDecl\n");
	@:etrace(parseDefaultNamespaceDecl)@
	return PARSE_OK;
}

STATIC int parseNamespaceDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseNamespaceDecl)@
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "namespace", 9))
		return PARSE_ERR;
	if ((i=parseNCName(cntxt,xb)) <= 0) 
		return xqryError(cntxt,"<NCName> expected in NamespaceDecl\n");
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '=')
		return xqryError(cntxt,"'=' expected in NamespaceDecl\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);
	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return xqryError(cntxt,"<URIliteral> expected in NamespaceDecl\n");
	@:etrace(parseNamespaceDecl)@
	return PARSE_OK;
}

STATIC int parseBoundarySpaceDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseBoundarySpaceDecl)@
	(void) xb;
	/* if( !xqryKeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!xqryKeyword(cntxt, "boundary-space", 14))
		return PARSE_ERR;
	if (xqryKeyword(cntxt, "preserve", 8) != PARSE_OK &&
	    xqryKeyword(cntxt, "split", 5) != PARSE_OK)
		return xqryError(cntxt,"'preserve' or 'split' expected in BoundarySpaceDecl\n");
	@:etrace(parseBoundarySpaceDecl)@
	return PARSE_OK;
}

STATIC int parseImport(Client cntxt, Xbackend xb) {
	@:ptrace(parseImport)@
	(void) xb;
	xqrySkipSpace(cntxt);
	if (parseSchemaImport(cntxt, xb) != PARSE_OK &&
	    parseModuleImport(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

STATIC int parseSetter(Client cntxt, Xbackend xb) {
	@:ptrace(parseSetter)@
	xqrySkipSpace(cntxt);
	if (parseBoundarySpaceDecl(cntxt, xb) != PARSE_OK &&
	    parseDefaultCollationDecl(cntxt, xb) != PARSE_OK &&
	    parseBaseURIDecl(cntxt, xb) != PARSE_OK &&
	    parseConstructionDecl(cntxt, xb) != PARSE_OK &&
	    parseOrderingModeDecl(cntxt, xb) != PARSE_OK &&
	    parseEmptyOrderDecl(cntxt, xb) != PARSE_OK &&
	    parseCopyNamespacesDecl(cntxt, xb) != PARSE_OK)
		return xqryError(cntxt,"<Setter> expected in Setter\n");
	@:etrace(parseSetter)@
	return PARSE_OK;
}

STATIC int parseProlog(Client cntxt, Xbackend xb) {
	@:ptrace(parseProlog)@
	do {
		if (xqryKeyword(cntxt, "declare", 7)) {
			xqrySkipSpace(cntxt);
			if (parseDefaultNamespaceDecl(cntxt, xb) != PARSE_OK && 
				parseSetter(cntxt, xb) != PARSE_OK &&
			    parseNamespaceDecl(cntxt, xb) != PARSE_OK)
				break;
		} else if (parseImport(cntxt, xb) == PARSE_ERR)
			break;
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != ';')
			break;
		nextChar(cntxt);
	} while (1);

	do {
		xqrySkipSpace(cntxt);
		if (parseVarDecl(cntxt, xb) != PARSE_OK &&
		    parseFunctionDecl(cntxt, xb) != PARSE_OK &&
		    parseOptionDecl(cntxt, xb) != PARSE_OK)
			break;
		xqrySkipSpace(cntxt);
		if (currChar(cntxt) != ';')
			break;
		nextChar(cntxt);
	} while (1);
	@:etrace(parseProlog)@
	return PARSE_OK;
}

STATIC int parseModuleDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseModuleDecl)@
	if (!xqryKeyword(cntxt, "module", 6))
		return PARSE_ERR;
	if (!xqryKeyword(cntxt, "namespace", 9))
		return xqryError(cntxt,"'namespace' expected in ModuleDecl\n");
	if ((i=parseNCName(cntxt,xb)) <= 0) 
		return xqryError(cntxt,"<NCName> expected in ModuleDecl\n");
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != '=')
		return xqryError(cntxt,"'=' expected in ModuleDecl\n");
	nextChar(cntxt);
	xqrySkipSpace(cntxt);

	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return xqryError(cntxt,"<URILiteral> expected in ModuleDecl\n");
	xqrySkipSpace(cntxt);
	if (currChar(cntxt) != ';')
		return xqryError(cntxt,"';' expected in ModuleDecl\n");
	nextChar(cntxt);
	@:etrace(parseModuleDecl)@
	return PARSE_OK;
}

STATIC int parseLibraryModule(Client cntxt, Xbackend xb) {
	@:ptrace(parseLibraryModule)@
	xqrySkipSpace(cntxt);
	if (parseModuleDecl(cntxt, xb) != PARSE_OK) 
		return PARSE_ERR;
	if (parseProlog(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	@:etrace(parseLibraryModule)@
	return PARSE_OK;
}

STATIC int parseMainModule(Client cntxt, Xbackend xb) {
	@:ptrace(parseMainModule)@
	xqrySkipSpace(cntxt);
	parseProlog(cntxt, xb);
	xqrySkipSpace(cntxt);
	/* QueryBody */
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	@:etrace(parseMainModule)@
	return PARSE_OK;
}

STATIC int parseVersionDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseVersionDecl)@
	(void) xb;
	xqrySkipSpace(cntxt);
	if (!xqryKeyword(cntxt, "xquery", 6))
		return PARSE_ERR;
	xqrySkipSpace(cntxt);
	if (!xqryKeyword(cntxt, "version", 7))
		return xqryError(cntxt,"'version' expected in VersionDecl\n");
	xqrySkipSpace(cntxt);

	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return xqryError(cntxt,"<StringLiteral> expected in VersionDecl\n");
	xqrySkipSpace(cntxt);

	if (xqryKeyword(cntxt, "encoding", 7)) {
		xqrySkipSpace(cntxt);
		i = stringLength(cntxt);
		if (i > 0)
			strCopy(cntxt, i);
		else
		return xqryError(cntxt,"<StringLiteral> expected in VersionDecl\n");
	}
	@:etrace(parseVersionDecl)@
	return PARSE_OK;
}

STATIC int parseXQueryModule(Client cntxt, Xbackend xb) {
	@:ptrace(parseModule)@
	xqrySkipSpace(cntxt);
	parseVersionDecl(cntxt, xb);
	if (parseLibraryModule(cntxt, xb) != PARSE_OK &&
	    parseMainModule(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	skipSpace(cntxt);
	nextChar(cntxt);
	@:etrace(parseModule)@
	return PARSE_OK;
}

int parseXQuery(Client cntxt) {
	Xbackend xb = BE(cntxt);
	int ret = PARSE_OK;

	if( xqryKeyword(cntxt,"explain",7))
		xb->mode= xqry_explain;
	else
	if( xqryKeyword(cntxt,"debug",5))
		xb->mode= xqry_debug;
	else
	if( xqryKeyword(cntxt,"trace",5))
		xb->mode= xqry_trace;
	ret = parseXQueryModule(cntxt, xb);
#ifdef _XQRY_DEBUG
		stream_printf(cntxt->fdout, "PARSE %s\n",
				  ret == PARSE_OK ? "OK" : "ERR");
		stream_flush(cntxt->fdout);
#endif
	while(*CURRENT(cntxt) && *CURRENT(cntxt) != ';')
		nextChar(cntxt);
	return ret;
}

@-
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input .
This code fragment is largely copied from the MAL parser, which also
included an automatic skiptoend not required here.
@c
int
xqryError(Client cntxt, str msg)
{
	Symbol curPrg;
	MalBlkPtr curBlk;
	char buf[10 * 1024];
	char *s = buf, *t, *l = lastline(cntxt);
	long i;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	if (curBlk)
		curBlk->errors++;

	/* accidental %s directives in the lastline can
	   crash the vfsprintf later => escape them */
	for (t = l; *t && *t != '\n'; t++) {
		if (*t == '%')
			*s++ = '%';
		*s++ = *t;
	}
	*s++ = '\n';
	*s++ = '!';
	/* produce the position marker */
	i = position(cntxt) + strlen(GDKERROR) - 1;
	for (; i > 0; i--) {
		*s++ = ((l && *(l + 1) && *l++ != '\t')) ? ' ' : '\t';
	}
	*s++ = '^';
	*s = 0;

	if (msg == 0)
		msg = "can't help you here, sorry.\n";
	if (strlen(msg) + strlen(buf) < 1020)
		snprintf(s, 1020, "%s", msg);
	GDKerror(buf);
	return PARSE_ERR;
}


@}
