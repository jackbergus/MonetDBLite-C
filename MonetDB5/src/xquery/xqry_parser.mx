@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f xqry_parser
@a M. L. Kersten
@v 0.1
@+ XQuery Compilation
MonetDB supports several front-ends. One of those is XQuery
as defined by W3C. 
The version shipped with MonetDB Version 4 is based on the seminal
work at Konstanz and Munich, which use a schema agnostic approach
to prepresent the document and derive query plans.

The 'older' method designed and used in conjunction with the XMark
benchmark worked with path summaries. This provides an extreme
partitioning scheme of the database.

The sample compilation shown below has been designed as a proof
of concept that compilation of valid xqueries of the complexity
of the XMark benchmark can indeed be processed using the MonetDB
guide.

@{
@+ Implementation notes
The XQuery parser is a recursive-descend implementation.
The parser produced follows the structure of the MAL parser
and produces a MAL block for direct execution.

The grammar is taken from W3C website.
@}
@+ Conversion Pitfalls
In this section we summarize the pitfalls and limitations encountered
in using the XQuery to MAL compiler.
The grammar is spread over a large code base, but the naming is kept
close to its use in the W3C documents.
@{
@+ The lexical analyzer
It uses the features offered by the MAL parser.
The key structured is a XML context descriptor,
which keeps track of all retrictics made sofar
on the document tree.
@h
#ifndef _XQRY_PARSER_H
#define _XQRY_PARSER_H

#include "xqry.h"
#include "mal_builder.h"
#include "mal_parser.h"

#undef currChar
#define MAXXVARS 64
#define MAXSCOPES 32

#define PARSE_OK 0
#define PARSE_ERR -1

typedef struct IDS {
	str nme;
	int tmpid;	/* MAL equivalent */
	str path;	/* dataguide entry */
} Xvariable;

typedef struct {
	Xvariable vars[MAXXVARS];
	short vtop;
	int scopes[MAXSCOPES];	/* keep track of the depth */
	int stop;
	MalBlkPtr mb;	/* compiled program */
} *Xbackend, XbackendRec;

xqry_export Xbackend newXbackend(MalBlkPtr mb);

xqry_export str XQRYcompile(str qry);
xqry_export str XQRYexec(int ret, str qry);

xqry_export int parseXQuery(Client cntxt);

#define _XQRY_DEBUG 1	/* debugging option */

#endif /* _XQRY_PARSER_H */
@-
It helps during development to trace the parser actions.
It can be extended with relevant Xbackend dumps.
@= ptrace
#ifdef _XQRY_DEBUG
{ 	str dummy = GDKstrdup(CURRENT(cntxt));
	if( strlen(dummy) >25) strcpy(dummy+25,"...\n");
	stream_printf(cntxt->fdout,"@1:%s",dummy);
	GDKfree(dummy);
}
#endif
@c
#include "xqry_parser.h"
#include "mal_interpreter.h"

#define BE(X) ((Xbackend)(X->state[PARSER]))
#define needMore(X)  currChar(X)	/* need at least one more character */
#define advanceMore(X,Y) {advance(X,Y); needMore(X);}

#define XPATHLENGTH 1024

extern int xqryError(Client cntxt, str msg);

@-
The XQuery parser may request for more information to 
complete a parsing request.
@c

char
currChar(Client c)
{
	if (*CURRENT(c) == 0) {
		MALreader(c);
		c->yycur = 0;
	}
	return *CURRENT(c);
}

@+ The Parser
Unlike MonetDB V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

@= restoreState
    if( c->listing)
		printFunction(c->fdout,c->curprg->def, c->listing);
	resetInstructions(c->curprg->def, oldstate.stop);
	resetVariables(c->curprg->def,@1, oldstate.vtop);

@+ Symbol table
The XQuery name space is a collection of nested scopes.
This means we have to keep track on the identifiers
introduced in a block and issue a bind operation before using them.
@c
static int
XfindId(Xbackend be, str nme)
{
	int i;
	for(i=0; i< be->vtop; i++)
		if (strcmp(be->vars[i].nme, nme) == 0)
			return be->vars[i].tmpid;
	return 0;

}

Xbackend
newXbackend(MalBlkPtr mb){
	Xbackend xb;
	xb = (Xbackend) GDKmalloc( sizeof(XbackendRec));
	memset((char*) xb, 0, sizeof(XbackendRec));
	xb->mb= mb;
	return xb;
}

@+ The parser
The Xquery parser uses the recursive descent method,
producing MAL code on the fly as needed.
Given the FLWOR expression this might not be optimal,
but further tuning is left to the backend.
@c
static int parseIfExpr(Client cntxt, Xbackend xb);
static int parseReturnExprSingle(Client cntxt, Xbackend xb);
static int parseFLWORExpr(Client cntxt, Xbackend xb);
static int parseTypeswitchExpr(Client cntxt, Xbackend xb);
static int parseExpr(Client cntxt, Xbackend xb);
static int parseExprSingle(Client cntxt, Xbackend xb);
static int parseDirectConstructor(Client cntxt, Xbackend xb);

static int
parseQName(Client cntxt, Xbackend xb){
	int l;
	str s;

	l= idLength(cntxt);
	if( l == 0)
		return PARSE_ERR;
	s= idCopy(cntxt,l);
	for(l=0; l <xb->vtop; l++)
		if( strcmp(s, xb->vars[l].nme)==0 ){
			GDKfree(s);
			return PARSE_OK;
		}
	if( xb->vtop == MAXXVARS){
		xqryError(cntxt,"Too many variables");
		xb->vtop --;
	}
	xb->vars[xb->vtop++].nme = s;
	return PARSE_OK;
}
@-
The key of the problem is to deal with path expressions.
@c
#define CHILD 1
#define DESCENDANT 2
#define ATTRIBUTE 3
#define SELF 4
#define DESCENDANT_OR_SELF 5
#define FOLLOWING 6
#define FOLLOWING_SIBLING 7

#define PARENT 8
#define ANCESTOR 9
#define PRECEDING 10
#define ANCESTOR_OR_SELF  11
#define PRECEDING_SIBLING 12

#define ITEM_TEST 19
#define NODE_TEST	20
#define TEXT_TEST 	21
#define COMMENT_TEST 22
#define EMPTY_SEQUENCE_TEST 23

static int
parseElementName(Client cntxt, Xbackend xb){
	int i;
	@:ptrace(parseElementName)@
	(void) xb;
	i= idLength(cntxt);
	if( i>0)
		idCopy(cntxt,i);
	else return PARSE_ERR;
	return PARSE_OK;
}

static int
parseTypeName(Client cntxt, Xbackend xb){
	int i;
	@:ptrace(parseTypeName)@
	(void) xb;
	i= idLength(cntxt);
	if( i>0)
		idCopy(cntxt,i);
	else return PARSE_ERR;
	return PARSE_OK;
}

static int
parseAttributeName(Client cntxt, Xbackend xb){
	int i;
	@:ptrace(parseAttributeName)@
	(void) xb;
	i= idLength(cntxt);
	if( i>0)
		idCopy(cntxt,i);
	else return PARSE_ERR;
	return PARSE_OK;
}

static int 
parseSchemaElementTest(Client cntxt, Xbackend xb){
	int i;
	@:ptrace(parseSchemaElementTest)@
	(void) xb;

	if( !MALkeyword(cntxt,"schema-element",14))
		return PARSE_ERR;
	skipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected\n");
	nextChar(cntxt);
	i= idLength(cntxt);
	if( i>0)
		idCopy(cntxt,i);
	else return xqryError(cntxt,"<ElementName> expected\n");
	skipSpace(cntxt);
	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected\n");
	return PARSE_OK;
}

static int 
parseElementTest(Client cntxt, Xbackend xb){
	if( !MALkeyword(cntxt,"element",7))
		return PARSE_ERR;
	@:ptrace(parseElementTest)@
	skipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected\n");
	nextChar(cntxt);
	skipSpace(cntxt);

	if( currChar(cntxt) == '*'){
		nextChar(cntxt);
	} else
		parseElementName(cntxt,xb);
	
	skipSpace(cntxt);
	
	if( currChar(cntxt) != ','){
		if( parseTypeName(cntxt,xb)== PARSE_ERR )
			return xqryError(cntxt,"<TypeName> expected\n");
		skipSpace(cntxt);
		if( currChar(cntxt)== '?')
			nextChar(cntxt);
	}

	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected\n");
	nextChar(cntxt);
	return PARSE_OK;
}


static int 
parseSchemaAttributeTest(Client cntxt, Xbackend xb){
	if( !MALkeyword(cntxt,"schema-attribute",16))
		return PARSE_ERR;
	@:ptrace(parseSchemaAttributeTest)@
	skipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected\n");
	nextChar(cntxt);
	skipSpace(cntxt);

	if( parseAttributeName(cntxt,xb)== PARSE_ERR )
		return PARSE_ERR;
	skipSpace(cntxt);

	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected\n");
	nextChar(cntxt);
	return PARSE_OK;
}


static int 
parseAttributeTest(Client cntxt, Xbackend xb){
	if( !MALkeyword(cntxt,"attribute",9))
		return PARSE_ERR;
	@:ptrace(parseAttributeTest)@
	skipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected\n");
	nextChar(cntxt);
	skipSpace(cntxt);

	if( currChar(cntxt) == '*'){
		nextChar(cntxt);
	} else
		parseElementName(cntxt,xb);
	
	skipSpace(cntxt);
	
	if( currChar(cntxt) != ','){
		if( parseTypeName(cntxt,xb)== PARSE_ERR )
			return PARSE_ERR;
		skipSpace(cntxt);
	}

	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected\n");
	nextChar(cntxt);
	return PARSE_OK;
}

static int
parseDocumentTest(Client cntxt, Xbackend xb){
	if( !MALkeyword(cntxt,"document-node",13))
		return PARSE_ERR;
	@:ptrace(parseDocumentTest)@
	skipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected\n");
	nextChar(cntxt);
	skipSpace(cntxt);
	if( parseElementTest(cntxt,xb) == PARSE_ERR ||
		parseSchemaElementTest(cntxt,xb) ){
	}
	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected\n");
	nextChar(cntxt);
	return PARSE_OK;
}

static int
parsePITest(Client cntxt, Xbackend xb){
	int i;

	(void) xb;
	if( !MALkeyword(cntxt,"processing-instruction",13))
		return PARSE_ERR;
	@:ptrace(parsePITest)@
	skipSpace(cntxt);
	if( currChar(cntxt) != '(')
		return xqryError(cntxt,"'(' expected\n");
	nextChar(cntxt);
	skipSpace(cntxt);
	i= idLength(cntxt);
	if(i)
		idCopy(cntxt,i);
	else {
		i= stringLength(cntxt);
		if( i>0)
			strCopy(cntxt,i);
	}

	skipSpace(cntxt);
	if( currChar(cntxt) != ')')
		return xqryError(cntxt,"')' expected\n");
	nextChar(cntxt);
	return PARSE_OK;
}

static int
parseKindTest(Client cntxt, Xbackend xb){
	int kind=0;

	@:ptrace(parseKindTest)@
	(void) xb; (void) kind;
	if( parseSchemaElementTest(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if( parseAttributeTest(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if( parseSchemaAttributeTest(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if( parseElementTest(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if( parseDocumentTest(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if( parsePITest(cntxt,xb)== PARSE_OK)
		return PARSE_OK;

	if( MALkeyword(cntxt,"node",4) ) kind= NODE_TEST; else
	if( MALkeyword(cntxt,"text",4) ) kind= TEXT_TEST; else
	if( MALkeyword(cntxt,"comment",7) ) kind= COMMENT_TEST; 
		else return PARSE_ERR;
	if( !keyphrase1(cntxt,"(") ) 
		return xqryError(cntxt,"'(' expected\n");
	if( !keyphrase1(cntxt,")") ) 
		return xqryError(cntxt,"')' expected\n");
	return PARSE_OK;
}

static int
parseItemType(Client cntxt, Xbackend xb){
	int i;
	@:ptrace(parseItemType)@
	if( parseKindTest(cntxt,xb) == PARSE_OK) return PARSE_OK;
	if( MALkeyword(cntxt,"item",4) ) {
		if( !keyphrase1(cntxt,"(") )
			return xqryError(cntxt,"'(' expected\n");
		if( !keyphrase1(cntxt,")") ) 
			return xqryError(cntxt,"')' expected\n");
		i = ITEM_TEST; 
		return PARSE_OK;
	}
	/* AtomicType */
	i = idLength(cntxt);
	(void) i;
	if( i== 0)
			return xqryError(cntxt,"<AtomicType> expected\n");
	return PARSE_OK;
}

static int
parseSequenceType(Client cntxt, Xbackend xb){
	@:ptrace(parseSequenceType)@
	if( MALkeyword(cntxt,"empty-sequence",13) ) {
		if( !keyphrase1(cntxt,"(") ) 
			return xqryError(cntxt,"'(' expected\n");
		if( !keyphrase1(cntxt,")") )
			return xqryError(cntxt,"')' expected\n");
		return PARSE_OK;
	}
	if( parseItemType(cntxt,xb) == PARSE_ERR)
		return PARSE_ERR;
	/* ItemType OccurrenceIndicator */
	switch(currChar(cntxt)){
	case '?':
	case '+':
	case '*':
		nextChar(cntxt);
	default:
		xqryError(cntxt,"'?', '+', '*' expected\n");
	}
	return PARSE_OK;
}

static int
parseTypeDeclaration(Client cntxt, Xbackend xb){
	skipSpace(cntxt);
	if( !MALkeyword(cntxt,"as",2) )
		return PARSE_ERR;
	@:ptrace(parseTypeDeclaration)@
	return parseSequenceType(cntxt,xb);
}
static int
parseCompPIConstructor(Client cntxt, Xbackend xb){
	int i;

	skipSpace(cntxt);
	if( !MALkeyword(cntxt,"processing-instruction",22))
		return PARSE_ERR;
	@:ptrace(parseCompPIConstructor)@
	skipSpace(cntxt);
	i= idLength(cntxt);
	if( i > 0){
		idCopy(cntxt,i);
		skipSpace(cntxt);
	} else{
		if( currChar(cntxt) != '{')
			return PARSE_ERR;
		nextChar(cntxt);
		parseExpr(cntxt,xb);
		skipSpace(cntxt);
		if( currChar(cntxt) != '}')
			return PARSE_ERR;
		nextChar(cntxt);
	}

	if( currChar(cntxt) != '{')
		return PARSE_ERR;
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	skipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}


static int
parseCompCommentConstructor(Client cntxt, Xbackend xb){
	skipSpace(cntxt);
	if( !MALkeyword(cntxt,"comment",7) )
		return PARSE_ERR;
	@:ptrace(parseCompCommentConstructor)@
	skipSpace(cntxt);
	if( currChar(cntxt) != '{')
		return PARSE_ERR;
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	skipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int
parseCompTextConstructor(Client cntxt, Xbackend xb){
	skipSpace(cntxt);
	if( !MALkeyword(cntxt,"text",4) )
		return PARSE_ERR;
	@:ptrace(parseCompTextConstructor)@
	skipSpace(cntxt);
	if( currChar(cntxt) != '{')
		return PARSE_ERR;
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	skipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int
parseCompAttrConstructor(Client cntxt, Xbackend xb){
	int i;
	skipSpace(cntxt);
	if( !MALkeyword(cntxt,"attribute",9))
		return PARSE_ERR;
	@:ptrace(parseCompAttrConstructor)@
	skipSpace(cntxt);
	i= idLength(cntxt);
	if( i > 0){
		idCopy(cntxt,i);
		skipSpace(cntxt);
	} else{
		if( currChar(cntxt) != '{')
			return PARSE_ERR;
		nextChar(cntxt);
		parseExpr(cntxt,xb);
		skipSpace(cntxt);
		if( currChar(cntxt) != '}')
			return PARSE_ERR;
		nextChar(cntxt);
	}

	if( currChar(cntxt) != '{')
		return PARSE_ERR;
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	skipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int
parseCompElemConstructor(Client cntxt, Xbackend xb){
	int i;
	skipSpace(cntxt);
	if( !MALkeyword(cntxt,"element",7))
		return PARSE_ERR;
	@:ptrace(parseCompElemConstructor)@
	skipSpace(cntxt);
	i= idLength(cntxt);
	if( i > 0){
		idCopy(cntxt,i);
		skipSpace(cntxt);
	} else{
		if( currChar(cntxt) != '{')
			return PARSE_ERR;
		nextChar(cntxt);
		parseExpr(cntxt,xb);
		skipSpace(cntxt);
		if( currChar(cntxt) != '}')
			return PARSE_ERR;
		nextChar(cntxt);
	}

	if( currChar(cntxt) != '{')
		return PARSE_ERR;
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	skipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int
parseCompDocConstructor(Client cntxt, Xbackend xb){
	skipSpace(cntxt);
	if( !MALkeyword(cntxt,"document",8))
		return PARSE_ERR;
	@:ptrace(parseCompDocConstructor)@
	skipSpace(cntxt);
	if( currChar(cntxt) != '{')
		return PARSE_ERR;
	nextChar(cntxt);
	parseExpr(cntxt,xb);
	skipSpace(cntxt);
	if( currChar(cntxt) != '}')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int
parseComputedConstructor(Client cntxt, Xbackend xb){
	@:ptrace(parseComputedConstructor)@
	(void) cntxt; (void) xb;
	if( parseCompDocConstructor(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if( parseCompElemConstructor(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if( parseCompAttrConstructor(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if( parseCompTextConstructor(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	if( parseCompCommentConstructor(cntxt,xb)== PARSE_OK)
		return PARSE_OK;
	return parseCompPIConstructor(cntxt,xb);
}

static int
parseDirPIConstructor(Client cntxt, Xbackend xb){
	int i;
	(void) xb;

	skipSpace(cntxt);
	if( !keyphrase2(cntxt,"<?") )
		return PARSE_ERR;
	@:ptrace(parseDirPIConstructor)@
	skipSpace(cntxt);
	/* PItarget */
	i= idLength(cntxt);
	if(i== 0)
		return PARSE_ERR;
	idCopy(cntxt,i);

	while( currChar(cntxt) != '?' && currChar(cntxt))
		nextChar(cntxt);
	if( !keyphrase2(cntxt,"?>") )
		return PARSE_ERR;
	return PARSE_OK;
}

static int
parseDirCommentConstructor(Client cntxt, Xbackend xb){
	int i =0;

	(void) xb;
	skipSpace(cntxt);
	if( !keyphrase(cntxt,"<!--",4) )
		return PARSE_ERR;
	@:ptrace(parseCommentConstructor)@
	do{
		if(currChar(cntxt)=='-' && i) break;
		if(currChar(cntxt)=='-') i++; else i= 0;
		nextChar(cntxt);
	} while(currChar(cntxt));
	if( !keyphrase1(cntxt,">") )
		return PARSE_ERR;
	return PARSE_OK;
}

static int
parseDirAttributeValue(Client cntxt, Xbackend xb){
	int i=0;
	(void) xb;
	@:ptrace(parseDirAttributeValue)@
	if( currChar(cntxt)== '"'){
		nextChar(cntxt);
		while( currChar(cntxt) && currChar(cntxt)!= '"')
		if( currChar(cntxt)=='"' && i){
			nextChar(cntxt); i=0;
		} else
		if( currChar(cntxt)=='"'){
			nextChar(cntxt); i=1;
		} else{
			nextChar(cntxt); i=0;
		}
		if( currChar(cntxt)== '"') nextChar(cntxt);
	} else
	if( currChar(cntxt)== '\'') {
	nextChar(cntxt);
	while (currChar(cntxt) && currChar(cntxt) != '\'')
		if (currChar(cntxt) == '\'' && i) {
			nextChar(cntxt);
			i = 0;
		} else if (currChar(cntxt) == '\'') {
			nextChar(cntxt);
			i = 1;
		} else {
			nextChar(cntxt);
			i = 0;
		}
	if (currChar(cntxt) == '\'')
		nextChar(cntxt);
}

else
return PARSE_ERR;
return PARSE_OK;
}

static int parseDirAttributeList(Client cntxt, Xbackend xb) {
	int i;

	@:ptrace(parseDirAttributeList)@
	(void) xb;
	skipSpace(cntxt);
	do {
		i = idLength(cntxt);
		if (i == 0)
			break;
		idCopy(cntxt, i);
		skipSpace(cntxt);
		/* parseDirAttributeValue */
	} while (currChar(cntxt));
	return PARSE_OK;
}

static int parseCDataSection(Client cntxt, Xbackend xb) {
	(void) xb;
	skipSpace(cntxt);
	if (!keyphrase(cntxt, "<![CDATA[", 9))
		return PARSE_ERR;
	@:ptrace(parseCDataSection)@
	    while (!keyphrase(cntxt, "]]>", 3))
		nextChar(cntxt);
	return PARSE_OK;
}

static int parseCommonContent(Client cntxt, Xbackend xb) {
	ValRecord val;
	int i;

	skipSpace(cntxt);
	if (keyphrase2(cntxt, "{{"))
		return PARSE_OK;
	if (keyphrase2(cntxt, "}}"))
		return PARSE_OK;
	if (currChar(cntxt) == '{') {
		nextChar(cntxt);
		if (parseExpr(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		skipSpace(cntxt);
		if (currChar(cntxt) != '}')
			return PARSE_ERR;
		nextChar(cntxt);
		return PARSE_OK;
	}
	/* check PredefinedEntityRef */
	/* and the rest */
	i = cstToken(cntxt, &val);
	if (i == 0 || val.vtype != TYPE_chr)
		return PARSE_ERR;
	advance(cntxt, i);
	return PARSE_OK;
}

static int parseElementContentChar(Client cntxt, Xbackend xb) {
	(void) xb;
	@:ptrace(parseElementContentChar)@
	switch (currChar(cntxt)) {
	case '{':
	case '}':
	case '<':
	case '&':
		return PARSE_ERR;
	}
	return PARSE_OK;
}

static int parsePredefinedEntityRef(Client cntxt, Xbackend xb) {
	(void) xb;
	if (currChar(cntxt) != '&')
		return PARSE_ERR;
	@:ptrace(parsePredefinedEntityRef)@
	nextChar(cntxt);
	if (MALkeyword(cntxt, "gt", 2));
	else if (MALkeyword(cntxt, "lt", 2));
	else if (MALkeyword(cntxt, "amp", 3));
	else if (MALkeyword(cntxt, "quot", 4));
	else if (MALkeyword(cntxt, "apos", 4));
	else
		return PARSE_ERR;
	if (currChar(cntxt) != ';')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int parseDirElementContent(Client cntxt, Xbackend xb) {
	@:ptrace(parseDirElementContent)@
	if (parseDirectConstructor(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (parseCDataSection(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (parseCommonContent(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	return parseElementContentChar(cntxt, xb);
}

static int parseDirElementConstructor(Client cntxt, Xbackend xb) {
	int i;

	@:ptrace(parseDirElementConstructor)@

	skipSpace(cntxt);
	if (currChar(cntxt) != '<')
		return PARSE_ERR;
	nextChar(cntxt);
	skipSpace(cntxt);
	i = idLength(cntxt);
	if (i == 0)
		return PARSE_ERR;
	idCopy(cntxt, i);
	parseDirAttributeList(cntxt, xb);

	skipSpace(cntxt);
	if (keyphrase2(cntxt, "/>"))
		return PARSE_OK;

	if (currChar(cntxt) != '>')
		return PARSE_ERR;
	nextChar(cntxt);

	parseDirElementContent(cntxt, xb);

	if (!keyphrase2(cntxt, "</"))
		return PARSE_ERR;

	i = idLength(cntxt);
	if (i == 0)
		return PARSE_ERR;
	idCopy(cntxt, i);

	if (currChar(cntxt) != '>')
		return PARSE_ERR;
	nextChar(cntxt);

	return PARSE_OK;
}

int parseDirectConstructor(Client cntxt, Xbackend xb) {
	@:ptrace(parseDirConstructor)@
	    if (parseDirElementConstructor(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (parseDirCommentConstructor(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	return parseDirPIConstructor(cntxt, xb);
}

static int parseConstructor(Client cntxt, Xbackend xb) {
	@:ptrace(parseConstructor)@
	    if (parseDirectConstructor(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	return parseComputedConstructor(cntxt, xb);
}

/* todo QName is [{prefix}':']?(name) */
static int parseNameTest(Client cntxt, Xbackend xb) {
	int i = 0;
	str nme;
	@:ptrace(parseNameTest)@
	(void) xb;
	(void) nme;
	i = idLength(cntxt);
	if (i > 0) {
		if (i)
			nme = idCopy(cntxt, i);
		if (currChar(cntxt) == ':') {
			nextChar(cntxt);
			if (currChar(cntxt) != '*') {
				return PARSE_ERR;
			}
		}
		return PARSE_OK;
	}
	if (currChar(cntxt) == '*') {
		nextChar(cntxt);
		if (currChar(cntxt) == ':') {
			nextChar(cntxt);
			i = idLength(cntxt);
			if (i)
				nme = idCopy(cntxt, i);
			else
				return PARSE_ERR;
		}
	} else {
		return PARSE_ERR;
	}
	return PARSE_OK;
}

/* we need readahead here */
static int parseFunctionCall(Client cntxt, Xbackend xb) {
	int before = cntxt->yycur;
	int i;
	int argc = 0;

	@:ptrace(parseFunctionCall)@
	skipSpace(cntxt);
	i = idLength(cntxt); /* need special version as a '-' may be in here */ 
	if (i == 0)
		return PARSE_ERR;
	idCopy(cntxt, i);
	skipSpace(cntxt);
	if (currChar(cntxt) != '(') {
		cntxt->yycur = before; /* hackkk */
		return PARSE_ERR;
	}
	nextChar(cntxt);
	do {
		skipSpace(cntxt);
		if (currChar(cntxt) == ')')
			break;
		if (argc && currChar(cntxt) != ',') 
			return PARSE_ERR;
		argc++;
	} while (parseExprSingle(cntxt, xb) == PARSE_OK);
	if (currChar(cntxt) != ')') 
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}


static int parsePrimaryExpr(Client cntxt, Xbackend xb) {
	int i;
	ValRecord val;

	@:ptrace(parsePrimaryExpr)@
	skipSpace(cntxt);
	i = stringLength(cntxt);
	if (i > 0) {
		strCopy(cntxt, i);
		advance(cntxt, i);
		return PARSE_OK;
	}
	if ((i = cstToken(cntxt, &val)) != 0) {
		advance(cntxt, i);
		return PARSE_OK;
	}
	if (currChar(cntxt) == '$') {
		nextChar(cntxt);
		skipSpace(cntxt);
		i = idLength(cntxt);
		if (i)
			idCopy(cntxt, i);
		else
			return PARSE_ERR;
		return PARSE_OK;
	}
	/* ParenthesizedExpr */
	if (currChar(cntxt) == '(') {
		parseExpr(cntxt, xb);
		if (currChar(cntxt) == ')')
			return PARSE_OK;
	} else
		/* ContextItemExpr */
	if (currChar(cntxt) == '.') {
		nextChar(cntxt);
		skipSpace(cntxt);
	} else
		/* OrderedExpr */
	if (MALkeyword(cntxt, "ordered", 7)) {
		skipSpace(cntxt);
		if (currChar(cntxt) != '{')
			return PARSE_ERR;
		nextChar(cntxt);
		if (parseExpr(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		skipSpace(cntxt);
		if (currChar(cntxt) != '}')
			return PARSE_ERR;
	} else
		/* UnorderedExpr */
	if (MALkeyword(cntxt, "unordered", 9)) {
		skipSpace(cntxt);
		if (currChar(cntxt) != '{')
			return PARSE_ERR;
		nextChar(cntxt);
		if (parseExpr(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		skipSpace(cntxt);
		if (currChar(cntxt) != '}')
			return PARSE_ERR;
	}
	if (parseConstructor(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	return parseFunctionCall(cntxt, xb);
}

static int parsePredicate(Client cntxt, Xbackend xb) {
	skipSpace(cntxt);
	if (currChar(cntxt) != '[')
		return PARSE_ERR;
	@:ptrace(parsePredicate)@
	nextChar(cntxt);
	skipSpace(cntxt);
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (currChar(cntxt) != ']')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;

}
static int parsePredicateList(Client cntxt, Xbackend xb) {
	@:ptrace(parsePredicateList)@
	do {
		skipSpace(cntxt);
	} while (parsePredicate(cntxt, xb) == PARSE_OK);
	return PARSE_OK;
}

static int parseFilterExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseFilter)@
	skipSpace(cntxt);
	if (parsePrimaryExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	return parsePredicateList(cntxt, xb);
}

static int parseNodeTest(Client cntxt, Xbackend xb) {
	@:ptrace(parseNodeTest)@
	if (parseKindTest(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	return parseNameTest(cntxt, xb);
}

static int parseAbbrevReverseStep(Client cntxt, Xbackend xb) {
	@:ptrace(parseAbbrevReverseStep)@
	(void) xb;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "..", 2)) {
		return PARSE_OK;
	}
	return PARSE_ERR;
}

static int parseReverseAxis(Client cntxt, Xbackend xb) {
	int ret;

	@:ptrace(parseReverseAxis)@
	(void) xb;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "parent", 6))
		ret = PARENT;
	else if (MALkeyword(cntxt, "ancestor", 8))
		ret = ANCESTOR;
	else if (MALkeyword(cntxt, "preceding", 9))
		ret = PRECEDING;
	else if (MALkeyword(cntxt, "preceding-sibling", 17))
		ret = PRECEDING_SIBLING;
	else if (MALkeyword(cntxt, "ancestor-or-self", 16))
		ret = ANCESTOR_OR_SELF;
	else
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!keyphrase2(cntxt, "::"))
		return PARSE_ERR;
	(void) ret;
	return PARSE_OK;
}

static int parseReverseStep(Client cntxt, Xbackend xb) {
	@:ptrace(parseReverseStep)@
	skipSpace(cntxt);
	if (parseReverseAxis(cntxt, xb) == PARSE_OK) {
		return parseNodeTest(cntxt, xb);
	}
	return parseAbbrevReverseStep(cntxt, xb);
}

static int parseAbbrevForwardStep(Client cntxt, Xbackend xb) {
	@:ptrace(parseAbbrevForwardStep)@
	(void) xb;
	skipSpace(cntxt);
	if (currChar(cntxt) == '@') {
		nextChar(cntxt);
		skipSpace(cntxt);
	}
	return parseNodeTest(cntxt, xb);
}

static int parseForwardAxis(Client cntxt, Xbackend xb) {
	int ret;

	@:ptrace(parseForwardAxis)@
	(void) xb;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "child", 5))
		ret = CHILD;
	else if (MALkeyword(cntxt, "descendant", 10))
		ret = DESCENDANT;
	else if (MALkeyword(cntxt, "attribute", 9))
		ret = ATTRIBUTE;
	else if (MALkeyword(cntxt, "following", 9))
		ret = FOLLOWING;
	else if (MALkeyword(cntxt, "following-sibling", 17))
		ret = FOLLOWING;
	else if (MALkeyword(cntxt, "self", 4))
		ret = SELF;
	else if (MALkeyword(cntxt, "descendant-or-self", 18))
		ret = DESCENDANT_OR_SELF;
	else
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!keyphrase2(cntxt, "::"))
		return PARSE_ERR;
	(void) ret;
	return PARSE_OK;
}

static int parseForwardStep(Client cntxt, Xbackend xb) {
	@:ptrace(parseForwardStep)@
	skipSpace(cntxt);
	if (parseForwardAxis(cntxt, xb) == PARSE_OK) {
		return parseNodeTest(cntxt, xb);
	}
	return parseAbbrevForwardStep(cntxt, xb);
}

static int parseAxisStep(Client cntxt, Xbackend xb) 
{
	@:ptrace(parseAxisStep)@
	if (parseReverseStep(cntxt, xb) == PARSE_OK) {
	} else if (parseForwardStep(cntxt, xb) == PARSE_OK) {
	} else
		return PARSE_ERR;
	return parsePredicateList(cntxt, xb);
}

static int parseStepExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseStepExpr)@
	if (parseFilterExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	return parseAxisStep(cntxt, xb);
}

int parseRelativePathExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	@:ptrace(parseRelativePathExpr)@
	skipSpace(cntxt);
	res = parseStepExpr(cntxt, xb);
	while (res == PARSE_OK && currChar(cntxt) == '/') {
		nextChar(cntxt);
		if (currChar(cntxt) == '/')
			nextChar(cntxt);
		skipSpace(cntxt);
		res = parseStepExpr(cntxt, xb);
		skipSpace(cntxt);
	}
	return res;
}

static int parsePathExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parsePathExpr)@
	skipSpace(cntxt);
	if (currChar(cntxt) == '/') {
		nextChar(cntxt);
		if (currChar(cntxt) == '/')
			nextChar(cntxt);
	}
	return parseRelativePathExpr(cntxt, xb);
}

@-
Variables are declared and stored on the top
of the variable stack.
@c 
static int parseVarName(Client cntxt, Xbackend xb);

static int parsePositionalVar(Client cntxt, Xbackend xb) {
	int i = xb->vtop - 1;	/* last defined one */
	(void) i;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "at", 2))
		return PARSE_ERR;
	@:ptrace(parsePositionalVar)@
	parseVarName(cntxt, xb);
	return PARSE_OK;
}

int parseVarName(Client cntxt, Xbackend xb) {
	skipSpace(cntxt);
	if (currChar(cntxt) != '$')
		return PARSE_ERR;
	@:ptrace(parseVarName)@
	nextChar(cntxt);
	skipSpace(cntxt);
	if (parseQName(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	/* has optional type? */

#ifdef _XQRY_DEBUG
	stream_printf(cntxt->fdout, "parseVarName %s\n",
		      xb->vars[xb->vtop - 1].nme);
#endif
	return PARSE_OK;
}

static int parsePragma(Client cntxt, Xbackend xb) {
	int i;
	(void) xb;
	skipSpace(cntxt);
	if (!keyphrase2(cntxt, "(#"))
		return PARSE_ERR;
	@:ptrace(parsePragma)@
	skipSpace(cntxt);
	i = idLength(cntxt);
	if (i)
		idCopy(cntxt, i);
	else
		return PARSE_ERR;
	i = 0;

	do {
		if (currChar(cntxt) == ')' && i)
			break;
		if (currChar(cntxt) == '#')
			i++;
		else
			i = 0;
		nextChar(cntxt);
	} while (currChar(cntxt));
	return PARSE_OK;
}

static int parseExtensionExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseExtensionExpr)@
	do {
		skipSpace(cntxt);
	} while (parsePragma(cntxt, xb) == PARSE_OK);
	if (currChar(cntxt) != '(')
		return PARSE_ERR;
	nextChar(cntxt);
	skipSpace(cntxt);
	parseExpr(cntxt, xb);
	if (currChar(cntxt) != ')')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int parseValidateExpr(Client cntxt, Xbackend xb) {
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "validate", 8))
		return PARSE_ERR;
	@:ptrace(parseValidateExpr)@
	    if (MALkeyword(cntxt, "lax", 3)) {
	} else if (MALkeyword(cntxt, "strict", 6)) {
	}
	skipSpace(cntxt);
	if (currChar(cntxt) != '(')
		return PARSE_ERR;
	nextChar(cntxt);
	skipSpace(cntxt);
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (currChar(cntxt) != ')')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int parseSingleType(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseSingleType)@
	(void) xb;
	i = idLength(cntxt);
	if (i)
		idCopy(cntxt, i);
	else
		return PARSE_ERR;
	if (currChar(cntxt) == '?')
		nextChar(cntxt);
	return PARSE_OK;
}

static int parseValueExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseValueExpr)@
	skipSpace(cntxt);
	if (parsePathExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (parseValidateExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (parseExtensionExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	return PARSE_ERR;
}

static int parseUnaryExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseUnaryExpr)@
	skipSpace(cntxt);
	if (currChar(cntxt) == '+' || currChar(cntxt) == '-')
		nextChar(cntxt);
	skipSpace(cntxt);
	return parseValueExpr(cntxt, xb);
}

static int parseCastExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseCastExpr)@
	skipSpace(cntxt);
	if (parseUnaryExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "cast", 4))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "as", 2))
		return PARSE_ERR;
	return parseSingleType(cntxt, xb);
}

static int parseCastableExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseCastableExpr)@
	skipSpace(cntxt);
	if (parseCastExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "castable", 8))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "as", 2))
		return PARSE_ERR;
	return parseSingleType(cntxt, xb);
}

static int parseTreatExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseTreatExpr)@
	skipSpace(cntxt);
	if (parseCastableExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "treat", 5))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "as", 2))
		return PARSE_ERR;
	return parseSequenceType(cntxt, xb);
}

static int parseInstanceOfExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseInstanceOfExpr)@
	skipSpace(cntxt);
	if (parseTreatExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "instance", 7))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "of", 2))
		return PARSE_ERR;
	return parseSequenceType(cntxt, xb);
}

static int parseIntersectExceptExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	@:ptrace(parseIntersectExceptExpr)@
	skipSpace(cntxt);
	if ((res = parseInstanceOfExpr(cntxt, xb)) == PARSE_OK)
		return res;
	do {
		skipSpace(cntxt);
		if (MALkeyword(cntxt, "intersect", 9)) {
		} else if (MALkeyword(cntxt, "except", 6)) {
		} else 
			break;
	} while ((res = parseInstanceOfExpr(cntxt, xb)) == PARSE_OK);
	return res;
}

static int parseUnionExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	@:ptrace(parseUnion)@
	skipSpace(cntxt);
	if ((res = parseIntersectExceptExpr(cntxt, xb)) == PARSE_OK)
		return res;
	do {
		skipSpace(cntxt);
		if (currChar(cntxt) == '|')
			nextChar(cntxt);
		else if (MALkeyword(cntxt, "union", 5)) {
		} else
			break;
	} while ((res = parseIntersectExceptExpr(cntxt, xb)) == PARSE_OK);
	return res;
}

static int parseMultiplicativeExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	@:ptrace(parseMultiplicativeExpr)@
	skipSpace(cntxt);
	if ((res = parseUnionExpr(cntxt, xb)) == PARSE_OK)
		return res;
	do {
		skipSpace(cntxt);
		if (currChar(cntxt) == '*')
			nextChar(cntxt);
		else if (MALkeyword(cntxt, "div", 3)) {
		} else if (MALkeyword(cntxt, "idiv", 4)) {
		} else if (MALkeyword(cntxt, "mod", 3)) {
		} else
			return PARSE_ERR;
	} while ((res = parseUnionExpr(cntxt, xb)) == PARSE_OK);
	return res;
}

static int parseAdditiveExpr(Client cntxt, Xbackend xb) {
	int res = PARSE_OK;
	@:ptrace(parseAdditiveExpr)@
	skipSpace(cntxt);
	if ((res = parseMultiplicativeExpr(cntxt, xb)) == PARSE_OK)
		return res;
	do {
		skipSpace(cntxt);
		if (currChar(cntxt) == '+' || currChar(cntxt) == '-')
			nextChar(cntxt);
		else
			break;
	} while ((res = parseMultiplicativeExpr(cntxt, xb)) == PARSE_OK);
	return res;
}
static int parseRangeExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseRangeExpr)@
	skipSpace(cntxt);
	if (parseAdditiveExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "to", 2))
		return parseRangeExpr(cntxt, xb);
	return PARSE_ERR;
}

static int parseComparisonExpr(Client cntxt, Xbackend xb) {
	int before = cntxt->yycur;
	@:ptrace(parseComparisonExpr)@
	skipSpace(cntxt);
	if (parseRangeExpr(cntxt, xb) == PARSE_OK) {
		assert(cntxt->yycur != before);
			/* NodeComp */
		skipSpace(cntxt);
		if (keyphrase2(cntxt, "<<")) {
		} else if (keyphrase2(cntxt, ">>")) {
		} else if (MALkeyword(cntxt, "is", 2)) {
		} else
		/* ValueComp | GeneralComp | NodeComp) RangeExpr)? */
		if (keyphrase1(cntxt, "=")) {
		} else if (keyphrase2(cntxt, "!=")) {
		} else if (keyphrase2(cntxt, "<=")) {
		} else if (keyphrase2(cntxt, ">=")) {
		} else if (keyphrase1(cntxt, ">")) {
		} else if (keyphrase1(cntxt, "<")) {
		} else
			/* ValueComp */
		if (MALkeyword(cntxt, "eq", 2)) {
		} else if (MALkeyword(cntxt, "ne", 2)) {
		} else if (MALkeyword(cntxt, "lt", 2)) {
		} else if (MALkeyword(cntxt, "le", 2)) {
		} else if (MALkeyword(cntxt, "gt", 2)) {
		} else if (MALkeyword(cntxt, "ge", 2)) {
		} else
			return PARSE_OK;

		return parseRangeExpr(cntxt, xb);
	}
	return PARSE_ERR;
}

static int parseAndExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseAndExpr)@
	skipSpace(cntxt);
	if (parseComparisonExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (!MALkeyword(cntxt, "and", 3)) {
		return PARSE_OK;
	}
	return parseAndExpr(cntxt, xb);
}

static int parseOrExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseOrExpr)@
	skipSpace(cntxt);
	if (parseAndExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (!MALkeyword(cntxt, "or", 2)) {
		return PARSE_OK;
	}
	return parseOrExpr(cntxt, xb);
}

static int parseQuantifiedExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseQuantifiedExpr)@
	if (!MALkeyword(cntxt, "some", 4) &&
	    !MALkeyword(cntxt, "every", 5))
		return PARSE_ERR;
	do {
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		skipSpace(cntxt);
		if (parseVarName(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		skipSpace(cntxt);
		parseTypeDeclaration(cntxt, xb);
		skipSpace(cntxt);
		if (!MALkeyword(cntxt, "in", 2))
			return PARSE_ERR;
		skipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
	} while (currChar(cntxt) == ',');
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "satisfies", 9))
		return PARSE_ERR;
	if (parseExprSingle(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	return PARSE_OK;
}
static int parseExprSingle(Client cntxt, Xbackend xb) {
	@:ptrace(parseExprSingle)@
	skipSpace(cntxt);
	if (MALlookahead(cntxt, "for", 3) || 
	    MALlookahead(cntxt, "let", 3)) 
		return parseFLWORExpr(cntxt, xb);
	if (parseIfExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;
	if (parseTypeswitchExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;

	if (parseQuantifiedExpr(cntxt, xb) == PARSE_OK)
		return PARSE_OK;

	return parseOrExpr(cntxt, xb);
}

int parseExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseExpr)@
	skipSpace(cntxt);
	do {
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		skipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
	} while (currChar(cntxt) == ',');
	return PARSE_OK;
}

static int parseCaseClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseCaseClause)@
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "case", 4))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (parseVarName(cntxt, xb) == PARSE_ERR) {
		if (!MALkeyword(cntxt, "as", 2))
			return PARSE_ERR;
	}
	if (parseSequenceType(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	return parseReturnExprSingle(cntxt, xb);
}

static int parseTypeswitchExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseTypeSwitch)@
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "typeswitch", 10))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (currChar(cntxt) == '(') {
		nextChar(cntxt);
		skipSpace(cntxt);
	} else
		return PARSE_ERR;
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (currChar(cntxt) == ')') {
		nextChar(cntxt);
		skipSpace(cntxt);
	} else
		return PARSE_ERR;
	while (parseCaseClause(cntxt, xb) == PARSE_OK);
	if (!MALkeyword(cntxt, "default", 7))
		return PARSE_ERR;
	return parseReturnExprSingle(cntxt, xb);
}

static int parseIfExpr(Client cntxt, Xbackend xb) {
	@:ptrace(parseIfExpr)@
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "if", 2))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (currChar(cntxt) == '(') {
		nextChar(cntxt);
		skipSpace(cntxt);
	}
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (currChar(cntxt) == ')') {
		nextChar(cntxt);
		skipSpace(cntxt);
	}
	if (!MALkeyword(cntxt, "then", 4))
		return PARSE_ERR;
	if (parseExprSingle(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	if (!MALkeyword(cntxt, "else", 4))
		return PARSE_ERR;
	return parseExprSingle(cntxt, xb);
}

int parseReturnExprSingle(Client cntxt, Xbackend xb) {
	@:ptrace(parseReturnExprSingle)@
	(void) xb;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "return", 6))
		return PARSE_ERR;
	return parseExprSingle(cntxt, xb);
}

static int parseOrderByClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseOrderByClause)@
	skipSpace(cntxt);
	MALkeyword(cntxt, "stable", 6);
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "order", 5))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "by", 2))
		return PARSE_ERR;
	skipSpace(cntxt);
	do {
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		skipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_OK) {
			/* check order modifier */
			skipSpace(cntxt);
			if (MALkeyword(cntxt, "ascending", 9));
			else if (MALkeyword(cntxt, "descending", 10));
			else if (MALkeyword(cntxt, "empty", 5));
			else if (MALkeyword(cntxt, "greatest", 8));
			else if (MALkeyword(cntxt, "least", 5));
			else if (MALkeyword(cntxt, "collation", 5)) {
				/* parse URILiteral */
			} else
				return PARSE_ERR;
		} else
			return PARSE_ERR;
	} while (currChar(cntxt) == ',');
	return PARSE_OK;
}

static int parseWhereClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseWhereClause)@
	    if (!MALkeyword(cntxt, "where", 5))
		return PARSE_ERR;
	return parseExprSingle(cntxt, xb);
}

static int parseForClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseForClause)@
	do {
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		skipSpace(cntxt);
		if (parseVarName(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		skipSpace(cntxt);
		parseTypeDeclaration(cntxt, xb);
/* should be optional
		if (parsePositionalVar(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
*/
		skipSpace(cntxt);
		if (!MALkeyword(cntxt, "in", 2))
			return PARSE_ERR;
		skipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
	} while (currChar(cntxt) == ',');
	@:ptrace(parseForClause done)@
	return PARSE_OK;
}

static int parseLetClause(Client cntxt, Xbackend xb) {
	@:ptrace(parseLetClause)@
	do {
		if (currChar(cntxt) == ',')
			nextChar(cntxt);
		skipSpace(cntxt);
		if (parseVarName(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		skipSpace(cntxt);
		parseTypeDeclaration(cntxt, xb);
		skipSpace(cntxt);
		if (!keyphrase2(cntxt, ":="))
			return PARSE_ERR;
		skipSpace(cntxt);
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
		skipSpace(cntxt);
	} while (currChar(cntxt) == ',');
	@:ptrace(parseLetClause done)@
	return PARSE_OK;
}

int parseFLWORExpr(Client cntxt, Xbackend xb) {
	int ret = PARSE_OK;
	@:ptrace(parseFLWORExpr)@
	do {
		skipSpace(cntxt);
		if (MALkeyword(cntxt, "for", 3)) {
			ret = parseForClause(cntxt, xb);
		} else if (MALkeyword(cntxt, "let", 3)) {
			ret = parseLetClause(cntxt, xb);
		} else {
			break;
		}
	} while (ret == PARSE_OK);
	if (ret == PARSE_ERR)
		return PARSE_ERR;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "where", 5)) {
		if (parseExprSingle(cntxt, xb) == PARSE_ERR)
			return PARSE_ERR;
	}
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "order", 5))
		return parseOrderByClause(cntxt, xb);

	skipSpace(cntxt);
	return parseReturnExprSingle(cntxt, xb);
}

static int parseParam(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseParam)@
	skipSpace(cntxt);
	if (currChar(cntxt) != '$')
		return PARSE_ERR;
	nextChar(cntxt);
	skipSpace(cntxt);
	i = idLength(cntxt);
	if (i)
		idCopy(cntxt, i);
	parseTypeDeclaration(cntxt, xb);
	return PARSE_OK;
}

static int parseParamList(Client cntxt, Xbackend xb) {
	@:ptrace(parseParamList)@
	    if (parseParam(cntxt, xb) == PARSE_OK)
		do {
			skipSpace(cntxt);
			if (currChar(cntxt) != ',')
				return PARSE_OK;
			nextChar(cntxt);
		} while (parseParam(cntxt, xb));
	return PARSE_ERR;
}

static int parseFunctionDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseFunctionDecl)@
	    /* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	    if (!MALkeyword(cntxt, "function", 8))
		return PARSE_ERR;
	skipSpace(cntxt);
	i = idLength(cntxt);
	if (i > 0)
		idCopy(cntxt, i);
	else
		return PARSE_ERR;
	skipSpace(cntxt);
	if (currChar(cntxt) != '(')
		return PARSE_ERR;
	nextChar(cntxt);
	parseParamList(cntxt, xb);
	skipSpace(cntxt);
	if (currChar(cntxt) != ')')
		return PARSE_ERR;
	nextChar(cntxt);

	skipSpace(cntxt);
	if (MALkeyword(cntxt, "as", 2))
		parseSequenceType(cntxt, xb);
	if (MALkeyword(cntxt, "external", 8))
		return PARSE_OK;

	if (currChar(cntxt) != '{')
		return PARSE_ERR;
	nextChar(cntxt);
	parseExpr(cntxt, xb);
	skipSpace(cntxt);
	if (currChar(cntxt) != '}')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int parseConstructionDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseConstructionDecl)@
	(void) xb;
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (MALkeyword(cntxt, "construction", 12))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "strict", 6)
	    || MALkeyword(cntxt, "preserve", 8))
		return PARSE_OK;
	return PARSE_ERR;
}

static int parseVarDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseVarDecl)@
	    /* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	    if (!MALkeyword(cntxt, "variable", 8))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (currChar(cntxt) != '$')
		return PARSE_ERR;
	nextChar(cntxt);
	i = idLength(cntxt);
	if (i > 0)
		idCopy(cntxt, i);
	else
		return PARSE_ERR;
	skipSpace(cntxt);
	if (parseTypeDeclaration(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;

	skipSpace(cntxt);
	if (MALkeyword(cntxt, "external", 8))
		return PARSE_OK;
	skipSpace(cntxt);
	if (keyphrase2(cntxt, ":=")) {
		skipSpace(cntxt);
		return parseSequenceType(cntxt, xb);
	}
	return PARSE_ERR;
}

static int parseModuleImport(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseModuleImport)@
	(void) xb;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "import", 6))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "module", 6))
		return PARSE_ERR;
	skipSpace(cntxt);

	if (MALkeyword(cntxt, "namespace", 9)) {
		skipSpace(cntxt);
		if (currChar(cntxt) != '=')
			return PARSE_ERR;
	}
	i = stringLength(cntxt);
	if (i)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "at", 2))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (i)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;

	skipSpace(cntxt);
	while (currChar(cntxt) == ',') {
		nextChar(cntxt);
		skipSpace(cntxt);
		if (i)
			strCopy(cntxt, i);
		else
			return PARSE_ERR;
		skipSpace(cntxt);
	}
	return PARSE_OK;
}

static int parseSchemaPrefix(Client cntxt, Xbackend xb) {
	@:ptrace(parseSchemaPrefix)@
	(void) xb;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "namespace", 9)) {
		skipSpace(cntxt);
		if (currChar(cntxt) != '=')
			return PARSE_ERR;
		nextChar(cntxt);
		return PARSE_OK;
	} else if (MALkeyword(cntxt, "default", 7)) {
		skipSpace(cntxt);
		if (MALkeyword(cntxt, "element", 7)) {
			skipSpace(cntxt);
			if (MALkeyword(cntxt, "namespace", 9)) {
				return PARSE_OK;
			}
		}
	}
	return PARSE_ERR;
}

static int parseSchemaImport(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseSchemaImport)@
	    if (!MALkeyword(cntxt, "import", 6))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "schema", 6))
		return PARSE_ERR;
	parseSchemaPrefix(cntxt, xb);
	i = stringLength(cntxt);
	if (i)
		strCopy(cntxt, i);
	skipSpace(cntxt);

	if (!MALkeyword(cntxt, "at", 2))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (i)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;

	skipSpace(cntxt);
	while (currChar(cntxt) == ',') {
		nextChar(cntxt);
		skipSpace(cntxt);
		if (i)
			strCopy(cntxt, i);
		else
			return PARSE_ERR;
		skipSpace(cntxt);
	}
	return PARSE_OK;
}

static int parseBaseURIDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseBaseURIDecl)@
	(void) xb;
	skipSpace(cntxt);
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!MALkeyword(cntxt, "base-url", 8))
		return PARSE_ERR;
	skipSpace(cntxt);
	i = stringLength(cntxt);
	if (i)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseDefaultCollationDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseeDefaultCollationDecl)@
	(void) xb;
	skipSpace(cntxt);
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!MALkeyword(cntxt, "default", 7))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "collation", 9))
		return PARSE_ERR;
	skipSpace(cntxt);
	i = stringLength(cntxt);
	if (i)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseCopyNamespacesDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseCopyNamespacesDecl)@
	(void) xb;
	skipSpace(cntxt);
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!MALkeyword(cntxt, "copy-namespaces", 15))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "preserve", 8) != PARSE_OK &&
	    MALkeyword(cntxt, "no-preserve", 11) != PARSE_OK)
		return PARSE_ERR;
	skipSpace(cntxt);
	if (currChar(cntxt) != ',')
		return PARSE_ERR;
	if (MALkeyword(cntxt, "inherit", 7) != PARSE_OK &&
	    MALkeyword(cntxt, "no-inherit", 10) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseEmptyOrderDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseEmptyOrderDecl)@
	(void) xb;
	skipSpace(cntxt);
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!MALkeyword(cntxt, "default", 7))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "order", 5))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "empty", 5))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "greatest", 8) != PARSE_OK &&
	    MALkeyword(cntxt, "least", 5) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseOrderingModeDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseOrderingModeDecl)@
	(void) xb;
	skipSpace(cntxt);
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!MALkeyword(cntxt, "ordening", 8))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "ordered", 7) != PARSE_OK &&
	    MALkeyword(cntxt, "unordered", 9) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseOptionDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseOptionDecl)@
	(void) xb;
	skipSpace(cntxt);
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!MALkeyword(cntxt, "option", 6))
		return PARSE_ERR;
	skipSpace(cntxt);
	i = idLength(cntxt);
	if (i > 0)
		idCopy(cntxt, i);
	else
		return PARSE_ERR;
	skipSpace(cntxt);
	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseDefaultNamespaceDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseDefaultNamespaceDecl)@
	(void) xb;
	skipSpace(cntxt);
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!MALkeyword(cntxt, "default", 7))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "element", 7) != PARSE_OK &&
	    MALkeyword(cntxt, "function", 8) != PARSE_OK)
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "namespace", 9))
		return PARSE_ERR;
	skipSpace(cntxt);
	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseNamespaceDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseNamespaceDecl)@
	(void) xb;
	skipSpace(cntxt);
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!MALkeyword(cntxt, "namespace", 9))
		return PARSE_ERR;
	skipSpace(cntxt);
	i = idLength(cntxt);
	if (i > 0)
		idCopy(cntxt, i);
	else
		return PARSE_ERR;
	skipSpace(cntxt);
	if (currChar(cntxt) != '=')
		return PARSE_ERR;
	nextChar(cntxt);
	skipSpace(cntxt);
	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseBoundarySpaceDecl(Client cntxt, Xbackend xb) {
	@:ptrace(parseBoundarySpaceDecl)@
	(void) xb;
	skipSpace(cntxt);
	/* if( !MALkeyword(cntxt,"declare",7) ) return PARSE_ERR; */
	if (!MALkeyword(cntxt, "boundary-space", 14))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (MALkeyword(cntxt, "preserve", 8) != PARSE_OK &&
	    MALkeyword(cntxt, "split", 5) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseImport(Client cntxt, Xbackend xb) {
	@:ptrace(parseImport)@
	(void) xb;
	skipSpace(cntxt);
	if (parseSchemaImport(cntxt, xb) != PARSE_OK &&
	    parseModuleImport(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseSetter(Client cntxt, Xbackend xb) {
	@:ptrace(parseSetter)@
	skipSpace(cntxt);
	if (parseBoundarySpaceDecl(cntxt, xb) != PARSE_OK &&
	    parseDefaultCollationDecl(cntxt, xb) != PARSE_OK &&
	    parseBaseURIDecl(cntxt, xb) != PARSE_OK &&
	    parseConstructionDecl(cntxt, xb) != PARSE_OK &&
	    parseOrderingModeDecl(cntxt, xb) != PARSE_OK &&
	    parseEmptyOrderDecl(cntxt, xb) != PARSE_OK &&
	    parseCopyNamespacesDecl(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseProlog(Client cntxt, Xbackend xb) {
	@:ptrace(parseProlog)@
	skipSpace(cntxt);
	do {
		if (MALkeyword(cntxt, "declare", 7)) {
			skipSpace(cntxt);
			if (parseDefaultNamespaceDecl(cntxt, xb) !=
			    PARSE_OK && parseSetter(cntxt, xb) != PARSE_OK
			    && parseNamespaceDecl(cntxt, xb) != PARSE_OK)
				break;
		} else if (parseImport(cntxt, xb) == PARSE_ERR)
			break;
		skipSpace(cntxt);
		if (currChar(cntxt) != ';')
			break;
		nextChar(cntxt);
	} while (1);

	do {
		skipSpace(cntxt);
		if (parseVarDecl(cntxt, xb) != PARSE_OK &&
		    parseFunctionDecl(cntxt, xb) != PARSE_OK &&
		    parseOptionDecl(cntxt, xb) != PARSE_OK)
			break;
		skipSpace(cntxt);
		if (currChar(cntxt) != ';')
			break;
		nextChar(cntxt);
	} while (1);
	return PARSE_OK;
}

static int parseModuleDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseModuleDecl)@
	(void) xb;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "module", 6))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "namespace", 9))
		return PARSE_ERR;

	i = idLength(cntxt);
	if (i > 0)
		idCopy(cntxt, i);
	else
		return PARSE_ERR;
	skipSpace(cntxt);
	if (currChar(cntxt) != '=')
		return PARSE_ERR;
	nextChar(cntxt);
	skipSpace(cntxt);

	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;
	skipSpace(cntxt);
	if (currChar(cntxt) != ';')
		return PARSE_ERR;
	nextChar(cntxt);
	return PARSE_OK;
}

static int parseLibraryModule(Client cntxt, Xbackend xb) {
	@:ptrace(parseLibraryModule)@
	skipSpace(cntxt);
	if (parseModuleDecl(cntxt, xb) != PARSE_OK &&
	    parseProlog(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseMainModule(Client cntxt, Xbackend xb) {
	@:ptrace(parseMainModule)@
	skipSpace(cntxt);
	parseProlog(cntxt, xb);
	skipSpace(cntxt);
	if (parseExpr(cntxt, xb) == PARSE_ERR)
		return PARSE_ERR;
	return PARSE_OK;
}

static int parseVersionDecl(Client cntxt, Xbackend xb) {
	int i;
	@:ptrace(parseVersionDecl)@
	(void) xb;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "xquery", 6))
		return PARSE_ERR;
	skipSpace(cntxt);
	if (!MALkeyword(cntxt, "version", 7))
		return PARSE_ERR;
	skipSpace(cntxt);

	i = stringLength(cntxt);
	if (i > 0)
		strCopy(cntxt, i);
	else
		return PARSE_ERR;
	skipSpace(cntxt);

	if (MALkeyword(cntxt, "encoding", 7)) {
		skipSpace(cntxt);
		i = stringLength(cntxt);
		if (i > 0)
			strCopy(cntxt, i);
		else
			return PARSE_ERR;
	}
	return PARSE_OK;
}

static int parseModule(Client cntxt, Xbackend xb) {
	@:ptrace(parseModule)@
	skipSpace(cntxt);
	parseVersionDecl(cntxt, xb);
	if (parseLibraryModule(cntxt, xb) != PARSE_OK &&
	    parseMainModule(cntxt, xb) != PARSE_OK)
		return PARSE_ERR;
	return PARSE_OK;
}

int parseXQuery(Client cntxt) {
	char c;
	Xbackend xb = BE(cntxt);
	int ret = PARSE_OK;

	while (ret != PARSE_ERR && (c = *CURRENT(cntxt))) {
		switch (c) {
		case '#':
			while (currChar(cntxt) && currChar(cntxt) != '\n')
				nextChar(cntxt);
			continue;
		case '\n':
		case '\r':
		case '\f':
		case ';':
		case '\t':
		case ' ':
			nextChar(cntxt);
			break;
		case 0:
			return cntxt->curprg->def->errors;
		case 'f':
		case 'l':
			ret = parseFLWORExpr(cntxt, xb);
#ifdef _XQRYDEBUG
			stream_printf(cntxt->fdout, "PARSE %s",
				      ret == PARSE_OK ? "OK" : "ERR");
			stream_flush(cntxt->fdout);
#endif
		}
	}
	chkProgram(cntxt->nspace, cntxt->curprg->def);
	/*return cntxt->curprg->def->errors; */
	return ret;
}

@-
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input .
This code fragment is largely copied from the MAL parser, which also
included an automatic skiptoend not required here.
@c
int
xqryError(Client cntxt, str msg)
{
	Symbol curPrg;
	MalBlkPtr curBlk;
	char buf[10 * 1024];
	char *s = buf, *t, *l = lastline(cntxt);
	long i;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	if (curBlk)
		curBlk->errors++;

	/* accidental %s directives in the lastline can
	   crash the vfsprintf later => escape them */
	for (t = l; *t && *t != '\n'; t++) {
		if (*t == '%')
			*s++ = '%';
		*s++ = *t;
	}
	*s++ = '\n';
	*s++ = '!';
	/* produce the position marker */
	i = position(cntxt) + strlen(GDKERROR) - 1;
	for (; i > 0; i--) {
		*s++ = ((l && *(l + 1) && *l++ != '\t')) ? ' ' : '\t';
	}
	*s++ = '^';
	*s = 0;

	if (msg == 0)
		msg = "can't help you here, sorry.\n";
	if (strlen(msg) + strlen(buf) < 1020)
		snprintf(s, 1020, "%s", msg);
	GDKerror(buf);
	return PARSE_ERR;
}


@}
