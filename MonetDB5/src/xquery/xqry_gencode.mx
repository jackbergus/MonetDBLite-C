
@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f xqry_gencode
@t XQuery code generation
@a N. Nes, M.L. Kersten
@+ XQUERY scenario
This module contains the MAL code generation support routines
for XQuery plans.

@h
#ifndef _XQUERY_GENCODE_H_
#define _XQUERY_GENCODE_H_

#include "xqry.h"
#include "xqry_backend.h"

#define _XQRY_GENCODE_DEBUG   1 /* trace it use */

xqry_export int XfindId(Xbackend xb, str nme);
xqry_export void XsetId(Xbackend xb, str nme, int id);
xqry_export int pushXvar(Xbackend xb);
xqry_export int popXvar(Xbackend xb);
xqry_export void xqryCoercion(Xbackend xb);
xqry_export void xqryStatement(Xbackend xb, str mod, str fcn, int argc);
xqry_export void xqryDefConstant(Xbackend xb, ValPtr val);

xqry_export void xqryPushNameTest(Xbackend xb, char *name);
xqry_export void xqryPushChild(Xbackend xb);
xqry_export void xqryPushDescendant(Xbackend xb);
xqry_export void xqryPushPredicate(Xbackend xb);
xqry_export void xqryPushAttribute(Xbackend xb);

xqry_export char *xqryXpathFlatten(Xbackend xb);

#endif /* _XQUERY_GENCODE_H_ */

@+ Symbol table
The XQuery name space is a collection of nested scopes.
This means we have to keep track on the identifiers
introduced in a block and issue a bind operation before using them.

@c
#include "xqry_gencode.h"
#include "mal_instruction.h"
#include "mal_builder.h"

int
XfindId(Xbackend xb, str nme)
{
    int i;
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG XfindId %s\n",nme);
#endif
    for(i=0; i< xb->vtop; i++)
        if (xb->vars[i].nme && strcmp(xb->vars[i].nme, nme) == 0)
            return xb->vars[i].tmpid;
    return 0;

}

void XsetId(Xbackend xb, str nme, int id)
{
	int i;
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG XfindId %s\n",nme);
#endif
	for(i=0; i< xb->vtop; i++) {
		if (xb->vars[i].nme && strcmp(xb->vars[i].nme, nme) == 0) {
			assert(xb->vars[i].tmpid == -1);
			xb->vars[i].tmpid = id;
			break;
		}
	}
}


@+
The result of statements are represented as variables
on the Xbackend variable stack. The parser can remove
them upon need.
@c
static int varid=0;

int
pushXvar(Xbackend xb){
	if( xb->vtop == MAXXVARS){
		stream_printf(GDKout,"OUT OF XBACKEND VARIABLES\n");
		xb->vtop--;
	} 
	/* initialize the variable further */
	xb->vars[xb->vtop].tmpid= 
		newVariable(xb->mb, newTmpName('X',varid++),TYPE_any);
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG pushXvar %d\n",xb->vars[xb->vtop].tmpid);
#endif
	xb->vtop++;
	return xb->vars[xb->vtop-1].tmpid;
}

int 
popXvar(Xbackend xb){
	if( xb->vtop == 0){
		stream_printf(GDKout,"OUT OF XBACKEND VARIABLES to pop\n");
		return 0;
	}
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG popXvar %d\n",xb->vars[xb->vtop-1].tmpid);
#endif
	return xb->vars[--xb->vtop].tmpid;
}
void
xqryDefConstant(Xbackend xb, ValPtr val){
	int i;
	i= pushXvar(xb);
	xb->vars[i].tmpid= defConstant(xb->mb, val->vtype,val);
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG xqryDefConstant %d %d\n",i, xb->vars[i].tmpid);
#endif
}
@-
The remainder of this document contains supportive routines
for code generation.

XQuery needs an elaborate coercion scheme, because many
expressions are polymorphic. The underlying engine requires
strong types and in most cases operations should even have
identical types. An explicit coercion is required.

The xqryCoercion produces the coercion code and relies on
the MAL compiler to generate error messages.
@c
void
xqryCoercion(Xbackend xb){
	int lt, rt, ct;
	InstrPtr p;
	str tpe;

	if( xb->vtop <2) return;
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG xqryCoercion %d %d %d\n",xb->vtop,
		xb->vars[xb->vtop-1].tmpid,xb->vars[xb->vtop-2].tmpid);
#endif
	lt= getVarType(xb->mb, xb->vars[xb->vtop-2].tmpid);
	rt= getVarType(xb->mb, xb->vars[xb->vtop-1].tmpid);
	ct= coercion(lt,rt);
	if( isaBatType(ct) )
		return;
	if( lt!= ct){
		tpe= getTypeName(ct);
		p= newStmt(xb->mb, calcRef, putName(tpe,strlen(tpe)));
		getArg(p,0)= newVariable(xb->mb, newTmpName('X',varid++),ct);
		pushArgument(xb->mb,p,xb->vars[xb->vtop-2].tmpid);
		xb->vars[xb->vtop-2].tmpid= getArg(p,0);
		GDKfree(tpe);
	}
	if( rt!= ct){
		tpe= getTypeName(ct);
		p= newStmt(xb->mb, calcRef, putName(tpe,strlen(tpe)));
		getArg(p,0)= newVariable(xb->mb, newTmpName('X',varid++),ct);
		pushArgument(xb->mb,p,xb->vars[xb->vtop-1].tmpid);
		xb->vars[xb->vtop-1].tmpid= getArg(p,0);
		GDKfree(tpe);
	}
}
@-
The xqry parser prepares the arguments for calls on the stack
which are translated in the end by a MAL function call.
We attempt to type check the instruction to ease
subsequent code generation.
@c
void
xqryStatement(Xbackend xb, str mod, str fcn, int argc){
	InstrPtr p;
	int i,err;
	
	p= newStmt(xb->mb, putName(mod,strlen(mod)), putName(fcn,strlen(fcn)) );
	for(i= xb->vtop-argc; i< xb->vtop; i++)
		pushArgument(xb->mb,p,xb->vars[i].tmpid);
	xb->vtop -= argc; /* don't forget garbage collection */
	getArg(p,0)= pushXvar(xb);
	err= xb->mb->errors; /* ignore if type check fails */
	typeChecker(0,xb->mb,p,TRUE);
	xb->mb->errors= err;
}

static void
xpathAdd(Xpath *x, xpath *p) 
{
	if (!x->h) {
		x->h = p;
	} else {
		x->t -> l = p;
	}
	x->t = p;
}

void
xqryPushNameTest(Xbackend xb, char *name)
{
	Xpath *X = &xb->vars[xb->vtop-1].xpath;
	xpath *x = X->t;

	x -> name = name;
	printf( "name = %s\n", name);
}

void
xqryPushChild(Xbackend xb)
{
	Xpath *x = &xb->vars[xb->vtop-1].xpath;
	xpath *p = ZNEW(xpath);

	p -> op = child;
	xpathAdd(x, p);
	printf( "/\n");
}

void
xqryPushDescendant(Xbackend xb)
{
	Xpath *x = &xb->vars[xb->vtop-1].xpath;
	xpath *p = ZNEW(xpath);

	p -> op = descendant;
	xpathAdd(x, p);
	printf( "//\n");
}

void
xqryPushPredicate(Xbackend xb)
{
	Xpath *x = &xb->vars[xb->vtop-1].xpath;
	xpath *p = ZNEW(xpath);

	p -> op = predicate;
	xpathAdd(x, p);
	printf( "[]\n");
}

void
xqryPushAttribute(Xbackend xb)
{
	Xpath *x = &xb->vars[xb->vtop-1].xpath;
	xpath *p = ZNEW(xpath);

	p -> op = attribute;
	xpathAdd(x, p);
	printf( "@\n");
}

char *
xqryXpathFlatten(Xbackend xb)
{
	Xpath *x = &xb->vars[xb->vtop-1].xpath;
	xpath *p = x->h;
	int len = 0;
	char *res, *s;

	for(p = x->h; p; p = p -> l) {
		switch(p->op) {
		case descendant:
			len ++;
		case child:
			len ++;
			break;
		case attribute:
			len += 4;
		default:
			break;
		}
		if (p->name)
			len += strlen(p->name); 
	}
	s = res = GDKmalloc(len + 1);
	for(p = x->h; p; p = p -> l) {
		if(p->op == descendant) {
			*s++ = '/';
			*s++ = '/';
		} else if (p->op == child || p->op == attribute) {
			*s++ = '/';
		}
		if (p->name) {
			len = strlen(p->name);
			memcpy(s, p->name, len);
			s+= len;
		}
		if(p->op == attribute) {
			int l = sizeof("@str");
			strncpy(s, "@str", l);
			s+=l;
		}
	}
	*s++ = 0;
	printf("flatten %s\n", res);
	return res;
}
