
@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f xqry_gencode
@t XQuery code generation
@a N. Nes, M.L. Kersten
@+ XQUERY scenario
This module contains the MAL code generation support routines
for XQuery plans.

@h
#ifndef _XQUERY_GENCODE_H_
#define _XQUERY_GENCODE_H_

#include "xqry.h"
#include "xqry_backend.h"

#define _XQRY_GENCODE_DEBUG   1 /* trace it use */

xqry_export int XfindId(Xbackend xb, str nme);
xqry_export int pushXvar(Xbackend xb);
xqry_export int popXvar(Xbackend xb);
xqry_export void xqryCoercion(Xbackend xb);
xqry_export void xqryStatement(Xbackend xb, str mod, str fcn, int argc);
xqry_export void xqryDefConstant(Xbackend xb, ValPtr val);

#endif /* _XQUERY_GENCODE_H_ */

@+ Symbol table
The XQuery name space is a collection of nested scopes.
This means we have to keep track on the identifiers
introduced in a block and issue a bind operation before using them.

@c
#include "xqry_gencode.h"
#include "mal_instruction.h"
#include "mal_builder.h"

int
XfindId(Xbackend xb, str nme)
{
    int i;
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG XfindId %s\n",nme);
#endif
    for(i=0; i< xb->vtop; i++)
        if (strcmp(xb->vars[i].nme, nme) == 0)
            return xb->vars[i].tmpid;
    return 0;

}

@+
The result of statements are represented as variables
on the Xbackend variable stack. The parser can remove
them upon need.
@c
static int varid=0;

int
pushXvar(Xbackend xb){
	if( xb->vtop == MAXXVARS){
		stream_printf(GDKout,"OUT OF XBACKEND VARIABLES\n");
		xb->vtop--;
	} 
	/* initialize the variable further */
	xb->vars[xb->vtop].tmpid= 
		newVariable(xb->mb, newTmpName('X',varid++),TYPE_any);
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG pushXvar %d\n",xb->vars[xb->vtop].tmpid);
#endif
	xb->vtop++;
	return xb->vars[xb->vtop-1].tmpid;
}

int 
popXvar(Xbackend xb){
	if( xb->vtop == 0){
		stream_printf(GDKout,"OUT OF XBACKEND VARIABLES to pop\n");
		return 0;
	}
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG popXvar %d\n",xb->vars[xb->vtop-1].tmpid);
#endif
	return xb->vars[--xb->vtop].tmpid;
}
void
xqryDefConstant(Xbackend xb, ValPtr val){
	int i;
	i= pushXvar(xb);
	xb->vars[i].tmpid= defConstant(xb->mb, val->vtype,val);
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG xqryDefConstant %d %d\n",i, xb->vars[i].tmpid);
#endif
}
@-
The remainder of this document contains supportive routines
for code generation.

XQuery needs an elaborate coercion scheme, because many
expressions are polymorphic. The underlying engine requires
strong types and in most cases operations should even have
identical types. An explicit coercion is required.

The xqryCoercion produces the coercion code and relies on
the MAL compiler to generate error messages.
@c
void
xqryCoercion(Xbackend xb){
	int lt, rt, ct;
	InstrPtr p;
	str tpe;

	if( xb->vtop <2) return;
#ifdef _XQRY_GENCODE_DEBUG
	stream_printf(GDKout,"#DEBUG xqryCoercion %d %d %d\n",xb->vtop,
		xb->vars[xb->vtop-1].tmpid,xb->vars[xb->vtop-2].tmpid);
#endif
	lt= getVarType(xb->mb, xb->vars[xb->vtop-2].tmpid);
	rt= getVarType(xb->mb, xb->vars[xb->vtop-1].tmpid);
	ct= coercion(lt,rt);
	if( isaBatType(ct) )
		return;
	if( lt!= ct){
		tpe= getTypeName(ct);
		p= newStmt(xb->mb, calcRef, putName(tpe,strlen(tpe)));
		getArg(p,0)= newVariable(xb->mb, newTmpName('X',varid++),ct);
		pushArgument(xb->mb,p,xb->vars[xb->vtop-2].tmpid);
		xb->vars[xb->vtop-2].tmpid= getArg(p,0);
		GDKfree(tpe);
	}
	if( rt!= ct){
		tpe= getTypeName(ct);
		p= newStmt(xb->mb, calcRef, putName(tpe,strlen(tpe)));
		getArg(p,0)= newVariable(xb->mb, newTmpName('X',varid++),ct);
		pushArgument(xb->mb,p,xb->vars[xb->vtop-1].tmpid);
		xb->vars[xb->vtop-1].tmpid= getArg(p,0);
		GDKfree(tpe);
	}
}
@-
The xqry parser prepares the arguments for calls on the stack
which are translated in the end by a MAL function call.
We attempt to type check the instruction to ease
subsequent code generation.
@c
void
xqryStatement(Xbackend xb, str mod, str fcn, int argc){
	InstrPtr p;
	int i,err;
	
	p= newStmt(xb->mb, putName(mod,strlen(mod)), putName(fcn,strlen(fcn)) );
	for(i= xb->vtop-argc; i< xb->vtop; i++)
		pushArgument(xb->mb,p,xb->vars[i].tmpid);
	xb->vtop -= argc; /* don't forget garbage collection */
	getArg(p,0)= pushXvar(xb);
	err= xb->mb->errors; /* ignore if type check fails */
	typeChecker(0,xb->mb,p,TRUE);
	xb->mb->errors= err;
}
