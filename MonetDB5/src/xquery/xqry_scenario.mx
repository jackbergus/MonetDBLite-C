@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f xqry_scenario
@t XQUERY scenario 
@a N. Nes
@+ XQUERY scenario
The XQUERY scenario implementation is a derivative of the MAL session scenario.

@h
#ifndef _XQUERY_SCENARIO_H_
#define _XQUERY_SCENARIO_H_
#include "xqry.h"

#define _XQUERY_SCENARIO_DEBUG 
/* #define _XQUERY_READER_DEBUG */
/* #define _XQUERY_PARSER_DEBUG */

xqry_export str XQUERYsession(str *ret);
xqry_export str XQUERYprelude();
xqry_export str XQUERYepilogue();

xqry_export str XQUERYexit(Client c);
xqry_export str XQUERYinit(Client c);
xqry_export str XQUERYexitClient(Client c);
xqry_export str XQUERYinitClient(Client c);
xqry_export str XQUERYreader(Client c);
xqry_export str XQUERYparser(Client c);
xqry_export str XQUERYengine(Client c);

#endif /* _XQUERY_SCENARIO_H_ */

@c
#include "xqry_scenario.h"
#include "xqry_parser.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

static void xqryfreeVariables(MalBlkPtr mb, MalStkPtr glb, int start);

str
XQUERYsession(str *ret)
{
	str msg = MAL_SUCCEED;

	msg = setScenario(MCgetClient(), "xquery");
	*ret = 0;
	return msg;
}

str
XQUERYprelude()
{
	Scenario s = getFreeScenario();
	if (!s)
		return NULL; /* should be an error */
	s->name = "xquery";
	s->language = "xq";
	s->initSystem = "XQUERYinit";
	s->exitSystem = "XQUERYexit";
	s->initClient = "XQUERYinitClient";
	s->exitClient = "XQUERYexitClient";
	s->reader = "XQUERYreader";
	s->parser = "XQUERYparser";
	s->optimizer = "XQUERYoptimizer";
	/* s->tactics = .. */
	s->engine = "XQUERYengine";
	XQRYinit();
	return MAL_SUCCEED;
}
str
XQUERYepilogue()
{
	return MAL_SUCCEED;
}

str
XQUERYinit(Client c)
{
	(void) c;		/* not used */
	optimizerInit();
	return MAL_SUCCEED;
}

str
XQUERYexit(Client c)
{
	(void) c;		/* not used */
	return MAL_SUCCEED;
}

str
XQUERYinitClient(Client c)
{
	if (c->state[PARSER] == NULL) {
		Xbackend  xb = newXbackend(c->curprg->def);
		c->state[PARSER] = (void*)xb;
	}

	c->yycur = 0;		/* make sure we don't reuse the used input */
	c->fdin->eof = 1;	/* force prompt on first iteration */
	return MAL_SUCCEED;
}

str
XQUERYexitClient(Client c)
{
	if (c->state[PARSER]) {
		GDKfree(c->state[PARSER]); /* TODO destroyXbackend */
		c->state[PARSER] = NULL;
	}
	return MAL_SUCCEED;
}

str
XQUERYreader(Client c)
{
	int go = TRUE;
	int more = TRUE;
	bstream *in = c->fdin;
	int blocked = isa_block_stream(in->s);

	if (c->mode <= FINISHING) {
		c->mode = FINISHING;
		return NULL;
	}

	while(more) {
	    more = FALSE;
	    if (go && in->pos >= in->len) {
		ssize_t rd;

		if (c->bak) {
			MCpopClientInput(c);
			in = c->fdin;
			c->fdin->pos += c->yycur;
			c->yycur = 0;
		}
		if (in->eof || !blocked) {
			if (go && ((!blocked && stream_write(c->fdout, c->prompt, c->promptlength, 1) != 1) || stream_flush(c->fdout))) {
				go = FALSE;
				break;
			}
			in->eof = 0;
		}
		if (go && (rd = bstream_next(in)) <= 0) {
			if (rd == 0 && in->eof) {
				/* we hadn't seen the EOF before, so just try again
				   (this time with prompt) */
				more = TRUE;
				continue;
			}
			go = FALSE;
			break;
		}
	    }
	}
	if ( !go || (strncmp(CURRENT(c), "quit", 4) == 0)) {
		in->pos = in->len;	/* skip rest of the input */
		c->mode = FINISHING;
		return NULL;
	}
	return MAL_SUCCEED;
}

str
XQUERYparser(Client c)
{
	Xbackend xb;
	int err, oldstop, oldvtop;
#ifdef _XQRY_SCENARIO
	stream_printf(c->fdout,"#start the xquery parser\n");
#endif

	xb= (Xbackend) c->state[PARSER];
	if(xb == NULL || c->curprg->def== NULL) 
		return throwMessage("xquery.parser","No context available\n");

    oldvtop = c->curprg->def->vtop;
    oldstop = c->curprg->def->stop;

	err=parseXQuery(c);

	if( err == 0){
		pushEndInstruction(c->curprg->def);
		chkProgram(c->nspace, c->curprg->def);
	}
	if( c->curprg->def->errors || err){
		showErrors();
		if( xb->mode == xqry_explain)
			printFunction(c->fdout, c->curprg->def,LIST_MAL_ALL);
		/* restore the state */
		resetMalBlk(c->curprg->def, oldstop);
		xqryfreeVariables(c->curprg->def, c->glb, oldvtop);
		c->curprg->def->errors = 0;
		return throwMessage("xquery.parser","Parsing errors\n");
	} 
	return MAL_SUCCEED;
}

str
XQUERYoptimizer(Client c)
{	
#ifdef _XQRY_SCENARIO
	stream_printf(c->fdout,"#start the xquery optimizer\n");
#endif
	(void)c;
	return MAL_SUCCEED;
}
	
str
XQUERYengine(Client c)
{
	Xbackend xb;
#ifdef _XQRY_SCENARIO
	stream_printf(c->fdout,"#start the xquery engine\n");
#endif
	xb= (Xbackend) c->state[PARSER];
	if(xb == NULL || c->curprg->def== NULL|| c->curprg->def->errors)
		return MAL_SUCCEED;

	if( xb->mode == xqry_explain)
		printFunction(c->fdout, c->curprg->def,0);
	return MAL_SUCCEED;
}

void
xqryfreeVariables(MalBlkPtr mb, MalStkPtr glb, int start)
{
    int i;

    for (i = start; i < mb->vtop;) {
        clearVariable(mb, i);

        if (glb) {
            garbageElement(&glb->stk[i]);
            /* clean stack entry */
            glb->stk[i].vtype = TYPE_int;
            glb->stk[i].val.ival = 0;
            glb->stk[i].len = 0;
        }
        i++;
    }
    mb->vtop = start;
}

