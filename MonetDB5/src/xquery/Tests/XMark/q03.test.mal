# Query Q3:
# Return the IDs of all open auctions whose current increase is at
# least twice as high as the initial increase.

# FOR    $b IN document("auction.xml")/site/open_auctions/open_auction
# WHERE  $b/bidder[1]/increase/text() *2 <= $b/bidder[last()]/increase/text()
# RETURN <increase first=$b/bidder[1]/increase/text()
#                  last=$b/bidder[last()]/increase/text()/>

# This is a more complex application of index lookups.  In the case of
# a relational DBMS, the query can take advantage of set-valued
# aggregates on the index attribute to accelerate the execution.

#var monet_guide := bat("mxml_guide");
#var b1 := bat(find(monet_guide,"site/open_auctions/open_auction.bidder"));

#var b2 := bat(find(monet_guide,"site/open_auctions/open_auction/bidder/increase"));

#var b3 := bat(find(monet_guide,"site/open_auctions/open_auction/bidder/increase.cdata"));

#var b4 := bat(find(monet_guide,"site/open_auctions/open_auction/bidder/increase.cdata.string@"));
#var b6 := {min}(b1);
#var b7 := {max}(b1);
#var b8 := join(b6,b2);
#var b9 := join(b8,b3);
#var b10 := join(b9,b4);
#var b11 := join(b7,b2);
#var b13 := join(b12,b4);
#var b14 := [flt](b10);
#var b15 := [flt](b13);
#var b16 := [*](b14,2);
#var b17 := [<=](b16,b15);
#var b18 := uselect(b17,true).mirror();
#var b20 := join(b18,b10).sort();
#var b12 := join(b11,b3);
#var b21 := join(b18,b13);
#var b22 := leftjoin(reverse(b20),b21);
#b22@batloop() {
#printf("<increase first=\"%s\" last=\"%s\"/>\n", $h, $t);
#}

# FOR    $b IN document("auction.xml")/site/open_auctions/open_auction
mg:= mguide.open("auctions.xml");
b0:bat[:oid,:oid]:= xml.bind(mg,"site/open_auctions/open_auction");
# create the context node set using the tail of the open_auctions/open_auction
br:= bat.reverse(b0);
b := bat.mirror(br);

# WHERE  $b/bidder[1] -> open_auction/bidder
x0:bat[:oid,:oid]:= mguide.bind(mg,"/site/open_auctions/open_auction/bidder");
# detect that the head of x0 is fully covered by b, which is a path prefix match
# and no further reduction has been made. Then the next join is trivial.
X1 := algebra.join(b,x0);
g0:= group.first(x1);

# WHERE  $b/bidder[1]/increase/text()
b3 := mguide.descendant(mg,g0,
	"site/open_auctions/open_auction/bidder/",
	"site/open_auctions/open_auction/bidder/increase/string@");

# WHERE  $b/bidder[1]/increase/text() * 2
f4 := batcalc.int(b3);
# we should probably use .../increase/int() and generate an error if not
# all text is a legal integer
f5 := batcalc.*(f4,2);

# $b/bidder[last()]
x2:bat[:oid,:oid] := mguide.bind(mg,"site/open_auctions/open_auction/bidder");
x3 := algebra.join(b,x2);
# f6 represents the edge [open_auction,bidder[1]]
f6 := group.last(x3); # to be implemented

# $b/bidder[last()]/increase/text()
b7 := mguide.descendant(mg,f6,
	"site/open_auctions/open_auction/bidder",
	"site/open_auctions/open_auction/bidder/increase/string@");
f9:= batcalc.int(b7);
#in this case we should retain the mapping $b/string@ instead
# of the increase/string@ step

# WHERE  $b/bidder[1]/increase/text() *2 <= $b/bidder[last()]/increase/text()
# both operands are arbitrary bat[:oid,:int] objects, which call for a more
# complicated comparison, where the comparison is only made if the oids also match.
# Furthermore, Xquery only requires for each lhs to find a single
# rhs that satisfies the constraint.
# What if there are multiple existencials in the same conditions?
r0 := mguide.<=(f5,f9);
# the result should be the subset of f5 that qualifies

# consolidate the result of the expression in the qualifying b-nodes
b := algebra.semijoin(b,r0);
# how about the second operand?

# sort the documents for retrieval
b := algebra.sort(b);

mr := mguide.new("result");
mguide.add(mr, "/", b);
mguide.add(mr, "/increase", b);
# assume the common expression optimizer to take care of some stuff
mguide.add(mr, "/increase/@first", f3);
mguide.add(mr, "/increase/@last", f9);
mguide.add(mg,"/increase/@last/int@",f4);
mguide.add(mg,"/increase/@last/int@",b8);
mguide.serialize(mr);
