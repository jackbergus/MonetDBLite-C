# Query Q1:
# Return the name of the item with ID `item20748' registered in North
# America

# FOR    $b IN doc("auction.xml")/site/people/person[@id="person0"]
# RETURN $b/name/text()

# This simple query is mainly used to establish a simple performance
# primitive unit to help establish a `metric' to interpret subsequent
# queries.  It tests the database ability to handle simple string
# lookups with a fully specified path

# A real compiler would have access to the data guide as an
# ordinary catalog. This means that the mapping of the paths
# to the BATs is known upfront.

# Albrecht's code
#monet_guide := bat("mxml_guide");
#var b1 := bat(find(monet_guide,"site.people.person.id@"));
#var b2 := select(b1,"person0");
#var b3 := reverse(b2);
#var b4 := join (b3, bat(find(monet_guide,"site.people.person.name")));
#var b5 := join (b4, bat(find(monet_guide,"site.people.person.name.cdata")));
#var b6 := join (b5, bat(find(monet_guide,"site.people.person.name.cdata.string@")));
#b6@batloop() {
#printf("%s\n",$t);
#}

# Why the extra redirection in elm/cdata/string@ ?
# This is necessary if there are more children in elm
# or elm contains multiple independent text children.

#$b IN doc("auction.xml")
mg := mguide.open("auction.xml");

# Recursive parse brings you directly to the id string
b1:bat[:oid,:str] := mguide.bind(mg,"/site/people/person/id/cdata/text()");
# b1 represents the edge cdata/text()

# Limit this set to all person0
b2:= algebra.uselect(b2,"person0");

# Backtracking in the recursion means we have to fix the path
# /site/people/person, because it is the last context decision
# This is a guide specific action and can be optimized by not
# using materialized intermediates
b4:bat[:oid,:oid] := mguide.ancestor(mg, b2,
		"/site/people/person/id/cdata/text()", "/site/people/person");

# b4 represents the edge person/id
# it can be reached by a double join.
# the context binding for $b now is just
b := bat.mirror(b4);

#RETURN $b/name/text()
mr:= mguide.new("result");

# propagate the context restriction to the child
x2:bat[:oid,:str] := mguide.descendant(mg,b, 
		"/site/people/person", "/site/people/person/name/cdata/text()");
# all valid strings are collected

# construct a new guide structure
# we have to introduce a new document id
# it is assumed handled by inspection of the path
mguide.add(mr, "/",x2);
xr := bat.reverse(x2);
xm := bat.mirror(xr);
mguide.add(mr, "/cdata",xm);
mguide.add(mr, "/cdata/text()",x2);

mguide.serialize(mr);
