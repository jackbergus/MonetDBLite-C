@/
Copyright Notice:
-----------------

The contents of this file are subject to the PfTijah Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the PfTijah system.

The Initial Developer of the Original Code is the "University of Twente".
Portions created by the "University of Twente" are
Copyright (C) 2006-2007 "University of Twente".
All Rights Reserved.
@

@f pftijah_stem
@a Jan Flokstra
@a Henning Rode
@t pftijah_stem

@h

typedef struct tijahStemmingStruct {
	const char* name;
	int (*init)(void* ctx, char* s);
	const char* (*stem)(void* ctx, const char* s);
	int (*clear)(void* ctx);
	void* udf;
	char* stopWords[];
} tjStemCtx;

extern tjStemCtx* getStemmingContext(char* name);

@c
#include <monetdb_config.h>

#include <gdk.h>

/*******************************************
 * pftijah_stem.c : stemming support for pftijah
 *		    the current implementation is non-reentrant and single
 *		    user but will suffice for the moment.
 *
 */

#include <gdk.h>

#include "pftijah_stem.h"

#include "snb_api.h"

#define ENGLISH_STOPWORDS { \
"a",\
"about",\
"above",\
"across",\
"after",\
"again",\
"against",\
"all",\
"almost",\
"alone",\
"along",\
"already",\
"also",\
"although",\
"always",\
"among",\
"an",\
"and",\
"another",\
"any",\
"anybody",\
"anyone",\
"anything",\
"anywhere",\
"are",\
"area",\
"areas",\
"around",\
"as",\
"ask",\
"asked",\
"asking",\
"asks",\
"at",\
"away",\
"b",\
"back",\
"backed",\
"backing",\
"backs",\
"be",\
"became",\
"because",\
"become",\
"becomes",\
"been",\
"before",\
"began",\
"behind",\
"being",\
"beings",\
"best",\
"better",\
"between",\
"big",\
"both",\
"but",\
"by",\
"c",\
"came",\
"can",\
"cannot",\
"case",\
"cases",\
"certain",\
"certainly",\
"clear",\
"clearly",\
"come",\
"could",\
"d",\
"did",\
"differ",\
"different",\
"differently",\
"do",\
"does",\
"done",\
"down",\
"downed",\
"downing",\
"downs",\
"during",\
"e",\
"each",\
"early",\
"either",\
"end",\
"ended",\
"ending",\
"ends",\
"enough",\
"even",\
"evenly",\
"ever",\
"every",\
"everybody",\
"everyone",\
"everything",\
"everywhere",\
"f",\
"face",\
"faces",\
"fact",\
"facts",\
"far",\
"felt",\
"few",\
"find",\
"finds",\
"first",\
"for",\
"four",\
"from",\
"full",\
"fully",\
"further",\
"furthered",\
"furthering",\
"furthers",\
"g",\
"gave",\
"general",\
"generally",\
"get",\
"gets",\
"give",\
"given",\
"gives",\
"go",\
"going",\
"good",\
"goods",\
"got",\
"great",\
"greater",\
"greatest",\
"group",\
"grouped",\
"grouping",\
"groups",\
"h",\
"had",\
"has",\
"have",\
"having",\
"he",\
"her",\
"here",\
"herself",\
"high",\
"higher",\
"highest",\
"him",\
"himself",\
"his",\
"how",\
"however",\
"i",\
"if",\
"important",\
"in",\
"interest",\
"interested",\
"interesting",\
"interests",\
"into",\
"is",\
"it",\
"its",\
"itself",\
"j",\
"just",\
"k",\
"keep",\
"keeps",\
"kind",\
"knew",\
"know",\
"known",\
"knows",\
"l",\
"large",\
"largely",\
"last",\
"later",\
"latest",\
"least",\
"less",\
"let",\
"lets",\
"like",\
"likely",\
"long",\
"longer",\
"longest",\
"m",\
"made",\
"make",\
"making",\
"man",\
"many",\
"may",\
"me",\
"member",\
"members",\
"men",\
"might",\
"more",\
"most",\
"mostly",\
"mr",\
"mrs",\
"much",\
"must",\
"my",\
"myself",\
"n",\
"necessary",\
"need",\
"needed",\
"needing",\
"needs",\
"never",\
"new",\
"newer",\
"newest",\
"next",\
"no",\
"nobody",\
"non",\
"noone",\
"not",\
"nothing",\
"now",\
"nowhere",\
"number",\
"numbers",\
"o",\
"of",\
"off",\
"often",\
"old",\
"older",\
"oldest",\
"on",\
"once",\
"one",\
"only",\
"open",\
"opened",\
"opening",\
"opens",\
"or",\
"order",\
"ordered",\
"ordering",\
"orders",\
"other",\
"others",\
"our",\
"out",\
"over",\
"p",\
"part",\
"parted",\
"parting",\
"parts",\
"per",\
"perhaps",\
"place",\
"places",\
"point",\
"pointed",\
"pointing",\
"points",\
"possible",\
"present",\
"presented",\
"presenting",\
"presents",\
"problem",\
"problems",\
"put",\
"puts",\
"q",\
"quite",\
"r",\
"rather",\
"really",\
"right",\
"room",\
"rooms",\
"s",\
"said",\
"same",\
"saw",\
"say",\
"says",\
"second",\
"seconds",\
"see",\
"seem",\
"seemed",\
"seeming",\
"seems",\
"sees",\
"sveral",\
"shall",\
"she",\
"should",\
"show",\
"showed",\
"showing",\
"shows",\
"side",\
"sides",\
"since",\
"small",\
"smaller",\
"smallest",\
"so",\
"some",\
"somebody",\
"someone",\
"something",\
"somewhere",\
"state",\
"states",\
"still",\
"such",\
"sure",\
"t",\
"take",\
"taken",\
"than",\
"that",\
"the",\
"their",\
"them",\
"then",\
"there",\
"therefore",\
"these",\
"they",\
"thing",\
"things",\
"think",\
"thinks",\
"this",\
"those",\
"though",\
"thought",\
"thoughts",\
"three",\
"through",\
"thus",\
"to",\
"today",\
"together",\
"too",\
"took",\
"toward",\
"turn",\
"turned",\
"turning",\
"turns",\
"two",\
"u",\
"under",\
"until",\
"up",\
"upon",\
"us",\
"use",\
"used",\
"uses",\
"v",\
"very",\
"w",\
"want",\
"wanted",\
"wanting",\
"wants",\
"was",\
"way",\
"ways",\
"we",\
"well",\
"wells",\
"went",\
"were",\
"what",\
"when",\
"where",\
"whether",\
"which",\
"while",\
"who",\
"whole",\
"whose",\
"why",\
"will",\
"with",\
"within",\
"without",\
"work",\
"worked",\
"working",\
"works",\
"would",\
"x",\
"y",\
"year",\
"years",\
"yet",\
"you",\
"young",\
"younger",\
"youngest",\
"your",\
"yours",\
"z",\
NULL }

#define NULL_STOPWORDS { \
	NULL }

const char* debugStem(void* ctx, const char* s) {
	tjStemCtx* sctx = (tjStemCtx*)ctx;

	mnstr_printf(GDKout,"stemmer(%s): stem(\"%s\")\n",sctx->name,s);
	return s;
}

/* #define STEMMING_DEBUG */

/*
 * First define the nostemming and debug stemming structures
 */

static tjStemCtx nostemming = { "nostemming", NULL, NULL, NULL, NULL, NULL_STOPWORDS };

static tjStemCtx debug      = { "debug",      NULL, debugStem, NULL, NULL, NULL_STOPWORDS };


/*
 * no stemming with english stopwords
 */

static tjStemCtx stopwords_english = { "stopwords-english", NULL, NULL, NULL, NULL, ENGLISH_STOPWORDS };

/*
 *
 * Definition of the pftijah interface to the "porter" Snowball stemmer
 *
 */

#include "stem_UTF_8_porter.h"

static int snb_porter_init(void* ctx, char* s) {
	(void)s;
	struct SN_env *env =  porter_UTF_8_create_env();
	((tjStemCtx*)ctx)->udf = env;
	return 1;
}

static const char* snb_porter_stem(void* ctx, const char* s) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

	SN_set_current(env,strlen(s),(unsigned char*)s);
	if ( !porter_UTF_8_stem(env) ) {
		fprintf(stderr,"english_stem(\"%s\") FAILS \n",s);
		return NULL;
	}
	env->p[env->l] = 0;
#ifdef STEMMING_DEBUG
	mnstr_printf(GDKout,"+ stem-snowball-porter(%s)=\"%s\"\n",s,env->p);
#endif
	return (const char*)env->p;
}

static int snb_porter_clear(void* ctx) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

 	porter_UTF_8_close_env(env);
	((tjStemCtx*)ctx)->udf = NULL;
	return 1;
}

static tjStemCtx snb_porter = { "snowball-porter", snb_porter_init, snb_porter_stem, snb_porter_clear, NULL , ENGLISH_STOPWORDS };

/*
 *
 * Definition of the pftijah interface to the "english" Snowball stemmer
 *
 */

#include "stem_UTF_8_english.h"

static int snb_english_init(void* ctx, char* s) {
	(void)s;
	struct SN_env *env =  english_UTF_8_create_env();
	((tjStemCtx*)ctx)->udf = env;
	return 1;
}

static const char* snb_english_stem(void* ctx, const char* s) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

	SN_set_current(env,strlen(s),(unsigned char*)s);
	if ( !english_UTF_8_stem(env) ) {
		fprintf(stderr,"english_stem(\"%s\") FAILS \n",s);
		return NULL;
	}
	env->p[env->l] = 0;
#ifdef STEMMING_DEBUG
	mnstr_printf(GDKout,"+ stem-snowball-english(%s)=\"%s\"\n",s,env->p);
#endif
	return (const char*)env->p;
}

static int snb_english_clear(void* ctx) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

 	english_UTF_8_close_env(env);
	((tjStemCtx*)ctx)->udf = NULL;
	return 1;
}

static tjStemCtx snb_english = { "snowball-english", snb_english_init, snb_english_stem, snb_english_clear, NULL , ENGLISH_STOPWORDS };

/*
 *
 * Definition of the pftijah interface to the "dutch" Snowball stemmer
 *
 */

#include "stem_UTF_8_dutch.h"

static int snb_dutch_init(void* ctx, char* s) {
	(void)s;
	struct SN_env *env =  dutch_UTF_8_create_env();
	((tjStemCtx*)ctx)->udf = env;
	return 1;
}

static const char* snb_dutch_stem(void* ctx, const char* s) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

	SN_set_current(env,strlen(s),(unsigned char*)s);
	if ( !dutch_UTF_8_stem(env) ) {
		fprintf(stderr,"dutch_stem(\"%s\") FAILS \n",s);
		return NULL;
	}
	env->p[env->l] = 0;
#ifdef STEMMING_DEBUG
	mnstr_printf(GDKout,"+ stem-snowball-dutch(%s)=\"%s\"\n",s,env->p);
#endif
	return (const char*)env->p;
}

static int snb_dutch_clear(void* ctx) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

 	dutch_UTF_8_close_env(env);
	((tjStemCtx*)ctx)->udf = NULL;
	return 1;
}

static tjStemCtx snb_dutch = { "snowball-dutch", snb_dutch_init, snb_dutch_stem, snb_dutch_clear, NULL , NULL_STOPWORDS };

#include "stem_UTF_8_french.h"

static int snb_french_init(void* ctx, char* s) {
	(void)s;
	struct SN_env *env =  french_UTF_8_create_env();
	((tjStemCtx*)ctx)->udf = env;
	return 1;
}

static const char* snb_french_stem(void* ctx, const char* s) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

	SN_set_current(env,strlen(s),(unsigned char*)s);
	if ( !french_UTF_8_stem(env) ) {
		fprintf(stderr,"french_stem(\"%s\") FAILS \n",s);
		return NULL;
	}
	env->p[env->l] = 0;
#ifdef STEMMING_DEBUG
	mnstr_printf(GDKout,"+ stem-snowball-french(%s)=\"%s\"\n",s,env->p);
#endif
	return (const char*)env->p;
}

static int snb_french_clear(void* ctx) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

 	french_UTF_8_close_env(env);
	((tjStemCtx*)ctx)->udf = NULL;
	return 1;
}

static tjStemCtx snb_french = { "snowball-french", snb_french_init, snb_french_stem, snb_french_clear, NULL , NULL_STOPWORDS };

#include "stem_UTF_8_german.h"

static int snb_german_init(void* ctx, char* s) {
	(void)s;
	struct SN_env *env =  german_UTF_8_create_env();
	((tjStemCtx*)ctx)->udf = env;
	return 1;
}

static const char* snb_german_stem(void* ctx, const char* s) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

	SN_set_current(env,strlen(s),(unsigned char*)s);
	if ( !german_UTF_8_stem(env) ) {
		fprintf(stderr,"german_stem(\"%s\") FAILS \n",s);
		return NULL;
	}
	env->p[env->l] = 0;
#ifdef STEMMING_DEBUG
	mnstr_printf(GDKout,"+ stem-snowball-german(%s)=\"%s\"\n",s,env->p);
#endif
	return (const char*)env->p;
}

static int snb_german_clear(void* ctx) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

 	german_UTF_8_close_env(env);
	((tjStemCtx*)ctx)->udf = NULL;
	return 1;
}

static tjStemCtx snb_german = { "snowball-german", snb_german_init, snb_german_stem, snb_german_clear, NULL , NULL_STOPWORDS };

/*
 *
 * a fast porter stemmer experiment
 *
 */

#include "porter_eng.h"

static int porter_english_init(void* ctx, char* s) {
	(void)ctx;
	(void)s;
	return 1;
}

static const char* porter_english_stem(void* ctx, const char* s) {
	(void)ctx;
#ifdef STEMMING_DEBUG
	mnstr_printf(GDKout,"+ stem-porter_english(%s)=",s);
#endif
	if ( Stem( (char *) s ) ) {
#ifdef STEMMING_DEBUG
	    mnstr_printf(GDKout,"\"%s\"\n",s);
#endif
	    return s;
	} else {
#ifdef STEMMING_DEBUG
	    mnstr_printf(GDKout,"\<FAIL>\"%s\"\n",s);
#endif
	    return s;
        }
}

static int porter_english_clear(void* ctx) {
	(void)ctx;
	return 1;
}

static tjStemCtx porter_english = { "porter-english", porter_english_init, porter_english_stem, porter_english_clear, NULL , ENGLISH_STOPWORDS };

#include "porter_dutch.h"

static int porter_dutch_init(void* ctx, char* s) {
	(void)ctx;
	(void)s;
	return 1;
}

static const char* porter_dutch_stem(void* ctx, const char* s) {
	(void)ctx;
#ifdef STEMMING_DEBUG
	mnstr_printf(GDKout,"+ stem-porter_dutch(%s)=",s);
#endif
	dStem( (char *) s );
#ifdef STEMMING_DEBUG
	mnstr_printf(GDKout,"\"%s\"\n",s);
#endif
	return s;
}

static int porter_dutch_clear(void* ctx) {
	(void)ctx;
	return 1;
}

static tjStemCtx porter_dutch = { "porter-dutch", porter_dutch_init, porter_dutch_stem, porter_dutch_clear, NULL , NULL_STOPWORDS };


/*
 *
 * end of fast porter stemmer experiment
 *
 */


/*
 * The getStemmingContext() function is the extern function called to get
 * the stemming context.
 */

tjStemCtx* getStemmingContext(char* name) {
	tjStemCtx* res;

	if (name == NULL)
	    res = & nostemming;
	else if ( strcmp(name,"nostemming")==0 )
	    res = & nostemming;
	else if ( strcmp(name,"default")==0 )
	    res = & nostemming;
	else if ( strcmp(name,"debug")==0 )
	    res = & debug;
	else if ( strcmp(name,"stopwords-english")==0 )
	    res = & stopwords_english;
	else if ( strcmp(name,"snowball-porter")==0 )
	    res = & snb_porter;
	else if ( strcmp(name,"snowball-english")==0 )
	    res = & snb_english;
	else if ( strcmp(name,"snowball-dutch")==0 )
	    res = & snb_dutch;
	else if ( strcmp(name,"snowball-french")==0 )
	    res = & snb_french;
	else if ( strcmp(name,"snowball-german")==0 )
	    res = & snb_german;
	else if ( strcmp(name,"porter-english")==0 )
	    res = & porter_english;
	else if ( strcmp(name,"porter-dutch")==0 )
	    res = & porter_dutch;
	else {
	    mnstr_printf(GDKerr,"# WARNING: stemmer \"%s\" unknown, using nostemming\n",name);
	    res = & nostemming;
	}
	return res;
}

/* vim:set shiftwidth=4 expandtab: */
