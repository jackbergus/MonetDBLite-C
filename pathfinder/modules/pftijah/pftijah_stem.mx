@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'

@f pftijah_stem
@a Jan Flokstra
@a Henning Rode
@t pftijah_stem

@h

typedef struct tijahStemmingStruct {
	const char* name;
	int (*init)(void* ctx, char* s);
	unsigned char* (*stem)(void* ctx, unsigned char* s);
	int (*clear)(void* ctx);
	void* udf;
} tjStemCtx;

extern tjStemCtx* getStemmingContext(char* name);

@c

/*******************************************
 * pftijah_stem.c : stemming support for pftijah
 *		    the current implementation is non-reentrant and single
 *		    user but will suffice for the moment.
 *
 */

#include <gdk.h>

#include "pftijah_stem.h"

#include "snb_api.h"


unsigned char* debugStem(void* ctx, unsigned char* s) {
	tjStemCtx* sctx = (tjStemCtx*)ctx;

	stream_printf(GDKout,"stemmer(%s): stem(\"%s\")\n",sctx->name,s);
	return s;
}

/* #define STEMMING_DEBUG */

/*
 * First define the nostemming and debug stemming structures
 */

static tjStemCtx nostemming = { "nostemming", NULL, NULL, NULL, NULL };

static tjStemCtx debug      = { "debug",      NULL, debugStem, NULL, NULL };

/*
 *
 * Definition of the pftijah interface to the "porter" Snowball stemmer
 *
 */

#include "stem_UTF_8_porter.h"

static int snb_porter_init(void* ctx, char* s) {
	(void)s;
	struct SN_env *env =  porter_UTF_8_create_env();
	((tjStemCtx*)ctx)->udf = env;
	return 1;
}

static unsigned char* snb_porter_stem(void* ctx, unsigned char* s) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

	SN_set_current(env,strlen((char*)s),s);
	if ( !porter_UTF_8_stem(env) ) {
		fprintf(stderr,"english_stem(\"%s\") FAILS \n",s);
		return NULL;
	}
	env->p[env->l] = 0;
#ifdef STEMMING_DEBUG
	stream_printf(GDKout,"+ stem-snowball-porter(%s)=\"%s\"\n",s,env->p);
#endif
	return env->p;
}

static int snb_porter_clear(void* ctx) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

 	porter_UTF_8_close_env(env);
	((tjStemCtx*)ctx)->udf = NULL;
	return 1;
}

static tjStemCtx snb_porter = { "snowball-porter", snb_porter_init, snb_porter_stem, snb_porter_clear, NULL };

/*
 *
 * Definition of the pftijah interface to the "english" Snowball stemmer
 *
 */

#include "stem_UTF_8_english.h"

static int snb_english_init(void* ctx, char* s) {
	(void)s;
	struct SN_env *env =  english_UTF_8_create_env();
	((tjStemCtx*)ctx)->udf = env;
	return 1;
}

static unsigned char* snb_english_stem(void* ctx, unsigned char* s) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

	SN_set_current(env,strlen((char*)s),s);
	if ( !english_UTF_8_stem(env) ) {
		fprintf(stderr,"english_stem(\"%s\") FAILS \n",s);
		return NULL;
	}
	env->p[env->l] = 0;
#ifdef STEMMING_DEBUG
	stream_printf(GDKout,"+ stem-snowball-english(%s)=\"%s\"\n",s,env->p);
#endif
	return env->p;
}

static int snb_english_clear(void* ctx) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

 	english_UTF_8_close_env(env);
	((tjStemCtx*)ctx)->udf = NULL;
	return 1;
}

static tjStemCtx snb_english = { "snowball-english", snb_english_init, snb_english_stem, snb_english_clear, NULL };

/*
 *
 * Definition of the pftijah interface to the "dutch" Snowball stemmer
 *
 */

#include "stem_UTF_8_dutch.h"

static int snb_dutch_init(void* ctx, char* s) {
	(void)s;
	struct SN_env *env =  dutch_UTF_8_create_env();
	((tjStemCtx*)ctx)->udf = env;
	return 1;
}

static unsigned char* snb_dutch_stem(void* ctx, unsigned char* s) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

	SN_set_current(env,strlen((char*)s),s);
	if ( !dutch_UTF_8_stem(env) ) {
		fprintf(stderr,"dutch_stem(\"%s\") FAILS \n",s);
		return NULL;
	}
	env->p[env->l] = 0;
#ifdef STEMMING_DEBUG
	stream_printf(GDKout,"+ stem-snowball-dutch(%s)=\"%s\"\n",s,env->p);
#endif
	return env->p;
}

static int snb_dutch_clear(void* ctx) {
	struct SN_env *env = (struct SN_env *)((tjStemCtx*)ctx)->udf;

 	dutch_UTF_8_close_env(env);
	((tjStemCtx*)ctx)->udf = NULL;
	return 1;
}

static tjStemCtx snb_dutch = { "snowball-dutch", snb_dutch_init, snb_dutch_stem, snb_dutch_clear, NULL };

/*
 * The getStemmingContext() function is the extern function called to get
 * the stemming context.
 */

tjStemCtx* getStemmingContext(char* name) {
	(void) name;
	tjStemCtx* res;

	if ( strcmp(name,"nostemming")==0 )
	    res = & nostemming;
	else if ( strcmp(name,"default")==0 )
	    res = & nostemming;
	else if ( strcmp(name,"debug")==0 )
	    res = & debug;
	else if ( strcmp(name,"snowball-porter")==0 )
	    res = & snb_porter;
	else if ( strcmp(name,"snowball-english")==0 )
	    res = & snb_english;
	else if ( strcmp(name,"snowball-dutch")==0 )
	    res = & snb_dutch;
	else {
	    stream_printf(GDKerr,"# WARNING: stemmer \"%s\" unknown, using nostemming\n",name);
	    res = & nostemming;
	}
	return res;
};

/* vim:set shiftwidth=4 expandtab: */
