@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2006 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'

@f termdb
@a Jan Flokstra
@a Henning Rode
@t termdb

@h

/* #define USE_TERMDB */ /* used by serialize_pftijah */

#define TDB_DEBUG if ( 0 ) stream_printf
#define TDB_OUT   GDKout

#define TERMDBCONF	"tj_termDBconf"
#define TERMDBTAGS	"tj_termDBtags0"
#define TERMDBFRAGMENTS	"tj_termDBfragments"
#define TERMDBBAT	"tj_termDBbat%d"

#define TDB_LOC_NFRAG       0
#define TDB_LOC_MAXFRAGSIZE 1
#define TDB_LOC_CURFRAG     2
#define TDB_LOC_CUROID      3
#define CONFFRAG_LOC(I)     (I+4)

typedef struct termDbCtx {
	BAT*	frags;
	BAT*	conf;
	oid	nFrag;
	oid	maxFragSize;
	oid	curFrag;
	oid	curOid;
	oid	startOid;
	//
	oid     curTagOid;
	BAT*	tags;
	//
	unsigned int nBuckets;
	//
	int*	buckets;
	BAT**	hashbats;
} termDbCtx;

extern int termdb_prelude();

extern termDbCtx* tdb_open();
extern oid	  tdb_lookupTerm(termDbCtx* tdb, char* term);
// INCOMPLETE
extern int	  tdb_insertTerm(termDbCtx* tdb, char* term, oid o, int check);
extern oid	  tdb_lookupTag(termDbCtx* tdb, char* term);
extern int        tdb_close(termDbCtx* tdb);

@c
#include <pf_config.h>

/*******************************************
 * termdb.c : the parallel term database
 *
 */

#include <gdk.h>

#include "termdb.h"

BAT* tdb_createBAT(char* name, int ht, int tt, int persists) {
    BAT* b = BATnew(ht,tt,0);
    if ( (!b) || (BBPrename(BBPcacheid(b),name)!=0) ) {
      stream_printf(GDKout,"#termdb:createBAT(\"name\"): bat creation failed.\n",name);
      return NULL;
    }
    if ( persists ) {
      b->batPersistence = PERSISTENT;
    }
    TDB_DEBUG(TDB_OUT,"#termdb: createBAT(\"%s\",%d,%d,%d) succes.\n",name,ht,tt,persists);
    return b;
}

BAT *tdb_lookupBAT(str name) {
    bat b = BBPindex(name);
    
    if ( b == bat_nil ) {
    	return NULL;
    } else {
    	return BBPdescriptor(b);
    }
}

static char* hashbatName(char* format, int i) {
    static char buff[32];

    sprintf(buff,format,i);
    return buff;
}


oid tdb_findOid(BAT* void_oid_bat, oid idx) {
	BUN bun;

	BUNfndVOID(bun,void_oid_bat,&idx);
	if ( bun ) {
	    return *(oid*)BUNtail(void_oid_bat,bun);
	} else {
	    return oid_nil;
	}
}

int tdb_replaceOid(BAT* void_oid_bat, oid idx, oid v) {
	if ( !BUNreplace(void_oid_bat,&idx,&v,0) ) {
            stream_printf(GDKout,"#tdb_replaceOid: BUNreplace failed.\n");
	    return 0;
	} else
	    return 1;
}

BAT* tdb_findBat(BAT* void_bat_bat, oid idx) {
	BUN bun;

	BUNfndVOID(bun,void_bat_bat,&idx);
	if ( bun ) {
	    bat resbat = *(bat*)BUNtail(void_bat_bat,bun);
    	    return BBPdescriptor(resbat);
	} else {
	    return NULL;
	}
}

int termdb_prelude() {
    TDB_DEBUG(TDB_OUT,"#termdb:prelude: start.\n");

    BAT* conf = tdb_lookupBAT(TERMDBCONF);

    if ( conf ) {
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: found conf bat: \"%s\".\n",TERMDBCONF);
        if ( tdb_lookupBAT(TERMDBFRAGMENTS) ) {
            stream_printf(GDKout,"#termdb_prelude: bat \"%s\"already exists.\n",TERMDBFRAGMENTS);
            return GDK_FAIL;
        }
        BAT* rt = tdb_createBAT(TERMDBFRAGMENTS,TYPE_void,TYPE_bat,0);
	if ( !rt )
	    return GDK_FAIL;
        BBPfix(BBPcacheid(rt));
        BATseqbase(rt,(oid)0);

	oid curFrag = tdb_findOid(conf,TDB_LOC_CURFRAG); 
	if ( curFrag == oid_nil ) {
            stream_printf(GDKout,"#termdb_prelude: read nil curFrag.\n");
	    return GDK_FAIL;
	}
	for(int i=0; i<(int)curFrag; i++) {
	    BAT* fb = tdb_lookupBAT(hashbatName(TERMDBBAT,i));

            if ( !fb || !BUNappend(rt, &BBPcacheid(fb), 0) ) {
                stream_printf(GDKout,"#termdb_prelude: fail to add fragbat[%i] to rt bat.\n");
	        return GDK_FAIL;
	    }
	}
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: created runtime bat: \"%s\".\n",TERMDBFRAGMENTS);
	if ( 0 ) BATprintf(GDKout,rt);
    } else {
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: no conf bat: \"%s\".\n",TERMDBCONF);
    }
    return GDK_SUCCEED;
}


int CMDtj_create_termdb(int* p_nFrag, oid* p_maxFragSize) {
    oid nFrag       = *p_nFrag;
    oid maxFragSize = *p_maxFragSize;
    int dynamic     = (maxFragSize != oid_nil);
    oid curFrag     = (dynamic ? (oid)1 :nFrag);
    oid curOid      = (oid)1;

    TDB_DEBUG(TDB_OUT,"#termdb: CMDtj_create_termdb(" OIDFMT "," OIDFMT ").\n",nFrag, maxFragSize);

    BAT* conf;
    
    if ( tdb_lookupBAT(TERMDBCONF) ) {
        stream_printf(GDKout,"#CMDtj_create_termdb: bat \"%s\"already exists.\n",TERMDBCONF);
        return GDK_FAIL;
    }
    if (!(conf = tdb_createBAT(TERMDBCONF,TYPE_void,TYPE_oid,1/*persistent*/)))
        return GDK_FAIL;
    BATseqbase(conf,(oid)0);
    if ( !BUNappend(conf, &nFrag, 0) ||
         !BUNappend(conf, &maxFragSize, 0) ||
         !BUNappend(conf, &curFrag, 0) ||
         !BUNappend(conf, &curOid, 0) 
    ) {
        stream_printf(GDKout,"#ERROR: CMDtj_create_termdb: error writing conf HEADER.\n");
        return GDK_FAIL;
    }

    BAT* tags;
    if ( ! (tags=tdb_createBAT(TERMDBTAGS,TYPE_oid,TYPE_str,1/*persistent*/)) )
                return GDK_FAIL;

    oid lastbat = 0;
    for(int i=0; i< (int)nFrag; i++) {
        if (  (i==0) || !dynamic ) {
	    lastbat = (oid)i;
            if ( ! tdb_createBAT(hashbatName(TERMDBBAT,i),TYPE_oid,TYPE_str,1/*persistent*/))
                return GDK_FAIL;
	}
    	if ( !BUNappend(conf, &lastbat, 0) ) {
            stream_printf(GDKout,"#ERROR: CMDtj_create_termdb: error writing hash HEADER.\n");
	    return GDK_FAIL;
	}
    }
    if ( 0 ) BATprintf(GDKout,conf);
    // unfix conf???
    return termdb_prelude();
}

/*
 *
 */
int tdb_checkHashTable(BAT* b) {
    if ( b->thash == NULL ) {
         if ( !BAThash(BATmirror(b),0) ) {
                 stream_printf(GDKout,"#Itermdb:tdb_checkHashTable: fail to creat hashtable on [oid,str] bat.\n");
             return 0;
         } else {
            TDB_DEBUG(TDB_OUT,"#termdb:tdb_checkHashTable(): created hashtable on [oid,str] bat.\n");
	}
    }
    return 1;
}

/*
 *
 *
 */

termDbCtx* tdb_open() {
    TDB_DEBUG(TDB_OUT,"#termdb: start tdb_open().\n");

    BAT* tdb_frags = tdb_lookupBAT(TERMDBFRAGMENTS);
    if ( !tdb_frags ) {
        stream_printf(GDKout,"#ERROR:tdb_open: no termdb runtime bat found.\n");
    	return NULL;
    }
    termDbCtx* tdbctx = GDKmalloc(sizeof(termDbCtx));
    if ( !tdbctx ) {
        stream_printf(GDKout,"#ERROR:tdb_open: out of memory on termDbCtx malloc.\n");
    	return NULL;
    }

    tdbctx->frags	= tdb_frags;
    BBPfix(BBPcacheid(tdbctx->frags));
    tdbctx->conf	= tdb_lookupBAT(TERMDBCONF);
    if ( tdbctx->conf == NULL ) {
        stream_printf(GDKout,"#ERROR:tdb_open: unable to load conf bat.\n");
    	return NULL;
    }
    BBPfix(BBPcacheid(tdbctx->conf));
    //
    tdbctx->tags        = tdb_lookupBAT(TERMDBTAGS);
    if ( tdbctx->tags == NULL ) {
        stream_printf(GDKout,"#ERROR:tdb_open: unable to load tags bat.\n");
    	return NULL;
    }
    BBPfix(BBPcacheid(tdbctx->tags));
    if ( !tdb_checkHashTable(tdbctx->tags) )
        return NULL;
    tdbctx->curTagOid   = (oid)BATcount(tdbctx->tags);
    //
    tdbctx->nFrag       = tdb_findOid(tdbctx->conf,TDB_LOC_NFRAG);
    tdbctx->nBuckets    = (unsigned int)tdbctx->nFrag;
    tdbctx->curOid      = tdb_findOid(tdbctx->conf,TDB_LOC_CUROID);
    tdbctx->startOid    = tdbctx->curOid;
    tdbctx->curFrag     = tdb_findOid(tdbctx->conf,TDB_LOC_CURFRAG);
    tdbctx->maxFragSize = tdb_findOid(tdbctx->conf,TDB_LOC_MAXFRAGSIZE);

    TDB_DEBUG(TDB_OUT,"#termdb: loaded conf parameters:\n");
    TDB_DEBUG(TDB_OUT,"#termdb: nFrag       = " OIDFMT "\n",tdbctx->nFrag);
    TDB_DEBUG(TDB_OUT,"#termdb: maxFragSize = " OIDFMT "\n",tdbctx->maxFragSize);
    TDB_DEBUG(TDB_OUT,"#termdb: curOid      = " OIDFMT "\n",tdbctx->curOid);
    TDB_DEBUG(TDB_OUT,"#termdb: curFrag     = " OIDFMT "\n",tdbctx->curFrag);

    tdbctx->buckets = GDKmalloc((int)tdbctx->nFrag  * sizeof(int));
    tdbctx->hashbats= GDKmalloc((int)tdbctx->curFrag* sizeof(int));
    if ( !tdbctx->buckets || !tdbctx->hashbats ) {
        stream_printf(GDKout,"#ERROR:tdb_open: out of memory on bucket/bats malloc.\n");
    	return NULL;
    }
    int i;

    for(i=0; i<(int)tdbctx->nFrag; i++) {
        tdbctx->buckets[i] = (int)tdb_findOid(tdbctx->conf,CONFFRAG_LOC(i));
    }
    for(i=0; i<(int)tdbctx->curFrag; i++) {
        tdbctx->hashbats[i] = NULL; // demand loading
    }
    TDB_DEBUG(TDB_OUT,"#termdb: finish tdb_open().\n");
    return tdbctx;
}

int tdb_close(termDbCtx* tdbctx) {
    TDB_DEBUG(TDB_OUT,"#termdb: execute tdb_close().\n");
    if ( tdbctx->startOid != tdbctx->curOid ) {
        if ( !tdb_replaceOid(tdbctx->conf,TDB_LOC_CUROID,tdbctx->curOid) )
	    return 0;
    }
    GDKfree(tdbctx->buckets);
    for(int i=0; i<(int)tdbctx->curFrag; i++) {
        if ( tdbctx->hashbats[i] ) {
	    BBPunfix(BBPcacheid(tdbctx->hashbats[i]));
	}
    }
    GDKfree(tdbctx->hashbats);
    BBPunfix(BBPcacheid(tdbctx->conf));
    BBPunfix(BBPcacheid(tdbctx->tags));
    BBPunfix(BBPcacheid(tdbctx->frags));
    GDKfree(tdbctx);
    return 1;
}

unsigned int hashTerm(char* t) {
	return (unsigned int)*t;
}

BAT* get_fragBAT(termDbCtx* tdbctx, int idx) {
    BAT* res = tdbctx->hashbats[idx];

    if ( !res ) {
    	res = tdb_findBat(tdbctx->frags,idx);
	if ( ! res ) {
            stream_printf(GDKout,"#Itermdb:get_fragBAT: unable to load fragment[%d].\n",idx);
	    return NULL;
	}
	if ( !tdb_checkHashTable(res) )
	    return NULL;
	BBPfix(BBPcacheid(res));
	tdbctx->hashbats[idx] = res;
        TDB_DEBUG(TDB_OUT,"#termdb:get_fragBAT(): loaded fragment[%d].\n",idx);
	return res;
    } else {
        return res;
    }
}

#define SHOWLOOKUP 0

oid tdb_lookupTerm(termDbCtx* tdb, char* term) {
    int frag = tdb->buckets[hashTerm(term) % tdb->nBuckets];

    BAT* fragTerm = get_fragBAT(tdb, frag);

    if ( ! fragTerm )
    	return oid_nil;
    BUN bun;
    BAT* m_fragTerm = BATmirror(fragTerm);
    if ( (bun = BUNfnd(m_fragTerm,term)) ) {
        if (SHOWLOOKUP) TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookup(\"%s\") = " OIDFMT "\n",term,*(oid*)BUNtail(m_fragTerm,bun));
        return *(oid*)BUNtail(m_fragTerm,bun);
    } else {
    	if ( !BUNins(fragTerm, &tdb->curOid, (str)term, FALSE)){
    	    GDKerror("tdb_lookup: insert \"%s\" in termbat fails.\n");
    	    return oid_nil;
        } else { 
            if (SHOWLOOKUP) TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookup(\"%s\") = " OIDFMT "[new]\n",term,tdb->curOid);
    	    return tdb->curOid++;
        }
    }
}

oid tdb_lookupTag(termDbCtx* tdb, char* tag) {
    BUN bun;
	
    BAT* m_tags = BATmirror(tdb->tags);

    if ( (bun = BUNfnd(m_tags,tag)) ) {
        if (SHOWLOOKUP) TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTag(\"%s\") = " OIDFMT "\n",tag,*(oid*)BUNtail(m_tags,bun));
        return *(oid*)BUNtail(m_tags,bun);
    } else {
    	if ( !BUNins(tdb->tags, &tdb->curTagOid, (str)tag, FALSE)){
    	    GDKerror("tdb_lookupTag: insert \"%s\" in tagbat fails.\n");
    	    return oid_nil;
        } else { 
            if (SHOWLOOKUP) TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTag(\"%s\") = " OIDFMT "[new]\n",tag,tdb->curTagOid);
    	    return tdb->curTagOid++;
        }
    }
}

/* vim:set shiftwidth=4 expandtab: */
