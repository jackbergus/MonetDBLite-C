@/
Copyright Notice:
-----------------

The contents of this file are subject to the PfTijah Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the PfTijah system.

The Initial Developer of the Original Code is the "University of Twente".
Portions created by the "University of Twente" are
Copyright (C) 2006-2007 "University of Twente".
All Rights Reserved.
@

@f termdb
@a Jan Flokstra
@a Henning Rode
@t termdb

@h

/*
 * CHANGES: make all term bats of type [str,oid] because all major operations
 *          use BUNfnd and hashing and these work more easy with the string
 *          in the head
 *
 * BUGS: stopword problem. Multiple stopword collections on one term db is
 *       never goiing to work.
 */

/* #define USE_TERMDB */ /* used by serialize_pftijah */

#define TDB_DEBUG if ( 0 ) stream_printf
#define TDB_OUT   GDKout
/* #define TDB_SHOWLOOKUP */ /* used to debug all term lookups */

#define TERMDBCONF	"tj_termDBconf"
#define TERMDBTAGS	"tj_termDBtags0"
#define TERMDBFRAGMENTS	"tj_termDBfragments"
#define TERMDBBAT	"tj_termDBbat%d"

#define TDB_LOC_NFRAG       0
#define TDB_LOC_MAXFRAGSIZE 1
#define TDB_LOC_CURFRAG     2
#define TDB_LOC_CUROID      3
#define TDB_LOC_TREE(I)     (oid)(I+4)

typedef struct termDbCtx {
	BAT*	frags;
	BAT*	conf;
	oid	nFrag;
	oid	maxFragSize;
	oid	curFrag;
	oid	curOid;
	oid	startOid;
	//
	oid     curTagOid;
	BAT*	tags;
	//
	unsigned int nBuckets;
	//
	int*	buckets;
	BAT**	hashbat;
	BUN*	hashbatSize;
} termDbCtx;

extern int termdb_prelude(void);

extern termDbCtx* tdb_open(char* name);
extern int	  tdb_insertTerm(termDbCtx* tdb, char* term, oid o, int check);
extern oid	  tdb_lookupTerm(termDbCtx* tdb, char* term);
extern oid	  tdb_lookupTag(termDbCtx* tdb, char* term);
extern int        tdb_close(termDbCtx* tdb);
extern int        tdb_isEmpty(termDbCtx* tdb);

@c
#include <pf_config.h>

/*******************************************
 * termdb.c : the parallel term database
 *
 */

#include <gdk.h>

#include "pftijah_util.h"

#include "termdb.h"

static int tdb_destroyCnt = 0;

INLINE static BAT *tdb_prepare2destroy(BAT* bat) {
    char buff[32];

    sprintf(buff,"tdb_destroy%d",tdb_destroyCnt++);
    BBPrename(BBPcacheid(bat),(str)buff);
    bat->batPersistence = TRANSIENT;
    return bat;
}

INLINE static int tdb_destroyBAT(str name) {
    bat b = BBPindex(name);

    if ( b == bat_nil ) {
        stream_printf(GDKout,"#termdb:tdb_destroyBAT(\"%s\"): bat deletion failed.\n",name);
        return 0;
    } else {
        BAT* bat = BBPdescriptor(b);

        bat->batPersistence = TRANSIENT;
	BATdelete(bat);
        /* stream_printf(GDKout,"#termdb:tdb_destroyBAT(\"%s\")\n",name); */
        return 1;
    }
}

INLINE static char* hashbatName(char* format, int i) {
    static char buff[32];

    sprintf(buff,format,i);
    return buff;
}


INLINE static oid tdb_findOid(BAT* void_oid_bat, oid idx) {
        BATiter void_oid_bati = bat_iterator(void_oid_bat);
	BUN bun;

	BUNfndVOID(bun,void_oid_bati,&idx);
	if ( bun != BUN_NONE ) {
	    return *(oid*)BUNtail(void_oid_bati,bun);
	} else {
	    return oid_nil;
	}
}

INLINE static int tdb_replaceOid(BAT* void_oid_bat, oid idx, oid v) {
	if ( !BUNreplace(void_oid_bat,&idx,&v,0) ) {
            stream_printf(GDKout,"#tdb_replaceOid: BUNreplace failed.\n");
	    return 0;
	} else
	    return 1;
}

BAT* tdb_findBat(BAT* void_bat_bat, oid idx) {
        BATiter void_bat_bati = bat_iterator(void_bat_bat);
	BUN bun;

	BUNfndVOID(bun,void_bat_bati,&idx);
	if ( bun != BUN_NONE ) {
	    bat resbat = *(bat*)BUNtail(void_bat_bati,bun);
    	    return BBPdescriptor(resbat);
	} else {
	    return NULL;
	}
}

int termdb_prelude() {
    TDB_DEBUG(TDB_OUT,"#termdb:prelude: start.\n");

    BAT* conf = pftu_lookup_bat(TERMDBCONF);

    if ( conf ) {
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: found conf bat: \"%s\".\n",TERMDBCONF);
        if ( pftu_lookup_bat(TERMDBFRAGMENTS) ) {
            stream_printf(GDKout,"#termdb_prelude: bat \"%s\"already exists.\n",TERMDBFRAGMENTS);
            return GDK_FAIL;
        }
        BAT* rt = pftu_create_bat(TERMDBFRAGMENTS,TYPE_void,TYPE_bat,0);
	if ( !rt )
	    return GDK_FAIL;
        BBPfix(BBPcacheid(rt));
        BATseqbase(rt,(oid)0);

	oid curFrag = tdb_findOid(conf,TDB_LOC_CURFRAG); 
	if ( curFrag == oid_nil ) {
            stream_printf(GDKout,"#termdb_prelude: read nil curFrag.\n");
	    return GDK_FAIL;
	}
	for(int i=0; i<(int)curFrag; i++) {
	    BAT* fb = pftu_lookup_bat(hashbatName(TERMDBBAT,i));

            if ( !fb || !BUNappend(rt, &BBPcacheid(fb), 0) ) {
                stream_printf(GDKout,"#termdb_prelude: fail to add fragbat[%i] to rt bat.\n",i);
	        return GDK_FAIL;
	    }
	}
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: created runtime bat: \"%s\".\n",TERMDBFRAGMENTS);
	if ( 0 ) BATprintf(GDKout,rt);
    } else {
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: no conf bat: \"%s\".\n",TERMDBCONF);
    }
    return GDK_SUCCEED;
}

int CMDtj_create_termdb(int* p_nFrag, oid* p_maxFragSize) {
    oid nFrag       = *p_nFrag;
    oid maxFragSize = *p_maxFragSize;
    int dynamic     = (maxFragSize != oid_nil);
    oid curFrag     = (dynamic ? (oid)1 :nFrag);
    oid curOid      = (oid)0; /* first oid in termdb */

    TDB_DEBUG(TDB_OUT,"#termdb: CMDtj_create_termdb(" OIDFMT "," OIDFMT ").\n",nFrag, maxFragSize);

    BAT* conf;
    
    if ( pftu_lookup_bat(TERMDBCONF) ) {
        stream_printf(GDKout,"#CMDtj_create_termdb: bat \"%s\"already exists.\n",TERMDBCONF);
        return GDK_FAIL;
    }
    if (!(conf = pftu_create_bat(TERMDBCONF,TYPE_void,TYPE_oid,1/*persistent*/)))
        return GDK_FAIL;
    BATseqbase(conf,(oid)0);
    if ( !BUNappend(conf, &nFrag, 0) ||
         !BUNappend(conf, &maxFragSize, 0) ||
         !BUNappend(conf, &curFrag, 0) ||
         !BUNappend(conf, &curOid, 0) 
    ) {
        stream_printf(GDKout,"#ERROR: CMDtj_create_termdb: error writing conf HEADER.\n");
        return GDK_FAIL;
    }

    if ( ! (pftu_create_bat(TERMDBTAGS,TYPE_str,TYPE_oid,1/*persistent*/)) )
                return GDK_FAIL;

    oid lastbat = 0;
    for(int i=0; i< (int)nFrag; i++) {
        if (  (i==0) || !dynamic ) {
	    lastbat = (oid)i;
            if ( ! pftu_create_bat(hashbatName(TERMDBBAT,i),TYPE_str,TYPE_oid,1/*persistent*/))
                return GDK_FAIL;
	}
    	if ( !BUNappend(conf, &lastbat, 0) ) {
            stream_printf(GDKout,"#ERROR: CMDtj_create_termdb: error writing hash tree HEADER.\n");
	    return GDK_FAIL;
	}
    }
    if ( 0 ) BATprintf(GDKout,conf);
    return termdb_prelude();
}

/*
 *
 */
 
extern BAT* get_fragBAT(termDbCtx* tdb, int idx);

static void dumpTDBtree(termDbCtx* tdb) {
    stream_printf(GDKout,"# TDB TREE=[");
    for(int i=0; i<(int)tdb->nFrag; i++) {
        stream_printf(GDKout,"%d[%d] ",i,tdb->buckets[i]);
    }
    stream_printf(GDKout,"]\n");
}

static void dumpTDB(termDbCtx* tdb,char* p) {
int i;

    stream_printf(GDKout,"########################################\n");
    stream_printf(GDKout,"### dump of termDB: %s. #####\n",p);
    stream_printf(GDKout,"########################################\n");
    dumpTDBtree(tdb);
    stream_printf(GDKout,"FRAGMENT BATS: \n",p);
    for(i=0; i<(int)tdb->curFrag; i++) {
        stream_printf(GDKout,"BAT[frag#=%d]: \n",i);
	BATprintf(GDKout,get_fragBAT(tdb,i));
    }
}

int CMDtj_dispose_termdb() {
    TDB_DEBUG(TDB_OUT,"#termdb: start CMDtj_dispose_termdb().\n");
    termDbCtx *tdb = tdb_open("termDB");

    if ( 0 ) {
	dumpTDB(tdb,"DISPOSED termDB");
    }
    if ( !tdb ) {
        stream_printf(GDKout,"#ERROR: CMDtj_dispose_termdb: fail to open termDB.\n");
	return  GDK_FAIL;
    }
    oid curFrag = tdb->curFrag;
    if ( ! tdb_close(tdb) ) {
        stream_printf(GDKout,"#ERROR: CMDtj_dispose_termdb: fail to close termDB.\n");
	return  GDK_FAIL;
    }
    TDB_DEBUG(TDB_OUT,"#termdb: CMDtj_dispose_termdb() throw away conf bats.\n");
    if ( !tdb_destroyBAT(TERMDBCONF) ||
         !tdb_destroyBAT(TERMDBTAGS) ||
         !tdb_destroyBAT(TERMDBFRAGMENTS)
       ) {
    	return GDK_FAIL;
    }
    for(int i=0; i<(int)curFrag; i++) {
	if ( !tdb_destroyBAT(hashbatName(TERMDBBAT,i)) )
	    return GDK_FAIL;
        TDB_DEBUG(TDB_OUT,"#termdb: CMDtj_dispose_termdb() delete frag[%d].\n",i);
    }
    TDB_DEBUG(TDB_OUT,"#termdb: finish CMDtj_dispose_termdb().\n");
    return GDK_SUCCEED;
}

/*
 *
 */

int tdb_checkHashTable(BAT* b) {
    if ( b->H->hash == NULL ) {
         if ( !BAThash(b,0) ) {
                 stream_printf(GDKout,"#termdb:tdb_checkHashTable: fail to creat hashtable on [oid,str] bat.\n");
             return 0;
         } else {
            TDB_DEBUG(TDB_OUT,"#termdb:tdb_checkHashTable(): created hashtable on [oid,str] bat.\n");
	}
    }
    return 1;
}

/*
 *
 *
 */

termDbCtx* tdb_open(char* name) {
    (void)name; // incomplete, termDB's should have a name
    TDB_DEBUG(TDB_OUT,"#termdb: start tdb_open().\n");

    BAT* tdb_frags = pftu_lookup_bat(TERMDBFRAGMENTS);
    if ( !tdb_frags ) {
        stream_printf(GDKout,"#ERROR:tdb_open: no termdb runtime bat found.\n");
    	return NULL;
    }
    termDbCtx* tdb = GDKmalloc(sizeof(termDbCtx));
    if ( !tdb ) {
        stream_printf(GDKout,"#ERROR:tdb_open: out of memory on termDbCtx malloc.\n");
    	return NULL;
    }

    tdb->frags	= tdb_frags;
    BBPfix(BBPcacheid(tdb->frags));
    tdb->conf	= pftu_lookup_bat(TERMDBCONF);
    if ( tdb->conf == NULL ) {
        stream_printf(GDKout,"#ERROR:tdb_open: unable to load conf bat.\n");
    	return NULL;
    }
    BBPfix(BBPcacheid(tdb->conf));
    //
    tdb->tags        = pftu_lookup_bat(TERMDBTAGS);
    if ( tdb->tags == NULL ) {
        stream_printf(GDKout,"#ERROR:tdb_open: unable to load tags bat.\n");
    	return NULL;
    }
    BBPfix(BBPcacheid(tdb->tags));
    if ( !tdb_checkHashTable(tdb->tags) )
        return NULL;
    tdb->curTagOid   = (oid)BATcount(tdb->tags);
    //
    tdb->nFrag       = tdb_findOid(tdb->conf,TDB_LOC_NFRAG);
    tdb->nBuckets    = (unsigned int)tdb->nFrag;
    tdb->curOid      = tdb_findOid(tdb->conf,TDB_LOC_CUROID);
    tdb->startOid    = tdb->curOid;
    tdb->curFrag     = tdb_findOid(tdb->conf,TDB_LOC_CURFRAG);
    tdb->maxFragSize = tdb_findOid(tdb->conf,TDB_LOC_MAXFRAGSIZE);

    TDB_DEBUG(TDB_OUT,"#termdb: loaded conf parameters:\n");
    TDB_DEBUG(TDB_OUT,"#termdb: nFrag       = " OIDFMT "\n",tdb->nFrag);
    TDB_DEBUG(TDB_OUT,"#termdb: maxFragSize = " OIDFMT "\n",tdb->maxFragSize);
    TDB_DEBUG(TDB_OUT,"#termdb: curOid      = " OIDFMT "\n",tdb->curOid);
    TDB_DEBUG(TDB_OUT,"#termdb: curFrag     = " OIDFMT "\n",tdb->curFrag);

    tdb->buckets = GDKmalloc((int)tdb->nFrag  * sizeof(int));
    tdb->hashbat= GDKmalloc((int)tdb->curFrag* sizeof(BAT*));
    if ( !tdb->buckets || !tdb->hashbat ) {
        stream_printf(GDKout,"#ERROR:tdb_open: out of memory on bucket/bats malloc.\n");
    	return NULL;
    }
    if ( tdb->maxFragSize == oid_nil) {
    	tdb->hashbatSize = NULL;
    } else {
    	tdb->hashbatSize = GDKmalloc((int)tdb->curFrag* sizeof(BUN));
	if ( !tdb->hashbatSize ) {
	    stream_printf(GDKout,"#ERROR:tdb_open: out of memory on hashbatSize malloc.\n");
	    return NULL;

	}
        TDB_DEBUG(TDB_OUT,"#termdb: create hashbatSize[%d] array.\n",(int)tdb->curFrag);
    }
    int i;

    for(i=0; i<(int)tdb->nFrag; i++) {
        tdb->buckets[i] = (int)tdb_findOid(tdb->conf,TDB_LOC_TREE(i));
    }
    for(i=0; i<(int)tdb->curFrag; i++) {
        tdb->hashbat[i] = NULL; // demand loading
	if ( tdb->hashbatSize )
		tdb->hashbatSize[i] = 0;
    }
    TDB_DEBUG(TDB_OUT,"#termdb: finish tdb_open().\n");
    return tdb;
}

int tdb_isEmpty(termDbCtx* tdb) {
    return (tdb->curOid == 0);
}

int tdb_close(termDbCtx* tdb) {
    TDB_DEBUG(TDB_OUT,"#termdb: execute tdb_close().\n");
    if ( tdb->startOid != tdb->curOid ) {
        if ( !tdb_replaceOid(tdb->conf,TDB_LOC_CUROID,tdb->curOid) )
	    return 0;
    }
    GDKfree(tdb->buckets);
    TDB_DEBUG(TDB_OUT,"#termdb: active hash-distr =");
    for(int i=0; i<(int)tdb->curFrag; i++) {
        if ( tdb->hashbat[i] ) {
            TDB_DEBUG(TDB_OUT," %d[%d]",i,(int)BATcount(tdb->hashbat[i]));
	    BBPunfix(BBPcacheid(tdb->hashbat[i]));
	} else {
            TDB_DEBUG(TDB_OUT," %d[X]",i);
	}
    }
    TDB_DEBUG(TDB_OUT,".\n");
    GDKfree(tdb->hashbat);
    if ( tdb->hashbatSize ) 
        GDKfree(tdb->hashbatSize);
    BBPunfix(BBPcacheid(tdb->conf));
    BBPunfix(BBPcacheid(tdb->tags));
    BBPunfix(BBPcacheid(tdb->frags));
    GDKfree(tdb);
    TDB_DEBUG(TDB_OUT,"#termdb: finish tdb_close().\n");
    return 1;
}

INLINE static unsigned long hashTerm(char* str) {
    unsigned long res = 0;
    int ch;

    while ( (ch = *str++) )
        res = ch + (res << 6) + (res << 16) - res;

    return res;
}

BAT* get_fragBAT(termDbCtx* tdb, int idx) {
    BAT* res;

    if ( (res = tdb->hashbat[idx]) )
        return res;
    else {
    	res = tdb_findBat(tdb->frags,idx);
	if ( ! res ) {
            stream_printf(GDKout,"#termdb:get_fragBAT: unable to load fragment[%d].\n",idx);
	    return NULL;
	}
	if ( !tdb_checkHashTable(res) )
	    return NULL;
	BBPfix(BBPcacheid(res));
	tdb->hashbat[idx] = res;
	if ( tdb->hashbatSize ) {
	    tdb->hashbatSize[idx] = BATcount(res);
	}
        TDB_DEBUG(TDB_OUT,"#termdb:get_fragBAT(): loaded fragment[%d].\n",idx);
	return res;
    }
}

int tdb_splitBucket(termDbCtx* tdb, int frag) {
    // dumpTDB(tdb,"before split");
    TDB_DEBUG(TDB_OUT,"#termdb:tdb_splitBucket(tdb,%d): called.\n",frag);
    int i, lower = -1, upper = -1;
    for(i=0; i<(int)tdb->nFrag; i++) {
    	if ( tdb->buckets[i] == frag ) {
	    if ( lower == -1 )
	        lower = i;
	     if ( i > upper )
	        upper = i;
	}
    }
    TDB_DEBUG(TDB_OUT,"# tdb_splitBucket(), frag=%d, range=[%d,%d]\n",frag,lower,upper);
    int new_fragIdx = tdb->curFrag;
    int range = ((upper+1)-lower);
    if ( range == 1 ) {
        stream_printf(GDKout,"# WARNING: tdb_splitBucket(), frag=%d, range=[%d,%d], UNABLE to split\n",frag,lower,upper);
	tdb->hashbatSize[frag] = 0; // to be able to continue
        return 1;
    }
    for(i=lower+range/2; i<=upper ; i++) {
        TDB_DEBUG(TDB_OUT,"# tdb_splitBucket(), bucket[%d] = %d\n",i,(int)new_fragIdx);
	tdb->buckets[i] = new_fragIdx;
        if ( !tdb_replaceOid(tdb->conf,TDB_LOC_TREE(i),(oid)new_fragIdx) )
            return 0;
    }
    BAT* old_frag = tdb_prepare2destroy(tdb->hashbat[frag]);
    BAT* new_frag;
    if ( !(tdb->hashbat[frag] = pftu_create_bat(hashbatName(TERMDBBAT,frag),TYPE_str,TYPE_oid,1/*persistent*/)) ||

         !(new_frag = pftu_create_bat(hashbatName(TERMDBBAT,new_fragIdx),TYPE_str,TYPE_oid,1/*persistent*/)) )
        return 0;
    BBPfix(BBPcacheid(new_frag));
    BBPfix(BBPcacheid(tdb->hashbat[frag]));
    //
    oid oid_frag = (oid)frag;
    if ( !BUNappend(tdb->frags, &BBPcacheid(new_frag), 0) ||
	 !BUNreplace(tdb->frags,&oid_frag,&BBPcacheid(tdb->hashbat[frag]),0)
       ) {
	   stream_printf(GDKout,"# ERROR: unable to update frag bat.\n");
           return 0;
    }
    /*
     *
     */
    tdb->hashbat= GDKrealloc(tdb->hashbat,1+(int)tdb->curFrag* sizeof(BAT*));
    if ( !tdb->hashbat ) {
	stream_printf(GDKout,"tdb_splitBucket: realloc fails.\n");
        return 0;
    }
    tdb->hashbat[new_fragIdx] = 0;
    if (tdb->hashbatSize) {
        tdb->hashbatSize = GDKrealloc(tdb->hashbatSize,1+(int)tdb->curFrag* sizeof(BUN));
        if ( !tdb->hashbatSize ) {
	    stream_printf(GDKout,"tdb_splitBucket: realloc fails.\n");
            return 0;
        }
        tdb->hashbatSize[frag]        = 0;
        tdb->hashbatSize[new_fragIdx] = 0;
    }
    /*
     *
     */
    BUN p, q;
    BATiter old_fragi = bat_iterator(old_frag);
    BATloop(old_frag, p, q) {
	str h = (str) BUNhead(old_fragi, p);
	oid t = *(oid*)BUNtail(old_fragi, p);

	if ( !tdb_insertTerm(tdb,h,t,1 /*incomplete, should be 0 */ ) )
	    return 0;
    }
    BBPunfix(BBPcacheid(old_frag));
    if ( !tdb_replaceOid(tdb->conf,TDB_LOC_CURFRAG,++tdb->curFrag) )
        return 0;
    /* oeff, ready */
    return 1;
}


int tdb_insertTerm(termDbCtx* tdb, char* term, oid o, int check) {
    int frag = tdb->buckets[hashTerm(term) % tdb->nBuckets];

    BAT* fragTerm = get_fragBAT(tdb, frag);

    if ( ! fragTerm )
    	return 0;
    if ( check && BUNfnd(fragTerm,term) != BUN_NONE ) {
        stream_printf(GDKout,"#tdb_insertTerm:frag[%d]: duplicate term \"%s\".\n",frag,term);
        return 0;
    } else {
    	if ( !BUNins(fragTerm, (str)term, &o, FALSE)){
    	    GDKerror("tdb_insertTerm: insert \"%s\" in termbat fails.\n");
    	    return 0;
        } 
	if ( tdb->hashbatSize ) {
	    if ( ++tdb->hashbatSize[frag] > tdb->maxFragSize)
	        if ( !tdb_splitBucket(tdb,frag) )
		    return 0;
	}
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_insertTerm[%d](\"%s\") = " OIDFMT "[new]\n",frag,term,o);
#endif
    }
    return 1;
}

oid tdb_lookupTerm(termDbCtx* tdb, char* term) {
    if (1) TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTerm(\"%s\") start\n",term);
    int frag = tdb->buckets[hashTerm(term) % tdb->nBuckets];

    BAT* fragTerm = get_fragBAT(tdb, frag);

    if ( ! fragTerm )
    	return oid_nil;
    BUN bun;
    if ( (bun = BUNfnd(fragTerm,term)) != BUN_NONE ) {
        BATiter fragTermi = bat_iterator(fragTerm);
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTerm[%d](\"%s\") = " OIDFMT "\n",frag,term,*(oid*)BUNtail(fragTermi,bun));
#endif
        return *(oid*)BUNtail(fragTermi,bun);
    } else {
    	if ( !BUNins(fragTerm, (str)term, &tdb->curOid, FALSE)){
    	    GDKerror("tdb_lookup: insert \"%s\" in termbat fails.\n");
    	    return oid_nil;
        }  
	if ( tdb->hashbatSize ) {
	    if ( ++tdb->hashbatSize[frag] > tdb->maxFragSize)
	        if ( !tdb_splitBucket(tdb,frag) )
	            return oid_nil;
	}
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTerm[%d](\"%s\") = " OIDFMT "[new]\n",frag,term,tdb->curOid);
#endif
    	return tdb->curOid++;
    }
}

oid tdb_lookupTag(termDbCtx* tdb, char* tag) {
    BUN bun;
	
    if ( (bun = BUNfnd(tdb->tags,tag)) != BUN_NONE ) {
        BATiter ti = bat_iterator(tdb->tags);
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTag(\"%s\") = " OIDFMT "\n",tag,*(oid*)BUNtail(ti,bun));
#endif
        return *(oid*)BUNtail(ti,bun);
    } else {
    	if ( !BUNins(tdb->tags, (str)tag, &tdb->curTagOid, FALSE)){
    	    GDKerror("tdb_lookupTag: insert \"%s\" in tagbat fails.\n");
    	    return oid_nil;
        } else { 
#ifdef TDB_SHOWLOOKUP
            TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTag(\"%s\") = " OIDFMT "[new]\n",tag,tdb->curTagOid);
#endif
    	    return tdb->curTagOid++;
        }
    }
}

/* vim:set shiftwidth=4 expandtab: */
