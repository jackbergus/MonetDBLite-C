@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2007 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'

@f termdb
@a Jan Flokstra
@a Henning Rode
@t termdb

@h

/*
 * CHANGES: make all term bats of type [str,oid] because all major operations
 *          use BUNfnd and hashing and these work more easy with the string
 *          in the head
 *
 */

/* #define USE_TERMDB */ /* used by serialize_pftijah */

#define TDB_DEBUG if ( 0 ) stream_printf
#define TDB_OUT   GDKout
/* #define TDB_SHOWLOOKUP used to debug all term lookups */

#define TERMDBCONF	"tj_termDBconf"
#define TERMDBTAGS	"tj_termDBtags0"
#define TERMDBFRAGMENTS	"tj_termDBfragments"
#define TERMDBBAT	"tj_termDBbat%d"

#define TDB_LOC_NFRAG       0
#define TDB_LOC_MAXFRAGSIZE 1
#define TDB_LOC_CURFRAG     2
#define TDB_LOC_CUROID      3
#define TDB_LOC_TREE(I)     (I+4)

typedef struct termDbCtx {
	BAT*	frags;
	BAT*	conf;
	oid	nFrag;
	oid	maxFragSize;
	oid	curFrag;
	oid	curOid;
	oid	startOid;
	//
	oid     curTagOid;
	BAT*	tags;
	//
	unsigned int nBuckets;
	//
	int*	buckets;
	BAT**	hashbat;
	size_t* hashbatSize;
} termDbCtx;

extern int termdb_prelude();

extern termDbCtx* tdb_open();
extern int	  tdb_insertTerm(termDbCtx* tdb, char* term, oid o, int check);
extern oid	  tdb_lookupTerm(termDbCtx* tdb, char* term);
extern oid	  tdb_lookupTag(termDbCtx* tdb, char* term);
extern int        tdb_close(termDbCtx* tdb);
extern int        tdb_isEmpty(termDbCtx* tdb);

@c
#include <pf_config.h>

/*******************************************
 * termdb.c : the parallel term database
 *
 */

#include <gdk.h>

#include "termdb.h"

BAT* tdb_createBAT(char* name, int ht, int tt, int persists) {
    BAT* b = BATnew(ht,tt,0);
    if ( (!b) || (BBPrename(BBPcacheid(b),name)!=0) ) {
      stream_printf(GDKout,"#termdb:createBAT(\"name\"): bat creation failed.\n",name);
      return NULL;
    }
    if ( persists ) {
      b->batPersistence = PERSISTENT;
    }
    TDB_DEBUG(TDB_OUT,"#termdb: createBAT(\"%s\",%d,%d,%d) succes.\n",name,ht,tt,persists);
    return b;
}

INLINE static BAT *tdb_lookupBAT(str name) {
    bat b = BBPindex(name);
    
    if ( b == bat_nil ) {
    	return NULL;
    } else {
    	return BBPdescriptor(b);
    }
}

INLINE static int tdb_destroyBAT(str name) {
    bat b = BBPindex(name);

    if ( b == bat_nil ) {
        stream_printf(GDKout,"#termdb:tdb_destroyBAT(\"%s\"): bat deletion failed.\n",name);
        return 0;
    } else {
        BAT* bat = BBPdescriptor(b);

        bat->batPersistence = TRANSIENT;
	BATdelete(bat);
        /* stream_printf(GDKout,"#termdb:tdb_destroyBAT(\"%s\")\n",name); */
        return 1;
    }
}

INLINE static char* hashbatName(char* format, int i) {
    static char buff[32];

    sprintf(buff,format,i);
    return buff;
}


INLINE static oid tdb_findOid(BAT* void_oid_bat, oid idx) {
	BUN bun;

	BUNfndVOID(bun,void_oid_bat,&idx);
	if ( bun ) {
	    return *(oid*)BUNtail(void_oid_bat,bun);
	} else {
	    return oid_nil;
	}
}

INLINE static int tdb_replaceOid(BAT* void_oid_bat, oid idx, oid v) {
	if ( !BUNreplace(void_oid_bat,&idx,&v,0) ) {
            stream_printf(GDKout,"#tdb_replaceOid: BUNreplace failed.\n");
	    return 0;
	} else
	    return 1;
}

BAT* tdb_findBat(BAT* void_bat_bat, oid idx) {
	BUN bun;

	BUNfndVOID(bun,void_bat_bat,&idx);
	if ( bun ) {
	    bat resbat = *(bat*)BUNtail(void_bat_bat,bun);
    	    return BBPdescriptor(resbat);
	} else {
	    return NULL;
	}
}

int termdb_prelude() {
    TDB_DEBUG(TDB_OUT,"#termdb:prelude: start.\n");

    BAT* conf = tdb_lookupBAT(TERMDBCONF);

    if ( conf ) {
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: found conf bat: \"%s\".\n",TERMDBCONF);
        if ( tdb_lookupBAT(TERMDBFRAGMENTS) ) {
            stream_printf(GDKout,"#termdb_prelude: bat \"%s\"already exists.\n",TERMDBFRAGMENTS);
            return GDK_FAIL;
        }
        BAT* rt = tdb_createBAT(TERMDBFRAGMENTS,TYPE_void,TYPE_bat,0);
	if ( !rt )
	    return GDK_FAIL;
        BBPfix(BBPcacheid(rt));
        BATseqbase(rt,(oid)0);

	oid curFrag = tdb_findOid(conf,TDB_LOC_CURFRAG); 
	if ( curFrag == oid_nil ) {
            stream_printf(GDKout,"#termdb_prelude: read nil curFrag.\n");
	    return GDK_FAIL;
	}
	for(int i=0; i<(int)curFrag; i++) {
	    BAT* fb = tdb_lookupBAT(hashbatName(TERMDBBAT,i));

            if ( !fb || !BUNappend(rt, &BBPcacheid(fb), 0) ) {
                stream_printf(GDKout,"#termdb_prelude: fail to add fragbat[%i] to rt bat.\n");
	        return GDK_FAIL;
	    }
	}
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: created runtime bat: \"%s\".\n",TERMDBFRAGMENTS);
	if ( 0 ) BATprintf(GDKout,rt);
    } else {
        TDB_DEBUG(TDB_OUT,"#termdb:prelude: no conf bat: \"%s\".\n",TERMDBCONF);
    }
    return GDK_SUCCEED;
}

int CMDtj_create_termdb(int* p_nFrag, oid* p_maxFragSize) {
    oid nFrag       = *p_nFrag;
    oid maxFragSize = *p_maxFragSize;
    int dynamic     = (maxFragSize != oid_nil);
    oid curFrag     = (dynamic ? (oid)1 :nFrag);
    oid curOid      = (oid)0; /* first oid in termdb */

    TDB_DEBUG(TDB_OUT,"#termdb: CMDtj_create_termdb(" OIDFMT "," OIDFMT ").\n",nFrag, maxFragSize);

    BAT* conf;
    
    if ( tdb_lookupBAT(TERMDBCONF) ) {
        stream_printf(GDKout,"#CMDtj_create_termdb: bat \"%s\"already exists.\n",TERMDBCONF);
        return GDK_FAIL;
    }
    if (!(conf = tdb_createBAT(TERMDBCONF,TYPE_void,TYPE_oid,1/*persistent*/)))
        return GDK_FAIL;
    BATseqbase(conf,(oid)0);
    if ( !BUNappend(conf, &nFrag, 0) ||
         !BUNappend(conf, &maxFragSize, 0) ||
         !BUNappend(conf, &curFrag, 0) ||
         !BUNappend(conf, &curOid, 0) 
    ) {
        stream_printf(GDKout,"#ERROR: CMDtj_create_termdb: error writing conf HEADER.\n");
        return GDK_FAIL;
    }

    BAT* tags;
    if ( ! (tags=tdb_createBAT(TERMDBTAGS,TYPE_str,TYPE_oid,1/*persistent*/)) )
                return GDK_FAIL;

    oid lastbat = 0;
    for(int i=0; i< (int)nFrag; i++) {
        if (  (i==0) || !dynamic ) {
	    lastbat = (oid)i;
            if ( ! tdb_createBAT(hashbatName(TERMDBBAT,i),TYPE_str,TYPE_oid,1/*persistent*/))
                return GDK_FAIL;
	}
    	if ( !BUNappend(conf, &lastbat, 0) ) {
            stream_printf(GDKout,"#ERROR: CMDtj_create_termdb: error writing hash tree HEADER.\n");
	    return GDK_FAIL;
	}
    }
    if ( 0 ) BATprintf(GDKout,conf);
    return termdb_prelude();
}

int CMDtj_dispose_termdb() {
    termDbCtx *tdb = tdb_open();

    if ( !tdb ) {
        stream_printf(GDKout,"#ERROR: CMDtj_dispose_termdb: fail to open termDB.\n");
	return  GDK_FAIL;
    }
    oid nFrag = tdb->nFrag;
    if ( ! tdb_close(tdb) ) {
        stream_printf(GDKout,"#ERROR: CMDtj_dispose_termdb: fail to close termDB.\n");
	return  GDK_FAIL;
    }
    if ( !tdb_destroyBAT(TERMDBCONF) ||
         !tdb_destroyBAT(TERMDBTAGS) ||
         !tdb_destroyBAT(TERMDBFRAGMENTS)
       ) {
    	return GDK_FAIL;
    }
    for(int i=0; i<(int)nFrag; i++) {
	if ( !tdb_destroyBAT(hashbatName(TERMDBBAT,i)) )
	    return GDK_FAIL;
    }
    return GDK_SUCCEED;
}

/*
 *
 */
int tdb_checkHashTable(BAT* b) {
    if ( b->thash == NULL ) {
         if ( !BAThash(b,0) ) {
                 stream_printf(GDKout,"#Itermdb:tdb_checkHashTable: fail to creat hashtable on [oid,str] bat.\n");
             return 0;
         } else {
            TDB_DEBUG(TDB_OUT,"#termdb:tdb_checkHashTable(): created hashtable on [oid,str] bat.\n");
	}
    }
    return 1;
}

/*
 *
 *
 */

termDbCtx* tdb_open() {
    TDB_DEBUG(TDB_OUT,"#termdb: start tdb_open().\n");

    BAT* tdb_frags = tdb_lookupBAT(TERMDBFRAGMENTS);
    if ( !tdb_frags ) {
        stream_printf(GDKout,"#ERROR:tdb_open: no termdb runtime bat found.\n");
    	return NULL;
    }
    termDbCtx* tdb = GDKmalloc(sizeof(termDbCtx));
    if ( !tdb ) {
        stream_printf(GDKout,"#ERROR:tdb_open: out of memory on termDbCtx malloc.\n");
    	return NULL;
    }

    tdb->frags	= tdb_frags;
    BBPfix(BBPcacheid(tdb->frags));
    tdb->conf	= tdb_lookupBAT(TERMDBCONF);
    if ( tdb->conf == NULL ) {
        stream_printf(GDKout,"#ERROR:tdb_open: unable to load conf bat.\n");
    	return NULL;
    }
    BBPfix(BBPcacheid(tdb->conf));
    //
    tdb->tags        = tdb_lookupBAT(TERMDBTAGS);
    if ( tdb->tags == NULL ) {
        stream_printf(GDKout,"#ERROR:tdb_open: unable to load tags bat.\n");
    	return NULL;
    }
    BBPfix(BBPcacheid(tdb->tags));
    if ( !tdb_checkHashTable(tdb->tags) )
        return NULL;
    tdb->curTagOid   = (oid)BATcount(tdb->tags);
    //
    tdb->nFrag       = tdb_findOid(tdb->conf,TDB_LOC_NFRAG);
    tdb->nBuckets    = (unsigned int)tdb->nFrag;
    tdb->curOid      = tdb_findOid(tdb->conf,TDB_LOC_CUROID);
    tdb->startOid    = tdb->curOid;
    tdb->curFrag     = tdb_findOid(tdb->conf,TDB_LOC_CURFRAG);
    tdb->maxFragSize = tdb_findOid(tdb->conf,TDB_LOC_MAXFRAGSIZE);

    TDB_DEBUG(TDB_OUT,"#termdb: loaded conf parameters:\n");
    TDB_DEBUG(TDB_OUT,"#termdb: nFrag       = " OIDFMT "\n",tdb->nFrag);
    TDB_DEBUG(TDB_OUT,"#termdb: maxFragSize = " OIDFMT "\n",tdb->maxFragSize);
    TDB_DEBUG(TDB_OUT,"#termdb: curOid      = " OIDFMT "\n",tdb->curOid);
    TDB_DEBUG(TDB_OUT,"#termdb: curFrag     = " OIDFMT "\n",tdb->curFrag);

    tdb->buckets = GDKmalloc((int)tdb->nFrag  * sizeof(int));
    tdb->hashbat= GDKmalloc((int)tdb->curFrag* sizeof(int));
    if ( !tdb->buckets || !tdb->hashbat ) {
        stream_printf(GDKout,"#ERROR:tdb_open: out of memory on bucket/bats malloc.\n");
    	return NULL;
    }
    if ( tdb->maxFragSize == oid_nil) {
    	tdb->hashbatSize = NULL;
    } else {
    	tdb->hashbatSize = GDKmalloc((int)tdb->curFrag* sizeof(size_t));
	if ( !tdb->hashbatSize ) {
	    stream_printf(GDKout,"#ERROR:tdb_open: out of memory on hashbatSize malloc.\n");
	    return NULL;

	}
    }
    int i;

    for(i=0; i<(int)tdb->nFrag; i++) {
        tdb->buckets[i] = (int)tdb_findOid(tdb->conf,TDB_LOC_TREE(i));
    }
    for(i=0; i<(int)tdb->curFrag; i++) {
        tdb->hashbat[i] = NULL; // demand loading
	if ( tdb->hashbatSize )
		tdb->hashbatSize = 0;
    }
    TDB_DEBUG(TDB_OUT,"#termdb: finish tdb_open().\n");
    return tdb;
}

int tdb_isEmpty(termDbCtx* tdb) {
    return (tdb->curOid == 0);
}

int tdb_close(termDbCtx* tdb) {
    TDB_DEBUG(TDB_OUT,"#termdb: execute tdb_close().\n");
    if ( tdb->startOid != tdb->curOid ) {
        if ( !tdb_replaceOid(tdb->conf,TDB_LOC_CUROID,tdb->curOid) )
	    return 0;
    }
    GDKfree(tdb->buckets);
    TDB_DEBUG(TDB_OUT,"#termdb: active hash-distr =");
    for(int i=0; i<(int)tdb->curFrag; i++) {
        if ( tdb->hashbat[i] ) {
            TDB_DEBUG(TDB_OUT," %d[%d]",i,(int)BATcount(tdb->hashbat[i]));
	    BBPunfix(BBPcacheid(tdb->hashbat[i]));
	} else {
            TDB_DEBUG(TDB_OUT," %d[X]",i);
	}
    }
    TDB_DEBUG(TDB_OUT,".\n");
    GDKfree(tdb->hashbat);
    if ( tdb->hashbatSize) 
        GDKfree(tdb->hashbatSize);
    BBPunfix(BBPcacheid(tdb->conf));
    BBPunfix(BBPcacheid(tdb->tags));
    BBPunfix(BBPcacheid(tdb->frags));
    GDKfree(tdb);
    TDB_DEBUG(TDB_OUT,"#termdb: finish tdb_close().\n");
    return 1;
}

INLINE static unsigned long hashTerm(char* str) {
    unsigned long res = 0;
    int ch;

    while ( (ch = *str++) )
        res = ch + (res << 6) + (res << 16) - res;

    return res;
}

BAT* get_fragBAT(termDbCtx* tdb, int idx) {
    BAT* res;

    if ( (res = tdb->hashbat[idx]) )
        return res;
    else {
    	res = tdb_findBat(tdb->frags,idx);
	if ( ! res ) {
            stream_printf(GDKout,"#Itermdb:get_fragBAT: unable to load fragment[%d].\n",idx);
	    return NULL;
	}
	if ( !tdb_checkHashTable(res) )
	    return NULL;
	BBPfix(BBPcacheid(res));
	tdb->hashbat[idx] = res;
	if ( tdb->hashbatSize ) {
	    tdb->hashbatSize[idx] = BATcount(res);
	}
        TDB_DEBUG(TDB_OUT,"#termdb:get_fragBAT(): loaded fragment[%d].\n",idx);
	return res;
    }
}

int tdb_handleOverflow(termDbCtx* tdb, int bucket) {
    (void)tdb;
    (void)bucket;
    // INCOMPLETE, bucket is overflowing and should be split
    return 1;
}

int tdb_insertTerm(termDbCtx* tdb, char* term, oid o, int check) {
    int frag = tdb->buckets[hashTerm(term) % tdb->nBuckets];

    BAT* fragTerm = get_fragBAT(tdb, frag);

    if ( ! fragTerm )
    	return oid_nil;
    if ( check && BUNfnd(fragTerm,term) ) {
        stream_printf(GDKout,"#tdb_insertTerm: duplicate term \"%s\".\n",term);
        return 0;
    } else {
    	if ( !BUNins(fragTerm, (str)term, &o, FALSE)){
    	    GDKerror("tdb_insertTerm: insert \"%s\" in termbat fails.\n");
    	    return 0;
        } 
	if ( tdb->hashbatSize ) {
	    if ( (size_t)++tdb->hashbatSize[frag] > (size_t)tdb->maxFragSize)
	        if ( !tdb_handleOverflow(tdb,frag) )
		    return 0;
	}
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookup(\"%s\") = " OIDFMT "[new]\n",term,o);
#endif
    }
    return 1;
}

oid tdb_lookupTerm(termDbCtx* tdb, char* term) {
    int frag = tdb->buckets[hashTerm(term) % tdb->nBuckets];

    BAT* fragTerm = get_fragBAT(tdb, frag);

    if ( ! fragTerm )
    	return oid_nil;
    BUN bun;
    if ( (bun = BUNfnd(fragTerm,term)) ) {
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookup(\"%s\") = " OIDFMT "\n",term,*(oid*)BUNtail(fragTerm,bun));
#endif
        return *(oid*)BUNtail(fragTerm,bun);
    } else {
    	if ( !BUNins(fragTerm, (str)term, &tdb->curOid, FALSE)){
    	    GDKerror("tdb_lookup: insert \"%s\" in termbat fails.\n");
    	    return oid_nil;
        } else { 
	    if ( tdb->hashbatSize ) {
	        if ( (size_t)++tdb->hashbatSize[frag] > (size_t)tdb->maxFragSize)
	            if ( !tdb_handleOverflow(tdb,frag) )
		        return 0;
	    }
#ifdef TDB_SHOWLOOKUP
            TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookup(\"%s\") = " OIDFMT "[new]\n",term,tdb->curOid);
#endif
    	    return tdb->curOid++;
        }
    }
}

oid tdb_lookupTag(termDbCtx* tdb, char* tag) {
    BUN bun;
	
    if ( (bun = BUNfnd(tdb->tags,tag)) ) {
#ifdef TDB_SHOWLOOKUP
        TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTag(\"%s\") = " OIDFMT "\n",tag,*(oid*)BUNtail(tdb->tags,bun));
#endif
        return *(oid*)BUNtail(tdb->tags,bun);
    } else {
    	if ( !BUNins(tdb->tags, (str)tag, &tdb->curTagOid, FALSE)){
    	    GDKerror("tdb_lookupTag: insert \"%s\" in tagbat fails.\n");
    	    return oid_nil;
        } else { 
#ifdef TDB_SHOWLOOKUP
            TDB_DEBUG(TDB_OUT,"#termdb:tdb_lookupTag(\"%s\") = " OIDFMT "[new]\n",tag,tdb->curTagOid);
#endif
    	    return tdb->curTagOid++;
        }
    }
}

/* vim:set shiftwidth=4 expandtab: */
