@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'

@f serialize_pftijah_options
@a Jan Flokstra
@a Henning Rode
@t serialize_pftijah_options

@h

extern int serialize_pftijah_options_DRIVER(
	BAT**			res;
        BAT*			ws,
        size_t			niters,
        BAT*			loop,
        BAT*			iter,
        BAT*			item, 
        BAT*			kind,
        BAT*			intVAL,
        BAT*			dblVAL,
        BAT*			strVAL);

@c

/*******************************************
 * serialize_pftijah_option.c : Tijah options serialization
 *
 */

#include <gdk.h>
#include <monet.h>

#include <pf_config.h>

#include <pathfinder.h>
#include <pf_support.h>
#include <serialize.h>

typedef struct PTOS {
    int  cnt;			/* count the number of tags here */
    BAT* bat;			/* [str,str] result BAT */
    const char* errorMessage;	/* error message buffer */
} PTOS;

static struct PTOS* GLOBAL_PTOS = NULL;

/**
 *
 * Definition of the structure containing the functions
 */
static int pftijah_options_init(XqueryCtx* ctx, char* args) {
    (void) args;
    ctx->driverWs		= GLOBAL_PTOS;
    GLOBAL_PTOS->errorMessage	= NULL;
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: pftijah_options_init() called.\n");
#endif
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static int
pftijah_options_handle_startElement(XqueryCtx* ctx, str ns, str name, oid pre) {
    struct PTOS* ptoctx = (struct PTOS*)ctx->driverWs;
    (void)ns;
    (void)pre;

    if ( strcmp("TijahOptions",name) != 0 ) {
        /* error here */
#ifdef DEBUG
        stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_startElement(%s) FAILS[badname].\n",name);
#endif
	return 0;
    }
    if ( ++ptoctx->cnt != 1 ) {
        /* error here */
        stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_startElement(%s) FAILS[badcount].\n",name);
	return 0;
    }
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_startElement(%s) SUCCES.\n",name);
#endif
    return 1;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static int pftijah_options_handle_attribute(XqueryCtx* ctx, str uri, str prefix, str loc, str value, int top) {
    struct PTOS* ptoctx = (struct PTOS*)ctx->driverWs;
    (void)uri;
    (void)prefix;
    (void)top;
    if ( !BUNins(ptoctx->bat, loc, value) ) {
        stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_attribute(%s,%s) FAILS[BUNins].\n",loc,value);
        /* error message here */
	return 0;
    }
#ifdef DEBUG
    stream_printf(GDKout,"pft_opt_deb: pftijah_options_handle_attribute(%s,%s) SUCCES.\n",loc,value);
#endif
    return 1;
}

static struct serializeFunStruct pftijah_optionsSerializeFun = {
	"pftijah_options",
	pftijah_options_init,
	null_handle_startDocument,
	null_handle_endDocument,
	pftijah_options_handle_attribute,
	null_handle_attributeEnd,
	pftijah_options_handle_startElement,
	null_handle_endElement,
	null_handle_characters,
	null_handle_ignorableWhitespace,
	null_handle_comment,
	null_handle_processingInstruction,
	/* */
	null_seqStart,
	null_seqDmAttrStart,
	null_seqDmAttrEnd,
	null_seqElementStart,
	null_seqElementEnd,
	null_seqEnd,
	null_seqEmitBool,
	null_seqEmitInt,
	null_seqEmitDbl,
	null_seqEmitStr
};

int serialize_pftijah_options_DRIVER(
	BAT**			res,
        BAT*			ws,
        size_t			niters,
        BAT*			loop,
        BAT*			iter,
        BAT*			item, 
        BAT*			kind,
        BAT*			intVAL,
        BAT*			dblVAL,
        BAT*			strVAL) {

	(void)niters;
	(void)loop;
	(void)iter;
	struct PTOS ptos;
	if ( GLOBAL_PTOS ) {
	    /* error locked ?? */
	    return GDK_FAIL;
	}
	GLOBAL_PTOS = &ptos;
	ptos.cnt = 0;
	ptos.bat = BATnew(TYPE_str, TYPE_str, 32);
#ifdef DEBUG
	stream_printf(GDKout,"******** NITERS = %d\n",niters);
	BATprintf(GDKout,loop);
	BATprintf(GDKout,iter);
	BATprintf(GDKout,item);
	BATprintf(GDKout,kind);
#endif
	int returnVal = xquery_print_result_DRIVER(
		"",
		&pftijah_optionsSerializeFun,
		"",
        	ws,
        	1,    /* niters, */
        	item, /* loop, */
        	item, /* iter, */
        	item, 
        	kind,
        	intVAL,
        	dblVAL,
        	strVAL);
#ifdef DEBUG
	BATprintf(GDKout,ptos.bat);
#endif
	*res = ptos.bat;
	GLOBAL_PTOS = NULL;
	return returnVal;
}

/* vim:set shiftwidth=4 expandtab: */
