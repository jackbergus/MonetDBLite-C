@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the PfTijah Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html
@' 
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@' 
@' The Original Code is the PfTijah system.
@' 
@' The Initial Developer of the Original Code is the "University of Twente".
@' Portions created by the "University of Twente" are 
@' Copyright (C) 2006-2007 "University of Twente".
@' All Rights Reserved.
@'

@f serialize_pftijah
@a Jan Flokstra
@a Henning Rode
@t serialize_pftijah

@h
#include <gdk.h>

struct tijahContextStruct;

extern int handleTijahTerm(struct tijahContextStruct *ctx, char* term);

extern int useFlexScanner(char* buf, int len, struct tijahContextStruct* tjCtx); /* FLEX */
extern char* flexScanOneTerm(char* buf, int len);

extern char* normalizeTerm(struct tijahContextStruct *ctx, char* term );

extern int CMDtj_normalizeTerm(char** res, str term, str stemmer);

@c
#include <pf_config.h>


/* #define TJ_TRACE 1 */

/*******************************************
 * serialize_pftijah.c : XML serialization
 *
 */

#include "serialize.h"
/* contains dummy callback functions */
#include "serialize_null.h"

#include "serialize_pftijah.h"
#include "pftijah_stem.h"

#include "pftijah_util.h"

#include "termdb.h"

#include "shredder.h"

/************************************************
 *
 * The fast direct BAT interface
 */

typedef struct dbat_struct {
	const char*	name;
	BAT*		bat;
	int		oid_mark;
	int		max_i;
	int		max_sz;
	bit		dflt;	  /* fill with default value during extend */
	int		dflt_int; /* the default int value */
	chr		dflt_chr; /* the default chr value */
	oid		dflt_oid; /* the default oid value */
	/* */
        union { /* cast to perform direct indexex insert in [void,any] BATs */
            void* voidCAST; /* the basecast */
            chr*  chrCAST;  /* cast for [void,chr] BAT */
            int*  intCAST;  /* cast for [void,int] BAT */
            oid*  oidCAST;  /* cast for [void,oid] BAT */
        } cast;
} dbat;

int dbat_init(const char* name, dbat* dbat, BAT* b) {
	dbat->name = name;
	dbat->bat  = b;
	dbat->dflt = FALSE;
	if ( dbat->bat->htype != TYPE_void ) {
	    stream_printf(GDKerr,"ERROR: dbat_init(%s) non void BAT\n",dbat->name);
	    return 0;
	}
	if ( !((dbat->bat->ttype == TYPE_oid) || (dbat->bat->ttype == TYPE_int)) ) {
	    stream_printf(GDKerr,"ERROR: dbat_init(%s) unknown ttype(%d)\n",dbat->name,dbat->bat->ttype);
	    return 0;
	}
        dbat->oid_mark = b->hseqbase;
	dbat->max_i = dbat->max_sz = BATcount(dbat->bat);
	dbat->cast.voidCAST = (void*)BUNfirst(dbat->bat);
	/* */
	return 1;
}

int dbat_finalize(dbat* dbat) {
        BAT* b = dbat->bat;

        void* top;
        
        int bottomTop = dbat->max_i;
	if ( 0 ) stream_printf(GDKout,"dbat_finalize(size=%d)\n",dbat->max_i);
        switch( b->ttype ) {
         case TYPE_int :
                top = &dbat->cast.intCAST[bottomTop];
                break;
         case TYPE_chr: {
                b->batBuns->free = dbat->max_i; 
                BATsetcount(b, dbat->max_i);
                b->tsorted = 0;
		b->batDirty = TRUE; /* VERY important this one */
                return 1;
                }
         case TYPE_oid:
                top = &dbat->cast.oidCAST[bottomTop];
                break;
         default:
                GDKerror("dbat_finalize: bad ttype\n");
                return -1;
        }
        b->batBuns->free = ((BUN)top) - BUNfirst(b);
        BATsetcount(b, (b->batBuns->free+Bunbase(b)-BUNfirst(b))/BUNsize(b));
        b->tsorted  = 0;
	b->batDirty = TRUE; /* VERY important this one */
	/* */
	dbat->name  = NULL;
	dbat->bat   = NULL;
	dbat->max_i = dbat->max_sz = 0;
	/* */
	return 1;
}

#define MINCHUNK 8192
#define MAXCHUNK 67108864

int dbat_extend(dbat* dbat, int i_mark) {
    /* CHECK THIS if ( i_mark ) i = i_mark - dbat->oid_mark; */
    size_t newsize = MAX(MIN(MAX(MINCHUNK,dbat->max_sz*2),(size_t)(dbat->max_sz+MAXCHUNK)),(size_t)i_mark);

    /* first check if the number of BUN's < INT_MAX. If this was the case
     * and the previous time INT_MAX was returned this means the BAT cannot
     * grow any longer.
     */
    if ( newsize > INT_MAX ) {
    	newsize = INT_MAX;

	if ( dbat->max_sz == INT_MAX ) {
        	GDKerror("dbat_extend: BATextend[\"%s\"](size>INT_MAX) fails\n","incomplete");
		return -1;
	}
    }
    if ( 0 ) { stream_printf(GDKout,"dbat_extend[%s](%d -> %d)\n",dbat->name,dbat->max_sz,newsize); }
    dbat->max_sz= newsize;
    if ( !(dbat->bat = BATextend(dbat->bat,newsize)) ) {
        GDKerror("dbat_extend: BATextend[\"%s\"](to %d) fails\n","incomplete",newsize);
        return -1;
    }
    dbat->cast.voidCAST = (void*)BUNfirst(dbat->bat);
    /*
     * now check if there's a default value handler used  
     *
     */
    if ( dbat->dflt ) {
        switch( dbat->bat->ttype ) {
         case TYPE_int : {
		int v   = dbat->dflt_int;
		int *to = &dbat->cast.intCAST[dbat->max_sz];
		for(register int *p = &dbat->cast.intCAST[dbat->max_i]; p<to;)
		    *p++ = v;
                break;
		}
         case TYPE_chr: {
		chr v   = dbat->dflt_chr;
		chr *to = &dbat->cast.chrCAST[dbat->max_sz];
		for(register chr *p = &dbat->cast.chrCAST[dbat->max_i]; p<to;)
		    *p++ = v;
                break;
                }
         case TYPE_oid: {
		oid v   = dbat->dflt_oid;
		oid *to = &dbat->cast.oidCAST[dbat->max_sz];
		for(register oid *p = &dbat->cast.oidCAST[dbat->max_i]; p<to;)
		    *p++ = v;
                break;
		}
         default:
                GDKerror("dbat_extend: bad ttype\n");
                return -1;
        }
    }
    /* */
    return 1;
}

int dbat_sizeHint(dbat* dbat, int sizeHint_mark) {
        int sizeHint = sizeHint_mark - dbat->oid_mark;
	int estimate = dbat->max_i + sizeHint;

	return dbat_extend(dbat, estimate);
}

INLINE static int dbat_set_oid(dbat* dbat, int pos_mark, oid v) {
	register int pos;

	if ( (pos=pos_mark - dbat->oid_mark) < dbat->max_i ) {
	    dbat->cast.oidCAST[pos] = v;
	    return 1;
	} else {
	    if ( pos >= dbat->max_sz ) {
		if ( dbat_extend(dbat,pos) < 0 )
		    return -1;
	    }
	    dbat->max_i = pos + 1;
	    dbat->cast.oidCAST[pos] = v;
	    return 1;
	}
}

INLINE static int dbat_set_int(dbat* dbat, int pos_mark, int v) {
	register int pos;

	if ( (pos=pos_mark - dbat->oid_mark) < dbat->max_i ) {
	    dbat->cast.intCAST[pos] = v;
	    return 1;
	} else {
	    if ( pos >= dbat->max_sz ) {
		if ( dbat_extend(dbat,pos) < 0 )
		    return -1;
	    }
	    dbat->max_i = pos + 1;
	    dbat->cast.intCAST[pos] = v;
	    return 1;
	}
}

/************************************************
 *
 * The Tijah-Pathfinder index creation context
 */

typedef struct tijahContextStruct {
	char* name;		/* name of the collection */
	oid  n_globalTerm;
	BAT* b_globalTerm;	/* global term dictionary*/
	BAT* hm_globalTerm;	/* hashed mirrorred global term dictionary*/
#ifdef USE_TERMDB
	termDbCtx* tdb;
#endif
	oid  n_globalTag;
	BAT* b_globalTag;	/* global tag dictionary*/
	BAT* hm_globalTag;	/* hashed mirrorred global tag dictionary*/
	BAT* b_docName;		/* BAT to store docnames in collection */
	BAT* b_docFirstPre;	/* First tijah-pre-nr of document */
	BAT* b_collParam;	/* Collection Parameters BAT */
	/* */
	unsigned int  fragmentSize;	/* maximum frament size, new frag if larger */
	oid  tijahPre;		/* Current max tijahpre number */
	/* INCOMPLETE< SHOULD BE FRAGMENTED */
	BAT* b_collPre;		/* Main tijah pre BAT */
	dbat dbat_collPre;	/* Direct access struct for b_collPre */
	/* INCOMPLETE< SHOULD BE FRAGMENTED */
	BAT* b_collSize;	/* Tijah PRE-size BAT */
	dbat dbat_collSize;	/* Direct access struct for b_collSize */
	/* */
	BAT* b_collPfPre;	/* Tijah PRE-PF BAT for Pathinder link */
	/*
	 */
	int		doc_height;
	int		max_doc_height;
	/* The BAT's for the tag selection and associated counters
	 */
	BAT* b_selectTags;	/* [void,str] BAT containing select tags */
	int  selTagDepth;	/* current selection tag depth, 0 = skip */
	/* The tagStack[] contains the starting Tijah oid of an element
	 * and is used to compute the size of an element in the Tijah
	 * pre-post-plane.
	 */
	oid  tagStack[MAXTAGDEPTH];
	int  tagStackPtr;
	/* */
	int preExpansion;	/* estimation for #TijahPre/PfPre */
	char* stemmer;	/* name of the stemmer used for this collection */
	tjStemCtx* stemCtx;
	char	checkStopWords;
} tjCtx;

#define DOEMIT(TJCTX)	((TJCTX)->selTagDepth)

static INLINE int
tj_pushTag(tjCtx* tjctx, oid start) {
	if ( tjctx->tagStackPtr > MAXTAGDEPTH ) {
	     GDKerror("tj_pushTag: MAXTAGDEPTH exceeded.\n");
	     return -1;
	}
	tjctx->tagStack[tjctx->tagStackPtr++] = start;
	return 1;
}

INLINE static oid
tj_popTag(tjCtx* tjctx) {
	return tjctx->tagStack[--tjctx->tagStackPtr];
}

/************************************************
 *
 *
 * First the temporary shredder for Tijah by JF
 *
 */

INLINE static oid
tj_tagOid(tjCtx* tjctx, str t) {
#ifdef USE_TERMDB
    return tdb_lookupTag(tjctx->tdb,t);
#else
    BUN bun;

    HASHfnd_str(bun, tjctx->hm_globalTag, (str)t);
    if ( bun )
    /* if ( (bun = BUNfnd(tjctx->hm_globalTag,t)) ) OLD */
        return *(oid*)BUNtail(tjctx->hm_globalTag,bun);
    else {
    	if ( !BUNins(tjctx->b_globalTag, &tjctx->n_globalTag, (str)t, FALSE) ) {
    	    GDKerror("INSERT OF \"%s\" in globalTag fails.\n");
    	    return oid_nil;
        } else
    	    return tjctx->n_globalTag++;
    }
#endif
}

INLINE static oid
tj_checkTerm(tjCtx* tjctx, char *t) {
#ifdef USE_TERMDB
   INCOMPLETE
#endif
   BUN bun;

   HASHfnd_str(bun, tjctx->hm_globalTerm, (str)t);
   if ( bun ) {
       return *(oid*)BUNtail(tjctx->hm_globalTerm,bun);
   } else
       return oid_nil;
}

INLINE static oid
tj_termOid(tjCtx* tjctx, char *t) {
#ifdef USE_TERMDB
    return tdb_lookupTerm(tjctx->tdb,t);
#else
    BUN bun;

    HASHfnd_str(bun, tjctx->hm_globalTerm, (str)t);
    if ( bun )
        return *(oid*)BUNtail(tjctx->hm_globalTerm,bun);
    else {
    	if ( !BUNins(tjctx->b_globalTerm, &tjctx->n_globalTerm, (str)t, FALSE)){
    	    GDKerror("INSERT OF \"%s\" in globalTerm fails.\n");
    	    return oid_nil;
        } else 
    	    return tjctx->n_globalTerm++;
    }
#endif
}

#define tj_add2plane(TJCTX,O) \
    ((dbat_set_oid(&(TJCTX)->dbat_collPre, (TJCTX)->tijahPre, O) < 0) \
    	   	? oid_nil : ((oid)(TJCTX)->tijahPre++))

#define insertPreSize(TJCTX,POS,SIZE) \
    dbat_set_int(&TJCTX->dbat_collSize,(int)POS,SIZE)


int
handleTijahTerm(struct tijahContextStruct *tjctx, char* term) {
    oid termOid, tjPre;

    /* is this DOEMIT here really necessary ??? */
    if ( DOEMIT(tjctx) ) {
        if ( (termOid = tj_checkTerm(tjctx, term)) == oid_nil ) {
          if ( tjctx->stemCtx->stem) {
    	    if ( !(term = (char*)tjctx->stemCtx->stem(tjctx->stemCtx,(char*)term)) ) {
	        /* must be a stopword */
	        return 1;
	    }
          }
          if ( (termOid = tj_termOid(tjctx, term)) == oid_nil )
    	    return 0;
	}
	if ( termOid ) { /* term is not a stopword */
            if ( (tjPre = tj_add2plane(tjctx, termOid)) == oid_nil )
    	        return 0;
            if ( insertPreSize(tjctx,tjPre,0) < 0 )
       	        return -1;
#ifdef TJ_TRACE
            if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:TERM: \"%s\", termoid=%d, tjPre=%d\n",tjctx->name,term,termOid,tjPre);
#endif
         } else {
#ifdef TJ_TRACE
            if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:STOPWORD: \"%s\"\n",tjctx->name,term);
#endif
	 }
     }
     return 1;
}

/************
 *
 * The part where the Strings from Pathfinder are shredded into words
 * by Tijah. The USE_FLEX macro determines if the strings is shredded
 * by Hennings fancy flex scanner or Jan's simple strtok() scanner.
 */

const char* obsoleteNexiChars = " \t\n\r,:;&*%$#!@=";

int 
useStrtokScanner(tjCtx* tjctx, char* s)
{
    char *t;
    int  sz = 0;

#ifdef TJ_TRACE
    if (TJ_TRACE) stream_printf(GDKout,"C[%s]:CHARACTERS:\n",tjctx->name);
#endif
    if ( (t = strtok(s,obsoleteNexiChars)) ) do {
	/* not the empty string here */
        if ( handleTijahTerm(tjctx,t) < 0 )
             return -1;
    	sz++;
    } while ( (t=strtok(NULL,obsoleteNexiChars)) );
    return 1;
}

/************************************************
 *
 * Now the real output handlers
 */


#ifdef notused
static int
handle_sizeHint(XqueryCtx* ctx, int hinted_size) {
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

    int estimate = hinted_size * tjctx->preExpansion;

    if ( dbat_sizeHint(&tjctx->dbat_collPre,estimate) < 0 )
    	return 0;
    if ( dbat_sizeHint(&tjctx->dbat_collSize,estimate) < 0 )
    	return 0;
    return 1;
}
#endif

const char* delchars2 = " \t\n\r,";

static int loadSelectionTagList(tjCtx* tjctx, char *l) {
    char *t;
    int  cnt=0;

    tjctx->b_selectTags = NULL; /* no selection tags specified is default */
    tjctx->selTagDepth  = 99;
    if ( (t = strtok(l,delchars2)) ) do {
	/* not the empty string here */
	if ( cnt++ == 0 ) {
    	    tjctx->selTagDepth  = 0;
	    tjctx->b_selectTags = BATmirror(BAThash(BATmirror(
	     		BATnew(TYPE_void, TYPE_str,32)),0));
	    if ( !tjctx->b_selectTags ) {
	    	return 0;
	    }
	}
	str v = (str)t;
	oid my_oid_nil = oid_nil;
	if ( !BUNins(tjctx->b_selectTags, &my_oid_nil, v, FALSE) )
	     return 0;
    } while ( (t=strtok(NULL,delchars2)) );
    return 1;
}

/* 
 * Read the value of a collection parameter from the collection parameter bat
 */
static str readCollParam(tjCtx* tjctx, str param) {
	BUN bun;
        bun = BUNfnd(tjctx->b_collParam,param);
	if ( bun ) {
	    return (str)BUNtail(tjctx->b_collParam,bun);
	} else
	    return (str)str_nil;
}

#define GUESSFORCE FALSE

/* 
 * Replace the value of a collection parameter int the collection parameter
 * bat
 */
static int replaceCollParam(tjCtx* tjctx, str param, str val) {
	return ( BUNreplace(tjctx->b_collParam,param,val,GUESSFORCE) != NULL );
}

static BAT*
getBAT(BAT* batbat, str bname) {
	BUN bun;
	if ( !(bun=BUNfnd(batbat,bname)) ) {
	    stream_printf(GDKerr,"getBAT:BUNfnd(%s) failed.\n",bname);
	    return NULL;
	}
	BAT* res = BATdescriptor( *(bat*)BUNtail(batbat,bun));
	if ( !res )
	    stream_printf(GDKerr,"getBAT:BATdescriptor() for %s failed.\n",bname);
	return res;
}

static const char* stopwordMarker = "#STOPWORD#";

static oid getPreSize(tjCtx* tjCtx) {
	str str_tijahPre = readCollParam(tjCtx,"_last_tijahPre");
	oid par_tijahPre;
	if ( str_tijahPre != str_nil ) {
		par_tijahPre = (oid)atol(str_tijahPre);
        } else {
		par_tijahPre = 1;
	}
	if ( 0 /* CHECK */ ) {
            oid chk = (oid)BATcount(tjCtx->b_collPre) + 1; 
	    if ( par_tijahPre != chk ) {
		stream_printf(GDKerr,"ERROR: getPreSize: oid out of sync: %d <-> %d.\n",par_tijahPre,chk);
	        return oid_nil;
	    }
	}
	return par_tijahPre;
}

static int setPreSize(tjCtx* tjCtx, oid newSize) {
	char buff[16];

	sprintf(buff,OIDFMT,newSize);
	if ( !replaceCollParam(tjCtx, "_last_tijahPre", (str)buff) )
	    return 0;
	return 1;
} 

static tjCtx*
loadTijahContext(BAT* tjCtx_BAT, char* selTagList) {
	tjCtx* res;

#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[]: start loadTijahContext\n");
#endif
	if ( !(res = (tjCtx*)malloc( sizeof(tjCtx) )) )
		return NULL;
	/*
	 * Set first settings
	 */

	/* set parameter bat first */
	if ( !(res->b_collParam   = getBAT(tjCtx_BAT,"_param")) ) return NULL;

	res->preExpansion = 1;
	str str_preExpansion = readCollParam(res,"preExpansion");
	if ( str_preExpansion != str_nil ) {
		int v = atoi(str_preExpansion);

		if ( v < 1 ) {
		} else
			res->preExpansion = v;
	}
	/* */
	res->fragmentSize = 0;
	str str_fragmentSize = readCollParam(res,"fragmentSize");
	if ( str_fragmentSize != str_nil ) {
		int v = atoi(str_fragmentSize);

		if ( v < 1 ) {
		} else
			res->fragmentSize = v;
	}
	/* */
	str str_name = readCollParam(res,"name");
	res->name = (char*)str_name;

	/* */
        res->checkStopWords = 1;
	str str_stopw = readCollParam(res,"stopwords");
	if ( str_stopw ) {
	    if (  (strcmp(str_stopw,"false") == 0) || (strcmp(str_stopw,"off")==0) )
	        res->checkStopWords = 0;
	}

	str str_stemmer = readCollParam(res,"stemmer");

	if ( str_stemmer != str_nil ) 
		res->stemmer = strdup((char*)str_stemmer);
	else
		res->stemmer = NULL;
	if ( !(res->stemCtx = getStemmingContext(res->stemmer)) )
		return NULL;
	if ( res->stemCtx->init && !res->stemCtx->init(res->stemCtx,NULL) )
			return NULL;
#ifdef TJ_TRACE
	if ( TJ_TRACE ) {
	   stream_printf(GDKout,"C[%s]: loadTijahContext() options read\n",res->name);
	   if ( res->fragmentSize )
	       stream_printf(GDKout,"C[%s]: loadTijahContext() fragmentSize = %d\n",res->name, res->fragmentSize);
        }
#endif
	/*
	 * The section where the parameter bats are read
	 */
#ifdef USE_TERMDB
	if ( !(res->tdb = tdb_open("termDB")) )
	    return NULL;
#endif
	if ( !(res->b_globalTerm  = getBAT(tjCtx_BAT,"_globalTerms")) ) return NULL;
	res->n_globalTerm = (oid)BATcount(res->b_globalTerm);
	if ( !(res->b_globalTag   = getBAT(tjCtx_BAT,"_globalTags")) ) return NULL;
	res->n_globalTag = (oid)BATcount(res->b_globalTag);
	/*
	 *
	 */
	if ( !(res->b_docName     = getBAT(tjCtx_BAT,"_doc_name")) ) return NULL;
	if ( !(res->b_docFirstPre = getBAT(tjCtx_BAT,"_doc_firstpre")) ) return NULL;
	if ( !(res->b_collPre     = getBAT(tjCtx_BAT,"_tid")) ) return NULL;
	if ( !(res->b_collSize    = getBAT(tjCtx_BAT,"_size")) ) return NULL;
	if ( (res->tijahPre = getPreSize(res)) == oid_nil )
	     return NULL;;
	/* check here for new fragmentation */
	if ( res->fragmentSize ) {
	    if ( (BATcount(res->b_collPre) > res->fragmentSize) ) {
#ifdef TJ_TRACE
	        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]: loadTijahContext() [b_collPre|b_collSize] too big(%d), create new fragment\n",res->name,BATcount(res->b_collPre));
#endif
		BAT* fragments;
	        if ( !(fragments = getBAT(tjCtx_BAT,"_fragments")) )
		    return NULL;
	        int newFragments  = (int)BATcount(fragments) + 1;
		/* */
		BBPunfix(BBPcacheid(res->b_collPre));
		res->b_collPre     = pftu_create_bat(pftu_batname1("tj_%s_tid%d",res->name,newFragments),TYPE_void,TYPE_oid,1);
		if ( !res->b_collPre ) 
		    return NULL;
		BBPfix(BBPcacheid(res->b_collPre));
	        BATseqbase(res->b_collPre,res->tijahPre);
		BBPunfix(BBPcacheid(res->b_collSize));
	        res->b_collSize    = pftu_create_bat(pftu_batname1("tj_%s_size%d",res->name,newFragments),TYPE_void,TYPE_int,1);
		if ( !res->b_collSize )
		    return NULL;
		BBPfix(BBPcacheid(res->b_collSize));
	        BATseqbase(res->b_collSize,res->tijahPre);
		if ( !BUNappend(fragments,&res->tijahPre,0) )
		    return NULL;
		BBPunfix(BBPcacheid(fragments));
		/* */
		str pretag = "_tid";
		bat prebat = BBPcacheid(res->b_collPre);
		if ( !BUNreplace(tjCtx_BAT,pretag,&prebat,0) ) { return NULL; }
		str sizetag = "_size";
		bat sizebat = BBPcacheid(res->b_collSize);
		if ( !BUNreplace(tjCtx_BAT,sizetag,&sizebat,0) ) { return NULL; }
#ifdef TJ_TRACE
	        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]: loadTijahContext() finished creating new fragments\n",res->name);
#endif
	    }
	}
	if ( dbat_init("b_collPre", &res->dbat_collPre, res->b_collPre) < -1 )
		return NULL;
	if ( dbat_init("b_collSize", &res->dbat_collSize, res->b_collSize) < -1 )
		return NULL;
	if ( !(res->b_collPfPre   = getBAT(tjCtx_BAT,"_pfpre")) ) return NULL;
	if ( !loadSelectionTagList(res,selTagList) ) return NULL;
	/* */
	res->tagStackPtr = 0;

#ifdef USE_TERMDB
	if ( tdb_isEmpty(res->tdb) ) {
	     if ( tdb_lookupTerm(res->tdb,(char*)stopwordMarker) == oid_nil )
	     	     return NULL;
	}
#endif
	/*
	 * Finally ensure there are accellerators on the Term and Tag dictionaries
	 */
	res->hm_globalTerm = BATmirror(res->b_globalTerm);

	if ( res->n_globalTerm == 0 ) {
	     oid zero = 0;
	     if ( !BUNins(res->b_globalTerm, &zero, (str)stopwordMarker, FALSE)){
	             return NULL;
	     }
	     res->n_globalTerm++;

#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:INSERTED STOPWORDMARKER IN GLOBALTERM\n",res->name);
#endif
	     if ( res->checkStopWords ) {
		 for(int i=0; res->stemCtx->stopWords[i]; i++) {
		     str sw = (str)res->stemCtx->stopWords[i];
		     /* INCOMPLETE, store it with 0 in termDB */
#ifdef USE_TERMDB
	             if ( !tdb_insertTerm(res->tdb,(char*)sw, zero, 0) ) {
		         return NULL;
		     }
#endif
	             if ( !BUNins(res->b_globalTerm, &zero, sw, FALSE)){
	                 return NULL;
	             }
#ifdef TJ_TRACE
	             if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:ADDED STOPWORD \"%s\" to GLOBALTERM\n",res->name,sw);
#endif
		     }
	     }
	}
	if ( res->b_globalTerm->thash == NULL ) {
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CREATE NEW HASHTABLE ON GLOBALTERM\n",res->name);
#endif
	     if ( !BAThash(BATmirror(res->b_globalTerm),0) ) {
                 GDKerror("loadTijahContext: adding hashtable to globalTerm fails\n");
	         return NULL;
	     }
	}
	res->hm_globalTag = BATmirror(res->b_globalTag);
	if ( res->b_globalTag->thash == NULL ) {
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CREATE NEW HASHTABLE ON GLOBALTAG\n",res->name);
#endif
	     if ( !BAThash(BATmirror(res->b_globalTag),0) ) {
                 GDKerror("loadTijahContext: adding hashtable to globalTag fails\n");
	         return NULL;
	     }
	}
	if ( ! (res->hm_globalTerm->hhash && res->hm_globalTag->hhash) )
	   stream_printf(GDKout,"# WARNING: MISSING HASH ON TAG/TERM DICTIONARY\n");
	return res;
}

static int
freeTijahContext(tjCtx* tjctx) {
        if ( !setPreSize(tjctx,tjctx->tijahPre) )
	        return GDK_FAIL;
#ifdef USE_TERMDB
	if ( ! tdb_close(tjctx->tdb) )
		return GDK_FAIL;
#endif
	/* BATkey(BATmirror(tjctx->b_globalTerm), TRUE); */
	/* BATkey(BATmirror(tjctx->b_globalTag), TRUE); */
	BATkey(BATmirror(tjctx->b_collPre), FALSE);
	BATkey(BATmirror(tjctx->b_collSize), FALSE);
	BBPunfix(BBPcacheid(tjctx->b_globalTerm));
	BBPunfix(BBPcacheid(tjctx->b_globalTag));
	BBPunfix(BBPcacheid(tjctx->b_docName));
	BBPunfix(BBPcacheid(tjctx->b_docFirstPre));
	BBPunfix(BBPcacheid(tjctx->b_collParam));
	BBPunfix(BBPcacheid(tjctx->b_collPre));
	BBPunfix(BBPcacheid(tjctx->b_collSize));
	BBPunfix(BBPcacheid(tjctx->b_collPfPre));
	if ( tjctx->stemCtx->clear && !tjctx->stemCtx->clear(tjctx->stemCtx) )
		return GDK_FAIL;
	free(tjctx);
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[{}]:FINISH: CMDtj_throw2collection()\n");
#endif
	return GDK_SUCCEED;
}

static int
handle_doc_height(tjCtx* tjctx) {
	str oldval = readCollParam(tjctx,"height");

	if ( oldval == str_nil)
	    return 0;
	if ( tjctx->max_doc_height > atoi( (char*)oldval) ) {
	   char buff[8];

	   sprintf(&buff[0],"%d",tjctx->max_doc_height);
	   if ( ! replaceCollParam(tjctx,"height",(str)&buff[0]))
	       return 0;
	}
	if ( 1 ) stream_printf(GDKout,"# **** SET MAX DOC HEIGHT TO: %d\n",tjctx->max_doc_height);
	return 1;
}

static oid
tijahDocIndex(tjCtx* ctx, str docName) {
        BAT* mb = BATmirror(ctx->b_docName);

        BUN bun;
        bun = BUNfnd(mb,docName);
        if ( bun ) {
               return *(oid*)BUNtail(mb,bun);
        }
	return oid_nil;
}

/*
 *
 *
 *
 */

static tjCtx* GLOBAL_TJCTX; /* INCOMPLETE, CODE NOT REENTRANT */

/**
 * Default driver initialization function
 */
static bool
pftijah_init(XqueryCtx* ctx, char* args, char* restag, char* resprefix, char* module, char* method) {
    (void) ctx;
    (void) args;
    (void) restag;
    (void) resprefix;
    (void) module;
    (void) method;

    ctx->driverWs = GLOBAL_TJCTX;
#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:pftijah_init()\n",GLOBAL_TJCTX->name);
#endif
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static bool
pftijah_handle_startDocument(XqueryCtx* ctx) {
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

    tjctx->doc_height = tjctx->max_doc_height = 0;
#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:startDocument()\n",tjctx->name);
#endif
    return 1;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static bool
pftijah_handle_attribute(XqueryCtx* ctx, str prefix, str loc, str value) {
    (void)ctx;
    (void)prefix;
    (void)loc;
    (void)value;
    return 1;
}

static int checkSelectTag(tjCtx* tjctx, str t, int plusormin) {
    if ( !tjctx->b_selectTags ) {
        return 1;
    } else {
        BAT* mb = BATmirror(tjctx->b_selectTags);

        BUN bun;
        bun = BUNfnd(mb,t);
        if ( bun ) { /* found */
    		tjctx->selTagDepth += plusormin;
    	}
        return 1;
    }
}

#define EMPTY_CHECK 

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static bool
pftijah_handle_startElement(XqueryCtx* ctx, str ns, str name, oid pre) {
    (void)ns;
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;
    oid termOid, tjPre;

    if ( ++tjctx->doc_height > tjctx->max_doc_height )
        tjctx->max_doc_height = tjctx->doc_height;
    if ( tjctx->b_selectTags && !checkSelectTag(tjctx,name,1) ) return 0;
    /* if ( DOEMIT(tjctx) ) { */
        if ( (termOid = tj_tagOid(tjctx, name)) == oid_nil )
    	    return 0;
        if ( (tjPre = tj_add2plane(tjctx, termOid)) == oid_nil )
    	    return 0;
        if ( tj_pushTag(tjctx,tjPre) < 0 ) return 0;
        if ( 0 ) stream_printf(GDKout,"C[%s]:startElement: \"%s\", termoid=%d, Tijah pre#=%d, Pathfinder pre#=%d\n",tjctx->name,name,termOid,tjPre,pre);
#ifdef TJ_TRACE
        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:startElement: \"%s\", termoid=%d, Tijah pre#=%d, Pathfinder pre#=%d\n",tjctx->name,name,termOid,tjPre,pre);
#endif
        if ( !BUNins(tjctx->b_collPfPre, &tjPre, &pre, FALSE) ) return 0;
    /* } */
    return 1;
}

static bool
pftijah_complete_startElementEmpty(XqueryCtx* ctx) {
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;
    --tjctx->doc_height;
    oid start = tj_popTag(tjctx); /* oid of the first node of the element */
    int size  = tjctx->tijahPre - start - 1; /* the Tijah element size */
    if ( insertPreSize(tjctx,start,size) < 0 )
	    return 0;
#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:empty_endElement: \"%s\"\n", tjctx->name,"");
#endif
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static bool
pftijah_handle_endElement(XqueryCtx* ctx, str ns, str name) {
    (void)ns;
    (void)name;
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;
    --tjctx->doc_height;
    /* if ( DOEMIT(tjctx) ) { */
        oid start = tj_popTag(tjctx); /* oid of the first node of the element */
        int size  = tjctx->tijahPre - start - 1; /* the Tijah element size */
	if ( insertPreSize(tjctx,start,size) < 0 )
	    return 0;
#ifdef TJ_TRACE
        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:endElement: \"%s\"\n", tjctx->name,name);
#endif
    /* } */
    if ( tjctx->b_selectTags && !checkSelectTag(tjctx,name,-1) ) return 0;
    return 1;
}

#define USE_FLEX 1

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static bool
pftijah_handle_characters(XqueryCtx* ctx, str ch) {
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:handle_characters(%s) start\n",tjctx->name, (char*)ch);
#endif

    if ( DOEMIT(tjctx) ) {
#ifdef USE_FLEX
        return useFlexScanner((char*)ch,strlen((char*)ch),tjctx);
#else
        return useStrtokScanner(tjctx,(char*)ch);
#endif
    }
    return 1;
}

char* normalizeTerm(struct tijahContextStruct *tjctx, char* term ) {
	char *res;
#ifdef USE_FLEX
        res = flexScanOneTerm((char*)term,strlen((char*)term));
#else
	res = strtok(term,obsoleteNexiChars);
#endif
	/* INCOMPLETE, should make shure tijahContext is always avail. here */
        if ( res && tjctx && tjctx->stemCtx->stem) {
    	    if ( !(res = (char*)tjctx->stemCtx->stem(tjctx->stemCtx,(char*)res)) ) {
	        /* must be a stopword */
	        return NULL;
	    }
        }
	return res;
}

int CMDtj_normalizeTerm(char** res, str term, str stemmer) {
//Leave tokenization disabled for now
//    char* tokenized;
//#ifdef USE_FLEX
//    tokenized = flexScanOneTerm(term,strlen(term));
//#else
//    tokenized = strtok(term,obsoleteNexiChars);
//#endif

    tjStemCtx* stemCtx = getStemmingContext( stemmer );

    if ( stemCtx->stem ) {
        if ( !stemCtx->udf && stemCtx->init ) stemCtx->init( stemCtx, NULL );

        char* stemmed = (char *)stemCtx->stem( stemCtx, term );
        if ( !stemmed ) {
            *res = NULL;
        } else {
            //if (*res) GDKfree(*res);
            *res = GDKmalloc( strlen(stemmed)+1 );
            strcpy( *res, stemmed );
        }
        //if ( stemCtx->clear ) stemCtx->clear( stemCtx );
    } else {
        //if (*res) GDKfree(*res);
        *res = GDKmalloc( strlen(term)+1 );
        strcpy( *res, term );
    }
    return GDK_SUCCEED;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static bool
pftijah_handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
    return pftijah_handle_characters(ctx,ch); /* dispatch */
}

/**
 *
 * Definition of the structure containing the functions
 */
struct serializeFunStruct pftijahSerializeFun = {
    "pftijah",
    pftijah_init,
    null_cleanup,

    null_startSerialize,
    null_endSerialize,

    pftijah_handle_startDocument,
    null_handle_endDocument,
    pftijah_handle_startElement,
    pftijah_handle_endElement,
    pftijah_handle_characters,
    pftijah_handle_ignorableWhitespace,
    null_handle_comment,
    null_handle_processingInstruction,

    null_complete_startElement,
    pftijah_complete_startElementEmpty,
    pftijah_handle_attribute,

    null_seqEmitBool,
    null_seqEmitInt,
    null_seqEmitDbl,
    null_seqEmitStr,
    null_handle_attribute,
    null_handle_characters,

    null_seqStart,
    null_complete_seqStart,
    null_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    null_seqItemSeparator
};

/*
 *
 *
 */

static int
MAINtj_throw2collection(int justIndex, BAT* tjCtx_BAT, BAT* ws, str docName, str selTagList) {
	tjCtx* tjctx;

#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[{}]:START: CMDtj_throw2collection(%s)\n",docName);
#endif
	if ( !(tjctx = loadTijahContext(tjCtx_BAT, selTagList)) )
		return GDK_FAIL;
	/* return the main plane, the caller should check if the main plane
	 * has changed and this one should be added.
	 */ 
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:LOADED CONTEXT\n",tjctx->name);
#endif
	if ( tijahDocIndex(tjctx,docName) != oid_nil ) {
	    stream_printf(GDKerr,"CMDtj_throw2collection(CTX,%s) already in collection\n",docName);
	    return GDK_FAIL;
	}
	oid start_oid = tjctx->tijahPre;

	if ( !BUNappend(tjctx->b_docName, docName, 0) ||
	     !BUNappend(tjctx->b_docFirstPre, &start_oid, 0) )
	   stream_printf(GDKerr,"Error writing Tijah document record\n");;
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:START INDEXING\n",tjctx->name);
#endif

	GLOBAL_TJCTX = tjctx;
	if ( justIndex ) {
#ifdef TJ_TRACE
	    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CALL INDEXING SHREDDER\n",tjctx->name);
#endif
	    XqueryCtx xqctx;
	    /* StM:
	     * changed the original `EXTshred_and_index_doc(docName, (str)"", &pftijahSerializeFun, &xqctx)` into this;
	     * it compiles and loads, but I have now idea, whether it does work;
	     * especially the last parameter (lock *collLock) should most probably not be NULL
	     * (atleast if we desire any consistent concurrency) ...
	     */
	    if ( shred(BATnew(TYPE_str,TYPE_bat,30), docName, NULL, NULL, 0, &pftijahSerializeFun, &xqctx, NULL) == GDK_FAIL)
	    	 return GDK_FAIL;
	} else {
#ifdef TJ_TRACE
	    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CALL INDEXING SERIALIZER\n",tjctx->name);
#endif
	    if ( xquery_print_doc_DRIVER("",&pftijahSerializeFun,NULL,ws,docName) == GDK_FAIL)
	        return GDK_FAIL;
	}
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:FINISH INDEXING\n",tjctx->name);
#endif

        /* feature not used anymore ????? */
	if ( 0 /* ROEL CHANGE VIRTUAL ROOT SIZE HERE */ )
	        insertPreSize(tjctx,0,tjctx->tijahPre - 1);
	if ( dbat_finalize(&tjctx->dbat_collPre) < 0 )
		return GDK_FAIL;
	if ( dbat_finalize(&tjctx->dbat_collSize) < 0 )
		return GDK_FAIL;
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:FINALIZED DIRECT BATS\n",tjctx->name);
#endif
	/* finally do the maximum doc height administration */
	if ( 0 && !handle_doc_height(tjctx) )
	    return GDK_FAIL;
	/* read elapsed time */
#ifdef TJ_TRACE
	if ( TJ_TRACE ) {
		stream_printf(GDKout,"C[%s]:SIZES\n",tjctx->name);
		stream_printf(GDKout,"C[%s]:size( b_globalTerm ) = %d\n",tjctx->name, BATcount(tjctx->b_globalTerm));
		stream_printf(GDKout,"C[%s]:size( b_globalTag )  = %d\n",tjctx->name, BATcount(tjctx->b_globalTag));
		stream_printf(GDKout,"C[%s]:size( b_collPre )    = %d\n",tjctx->name, BATcount(tjctx->b_collPre));
		stream_printf(GDKout,"C[%s]:size( b_collSize )   = %d\n",tjctx->name, BATcount(tjctx->b_collSize));
		stream_printf(GDKout,"C[%s]:size( b_collPfPre )  = %d\n",tjctx->name, BATcount(tjctx->b_collPfPre));

	}
#endif
	return freeTijahContext(tjctx);
}

int
CMDtj_throw2collection(BAT* tjCtx_BAT, BAT* ws, str docName, str selTagList) {
    return  MAINtj_throw2collection(0,tjCtx_BAT,ws,docName,selTagList);
}

int
CMDtj_throw2collection_index(BAT* tjCtx_BAT, str locName) {
    return  MAINtj_throw2collection(1,tjCtx_BAT,NULL,locName,"");
}

/* vim:set shiftwidth=4 expandtab: */
