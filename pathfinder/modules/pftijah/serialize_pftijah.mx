@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the PfTijah Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html
@' 
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@' 
@' The Original Code is the PfTijah system.
@' 
@' The Initial Developer of the Original Code is the "University of Twente".
@' Portions created by the "University of Twente" are 
@' Copyright (C) 2006-2007 "University of Twente".
@' All Rights Reserved.
@'

@f serialize_pftijah
@a Jan Flokstra
@a Henning Rode
@t serialize_pftijah

@h
struct tijahContextStruct;

extern int handleTijahTerm(struct tijahContextStruct *ctx, char* term);

extern int tokenize_flex(char* buf, struct tijahContextStruct* tjCtx);
extern int tokenize_fast(char* buf, struct tijahContextStruct* tjCtx);

extern char* flexScanOneTerm(char* buf);

extern char* normalizeTerm(struct tijahContextStruct *ctx, char* term );

extern int CMDtj_normalizeTerm(char** res, char *term, char *stemmer);

@c
#include <pf_config.h>

/* #define TJ_TRACE 1 */

/*******************************************
 * serialize_pftijah.c : XML serialization
 *
 */

#include "stream.h"
#include "pf_support.h"
#include "serialize.h"
/* contains dummy callback functions */
#include "serialize_null.h"

#include "serialize_pftijah.h"
#include <gdk.h>

#include "pftijah_stem.h"

#include "pftijah_util.h"

#include "termdb.h"

#include "shredder.h"

/************************************************
 *
 * The fast direct BAT interface
 */

typedef struct dbat_struct {
	const char*	name;
	BAT*		bat;
	oid		raw_max;
	oid		seqbase;
	oid		seq_max;
        union { /* cast to perform direct indexe insert in [void,any] BATs */
            void* voidCAST; /* the basecast */
            chr*  chrCAST;  /* cast for [void,chr] BAT */
            int*  intCAST;  /* cast for [void,int] BAT */
            oid*  oidCAST;  /* cast for [void,oid] BAT */
        } cast;
} dbat;

int dbat_init(const char* name, dbat* dbat, BAT* b) {
	dbat->name = name;
	dbat->bat  = b;
	if ( dbat->bat->htype != TYPE_void ) {
	    stream_printf(GDKerr,"ERROR: dbat_init(%s) non void BAT\n",dbat->name);
	    return 0;
	}
	if ( !((dbat->bat->ttype == TYPE_oid) || (dbat->bat->ttype == TYPE_int)) ) {
	    stream_printf(GDKerr,"ERROR: dbat_init(%s) unknown ttype(%d)\n",dbat->name,dbat->bat->ttype);
	    return 0;
	}
        dbat->seqbase = (oid)b->hseqbase;
	dbat->raw_max = (oid)BATcount(dbat->bat);
	dbat->seq_max = dbat->raw_max + dbat->seqbase;
        dbat->cast.voidCAST = (void*)Tloc(dbat->bat,BUNfirst(dbat->bat));
	/* */
	return 1;
}


int dbat_finalize(dbat* dbat, int topidx) {
        void* top;
        BAT* b = dbat->bat;
        
	topidx -= (int)dbat->seqbase;
        int bottomTop = topidx;
        switch( b->ttype ) {
         case TYPE_int :
                top = &dbat->cast.intCAST[bottomTop];
                break;
         case TYPE_oid:
                top = &dbat->cast.oidCAST[bottomTop];
                break;
         default:
                GDKerror("dbat_finalize: bad ttype\n");
                return -1;
        }
        BATsetcount(b, (((char*)top)-b->T->heap.base)/Tsize(b) - BUNfirst(b));
        b->tsorted  = 0;
	b->batDirty = TRUE; /* VERY important this one */
	/* */
	dbat->name  = NULL;
	dbat->bat   = NULL;
	dbat->raw_max = dbat->seqbase = 0;
	/* */
	return 1;
}

#define MINCHUNK 8192
#define MAXCHUNK 67108864

static void
dbat_setcount(dbat *dbat, oid n)
{
    BAT *b = dbat->bat;
    BATsetcount(b, n);
    if (b->ttype) {
        b->tsorted = 0;
        b->tdense = 0;
    }
}

static int
dbat_extend(dbat* dbat, oid min_i /*raw-index*/, size_t forced_size) {
    size_t newsize;
    
    dbat_setcount(dbat, dbat->raw_max);
    if ( forced_size ) {
       newsize = forced_size;
    } else {
       newsize = MAX(MIN(MAX(MINCHUNK,dbat->raw_max*2),(size_t)(dbat->raw_max+MAXCHUNK)),(size_t)min_i);
    }

    /* first check if the number of BUN's < INT_MAX. If this was the case
     * and the previous time INT_MAX was returned this means the BAT cannot
     * grow any longer.
     */
    if ( newsize > INT_MAX ) {
    	newsize = INT_MAX;

	if ( dbat->raw_max == INT_MAX ) {
        	GDKerror("dbat_extend: BATextend[\"%s\"](size>INT_MAX) fails\n","incomplete");
		return -1;
	}
    }
#if 1
    /* copied this form shredder.mx, keep it here ??? */
    if (newsize+newsize > (size_t) REMAP_PAGE_MAXSIZE) { /* try to use mmap() */
        BATmmap(dbat->bat, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP);
    }

#endif

#if 0
    stream_printf(GDKout,"dbat_extend[%s](%d -> %d)\n",dbat->name,dbat->raw_max,newsize);
#endif

    dbat->raw_max = newsize;
    dbat->seq_max = dbat->raw_max + dbat->seqbase;
    if ( !(dbat->bat = BATextend(dbat->bat,newsize)) ) {
        GDKerror("dbat_extend: BATextend[\"%s\"](to %d) fails\n","incomplete",newsize);
        return -1;
    }
    dbat->cast.voidCAST = (void*)Tloc(dbat->bat,BUNfirst(dbat->bat));
    return 1;
}

#if 0
static int
dbat_sizeHint(dbat* dbat, int sizeHint_mark) {
        int sizeHint = sizeHint_mark - dbat->seqbase;
	int estimate = dbat->raw_max + sizeHint;

	return dbat_extend(dbat, estimate, 0);
}
#endif

#define dbat_set_oid(DBAT,I,V) (DBAT)->cast.oidCAST[I-(DBAT)->seqbase] = V

#define dbat_set_int(DBAT,I,V) (DBAT)->cast.intCAST[I-(DBAT)->seqbase] = V

#if 0
static void
dbat_int_debug(char* t, dbat* dbat) {
	stream_printf(GDKout,"+ DEBUGGING INT DBAT[sz=%d]@=[%s]:\n",dbat->seq_max,t);
	for(int i=0; i<10; i++) {
	     stream_printf(GDKout,"+ dbat[%d] = %d\n",i,dbat->cast.intCAST[i]);
	}
}
#endif

/************************************************
 *
 * The Tijah-Pathfinder index creation context
 */

typedef struct tijahContextStruct {
	char* name;		/* name of the collection */
	oid  n_globalTerm;
	BAT* b_globalTerm;	/* global term dictionary*/
	BAT* hm_globalTerm;	/* hashed mirrorred global term dictionary*/
#ifdef USE_TERMDB
	termDbCtx* tdb;
#endif
	oid  n_globalTag;
	BAT* b_globalTag;	/* global tag dictionary*/
	BAT* hm_globalTag;	/* hashed mirrorred global tag dictionary*/

	int   tagswitch_sz;	/* the size of the next buff */
	char* tagswitch;	/* the recursive tag detector switch */
				/* 0 means: tag is not in use */
				/* 1 means: tag is in use */
				/* 2 means: tag is recursive */
	BAT* b_globalRTag;	/* recursive tag dictionary*/

	BAT* b_docName;		/* BAT to store docnames in collection */
	BAT* b_docFirstPre;	/* First tijah-pre-nr of document */
	BAT* b_collParam;	/* Collection Parameters BAT */
	/* */
	unsigned int  fragmentSize;	/* maximum frament size, new frag if larger */
	oid  tijahPre;		/* Current max tijahpre number */
	/* INCOMPLETE< SHOULD BE FRAGMENTED */
	BAT* b_collPre;		/* Main tijah pre BAT */
	dbat dbat_collPre;	/* Direct access struct for b_collPre */
	/* INCOMPLETE< SHOULD BE FRAGMENTED */
	BAT* b_collSize;	/* Tijah PRE-size BAT */
	dbat dbat_collSize;	/* Direct access struct for b_collSize */
	/* */
	BAT* b_collPfPre;	/* Tijah PRE-PF BAT for Pathinder link */
	/*
	 */
	int		doc_height;
	int		max_doc_height;
	/* The BAT's for the tag selection and associated counters
	 */
	BAT* b_filtering;	/* [void,str] BAT containing select tags */
	int  filterDepth;	/* */
	int  whitelisting;	/* bool, if not: blacklisting */
	int  emitting;		/* boolean indicating emit */
	/* The tagStartStack[] contains the starting Tijah oid of an element
	 * and is used to compute the size of an element in the Tijah
	 * pre-post-plane.
	 */
	oid  tagStartStack[MAXTAGDEPTH];
	int  tagOidStack[MAXTAGDEPTH];
	int  tagStackPtr;
	/* */
	int preExpansion;	/* estimation for #TijahPre/PfPre */
	int tokenize_fast;	/* boolean to indicate fast tokenizer */
	char* stemmer;	/* name of the stemmer used for this collection */
	tjStemCtx* stemCtx;
	char	checkStopWords;
	oid	lastStopWord;
} tjCtx;

#define DOEMIT(TJCTX)	((TJCTX)->emitting)

static INLINE int
tj_pushTag(tjCtx* tjctx, oid start, oid tagoid) {
	if ( tjctx->tagStackPtr > MAXTAGDEPTH ) {
	     GDKerror("tj_pushTag: MAXTAGDEPTH exceeded.\n");
	     return -1;
	}
	if ( tjctx->tagswitch[(int)tagoid] != 2 ) {
	    tjctx->tagswitch[(int)tagoid]++;
	}
	tjctx->tagOidStack[tjctx->tagStackPtr] = (int)tagoid;
	tjctx->tagStartStack[tjctx->tagStackPtr++] = start;
	return 1;
}

INLINE static oid
tj_popTag(tjCtx* tjctx) {
	--tjctx->tagStackPtr;
	if ( tjctx->tagswitch[tjctx->tagOidStack[tjctx->tagStackPtr]] != 2 ) {
	    tjctx->tagswitch[tjctx->tagOidStack[tjctx->tagStackPtr]]--;
	}
	return tjctx->tagStartStack[tjctx->tagStackPtr];
}

/************************************************
 *
 */

INLINE static oid
tj_tagOid(tjCtx* tjctx, str t) {
#ifdef USE_TERMDB
    /* incomplete, also tag check here */
    return tdb_lookupTag(tjctx->tdb,t);
#else
    BUN bun;

    // stream_printf(GDKout,"tj_tagOid(\"%s\"): start\n",t);
    BATiter bi = bat_iterator(tjctx->hm_globalTag);
    HASHfnd_str(bun, bi, (str)t);
    if ( bun != BUN_NONE ) {
        // stream_printf(GDKout,"tj_tagOid(\"%s\"): bun found @ %d\n",t,bun);
        return (oid)bun;
        // return *(oid*)BUNtail(tjctx->hm_globalTag,bun);
    } else {
        // stream_printf(GDKout,"tj_tagOid(\"%s\"): bun not found\n",t);
    	// if ( BUNins(tjctx->b_globalTag, &tjctx->n_globalTag, (str)t, FALSE) ) {
    	if ( BUNappend(tjctx->b_globalTag, (str)t, FALSE) ) {
	    /* check if the recursive tagswitcher still is large enough */
    	    if ( (int)tjctx->n_globalTag >= tjctx->tagswitch_sz ) {
                int old = tjctx->tagswitch_sz;
		tjctx->tagswitch_sz = 2*(int)tjctx->n_globalTag;
		tjctx->tagswitch    = GDKrealloc(tjctx->tagswitch,tjctx->tagswitch_sz );
		for(int i=old; i<tjctx->tagswitch_sz; i++)
	            tjctx->tagswitch[i] = 0;
            }
    	    return tjctx->n_globalTag++;
        } else {
            stream_printf(GDKout,"tj_tagOid(\"%s\"): insert error\n",t);
    	    GDKerror("INSERT OF \"%s\" in globalTag fails.\n");
    	    return oid_nil;
        }
    }
#endif
}

INLINE static oid
tj_checkTerm(tjCtx* tjctx, char *t) {
#ifdef USE_TERMDB
   INCOMPLETE
#endif
   BUN bun;

   BATiter bi = bat_iterator(tjctx->hm_globalTerm);
   HASHfnd_str(bun, bi, (str)t);
   // return ( (bun != BUN_NONE) ? *(oid*)BUNtail(tjctx->hm_globalTerm,bun) : oid_nil );
   oid res = ( (bun != BUN_NONE) ? (oid)bun : oid_nil );
   return (res < tjctx->lastStopWord) ? 0 : res;
}

INLINE static oid
tj_termOid(tjCtx* tjctx, char *t) {
#ifdef USE_TERMDB
    return tdb_lookupTerm(tjctx->tdb,t);
#else
    BUN bun;

    BATiter bi = bat_iterator(tjctx->hm_globalTerm);
    HASHfnd_str(bun, bi, (str)t);
    if ( bun != BUN_NONE ) {
        oid res = (oid)bun;

	if ( 0 && res < tjctx->lastStopWord ) stream_printf(GDKout,"SKIP STOPWORD[\"%s\"]\n",t);
	return (res < tjctx->lastStopWord) ? 0 : res;
    } else {
    	// if ( BUNins(tjctx->b_globalTerm, &tjctx->n_globalTerm, (str)t, FALSE)){
    	if ( BUNappend(tjctx->b_globalTerm, (str)t, FALSE)){
	    if (0) stream_printf(GDKout,"N-WORD[\"%s\"]=%d@0\n",t,tjctx->n_globalTerm);
    	    return tjctx->n_globalTerm++;
        } else { 
    	    GDKerror("INSERT OF \"%s\" in globalTerm fails.\n");
    	    return oid_nil;
        }
    }
#endif
}

INLINE static oid
tj_extend_plane(struct tijahContextStruct *tjctx) {
    oid base = tjctx->tijahPre - tjctx->dbat_collPre.seqbase; 

    if ( base >= tjctx->dbat_collPre.raw_max ) {
	if ( dbat_extend(&tjctx->dbat_collPre,base, 0) < 0 )
	    return oid_nil;
	/* IMPORTANT: the size of the two bats is synchronized by the use
	 * of the forced size (last) parameter of dbat_extend
	 */
	if ( dbat_extend(&tjctx->dbat_collSize,base,tjctx->dbat_collPre.raw_max) < 0 )
	    return oid_nil;
    }
    return tjctx->tijahPre++;
}

#define tj_newPre(TJCTX) \
	(((TJCTX)->tijahPre < (TJCTX)->dbat_collPre.seq_max) \
	? \
	((oid)(TJCTX)->tijahPre++) : tj_extend_plane(TJCTX))

int
handleTijahTerm(struct tijahContextStruct *tjctx, char* term) {
    oid termOid, tjPre;

    if ( DOEMIT(tjctx) ) {
        if ( (termOid = tj_checkTerm(tjctx, term)) == oid_nil ) {
          if ( tjctx->stemCtx->stem) {
    	    if ( !(term = (char*)tjctx->stemCtx->stem(tjctx->stemCtx,(char*)term)) ) {
	        /* must be a stopword */
	        return 1;
	    }
          }
          if ( (termOid = tj_termOid(tjctx, term)) == oid_nil )
    	    return -1;
	}
	if ( termOid ) { /* term is not a stopword */
            if ( (tjPre = tj_newPre(tjctx) ) == oid_nil )
    	        return 0;
            dbat_set_oid(&tjctx->dbat_collPre, tjPre, termOid);
            dbat_set_int(&tjctx->dbat_collSize,tjPre,0);
#ifdef TJ_TRACE
            if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:TERM: \"%s\", termoid=%d, tjPre=%d\n",tjctx->name,term,termOid,tjPre);
#endif
         } else {
#ifdef TJ_TRACE
            if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:STOPWORD: \"%s\"\n",tjctx->name,term);
#endif
	 }
     }
     return 1;
}

/************************************************
 *
 * Now the real output handlers
 */


#if 0
static int
handle_sizeHint(XqueryCtx* ctx, int hinted_size) {
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

    int estimate = hinted_size * tjctx->preExpansion;

    if ( dbat_sizeHint(&tjctx->dbat_collPre,estimate) < 0 )
    	return 0;
    if ( dbat_sizeHint(&tjctx->dbat_collSize,estimate) < 0 )
    	return 0;
    return 1;
}
#endif

const char* delchars2 = " \t\n\r,";

static int init_tagFiltering(tjCtx* tjctx, char* kind, char *l) {
    char *t;
    int  cnt=0;

    (void)kind;

    /* determine kind of filtering */
    if ( strcmp(kind,"whitelist")==0 )
    	tjctx->whitelisting = 1;
    else 
        tjctx->whitelisting = 0;

    /* read the tags */
    if ( (t = strtok(l,delchars2)) ) do {
	/* not the empty string here */
	if ( cnt++ == 0 ) {
	    tjctx->b_filtering = BATmirror(BAThash(BATmirror(
	     		BATnew(TYPE_void, TYPE_str,32)),0));
	    if ( !tjctx->b_filtering ) {
	    	return 0;
	    }
	}
	str v = (str)t;
	oid my_oid_nil = oid_nil;
	if ( !BUNins(tjctx->b_filtering, &my_oid_nil, v, FALSE) )
	     return 0;
    } while ( (t=strtok(NULL,delchars2)) );

    /* set runtime status variables */
    tjctx->filterDepth = 0;
    tjctx->emitting    = !(tjctx->whitelisting);

    return 1;
}

/* 
 * Read the value of a collection parameter from the collection parameter bat
 */
static str readCollParam(tjCtx* tjctx, str param) {
	BUN bun;
        bun = BUNfnd(tjctx->b_collParam,param);
	if ( bun != BUN_NONE ) {
            BATiter bi = bat_iterator(tjctx->b_collParam);
	    return (str)BUNtail(bi,bun);
	} else
	    return (str)str_nil;
}

/* 
 * Replace the value of a collection parameter int the collection parameter
 * bat
 */
static int replaceCollParam(tjCtx* tjctx, str param, str val) {
	return ( BUNreplace(tjctx->b_collParam,param,val,FALSE) != NULL );
}

static BAT*
getBAT(BAT* batbat, str bname) {
	BUN bun;
	if ( (bun=BUNfnd(batbat,bname)) == BUN_NONE ) {
	    stream_printf(GDKerr,"getBAT:BUNfnd(%s) failed.\n",bname);
	    return NULL;
	}
        BATiter batbati = bat_iterator(batbat);
	BAT* res = BATdescriptor( *(bat*)BUNtail(batbati,bun));
	if ( !res )
	    stream_printf(GDKerr,"getBAT:BATdescriptor() for %s failed.\n",bname);
	return res;
}

static const char* stopwordMarker = "#STOPWORD#";

static oid getPreSize(tjCtx* tjCtx) {
	str str_tijahPre = readCollParam(tjCtx,"_last_tijahPre");
	oid par_tijahPre;
	if ( str_tijahPre != str_nil ) {
		par_tijahPre = (oid)atol(str_tijahPre);
        } else {
		par_tijahPre = 1;
	}
	if ( 0 /* CHECK */ ) {
            oid chk = (oid)BATcount(tjCtx->b_collPre) + 1; 
	    if ( par_tijahPre != chk ) {
		stream_printf(GDKerr,"ERROR: getPreSize: oid out of sync: %d <-> %d.\n",par_tijahPre,chk);
	        return oid_nil;
	    }
	}
	return par_tijahPre;
}

static int setPreSize(tjCtx* tjCtx, oid newSize) {
	char buff[16];

	sprintf(buff,OIDFMT,newSize);
	if ( !replaceCollParam(tjCtx, "_last_tijahPre", (str)buff) )
	    return 0;
	return 1;
} 

static tjCtx*
loadTijahContext(BAT* tjCtx_BAT) {
	tjCtx* res;

#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[]: start loadTijahContext\n");
#endif
	if ( !(res = (tjCtx*)malloc( sizeof(tjCtx) )) )
		return NULL;
	/*
	 * Set first settings
	 */

	/* set parameter bat first */
	if ( !(res->b_collParam   = getBAT(tjCtx_BAT,"_param")) ) return NULL;

	res->preExpansion = 1;
	str str_preExpansion = readCollParam(res,"preExpansion");
	if ( str_preExpansion != str_nil ) {
		int v = atoi(str_preExpansion);

		if ( v < 1 ) {
		} else
			res->preExpansion = v;
	}
	/* */
	res->fragmentSize = 0;
	str str_fragmentSize = readCollParam(res,"fragmentSize");
	if ( str_fragmentSize != str_nil ) {
		int v = atoi(str_fragmentSize);

		if ( v < 1 ) {
		} else
			res->fragmentSize = v;
	}
	/* */
	str str_name = readCollParam(res,"name");
	res->name = (char*)str_name;

	res->tokenize_fast = 0;
	str str_tokenizer = readCollParam(res,"tokenizer");
	if ( strcmp(str_tokenizer,"fast") == 0 )
		res->tokenize_fast = 1;

	/* */
        res->checkStopWords = 1;
	str str_stopw = readCollParam(res,"stopwords");
	if ( str_stopw ) {
	    if (  (strcmp(str_stopw,"false") == 0) || (strcmp(str_stopw,"off")==0) )
	        res->checkStopWords = 0;
	}
	res->lastStopWord   = 0;
	str str_laststopw = readCollParam(res,"lastStopWord");
	if ( str_laststopw != str_nil ) {
		long v = atol(str_laststopw);

		if ( v < 1 ) {
		} else
			res->lastStopWord = (oid)v;
	}
	str str_stemmer = readCollParam(res,"stemmer");

	if ( str_stemmer != str_nil ) 
		res->stemmer = strdup((char*)str_stemmer);
	else
		res->stemmer = NULL;
	if ( !(res->stemCtx = getStemmingContext(res->stemmer)) )
		return NULL;
	if ( res->stemCtx->init && !res->stemCtx->init(res->stemCtx,NULL) )
			return NULL;

	res->emitting     = 1;
        res->b_filtering  = NULL;

	str wl = readCollParam(res,"whitelist");
	str bl = readCollParam(res,"blacklist");
	if ( wl != str_nil || bl != str_nil ) {
	    if ( wl != str_nil ) {
	    	if ( bl != str_nil ) {
		    GDKerror("Unable to mix whitelist/blacklist tag filters");
		    return NULL;
		}
		if ( !init_tagFiltering(res,"whitelist",wl) )
			return NULL;
	    } else {
		if ( !init_tagFiltering(res,"blacklist",bl) )
			return NULL;
	    }
	}

#ifdef TJ_TRACE
	if ( TJ_TRACE ) {
	   stream_printf(GDKout,"C[%s]: loadTijahContext() options read\n",res->name);
	   if ( res->fragmentSize )
	       stream_printf(GDKout,"C[%s]: loadTijahContext() fragmentSize = %d\n",res->name, res->fragmentSize);
        }
#endif
	/*
	 * The section where the parameter bats are read
	 */
#ifdef USE_TERMDB
	if ( !(res->tdb = tdb_open("termDB")) )
	    return NULL;
#endif
	if ( !(res->b_globalTerm  = getBAT(tjCtx_BAT,"_globalTerms")) ) return NULL;
	res->n_globalTerm = (oid)BATcount(res->b_globalTerm);
	if ( !(res->b_globalTag   = getBAT(tjCtx_BAT,"_globalTags")) ) return NULL;
	res->n_globalTag = (oid)BATcount(res->b_globalTag);
	if ( !(res->b_globalRTag   = getBAT(tjCtx_BAT,"_globalRTags")) ) return NULL;
	res->tagswitch_sz = (int)res->n_globalTag;
	if ( res->tagswitch_sz < 128 )
		res->tagswitch_sz = 128;
	res->tagswitch_sz *= 2;
	res->tagswitch = GDKmalloc( res->tagswitch_sz );
	for(int i=0; i<res->tagswitch_sz; i++)
	    res->tagswitch[i] = 0;
	/*
	 *
	 */
	if ( !(res->b_docName     = getBAT(tjCtx_BAT,"_doc_name")) ) return NULL;
	if ( !(res->b_docFirstPre = getBAT(tjCtx_BAT,"_doc_firstpre")) ) return NULL;
	if ( !(res->b_collPre     = getBAT(tjCtx_BAT,"_tid")) ) return NULL;
	if ( !(res->b_collSize    = getBAT(tjCtx_BAT,"_size")) ) return NULL;
	if ( (res->tijahPre = getPreSize(res)) == oid_nil )
	     return NULL;;
	/* check here for new fragmentation */
	if ( res->fragmentSize ) {
	    if ( (BATcount(res->b_collPre) > res->fragmentSize) ) {
#ifdef TJ_TRACE
	        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]: loadTijahContext() [b_collPre|b_collSize] too big(%d), create new fragment\n",res->name,BATcount(res->b_collPre));
#endif
		BAT* fragments;
	        if ( !(fragments = getBAT(tjCtx_BAT,"_fragments")) )
		    return NULL;
	        int newFragments  = (int)BATcount(fragments) + 1;
		/* */
		BBPunfix(BBPcacheid(res->b_collPre));
		res->b_collPre     = pftu_create_bat(pftu_batname1("tj_%s_tid%d",res->name,newFragments),TYPE_void,TYPE_oid,1);
		if ( !res->b_collPre ) 
		    return NULL;
		BBPfix(BBPcacheid(res->b_collPre));
	        BATseqbase(res->b_collPre,res->tijahPre);
		BBPunfix(BBPcacheid(res->b_collSize));
	        res->b_collSize    = pftu_create_bat(pftu_batname1("tj_%s_size%d",res->name,newFragments),TYPE_void,TYPE_int,1);
		if ( !res->b_collSize )
		    return NULL;
		BBPfix(BBPcacheid(res->b_collSize));
	        BATseqbase(res->b_collSize,res->tijahPre);
		if ( !BUNappend(fragments,&res->tijahPre,0) )
		    return NULL;
		BBPunfix(BBPcacheid(fragments));
		/* */
		str pretag = "_tid";
		bat prebat = BBPcacheid(res->b_collPre);
		if ( !BUNreplace(tjCtx_BAT,pretag,&prebat,0) ) { return NULL; }
		str sizetag = "_size";
		bat sizebat = BBPcacheid(res->b_collSize);
		if ( !BUNreplace(tjCtx_BAT,sizetag,&sizebat,0) ) { return NULL; }
#ifdef TJ_TRACE
	        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]: loadTijahContext() finished creating new fragments\n",res->name);
#endif
	    }
	}
	if ( dbat_init("b_collPre", &res->dbat_collPre, res->b_collPre) < -1 )
		return NULL;
	if ( dbat_init("b_collSize", &res->dbat_collSize, res->b_collSize) < -1 )
		return NULL;
	if ( !(res->b_collPfPre   = getBAT(tjCtx_BAT,"_pfpre")) ) return NULL;
	/* */
	res->tagStackPtr = 0;

#ifdef USE_TERMDB
	if ( tdb_isEmpty(res->tdb) ) {
	     if ( tdb_lookupTerm(res->tdb,(char*)stopwordMarker) == oid_nil )
	     	     return NULL;
	}
#endif
	/*
	 * Finally ensure there are accellerators on the Term and Tag dictionaries
	 */
	res->hm_globalTerm = BATmirror(res->b_globalTerm);

	if ( res->n_globalTerm == 0 ) {
	     // if ( !BUNins(res->b_globalTerm, &zero, (str)stopwordMarker, FALSE)){
	     
	     if ( !BUNappend(res->b_globalTerm, (str)stopwordMarker, FALSE)){
	             return NULL;
	     }
	     res->n_globalTerm++;

#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:INSERTED STOPWORDMARKER IN GLOBALTERM\n",res->name);
#endif
	     if ( res->checkStopWords ) {
		 for(int i=0; res->stemCtx->stopWords[i]; i++) {
		     str sw = (str)res->stemCtx->stopWords[i];
#ifdef USE_TERMDB
	             if ( !tdb_insertTerm(res->tdb,(char*)sw, zero, 0) ) {
		         return NULL;
		     }
#endif
	             // if ( !BUNins(res->b_globalTerm, &zero, sw, FALSE)){
	             if ( !BUNappend(res->b_globalTerm, sw, FALSE)){
                         GDKerror("loadTijahContext: inserting stopword fails\n");
	                 return NULL;
	             }
	             res->n_globalTerm++;
#ifdef TJ_TRACE
	             if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:ADDED STOPWORD \"%s\" to GLOBALTERM\n",res->name,sw);
#endif
		     }
		 res->lastStopWord = res->n_globalTerm; 
	         char buff[8];

	         sprintf(&buff[0],OIDFMT,res->lastStopWord);
	         if ( ! replaceCollParam(res,"lastStopWord",(str)&buff[0]))
	             return 0;
	     }
	}
	if ( res->b_globalTerm->T->hash == NULL ) {
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CREATE NEW HASHTABLE ON GLOBALTERM\n",res->name);
#endif
	     if ( !BAThash(BATmirror(res->b_globalTerm),0) ) {
                 GDKerror("loadTijahContext: adding hashtable to globalTerm fails\n");
	         return NULL;
	     }
	}
	res->hm_globalTag = BATmirror(res->b_globalTag);
	if ( res->b_globalTag->T->hash == NULL ) {
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CREATE NEW HASHTABLE ON GLOBALTAG\n",res->name);
#endif
	     if ( !BAThash(BATmirror(res->b_globalTag),0) ) {
                 GDKerror("loadTijahContext: adding hashtable to globalTag fails\n");
	         return NULL;
	     }
	}

	if ( ! (res->hm_globalTerm->H->hash && res->hm_globalTag->H->hash) )
	   stream_printf(GDKout,"# WARNING: MISSING HASH ON TAG/TERM DICTIONARY\n");
	return res;
}

static int
freeTijahContext(tjCtx* tjctx) {
        if ( !setPreSize(tjctx,tjctx->tijahPre) )
	        return GDK_FAIL;
	/* first store all new detected recursive tag oids */
	for(int i=0; i<tjctx->tagswitch_sz; i++) {
	    if ( tjctx->tagswitch[i] == 2) {
		oid store = (oid)i;
		if ( BUNfnd(tjctx->b_globalRTag,&store) == BUN_NONE ) {
		    if ( !BUNins(tjctx->b_globalRTag, &store,&store, 0)) {
	    	        GDKerror("error writing recursive tagbat");
		        return GDK_FAIL;
		    }
		}
            }
        }
#ifdef USE_TERMDB
	if ( ! tdb_close(tjctx->tdb) )
		return GDK_FAIL;
#endif
	/* BATkey(BATmirror(tjctx->b_globalTerm), TRUE); */
	/* BATkey(BATmirror(tjctx->b_globalTag), TRUE); */
	BATkey(BATmirror(tjctx->b_collPre), FALSE);
	BATkey(BATmirror(tjctx->b_collSize), FALSE);
	PROPDEBUG {
		BATpropcheck(tjctx->b_globalTerm,BATPROPS_ALL);
		BATpropcheck(tjctx->b_globalTag,BATPROPS_ALL);
		BATpropcheck(tjctx->b_docName,BATPROPS_ALL);
		BATpropcheck(tjctx->b_docFirstPre,BATPROPS_ALL);
		BATpropcheck(tjctx->b_collParam,BATPROPS_ALL);
		BATpropcheck(tjctx->b_collPre,BATPROPS_ALL);
		BATpropcheck(tjctx->b_collSize,BATPROPS_ALL);
		BATpropcheck(tjctx->b_collPfPre,BATPROPS_ALL);
	}
	BBPunfix(BBPcacheid(tjctx->b_globalTerm));
	BBPunfix(BBPcacheid(tjctx->b_globalTag));
	BBPunfix(BBPcacheid(tjctx->b_globalRTag));
	BBPunfix(BBPcacheid(tjctx->b_docName));
	BBPunfix(BBPcacheid(tjctx->b_docFirstPre));
	BBPunfix(BBPcacheid(tjctx->b_collParam));
	BBPunfix(BBPcacheid(tjctx->b_collPre));
	BBPunfix(BBPcacheid(tjctx->b_collSize));
	BBPunfix(BBPcacheid(tjctx->b_collPfPre));
	GDKfree(tjctx->tagswitch);
	if ( tjctx->stemCtx->clear && !tjctx->stemCtx->clear(tjctx->stemCtx) )
		return GDK_FAIL;
	free(tjctx);
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[{}]:FINISH: add2collection_handler()\n");
#endif
	return GDK_SUCCEED;
}

static int
handle_doc_height(tjCtx* tjctx) {
	str oldval = readCollParam(tjctx,"height");

	if ( oldval == str_nil)
	    return 0;
	if ( tjctx->max_doc_height > atoi( (char*)oldval) ) {
	   char buff[8];

	   sprintf(&buff[0],"%d",tjctx->max_doc_height);
	   if ( ! replaceCollParam(tjctx,"height",(str)&buff[0]))
	       return 0;
	}
	if ( 1 ) stream_printf(GDKout,"# **** SET MAX DOC HEIGHT TO: %d\n",tjctx->max_doc_height);
	return 1;
}

static oid
tijahDocIndex(tjCtx* ctx, str docName) {
        BAT* mb = BATmirror(ctx->b_docName);

        BUN bun;
        bun = BUNfnd(mb,docName);
        if ( bun != BUN_NONE ) {
               BATiter mbi = bat_iterator(mb);
               return *(oid*)BUNtail(mbi,bun);
        }
	return oid_nil;
}

/*
 *
 *
 *
 */

static tjCtx* GLOBAL_TJCTX; /* INCOMPLETE, CODE NOT REENTRANT */

/**
 * Default driver initialization function
 */
static bool
pftijah_init(XqueryCtx* ctx, char* args, char* restag, char* resprefix, char* module, char* method) {
    (void) ctx;
    (void) args;
    (void) restag;
    (void) resprefix;
    (void) module;
    (void) method;

    ctx->driverWs = GLOBAL_TJCTX;
#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:pftijah_init()\n",GLOBAL_TJCTX->name);
#endif
    return 1;
}

#define HANDLE_DOC_ROOT

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static bool
pftijah_handle_startDocument(XqueryCtx* ctx, oid pre) {
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;


    tjctx->doc_height = tjctx->max_doc_height = 0;
#ifdef HANDLE_DOC_ROOT
    oid termOid, tjPre;

    if ( ++tjctx->doc_height > tjctx->max_doc_height )
        tjctx->max_doc_height = tjctx->doc_height;
    if ( (termOid = tj_tagOid(tjctx, "_DOCUMENT_ROOT")) == oid_nil )
        return 0;
    if ( (tjPre = tj_newPre(tjctx) ) == oid_nil )
        return 0;
    dbat_set_oid(&tjctx->dbat_collPre, tjPre, termOid);
    if ( tj_pushTag(tjctx,tjPre,termOid) < 0 ) return 0;
    if ( !BUNins(tjctx->b_collPfPre, &tjPre, &pre, FALSE) ) return 0;
#else
    (void)  pre;
#endif

#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:startDocument()\n",tjctx->name);
#endif
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static bool
pftijah_handle_endDocument(XqueryCtx* ctx) {
#ifdef HANDLE_DOC_ROOT
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

    --tjctx->doc_height;
    oid start = tj_popTag(tjctx); /* oid of the first node of the element */
    int size  = tjctx->tijahPre - start - 1; /* the Tijah document size */
    dbat_set_int(&tjctx->dbat_collSize,(int)start,size);
#else
    (void) ctx;
#endif

#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:endDocument()\n",tjctx->name);
#endif
    return 1;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static bool
pftijah_handle_attribute(XqueryCtx* ctx, str prefix, str loc, str value) {
    (void)ctx;
    (void)prefix;
    (void)loc;
    (void)value;
    return 1;
}

static int checkFilterTag(tjCtx* tjctx, str t) {
        BAT* mb = BATmirror(tjctx->b_filtering);

        BUN bun;
        bun = BUNfnd(mb,t);
        if ( bun != BUN_NONE ) {
	    /* hit a filter tag */
	    tjctx->emitting = tjctx->whitelisting;
	    tjctx->filterDepth = 1;
    	}
        return 1;
}

#define EMPTY_CHECK 

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static bool
pftijah_handle_startElement(XqueryCtx* ctx, str ns, str name, oid pre) {
    (void)ns;
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;
    oid termOid, tjPre;

    if ( ++tjctx->doc_height > tjctx->max_doc_height )
        tjctx->max_doc_height = tjctx->doc_height;

    if ( tjctx->b_filtering ) {
    	if ( tjctx->filterDepth )
    	    tjctx->filterDepth++;
	else
	    checkFilterTag(tjctx,name);
    }
    if ( DOEMIT(tjctx) ) {
        if ( (termOid = tj_tagOid(tjctx, name)) == oid_nil )
    	    return 0;
        if ( (tjPre = tj_newPre(tjctx) ) == oid_nil )
    	    return 0;
        dbat_set_oid(&tjctx->dbat_collPre, tjPre, termOid);
        if ( tj_pushTag(tjctx,tjPre,termOid) < 0 ) return 0;
#ifdef TJ_TRACE
        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:startElement: \"%s\", termoid=%d, Tijah pre#=%d, Pathfinder pre#=%d\n",tjctx->name,name,termOid,tjPre,pre);
#endif
        if ( !BUNins(tjctx->b_collPfPre, &tjPre, &pre, FALSE) ) return 0;
    }
    return 1;
}

static bool
pftijah_complete_startElementEmpty(XqueryCtx* ctx) {
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;
    --tjctx->doc_height;
    if ( DOEMIT(tjctx) ) {
        oid start = tj_popTag(tjctx); /* oid of the first node of the element */
        int size  = tjctx->tijahPre - start - 1; /* the Tijah element size */
        dbat_set_int(&tjctx->dbat_collSize,(int)start,size);
    };
#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:empty_endElement: \"%s\"\n", tjctx->name,"");
#endif
    if ( tjctx->b_filtering && tjctx->filterDepth ) {
        /* a filter is currently 'on' */
        if ( --tjctx->filterDepth == 0 ) {
		/* end of filter */
	        tjctx->emitting = !(tjctx->whitelisting);

	}
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static bool
pftijah_handle_endElement(XqueryCtx* ctx, str ns, str name) {
    (void)ns;
    (void)name;
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;
    --tjctx->doc_height;
    if ( DOEMIT(tjctx) ) {
        oid start = tj_popTag(tjctx); /* oid of the first node of the element */
        int size  = tjctx->tijahPre - start - 1; /* the Tijah element size */
	dbat_set_int(&tjctx->dbat_collSize,(int)start,size);
#ifdef TJ_TRACE
        if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:endElement: \"%s\"\n", tjctx->name,name);
#endif
    }
    if ( tjctx->b_filtering && tjctx->filterDepth ) {
        /* a filter is currently 'on' */
        if ( --tjctx->filterDepth == 0 ) {
		/* end of filter */
	        tjctx->emitting = !(tjctx->whitelisting);
	}
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static bool
pftijah_handle_characters(XqueryCtx* ctx, str ch) {
    EMPTY_CHECK;
    tjCtx* tjctx = (tjCtx*)ctx->driverWs;

    register char* p = (char*)ch;
    while( *p && isspace(*p) ) p++;
    if ( !*p )
        return 1;
#ifdef TJ_TRACE
    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:handle_characters(%s) start\n",tjctx->name, p);
#endif

    if ( DOEMIT(tjctx) ) {
	if ( tjctx->tokenize_fast)
            return tokenize_fast(p,tjctx);
	else
            return tokenize_flex(p,tjctx);
    }
    return 1;
}

char* normalizeTerm(struct tijahContextStruct *tjctx, char* term ) {
	char *res;
        res = flexScanOneTerm((char*)term);
        if ( res && tjctx && tjctx->stemCtx->stem) {
    	    if ( !(res = (char*)tjctx->stemCtx->stem(tjctx->stemCtx,(char*)res)) ) {
	        /* must be a stopword */
	        return NULL;
	    }
        }
	return res;
}

int CMDtj_normalizeTerm(char** res, char *term, char *stemmer) {
    tjStemCtx* stemCtx = getStemmingContext( stemmer );

    if ( stemCtx->stem ) {
        if ( !stemCtx->udf && stemCtx->init ) stemCtx->init( stemCtx, NULL );

        char* stemmed = (char *)stemCtx->stem( stemCtx, term );
        if ( !stemmed ) {
            *res = NULL;
        } else {
            //if (*res) GDKfree(*res);
            *res = GDKmalloc( strlen(stemmed)+1 );
	    if ( !res ) {
	        stream_printf(GDKout,"CMDtj_normalizeTerm: GDKmalloc() failed.\n");
		return GDK_FAIL;
	    }
            strcpy( *res, stemmed );
        }
        //if ( stemCtx->clear ) stemCtx->clear( stemCtx );
    } else {
        //if (*res) GDKfree(*res);
        *res = GDKmalloc( strlen(term)+1 );
	if ( !res ) {
	    stream_printf(GDKout,"CMDtj_normalizeTerm: GDKmalloc() failed.\n");
	    return GDK_FAIL;
	}
        strcpy( *res, term );
    }
    return GDK_SUCCEED;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static bool
pftijah_handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
    return pftijah_handle_characters(ctx,ch); /* dispatch */
}

/**
 *
 * Definition of the structure containing the functions
 */
struct serializeFunStruct pftijahSerializeFun = {
    "pftijah",
    pftijah_init,
    null_cleanup,

    null_startSerialize,
    null_endSerialize,

    pftijah_handle_startDocument,
    pftijah_handle_endDocument,
    pftijah_handle_startElement,
    pftijah_handle_endElement,
    pftijah_handle_characters,
    pftijah_handle_ignorableWhitespace,
    null_handle_comment,
    null_handle_processingInstruction,

    null_complete_startElement,
    pftijah_complete_startElementEmpty,
    pftijah_handle_attribute,

    null_seqEmitBool,
    null_seqEmitInt,
    null_seqEmitDbl,
    null_seqEmitStr,
    null_handle_attribute,
    null_handle_characters,

    null_seqStart,
    null_complete_seqStart,
    null_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    null_seqItemSeparator
};

/*
 *
 *
 */

static int
add2collection_handler(int justIndex, BAT* tjCtx_BAT, BAT* ws, str docName) {
	tjCtx* tjctx;

#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[{}]:START: add2collection_handler(%s)\n",docName);
#endif
	if ( !(tjctx = loadTijahContext(tjCtx_BAT)) )
		return GDK_FAIL;

	/* return the main plane, the caller should check if the main plane
	 * has changed and this one should be added.
	 */ 
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:LOADED CONTEXT\n",tjctx->name);
#endif
	if ( tijahDocIndex(tjctx,docName) != oid_nil ) {
	    stream_printf(GDKerr,"add2collection_handler(CTX,%s) already in collection\n",docName);
	    return GDK_FAIL;
	}
	oid start_oid = tjctx->tijahPre;

	if ( !BUNappend(tjctx->b_docName, docName, 0) ||
	     !BUNappend(tjctx->b_docFirstPre, &start_oid, 0) )
	   stream_printf(GDKerr,"Error writing Tijah document record\n");;
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:START INDEXING\n",tjctx->name);
#endif

	GLOBAL_TJCTX = tjctx;
	if ( justIndex ) {
#ifdef TJ_TRACE
	    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CALL INDEXING SHREDDER\n",tjctx->name);
#endif
	    XqueryCtx xqctx;
	    /* StM:
	     * changed the original `EXTshred_and_index_doc(docName, (str)"", &pftijahSerializeFun, &xqctx)` into this;
	     * it compiles and loads, but I have now idea, whether it does work;
	     * especially the last parameter (lock *collLock) should most probably not be NULL
	     * (atleast if we desire any consistent concurrency) ...
	     */
	    if ( shred(BATnew(TYPE_str,TYPE_bat,30), docName, NULL, NULL, 0, &pftijahSerializeFun, &xqctx, NULL) == GDK_FAIL)
	    	 return GDK_FAIL;
	} else {
#ifdef TJ_TRACE
	    if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:CALL INDEXING SERIALIZER\n",tjctx->name);
#endif
	    if ( xquery_print_doc_DRIVER("",&pftijahSerializeFun,NULL,ws,docName) == GDK_FAIL)
	        return GDK_FAIL;
	}
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:FINISH INDEXING\n",tjctx->name);
#endif
	if ( dbat_finalize(&tjctx->dbat_collPre, tjctx->tijahPre) < 0 )
		return GDK_FAIL;
	if ( dbat_finalize(&tjctx->dbat_collSize, tjctx->tijahPre) < 0 )
		return GDK_FAIL;

        tjctx->b_collPre->batDirty   = TRUE;
        tjctx->b_collSize->batDirty  = TRUE;
        tjctx->b_collPfPre->batDirty = TRUE;
#ifdef TJ_TRACE
	if ( TJ_TRACE ) stream_printf(GDKout,"C[%s]:FINALIZED DIRECT BATS\n",tjctx->name);
#endif
	/* finally do the maximum doc height administration */
	if ( 0 && !handle_doc_height(tjctx) )
	    return GDK_FAIL;
	/* read elapsed time */
#ifdef TJ_TRACE
	if ( TJ_TRACE ) {
		stream_printf(GDKout,"C[%s]:SIZES\n",tjctx->name);
		stream_printf(GDKout,"C[%s]:size( b_globalTerm ) = %d\n",tjctx->name, BATcount(tjctx->b_globalTerm));
		stream_printf(GDKout,"C[%s]:size( b_globalTag )  = %d\n",tjctx->name, BATcount(tjctx->b_globalTag));
		stream_printf(GDKout,"C[%s]:size( b_globalRTag )  = %d\n",tjctx->name, BATcount(tjctx->b_globalRTag));
		stream_printf(GDKout,"C[%s]:size( b_collPre )    = %d\n",tjctx->name, BATcount(tjctx->b_collPre));
		stream_printf(GDKout,"C[%s]:size( b_collSize )   = %d\n",tjctx->name, BATcount(tjctx->b_collSize));
		stream_printf(GDKout,"C[%s]:size( b_collPfPre )  = %d\n",tjctx->name, BATcount(tjctx->b_collPfPre));

	}
#endif
	return freeTijahContext(tjctx);
}

int
CMDtj_throw2collection(BAT* tjCtx_BAT, BAT* ws, str docName, str dummy) {
    (void)dummy;
    return  add2collection_handler(0,tjCtx_BAT,ws,docName);
}

int
CMDtj_throw2collection_index(BAT* tjCtx_BAT, str locName) {
    return  add2collection_handler(1,tjCtx_BAT,NULL,locName);
}

/* vim:set shiftwidth=4 expandtab: */
