@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2006 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'

@f pftijah
@a Jan Flokstra
@a Henning Rode
@t pftijah

@m
.MODULE pftijah;

.USE pathfinder;

.COMMAND run_tijah_command(str s) : bit = CMDtijah_command;
 "INCOMPLETE"

.COMMAND run_tijah_query(BAT[str,str], str q) : BAT[oid,dbl] = CMDtijah_query;
 "INCOMPLETE"

.COMMAND tj_normalizeTerm(str, str) : str = CMDtj_normalizeTerm;
 "INCOMPLETE"

.COMMAND tj_add2collection(BAT[oid,bat],BAT[oid,bat],str,str) : void = CMDtj_add2collection;
 "INCOMPLETE"

.COMMAND tj_add2collection_index(BAT[oid,bat],str) : void = CMDtj_add2collection_index;
 "INCOMPLETE"
 
.COMMAND tijah_tokenize(str) : str = CMDtijah_tokenize;
 "INCOMPLETE"

.COMMAND serialize_tijah_opt(
                      BAT[void,bat] ws,
                      int	    niters,
                      BAT[void,oid] loop,
                      BAT[void,oid] iter,
                      BAT[void,oid] item,
		      BAT[void,int] kind,
                      BAT[void,lng] int_values,
		      BAT[void,dbl] dbl_values,
		      BAT[void,str] str_values)
		       : BAT[str,str] = serialize_pftijah_options_DRIVER;
 "C interface to pftijah option serialize"

.COMMAND offsetindex( BAT[void,oid] offset_tid, int res_size)
		: BAT[void,oid] = CMDoffsetindex;

"PARAMETERS:
BAT[void,oid] - the offset index 
ressize       - the result size, equals number of different tids + 1
DESCRIPTION:
creates an offset index.
"

.COMMAND indexfetchjoin( BAT[any,oid] tid, BAT[void,oid] index, BAT[void, oid] pre)
		: BAT[oid,oid] = CMDindexfetchjoin;
"PARAMETERS:
BAT[any,oid] - bat with tail values which have to be joined (e.g. tid values)
BAT[void,oid] - join index bat with value-offset
BAT[void,oid] - bat with indexed offset and tail values to be returned
DESCRIPTION:
the join algorithm comes down to a repeated slice and insert operation.
"

.PRELUDE = pftijah_prelude;
.EPILOGUE = pftijah_epilogue;

.END pftijah;
@mil
module("pathfinder");

###
# This file contains implementations of some of the SRA operators 
# to run on the TIJAH Light index.
#
# Based on code by the TIJAH team (Vojkan, Thijs)
#
# Additional retrieval models by Henning Rode 
#
# Authors: Roel van Os <roel.van.os@glacimonto.nl>
#          Henning Rode <h.rode@cs.utwente.nl>
#
###

const DEBUG := false;

# Type of the size used
const SIZE_ENTITY := 1;
const SIZE_TERM := 2;

# Comparisons
const GREATER := 10;
const LESS := 11;
const EQUAL := 12;
const GEQ := 13;
const LEQ := 14;

# Modifiers
const NORMAL := 71;
const PLUS := 72;
const MINUS := 73;
const MUST := 74;
const MUST_NOT := 75;

#default
var scoreBase := 0;

const ENTITY_NUM := 10000;

var collName := "PFX";
var collHeight := 10;
var retNum := 100;

if (view_bbp_name().reverse().exist("tj_collName")) {
	if (bat("tj_collName").count() > 0) {
		var name := bat("tj_collName").fetch(0);
		tj_setCollName(name);
	}
}

PROC tj_setCollName(str name) : void := 
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(name))) {
		printf("Error: Selected collection does not exist. Collection name is not changed.\n");
		fflush(stdout());
		quit(); 
	}
	collName := name;
	collHeight := bat("tj_" + collName + "_param").find("height").int();
	if ( DEBUG ) { 
        	printf("Work collection is set to %s (with height %d)\n", collName, collHeight);
        	fflush(stdout());
        } 
}

PROC tj_setScoreBase(int default) : void :=
{
	scoreBase := default;
}

const virtRoot := 0@0;


##
# Compute ancestor-descendant relation. 
#
# Forwards to anc_desc_llscj: see below.
##
PROC anc_desc( bat[oid,any] anc, bat[oid,any] desc ) : bat[oid,oid] :=
{
   return anc_desc_llscj(anc,desc);
}


##
# Compute ancestor-descendant relation using the loop-lifted staircase join.
#
# The arguments anc and desc must contain preorder indices in their heads. 
# The tail values are discarded.
#
# Returns a bat containing [anc,desc] preorder index pairs
##
PROC anc_desc_llscj( bat[oid,any] anc, bat[oid,any] desc ) : bat[oid,oid] :=
{
    # Items contains the context nodes for the descendant step: 
    # this is the right side argument to contained_by.
    # The table must be [void,oid], so:
    var items := anc.sort().mark(0@0).reverse();
    
    # Suggestion from Thijs: make iters a [void,void], with the same length as anc
    var iters := anc.hmark(oid(0)).mark(oid(0));
    
    # Candidates contains the right side argument. This must also be [void,oid]:
    var candidates := desc.sort().mark(0@0).reverse();
    
    # Load the pre-size table
    var pre_size := load( "tj_" + collName + "_size");
    
    # Call the descendant algorithm: it returns [ancestor, descendant] pairs 
    # if we pass items as the iteration argument
    var void_desc := ll_descendant(iters, items, pre_size, candidates, collHeight, false, false, min(iters), max(iters), false);
    
    # Map back the ancestors
    var anc_desc  := anc.mark(oid(0)).join(void_desc);
    
    candidates := nil;
    items := nil;
    pre_size := nil;
    
    return anc_desc;
}


## 
# Compute parent-child relation. 
# 
# Forwards to parent_child_llscj: see below.
##
PROC parent_child( bat[oid,any] parent, bat[oid,any] child ) : bat[oid,oid] :=
{
    return parent_child_llscj( parent, child );
}


## 
# Compute parent-child relation using the loop-lifted staircase join. 
# 
# The arguments parent and child must contain preorder indices in their heads. 
# The tail values are discarded.
#
# Returns a bat containing [parent,child] preorder index pairs
##
PROC parent_child_llscj( bat[oid,any] parent, bat[oid,any] child ) : bat[oid,oid] :=
{
    # Items contains the context nodes for the descendant step: 
    # this is the right side argument to contained_by.
    # The table must be [void,oid], so:
    var items := context.mark(0@0).reverse();
    
    # Candidates: all element nodes
    var candidates := child.sort().mark(0@0).reverse();
    
    # Load the pre-size table
    var pre_size := load( "tj_" + collName + "_size");
    
    # Check the order of the items:
    items.chk_order();
    
    var par_chld := ll_child(items, items, pre_size, candidates, collHeight, false, false, min(items), max(items), false);
    
    candidates := nil;
    items := nil;
    pre_size := nil;
    
    return par_chld;
}


##
# Converts a list of query terms to a list of term id->document position mappings.
#
# Stemming on the query terms is performed using the same stemmer
# that was used for the collection.
##
PROC Qterms_to_tid_pre( bat[void,str] Qterms ): bat[oid,oid] :=
{
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var stemmed := [tj_normalizeTerm]( Qterms, stemmer );
    
    var tids    := bat("tj_globalTerms").join( stemmed.reverse() ).sort().hmark(oid(0));
    
    var result := indexfetchjoin( tids,
                                  bat("tj_" + collName + "_TermIndex"),
                                  bat("tj_" + collName + "_Terms") );
    return result;
}


##
# Converts a list of query terms to a list of term ids
#
# Stemming on the query terms is performed using the same stemmer
# that was used for the collection.
##
PROC Qterms_to_void_tid( bat[void,str] Qterms ): bat[void,oid] :=
{
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var stemmed := [tj_normalizeTerm]( Qterms, stemmer );
    
    var tids    := bat("tj_globalTerms").join( stemmed.reverse() ).sort().hmark(oid(0));
    return tids;
}


##
# Return only the element nodes from region ctx
##
PROC nodes( bat[oid,any] ctx ) : bat[oid,any] :=
{
    # The pfpre table only stores element nodes, so we can use it as a filter:
    var pfpre  := bat( "tj_" + collName + "_pfpre");
    var result := pfpre.mirror().join( ctx );
    return result;
}


##
# Return only the terms from region ctx
##
PROC terms( bat[oid,any] ctx ) : bat[oid,any] :=
{
    # A term is everything that is not an element node
    var nodes  := nodes( ctx );
    var result := ctx.kdiff( nodes );
    return result;
}


################################################################################
# SELECTION
################################################################################

##
# Select the root node of the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_root() : bat[oid,dbl] :=
{
    # Because TIJAH expects all documents in a collection to be contained by one 
    # "virtual root" element, his behaviour should be emulated by the light index. 
    # An element with preorder oid(0) will indicate that it is the collection root.
    var root_reg := new(oid,dbl,1);
    
    root_reg.insert( virtRoot, dbl(scoreBase) );
    return root_reg;
}


##
# Select all element nodes in the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_node() : bat[oid,dbl] := 
{
    # The table pfpre only stores element nodes, so we can use it as a filter:
    var pfpre  := bat( "tj_" + collName + "_pfpre");
    
    return pfpre.project( dbl(scoreBase ) );
}


##
# Select all element nodes in the collection with the given name
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_node(str name) : bat[oid,dbl] :=
{
    var start_time := time();

    var tids := bat("tj_globalTags").select(name);
    if (tids.count() = 0) return new(oid,dbl);
    var tid := tids.reverse().fetch(0);
    var result := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TagIndex"),
    				  bat("tj_" + collName + "_Tags") );
    result := result.reverse().sort().project(dbl(scoreBase)); 

    var end_time := time();
    if (DEBUG) printf( "select_node: \t\t%d ms\n", end_time - start_time );
    return result;
}


##
# Select all element nodes in the collection with the given name.
#
# Equivalence classes are taken into account. 
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_node(str name, bit e_class) : bat[oid,dbl] :=
{
    if ( e_class ) printf( "WARNING: equivalences are not yet supported!\n" );
    return select_node(name);
}


##
# Select all terms with the given value
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_term(str name) : bat[oid,dbl] :=
{
    var start_time := time();
    # 
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var term    := tj_normalizeTerm( name, stemmer );
    
    # Select the term positions from the global term dictionary.
    var tids := bat("tj_globalTerms").select(term).mark(0@0).sort().reverse();
    
    var result := indexfetchjoin( tids,
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    result := result.reverse().sort().project(dbl(scoreBase)); 
    
    var end_time := time();
    if (DEBUG) printf( "select_term: \t\t%d ms\n", end_time - start_time );
    return result;
}


##
# Select all terms with the given value, possibly performing stemming on the argument.
#
# This variant of the select_term function is present for compatibility reasons:
# at the moment, stemming is always performed using the same stemmer that was
# used to index the collection.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_term(str name, int stemming) : bat[oid,dbl] := 
{
    return select_term( name );
}


##
# Select a number of terms by their term-id.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_phrase(bat[void,oid] terms) : bat[oid,dbl] :=
{
    var start_time := time();
    # Select the term positions from the global term dictionary. 
   
    var tid := terms.fetch(0);
    var tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    var res := tmp.reverse();
    var j := terms.count();
    var i := 1; 
    while (i < j)
    {
        tid := terms.fetch(i);
        tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
        res := res.semijoin(tmp.[int]().[-](i).[oid]().reverse());   
	i :+= 1;
    }	
    
    res := res.sort().project(dbl(scoreBase)); 
    
    var end_time := time();
    if (DEBUG) printf( "select_phrase: \t\t%d ms\n", end_time - start_time );
    return res;
}


################################################################################
# CONTAINMENT
################################################################################


#####################################
# left CONTAINED_BY right:
#
#   +--------------------+
#   |       right        |
#   | +---------------+  |
#   | |      left     |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it is contained a region in right
#
#####################################
PROC contained_by(bat[oid,dbl] left, bat[oid,dbl] right) : bat[oid,dbl] :=
{
    var start_time := time();
    
    # Check for the virtual root
    if ( and((count( left ) = 1),(left.reverse().fetch(0) = virtRoot))) 
            return new(oid,dbl);
    if ( and((count( right ) = 1),(right.reverse().fetch(0) = virtRoot))) 
            return left;
    
    var anc_desc := anc_desc( right, left );
    
    # Attach the scores to the resulting nodes again:
    var result := anc_desc.reverse().mirror().join(left);
    
    var end_time := time();
    if (DEBUG) printf( "contained_by: \t\t%d ms\n", end_time - start_time );
    return result;
}


##
# Returns all regions in the collection that are contained by the argument. 
# Equivalent with a descendant step in XPath.
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC contained_by(bat[oid,dbl] region) : bat[oid,dbl] :=
{
    var ctx      := region;
    var pre_size := load( "tj_" + collName + "_size");    
    var desc     := scj_desc( pre_size, ctx, collHeight, count(pre_size) );
    var result   := nodes( desc ).project( dbl(scoreBase) );
    return result;
}


#####################################
# left CONTAINING right:
#
#   +--------------------+
#   |       left         |
#   | +---------------+  |
#   | |      right    |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it contains a region in right
#
#####################################
PROC containing(bat[oid,dbl] left, bat[oid,dbl] right) : bat[oid,dbl] :=
{
    var start_time := time();
    
    # Check for the virtual root
    if ( and((count( left ) = 1),(left.reverse().fetch(0) = virtRoot))) 
            return right;
    if ( and((count( right ) = 1),(right.reverse().fetch(0) = virtRoot))) 
            return new(oid,dbl);
    
    var anc_desc := anc_desc( left, right );

    # Attach the scores to the resulting nodes again:
    var result := anc_desc.mirror().kunique().join(left);
    
    var end_time := time();
    if (DEBUG) printf( "containing: \t\t%d ms\n", end_time - start_time );
    return result;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

PROC p_containing_q_NLLR_batloop_anc(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
     var terms := Qterms_to_void_tid( Qterms );
     if (terms.count() = 0) {return new(oid,dbl);}
     var t1 := time();
     var tind := bat("tj_" + collName + "_TermIndex");
     var pres := bat("tj_" + collName + "_Terms");
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := pres.count();
     _lmbd :*= collFrq; 

     var t2 := time();
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var t5 := time();
	  var oid_min := int(tind.fetch($t));
	  var oid_max := int(tind.fetch(int($t) + 1)) - 1;
	  var tid_pre := pres.slice(oid_min, oid_max);
          var tmp_pre := tid_pre.tsort().tmark(0@0); 
	  tid_pre := nil;
	  var fac := tmp_pre.count();
	  if (fac > 0)
	  {
	       fac := _lmbd / fac;
               
               var elem_termpre := ll_ancestor(tmp_pre, tmp_pre, bat("tj_" + collName + "_size"), collHeight).reverse(); 
               tmp_pre := nil;
               elem_termpre := elem_termpre.semijoin(left);
               var elem_frq := bat("tj_" + collName + "_size").semijoin(elem_termpre);
	       
	       var tmp := elem_termpre.reverse().histogram();
               elem_termpre := nil;
	       tmp := [dbl](tmp);
	       tmp := [/](tmp, elem_frq);
	       tmp := [*](tmp, fac);
	       tmp := [+](tmp, 1);
	       tmp := [log](tmp);
	       var t8 := time();
	       doc_prob.insert(tmp);
	       var t9 := time();
         if (DEBUG) {
            printf("inside loop: ll_desc (%d), insert (%d), total (%d)\n", t7 - t6, t9 - t8, t9 - t5);
            fflush(stdout());
         }
	       
          }
     }
     var t3 := time();
     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), left.mark(0@0));
     res := res.[/](terms.count()).[+](left);
     var t4 := time();
     
     if (DEBUG) {
        printf("p_containing_q: loop (%d), total (%d)\n", t3 - t2, t4 - t1);
        fflush(stdout());
     }
     return res;
}

PROC p_containing_q_NLLR_batloop(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
     var terms := Qterms_to_void_tid( Qterms );
     if (terms.count() = 0) {return new(oid,dbl);}
     var t1 := time();
     var tind := bat("tj_" + collName + "_TermIndex");
     var pres := bat("tj_" + collName + "_Terms");
     var elem_frq := bat("tj_" + collName + "_size").semijoin(left);
     var elems := left.hmark(0@0);
     var iter := elems.mirror();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := pres.count();
     _lmbd :*= collFrq; 

     var t2 := time();
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var t5 := time();
	  var oid_min := int(tind.fetch($t));
	  var oid_max := int(tind.fetch(int($t) + 1)) - 1;
	  var tid_pre := pres.slice(oid_min, oid_max);
          var cands := tid_pre.reverse().sort().mark(0@0).reverse();
	  var fac := tid_pre.count();
	  if (fac > 0)
	  {
	       fac := _lmbd / fac;
	       var t6 := time();
               if (DEBUG) {
                    printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size").count());
                    fflush(stdout());
               }
	       var elem_termpre := ll_descendant(iter, 
     						 elems, 
						 bat("tj_" + collName + "_size"), 
						 cands, 
						 collHeight, 
						 false, false, min(iter), max(iter), false);
               var t7 := time();
	       cands := nil;
	       tid_pre := nil;
     	       elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
	       var tmp := elem_termpre.reverse().histogram();
               elem_termpre := nil;
	       tmp := [dbl](tmp);
	       tmp := [/](tmp, elem_frq);
	       tmp := [*](tmp, fac);
	       tmp := [+](tmp, 1);
	       tmp := [log](tmp);
	       var t8 := time();
	       doc_prob.insert(tmp);
	       var t9 := time();
           if (DEBUG) {
               printf("inside loop: ll_desc (%d), insert (%d), total (%d)\n", t7 - t6, t9 - t8, t9 - t5);
               fflush(stdout());
	       }
          }
     }
     var t3 := time();
     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), elems.reverse());
     res := res.[/](terms.count()).[+](left);
     var t4 := time();
     
     if (DEBUG) {
        printf("p_containing_q: loop (%d), total (%d)\n", t3 - t2, t4 - t1);
        fflush(stdout());
     }
     return res;
}

PROC _containing_desc(bat[oid,void] left, bat[oid,oid] tid_pre) : bat[oid,oid] :=
{
     var elems := left.hmark(0@0);
     var cands := tid_pre.tmark(0@0);
     var iter := elems.mirror();
     var elem_termpre := ll_descendant(	iter, 
     					elems, 
					bat("tj_" + collName + "_size"), 
					cands, 
					collHeight, 
					false, false, min(iter), max(iter), false);
     elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
     var elem_tid := elem_termpre.join(tid_pre.reverse());
     elem_termpre := nil;
     return elem_tid;
}

PROC _containing_anc(bat[oid,void] left, bat[oid,oid] tid_pre) : bat[oid,oid] :=
{
     var tmp_pre := tid_pre.tmark(0@0);
     var elems := ll_ancestor(tmp_pre, 
                              tmp_pre, 
                              bat("tj_" + collName + "_size"), 
                              collHeight).reverse(); 
     tmp_pre := nil;
     elems := elems.semijoin(left);
     var elem_tid := elems.join(tid_pre.reverse());
     var elems := nil;
     return elem_tid;
}

PROC p_containing_q_NLLR(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
     # fetch term occurrences
     var terms := Qterms_to_void_tid( Qterms );
     if (terms.count() = 0) {return new(oid,dbl);}
     var tid_pre := indexfetchjoin(terms, 
                                   bat("tj_" + collName + "_TermIndex"), 
                                   bat("tj_" + collName + "_Terms") );
     tid_pre := tid_pre.tsort();
     
     # compute constant factor in score computation
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := bat("tj_" + collName + "_Terms").count();
     _lmbd :*= collFrq;

     # compute collection terms frequencies
     var tid_frq := histogram(tid_pre.reverse());
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;

     # get evaluate doc/term (anc/desc) relationship
     # including rule-of-thumb optimization
     var elem_tid;
     if ((tid_pre.count() * 50000) > collFrq)
          elem_tid := _containing_desc(left.mark(0@0), tid_pre);
     else
          elem_tid := _containing_anc(left.mark(0@0), tid_pre);
     tid_pre := nil;

     # compute document frequencies
     var elem_frq := bat("tj_" + collName + "_size").semijoin(elem_tid);

     # compute scores in batloop over terms
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var tmp := elem_tid.select($t);
	  var fac := _tid_frq.find($t);
	  tmp := tmp.reverse().histogram();
	  tmp := [dbl](tmp);
	  tmp := [/](tmp, elem_frq);
	  tmp := [*](tmp, fac);
	  tmp := [+](tmp, 1);
	  tmp := [log](tmp);
	  doc_prob.insert(tmp);
     }
     
     # aggregate doc scores
     var res := {sum}(doc_prob.tmark(0@0), doc_prob.hmark(0@0), elem_tid.mirror());
     res := res.[/](terms.count()).[+](left);
     return res;
}

##
# Implementation of the Language Modeling retrieval model, with smoothing.
#
# This function is meant for term-at-a-time score computation (ASPECT algebra), e.g.:
#
# var R1 := select_node("article");
# var R2 := select_term("information");
# var R3 := p_containing_t_LMs(R1, R2, 0.5, SIZE_TERM);
#
# R3 now contains all regions in R1, however with scores attached according
# to the occurrence of the term "information" (R2)
##
PROC p_containing_t_LMs(bat[oid,dbl] left, bat[oid,dbl] right, flt lmbd, int size_type) : bat[oid,dbl] := 
{
    var start_time := time();
    var lambda;
    var m_lambda;
    var forgnd_prob := new(oid,dbl,ENTITY_NUM);
    var bckgnd_prob;

    var res_reg := new(oid,dbl,ENTITY_NUM);

    # Compute the foreground probability: how many regions from right does left contain?
    # This count is divided by the region size by reg_freq
    
    forgnd_prob := reg_freq(left,right,size_type);

    if (size_type = SIZE_ENTITY) {
        # Compute right size / collection entity size
        
        var pre_pfpre := bat("tj_" + collName + "_pfpre");
        bckgnd_prob := dbl(count(right))/dbl(count(pre_pfpre));

        pre_pfpre := nil;
    }

    else if (size_type = SIZE_TERM) {
        # Compute right size / collection term size
        
        var pre_tid  := bat("tj_" + collName + "_tid");
        var pre_pfpre := bat("tj_" + collName + "_pfpre");
        var terms := pre_tid.mirror().kdiff( pre_pfpre.mirror() );

        bckgnd_prob := dbl(count(right))/dbl(count(terms));
        
        var pre_tid := nil;
        var pre_pfpre := nil;
        var terms := nil;
    }

    if (bckgnd_prob = dbl(0)) {
        if (DEBUG) printf( "Minimum collection frequency has not been computed yet!\n" );
        # Assign minimum collection frequency
        
        bckgnd_prob := min(col_freq());
    }

    # Precompute lambda values
    lambda := dbl(lmbd);
    m_lambda := dbl(1)-lambda;

    if (scoreBase = 0)
        res_reg := [+](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));
    else if (scoreBase = 1)
        res_reg := [*](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));
    
    
    var end_time := time();
    if (DEBUG) printf( "p_containing_t_LMs: \t%d ms\n", end_time - start_time );
    return res_reg;
}

##
# Returns the collection frequency table (should be precomputed, but is calculated for now)
##
PROC col_freq() : bat[oid,dbl] :=
{
    var start_time := time();
    var allterms := bat("tj_globalTerms").sort().mark(0@0).reverse();
    var alltermpos := indexfetchjoin(allterms, bat("tj_"+collName+"_TermIndex"), bat("tj_"+collName+"_Terms"));
    var col_freqs := [dbl]({count}(alltermpos));

    if (DEBUG) printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return col_freqs;
}

##
# Returns the collection frequency of the term with the indicated tid
##
PROC col_freq(oid tid) : dbl :=
{
    var start_time := time();
    var alltermpos := indexfetchjoin(new(int,oid).insert(0,tid), bat("tj_"+collName+"_TermIndex"), bat("tj_"+collName+"_Terms"));
    var col_freqs := {count}(alltermpos);
    var result := dbl(col_freqs.fetch(0));
    if (DEBUG) printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return result;
}

##
# For each region in left, count the number of regions in right it contains.
##
PROC reg_freq(bat[oid,dbl] left, bat[oid,dbl] right, int size_type) : bat[oid,dbl]    :=    
{
    var start_time := time();
    
    var reg_size;
    
    var ctx_tmp2 := new( oid, int, ENTITY_NUM );
   
    ctx_tmp2 := anc_desc( left, right );
    
    # Containment count: for each region from left, count how many regions from right it contains
    var num_terms := {count}(ctx_tmp2);
    var prob_tmp  := [dbl](num_terms);
    
    # Region size: Determine the entity or term size of all regions from left that have descendants in right
    if (size_type = SIZE_ENTITY)
        reg_size := size_entity(prob_tmp);
    else if (size_type = SIZE_TERM)
        reg_size := size_term(prob_tmp);
    
    # prob_tmp := [/](prob_tmp,prob_tmp.mirror().join(reg_size));

    # Divide the containment count (left) by the region size (left)
    prob_tmp := [/](prob_tmp,reg_size);

    # Set all to zero regions from left that do not contain regions from right
	prob_tmp := prob_tmp.kunion( left.project(dbl(0)) );

    var end_time := time();
    if (DEBUG) printf( "reg_freq: \t\t%d ms\n", end_time - start_time );
    return prob_tmp;
}


# Calculate the term size of the region: how many terms does it contain?
PROC size_term( bat[oid,any] region ) : bat[oid,dbl] := 
{
    # For now, we use size_term = size_entity
    return size_entity( region );
    var start_time := time();
    
    # all terms:
    var pre_tid   := bat("tj_" + collName + "_tid");
    var pre_pfpre := bat("tj_" + collName + "_pfpre");
    var terms     := pre_tid.mirror().kdiff( pre_pfpre.mirror() );
    
    var items      := region.mirror().mark(0@0).reverse();
    var candidates := terms.mirror().mark(0@0).reverse();
    
    # Alternative:
    #var candidates      := bat("tj_" + collName + "_Terms" ).reverse().sort().mark(0@0).reverse();
    
    var pre_size := load( "tj_" + collName + "_size");
   
    # Check the order of the items:
    items.chk_order();
    
    var res := ll_descendant(items, items, pre_size, candidates, collHeight, false, false, min(items), max(items), false);
    
    var result := [dbl]({count}(res));
   
    var end_time := time();
    if (DEBUG) printf( "size_term: \t\t%d ms\n", end_time - start_time );
    return result;
}

# Calculate the entity size of the region: how many entities (tags and terms) does it contain?
PROC size_entity( bat[oid,any] region ) : bat[oid,dbl] :=
{
    var start_time := time();
    
    
    # Entity sizes:
    var pre_size := load( "tj_" + collName + "_size");
    
    var result := [dbl](region.mirror().join( pre_size ));

    var end_time := time();
    if (DEBUG) printf( "size_entity: \t\t%d ms\n", end_time - start_time );
    return result;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

PROC p_contained_by_sum(bat[oid,dbl] region) : bat[oid,dbl] :=
{
    # Candidates: all nodes
    var candidates := select_node();

    var ctx_res := anc_desc( region, candidates );

    var ctx := ctx_res.reverse().mirror();

    var reg_size := [dbl](size_term(ctx));

    reg_size:= reg_size.select(dbl(0),dbl(nil),false,true);

    ctx := reg_size.mirror();

    # calculating the score for each region
    var reg_score := {sum}(ctx_res.reverse().join(region));

    var res_reg := ctx.join(reg_score);

    return res_reg;
}


PROC p_contained_by_sum(bat[oid,dbl] left, bat[oid,dbl] right) : bat[oid,dbl] := 
{

    var ctx_res := anc_desc( right, left );
    
    var reg_score;
    var res_reg;
	var ctx := left.project(dbl(0));

    # calculating the score for each region
    reg_score := {sum}(ctx_res.reverse().join(right));
    reg_score := kunion(reg_score, ctx);

	if (scoreBase = 0)
		res_reg := [+](left, reg_score);
	else if (scoreBase = 1)
		res_reg := [*](left, reg_score);

	return res_reg;

}


PROC p_containing_wsumd(bat[oid,dbl] left, bat[oid,dbl] right, int size_type) : bat[oid,dbl] :=
{
    var ctx := left.project(dbl(0));
    var size_reg;
    var reg_score;
    var norm_reg;
    var res_reg;
    
    if (size_type = SIZE_ENTITY) {
        size_reg := size_entity(right);
    }
    else if (size_type = SIZE_TERM) {
        size_reg := size_term(right);
    }

    # Call the descendant algorithm: it returns [ancestor, descendant] pairs!
    var ctx_res := anc_desc( left, right );

    # calculating the score for each region
    reg_score := {sum}(ctx_res.join([*](size_reg,right)).sort());
    norm_reg := [dbl]({sum}(ctx_res.join(size_reg).sort()));

    # Select all values > 0
    norm_reg := norm_reg.select(dbl(0),dbl(nil),false,true);

    reg_score := norm_reg.mirror().join(reg_score);

    reg_score := [/](reg_score,norm_reg);

    reg_score := kunion(reg_score,ctx);

    if (scoreBase = 0)
        res_reg := [+](left, reg_score);
    else if (scoreBase = 1)
        res_reg := [*](left, reg_score);

    return res_reg;
}

#################################################################################
# SET BASED PROBABILISTIC TERM CONTAINING (COARSE2 ALGEBRA)
#################################################################################


#proc p_containing_q(bat ctx, bat Qterms, bat modifiers, int stemming, int size_type) : bat {   
#    return p_containing_q(ctx, Qterms,modifiers, flt(1.0), stemming, size_type);
#}

proc p_containing_q_LMs(bat[oid,dbl] ctx, bat[void,str] Qterms, bat modifiers, flt lambda, int stemming, int size_type) : bat {   
    if ( false ) {
        # Forward to p_containing_q_LM_fast:
        return p_containing_q_LM_fast( ctx, Qterms, modifiers, lambda, stemming, size_type );
    } else {
        var Qpositions := Qterms_to_tid_pre(Qterms).reverse().sort().project(dbl(scoreBase));
        var context := ctx.sort();
        var termscores := p_containing_t_LMs(context, Qpositions, lambda, size_type);
        return termscores;
    }
}

##
# Smarter LM implementation that needs only a single treemergejoin per query
# Arguments: 
#   ctx: context regions
#   Qterms: query terms ([void,oid])
#
# Original code by: Thijs, prefixed by #:
##
proc p_containing_q_LM_fast(bat[oid,dbl] ctx, bat[oid,str] Qterms, bat modifiers, flt lambda, int stemming, int size_type) : bat {   
    # TODO: add real weighting to avoid recomputation for duplicate query terms, 
    # or for morphological variants when stemming (can also be used to implement the modifiers)
    
	var QoidWeights := Qterms.project(dbl(1)); 
    
    if ( Qterms.count() = 0) {
        return ctx.[*](min(col_freq()));
    }
    
    var Qoid_pre := Qterms_to_tid_pre( Qterms );
    
    # pre_Qoid  : [pre, term-oid] 
    var pre_Qoid := Qoid_pre.reverse().sort();
    
    # res       : [anc_pre, desc_pre]
    var res := anc_desc( ctx, pre_Qoid );
    
    
	# res_ctx: [void, anc_pre]
    var res_ctx := res.hmark(oid(0));
    
    # res: [anc_pre, desc_pre]
    # res.tmark(oid(0)): [void,desc_pre]
    # pre_Qoid: [desc_pre, tid]
    # pre_Qoid.tmark(oid(0)): [void, tid]
    
	#: var res_Qoid := res.tmark(oid(0)).join(pre_Qoid.tmark(oid(0)));
    
    var res_Qoid := res.join(pre_Qoid);
	var termcounts := res_Qoid.CTgroup(res_ctx).CThistogram();
    
    #:var termcounts := {count}(res);
    
    var ctx_size;

	if (size_type = SIZE_ENTITY)
        ctx_size:=res_oid.reverse().kunique().mirror().sort().size_entity();
	else if (size_type = SIZE_TERM)
		#: ctx_size :=ctx_oid.join(BAT(col_name+"entity_text_size"));
        ctx_size := size_term(ctx);      

    var termprobs:=termcounts.[dbl]().[/](res_ctx.join(ctx_size).[dbl]());

	termprobs:=termprobs.[*](lambda);
	var prob;	

	if (lambda<1.0)
	{
        var BG;
        if (size_type = SIZE_ENTITY) {
            var col_root := load(col_name+"col_root");
            BG := pre_Qoid.reverse().{count}().[/](size_entity(entity_pre.join(col_root)).find(oid(0)));
        }  

        else if (size_type = SIZE_TERM) {

            BG := pre_Qoid.reverse().{count}().[/](dbl(count(word_pre)));
        }

        word_pre := nil;
        entity_pre := nil;

        BG:= BG.[*](1-lambda);
     
        var BGprobs := res_Qoid.join(BG);

        # This is the presence weighting scheme 
        # (cf. for example Eq. 3.22 in thesis Thijs)
        prob := termprobs.[/](BGprobs).[+](1); 	
        

        # Apply query term weights 
        # normalisation for number query terms not needed (does not influence ranking)

        prob:= prob.[dbl]().[pow](join(res_Qoid,QoidWeights));

        # convert to (ctx_ind,prob)
        prob := res_ctx.reverse().join(prob);
        
        # aggregate over query terms (joint probability)
        prob := prob.{prod}().sort(); # only scores for matchin nodes
        
        # non matching-score
        var NMS := BG.[pow](QoidWeights).prod();
        prob:=prob.[*](NMS); # multiply matching w. NMS (cv. presence weighting scheme)
        # non matching elements get NMS only;
        prob:=ctx_oid.project(NMS).access(BAT_WRITE).inplace(prob).access(BAT_READ);
	}
	else
	{

        # lambda = 1 -> do not use presence weighting to avoid division by zero; 
        # compute without rewriting (cf. eq. 3.20 and 3.21 in Thijs' thesis)
        prob := termprobs;

        # Apply query term weights 
        # normalisation for number query terms not needed (does not influence ranking)

        prob:= prob.[dbl]().[pow](join(res_Qoid,QoidWeights).[dbl]());

        # convert to (entity_oid,prob)
        prob := res_ctx.reverse().join(prob);
	
        # aggregate over query terms (joint probability)
        prob := prob.{prod}().sort(); # only scores for matchin nodes
	

        # add non-matching elements
        prob := ctx_oid.project(dbl(0)).access(BAT_WRITE).inplace(prob).access(BAT_READ);
    }

	if (scoreBase = 0)
		prob := [+](ctx_score,prob);
	else if (scoreBase = 1)
		prob := [*](ctx_score,prob);

	prob := ctx_oid.reverse().join(prob);

	return prob; 
    #: }
}


################################################################################
# SET OPERATORS
################################################################################

### UNION
PROC union(bat left, bat right) : bat :=
{

	return left.kunion(right);

}

### INTERSECTION
PROC intersect(bat left, bat right) : bat := 
{

	return left.kintersect(right);

}


################################################################################
# SCALING
################################################################################

PROC scale(bat region, flt importance) : bat := 
{

	var res_reg := new(oid,dbl,ENTITY_NUM);
	res_reg := [*](dbl(importance),region);
	return res_reg;

}


################################################################################
# PROBABILISTIC SET OPERATORS
################################################################################

PROC or_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC or_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC or_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

PROC or_exp(bat left, bat right, int A) : bat := 
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC or_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC or_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC and_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC and_exp(bat left, bat right, int A) : bat :=
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC and_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC and_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

################################################################################
# VALUE SELECTION
################################################################################

PROC near_val(bat region, int command, str value) : bat :=
{
    var r_value;
    var reg_res := new(oid,dbl,ENTITY_NUM);
    var reg_tmp := new(oid,oid,ENTITY_NUM);

    var entity_pre := new(oid,oid,WORD_NUM);
    entity_pre := load(col_name+"entity_pre");

    # region:               [region-id, score]
    # region.mirror():      [region-id, region-id]
    # entity_pre:           [region-id, region pre-id]
    # reg_tmp:              [region-id, region pre-id]
    reg_tmp := region.mirror().join(entity_pre);

    entity_pre := nil;

    r_value := int(value);

    if (command = GREATER)
        reg_tmp := gt(reg_tmp, r_value);
    else if (command = LESS)
        reg_tmp := lt(reg_tmp, r_value);
    else if (command = EQUAL)
        reg_tmp := eq(reg_tmp, r_value);
    else if (command = GEQ)
        reg_tmp := gte(reg_tmp, r_value);
    else if (command = LEQ)
        reg_tmp := lte(reg_tmp, r_value);

    reg_res := reg_tmp.mirror().join(region);

    return reg_res;
}
#ADDHELP("near_val", "vojkan", "March 16, 2005",
#"Selects regions that satisfy the inequality (integer) test.",
#"TIJAH");

########################################################################################################
# Procudures for executing value comparison:
#       - eq            selects the regions with equal text content
#       - lt            selects the regions with less than text content
#       - gt            selects the regions with greater then text content
#       - lte           selects the regions with less than or equal text content
#       - gte           selects the regions with greater than or equal text content
#########################################################################################################

PROC gt(bat ctx, int comp) : bat :=
{

        var entity_pre := new(oid,oid,ENTITY_NUM);
        entity_pre := load(col_name+"entity_pre");
        var entity_type := new(oid,oid,ENTITY_NUM);
        entity_type := load(col_name+"entity_type");

        var word_pre := new(oid,oid,ENTITY_NUM);
        word_pre := load(col_name+"word_pre");
        var word_name := new(oid,oid,ENTITY_NUM);
        word_name := load(col_name+"word_name");
        var enum_word := new(str,int,ENTITY_NUM);
        enum_word := load(col_name+"enum_word");

        var cur_tmp := new(oid,oid,ENTITY_NUM);
        var ctx_tmp := new(oid,oid,TERM_NUM);
        var ctx_reg := new(oid,oid,ENTITY_NUM);

        cur_tmp:= ctx.child().mirror().join(entity_type).uselect('t').mirror().join(entity_pre);

        entity_type := nil;

        ctx_reg := [int]([str](word_pre.join(cur_tmp.reverse()).mirror().join(word_name).join(enum_word.reverse())));

        word_name := nil;
        enum_word := nil;

        var low := comp + 1;
        ctx_tmp := ctx_reg.select(comp,int(nil),false,false).mirror().join(word_pre);
        cur_tmp := entity_pre.join(ctx_tmp.reverse().mirror()).parent().mirror().join(ctx);

        word_pre := nil;
        entity_pre := nil;

        ctx := cur_tmp;

        return ctx;

}
#ADDHELP("gt", "vojkan", "Nov 14, 2003",
#"Performing greater than comparison between element content and integer.",
#"TIJAH");



################################################################################
# PRIOR
################################################################################

PROC prior_ls(bat region, int size_type) : bat := 
{

	var ctx_size := new(oid,dbl,ENTITY_NUM);
	var res_reg := new(oid,dbl,ENTITY_NUM);

	if (size_type = SIZE_ENTITY)
		ctx_size := size_entity(region);
	else if (size_type = SIZE_TERM)
		ctx_size := size_term(region);

	res_reg := [+]([log](region.select(dbl(0),dbl(nil),false,false)),[log](ctx_size));
	res_reg := [-](region.select(dbl(0)).project(min(res_reg)),dbl(1)).kunion(res_reg);

	# res_reg := [+]([log](region),[*](dbl(3.0),[log](ctx_size)));

	# var ref_reg := new(oid,dbl,ENTITY_NUM);
	# var ref_size := new(oid,dbl,ENTITY_NUM);

	# var entity_name := load(collName+"entity_name");

	# var ref_name := entity_name.join(region.mirror().join(entity_name).reverse().mirror());
	# ref_reg := ref_name.project(dbl(1));

	# if (size_type = SIZE_ENTITY) {
	#	ctx_size := size_entity(region);
	#	ref_size := size_entity(ref_reg);
	# }
	# else if (size_type = SIZE_TERM) {
	#	ctx_size := size_term(region);
	#	ref_size := size_term(ref_reg);
	# }

	# ref_size := region.mirror().join(entity_name).join({sum}(ref_size.reverse().join(ref_name).reverse()));

	# res_reg := [*](region,[/](ctx_size,ref_size));

	return res_reg;

}
#ADDHELP("prior_ls", "vojkan", "March 16, 2005",
#"Adds element prior based on element length to the region score.",
#"TIJAH");



################################################################################
# ORDER
################################################################################

PROC order_regions(bat region) : bat :=
{

	region := region.reverse().sort_rev().reverse();

	return region;

}
#ADDHELP("order_regions", "vojkan", "March 29, 2005",
#"Order regions in descending order based on their score values.",
#"TIJAH");



PROC tj_global_init() : void 
{
	if (DEBUG) printf("# Initializing Pathfinder-Tijah integration package.\n");
	new(oid,str).persists(true).bbpname("tj_globalTerms");
	new(oid,str).persists(true).bbpname("tj_globalTags");
	new(oid,str).persists(true).bbpname("tj_collName");
	commit();
}

##########################################
# Collection Management Functions
#
##########################################

PROC tj_coll_init(str collName, str stemmer) : void
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}

	new(void,str).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_name");
	new(void,int).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_firstpre");
	new(str,str).persists(true).bbpname("tj_" + collName + "_param");

	new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_tid");
	new(void,int).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_size"); # incomplete, should be void/int
	new( oid,oid).persists(true).bbpname("tj_" + collName + "_pfpre");
	
	var coll_oid;
	if (bat("tj_collName").count() = 0) { coll_oid := 0@0; }
     	else { coll_oid := oid(int(bat("tj_collName").reverse().max()) + 1); }
	bat("tj_collName").insert(coll_oid, collName);
	#
	# now set the parameters for this collection
	#
	bat("tj_" + collName + "_param").insert("name",collName);
	bat("tj_" + collName + "_param").insert("height","0");
	if (stemmer = "") bat("tj_" + collName + "_param").insert("stemmer","nostemming");
	else bat("tj_" + collName + "_param").insert("stemmer",stemmer);
	bat("tj_" + collName + "_param").insert("preExpansion","4");
	bat("tj_" + collName + "_param").insert("status","building");
	#
	commit();
}

PROC tj_global_remove() : void
{
	bat("tj_collName")@batloop(){
		tj_coll_remove($t);
	}
	bat("tj_globalTerms").persists(false);
	bat("tj_globalTags").persists(false);
	bat("tj_collName").persists(false);
	commit();
}

PROC tj_coll_remove() : void
{
	tj_coll_remove(collName);
}

PROC tj_coll_remove(str collName) : void
{
	bat("tj_" + collName + "_doc_name").persists(false);
	bat("tj_" + collName + "_doc_firstpre").persists(false);
	bat("tj_" + collName + "_param").persists(false);
	bat("tj_" + collName + "_tid").persists(false);
	bat("tj_" + collName + "_size").persists(false);
	bat("tj_" + collName + "_pfpre").persists(false);
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) {
		bat("tj_" + collName + "_TermIndex").persists(false);
		bat("tj_" + collName + "_Terms").persists(false);
		bat("tj_" + collName + "_TagIndex").persists(false);
		bat("tj_" + collName + "_Tags").persists(false);
	}
        
	var coll_oid := bat("tj_collName").reverse().find(collName);
	bat("tj_collName").delete(coll_oid);
	commit();
}

PROC tj_collection() : BAT[void,bat]
{
	return tj_collection(collName);
}

PROC tj_collection(str collName) : BAT[void,bat]
{
	var tjCollBat := new(void,bat).seqbase(0@0);

	tjCollBat.append(bat("tj_globalTerms"));
	tjCollBat.append(bat("tj_globalTags"));
	tjCollBat.append(bat("tj_" + collName + "_doc_name"));
	tjCollBat.append(bat("tj_" + collName + "_doc_firstpre"));
	tjCollBat.append(bat("tj_" + collName + "_param"));
	tjCollBat.append(bat("tj_" + collName + "_tid"));
	tjCollBat.append(bat("tj_" + collName + "_size"));
	tjCollBat.append(bat("tj_" + collName + "_pfpre"));
	return tjCollBat;
}

PROC tj_createCollection(str doc, str url, str stemmer) : BAT[void,bat]
{
	return tj_createCollection(collName, doc, url, stemmer);
}

PROC tj_createCollection(str collName, str doc, str url, str stemmer) : void
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(collName))) {
		tj_coll_init(stemmer);
	}
	
	tj_url2Collection(collName, doc, url, "");
	tj_finalize(collName);
}

PROC tj_url2Collection(str doc, str url, str selTagList) : void
{
	tj_url2Collection(collName, doc, url, selTagList);
}

PROC tj_url2Collection(str collName, str doc, str url, str selTagList) : void
{
	var ws := create_ws();
	if (not(bat("doc_name").reverse().exist(doc))) {
		shred_doc(url,doc);
	}
	add_doc(ws,doc);
        
	bat("tj_globalTerms").access(BAT_WRITE);
	bat("tj_globalTags").access(BAT_WRITE);
        
	tj_add2collection(tj_collection(collName),ws,doc,selTagList);
	destroy_ws(ws);
	var height1 := bat("doc_height").fetch(bat("doc_name").reverse().find(doc));
        
        var coll_oid := bat("tj_collName").reverse().find(collName);
	var height2 := bat("tj_" + collName + "_param").find("height").int();
	bat("tj_" + collName + "_param").replace("height", max(height1,height2).str());
	bat("tj_" + collName + "_param").replace("status","building");
        commit();	
}

PROC tj_url2Collection_index(str collName, str url, str selTagList) : void
{
	bat("tj_globalTerms").access(BAT_WRITE);
	bat("tj_globalTags").access(BAT_WRITE);
        
	tj_add2collection_index(tj_collection(collName),url);

	bat("tj_" + collName + "_param").replace("status","building");
        commit();	
}

PROC tj_finalize() : void
{
	tj_finalize(collName);
}

PROC tj_finalize(str collName) : void
{
	# Finalize one collection. No documents should be added after this
	tj_buildIRindex(collName);
	#
	bat("tj_" + collName + "_param").replace("status","finalized");
	#
	var gterm_sort := bat("tj_globalTerms").reverse().sort().reverse();
	bat("tj_globalTerms").persists(false);
	var gtag_sort := bat("tj_globalTags").reverse().sort().reverse();
	bat("tj_globalTags").persists(false);
	commit();
	gterm_sort.persists(true);
	gterm_sort.bbpname("tj_globalTerms");
	gtag_sort.persists(true);
	gtag_sort.bbpname("tj_globalTags");
	bat("tj_globalTerms").access(BAT_READ);
	bat("tj_globalTags").access(BAT_READ);
        
	commit(); 
}

PROC tj_dump() : void
{
	tj_dump(collName);
}

PROC tj_dump(str collName) : void
{
	bat("tj_" + collName + "_param").print();
	bat("tj_" + collName + "_doc_name").print();
	bat("tj_" + collName + "_doc_firstpre").print();
	# print(bat("tj_" + collName + "_doc_name"),bat("tj_" + collName + "_doc_firstpre"));
	bat("tj_globalTerms").print();
	bat("tj_globalTags").print();
	print(bat("tj_" + collName + "_tid"));
	print(bat("tj_" + collName + "_size"));
	print(bat("tj_" + collName + "_pfpre"));
	# print(bat("tj_" + collName + "_tid"),join(bat("tj_" + collName + "_tid"),bat("tj_globalTerms")));
	# print(bat("tj_" + collName + "_height"));
}

# mil-code to build faster IR indices
PROC tj_buildIRindex() : void :=
{
	tj_buildIRindex(collName);
}

PROC tj_buildIRindex(str collName) : void :=
{
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) {
		bat("tj_" + collName + "_TermIndex").persists(false);
		bat("tj_" + collName + "_Terms").persists(false);
		bat("tj_" + collName + "_TagIndex").persists(false);
		bat("tj_" + collName + "_Tags").persists(false);
		commit();
	}
	var tmp := bat("tj_" + collName + "_tid").kdiff(bat("tj_" + collName + "_pfpre"));
        tmp := tmp.reverse().sort();
	var termindex := tmp.mark(0@0).reverse().offsetindex(bat("tj_globalTerms").count() + 1);
	var terms := tmp.reverse().mark(0@0).reverse();
	termindex.persists(true).bbpname("tj_" + collName + "_TermIndex");
	terms.persists(true).bbpname("tj_" + collName + "_Terms");
	tmp := nil;
	termindex := nil;
	terms := nil;
	commit();
	
	tmp := bat("tj_" + collName + "_tid").semijoin(bat("tj_" + collName + "_pfpre"));
        tmp := tmp.reverse().sort();
	var tagindex := tmp.mark(0@0).reverse().offsetindex(bat("tj_globalTags").count() + 1);
	var tags := tmp.reverse().mark(0@0).reverse();
	tagindex.persists(true).bbpname("tj_" + collName + "_TagIndex");
	tags.persists(true).bbpname("tj_" + collName + "_Tags");
	tmp := nil;
	tagindex := nil;
	tags := nil;
	commit();
}

######################################
# PF interface functions
#
######################################

PROC tijah2pf(BAT[oid,dbl] pre_score) : BAT :=
{
	var docpre := bat("tj_" + collName + "_doc_firstpre").[oid]();
	var pfpre :=  bat("tj_" + collName + "_pfpre");
	
	var item := pre_score.hmark(0@0);
	var score := pre_score.tmark(0@0);
	var iter := item.mirror();
	var frag := [find_lower](const docpre.reverse().mark(0@0), item);
	item := item.join(pfpre).sort().tmark(0@0);
	
	var res := new(void,bat);
	res.append(iter);
	res.append(item);
	res.append(frag);
	res.append(score);
	return res;
}

# align_frag assumes the following variable to be global to its scope:
# frag, kind, ipik, ws
PROC align_frag() : void :=
{
	var needed_docs := bat("tj_" + collName + "_doc_name").semijoin(frag.tunique());
	var loaded_docs := ws.fetch(DOC_LOADED).reverse();
	needed_docs@batloop()
	{
		if (not(loaded_docs.exist($t))) {
			ws.add_doc($t); }
	}
	var fid_pffid := needed_docs.join(ws.fetch(DOC_LOADED).reverse());
	frag := frag.join(fid_pffid).sort().tmark(0@0);
	kind := set_kind(frag, ELEM);
	ipik := iter;
}

@h

@c
#include <monet.h>
#include <gdk.h>

#include <pathfinder.h>

int executeMIL(char* str) {
    return monet_exec(str);
}

int CMDtijah_command(bit* res, str command) {
	if ( 0 ) stream_printf(GDKout,"# tijah_command(%s)\n",(char*)command);
	*res = executeMIL(command); /* OK */
	return GDK_SUCCEED;
}

extern char* tijahParse(BAT* optbat, char* query, char** errBUFF);

static int oldScoreCounter = 0;

int CMDtijah_query(BAT** res, BAT* optbat, str q) {
	char* err;
	char* mil;

	if ( !optbat ) {
            GDKerror("CMDtijah_query: missing option bat.\n");
	    return GDK_FAIL;
	}
	if ( !(mil=tijahParse(optbat,q,&err)) ) {
            GDKerror("CMDtijah_query: %s.\n", err);
	    return GDK_FAIL;
	}
        if ( executeMIL(mil)<0 ) {
            GDKerror("CMDtijah_query: execute MIL failed.\n");
	    return GDK_FAIL;
	}
	BAT* scoreBAT = BATdescriptor( BBPindex("nexi_result") );

	if ( ! scoreBAT ) {
            GDKerror("CMDtijah_query: fail to load score bat: \"%s\".\n", "nexi_result");
	    return GDK_FAIL;
        }
	char buff[32];
	sprintf(&buff[0],"%s_del%d","nexi_result",oldScoreCounter++);
	if ( BATrename(scoreBAT,(str)&buff[0]) == str_nil ) {
            GDKerror("CMDtijah_query: fail to rename score bat: \"%s\".\n", &buff[0]);
	    return GDK_FAIL;
	}
	BATmode(scoreBAT,TRANSIENT);

	*res = scoreBAT;
        return GDK_SUCCEED;
}

char* tijah_tokenize_string(char* buf, int len, char* outbuf);

int CMDtijah_tokenize (str* res, str arg)
{
	int sz    = strlen(arg);
	char* buf = GDKmalloc(sz + 1);

	buf[0] = 0;
	*res = tijah_tokenize_string(arg,sz,buf);

	return GDK_SUCCEED;
}

int CMDoffsetindex ( BAT** result, BAT* tid, int* res_size )
{
	char *name = "TJoffsetindex";
	BAT *res = NULL;
        BUN p, q, dst = NULL;
	oid t, s;
	int bs_res, x;

	/* --------------------------- checks ---------------------------------- */

	BATcheck(tid, name);
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: index-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}
	if (!(BAThdense(tid)))
    	{
        	GDKerror("%s: index-bat must have a dense head.\n", name);
    		return GDK_FAIL;
	}
		
	res = BATnew(TYPE_void, TYPE_oid, *res_size);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, *res_size);
            	return(GDK_FAIL);
        }
	bs_res = BUNsize(res);
	dst = BUNlast(res);
    
	t = (oid)0;
	*(oid*)dst = (oid)0;
	dst += bs_res;
	
	BATloopFast(tid, p, q, x)
	{
		s = *(oid*) BUNtail(tid, p);
		if (t != s)
		{
			for(; t < s; t++)
			{
				*(oid*)dst = BUNindex(tid, p);
				dst += bs_res; 
			}
		}
	}

	s = (oid) (*res_size - 1);
	for(; t < s; t++)
	{
		*(oid*)dst = BUNindex(tid, p);
		dst += bs_res; 
	}
	
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->tsorted = GDK_SORTED;
        BATkey (res, TRUE);
	BATset(res, TRUE);
	BATseqbase(res, 0);
	
	*result = res;
	return GDK_SUCCEED;
}	
	
int CMDindexfetchjoin ( BAT** result, BAT* tid, BAT* index, BAT* pre )
{
	char *name = "TJindexfetchjoin";
	BAT *res = NULL;
        BUN dst = NULL;
	int bs_pre = BUNsize(pre);
	int bs_res;

	int ressize = 0;
	oid t, *ind;
	BUN p, q;
        int x, j, i = 0;
	bit one_tid = FALSE;
    
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tid, name);
	BATcheck(index, name);
	BATcheck(pre, name);
	
        if (BATcount(tid) <= 1) one_tid = TRUE;
	
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	ind = GDKmalloc(sizeof(oid) * BATcount(tid) * 3);
	
	BATloopFast(tid, p, q, x) {
		t = *(oid*) BUNtail(tid, p);
		ind[i++] = t;
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t));
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t + 1));
		ressize += (ind[i - 1] - ind[i - 2]);
	}
	
	res = BATnew(TYPE_oid, TYPE_oid, ressize);
	bs_res = BUNsize(res);
	dst = BUNlast(res);
	
	j = 0;
	while (j < i) {
        	t = ind[j++];
		p = BUNptr(pre, ind[j++]);
		q = BUNptr(pre, ind[j++]);
		for (; p < q; p += bs_pre) {
			*(oid*)dst = t;
			*(oid*)(dst + SIZEOF_OID) = *(oid*)p;
			dst += bs_res;
		}
	}

	GDKfree(ind);
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
        BATkey (BATmirror(res), TRUE);
	BATset(res, TRUE);
	
	*result = res;
	return GDK_SUCCEED;
}

bat* pftijah_prelude() {
    return NULL;
}

void pftijah_epilogue() {
}
@

/* vim:set shiftwidth=4 expandtab: */
