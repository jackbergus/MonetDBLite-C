@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'

@f pftijah
@a Jan Flokstra
@a Henning Rode
@t pftijah

@m
.MODULE pftijah;

.USE pathfinder;

.COMMAND run_tijah_command(str s) : bit = CMDtijah_command;
 "INCOMPLETE"

.COMMAND run_tijah_query(str p, str q) : BAT[oid,dbl] = CMDtijah_query;
 "INCOMPLETE"

.COMMAND tj_add2collection(BAT[oid,bat],BAT[oid,bat],str,str) : void = CMDtj_add2collection;
 "INCOMPLETE"

.COMMAND offsetindex( BAT[void,oid] offset_tid, int res_size)
		: BAT[void,oid] = CMDoffsetindex;

"PARAMETERS:
BAT[void,oid] - the offset index 
ressize       - the result size, equals number of different tids + 1
DESCRIPITON:
creates an offset index.
"

.COMMAND indexfetchjoin( BAT[any,oid] tid, BAT[void,oid] index, BAT[void, oid] pre)
		: BAT[oid,oid] = CMDindexfetchjoin;
"PARAMETERS:
BAT[any,oid] - bat with tail values which have to be joined (e.g. tid values)
BAT[void,oid] - join index bat with value-offset
BAT[void,oid] - bat with indexed offset and tail values to be returned
DESCRIPITON:
the join algorithm comes down to a repeated slice and insert operation.
"

.PRELUDE = pftijah_prelude;
.EPILOGUE = pftijah_epilogue;

.END pftijah;
@mil
module("pathfinder");

###
# This file contains implementations of some of the SRA operators 
# to run on the TIJAH Light index.
#
# Based on code by the TIJAH team (Vojkan, Thijs)
#
# Additional retrieval models by Henning Rode 
#
# Authors: Roel van Os <roel.van.os@glacimonto.nl>
#          Henning Rode <h.rode@cs.utwente.nl>
#
###

# Stemming setup
const STEM_OFF := 1;
const STEM_ON := 2;

# Type of the size used
const SIZE_ENTITY := 1;
const SIZE_TERM := 2;

#default
var scoreBase := 1;

const TERM_NUM := 10000;
const ENTITY_NUM := 10000;

var collName := "PFX";
var collHeight := 10;

if (view_bbp_name().reverse().exist("tj_collName")) {
	if (bat("tj_collName").count() > 0) {
		var name := bat("tj_collName").fetch(0);
		tj_setCollName(name);
	}
}

PROC tj_setCollName(str name) : void := 
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(name))) {
		printf("Error: Selected collection does not exist. Collection name is not changed.\n");
		fflush(stdout());
		quit(); 
	}
	collName := name;
	collHeight := bat("tj_" + collName + "_param").find("height").int();
	printf("Work collection is set to %s (with height %d)\n", collName, collHeight);
	fflush(stdout());
}

PROC tj_setScoreBase(int default) : void :=
{
	scoreBase := default;
}

const virtRoot := 0@0;


################################################################################
# SELECTION
################################################################################

PROC select_root() : bat :=
{
    # Because TIJAH expects all documents in a collection to be contained by one 
    # "virtual root" element, his behaviour should be emulated by the light index. 
    # An element with preorder oid(0) will indicate that it is the collection root.
    var root_reg := new(oid,dbl,1);
    
    root_reg.insert( virtRoot, dbl(scoreBase) );
    return root_reg;
}

PROC select_node(str name) : bat :=
{
    var start_time := time();

    var tids := bat("tj_globalTags").select(name);
    if (tids.count() = 0) return new(oid,dbl);
    var tid := tids.reverse().fetch(0);
    var result := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TagIndex"),
    				  bat("tj_" + collName + "_Tags") );
    result := result.reverse().sort().project(dbl(scoreBase)); 

    var end_time := time();
    #printf( "select_node: \t\t%d ms\n", end_time - start_time );
    return result;
}

PROC select_node(str name, bit e_class) : bat :=
{
    if ( e_class ) printf( "WARNING: equivalences are not yet supported!\n" );
    return select_node(name);
}

PROC select_term(str name) : bat :=
{
    var start_time := time();
    # Select the term positions from the global term dictionary. 
   
    var tid := bat("tj_globalTerms").reverse().find(name);
    var result := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    result := result.reverse().sort().project(dbl(1)); 
    
    var end_time := time();
    printf( "select_term: \t\t%d ms\n", end_time - start_time );
    return result;
}

PROC select_term(str name, int stemming) : bat := 
{
    # perform stemming
    
    if ( stemming = STEM_ON ) printf( "WARNING: stemming is not yet supported!\n" );
    
    return select_term( name );
}

PROC select_phrase(bat[void,oid] terms) : bat[oid,dbl] :=
{
    var start_time := time();
    # Select the term positions from the global term dictionary. 
   
    var tid := terms.fetch(0);
    var tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    var res := tmp.reverse();
    var j := terms.count();
    var i := 1; 
    while (i < j)
    {
        tid := terms.fetch(i);
        tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
        res := res.semijoin(tmp.[int]().[-](i).[oid]().reverse());   
	i :+= 1;
    }	
    
    res := res.sort().project(dbl(1)); 
    
    var end_time := time();
    printf( "select_phrase: \t\t%d ms\n", end_time - start_time );
    return res;
}


################################################################################
# CONTAINMENT
################################################################################


#####################################
# left CONTAINED_BY right:
#
#   +--------------------+
#   |       right        |
#   | +---------------+  |
#   | |      left     |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it is contained a region in right
#
#####################################
PROC contained_by(bat left, bat right) : bat :=
{
    var start_time := time();
    
    # Check for the virtual root
    if ( and((count( left ) = 1),(left.reverse().fetch(0) = virtRoot))) 
            return new(oid,dbl);
    if ( and((count( right ) = 1),(right.reverse().fetch(0) = virtRoot))) 
            return left;
    
    # We use the pathfinder loop-lifted descendant algorithm to calculate containment.
    
    # Items contains the context nodes for the descendant step: this is the right side argument to contained_by.
    # The table must be [void,oid], so:
    var items := right.mirror().mark(0@0).reverse();
    
    # Candidates contains the left side argument. This must also be [void,oid]:
    var candidates := left.mirror().mark(0@0).reverse();
    
    var pre_size := load( "tj_" + collName + "_size");
            
    # Check the order of the items:
    items.chk_order();
    
    # Call the descendant algorithm: it returns [ancestor, descendant] pairs!
    var res := ll_descendant(items, items, pre_size, candidates, collHeight, false, false, min(items), max(items), false);
    
    # Attach the scores to the resulting nodes again:
    var result := res.reverse().mirror().join(left);
    
    var end_time := time();
    printf( "contained_by: \t\t%d ms\n", end_time - start_time );
    return result;
}


#####################################
# left CONTAINING right:
#
#   +--------------------+
#   |       left         |
#   | +---------------+  |
#   | |      right    |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it contains a region in right
#
#####################################
PROC containing(bat left, bat right) : bat :=
{
    var start_time := time();
    
    # Check for the virtual root
    if ( and((count( left ) = 1),(left.reverse().fetch(0) = virtRoot))) 
            return right;
    if ( and((count( right ) = 1),(right.reverse().fetch(0) = virtRoot))) 
            return new(oid,dbl);
    
    # We use the pathfinder loop-lifted descendant algorithm to calculate containment.
    
    # Items contains the context nodes for the descendant step: this is the left side argument to containing.
    # The table must be [void,oid], so:
    var items := left.mirror().mark(0@0).reverse();
    
    # Candidates contains the right side argument. This must also be [void,oid]:
    var candidates := right.mirror().mark(0@0).reverse();
    
    var pre_size := load( "tj_" + collName + "_size");
    
    # Check the order of the items:
    items.chk_order();
    
    # Call the descendant algorithm: it returns [ancestor, descendant] pairs!
    var res := ll_descendant(items, items, pre_size, candidates, collHeight, false, false, min(items), max(items), false);
    
    # Attach the scores to the resulting nodes again:
    var result := res.mirror().kunique().join(left);
    
    var end_time := time();
    printf( "containing: \t\t%d ms\n", end_time - start_time );
    return result;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

PROC p_containing_q_NLLR_batloop_anc(bat[oid,dbl] left, bat[void,oid] terms, flt lmbd) : bat[oid,dbl] :=
{
     var t1 := time();
     var tind := bat("tj_" + collName + "_TermIndex");
     var pres := bat("tj_" + collName + "_Terms");
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := pres.count();
     _lmbd :*= collFrq; 

     var t2 := time();
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var t5 := time();
	  var oid_min := int(tind.fetch($t));
	  var oid_max := int(tind.fetch(int($t) + 1)) - 1;
	  var tid_pre := pres.slice(oid_min, oid_max);
          var cands := tid_pre.reverse().sort().mark(0@0);
	  var fac := tid_pre.count();
	  tid_pre := nil;
	  if (fac > 0)
	  {
	       fac := _lmbd / fac;
               var elems := scj_anc(bat("tj_" + collName + "_size"), cands, collHeight, cands.count() * 4); 
	       var t6 := time();
	       elems := left.semijoin(elems);
               cands := cands.reverse();
               var elem_frq := bat("tj_" + collName + "_size").semijoin(elems);
               elems := elems.mark(0@0).reverse();
               var iter := elems.mirror();
               #printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size").count());
	       #fflush(stdout());
	       var elem_termpre := ll_descendant(iter, 
     						 elems, 
						 bat("tj_" + collName + "_size"), 
						 cands, 
						 collHeight, 
						 false, false, min(iter), max(iter), false);
               var t7 := time();
	       cands := nil;
	       iter := nil;
     	       elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
	       var tmp := elem_termpre.reverse().histogram();
               elem_termpre := nil;
	       tmp := [dbl](tmp);
	       tmp := [/](tmp, elem_frq);
	       tmp := [*](tmp, fac);
	       tmp := [+](tmp, 1);
	       tmp := [log](tmp);
	       var t8 := time();
	       doc_prob.insert(tmp);
	       var t9 := time();
     printf("inside loop: ll_desc (%d), insert (%d), total (%d)\n", t7 - t6, t9 - t8, t9 - t5);
     fflush(stdout());
	       
          }
     }
     var t3 := time();
     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), left.mark(0@0));
     res := res.[/](terms.count()).[+](left);
     var t4 := time();
     
     printf("p_containing_q: loop (%d), total (%d)\n", t3 - t2, t4 - t1);
     fflush(stdout());
     return res;
}

PROC p_containing_q_NLLR_batloop(bat[oid,dbl] left, bat[void,oid] terms, flt lmbd) : bat[oid,dbl] :=
{
     var t1 := time();
     var tind := bat("tj_" + collName + "_TermIndex");
     var pres := bat("tj_" + collName + "_Terms");
     var elem_frq := bat("tj_" + collName + "_size").semijoin(left);
     var elems := left.mark(0@0).reverse();
     var iter := elems.mirror();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := pres.count();
     _lmbd :*= collFrq; 

     var t2 := time();
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var t5 := time();
	  var oid_min := int(tind.fetch($t));
	  var oid_max := int(tind.fetch(int($t) + 1)) - 1;
	  var tid_pre := pres.slice(oid_min, oid_max);
          var cands := tid_pre.reverse().sort().mark(0@0).reverse();
	  var fac := tid_pre.count();
	  if (fac > 0)
	  {
	       fac := _lmbd / fac;
	       var t6 := time();
               printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size").count());
	       fflush(stdout());
	       var elem_termpre := ll_descendant(iter, 
     						 elems, 
						 bat("tj_" + collName + "_size"), 
						 cands, 
						 collHeight, 
						 false, false, min(iter), max(iter), false);
               var t7 := time();
	       cands := nil;
	       iter := nil;
	       tid_pre := nil;
     	       elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
	       var tmp := elem_termpre.reverse().histogram();
               elem_termpre := nil;
	       tmp := [dbl](tmp);
	       tmp := [/](tmp, elem_frq);
	       tmp := [*](tmp, fac);
	       tmp := [+](tmp, 1);
	       tmp := [log](tmp);
	       var t8 := time();
	       doc_prob.insert(tmp);
	       var t9 := time();
     printf("inside loop: ll_desc (%d), insert (%d), total (%d)\n", t7 - t6, t9 - t8, t9 - t5);
     fflush(stdout());
	       
          }
     }
     var t3 := time();
     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), elems.reverse());
     res := res.[/](terms.count()).[+](left);
     var t4 := time();
     
     printf("p_containing_q: loop (%d), total (%d)\n", t3 - t2, t4 - t1);
     fflush(stdout());
     return res;
}

PROC p_containing_q_NLLR_batloop_aggregation(bat[oid,dbl] left, bat[void,oid] terms, flt lmbd) : bat[oid,dbl] :=
{
     var t1 := time();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := bat("tj_" + collName + "_Terms").count();
     _lmbd :*= collFrq; 
     var t2 := time();
     var tid_pre := indexfetchjoin(terms, bat("tj_" + collName + "_TermIndex"), bat("tj_" + collName + "_Terms") );
     var t3 := time();

     var elems := left;

     var tid_frq := histogram(tid_pre.reverse());
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;
     var elem_frq := bat("tj_" + collName + "_size").semijoin(elems);
     elems := elems.mark(0@0).reverse();
     var cands := tid_pre.reverse().sort().mark(0@0).reverse();
     var iter := elems.mirror();
     printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size").count());
	       fflush(stdout());
     var t4 := time();
     var elem_termpre := ll_descendant(	iter, 
     					elems, 
					bat("tj_" + collName + "_size"), 
					cands, 
					collHeight, 
					false, false, min(iter), max(iter), false);
     var t5 := time();
     elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
     var elem_tid := elem_termpre.join(tid_pre.reverse());
     tid_pre := nil;
     elem_termpre := nil;
     
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var tmp := elem_tid.select($t);
	  var fac := _lmbd / tmp.count();
	  tmp := tmp.reverse().histogram();
	  tmp := [dbl](tmp);
	  tmp := [/](tmp, elem_frq);
	  tmp := [*](tmp, fac);
	  tmp := [+](tmp, 1);
	  tmp := [log](tmp);
	  doc_prob.insert(tmp);
     }

     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), elems.reverse());
     res := res.[/](terms.count()).[+](left);
     
     var t6 := time();
    
     printf("p_containing_q: indexfetchjoin (%d), ll_descendant (%d), total (%d)\n", t3 - t2, t5 - t4, t6 - t1);
     fflush(stdout());
     return res;
}

PROC p_containing_q_NLLR_batloop_aggregation_anc(bat[oid,dbl] left, bat[void,oid] terms, flt lmbd) : bat[oid,dbl] :=
{
     var t1 := time();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := bat("tj_" + collName + "_Terms").count();
     _lmbd :*= collFrq; 
     var t2 := time();
     var tid_pre := indexfetchjoin(terms, bat("tj_" + collName + "_TermIndex"), bat("tj_" + collName + "_Terms") );
     var t3 := time();

     var cands := tid_pre.reverse().sort().mark(0@0);
#     printf("scj_anc: #items: %d, #pre_size: %d, upperbound %d\n", cands.count(), bat("tj_" + collName + "_size").count(), cands.count() * 4);
#	       fflush(stdout());
     var t7 := time();
     var elems := scj_anc(bat("tj_" + collName + "_size"), cands, collHeight, cands.count() * 4); 
     var t8 := time();
     elems := left.semijoin(elems);
     cands := cands.reverse();

     var tid_frq := histogram(tid_pre.reverse());
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;
     var elem_frq := bat("tj_" + collName + "_size").semijoin(elems);
     elems := elems.mark(0@0).reverse();
     var iter := elems.mirror();
     printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size").count());
	       fflush(stdout());
     var t4 := time();
     var elem_termpre := ll_descendant(	iter, 
     					elems, 
					bat("tj_" + collName + "_size"), 
					cands, 
					collHeight, 
					false, false, min(iter), max(iter), true);
     var t5 := time();
     elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
     var elem_tid := elem_termpre.join(tid_pre.reverse());
     tid_pre := nil;
     elem_termpre := nil;
     
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var tmp := elem_tid.select($t);
	  var fac := _lmbd / tmp.count();
	  tmp := tmp.reverse().histogram();
	  tmp := [dbl](tmp);
	  tmp := [/](tmp, elem_frq);
	  tmp := [*](tmp, fac);
	  tmp := [+](tmp, 1);
	  tmp := [log](tmp);
	  doc_prob.insert(tmp);
     }

     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), elems.reverse());
     res := res.[/](terms.count()).[+](left);
     
     var t6 := time();
    
     printf("p_containing_q: indexfetchjoin (%d), scj_anc (%d), ll_descendant (%d), total (%d)\n", t3 - t2, t8 - t7, t5 - t4, t6 - t1);
     fflush(stdout());
     return res;
}

PROC p_containing_q_NLLR(bat[oid,dbl] left, bat[void,oid] terms, flt lmbd) : bat[oid,dbl] :=
{
     var t1 := time();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := bat("tj_" + collName + "_Terms").count();
     _lmbd :*= collFrq; 
     var t2 := time();
     var tid_pre := indexfetchjoin(terms, bat("tj_" + collName + "_TermIndex"), bat("tj_" + collName + "_Terms") );
     var t3 := time();
     var tid_frq := histogram(tid_pre.reverse());
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;
     var elem_frq := bat("tj_" + collName + "_size").semijoin(left);
     var elems := left.mark(0@0).reverse().chk_order();
     var t4 := time();
     var elem_termpre := ll_descendant(	elems, 
     					elems, 
					bat("tj_" + collName + "_size"), 
					tid_pre.reverse().sort().mark(0@0).reverse(), 
					collHeight, 
					false, false, min(elems), max(elems), false);
     var t5 := time();
     var elem_tid := elem_termpre.join(tid_pre.reverse());
     tid_pre := nil;
     elem_termpre := nil; 
     var dtf_elem := elem_tid.mark(0@0).reverse();
     var dtf_tid := elem_tid.reverse().mark(0@0).reverse();
     elem_tid := nil;
     var tmp :=  CTderive(dtf_elem, dtf_tid);
     var dtf_frq := CThistogram(tmp).[dbl]();
     tmp := nil;
     dtf_frq := [/](dtf_frq, dtf_elem.join(elem_frq));
     elem_frq := nil;
     dtf_frq := [*](dtf_frq, dtf_tid.join(_tid_frq));
     _tid_frq := nil;
     dtf_frq := [+](dtf_frq, 1);
     dtf_frq := [log](dtf_frq);
     var res := {sum}(dtf_frq, dtf_elem, elems.reverse());
     res := res.[/](terms.count()).[+](left);
     var t6 := time();
    
     printf("p_containing_q: indexfetchjoin (%d), ll_descendant (%d), total (%d)\n", t3 - t2, t5 - t4, t6 - t1);
     fflush(stdout());
     return res;
}

PROC p_containing_t_LMs(bat left, bat right, flt lmbd, int size_type) : bat := 
{
    var start_time := time();
    var lambda;
    var m_lambda;
    var forgnd_prob := new(oid,dbl,ENTITY_NUM);
    var bckgnd_prob;

    var res_reg := new(oid,dbl,ENTITY_NUM);

    forgnd_prob := reg_freq(left,right,size_type);

    if (size_type = SIZE_ENTITY) {
        # Compute right size / collection entity size
        
        var pre_pfpre := bat("tj_" + collName + "_pfpre");
        bckgnd_prob := dbl(count(right))/dbl(count(pre_pfpre));

        pre_pfpre := nil;
    }

    else if (size_type = SIZE_TERM) {
        # Compute right size / collection term size
        
        var pre_tid  := bat("tj_" + collName + "_tid");
        var pre_pfpre := bat("tj_" + collName + "_pfpre");
        var terms := pre_tid.mirror().kdiff( pre_pfpre.mirror() );

        bckgnd_prob := dbl(count(right))/dbl(count(terms));
        
        var pre_tid := nil;
        var pre_pfpre := nil;
        var terms := nil;
    }

    if (bckgnd_prob = dbl(0)) {
        printf( "Minimum collection frequency has not been computed yet!\n" );
        # Assign minimum collection frequency
        
        bckgnd_prob := min(col_freq());
    }

    # Precompute lambda values
    lambda := dbl(lmbd);
    m_lambda := dbl(1)-lambda;

    if (scoreBase = 0)
        res_reg := [+](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));
    else if (scoreBase = 1)
        res_reg := [*](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));
    
    
    var end_time := time();
    printf( "p_containing_t_LMs: \t%d ms\n", end_time - start_time );
    return res_reg;
}

# Returns the collection frequency table (should be precomputed, but is calculated for now)
PROC col_freq() : bat :=
{
    var start_time := time();
    var allterms := bat("tj_globalTerms").sort().mark(0@0).reverse();
    var alltermpos := indexfetchjoin(allterms, bat("tj_PFX_TermIndex"), bat("tj_PFX_Terms"));
    var col_freqs := [dbl]({count}(alltermpos));

    printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return col_freqs;
}


# Returns the collection frequency of the term with the indicated tid
PROC col_freq(oid tid) : dbl :=
{
    var start_time := time();
    var alltermpos := indexfetchjoin(new(int,oid).insert(0,tid), bat("tj_PFX_TermIndex"), bat("tj_PFX_Terms"));
    var col_freqs := {count}(alltermpos);
    var result := dbl(col_freqs.fetch(0));
    printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return result;
}

# For each region in left, count the number of regions in right it contains.
PROC reg_freq(bat left, bat right, int size_type) : bat    :=    
{
    var start_time := time();
    
    var reg_size;
    var ctx_tmp := new(oid,dbl,ENTITY_NUM);
    var ctx_tmp2 := new( oid, int, ENTITY_NUM );
    
    var items := left.mirror().mark(0@0).reverse();
    
    var candidates := right.mirror().mark(0@0).reverse();
    
    var pre_size := load( "tj_" + collName + "_size");

    # Check the order of the items:
    items.chk_order();
    
    var res := ll_descendant(items, items, pre_size, candidates, collHeight, false, false, min(items), max(items), false);
    
    ctx_tmp2 := {count}(res);
    
    var num_terms := ctx_tmp2;
    var prob_tmp  := [dbl](num_terms);
    
    if (size_type = SIZE_ENTITY)
        reg_size := size_entity(left);
    else if (size_type = SIZE_TERM)
        reg_size := size_term(prob_tmp);
    
    prob_tmp := [/](prob_tmp,prob_tmp.mirror().join(reg_size));

    prob_tmp := {sum}(prob_tmp.sunion(ctx_tmp));

    var end_time := time();
    printf( "reg_freq: \t\t%d ms\n", end_time - start_time );
    return prob_tmp;
        
}

# Calculate the term size of the region: how many terms does it contain?
PROC size_term( bat region ) : bat := 
{
    var start_time := time();
    
    # all terms:
    var pre_tid   := bat("tj_" + collName + "_tid");
    var pre_pfpre := bat("tj_" + collName + "_pfpre");
    var terms     := pre_tid.mirror().kdiff( pre_pfpre.mirror() );
    
    var items      := region.mirror().mark(0@0).reverse();
    var candidates := terms.mirror().mark(0@0).reverse();
    
    # Alternative:
    #var candidates      := bat("tj_" + collName + "_Terms" ).reverse().sort().mark(0@0).reverse();
    
    var pre_size := load( "tj_" + collName + "_size");
   
    # Check the order of the items:
    items.chk_order();
    
    var res := ll_descendant(items, items, pre_size, candidates, collHeight, false, false, min(items), max(items), false);
    
    var result := [dbl]({count}(res));
   
    var end_time := time();
    printf( "size_term: \t\t%d ms\n", end_time - start_time );
    return result;
}

# Calculate the entity size of the region: how many entities does it contain?
PROC size_entity( bat region ) : bat :=
{
    var start_time := time();
    
    
    # All entities:
    var pre_pfpre := bat("tj_" + collName + "_pfpre");

    var items      := region.mirror().mark(0@0).reverse();
    var candidates := pre_pfpre.mirror().mark(0@0).reverse();
    
    var pre_size := load( "tj_" + collName + "_size");
    
    # Check the order of the items:
    items.chk_order();
    
    var res := ll_descendant(items, items, pre_size, candidates, collHeight, false, false, min(items), max(items), false);
    
    var result := {count}(res);

    var end_time := time();
    printf( "size_entity: \t\t%d ms\n", end_time - start_time );
    return result;
}

# The following functions have been copied without change from algebra_procs.mil


################################################################################
# SET OPERATORS
################################################################################

### UNION
PROC union(bat left, bat right) : bat :=
{

	return left.kunion(right);

}

### INTERSECTION
PROC intersect(bat left, bat right) : bat := 
{

	return left.kintersect(right);

}


################################################################################
# SCALING
################################################################################

PROC scale(bat region, flt importance) : bat := 
{

	var res_reg := new(oid,dbl,ENTITY_NUM);
	res_reg := [*](dbl(importance),region);
	return res_reg;

}


################################################################################
# PROBABILISTIC SET OPERATORS
################################################################################

PROC or_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC or_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC or_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

PROC or_exp(bat left, bat right, int A) : bat := 
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC or_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC or_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC and_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC and_exp(bat left, bat right, int A) : bat :=
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC and_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC and_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

################################################################################
# PRIOR
################################################################################

PROC prior_ls(bat region, int size_type) : bat := 
{

	var ctx_size := new(oid,dbl,ENTITY_NUM);
	var res_reg := new(oid,dbl,ENTITY_NUM);

	if (size_type = SIZE_ENTITY)
		ctx_size := size_entity(region);
	else if (size_type = SIZE_TERM)
		ctx_size := size_term(region);

	res_reg := [+]([log](region.select(dbl(0),dbl(nil),false,false)),[log](ctx_size));
	res_reg := [-](region.select(dbl(0)).project(min(res_reg)),dbl(1)).kunion(res_reg);

	# res_reg := [+]([log](region),[*](dbl(3.0),[log](ctx_size)));

	# var ref_reg := new(oid,dbl,ENTITY_NUM);
	# var ref_size := new(oid,dbl,ENTITY_NUM);

	# var entity_name := load(collName+"entity_name");

	# var ref_name := entity_name.join(region.mirror().join(entity_name).reverse().mirror());
	# ref_reg := ref_name.project(dbl(1));

	# if (size_type = SIZE_ENTITY) {
	#	ctx_size := size_entity(region);
	#	ref_size := size_entity(ref_reg);
	# }
	# else if (size_type = SIZE_TERM) {
	#	ctx_size := size_term(region);
	#	ref_size := size_term(ref_reg);
	# }

	# ref_size := region.mirror().join(entity_name).join({sum}(ref_size.reverse().join(ref_name).reverse()));

	# res_reg := [*](region,[/](ctx_size,ref_size));

	return res_reg;

}
#ADDHELP("prior_ls", "vojkan", "March 16, 2005",
#"Adds element prior based on element length to the region score.",
#"TIJAH");



################################################################################
# ORDER
################################################################################

PROC order_regions(bat region) : bat :=
{

	region := region.reverse().sort_rev().reverse();

	return region;

}
#ADDHELP("order_regions", "vojkan", "March 29, 2005",
#"Order regions in descending order based on their score values.",
#"TIJAH");



PROC tj_global_init() : void 
{
	printf("# Initializing Pathfinder-Tijah integration package.\n");
	new(oid,str).persists(true).bbpname("tj_globalTerms");
	new(oid,str).persists(true).bbpname("tj_globalTags");
	new(oid,str).persists(true).bbpname("tj_collName");
	commit();
}

##########################################
# Collection Management Functions
#
##########################################

PROC tj_coll_init(str collName, str stemmer) : void
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}

	new(void,str).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_name");
	new(void,int).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_firstpre");
	new(str,str).persists(true).bbpname("tj_" + collName + "_param");

	new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_tid");
	new(void,int).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_size"); # incomplete, should be void/int
	new( oid,oid).persists(true).bbpname("tj_" + collName + "_pfpre");
	
	var coll_oid;
	if (bat("tj_collName").count() = 0) { coll_oid := 0@0; }
     	else { coll_oid := oid(int(bat("tj_collName").reverse().max()) + 1); }
	bat("tj_collName").insert(coll_oid, collName);
	#
	# now set the parameters for this collection
	#
	bat("tj_" + collName + "_param").insert("name",collName);
	bat("tj_" + collName + "_param").insert("height","0");
	if (stemmer = "") bat("tj_" + collName + "_param").insert("stemmer","nostemming");
	else bat("tj_" + collName + "_param").insert("stemmer",stemmer);
	bat("tj_" + collName + "_param").insert("preExpansion","4");
	bat("tj_" + collName + "_param").insert("status","building");
	#
	commit();
}

PROC tj_global_remove() : void
{
	bat("tj_collName")@batloop(){
		tj_coll_remove($t);
	}
	bat("tj_globalTerms").persists(false);
	bat("tj_globalTags").persists(false);
	bat("tj_collName").persists(false);
	commit();
}

PROC tj_coll_remove() : void
{
	tj_coll_remove(collName);
}

PROC tj_coll_remove(str collName) : void
{
	bat("tj_" + collName + "_doc_name").persists(false);
	bat("tj_" + collName + "_doc_firstpre").persists(false);
	bat("tj_" + collName + "_param").persists(false);
	bat("tj_" + collName + "_tid").persists(false);
	bat("tj_" + collName + "_size").persists(false);
	bat("tj_" + collName + "_pfpre").persists(false);
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) {
		bat("tj_" + collName + "_TermIndex").persists(false);
		bat("tj_" + collName + "_Terms").persists(false);
		bat("tj_" + collName + "_TagIndex").persists(false);
		bat("tj_" + collName + "_Tags").persists(false);
	}
        
	var coll_oid := bat("tj_collName").reverse().find(collName);
	bat("tj_collName").delete(coll_oid);
	commit();
}

PROC tj_collection() : BAT[void,bat]
{
	return tj_collection(collName);
}

PROC tj_collection(str collName) : BAT[void,bat]
{
	var tjCollBat := new(void,bat).seqbase(0@0);

	tjCollBat.append(bat("tj_globalTerms"));
	tjCollBat.append(bat("tj_globalTags"));
	tjCollBat.append(bat("tj_" + collName + "_doc_name"));
	tjCollBat.append(bat("tj_" + collName + "_doc_firstpre"));
	tjCollBat.append(bat("tj_" + collName + "_param"));
	tjCollBat.append(bat("tj_" + collName + "_tid"));
	tjCollBat.append(bat("tj_" + collName + "_size"));
	tjCollBat.append(bat("tj_" + collName + "_pfpre"));
	return tjCollBat;
}

PROC tj_createCollection(str doc, str url, str stemmer) : BAT[void,bat]
{
	return tj_createCollection(collName, doc, url, stemmer);
}

PROC tj_createCollection(str collName, str doc, str url, str stemmer) : void
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(collName))) {
		tj_coll_init(stemmer);
	}
	
	tj_url2Collection(collName, doc, url, "");
	tj_finalize(collName);
}

PROC tj_url2Collection(str doc, str url, str selTagList) : void
{
	tj_url2Collection(collName, doc, url, selTagList);
}

PROC tj_url2Collection(str collName, str doc, str url, str selTagList) : void
{
	var ws := create_ws();
	if (not(bat("doc_name").reverse().exist(doc))) {
		shred_doc(url,doc);
	}
	add_doc(ws,doc);
        
	bat("tj_globalTerms").access(BAT_WRITE);
	bat("tj_globalTags").access(BAT_WRITE);
        
	tj_add2collection(tj_collection(collName),ws,doc,selTagList);
	destroy_ws(ws);
	var height1 := bat("doc_height").fetch(bat("doc_name").reverse().find(doc));
        
        var coll_oid := bat("tj_collName").reverse().find(collName);
	var height2 := bat("tj_" + collName + "_param").find("height").int();
	bat("tj_" + collName + "_param").replace("height", max(height1,height2).str());
	bat("tj_" + collName + "_param").replace("status","building");
        commit();	
}

PROC tj_finalize() : void
{
	tj_finalize(collName);
}

PROC tj_finalize(str collName) : void
{
	# Finalize one collection. No documents should be added after this
	tj_buildIRindex(collName);
	#
	bat("tj_" + collName + "_param").replace("status","finalized");
	#
	var gterm_sort := bat("tj_globalTerms").reverse().sort().reverse();
	bat("tj_globalTerms").persists(false);
	var gtag_sort := bat("tj_globalTags").reverse().sort().reverse();
	bat("tj_globalTags").persists(false);
	commit();
	gterm_sort.persists(true);
	gterm_sort.bbpname("tj_globalTerms");
	gtag_sort.persists(true);
	gtag_sort.bbpname("tj_globalTags");
	bat("tj_globalTerms").access(BAT_READ);
	bat("tj_globalTags").access(BAT_READ);
        
	commit(); 
}

PROC tj_dump() : void
{
	tj_dump(collName);
}

PROC tj_dump(str collName) : void
{
	bat("tj_" + collName + "_param").print();
	bat("tj_" + collName + "_doc_name").print();
	bat("tj_" + collName + "_doc_firstpre").print();
	# print(bat("tj_" + collName + "_doc_name"),bat("tj_" + collName + "_doc_firstpre"));
	bat("tj_globalTerms").print();
	bat("tj_globalTags").print();
	print(bat("tj_" + collName + "_tid"));
	print(bat("tj_" + collName + "_size"));
	print(bat("tj_" + collName + "_pfpre"));
	# print(bat("tj_" + collName + "_tid"),join(bat("tj_" + collName + "_tid"),bat("tj_globalTerms")));
	# print(bat("tj_" + collName + "_height"));
}

# mil-code to build faster IR indices
PROC tj_buildIRindex() : void :=
{
	tj_buildIRindex(collName);
}

PROC tj_buildIRindex(str collName) : void :=
{
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) {
		bat("tj_" + collName + "_TermIndex").persists(false);
		bat("tj_" + collName + "_Terms").persists(false);
		bat("tj_" + collName + "_TagIndex").persists(false);
		bat("tj_" + collName + "_Tags").persists(false);
		commit();
	}
	var tmp := bat("tj_" + collName + "_tid").kdiff(bat("tj_" + collName + "_pfpre"));
        tmp := tmp.reverse().sort();
	var termindex := tmp.mark(0@0).reverse().offsetindex(bat("tj_globalTerms").count() + 1);
	var terms := tmp.reverse().mark(0@0).reverse();
	termindex.persists(true).bbpname("tj_" + collName + "_TermIndex");
	terms.persists(true).bbpname("tj_" + collName + "_Terms");
	tmp := nil;
	termindex := nil;
	terms := nil;
	commit();
	
	tmp := bat("tj_" + collName + "_tid").semijoin(bat("tj_" + collName + "_pfpre"));
        tmp := tmp.reverse().sort();
	var tagindex := tmp.mark(0@0).reverse().offsetindex(bat("tj_globalTags").count() + 1);
	var tags := tmp.reverse().mark(0@0).reverse();
	tagindex.persists(true).bbpname("tj_" + collName + "_TagIndex");
	tags.persists(true).bbpname("tj_" + collName + "_Tags");
	tmp := nil;
	tagindex := nil;
	tags := nil;
	commit();
}

######################################
# PF interface functions
#
######################################

PROC tijah2pf(BAT[oid,dbl] pre_score) : BAT :=
{
	var docpre := bat("tj_" + collName + "_doc_firstpre").[oid]();
	var pfpre :=  bat("tj_" + collName + "_pfpre");
	
	var item := pre_score.hmark(0@0);
	var score := pre_score.tmark(0@0);
	var iter := item.mirror();
	var frag := [find_lower](const docpre.reverse().mark(0@0), item);
	item := item.join(pfpre).sort().tmark(0@0);
	
	var res := new(void,bat);
	res.append(iter);
	res.append(item);
	res.append(frag);
	res.append(score);
	return res;
}

# align_frag assumes the following variable to be global to its scope:
# frag, kind, ipik, ws
PROC align_frag() : void :=
{
	var needed_docs := bat("tj_" + collName + "_doc_name").semijoin(frag.tunique());
	var loaded_docs := ws.fetch(DOC_LOADED).reverse();
	needed_docs@batloop()
	{
		if (not(loaded_docs.exist($t))) {
			ws.add_doc($t); }
	}
	var fid_pffid := needed_docs.join(ws.fetch(DOC_LOADED).reverse());
	frag := frag.join(fid_pffid).sort().tmark(0@0);
	kind := set_kind(frag, ELEM);
	ipik := iter;
}

@h

/* empty */
@c
#include <monet.h>
#include <gdk.h>

int executeMIL(char* str) {
	Cntxt stk = 0; /* OK??? */
	ValRecord res;

	if ( 0 ) stream_printf(GDKout,"# executeMIL(\"%s\")\n",str);
	int ret = interpret_str(stk,str,&res);
	if ( ret==-TOK_RETURN ) {
	    VALclear(&res);
	    ret = 1;
	} else if (ret >= 0) {
	    ret = 1;
	} else {
	    ret = 0;
	}
	return ret;
}

int CMDtijah_command(bit* res, str command) {
	if ( 0 ) stream_printf(GDKout,"# tijah_command(%s)\n",(char*)command);
	*res = executeMIL(command); /* OK */
	return GDK_SUCCEED;
}

extern char* tijahParse(char* pfx, char* query, char** errBUFF);

static int oldScoreCounter = 0;

int CMDtijah_query(BAT** res, str pfx, str q) {
	/* INCOMPLETE, complete Collection BAT should be parameter here */
	if ( 0 ) stream_printf(GDKout,"# tijah_	query(\"%s\",\"%s\")\n",pfx,q);
	/* */
	char* err;
	char* mil;

	if ( !(mil=tijahParse(pfx,q,&err)) ) {
            GDKerror("CMDtijah_query: %s.\n", err);
	    return GDK_FAIL;
	}
	if ( 1 && !executeMIL(mil) ) {
            GDKerror("CMDtijah_query: execute MIL failed.\n");
	    return GDK_FAIL;
	}
	/* */
	BAT* scoreBAT = BATdescriptor( BBPindex("nexi_result") );

	if ( ! scoreBAT ) {
            GDKerror("CMDtijah_query: fail to load score bat: \"%s\".\n", "nexi_result");
	    return GDK_FAIL;
        }
	char buff[32];
	sprintf(&buff[0],"%s_del%d","nexi_result",oldScoreCounter++);
	if ( BATrename(scoreBAT,(str)&buff[0]) == str_nil ) {
            GDKerror("CMDtijah_query: fail to rename score bat: \"%s\".\n", &buff[0]);
	    return GDK_FAIL;
	}
	BATmode(scoreBAT,TRANSIENT);

	*res = scoreBAT;

	return GDK_SUCCEED;
}

int CMDoffsetindex ( BAT** result, BAT* tid, int* res_size )
{
	char *name = "TJoffsetindex";
	BAT *res = NULL;
        BUN p, q, dst = NULL;
	oid t, s;
	int bs_res, x;

	/* --------------------------- checks ---------------------------------- */

	BATcheck(tid, name);
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: index-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}
	if (!(BAThdense(tid)))
    	{
        	GDKerror("%s: index-bat must have a dense head.\n", name);
    		return GDK_FAIL;
	}
		
	res = BATnew(TYPE_void, TYPE_oid, *res_size);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, *res_size);
            	return(GDK_FAIL);
        }
	bs_res = BUNsize(res);
	dst = BUNlast(res);
    
	t = (oid)0;
	*(oid*)dst = (oid)0;
	dst += bs_res;
	
	BATloopFast(tid, p, q, x)
	{
		s = *(oid*) BUNtail(tid, p);
		if (t != s)
		{
			for(; t < s; t++)
			{
				*(oid*)dst = BUNindex(tid, p);
				dst += bs_res; 
			}
		}
	}

	s = (oid) (*res_size - 1);
	for(; t < s; t++)
	{
		*(oid*)dst = BUNindex(tid, p);
		dst += bs_res; 
	}
	
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->tsorted = GDK_SORTED;
        BATkey (res, TRUE);
	BATset(res, TRUE);
	BATseqbase(res, 0);
	
	*result = res;
	return GDK_SUCCEED;
}	
	
int CMDindexfetchjoin ( BAT** result, BAT* tid, BAT* index, BAT* pre )
{
	char *name = "TJindexfetchjoin";
	BAT *res = NULL;
        BUN dst = NULL;
	int bs_pre = BUNsize(pre);
	int bs_res;

	int ressize = 0;
	oid t, *ind;
	BUN p, q;
        int x, j, i = 0;
	bit one_tid = FALSE;
    
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tid, name);
	BATcheck(index, name);
	BATcheck(pre, name);
	
        if (BATcount(tid) <= 1) one_tid = TRUE;
	
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	ind = GDKmalloc(sizeof(oid) * BATcount(tid) * 3);
	
	BATloopFast(tid, p, q, x) {
		t = *(oid*) BUNtail(tid, p);
		ind[i++] = t;
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t));
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t + 1));
		ressize += (ind[i - 1] - ind[i - 2]);
	}
	
	res = BATnew(TYPE_oid, TYPE_oid, ressize);
	bs_res = BUNsize(res);
	dst = BUNlast(res);
	
	j = 0;
	while (j < i) {
        	t = ind[j++];
		p = BUNptr(pre, ind[j++]);
		q = BUNptr(pre, ind[j++]);
		for (; p < q; p += bs_pre) {
			*(oid*)dst = t;
			*(oid*)(dst + SIZEOF_OID) = *(oid*)p;
			dst += bs_res;
		}
	}

	GDKfree(ind);
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
        BATkey (BATmirror(res), TRUE);
	BATset(res, TRUE);
	
	*result = res;
	return GDK_SUCCEED;
}

bat* pftijah_prelude() {
    return NULL;
}

void pftijah_epilogue() {
}
@

/* vim:set shiftwidth=4 expandtab: */
