@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the PfTijah Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html
@' 
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@' 
@' The Original Code is the PfTijah system.
@' 
@' The Initial Developer of the Original Code is the "University of Twente".
@' Portions created by the "University of Twente" are 
@' Copyright (C) 2006-2009 "University of Twente".
@' 
@' Portions created by the "CWI" are 
@' Copyright (C) 2008-2009 "CWI".
@' 
@' All Rights Reserved.
@'

@f pftijah
@a Jan Flokstra
@a Henning Rode
@t pftijah

@m
.MODULE pftijah;

.COMMAND _run_tijah_query(BAT[str,str] opt, BAT[oid,str] rtag, bit use_startnodes) : void = CMDtijah_query;
 "INCOMPLETE"

.COMMAND tj_checkHashTable(BAT[oid,str]) : void = CMDcheckHashTable;
 "INCOMPLETE"

.COMMAND tj_normalizeTerm(str, str) : str = CMDtj_normalizeTerm;
 "INCOMPLETE"

.COMMAND _tj_throw2collection(BAT[str,bat],BAT[oid,bat],str) : void = CMDtj_throw2collection;
 "INCOMPLETE"

.COMMAND _tj_throw2collection_bat(BAT[str,bat],BAT[oid,bat],BAT[str,str]) : void = CMDtj_throw2collection_bat;
 "INCOMPLETE"

.COMMAND _tj_throw2collection_index(BAT[str,bat],str) : void = CMDtj_throw2collection_index;
 "INCOMPLETE"
 
.COMMAND tijah_tokenize(str) : str = CMDtijah_tokenize;
 "INCOMPLETE"

.COMMAND tj_chk_dict_hash(BAT[void,str], BAT[void,str]) : void = CMDtj_chk_dict_hash;
"INCOMPLETE"

.COMMAND tj_create_termdb(int, oid) : void = CMDtj_create_termdb;
 "INCOMPLETE"

.COMMAND tj_dispose_termdb() : void = CMDtj_dispose_termdb;
 "INCOMPLETE"

.COMMAND tj_log(str, int) : void = CMDtj_log;
 "DEBUGGING function for difficult IO areas"

.COMMAND tj_setlog(str) : void = CMDtj_setlog;
 "intialize outputfile for tj_log"

.COMMAND left_add(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDleft_add_dbl;
"Fast in-bat implementation of 2 head sorted bat addition with synchronized oid"
.COMMAND left_sub(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDleft_sub_dbl;
"Fast in-bat implementation of 2 head sorted bat subtraction with synchronized oid"
.COMMAND left_mul(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDleft_mul_dbl;
"Fast in-bat implementation of 2 head sorted bat multiplication with synchronized oid"
.COMMAND left_div(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDleft_div_dbl;
"Fast in-bat implementation of 2 head sorted bat division with synchronized oid"
.COMMAND left_div(BAT[oid,dbl] l, BAT[oid,int] r) : BAT[oid,dbl] = CMDleft_div_dbl_int;
"Fast in-bat implementation of 2 head sorted bat division, right type int with synchronized oid"
.COMMAND left_log(BAT[oid,dbl] l) : BAT[oid,dbl] = CMDleft_log_dbl;
"Fast in-bat implementation of in bat log() with synchronized oid"

.COMMAND union_add(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDunion_add_dbl;
"Fast union implementation of 2 head sorted bat addition with synchronized oid"
.COMMAND union_sub(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDunion_sub_dbl;
"Fast union implementation of 2 head sorted bat addition with synchronized oid"
.COMMAND union_mul(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDunion_mul_dbl;
"Fast union implementation of 2 head sorted bat addition with synchronized oid"
.COMMAND union_div(BAT[oid,dbl] l, BAT[oid,dbl] r) : BAT[oid,dbl] = CMDunion_div_dbl;
"Fast union implementation of 2 head sorted bat addition with synchronized oid"


.COMMAND serialize_tijah_opt(
                      BAT[void,bat] ws,
                      int	    niters,
                      BAT[void,oid] loop,
                      BAT[void,oid] iter,
                      BAT[void,oid] item,
		      BAT[void,int] kind,
                      BAT[void,lng] int_values,
		      BAT[void,dbl] dbl_values,
		      BAT[void,str] str_values)
		       : BAT[str,str] = serialize_pftijah_options_DRIVER;
 "C interface to pftijah option serialize"

.COMMAND pf2tijah_node(
                      BAT[oid,str] doc_name,
                      BAT[oid,oid] doc_firstpre,
                      BAT[oid,oid] pfpre,
                      BAT[oid,oid] item,
		      BAT[oid,int] kind,
                      BAT[oid,str]  doc_loaded)
		       : BAT[void,oid] = CMDpf2tijah_node;
 "Translate Pathfinder node sequence to tijah node sequence"

.COMMAND offsetindex( BAT[void,oid] offset_tid, int res_size)
		: BAT[void,oid] = CMDoffsetindex;

"PARAMETERS:
BAT[void,oid] - the offset index 
ressize       - the result size, equals number of different tids + 1
DESCRIPTION:
creates an offset index.
"

.COMMAND mergeindex( BAT[oid,oid] tid_pre, BAT[void,oid] index, BAT[void, oid] pre, int indsize)
		: BAT[void,bat] = CMDmergeindex;
"PARAMETERS:
BAT[oid,oid] - new tid_pre to merge with the old index
BAT[void,oid] - old index bat with value-offset
BAT[void,oid] - old posting lists (pre order lists)
int - size of new (dense) offset index.
DESCRIPTION:
the operation merges a new sorted tid_pre with an existing offset index.
"

.COMMAND mergeindex2( BAT[oid,oid] tid_pre, BAT[oid,int] tid_size, BAT[void,oid] index, BAT[void, oid] pre, BAT[void, int] size, int indsize)
		: BAT[void,bat] = CMDmergeindex2;
"PARAMETERS:
BAT[oid,oid] - new tid_pre to merge with the old index
BAT[oid,int] - sizes of new elements to merge with the old index (synched with tid_pre)
BAT[void,oid] - old index bat with value-offset
BAT[void,oid] - old posting lists (pre order lists)
BAT[void,int] - corresponding size lists (pre order lists)
int - size of new (dense) offset index.
DESCRIPTION:
the operation merges a new sorted tid_pre with an existing offset index.
"

.COMMAND indexfetchjoin( BAT[any,oid] tid, BAT[void,oid] index, BAT[void, oid] pre)
		: BAT[void,oid] = CMDindexfetchjoin;
"PARAMETERS:
BAT[any,oid] - bat with tail values which have to be joined (e.g. tid values)
BAT[void,oid] - join index bat with value-offset
BAT[void,oid] - bat with indexed offset and tail values to be returned
DESCRIPTION:
the join algorithm comes down to a repeated slice and insert operation.
"

.COMMAND treemergejoin_sort(BAT[oid,oid],BAT[void,int],BAT[oid,oid]) : BAT[oid,oid] = CMDtreemergejoin_sort; 
"Stack tree merge join descendant"

.COMMAND treemergejoin_sort_unnested(BAT[oid,oid],BAT[void,int],BAT[oid,oid]) : BAT[oid,oid] = CMDtreemergejoin_sort_unnested; 
"Stack tree merge join descendant"

.COMMAND treemergejoin_nest_pre(BAT[oid,any],BAT[void,int],BAT[oid,any]) : BAT[oid,oid] = CMDtreemergejoin_pre; 
"Stack tree merge join descendant"

.COMMAND treemergejoin_nest_nid(BAT[oid,oid],BAT[void,int],BAT[oid,oid]) : BAT[oid,oid] = CMDtreemergejoin_nid; 
"Stack tree merge join descendant"

.COMMAND treemergejoin_unnest_pre(BAT[oid,any],BAT[void,int],BAT[oid,any]) : BAT[oid,oid] = CMDtreemergejoin_unnested_pre; 
"Stack tree merge join descendant"

.COMMAND treemergejoin_unnest_nid(BAT[oid,oid],BAT[void,int],BAT[oid,oid]) : BAT[oid,oid] = CMDtreemergejoin_unnested_nid; 
"Stack tree merge join descendant"

.PRELUDE = pftijah_prelude;
.EPILOGUE = pftijah_epilogue;

.END pftijah;
@mil
###
# This file contains implementations of some of the SRA operators 
# to run on the TIJAH Light index.
#
# Based on code by the TIJAH team (Vojkan, Thijs)
#
# Additional retrieval models by Henning Rode and Djoerd Hiemstra
#
# Authors: Roel van Os <roel.van.os@glacimonto.nl>
#          Henning Rode <h.rode@cs.utwente.nl>
#
###

const DEBUG := false;

# locks
var tj_adm_lock     := lock_create(); # tijah top administration lock
var tj_dep_lock     := lock_create(); # tijah top dependency adm lock
var tj_coll_lockbat := new(str,lock).rename("tj_coll_lockbat"); # locks for all active collections

# Comparisons
# const GREATER := 10;
# const LESS := 11;
# const EQUAL := 12;
# const GEQ := 13;
# const LEQ := 14;

# Modifiers
# const NORMAL := 71;
# const PLUS := 72;
# const MINUS := 73;
# const MUST := 74;
# const MUST_NOT := 75;

const ENTITY_NUM := 10000;

#var collHeight := 10;
#var retNum := 100;

var trace := false;
var timing := false;

##
# For retrieval models: 
#   true:  return all elements from the context set
#   false: return only elements from the context set that contain one or more query terms
#
# Setting this variable to false has the advantage of smaller intermediate region sets.
# In theory, true has the advantage of better results, since it is possible that
# elements that don't match any term at the beginning of a query, contain descendants
# that do match terms.
##
var returnAllElements := false;

if (isnil(CATCH(bat("tj_collName").count()))) {
	if (bat("tj_collName").count() > 0) {
		var name := bat("tj_collName").fetch(0);
		# tj_setCollName(name);
	}
}

const QENV_FTINAME        := 0@0;
const QENV_FTIBGNAME      := 1@0;
const QENV_SCOREBASE      := 2@0;
const QENV_C_LAMBDA       := 3@0;
const QENV_TERM_PROXIMITY := 4@0;
const QENV_FEEDBACK_DOCS  := 5@0;
const QENV_RECURSIVE_TAGS := 6@0;
const QENV_OKAPI_K1       := 7@0;
const QENV_OKAPI_B        := 8@0;

# create a query environment bat
PROC create_qenv() : BAT[oid,str]
{
    var res := new(oid,str);
    return res;
}

PROC modify_qenv(BAT[oid,str] qenv, oid key, str val) : void
{
    if (qenv.exist(key)) {
       qenv.replace(key, val);
    } else {
       qenv.insert(key, val);
    }
}

# safe bat removal
PROC _tj_safe_remove(str batName) : void := {
    var err := CATCH({
        bat(batName).persists(false);
    });
    if (not(isnil(err))) printf("#IGNORING: " + err);
}

#
# Hash utility functions
#

PROC tj_init_termHash(str ftiName) : void :=
{
	tj_checkHashTable(bat(_tj_TermBat(ftiName)));
}

PROC tj_init_tagHash(str ftiName) : void :=
{
	tj_checkHashTable(bat(_tj_TagBat(ftiName)));
}


#####################################################################
#                                                                   #
# Start of the information functions                                #
#                                                                   #
#####################################################################

# tijah:ft-index-info(), get all ft-index-information
PROC ws_ft_index_info(BAT[void,BAT] ws, bit consistent) : BAT[void,oid]
{
    return ws_ft_index_info_base(ws,new(void,str),true);
}

# tijah:ft-index-info(str), get all ft-index-information
PROC ws_ft_index_info(BAT[void,BAT] ws, BAT[any,str] ftiNames, bit consistent) : BAT[void,oid]
{
    return ws_ft_index_info_base(ws,ftiNames,false);
}

# tijah:ft-index-info(str), get all ft-index-information
PROC ws_ft_index_info_base(BAT[void,BAT] ws, BAT[any,str] ftiNames, bit all) : BAT[void,oid]
{
    var chkbat;

    var tjc;

    if (isnil(CATCH(bat("tj_collName").count()))) {
        tjc := bat("tj_collName");
    } else {
        tjc := new(oid,str);
    }

    if ( all )
        chkbat := tjc;
    else 
        chkbat := ftiNames;

    var res := new(void,str).seqbase(0@0);
    var stm := new(void,str).seqbase(0@0);
    var tok := new(void,str).seqbase(0@0);
    var col := new(void,str).seqbase(0@0);
    chkbat@batloop() {
	if ( or(all,tjc.reverse().exist($t)) ) {
          res.append($t);
          stm.append(bat("tj_" + $t + "_param").find("stemmer"));
          tok.append(bat("tj_" + $t + "_param").find("tokenizer"));
	  var as := "";
	  bat("tj_pfc_fti_dep").reverse().select($t)@batloop() {
	      if ( as = "" )
	          as := $h;
	      else 
	          as := as + "," + $h;
	  }
          col.append(as);
    	}
    }
    return xmltab4(ws, "ftindex", res, "stemmer", stm, "tokenizer", tok, "collections", col);
}

#####################################################################
#                                                                   #
# Start of the new implementation of the interfaces                 #
#                                                                   #
#####################################################################

var verbose      := false;

const dflt_ft_index   := "DFLT_FT_INDEX";
const dflt_bg_index   := "DFLT_FT_INDEX";
const dflt_score_base := "0";

PROC tj_get_ft_index(BAT[str,str] tj_options, bit chk_exists) : str :=
{
    var res := dflt_ft_index;
    if ( tj_options.exist("ft-index") ) {
        res := tj_options.find("ft-index");
    }
    if ( chk_exists ) {
      if ( not(bat("tj_collName").reverse().exist(res)) ) {
    	ERROR("tj_get_ft_index, ft-index \"%s\" does not exist\n",res);
      }
    }
    if ( verbose ) printf("#TJ:tj_get_ft_index() = %s.\n",res);
    return res;
}

ADDHELP("tj_init_global", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- optional BAT[str,str] param: initialization parameter for global pftijah.\n\
  settings.\n\
DESCRIPTION:\n\
Initialize the global pftijah environment.",
"pftijah");
PROC tj_init_global(BAT[str,str] param) : void :=
{
    tj_init_global(param,true);
}

const GLOBAL_TTBAT := false;
const VOID_TTBAT   := true;

PROC _tj_TermBat(str ftiName) : str :=
{
    if ( GLOBAL_TTBAT )
        return "tj_globalTerms";
    else
    	return "tj_" + ftiName + "_termdict";
}

PROC _tj_TagBat(str ftiName) : str :=
{
    if ( GLOBAL_TTBAT )
        return "tj_globalTags";
    else
    	return "tj_" + ftiName + "_tagdict";
}

PROC _tj_RTagBat(str ftiName) : str :=
{
    if ( GLOBAL_TTBAT )
        return "tj_globalRTags";
    else
    	return "tj_" + ftiName + "_rtags";
}

PROC tj_init_global(BAT[str,str] param, bit doLock) : void :=
{
    if (doLock) lock_set(tj_adm_lock);
    var err := CATCH({
      if ( verbose ) printf("#TJ:tj_init_global() called.\n");
      param@batloop() {
	if ( verbose ) printf("#TJ:tj_init_global():param[%s]=\"%s\"\n",$h,$t);
	if ( $h = "term_frag" ) {
	    # incomplete, handle term frag
	} else if ( $h = "term_frag_size" ) {
	    # incomplete, handle term frag
	} else {
	    ERROR("# tj_init_global() unkonwn parameter [%s].\n",$h);
	}
      }
      if ( GLOBAL_TTBAT ) {
          new(oid,str).persists(true).bbpname(_tj_TermBat(""));
          new(oid,str).persists(true).bbpname(_tj_TagBat(""));
          new(oid,str).persists(true).bbpname(_tj_RTagBat(""));
      }
      new(oid,str).persists(true).bbpname("tj_collName");
      new(str,str).persists(true).bbpname("tj_pfc_fti_dep");
      new(str,str).persists(true).bbpname("tj_pfc_fti_dep_star");
      var globals := new(void,str).seqbase(0@0);
      if ( GLOBAL_TTBAT ) {
          globals.append(_tj_TermBat(""));
          globals.append(_tj_TagBat(""));
          globals.append(_tj_RTagBat(""));
      }
      globals.append("tj_collName");
      globals.append("tj_pfc_fti_dep");
      globals.append("tj_pfc_fti_dep_star");
      subcommit(globals);
    });
    if (doLock) lock_unset(tj_adm_lock);
    if (not(isnil(err))) ERROR(err);
}

PROC tj_init_global() : void :=
{
     tj_init_global(new(str,str));
}

ADDHELP("tj_delete_global", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
DESCRIPTION:\n\
Delete all pftijah collections and remove the global pftijah settings.",
"pftijah");
PROC tj_delete_global() : void :=
{
    lock_set(tj_adm_lock);
    var err := CATCH({
      if ( verbose ) printf("#TJ:tj_delete_global() called.\n");
      #
      bat("tj_collName")@batloop(){
  	  tj_delete_collection($t,false);
      }
      if ( GLOBAL_TTBAT ) {
          _tj_safe_remove(_tj_TermBat(""));
          _tj_safe_remove(_tj_TagBat(""));
          _tj_safe_remove(_tj_RTagBat(""));
      }
      _tj_safe_remove("tj_collName");
      _tj_safe_remove("tj_pfc_fti_dep");
      _tj_safe_remove("tj_pfc_fti_dep_star");
      var globals := new(void,str).seqbase(0@0);
      if ( GLOBAL_TTBAT ) {
          globals.append(_tj_TermBat(""));
          globals.append(_tj_TagBat(""));
          globals.append(_tj_RTagBat(""));
      }
      globals.append("tj_collName");
      globals.append("tj_pfc_fti_dep");
      globals.append("tj_pfc_fti_dep_star");
      subcommit(globals);
    });
    lock_unset(tj_adm_lock);
    if (not(isnil(err))) ERROR(err);
}

# protext the lookup/insert of the per-collection-locks

var tj_coll_mutex := lock_create();

PROC tj_get_collection_lock(str colname) : lock
{
    var collection_lock;

    lock_set(tj_coll_mutex);
    var err := CATCH({
      if (tj_coll_lockbat.exist(colname))
        collection_lock := tj_coll_lockbat.find(colname);
      else {
        collection_lock := lock_create();
	tj_coll_lockbat.insert(colname,collection_lock);
      }
    });
    lock_unset(tj_coll_mutex);
    if (not(isnil(err))) ERROR(err);
    return collection_lock;
}

ADDHELP("tj_init_collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str ftiName: the name of the collection
- BAT[str,str] param: initialization parameter for collection.\n\
  possible values are:\n\
  tokenizer = { flex, fast }\n\
  stemmer = { nostemming, snowball-english, snowball-porter, snowball-dutch }\n\
  fragmentSize = [number] == the maximum size of a [pre|item] fragment\n\
  tagFilter = [comma seperated list of tags to be indexed]\n\
  etc.\n\
- BAT[void,str] v_pfc, list of pathfinder collection to index 
DESCRIPTION:\n\
Create a new tijah collection.",
"pftijah");
PROC tj_init_collection(str ftiName, BAT[str,str] param, BAT[void,str] v_pfc) : void :=
{
    _tj_init_collection(ftiName,param,v_pfc,FALSE);
}

PROC tj_init_collection(str ftiName, BAT[str,str] param) : void :=
{
    _tj_init_collection(ftiName,param,new(void,str),FALSE);
}

PROC tj_rebuild_collection(str ftiName) : void  
{
    # WARNING: not thoroughly tested yet
    _tj_init_collection(ftiName,new(str,str),new(void,str),TRUE);
}

PROC _tj_init_collection(str ftiName, BAT[str,str] param, BAT[void,str] v_pfc, bit rebuild) : void :=
{
    var coll_lock;

    #
    # first handle the global administration stuff
    #
    lock_set(tj_adm_lock);
    var err := CATCH({
      if ( verbose ) printf("#TJ tj_init_collection(\"%s\") called.\n",ftiName);

      if (not(isnil(CATCH(bat("tj_collName").count())))) {
    	tj_init_global(new(str,str),false); # just in case 
      }
      if (bat("tj_collName").reverse().exist(ftiName)) {
    	if ( not(rebuild) )
	  ERROR("tj_init_collection, pftijah collection already exists: %s\n",ftiName);
      } else {
        if (rebuild) {
	  ERROR("tj_rebuild_collection, pftijah collection \"%s\" does not exists\n",ftiName);
	}
      }
      #
      if ( not(rebuild) ) {
          var coll_oid;
          if (bat("tj_collName").count() = 0) { 
            coll_oid := 0@0;
          } else {
            coll_oid := oid(int(bat("tj_collName").reverse().max()) + 1);
          }
          bat("tj_collName").insert(coll_oid, ftiName);
          #
      }
      coll_lock := tj_get_collection_lock(ftiName);
    });
    lock_unset(tj_adm_lock);
    if (not(isnil(err))) ERROR(err);
    #
    # now the collection stuff 
    #
    var extra_del_bat;
    lock_set(coll_lock);
    var err := CATCH({
      if ( not(GLOBAL_TTBAT) ) {
	  if ( rebuild ) {
	      # INCOMPLETE, not throwing them away is much faster!!!
              bat(_tj_TermBat(ftiName)).delete();
              bat(_tj_TagBat(ftiName)).delete();
              bat(_tj_RTagBat(ftiName)).delete();
	  } else {
	      if ( VOID_TTBAT) {
                  new(void,str).seqbase(0@0).persists(true).bbpname(_tj_TermBat(ftiName));
                  new(void,str).seqbase(0@0).persists(true).bbpname(_tj_TagBat(ftiName));
	      } else {
                  new(oid,str).persists(true).bbpname(_tj_TermBat(ftiName));
                  new(oid,str).persists(true).bbpname(_tj_TagBat(ftiName));
	      }
              new(oid,str).persists(true).bbpname(_tj_RTagBat(ftiName));
	  }
      }
      extra_del_bat := new(void,str).seqbase(0@0);
      if ( rebuild ) {
          bat("tj_" + ftiName + "_doc_name").delete();
          bat("tj_" + ftiName + "_doc_firstpre").delete();
	  # do not delete the param bat
	  var frag_offset := int(2); # we delete all buns in existing 1 frag
	  var frag_last := bat("tj_" + ftiName + "_fragments").count();
	  while (frag_offset < frag_last)
	  {
		var bn := "tj_" + ftiName + "_tid" + str(frag_offset);
		_tj_safe_remove(bn);
                extra_del_bat.append(bn);
		bn := "tj_" + ftiName + "_size" + str(frag_offset);
		_tj_safe_remove(bn);
                extra_del_bat.append(bn);
		frag_offset :+= 1;
	  }
          bat("tj_" + ftiName + "_tid1").delete();
          bat("tj_" + ftiName + "_size1").delete();
          bat("tj_" + ftiName + "_fragments").delete();
          bat("tj_" + ftiName + "_fragments").append(1@0);
          bat("tj_" + ftiName + "_pfpre").delete();
          bat("tj_" + ftiName + "_conceptdict").delete();
          bat("tj_" + ftiName + "_concept_tid").delete();
          bat("tj_" + ftiName + "_concept_elem").delete();
          bat("tj_" + ftiName + "_concept_score").delete();
      } else {
          new(void,str).seqbase(0@0).persists(true).bbpname("tj_" + ftiName + "_doc_name");
          new(void,oid).seqbase(0@0).persists(true).bbpname("tj_" + ftiName + "_doc_firstpre");
          new(str,str).persists(true).bbpname("tj_" + ftiName + "_param");
          
          new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + ftiName + "_tid1");
          new(void,int).seqbase(1@0).persists(true).bbpname("tj_" + ftiName + "_size1");
          # bat contains the start oid of every tid/size frag. Head is postfix
          # string to _tid/_size. Normally "", "2", "3"
          new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + ftiName + "_fragments");
          bat("tj_" + ftiName + "_fragments").append(1@0);
          new(oid,oid).persists(true).bbpname("tj_" + ftiName + "_pfpre");
          new(oid,str).persists(true).bbpname("tj_" + ftiName + "_conceptdict");
          new(void,oid).seqbase(0@0).persists(true).bbpname("tj_" + ftiName + "_concept_tid");
          new(void,oid).seqbase(0@0).persists(true).bbpname("tj_" + ftiName + "_concept_elem");
          new(void,dbl).seqbase(0@0).persists(true).bbpname("tj_" + ftiName + "_concept_score");
      }
         
      var parambat := bat("tj_" + ftiName + "_param");
      if ( rebuild ) {
	parambat.replace("status","building");
	parambat.replace("_last_tijahPre","1");
	parambat.replace("_last_finalizedPre","0");
      } else {
        #
        # now read the param file
        #
        var stemmer        := "nostemming";
        var tokenizer      := "flex";
        var tagfilter      := "";
	var whitelist      := "";
	var blacklist      := "";
        var fragsize       := "0";
        var delay_finalize := "0";
  
        param@batloop() {
	  if ( verbose ) printf("#TJ:tj_init_collection():param[%s]=\"%s\"\n",$h,$t);
	  if ( $h = "stemmer" ) {
	      stemmer := $t;
	  } else if ( $h = "tokenizer" ) {
	      tokenizer := $t;
	  } else if ( $h = "pf_collection" ) {
              bat("tj_" + ftiName + "_param").insert($h,$t);
	  } else if ( $h = "fragmentSize" ) {
	      fragsize := $t;
	  } else if ( $h = "whitelist" ) {
              whitelist := $t;
	  } else if ( $h = "blacklist" ) {
              blacklist := $t;
	  } else if ( $h = "ft-index" ) {
	      # ignore this one here
	  } else if ( $h = "delay-finalize" ) {
	      # the number of pre nodes to delay a finalize
	      delay_finalize := $t;
	  } else {
	      ERROR("# tj_init_collection() unknown parameter [%s].\n",$h);
	  }
        }
        #
        # now set the parameters for this collection
        #
        parambat.insert("_version","1.01");
        parambat.insert("name",ftiName);
        parambat.insert("tokenizer",tokenizer);
        parambat.insert("stemmer",stemmer);
        parambat.insert("fragmentSize",fragsize);
        parambat.insert("preExpansion","4");
        parambat.insert("lastStopWord","0");
        parambat.insert("status","building");
        parambat.insert("_last_tijahPre","1");
        parambat.insert("_last_finalizedPre","0");
        parambat.insert("delay_finalize",delay_finalize);
	if( not(whitelist = "") )
            parambat.insert("whitelist",whitelist);
	if( not(blacklist = "") )
            parambat.insert("blacklist",blacklist);
      }
      if ( rebuild  ) {
        # reconstruct the original v_pfc
	v_pfc := bat("tj_pfc_fti_dep").reverse().select(ftiName).reverse();
      } else {
        #
        # now modify the global fti pfc dependency administration. We may ignore
        # the return value because all dependencies for this collection are new.
        modify_pfc_fti(ftiName,v_pfc);
      }
      if ( rebuild ) {
	if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) {
		_tj_safe_remove("tj_" + ftiName + "_TermIndex");
		_tj_safe_remove("tj_" + ftiName + "_Terms");
		_tj_safe_remove("tj_" + ftiName + "_TagIndex");
		_tj_safe_remove("tj_" + ftiName + "_Tags");
	}
      }
    });
    if ( rebuild ) {
        subcommit(extra_del_bat);
    }
    subcommit(_tj_collection_str(ftiName));
   lock_unset(coll_lock);
    #
    if (not(isnil(err))) ERROR(err);
    #
    if ( true ) {
      #
      # Now compute the list of existing docs which need to be added to the 
      # ft-index because of the associations.
      # WARNING: this piece of code is not yet very safe but is requires
      # a very close cooperation with Pathfinder locks to make it safe.
      #
      if ( verbose ) printf("#TJ:tj_init_collection(\"%s\") checking collection to index.\n",ftiName);
      var doclist;
      if ( v_pfc.uselect("*").count() > 0 ) {
         doclist := bat("doc_name").reverse().project(str(nil)).reverse();
      } else {
         doclist := bat("doc_name").reverse().join(bat("doc_collection").join(bat("collection_name").join(v_pfc.reverse())));
         doclist := doclist.project(str(nil)).reverse();
      }

      if ( verbose ) printf("#TJ:tj_init_collection(\"%s\") indexing existing collections.\n",ftiName);
      tj_add2collection(ftiName,doclist,false);
      if ( verbose ) printf("#TJ:tj_init_collection(\"%s\") finish indexing existing collections.\n",ftiName);
    }
    if ( verbose ) printf("#TJ:tj_init_collection(\"%s\") finished.\n",ftiName);
}

#
# The tj_extend_collection() adds new pf collection dependencies to an existing
# collection.
#
PROC tj_extend_collection(str ftiName, BAT[void,str] v_pfc) : void :=
{
    if ( verbose ) printf("#TJ:tj_extend_collection(\"%s\") start.\n",ftiName);
    var newdep := modify_pfc_fti(ftiName,v_pfc);

    var doclist := bat("doc_name").reverse().join(bat("doc_collection").join(bat("collection_name").join(newdep.reverse())));
    doclist := doclist.project(str(nil)).reverse();
    if ( doclist.count() > 0 ) {
        if ( verbose ) printf("#TJ:tj_extend_collection(\"%s\") indexing existing collections.\n",ftiName);
        if ( verbose ) doclist.print();
	tj_add2collection(ftiName,doclist,false);
        if ( verbose ) printf("#TJ:tj_extend_collection(\"%s\") finish indexing existing collections.\n",ftiName);
    } else {
        # be shure to commit extend bat changes when no docs are added
        subcommit(_tj_collection_str(ftiName));
    }
    if ( verbose ) printf("#TJ:tj_extend_collection(\"%s\") finished.\n",ftiName);
}


#
# Start of ft-index / pf-collection dependency module
#

PROC modify_pfc_fti(str fti_name, BAT[void,str]  v_pfc) : BAT[str,str] :=
{
    var result;

    lock_set(tj_dep_lock);
    var err := CATCH({
	var glb_fti_pfc     := bat("tj_pfc_fti_dep");
	var fti_dep := glb_fti_pfc.reverse().select(fti_name).reverse();
	if ( fti_dep.select("*").count() > 0 ) {
	    ERROR("# pfc_fti_dep: unable to extend ft-index when created with *\n");
	}
	var new_fti_pfc := v_pfc.tunique().project(fti_name).reverse().sunique().tdiff(fti_dep);
	if ( verbose ) {
	    printf("#TJ:modify_pfc_fti: ***** added dep ***\n");
	    new_fti_pfc.print();
	}
	var sz := new_fti_pfc.count();
	if ( sz > 0 ) {
	    if ( sz = 1 ) {
		glb_fti_pfc.insert(new_fti_pfc);
		if ( new_fti_pfc.uselect("*").count() > 0 ) {
		    bat("tj_pfc_fti_dep_star").insert(new_fti_pfc);
	        }
	    } else {
	    	if ( new_fti_pfc.uselect("*").count() > 0 ) {
		    ERROR("# pfc_fti_dep: when using * it must be the only collection dependency.\n");
		}
		glb_fti_pfc.insert(new_fti_pfc);
	    }
	}
	result := new_fti_pfc;
    });
    if ( verbose ) {
    	printf("\n# LOG modify_pfc_fti(\"%s\") START, v_pfc =\n", fti_name);
	v_pfc.print();
    	printf("# Dependence BATs are [STAR|ALL]:\n");
	bat("tj_pfc_fti_dep_star").print();
	bat("tj_pfc_fti_dep").print();
    	printf("# LOG modify_pfc_fti(\"%s\") END.\n", fti_name);
    }
    lock_unset(tj_dep_lock);
    if (not(isnil(err))) ERROR(err);
    #
    return result;
}

PROC delete_pfc_fti(str fti_name) :void :=
{
    lock_set(tj_dep_lock);
    var err := CATCH({
	bat("tj_pfc_fti_dep").delete(fti_name);
	bat("tj_pfc_fti_dep_star").delete(fti_name);
    });
    lock_unset(tj_dep_lock);
    if (not(isnil(err))) ERROR(err);
}

#
# End of ft-index / pf-collection dependency module
#

ADDHELP("tj_delete_collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str ftiName: the name of the collection to be deleted.\n
DESCRIPTION:\n\
Delete the collection with name \"ftiName\".",
"pftijah");
PROC tj_delete_collection(str ftiName) : void
{
    tj_delete_collection(ftiName,true);
}

PROC tj_delete_collection(str ftiName, bit doAdmLock) : void
{
    var coll_lock;

    #
    # first handle the global administration stuff
    #
    if ( doAdmLock ) lock_set(tj_adm_lock);
    var err := CATCH({
      if ( verbose ) printf("#TJ:tj_delete_collection(\"%s\") called.\n",ftiName);

      if (not(isnil(CATCH(bat("tj_collName").count())))) {
    	ERROR("tj_delete_collection: pftijah not initialized.\n");
      }
      if (not(bat("tj_collName").reverse().exist(ftiName))) {
    	ERROR("tj_delete_collection, pftijah collection does not exist: %s\n",ftiName);
      }
      #
      var coll_oid := bat("tj_collName").reverse().find(ftiName);
      bat("tj_collName").delete(coll_oid);
      #
      coll_lock := tj_get_collection_lock(ftiName);
    });
    if ( doAdmLock ) lock_unset(tj_adm_lock);
    if (not(isnil(err))) ERROR(err);
    #
    # now remove the collection stuff 
    #
    lock_set(coll_lock);
    var err := CATCH({
        if ( not(GLOBAL_TTBAT) ) {
          _tj_safe_remove(_tj_TermBat(ftiName));
          _tj_safe_remove(_tj_TagBat(ftiName));
          _tj_safe_remove(_tj_RTagBat(ftiName));
        }
	_tj_safe_remove("tj_" + ftiName + "_doc_name");
	_tj_safe_remove("tj_" + ftiName + "_doc_firstpre");
	_tj_safe_remove("tj_" + ftiName + "_param");
	_tj_safe_remove("tj_" + ftiName + "_pfpre");
	_tj_safe_remove("tj_" + ftiName + "_conceptdict");
	_tj_safe_remove("tj_" + ftiName + "_concept_tid");
	_tj_safe_remove("tj_" + ftiName + "_concept_elem");
	_tj_safe_remove("tj_" + ftiName + "_concept_score");
	bat("tj_" + ftiName + "_fragments")@batloop() {
	    var fpfx := str(int($h));
	    _tj_safe_remove("tj_" + ftiName + "_tid"+fpfx);
	    _tj_safe_remove("tj_" + ftiName + "_size"+fpfx);
	}
	bat("tj_" + ftiName + "_fragments").persists(false);
	if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) {
		_tj_safe_remove("tj_" + ftiName + "_TermIndex");
		_tj_safe_remove("tj_" + ftiName + "_Terms");
		_tj_safe_remove("tj_" + ftiName + "_TagIndex");
		_tj_safe_remove("tj_" + ftiName + "_TagSize");
		_tj_safe_remove("tj_" + ftiName + "_Tags");
	}
        delete_pfc_fti(ftiName);
        subcommit(_tj_collection_str(ftiName));
    });
    lock_unset(coll_lock);
    if (not(isnil(err))) ERROR(err);
}

# internal method which return all batnames of a collection in a
# a [void,str] bat
PROC _tj_collection_str(str ftiName) : BAT[void,bat]
{
        var tjCollBat := new(void,str).seqbase(0@0);

        tjCollBat.append(_tj_TermBat(ftiName));
        tjCollBat.append(_tj_TagBat(ftiName));
        tjCollBat.append(_tj_RTagBat(ftiName));
        tjCollBat.append("tj_pfc_fti_dep");
        tjCollBat.append("tj_pfc_fti_dep_star");
        tjCollBat.append("tj_collName");
        tjCollBat.append("tj_" + ftiName + "_param");
        tjCollBat.append("tj_" + ftiName + "_doc_name");
        tjCollBat.append("tj_" + ftiName + "_doc_firstpre");
        tjCollBat.append("tj_" + ftiName + "_pfpre");
        tjCollBat.append("tj_" + ftiName + "_conceptdict");
        tjCollBat.append("tj_" + ftiName + "_concept_tid");
        tjCollBat.append("tj_" + ftiName + "_concept_elem");
        tjCollBat.append("tj_" + ftiName + "_concept_score");
        tjCollBat.append("tj_" + ftiName + "_fragments");
	bat("tj_" + ftiName + "_fragments")@batloop()
        {       
            tjCollBat.append("tj_" + ftiName + "_tid" + str(int($t)));
            tjCollBat.append("tj_" + ftiName + "_size"+ str(int($t)));
        }       
        if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) {
            tjCollBat.append("tj_" + ftiName + "_Terms");
            tjCollBat.append("tj_" + ftiName + "_Tags");
            tjCollBat.append("tj_" + ftiName + "_TermIndex");
            tjCollBat.append("tj_" + ftiName + "_TagIndex");
            tjCollBat.append("tj_" + ftiName + "_TagSize");
        }      
        return tjCollBat;
}

# internal method which return all relevant data about a collection in a
# a single [void,bat] bat
PROC _tj_collection(str ftiName) : BAT[str, bat]
{
        if (not(isnil(CATCH(bat("tj_" + ftiName + "_param").count())))) {
	     ERROR("_tj_collection(): collection(\""+ftiName+"\") does not exist!\n");
	}
	var tjCollBat := new(str,bat);

	var parbat := bat("tj_" + ftiName + "_param");
	var curversion;
	if ( parbat.exist("_version") ) {
	    curversion := parbat.find("_version");
	} else {
	    curversion := "0.0";
	}
	if ( curversion < "1.0" ) {
	     ERROR("_tj_collection():%s: pftijah index structure changed, reindex collection!!",curversion);
	}
	tjCollBat.insert("_globalTerms", bat(_tj_TermBat(ftiName)));
	tjCollBat.insert("_globalTags", bat(_tj_TagBat(ftiName)));
	tjCollBat.insert("_globalRTags", bat(_tj_RTagBat(ftiName)));
	tjCollBat.insert("_doc_name", bat("tj_" + ftiName + "_doc_name"));
	tjCollBat.insert("_doc_firstpre", bat("tj_" + ftiName + "_doc_firstpre"));
	tjCollBat.insert("_param", parbat);
	# only load the top [pre|term|size] fragments
	var fpfx := str(bat("tj_" + ftiName + "_fragments").count());
	tjCollBat.insert("_tid",       bat("tj_" + ftiName + "_tid"+fpfx));
	tjCollBat.insert("_size",      bat("tj_" + ftiName + "_size"+fpfx));
	tjCollBat.insert("_pfpre",     bat("tj_" + ftiName + "_pfpre"));
	tjCollBat.insert("_conceptdict",      bat("tj_" + ftiName + "_conceptdict"));
	tjCollBat.insert("_concept_tid",  bat("tj_" + ftiName + "_concept_tid"));
	tjCollBat.insert("_concept_elem", bat("tj_" + ftiName + "_concept_elem"));
	tjCollBat.insert("_concept_score",bat("tj_" + ftiName + "_concept_score"));
	tjCollBat.insert("_fragments", bat("tj_" + ftiName + "_fragments"));
	
	if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) {
            tjCollBat.insert("_Terms", bat("tj_" + ftiName + "_Terms"));
	    tjCollBat.insert("_Tags", bat("tj_" + ftiName + "_Tags"));
	    tjCollBat.insert("_TermIndex", bat("tj_" + ftiName + "_TermIndex"));
	    tjCollBat.insert("_TagIndex", bat("tj_" + ftiName + "_TagIndex"));
	    tjCollBat.insert("_TagSize", bat("tj_" + ftiName + "_TagSize"));
	}
	tjCollBat.insert("submitBats", new(void,str).seqbase(0@0));
	tjCollBat.insert("replaceBats", new(str,str));
	
	return tjCollBat;
}

PROC _tj_commit(BAT[str,bat] collBat) : void
{
      var replaceBats := collBat.find("replaceBats");
      replaceBats@batloop() {
      	 bat($t).persists(false).rename("del_" + $t);
	 collBat.find($h).persists(true).bbpname($t);
      }
    
      var submitBats := collBat.find("submitBats");
      submitBats.append([+](const "del_", replaceBats.tmark(0@0)));
     
      subcommit(submitBats);
}

ADDHELP("tj_add2collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str ftiName: the name of the collection.\n
- str uri_loc: the location of the xml document.\n
- str uri_name: the name of the xml document (optional).\n
- bit shred: when true the doc is shredded when necessary.\n\
DESCRIPTION:\n\
Add a document to a pftijah collection. The document is indexed and if the \n\
shred parameter is true it is also shredded in Pathfinder. 
The index is automatically finalized at the end of the method.",
"pftijah");
PROC tj_add2collection(str ftiName, str uri_loc, str uri_name, bit shred) : void
{
    tj_add2collection(ftiName,new(str,str).insert(uri_loc,uri_name),shred);
}

ADDHELP("tj_add2collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str ftiName: the name of the collection.\n
- BAT[str,str]: the bat containing the [location,name] pairs of the xml docs.\n\
- bit shred: when true the doc is shredded when necessary.\n\
DESCRIPTION:\n\
The multidocument version of tj_add2collection. The main difference with the\n\
other method is the [str,str] bat which contains the location of the document\n\
in the head and the name in the tail.\n\
The advantage of this method is that the collection is finalized after all\n\
xml documents in the bat are added to the collection.",
"pftijah");
PROC tj_add2collection(str ftiName, BAT[str,str] uri, bit shred) : void
{
    var coll_lock := tj_get_collection_lock(ftiName);
    lock_set(coll_lock);
    var err := CATCH({
      var t_start := usec();
      bat(_tj_TermBat(ftiName)).access(BAT_APPEND);
      bat(_tj_TagBat(ftiName)).access(BAT_APPEND);
      bat(_tj_RTagBat(ftiName)).access(BAT_APPEND);
      var collBat;
      collBat := _tj_collection(ftiName);
      var ws_opt := ws_create(0);
      if ( not(shred) ) {
        ws_opendoc(ws_opt,uri.tmark(0@0));
        _tj_throw2collection_bat(collBat,ws_opt,uri);
      } else {
        uri@batloop() {
          _tj_add2collection(ftiName, ws_opt, collBat, $h, $t, shred);
        }
      }
      ws_destroy(ws_opt);
      _tj_set_parameter(collBat, "status", "building");
      _tj_finalize_collection(ftiName, collBat, FALSE);
      if ( timing ) {
         var ms := (usec()-t_start)/1000;
         printf("#C[%s]:tj_add2collection(BAT): + aggregate time = %lld.%03llds.\n",ftiName,/(ms,1000),%(ms,1000));
       }
      _tj_commit(collBat); 
    });
    lock_unset(coll_lock);
    if (not(isnil(err))) ERROR(err);
}

PROC _tj_add2collection(str ftiName, BAT[oid,bat] ws_opt, BAT[str,bat] collBat, str uri_loc, str uri_name, bit shred) : void
{ 
    var ms;
    var t_start := usec();
    if ( verbose ) printf("#TJ:_tj_add2collection(\"%s\",\"%s\",\"%s\") start.\n",ftiName,uri_loc,uri_name);

    var i_start;
    if ( shred ) {
	var pf_collection := _tj_get_parameter(collBat,"pf_collection");
	if ( isnil(uri_loc) and isnil(uri_name) ) {
	    ERROR("_tj_add2collection: should specify doc_name or doc_uri.");
	}
        if ( isnil(uri_name) ) {
	  uri_name := uri_loc;
	} else if ( uri_name = "" ) {
	  uri_name := uri_loc;
	}
        # var ws := ws_create(0);
        if (not(bat("doc_name").reverse().exist(uri_name))) {
            var s_start := usec();
	    if ( isnil(pf_collection) ) {
    	        shred_doc(uri_loc,uri_name);
	    } else {
    	        shred_doc(uri_loc,uri_name,pf_collection,0LL);
	    }
            if ( timing ) {
	      ms := (usec()-s_start)/1000;
              printf("#C[%s]:add2coll(\"%s\"): shred time = %lld.%03llds.\n",ftiName,uri_name,/(ms,1000),%(ms,1000));
            }
        } else {
            if ( verbose ) printf("#TJ:_tj_add2collection(%s,..) doc(\"%s\") already shredded.\n",ftiName,uri_name);
	}
        # ws_opendoc(ws, bat(void,str,1).append(uri_name));
        ws_opendoc(ws_opt, bat(void,str,1).append(uri_name));
	i_start := usec();
        if ( verbose ) printf("#TJ:_tj_throw2collection(cb(%s),ws,\"%s\") call next.\n",ftiName,uri_name);
        _tj_throw2collection(collBat,ws_opt,uri_name);
        # ws_destroy(ws);
    } else {
	i_start := usec();
        #_tj_throw2collection_index(collBat,uri_loc);
        _tj_throw2collection(collBat,ws_opt,uri_name);
    }
    if ( timing ) {
	ms := (usec()-i_start)/1000;
        printf("#C[%s]:add2coll(\"%s\"): index time = %lld.%03llds.\n",ftiName,uri_name,/(ms,1000),%(ms,1000));
    }
           
    if ( verbose ) printf("#TJ:_tj_add2collection(\"%s\") finish.\n",ftiName);
    if ( timing ) {
	ms := (usec()-t_start)/1000;
        printf("#C[%s]:add2coll(\"%s\"): total time = %lld.%03llds.\n",ftiName,uri_name,/(ms,1000),%(ms,1000));
    }
}

# internal finalize function
PROC _tj_finalize_collection(str ftiName, BAT[str,bat] collBat, bit fforce) : void
{
    var t_start := usec();
    if ( verbose ) printf("#TJ:_tj_finalize_collection(\"%s\") called.\n",ftiName);
    var parambat := bat("tj_" + ftiName + "_param");
    if ( not(fforce) ) {
        var delfin   := lng(parambat.find("delay_finalize"));
        if ( delfin > lng(0) ) {
            var finlast  := lng(parambat.find("_last_finalizedPre"));
            var prelast  := lng(parambat.find("_last_tijahPre"));
            var fdelta   := prelast - finlast;
	    if ( (prelast - finlast) < delfin ) {
                  if ( verbose ) printf("#TJ:_tj_finalize_collection(\"%s\") delaying finalization (%d < %d).\n",ftiName,int(fdelta),int(delfin));
		  return;
	    } else {
                  if ( verbose ) printf("#TJ:_tj_finalize_collection(\"%s\") finalization treshhold reached (%d > %d).\n",ftiName,int(fdelta),int(delfin));
	    }
        }
    }
    #
    var mod_frags := _tj_chk_modified_fragments(ftiName, collBat); 
    # set all fragments except the last one to BAT_READ
    mod_frags@batloop()
    {
        bat($t).access(BAT_READ);
	bat($t).mmap(1);
	collBat.find("submitBats").append($t);
    }
    collBat.find("_size").access(BAT_APPEND).mmap(1);
    collBat.find("_tid").access(BAT_APPEND).mmap(1);
    collBat.find("_pfpre").access(BAT_APPEND).mmap(1);
    var fpfx := str(collBat.find("_fragments").count());
    collBat.find("submitBats").append("tj_" + ftiName + "_size" + fpfx);
    collBat.find("submitBats").append("tj_" + ftiName + "_tid" + fpfx);
    collBat.find("submitBats").append("tj_" + ftiName + "_pfpre");
    collBat.find("submitBats").append("tj_" + ftiName + "_conceptdict");
    collBat.find("submitBats").append("tj_" + ftiName + "_concept_tid");
    collBat.find("submitBats").append("tj_" + ftiName + "_concept_elem");
    collBat.find("submitBats").append("tj_" + ftiName + "_concept_score");
    collBat.find("submitBats").append("tj_" + ftiName + "_fragments");
    collBat.find("submitBats").append("tj_" + ftiName + "_doc_name");
    collBat.find("submitBats").append("tj_" + ftiName + "_doc_firstpre");
    collBat.find("submitBats").append("tj_" + ftiName + "_param");
    
    _buildIRindex(ftiName, collBat);
    #
    _tj_set_parameter(collBat, "status", "finalized");
    var lst_fpre := str(lng(parambat.find("_last_tijahPre")) - 1);
    _tj_set_parameter(collBat, "_last_finalizedPre", lst_fpre);
    #
    if ( false ) {
    	# we now do hash lookups and always ensure there's a hash table on the
	# dictionarys when querying
        var gterm_sort := bat(_tj_TermBat(ftiName)).reverse().sort().reverse();
        gterm_sort.access(BAT_APPEND);
        gterm_sort.mmap(1);
        var gtag_sort := bat(_tj_TagBat(ftiName)).reverse().sort().reverse();
        gtag_sort.access(BAT_APPEND);
        gtag_sort.mmap(1);

        collBat.replace("_globalTerms", gterm_sort);
        collBat.replace("_globalTags", gtag_sort);
        var replaceBats := collBat.find("replaceBats");
        replaceBats.insert("_globalTerms", _tj_TermBat(ftiName));
        replaceBats.insert("_globalTags", _tj_TagBat(ftiName));
        replaceBats.insert("_globalTags", _tj_RTagBat(ftiName));
    
    }
    collBat.find("submitBats").append(_tj_TermBat(ftiName));
    collBat.find("submitBats").append(_tj_TagBat(ftiName));
    collBat.find("submitBats").append(_tj_RTagBat(ftiName));
    
    if ( timing ) {
        var ms := (usec()-t_start)/1000;
        printf("#C[%s]:finalize(): total time = %lld.%03llds.\n",ftiName,/(ms,1000),%(ms,1000));
    }
}

# set a collection parameter
PROC _tj_set_parameter(BAT[str,bat] collBat, str par, str val) : void
{
	var parbat := collBat.find("_param");

	if ( parbat.exist(par) ) {
	    parbat.replace(par,val);
	} else {
	    parbat.insert(par,val);
	}
}

# set a collection parameter
PROC tj_set_parameter(str ftiName, str par, str val) : void
{
    if ( verbose ) printf("#TJ:tj_set_parameterl(%s,%s,%s) called.\n",ftiName,par,val);
    var coll_lock := tj_get_collection_lock(ftiName);
    lock_set(coll_lock);
    var err := CATCH({
	var parbat := bat("tj_" + ftiName + "_param");

	if ( parbat.exist(par) ) {
	    parbat.replace(par,val);
	} else {
	    parbat.insert(par,val);
	}
    });
    lock_unset(coll_lock);
    if (not(isnil(err))) ERROR(err);
}

# get a collection parameter
PROC _tj_get_parameter(BAT[str,bat] collBat, str par) : str
{
	var parbat := collBat.find("_param");

	if ( parbat.exist(par) ) {
	    return parbat.find(par);
	} else {
	    return str(nil);
	}
}

PROC tj_dump_collection(str ftiName) : void
{
    var coll_lock := tj_get_collection_lock(ftiName);
    lock_set(coll_lock);
    var err := CATCH({
	bat("tj_" + ftiName + "_param").print();
	bat("tj_" + ftiName + "_doc_name").print();
	bat("tj_" + ftiName + "_doc_firstpre").print();
	# print(bat("tj_" + ftiName + "_doc_name"),bat("tj_" + ftiName + "_doc_firstpre"));
	bat(_tj_TermBat(ftiName)).print();
	bat(_tj_TagBat(ftiName)).print();
	print(bat("tj_" + ftiName + "_tid1"));
	print(bat("tj_" + ftiName + "_size1"));
	print(bat("tj_" + ftiName + "_pfpre"));
	print(bat("tj_" + ftiName + "_conceptdict"));
	print(bat("tj_" + ftiName + "_concept_tid"));
	print(bat("tj_" + ftiName + "_concept_elem"));
	print(bat("tj_" + ftiName + "_concept_score"));
	print(bat("tj_" + ftiName + "_fragments"));
	# print(bat("tj_" + ftiName + "_height"));
    });
    lock_unset(coll_lock);
    if (not(isnil(err))) ERROR(err);
}

PROC tj_size_collection(str ftiName) : void
{
    var sum := batdsksize(bat("tj_" + ftiName + "_tagdict"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_termdict"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_Tags"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_Terms"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TagIndex"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TermIndex"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TagSize"));
    print(sum);
}

PROC tj_size_collection2(str ftiName) : void
{
    var sum := batdsksize(bat("tj_" + ftiName + "_tagdict"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_termdict"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_Tags"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_Terms"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TagIndex"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_TermIndex"));
    sum :+=  batdsksize(bat("tj_" + ftiName + "_size1"));
    print(sum);
}

#####################################################################
#                                                                   #
# The query section				                    #
#                                                                   #
#####################################################################

# tijah function to 'package' a pathfinder [iter|item|kind|pos] operand
PROC tj_pfop(	BAT[void,oid] iter,
		BAT[void,any] item,
		BAT[void,int] kind,
		BAT[void,oid] pos) : BAT[void,bat] :=
{
	var res := new(void,bat).seqbase(0@0);

	res.append(iter);
	res.append(item);
	res.append(kind);
	res.append(pos);

	return res;
}

# universal tijah query function handler. Sould work in the milprint_summer
# and in the algebra context.
PROC tj_query_handler(
	bit par_storeScore,
	BAT[void,bat] pfop_sn,
	BAT[void,bat] pfop_query,
	BAT[void,bat] pfop_opt,
	BAT[oid,any]  par_loop,
	BAT[oid,bat]  par_ws,
	BAT[void,lng] par_int_values,
	BAT[void,dbl] par_dbl_values,
        BAT[void,str] par_str_values,
	BAT[void,bat] par_scoreDB
	) : BAT[void,bat] :=
{
     var result_id;
     var result_iter;
     var result_item;
     var result_pos;
     var result_frag;

     if ( par_storeScore ) {
      result_id   := new(void,lng).seqbase(0@0);
     } else {
      result_iter := new(void,oid).seqbase(0@0);
      result_item := new(void,oid).seqbase(0@0);
      result_pos  := new(void,oid).seqbase(0@0);
      result_frag := new(void,oid).seqbase(0@0);
     }

     var has_sn      := (pfop_sn.count() > 0);
     var has_options := (pfop_opt.count() > 0);

     par_loop@batloop() { # begin batloop over queries
      var optbat;
      if ( has_options ) {
       iter := pfop_opt.fetch(0@0).select($t);
       item := pfop_opt.fetch(1@0).semijoin(iter);
       kind := pfop_opt.fetch(2@0).semijoin(iter);
       iter := iter.tmark(0@0);
       item := item.tmark(0@0);
       kind := kind.tmark(0@0);
       optbat := serialize_tijah_opt(par_ws,1,iter,iter,item,kind,par_int_values,par_dbl_values,par_str_values);
      } else {
       optbat := new(str,str,32);
      }
      var ftindex := tj_get_ft_index(optbat,true);
      tijah_lock := tj_get_collection_lock(ftindex);
      lock_set(tijah_lock);
      var startNodes;
      if ( has_sn ) {
       iter := pfop_sn.fetch(0@0);
       var iteration := pfop_query.fetch(0@0).fetch(int($h));
       iter := iter.select(iteration);
       item := pfop_sn.fetch(1@0).semijoin(iter);
       kind := pfop_sn.fetch(2@0).semijoin(iter);
       item := item.tmark(0@0);
       kind := kind.tmark(0@0);
       var xdoc_name := bat("tj_" + ftindex + "_doc_name");
       var xdoc_firstpre := bat("tj_" + ftindex + "_doc_firstpre");
       var xpfpre := bat("tj_" + ftindex + "_pfpre");
       var doc_loaded := reverse(par_ws.fetch(OPEN_CONT)).leftfetchjoin(par_ws.fetch(OPEN_NAME));
       startNodes := pf2tijah_node(xdoc_name,xdoc_firstpre,xpfpre,item,kind,doc_loaded);
      } else {
       startNodes := new(void,oid);
      }
      optbat.access(BAT_WRITE);
      optbat.insert("_query",pfop_query.fetch(1@0).fetch(int($h)));
      var nexi_allscores := run_tijah_query(ftindex,optbat,has_sn,startNodes);
      var nexi_score;
      if ( optbat.exist("returnNumber") ) {
       var retNum := int(optbat.find("returnNumber"));
       nexi_score := nexi_allscores.slice(0, retNum - 1);
      } else {
       nexi_score := nexi_allscores;
      }
      var docpre := bat("tj_" + ftindex + "_doc_firstpre").[oid]();
      var pfpre :=  bat("tj_" + ftindex + "_pfpre");
      item  := nexi_score.hmark(0@0);
      var frag := [find_lower](const docpre.reverse().mark(0@0), item);
      item := item.join(pfpre).sort().tmark();
      var needed_docs := bat("tj_" + ftindex + "_doc_name").semijoin(frag.tunique());
      lock_unset(tijah_lock);
      tijah_lock := lock_nil;
      var loaded_docs := par_ws.fetch(OPEN_NAME).reverse();
      var docs_to_load := kdiff(needed_docs.reverse(),loaded_docs).hmark(0@0);
      ws_opendoc(par_ws, docs_to_load);
      var doc_loaded := reverse(par_ws.fetch(OPEN_CONT)).leftfetchjoin(par_ws.fetch(OPEN_NAME));
      var fid_pffid := needed_docs.join(doc_loaded.reverse());
      frag := frag.join(fid_pffid).sort().tmark();
      if ( par_storeScore ) {
       var tID := oid(par_scoreDB.fetch(0@0).count() + 10000);
       par_scoreDB.fetch(4@0).insert(lng(tID),lng(nexi_allscores.count()));
       par_scoreDB.fetch(0@0).append(item.project(tID));
       par_scoreDB.fetch(1@0).append(frag);
       par_scoreDB.fetch(2@0).append(item);
       par_scoreDB.fetch(3@0).append(nexi_score.tmark());
       result_id.append(lng(tID));
      } else {
       result_iter.append(item.project($t));
       result_pos.append(item.mark(1@0));
       result_frag.append(frag);
       result_item.append(item);
      }
     } # end batloop over queries
     if ( par_storeScore ) {
      item := int_values.addValues(result_id).tmark(0@0);
      iter := par_loop.tmark(oid(0));
      ipik := iter;
      pos  := oid(1);
      kind := INT;
     } else {
      iter := result_iter;
      pos := result_pos;
      kind := set_kind(result_frag, ELEM);
      item := result_item;
      ipik := iter;
     }
     var res := tj_pfop(iter.materialize(ipik),item.materialize(ipik),kind.materialize(ipik),pos.materialize(ipik));
     #
     return res;
}

var nexi_score_xfer  := nil;
var nexi_sn_xfer     := nil;
var nexi_parser_lock := lock_create();

PROC run_tijah_query(str ftiName, BAT[str,str] opt, bit use_startnodes, BAT[void,oid] nodes) : BAT[oid,dbl] :=
{
	if ( verbose ) printf("#TJ:run_tijah_query(\"%s\",..) called.\n",ftiName);
	var parambat := bat("tj_" + ftiName + "_param");
	var rtagbat  := bat(_tj_RTagBat(ftiName));

	var delfin   := lng(parambat.find("delay_finalize"));
        if ( delfin > lng(0) ) {
	    if ( verbose ) printf("#TJ:run_tijah_query(\"%s\",..) checking delayed finalize.\n",ftiName);
            var finlast  := lng(parambat.find("_last_finalizedPre"));
            var prelast  := lng(parambat.find("_last_tijahPre"));
	    if ( not(prelast=finlast) ) {
	        if ( verbose ) printf("#TJ:run_tijah_query(\"%s\",..) performing delayed finalize (%d != %d).\n",ftiName,int(finlast),int(prelast));
                var collBat := _tj_collection(ftiName);
                _tj_finalize_collection(ftiName, collBat, TRUE);
                _tj_commit(collBat); 
	    }
	}
	var res := nil;
        lock_set(nexi_parser_lock);
        var err := CATCH({
	    nexi_sn_xfer := nodes;
	    _run_tijah_query(opt,rtagbat,use_startnodes);
	    res := nexi_score_xfer;
        });
	nexi_score_xfer := nil;
	nexi_sn_xfer := nil;
        lock_unset(nexi_parser_lock);
        if (not(isnil(err))) ERROR(err);
	return res;
}

#####################################################################
#								    #
#								    #
# Experimental algebra section					    #
#								    #
#								    #
#####################################################################

# tijah function to 'package' an algebra [iter|item|kind|pos] operand
PROC ALG_tj_pfop(
		BAT[oid,oid] iter,
		BAT[oid,any] item,
		int          noKind,
		BAT[oid,oid] pos) : BAT[void,bat] :=
{
	var res := new(void,bat).seqbase(0@0);

	res.append(iter);
	res.append(item);
	res.append(item.project(0));
	res.append(pos);

	return res;
}

PROC ALG_tj_pfop(
		BAT[oid,oid] iter,
		BAT[oid,any] item,
		BAT[oid,oid] frag,
		BAT[oid,oid] pos) : BAT[void,bat] :=
{
	var res := new(void,bat).seqbase(0@0);

	res.append(iter);
	res.append(item);
	res.append(frag);
	res.append(pos);

	return res;
}

PROC ALG_tj_ft_index_info(
	BAT[oid,bat]  par_ws,
	BAT[void,any] par_loop,
	BAT[oid,bat]  pfop_names
	) : BAT[void,bat] :=
{
        var ret;

	if ( pfop_names.count() > 0 ) {
	    ret := ws_ft_index_info(ws, pfop_names.fetch(1@0),false);

	} else {
	    ret := reverse(par_loop).cross(ws_ft_index_info(ws,false));
	}
	var iter := ret.hmark(0@0);
	var item := ret.tmark(0@0);
	var ipik := item;
	var frag := WS;
	frag     := frag.materialize(ipik);
	var pos  := tmark_grp_unique(iter,ipik);

        var res := ALG_tj_pfop(iter,item,frag,pos);
        if ( verbose ) printf("# ALG_tj_ft_index_info: FINISH.\n");
        return res;
}

PROC ALG_tj_query_nodes(
	BAT[void,any] par_loop,
	BAT[oid,bat]  pfop_id,
	BAT[oid,bat]  tijah_scoreDB
	) : BAT[void,bat] :=
{
        if ( verbose ) printf("# ALG_tj_query_nodes: START.\n");
	var item := new(void,oid).seqbase(0@0);
	var iter := new(void,oid).seqbase(0@0);
	var pos  := new(void,oid).seqbase(0@0);
	var frag := new(void,oid).seqbase(0@0);
	par_loop@batloop() { # begin of query batloop
	    var qid := oid(pfop_id.fetch(1).fetch(int($h)));
	    var tmp := tijah_scoreDB.fetch(0@0).ord_uselect(qid);
	    item.append(tmp.mirror().leftfetchjoin(tijah_scoreDB.fetch(2@0)));
	    iter.append(tmp.project(par_loop.fetch(int($h))));
	    frag.append(tmp.mirror().leftfetchjoin(tijah_scoreDB.fetch(1@0)));
	    pos.append(tmp.mark(1@0));
	} # end of query batloop
        var res := ALG_tj_pfop(iter,item,frag,pos);
        if ( verbose ) printf("# ALG_tj_query_nodes: FINISH.\n");
        return res;
}

PROC ALG_tj_query_score(
	BAT[void,any] par_loop,
	BAT[oid,bat]  pfop_id,
	BAT[oid,bat]  pfop_nodes,
	BAT[oid,bat]  tijah_scoreDB
	) : BAT[void,bat] :=
{
	var score := new(oid,dbl);
	var tmp := [<<]([lng](tijah_scoreDB.fetch(1@0)), const 32);
	var tijah_fragpre := [+](tmp, [lng](tijah_scoreDB.fetch(2@0)));
	tmp := nil;
	var item1_unique := pfop_id.fetch(1).tunique();
	var item := pfop_nodes.fetch(1);
	var kind := pfop_nodes.fetch(2);
	item1_unique@batloop() {
	    var item_part := item.semijoin(pfop_id.fetch(1).uselect($h));
	    var frag_part := kind.semijoin(item_part);
	    frag_part := [<<]([lng](frag_part), const 32);
	    var fragpre_part := [+](frag_part, [lng](item_part));

	    item_part := nil;
	    frag_part := nil;
	    tmp := tijah_scoreDB.fetch(0@0).uselect(oid($h));
	    tmp := tmp.mirror().leftfetchjoin(tijah_fragpre);
	    tmp := tmp.join(fragpre_part.reverse());
	    score.insert(tmp.reverse().leftfetchjoin(tijah_scoreDB.fetch(3@0)));
	}
	var xitem := kdiff(item,score).project(dbl(0));
	score.insert(xitem);
	xitem := nil;
	score := score.sort().tmark(0@0);

        var iter := par_loop.tmark(0@0);
	var ipik := iter;
	var pos  := 1@0;
        var res := ALG_tj_pfop(iter,score,0,pos.materialize(ipik));
        if ( verbose ) printf("# ALG_tj_query_nodes: FINISH.\n");
        return res;
}

# temporary algebra query handler
PROC ALG_tj_query_handler(
        bit par_storeScore,
        BAT[oid,bat] pfop_sn,
        BAT[oid,bat] pfop_query,
        BAT[oid,bat] pfop_opt,
        BAT[void,any]  par_loop,
        BAT[oid,bat]  par_ws,
        BAT[oid,bat] par_scoreDB
        ) : BAT[void,bat] :=
{
     var result_id;
     var result_iter;
     var result_item;
     var result_pos;
     var result_frag;

    if ( verbose ) printf("# ALG_tj_query_handler: START.\n");
     if ( par_storeScore ) {
      if ( verbose ) printf("# ALG_tj_query_handler: storeScore=TRUE.\n");
      result_id   := new(void,lng).seqbase(0@0);
     } else {
      if ( verbose ) printf("# ALG_tj_query_handler: storeScore=FALSE.\n");
      result_iter := new(void,oid).seqbase(0@0);
      result_item := new(void,oid).seqbase(0@0);
      result_pos  := new(void,oid).seqbase(0@0);
      result_frag := new(void,oid).seqbase(0@0);
     }

     var has_sn      := (pfop_sn.count() > 0);
     var has_options := (pfop_opt.count() > 0);

     par_loop@batloop() {
      var optbat;
      if ( verbose ) printf("# ALG_tj_query_handler: loop start, id=%d.\n",$t);
      if ( has_options ) {
       if ( verbose ) printf("# ALG_tj_query_handler: running option handler.\n");
       var opt_iter := pfop_opt.fetch(0@0).select($t);
       var opt_item := pfop_opt.fetch(1@0).semijoin(opt_iter);
       var opt_kind := pfop_opt.fetch(2@0).semijoin(opt_iter);
       opt_iter := opt_iter.tmark(0@0);
       opt_item := opt_item.tmark(0@0);
       opt_kind := opt_kind.tmark(0@0);
       optbat := serialize_tijah_opt(par_ws,1,opt_iter,opt_iter,opt_item,set_kind(opt_kind,ELEM),new(void,lng),new(void,dbl),new(void,str));
       if ( verbose ) optbat.print();
      } else {
       optbat := new(str,str,32);
      }
      if ( verbose ) printf("# ALG_tj_query_handler: handle startNodes.\n");
      var ftindex := tj_get_ft_index(optbat,true);
      var tijah_lock := tj_get_collection_lock(ftindex);
      lock_set(tijah_lock);
      var err := CATCH({
        var startNodes;
        if ( has_sn ) {
         var sn_iter := pfop_sn.fetch(0@0);
         var sn_iteration := pfop_query.fetch(0@0).fetch(int($h));
         sn_iter := sn_iter.select(sn_iteration);
         var sn_item := pfop_sn.fetch(1@0).semijoin(sn_iter);
         var sn_kind := pfop_sn.fetch(2@0).semijoin(sn_iter);
         sn_item := sn_item.tmark(0@0);
         sn_kind := sn_kind.tmark(0@0);

         var xdoc_name := bat("tj_" + ftindex + "_doc_name");
         var xdoc_firstpre := bat("tj_" + ftindex + "_doc_firstpre");
         var xpfpre := bat("tj_" + ftindex + "_pfpre");
         var doc_loaded := par_ws.fetch(CONT_COLL).join(bat("doc_collection").reverse()).join(bat("doc_name"));
         if ( verbose ) printf("# ALG_tj_query_handler: compute startnodes\n");
         startNodes := pf2tijah_node(xdoc_name,xdoc_firstpre,xpfpre,sn_item,[int](sn_kind),doc_loaded);
        } else {
         startNodes := new(void,oid);
        }
        optbat.access(BAT_WRITE);
        optbat.insert("_query",pfop_query.fetch(1@0).fetch(int($h)));
        if ( verbose ) printf("# ALG_tj_query_handler: run tijah query.\n");
        var nexi_allscores := run_tijah_query(ftindex,optbat,has_sn,startNodes);
        var nexi_score;
        if ( verbose ) printf("# ALG_tj_query_handler: handling scores.\n");
        if ( optbat.exist("returnNumber") ) {
         var retNum := int(optbat.find("returnNumber"));
         nexi_score := nexi_allscores.slice(0, retNum - 1);
        } else {
         nexi_score := nexi_allscores;
        }
        var docpre := bat("tj_" + ftindex + "_doc_firstpre").[oid]();
        var pfpre  :=  bat("tj_" + ftindex + "_pfpre");
        var item   := nexi_score.hmark(0@0);
        var frag := [find_lower](const docpre.reverse().mark(0@0), item);
        item := item.join(pfpre).sort().tmark();
        var needed_docs := bat("tj_" + ftindex + "_doc_name").semijoin(frag.tunique());
        var loaded_docs := par_ws.fetch(OPEN_NAME).reverse();
        var docs_to_load := kdiff(needed_docs.reverse(),loaded_docs).hmark(0@0);
        ws_opendoc(par_ws, docs_to_load);
        var doc_loaded := reverse(par_ws.fetch(OPEN_CONT)).leftfetchjoin(par_ws.fetch(OPEN_NAME));
	# On the forced document loading size we keep using the old interface
	# until ws.fetch(OPEN_CONT|OPEN_DOC) disappears. This interface is
	# much cheaper for us and works also correct when the OPEN_CONT|DOC
	# bats are not complete.
	# var doc_loaded := par_ws.fetch(CONT_COLL).join(bat("doc_collection").reverse()).join(bat("doc_name"));
        var fid_pffid := needed_docs.join(doc_loaded.reverse());
        frag := frag.join(fid_pffid).sort().tmark();
        if ( verbose ) printf("# ALG_tj_query_handler: handled new frags/documents.\n");
        if ( par_storeScore ) {
         var tID := oid(par_scoreDB.fetch(0@0).count() + 8888);
         par_scoreDB.fetch(4@0).insert(lng(tID),lng(nexi_allscores.count()));
         par_scoreDB.fetch(0@0).append(item.project(tID));
         par_scoreDB.fetch(1@0).append(frag);
         par_scoreDB.fetch(2@0).append(item);
         par_scoreDB.fetch(3@0).append(nexi_score.tmark());
         result_id.append(lng(tID));
         if ( verbose ) printf("# ALG_tj_query_handler: stored loop score.\n");
        } else {
         result_iter.append(item.project($t));
         result_pos.append(item.mark(1@0));
         result_frag.append(frag);
         result_item.append(item);
        }
      });
      lock_unset(tijah_lock);
      if ( verbose ) printf("# ALG_tj_query_handler: released lock.\n");
      if (not(isnil(err))) ERROR(err);
       if ( verbose ) printf("# ALG_tj_query_handler: stored loop nodes in result.\n");
      if ( verbose ) printf("# ALG_tj_query_handler: loop finish, id=%d.\n",$t);
     } # end batloop over queries
     if ( verbose ) printf("# ALG_tj_query_handler: batloop finished.\n");
     var iter;
     var item;
     var ipik;
     var kind;
     var pos;
     if ( par_storeScore ) {
      if ( verbose ) printf("# ALG_tj_query_handler: create int return.\n");
      item := result_id;
      iter := par_loop.tmark(oid(0));
      ipik := iter;
      pos  := oid(1);
      kind := new(oid,oid);
     } else {
      if ( verbose ) printf("# ALG_tj_query_handler: create node return.\n");
      iter := result_iter;
      pos  := result_pos;
      kind := result_frag;
      item := result_item;
      ipik := iter;
     }
      if ( verbose ) {
         printf("# ALG_tj_query_handler: iter/item/kind/pos result start\n");
         iter.print();
         item.print();
         kind.print();
         pos.print();
         printf("# ALG_tj_query_handler: iter/item/kind/pos result finish\n");
      }
     var res := ALG_tj_pfop(iter,item,kind,pos.materialize(ipik));
     #
     if ( verbose ) printf("# ALG_tj_query_handler: FINISH.\n");
     return res;
}

PROC ALG_tj_add_fti_tape(
	str           op,
	BAT[oid,bat]  pfop_coll,
	BAT[oid,bat]  pfop_opt,
	BAT[void,any] par_loop,
	BAT[oid,bat]  par_ws,
	BAT[str,bat]  tape
	) : BAT[str,bat] :=
{
        if ( verbose ) printf("# ALG_tj_add_fti_tape: START.\n");
        var has_coll := (pfop_coll.count() > 0);
        var has_opt  := (pfop_opt.count() > 0);
        par_loop@batloop() {
            if ( verbose ) printf("# ALG_tj_query_handler: loop start, id=%d.\n",$t);

	    var collbat;
	    if ( has_coll ) {
       	        if ( verbose ) printf("# ALG_tj_add_fti_tape: start collection handler.\n");
       		var iter := pfop_coll.fetch(0@0).select($t);
       		collbat := pfop_coll.fetch(1@0).semijoin(iter);

		if ( collbat.select("*").count() > 0 ) {
			ERROR("not possible to use wildcards for pfcollections.");
		}
	    } else {
       	        if ( verbose ) printf("# ALG_tj_add_fti_tape: no collection.\n");
	        collbat := new(void,str).seqbase(0@0);
		collbat.append("*");
	    }

	    var optbat;
            if ( has_opt ) {
       	        if ( verbose ) printf("# ALG_tj_add_fti_tape: running option handler.\n");
       		var opt_iter := pfop_opt.fetch(0@0).select($t);
       		var opt_item := pfop_opt.fetch(1@0).semijoin(opt_iter);
       		var opt_kind := pfop_opt.fetch(2@0).semijoin(opt_iter);
       		opt_iter := opt_iter.tmark(0@0);
       		opt_item := opt_item.tmark(0@0);
       		opt_kind := opt_kind.tmark(0@0);
       		optbat := serialize_tijah_opt(par_ws,1,opt_iter,opt_iter,opt_item,set_kind(opt_kind,ELEM),new(void,lng),new(void,dbl),new(void,str));
       		if ( verbose ) optbat.print();
            } else {
       	        if ( verbose ) printf("# ALG_tj_add_fti_tape: no options.\n");
                optbat := new(str,str,32);
            } 

            if ( verbose ) printf("# ALG_tj_query_handler: writing tape.\n");
	    var bb := new(void,bat).seqbase(0@0);
	    bb.append(collbat);
	    bb.append(optbat);
	    tape.insert(op,bb);
	    if ( verbose ) tape.print();
            if ( verbose ) printf("# ALG_tj_query_handler: end loop start, id=%d.\n",$t);
	}
        if ( verbose ) printf("# ALG_tj_add_fti_tape: FINISH.\n");
	return tape;
}

#PROC DocmgmTape(BAT[void,BAT] ws,
#                BAT[void,str] location,
#                BAT[void,str] docname,
#                BAT[void,str] colname,
#                BAT[void,lng] percentage) : void
#{
#    var del_doc := percentage.ord_uselect(-1LL).hmark(0@0);
#    var add_doc := percentage.ord_uselect(0LL,lng_nil).hmark(0@0);
#
#    shred_doc_base(del_doc(bit_nil, del_doc.leftfetchjoin(docname), true),
#                   add_doc.leftfetchjoin(location),
#                   add_doc.leftfetchjoin(docname),
#                   add_doc.leftfetchjoin(colname),
#                   add_doc.leftfetchjoin(percentage),
#                   stream_nil, ws_id(ws));
#}

PROC ALG_tj_docmgmt_tape(BAT[str,bat] tape,
		      	 BAT[void,BAT] ws,
                	 BAT[void,str] location,
                	 BAT[void,str] docnames,
                	 BAT[void,str] colnames,
                	 BAT[void,lng] percentages) : bit :=
{
        if ( verbose ) printf("# ALG_tj_docmgmt_tape: START.\n");
	#
	# INCOMPLETE, CHECK IF THIS REALLY STILL WORKS
	#
        if (isnil(CATCH(bat("tj_collName").count()))) {
	    # pftijah is active
            if ( verbose ) printf("# ALG_tj_docmgmt_tape: running document management.\n");
            var del_doc    := percentages.ord_uselect(-1LL).hmark(0@0); 
            var add_doc    := percentages.ord_uselect(0LL,lng_nil).hmark(0@0); 
	    if ( verbose ) {
	        printf("# ALG_tj_docmgmt_tape: deleted docs are:\n");
	        del_doc.print();
	        printf("# ALG_tj_docmgmt_tape: added docs are:\n");
	        add_doc.print();
	    }
            #
            var pfc_name   := docnames.reverse().leftfetchjoin(colnames);
            var pfdep      := bat("tj_pfc_fti_dep");
            var pfdep_star := bat("tj_pfc_fti_dep_star");
            var fti_dname  := pfdep.join(pfc_name.reverse());
            if ( pfdep_star.count() > 0 ) {
                fti_dname.insert(pfdep_star.cross(pfc_name.reverse()));
            }

            var fti_cluster := new(str,bat);
            fti_dname@batloop() {
                var cb;
                if ( fti_cluster.exist($h) ) {
                  cb := fti_cluster.find($h);
                } else {
                  cb := new(str,str);
                  fti_cluster.insert($h,cb);
                }
                cb.insert(str(nil),$t);
            }
            fti_cluster@batloop() {
                if ( verbose ) { printf("#TJ:tj_play_doc_tape() doing ft-index \"%s\".\n",$h); $t.print(); }
                tj_add2collection($h,$t,false);
            }
	} else {
	    # pftijah is not active
	    if ( verbose ) printf("# ALG_tj_docmgmt_tape: skipping doc managemnt.\n");
	}

        if ( verbose ) printf("# ALG_tj_docmgmt_tape: running collection management.\n");
        tape@batloop() {
	    var op       := $h;
	    var collbat  := $t.fetch(0@0);
	    var optbat   := $t.fetch(1@0);
	    var fti_name := tj_get_ft_index(optbat,(op!="create"));

	    if ( op = "create" ) {
                if ( verbose ) printf("# ALG_tj_docmgmt_tape: tj_init_collection(%s).\n",fti_name);
	        tj_init_collection(fti_name,optbat,collbat);
	    } else if ( op = "extend" ) {
                if ( verbose ) printf("# ALG_tj_docmgmt_tape: tj_extend_collection(%s).\n",fti_name);
	        tj_extend_collection(fti_name,collbat);
	    } else if ( op = "remove" ) {
                if ( verbose ) printf("# ALG_tj_docmgmt_tape: tj_delete_collection(%s).\n",fti_name);
	        tj_delete_collection(fti_name);
	    } else {
	    	ERROR("ALG_tj_docmgmt_tape: unknown op");
	    }
	}
        if ( verbose ) printf("# ALG_tj_docmgmt_tape: FINISH.\n");
	return true;
}

var tracefile_handle := nil;
PROC tj_trace( str s ) : void := 
{
    if ( not( tracefile = "" ) ) {
        if ( isnil( tracefile_handle ) )
            tracefile_handle := open_wastream(tracefile);
        
        tracefile_handle.stream_write( sprintf( "%d %s\n", int(msec()/1000), s ) );
        tracefile_handle.stream_flush();
    }
}

#
#
#

PROC tj_is_indexed(str collName) : bit :=
{
    if (isnil(CATCH(bat("tj_pfc_fti_dep").count()))) {
	if ( bat("tj_pfc_fti_dep_star").count() > 0 ) {
	    # eg. all collections are indexed
            return TRUE;
	} else {
	    return bat("tj_pfc_fti_dep").reverse().exist(collName);
	}
    } else {
        return FALSE;
    }
}

PROC tj_play_doc_tape(BAT[void,BAT] ws,
                      BAT[void,oid] item, 
                      BAT[void,int] kind, 
                      BAT[void,lng] int_values, 
                      BAT[void,str] str_values) : void
{
    if (isnil(CATCH(bat("tj_pfc_fti_dep").count()))) {
      if ( bat("tj_pfc_fti_dep").count() > 0 ) {
        if ( verbose ) printf("#TJ:tj_play_doc_tape() start.\n");
        var IDoid       := [and]([lng](item.mirror()), 3LL).ord_uselect(0LL).hmark(0@0);
        var IDlng       := IDoid.[lng]();
        var locations   := IDoid.leftfetchjoin(item).leftfetchjoin(str_values);
        var names       := [+](IDlng, 1).[oid]().leftfetchjoin(item).leftfetchjoin(str_values);
        var colnames    := [+](IDlng, 2).[oid]().leftfetchjoin(item).leftfetchjoin(str_values);
        var percentages := [+](IDlng, 3).[oid]().leftfetchjoin(item).leftfetchjoin(int_values);
        var del_doc     := percentages.ord_uselect(-1LL).hmark(0@0); 
        var add_doc     := percentages.ord_uselect(0LL,lng_nil).hmark(0@0); 
        #
        var pfc_name   := names.reverse().leftfetchjoin(colnames);
        var pfdep      := bat("tj_pfc_fti_dep");
        var pfdep_star := bat("tj_pfc_fti_dep_star");
        var fti_dname  := pfdep.join(pfc_name.reverse());
        if ( pfdep_star.count() > 0 ) {
            fti_dname.insert(pfdep_star.cross(pfc_name.reverse()));
        }

        var fti_cluster := new(str,bat);
        fti_dname@batloop() {
            var cb;
            if ( fti_cluster.exist($h) ) {
              cb := fti_cluster.find($h);
            } else {
              cb := new(str,str);
              fti_cluster.insert($h,cb);
            }
            cb.insert(str(nil),$t);
        }
        fti_cluster@batloop() {
            if ( verbose ) { printf("#TJ:tj_play_doc_tape() doing ft-index \"%s\".\n",$h); $t.print(); }
            tj_add2collection($h,$t,false);
        }
        if ( verbose ) printf("#TJ:tj_play_doc_tape() finished.\n");
      }
    }
}

#####################################################################
#								    #
#								    #
#            IMPLEMENTATION OF PHYSICAL SRA OPERATORS		    #
#								    #
#								    #
#####################################################################


#####################################################################
# SELECTION
#####################################################################

##
# Select all element nodes in the collection
# Returns a bat [pre, any].
##
PROC tj_select_star() : bat[oid,any] := 
{
    # deselect document root
    return bat("tj_" + ftindex + "_pfpre").slice(1, bat("tj_" + ftindex + "_pfpre").count() - 1);
}

##
# Select all startNodes (node context set coming from pathfinder)
# Returns a bat [pre, any].
##
PROC tj_select_startnodes() : bat[oid,any] :=
{
    return nexi_sn_xfer.reverse();
}

##
# Select all element nodes in the collection with the given name
# Returns a bat [nid, any].
##
PROC tj_select_tag(str name) : bat[oid,any] :=
{
    var tids := bat("tj_" + ftindex + "_tagdict").select(name);
    if (tids.count() = 0) return new(oid,dbl);
    var tid := int(tids.reverse().fetch(0));
    var index := bat("tj_" + ftindex + "_TagIndex");
    var offset1 := int(index.fetch(tid));
    var offset2 := int(index.fetch(tid + 1)) - 1;
    return bat("tj_" + ftindex + "_Tags").slice(offset1, offset2).chk_order();
}

#####################################################################
# ADD PRE IDs 
#####################################################################

##
# associate pre identifiers to the nid identifiers
# Returns a bat [nid, pre].
##
PROC tj_add_pre(bat[oid,any] nid_score) : bat[oid,oid] :=
{
    return bat("tj_" + ftindex + "_Tags").semijoin(nid_score).chk_order();
}

#####################################################################
# ID TRANSLATION
#####################################################################

##
# Translate all nid identifiers to pre identifiers
# Returns a bat [pre, any].
##
PROC tj_nid2pre(bat[oid,any] nid_score) : bat[oid,any] :=
{
    return nid_score.reverse().leftfetchjoin(bat("tj_" + ftindex + "_Tags")).reverse().chk_order();
}

##
# Translate all pre identifiers to nid identifiers
# Returns a bat [nid, any].
##
PROC tj_pre2nid(bat[oid,any] pre_score) : bat[oid,any] :=
{
    # todo: if join turns out to be expensive, we can slice out the part belonging to
    # the respective tagname. pre2nid is only used, if result region has a single tag-name.

    return pre_score.reverse().join(bat("tj_" + ftindex + "_Tags").reverse()).reverse().sort();
}

#####################################################################
# Contained_by
#####################################################################

@mil

@:contained_by_noprop_nid(nest)@
@:contained_by_noprop_nid(unnest)@
@= contained_by_noprop_nid
PROC tj_contained_by_noprop_@1_nid (bat[oid,oid] left, bat[oid,oid] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_TagSize");
    var right_left := treemergejoin_@1_nid(right, size, left);
    var result := left.semijoin(right_left.reverse()).chk_order();
    return result;
}
@mil

@:contained_by_noprop_pre(nest)@
@:contained_by_noprop_pre(unnest)@
@= contained_by_noprop_pre
PROC tj_contained_by_noprop_@1_pre (bat[oid,oid] left, bat[oid,oid] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_size1");
    var right_left := treemergejoin_@1_pre(right, size, left);
    var result := right_left.reverse().chk_order();
    return result;
}
@mil

PROC tj_contained_by_prop_nest_nid (bat[oid,any] left, bat[oid,dbl] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_TagSize");
    var left_pre := bat("tj_" + ftindex + "_Tags").semijoin(left).chk_order().tsort();
    var right_pre := bat("tj_" + ftindex + "_Tags").semijoin(right).chk_order().tsort();
    var right_left := treemergejoin_nest_nid(right_pre, size, left_pre);
    var left_score;
    if (downprop = "sum") {
        left_score := {sum}(right, right_left, right_left.reverse().kunique()).sort();
    }
    if (downprop = "max") {
        left_score := {max}(right, right_left, right_left.reverse().kunique()).sort(); 
    }
    return left_score;
}
PROC tj_contained_by_prop_unnest_nid (bat[oid,any] left, bat[oid,dbl] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_TagSize");
    var left_pre := bat("tj_" + ftindex + "_Tags").semijoin(left).chk_order().tsort();
    var right_pre := bat("tj_" + ftindex + "_Tags").semijoin(right).chk_order().tsort();
    var right_left := treemergejoin_unnest_nid(right_pre, size, left_pre);
    var left_score := right_left.reverse().join(right).sort(); 
    return left_score;
}
PROC tj_contained_by_prop_nest_pre (bat[oid,any] left, bat[oid,dbl] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_size1");
    var right_left := treemergejoin_nest_pre(right, size, left);
    var left_score;
    if (downprop = "sum") {
        left_score := {sum}(right, right_left, right_left.reverse().kunique()).sort();
    }
    if (downprop = "max") {
        left_score := {max}(right, right_left, right_left.reverse().kunique()).sort(); 
    }
    return left_score;
}
PROC tj_contained_by_prop_unnest_pre (bat[oid,any] left, bat[oid,dbl] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_size1");
    var right_left := treemergejoin_unnest_pre(right, size, left);
    var left_score := right_left.reverse().join(right).sort(); 
    return left_score;
}

#####################################################################
# Containing
#####################################################################

@mil

@:containing_noprop_nid(nest)@
@:containing_noprop_nid(unnest)@
@= containing_noprop_nid
PROC tj_containing_noprop_@1_nid (bat[oid,oid] left, bat[oid,oid] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_TagSize");
    var left_right := treemergejoin_@1_nid(left, size, right);
    var result := left.semijoin(left_right).chk_order();
    return result;
}
@mil

@:containing_noprop_pre(nest)@
@:containing_noprop_pre(unnest)@
@= containing_noprop_pre
PROC tj_containing_noprop_@1_pre (bat[oid,oid] left, bat[oid,oid] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_size1");
    var left_right := treemergejoin_@1_pre(left, size, right);
    var result := left_right.chk_order();
    return result;
}
@mil

@:containing_prop_nid(nest)@
@:containing_prop_nid(unnest)@
@= containing_prop_nid
PROC tj_containing_prop_@1_nid (bat[oid,any] left, bat[oid,dbl] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_TagSize");
    var left_pre := bat("tj_" + ftindex + "_Tags").semijoin(left).chk_order().tsort();
    var right_pre := bat("tj_" + ftindex + "_Tags").semijoin(right).chk_order().tsort();
    var left_right := treemergejoin_@1_nid(left_pre, size, right_pre);
    var left_score;
    if (upprop = "sum") {
        left_score := {sum}(right, left_right.reverse(), left_right.kunique()).sort();
    }
    if (upprop = "max") {
        left_score := {max}(right, left_right.reverse(), left_right.kunique()).sort(); 
    }
    return left_score;
}
@mil

@:containing_prop_pre(nest)@
@:containing_prop_pre(unnest)@
@= containing_prop_pre
PROC tj_containing_prop_@1_pre (bat[oid,any] left, bat[oid,dbl] right) : bat[oid,any] :=
{
    var size := bat("tj_" + ftindex + "_size1");
    var left_right := treemergejoin_@1_pre(left, size, right);
    var left_score;
    if (upprop = "sum") {
        left_score := {sum}(right, left_right.reverse(), left_right.kunique()).sort();
    }
    if (upprop = "max") {
        left_score := {max}(right, left_right.reverse(), left_right.kunique()).sort(); 
    }
    return left_score;
}
@mil

#####################################################################
# Containing_query
#####################################################################

PROC tj_term2tid (bat[str,dbl] term_score) : bat[oid,dbl] :=
{
    var param    := bat("tj_" + ftindex + "_param");
    var stemmer  := param.find("stemmer");
    var firstterm:= oid(param.find("lastStopWord"));
    
    var mark_term := term_score.hmark(0@0);
    var mark_score := term_score.tmark(0@0);
    var stemmed  := [tj_normalizeTerm]( [toLower](mark_term), stemmer );
    
    var mark_tid := stemmed.join(bat("tj_" + ftindex + "_termdict").reverse());
    mark_tid := mark_tid.select(firstterm,oid(nil),TRUE,FALSE);
    return mark_tid.reverse().leftfetchjoin(mark_score);
}

# returns the pre-order positions of the term t 
# in the collection of the documents
PROC _getTermPositions (oid tid) : bat[void,oid] := {
     var index := bat("tj_" + ftindex + "_TermIndex");
     var offset1 := int(index.fetch(int(tid)));
     var offset2 := int(index.fetch(int(tid) + 1));
     var res := bat("tj_" + ftindex + "_Terms").slice(offset1, offset2 - 1);
     res := res.seqbase(0@0).chk_order();
     return res;
}

@mil

@:getTermDocCnt_nid(nest)@
@:getTermDocCnt_nid(unnest)@
@= getTermDocCnt_nid
PROC _getTermDocCnt_@1_nid(BAT[oid,oid] e_pre, BAT[void,int] e_size, BAT[void,oid] t_pre) : BAT[oid,int] := {
     
	# get doc - term relation
        var e_tPre := treemergejoin_@1_nid(e_pre, e_size, t_pre);
        return e_tPre.reverse().histogram().sort();
}
@mil
@:getTermDocCnt_pre(nest)@
@:getTermDocCnt_pre(unnest)@
@= getTermDocCnt_pre
PROC _getTermDocCnt_@1_pre(BAT[oid,any] e_pre, BAT[void,int] e_size, BAT[void,oid] t_pre) : BAT[oid,int] := {
     
	# get doc - term relation
        var e_tPre := treemergejoin_@1_pre(e_pre, e_size, t_pre.reverse());
        return e_tPre.reverse().histogram().sort();
}
@mil

#             ___          qCnt(t) 
# LM(d|q) =   | |    dLH(t) 
#            t in q           
#
# where qCnt(t) = count of term t in query q
# where dLH(t) = likelihood of term t in doc d
#

PROC _score_LM(dbl q_tCnt, int c_tCnt, int cSize, BAT[oid,int] e_tCnt, BAT[void,int] e_size) : bat[oid,dbl] := {
    var e_tScores := e_tCnt.[dbl]().access(BAT_WRITE);
    e_tScores.left_div(e_size);
    e_tScores := [log](e_tScores);
    e_tScores := e_tScores.[*](q_tCnt);
    e_tScores := [exp](e_tScores);
    return e_tScores;
}


#              ___                                         qCnt(t)      
# LMs(d|q) =   | |    ( (1-lambda) dLH(t) + lambda cLH(t) ) 
#             t in q           
#
# where qCnt(t) = count of term t in query q
# where dLH(t) = likelihood of term t in doc d
# where cLH(t) = likelihood of term t in (background) collection c
#

PROC _score_LMs(dbl q_tCnt, int c_tCnt, int cSize, BAT[oid,int] e_tCnt, BAT[void,int] e_size) : bat[oid,dbl] := {
    var tmp1 := c_lambda * c_tCnt / dbl(cSize);
    var tmp2 := dbl(1) - c_lambda;
    
    var e_tScores := e_tCnt.[dbl]().access(BAT_WRITE);
    e_tScores.left_div(e_size);
    e_tScores := e_tScores.[*](tmp2);
    e_tScores := e_tScores.[+](tmp1);
    e_tScores := [log](e_tScores);
    e_tScores := e_tScores.[*](q_tCnt);
    e_tScores := [exp](e_tScores);
    return e_tScores;
}


#               __     qCnt(t)       /  (1 - lambda) * dLH(t)       \  
# NLLR(d|q) =   >_     ------- * log |  ----------------------  + 1 |  
#              t in q   qSize        \      lambda * cLH(t)         /  
#
# where qCnt(t) = count of term t in query q
# where qSize = number of terms in query q
# where dLH(t) = likelihood of term t in doc d
# where cLH(t) = likelihood of term t in (background) collection c
#

PROC _score_NLLR(dbl q_tCnt, dbl qSize, int c_tCnt, int cSize, BAT[oid,int] e_tCnt, BAT[void,int] e_size) : bat[oid,dbl] := {
    var collFac := ((dbl(1) - c_lambda) / c_lambda) * cSize / dbl(c_tCnt);
    var q_tLH := q_tCnt / qSize;
    var e_tScores := e_tCnt.[dbl]().access(BAT_WRITE);
    e_tScores.left_div(e_size);
    e_tScores := e_tScores.[*](collFac);
    e_tScores := e_tScores.[+](dbl(1));
    e_tScores := [log](e_tScores);
    e_tScores := e_tScores.[*](q_tLH);
    return e_tScores;
}

#             __                /  cNdoc  \            (cK1 + 1) tf(t)
# OKAPI(q) =  >_  qCnt(t) * log | ------- | * -------------------------------------
#            t in q             \  DF(t)  /   cK1*((1-cB) + cB*(DL / cAvgDL)) + tf(t)
#
# where cNdoc    = number of elements that is scored
# where cAvgDL   = average element length
# where DL       = element length
# where cIDF(t)  = idf instead of the Robertson/Sparck-Jones weight (variation on idf)
# where tf(t)    = term frequency (number of occurences of term t in element)
# where cK1      = tuning parameter k1
# where cB       = tuning parameter b
#

PROC _score_OKAPI(dbl q_tCnt, BAT[oid,int] e_tCnt, BAT[void,int] e_size, int cNdoc, dbl cAvgDL) : bat[oid,dbl] := {
    
    # cIDF contains Robertson/Sparck-Jones relevance weight
    var cIDF := e_tCnt.count(); # df
    cIDF  := log((cNdoc + 0.5) / (cIDF + 0.5));

    # cK contains length normalization 
    var cK := e_size.semijoin(e_tCnt); # document lengths
    cK := [/](cK, cAvgDL / okapi_b);
    cK := [+](cK, 1 - okapi_b);
    cK := [*](cK, okapi_k1);
    cK := [+](cK, e_tCnt);
    var tmp := [*](e_tCnt, okapi_k1 + 1);
    tmp := [/](tmp, cK);
    var e_tScores := [*](tmp, cIDF * q_tCnt);
    return e_tScores;
}


@:containing_query_LM(nest,nid,TagSize)@
@:containing_query_LM(unnest,nid,TagSize)@
@:containing_query_LM(nest,pre,size1)@
@:containing_query_LM(unnest,pre,size1)@
@= containing_query_LM
PROC tj_containing_query_@1_@2_LM (bat[oid,any] left, bat[oid,dbl] query) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(query) = 0 ) return new(oid,dbl);
    
    var t_qCnt := {sum}(query);
    
    var e_pre := left.chk_order();
    var cSize := bat("tj_" + ftindex + "_Terms").count();
    var e_size := bat("tj_" + ftindex + "_@3");
    var eScores := new(oid,dbl);
    
    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var t_pre := _getTermPositions($h);
        var c_tCnt := count(t_pre); 
        # get element count of term
	var e_tCnt := _getTermDocCnt_@1_@2(e_pre, e_size, t_pre);
	# score elements by this term
        var e_tScores := _score_LM($t, c_tCnt, cSize, e_tCnt, e_size);
        e_tCnt := nil;
        
	# aggregate term scores
        eScores := eScores.union_mul(e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
    var res;
    res := eScores;
    
    t_total :+= time();
    if (timing) printf("# LM timing: total: %d\n", t_total);
    return res;
}
@mil


@:containing_query_LMs(nest,nid,TagSize)@
@:containing_query_LMs(unnest,nid,TagSize)@
@:containing_query_LMs(nest,pre,size1)@
@:containing_query_LMs(unnest,pre,size1)@
@= containing_query_LMs
PROC tj_containing_query_@1_@2_LMs (bat[oid,any] left, bat[oid,dbl] query) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(query) = 0 ) return new(oid,dbl);
    
    var t_qCnt := {sum}(query);
    
    var e_pre := left.chk_order();
    var cSize := bat("tj_" + ftindex + "_Terms").count();
    var e_size := bat("tj_" + ftindex + "_@3");
    var eScores := new(oid,dbl);
    var score_base := dbl(1);
    
    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var t_pre := _getTermPositions($h);
        var c_tCnt := count(t_pre); 
        # get element count of term
	var e_tCnt := _getTermDocCnt_@1_@2(e_pre, e_size, t_pre);
	# score elements by this term
        var e_tScores := _score_LMs($t, c_tCnt, cSize, e_tCnt, e_size);
        e_tCnt := nil;
        var base := c_lambda * c_tCnt / dbl(cSize);
        score_base :*= base;
        e_tScores := e_tScores.kunion(left.kdiff(e_tScores).project(base)).sort();

	# aggregate term scores
        eScores := e_tScores.left_mul(eScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    var res;
    if (returnall) {
        res := eScores;
    } else {
        var unchanged := eScores.uselect(score_base);
        res := eScores.kdiff(unchanged);
    }
    
    t_total :+= time();
    if (timing) printf("# LMs timing: total: %d\n", t_total);
    return res;
}
@mil


@:containing_query_NLLR(nest,nid,TagSize)@
@:containing_query_NLLR(unnest,nid,TagSize)@
@:containing_query_NLLR(nest,pre,size1)@
@:containing_query_NLLR(unnest,pre,size1)@
@= containing_query_NLLR
PROC tj_containing_query_@1_@2_NLLR (bat[oid,any] left, bat[oid,dbl] query) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(query) = 0 ) return new(oid,dbl);
    
    var qSize := query.sum();
    var t_qCnt := {sum}(query);
    
    var e_pre := left.chk_order();
    var cSize := bat("tj_" + ftindex + "_Terms").count();
    var e_size := bat("tj_" + ftindex + "_@3");
    var eScores := new(oid,dbl);
    
    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var t_pre := _getTermPositions($h);
        var c_tCnt := count(t_pre); 
        # get element count of term
	var e_tCnt := _getTermDocCnt_@1_@2(e_pre, e_size, t_pre);
        # score elements by this term
        var e_tScores := _score_NLLR($t, qSize, c_tCnt, cSize, e_tCnt, e_size);
        e_tCnt := nil;
        
	# aggregate term scores
        eScores := eScores.union_add(e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
    var res;
    if (returnall) {
        res := union(eScores,left.kdiff(eScores).project(dbl(0)));
    } else {
        res := eScores;
    }
    
    t_total :+= time();
    if (timing) printf("# NLLR timing: total: %d\n", t_total);
    return res;
}
@mil


@:containing_query_OKAPI(nest,nid,TagSize)@
@:containing_query_OKAPI(unnest,nid,TagSize)@
@:containing_query_OKAPI(nest,pre,size1)@
@:containing_query_OKAPI(unnest,pre,size1)@
@= containing_query_OKAPI
PROC tj_containing_query_@1_@2_OKAPI (bat[oid,any] left, bat[oid,dbl] query) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(query) = 0 ) return new(oid,dbl);
    
    var t_qCnt := {sum}(query);
    
    var e_pre := left.chk_order();
    var cSize := bat("tj_" + ftindex + "_Terms").count();
    var e_size := bat("tj_" + ftindex + "_@3");
    var eScores := new(oid,dbl);
    var cNdoc := e_pre.count();
    var cAvgDL := e_size.semijoin(e_pre).[dbl]().avg();
    
    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var t_pre := _getTermPositions($h);
        # get element count of term
	var e_tCnt := _getTermDocCnt_@1_@2(e_pre, e_size, t_pre);
	# score elements by this term
        var e_tScores := _score_OKAPI($t, e_tCnt, e_size, cNdoc, cAvgDL);
        e_tCnt := nil;
        
	# aggregate term scores
        eScores := eScores.union_add(e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
    var res;
    if (returnall) {
        res := union(eScores,left.kdiff(eScores).project(dbl(0)));
    } else {
        res := eScores;
    }
    
    t_total :+= time();
    if (timing) printf("# OKAPI timing: total: %d\n", t_total);
    return res;
}
@mil

#####################################################################
# Containing_conceptquery
#####################################################################

PROC tj_ent2tid (bat[str,dbl] concept_score) : bat[oid,dbl] :=
{
    return concept_score.reverse().join(bat("tj_" + ftindex + "_conceptdict")).reverse();
}

# returns the pre-order positions of the concept c
# in the collection of the documents
PROC _getConceptPositions (oid tid) : bat[void,oid] := {
     var index := bat("tj_" + ftindex + "_ConceptIndex");
     var offset1 := int(index.fetch(int(tid)));
     var offset2 := int(index.fetch(int(tid) + 1));
     var res := bat("tj_" + ftindex + "_Concepts").slice(offset1, offset2 - 1);
     res := res.seqbase(0@0).chk_order();
     return res;
}

@mil

@:getConceptDocScr_nid(nest)@
@:getConceptDocScr_nid(unnest)@
@= getConceptDocScr_nid
PROC _getConceptDocScr_@1_nid(BAT[oid,oid] e_pre, BAT[void,int] e_size, BAT[void,oid] c_pre) : BAT[oid,int] := {
     
	# get doc - Concept relation
	var c_Scr := bat("tj_" + ftindex + "_ConceptScore");
        var e_c := treemergejoin_@1_nid(e_pre, e_size, c_pre);
	var eself_c := e_pre.join(c_pre.reverse());
	var e_cScr := {sum}(c_Scr, e_c.reverse(), e_c.kunique()).sort();
	var eself_cScr := {sum}(c_Scr, eself_c.reverse(), eself_c.kunique()).sort();
        return union_add(e_cScr, eself_cScr);
}
@mil
@:getConceptDocScr_pre(nest)@
@:getConceptDocScr_pre(unnest)@
@= getConceptDocScr_pre
PROC _getConceptDocScr_@1_pre(BAT[oid,any] e_pre, BAT[void,int] e_size, BAT[void,oid] c_pre) : BAT[oid,int] := {
     
	# get doc - Concept relation
	var c_Scr := bat("tj_" + ftindex + "_ConceptScore");
        var e_c := treemergejoin_@1_nid(e_pre.mirror(), e_size, c_pre);
	var eself_c := e_pre.mirror().join(c_pre.reverse());
	var e_cScr := {sum}(c_Scr, e_c.reverse(), e_c.kunique()).sort();
	var eself_cScr := {sum}(c_Scr, eself_c.reverse(), eself_c.kunique()).sort();
        return union_add(e_cScr, eself_cScr);
}
@mil

#                 __              
# LogSum(d|q) =   >_   qCnt(c) * log dScr(c) 
#              c in q             
#
# where qCnt(c) = count of concept c in query q
# where dScr(c) = detector score for concept c in doc d
#

PROC _score_LogSum(dbl q_cCnt, BAT[oid,dbl] e_cScr) : bat[oid,dbl] := {
    var e_cScores := [log](e_cScr);
    e_cScores := e_cScores.[*](q_cCnt);
    return e_cScores;
}

@:containing_conceptquery_LogSum(nest,nid,TagSize)@
@:containing_conceptquery_LogSum(unnest,nid,TagSize)@
@:containing_conceptquery_LogSum(nest,pre,size1)@
@:containing_conceptquery_LogSum(unnest,pre,size1)@
@= containing_conceptquery_LogSum
PROC tj_containing_conceptquery_@1_@2_LogSum (bat[oid,any] left, bat[oid,dbl] query) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(query) = 0 ) return new(oid,dbl);
    
    var c_qCnt := {sum}(query);

    var e_pre := left.chk_order();
    var e_size := bat("tj_" + ftindex + "_@3");
    var eScores := new(oid,dbl);
    
    # loop over query terms
    c_qCnt@batloop()
    {
        # get collection count of term
        var c_pre := _getConceptPositions($h);
        # get element count of term
	var e_cScr := _getConceptDocScr_@1_@2(e_pre, e_size, c_pre);
	# score elements by this term
        var e_cScores := _score_LogSum($t, e_cScr);
        e_cScr := nil;
        
	# aggregate term scores
        eScores := eScores.union_add(e_cScores);
	e_cScores := nil;
    }
    eScores.access(BAT_READ);
    eScores := [exp](eScores);
    
    var res;
    if (returnall) {
        res := union(eScores,left.kdiff(eScores).project(dbl(0)));
    } else {
        res := eScores;
    }
    
    t_total :+= time();
    if (timing) printf("# LogSum timing: total: %d\n", t_total);
    return res;
}
@mil


#####################################################################
# and/or combination
#####################################################################

PROC tj_and_nocomb(bat left, bat right) : bat :=
{
    return left.semijoin(right).sort();
}

PROC tj_and_comb(bat left, bat right) : bat :=
{
    if (andcomb = "sum") return [+](left,right).sort();
    if (andcomb = "prod") return [*](left,right).sort();
    if (andcomb = "max") return [max](left,right).sort();
    if (andcomb = "min") return [min](left,right).sort();
    if (andcomb = "prob") return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right))).sort();
}

PROC tj_or_nocomb(bat left, bat right) : bat :=
{
    return left.kunion(right).sort();
}

PROC tj_or_comb(bat left, bat right) : bat :=
{
    if (orcomb = "sum") return left.union_add(right).sort();
    if (orcomb = "prod") return left.union_mul(right).sort();
    if (orcomb = "max") {
        var intersect := [max](left,right);
        var onlyleft  := left.kdiff(right);
        var onlyright := right.kdiff(left);
	var outer := onlyleft.kunion(onlyright);
        return intersect.kunion(outer).sort();
    }
    if (orcomb = "prob") {
	var intersect := [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));
        var onlyleft  := left.kdiff(right);
        var onlyright := right.kdiff(left);
	var outer := onlyleft.kunion(onlyright);
        return intersect.kunion(outer).sort();
    }
}

################################################################################
# PRIOR
################################################################################

PROC tj_prior_ls(BAT[oid,dbl] region) : bat := 
{
    var cName := qenv.find(QENV_FTINAME);
    var tag_size := bat("tj_" + ftindex + "_TagSize");
    return [*](region, tag_size);
}
#ADDHELP("prior_ls", "vojkan", "March 16, 2005",
#"Adds element prior based on element length to the region score.",
#"TIJAH");

################################################################################
# OVERLAP REMOVAL
################################################################################

PROC tj_rm_overlap(BAT[oid,dbl] ctx) : bat := 
{
   if ( count( ctx ) = 0 ) {
       return ctx;
   } else {
       var size := bat("tj_" + ftindex + "_size1");
       var a_d := treemergejoin_nest_pre(ctx, size, ctx);
       var x_a := a_d.hmark(0@0);
       var x_d := a_d.tmark(0@0);
       var x_ascore := x_a.join(ctx);
       var x_dscore := x_d.join(ctx);

       # deselect all ancestors having a higher scored descendant
       var tmp := [<](x_ascore, x_dscore).uselect(true).mirror().join(x_a);
       var res1 := ctx.kdiff(tmp.reverse());
       # deselect all descendants having a higher scored ancestor
       # select descendants having a higher scored ancestor in res1
       tmp := x_a.kdiff(tmp).join(res1).mirror().join(x_d); 
       var res := res1.kdiff(tmp.reverse());

       return res;
   }
}
#ADDHELP("rm_overlap","henning", "Oktober, 2008",
#"Removes overlapping elements from result list.",
#"TIJAH");



#####################################################################
#
#   OLD VERSION START
#
#####################################################################

const virtRoot := 0@0;

##
# Compute ancestor-descendant relation. 
#
# Forwards to anc_desc_llscj: see below.
##

PROC tj_nid2pre( bat[oid,any] nid_score, bat[oid,str] qenv ) : bat[oid,any] :=
{
    var cName := qenv.find(QENV_FTINAME);
    var res := nid_score.reverse().leftfetchjoin(bat("tj_" + cName + "_Tags")).reverse();
    return res;
}

PROC anc_desc( bat[oid,any] anc, bat[oid,any] desc, bat[oid,str] qenv ) : bat[oid,oid] :=
{
    var cName := qenv.find(QENV_FTINAME);
    var a_pre;
    var a_size;
    if (isnil(anc.fetch(0))) {
       var offset1 := int(anc.reverse().fetch(0));
       var offset2 := int(anc.reverse().fetch(1));
       a_pre := bat("tj_" + cName + "_Tags").slice(offset1, offset2).tsort();
       a_size := bat("tj_" + cName + "_TagSize").slice(offset1, offset2);
    } else {
       a_pre := bat("tj_" + cName + "_Tags").semijoin(anc).tsort();
       a_size := bat("tj_" + cName + "_TagSize");
    }
    var d_pre;
    if (isnil(desc.fetch(0))) {
       var offset1 := int(desc.reverse().fetch(0));
       var offset2 := int(desc.reverse().fetch(1));
       d_pre := bat("tj_" + cName + "_Tags").slice(offset1, offset2).tsort();
    } else {
       d_pre := bat("tj_" + cName + "_Tags").semijoin(desc).tsort();
    }
  
    var nested := false;
    if (qenv.find(QENV_RECURSIVE_TAGS) = "1") {nested := true;}
    var a_d;
    if (nested) {
       a_d := treemergejoin_sort(a_pre, a_size, d_pre);
    } else {
       a_d := treemergejoin_sort_unnested(a_pre, a_size, d_pre);
    }
    return a_d;
}


##
# Converts a list of query terms to a list of term ids
#
# Stemming on the query terms is performed using the same stemmer
# that was used for the collection.
##
PROC _terms2void_tid( bat[void,str] Qterms, str bg_cName): bat[void,oid] :=
{
    var param    := bat("tj_"+ bg_cName +"_param");
    var stemmer  := param.find("stemmer");
    var firstterm:= oid(param.find("lastStopWord"));
    var stemmed  := [tj_normalizeTerm]( [toLower](Qterms), stemmer );
    var tids := bat(_tj_TermBat(bg_cName)).join( stemmed.reverse() ).sort().hmark(oid(0));
    #var stopwords := tids.uselect(0@0,firstterm,TRUE,FALSE);
    #tids := tids.kdiff(stopwords);
    tids := tids.select(firstterm,oid(nil),TRUE,FALSE);
    return tids;
}


##
# Return only the element nodes from region ctx
##
PROC nodes( bat[oid,any] ctx, BAT[oid,str] qenv ) : bat[oid,any] :=
{
    # The pfpre table only stores element nodes, so we can use it as a filter:
    var pfpre  := bat( "tj_" + qenv.find(QENV_FTINAME) + "_pfpre");
    var result := ctx.semijoin(pfpre);
    return result;
}


##
# Return only the terms from region ctx
##
PROC terms( bat[oid,any] ctx, BAT[oid,str] qenv ) : bat[oid,any] :=
{
    # A term is everything that is not an element node
    var nodes  := nodes( ctx, qenv );
    var result := ctx.kdiff( nodes );
    return result;
}


################################################################################
# SELECTION
################################################################################

##
# Select the root node of the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_root(bat[void,oid] par_startNodes, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( not( isnil( par_startNodes ) ) ) {
        # Start from a set of starting nodes if available. 
        # It is assumed that the startNodes are [any, pre]
        if ( count( par_startNodes ) > 0 ) {
            var root_reg := par_startNodes.reverse().sort().project( dbl(qenv.find(QENV_SCOREBASE)) );
            return root_reg;
        } else {
            var root_reg := new(oid,dbl,1);
            
            root_reg.insert( virtRoot, dbl(qenv.find(QENV_SCOREBASE)) );
            return root_reg;
        }
    } else {
        # Because TIJAH expects all documents in a collection to be contained by one 
        # "virtual root" element, this behaviour should be emulated by the light index. 
        # An element with preorder oid(0) will indicate that it is the collection root.
        var root_reg := new(oid,dbl,1);
        
        root_reg.insert( virtRoot, dbl(qenv.find(QENV_SCOREBASE)) );
        return root_reg;
    }
}

PROC select_root(BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var res := new(oid,dbl,1);
    res.insert(virtRoot, dbl(qenv.find(QENV_SCOREBASE)));
    return res;
}

PROC select_startnodes(bat[void,oid] startNodes, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var cName := qenv.find(QENV_FTINAME);
    var res := startNodes.join(bat("tj_" + cName + "_Tags").reverse()).reverse();
    res := res.project(dbl(qenv.find(QENV_SCOREBASE))).sort();
    return res;
}

##
# Select all element nodes in the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_node(BAT[oid,str] qenv) : bat[oid,dbl] := 
{
     var cName := qenv.find(QENV_FTINAME);
     var index := bat("tj_" + cName + "_TagIndex");
     var offset1 := index.fetch(1);
     var offset2 := oid(int(index.fetch(index.count() - 1)) - 1);
     var res := new(void,oid).seqbase(0@0);
     res.append(offset1);
     res.append(offset2);
     res := res.reverse().project(dbl(nil)); 

     # set the recursive tag flag on "true" because all tags are selected
     modify_qenv(qenv,QENV_RECURSIVE_TAGS,"1");

    return res;
}

##
# Select all element nodes in the collection with the given name
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC _getTagPositions(oid tid, str cName) : bat[void,oid] := {
     var index := bat("tj_" + cName + "_TagIndex");
     var offset1 := index.fetch(int(tid));
     var offset2 := oid(int(index.fetch(int(tid) + 1)) - 1);
     var res := new(void,oid).seqbase(0@0);
     res.append(offset1);
     res.append(offset2);
     return res;
}

PROC select_node(str name, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var tids := bat(_tj_TagBat(qenv.find(QENV_FTINAME))).select(name);
    if (tids.count() = 0) return new(oid,dbl);
    var tid := tids.reverse().fetch(0);

    var cName := qenv.find(QENV_FTINAME);
    # set the recursive tag flag on "true" because all tags are selected
    if ( bat(_tj_RTagBat(cName)).exist(tid) ) {
        modify_qenv(qenv,QENV_RECURSIVE_TAGS,"1");
    }
    # Henning changes
    var result := _getTagPositions(tid, cName); 
    result := result.reverse().project(dbl(nil)); 

    return result;
}

PROC select_node(str name, bit e_class, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( e_class ) {
        printf("error occurred in select node. not supported class def feature.\n");
	return new(oid,dbl);
    } else {
        return select_node(name,qenv);
    }
}

PROC split2frag(bat[oid,any] nodes, bat[void,oid] frags) : bat[oid,bat] :=
{
    var res := new(oid,bat);
    
    var lst_frag := frags.reverse().fetch(frags.count() - 1);
    var i := 0;
    var j := nodes.count();
    while( i < j)
    {
    	var frag := find_lower(frags.reverse(), nodes.reverse().fetch(i));
        if (frag < lst_frag)
	{
	    var frag_limit := oid(int(frags.fetch(int(frag))) -1); #only correct if frag numbering starts at 1
	    var nodes_limit := int(find_lower(nodes.mark(0@0), frag_limit));
	    res.insert(frag, nodes.slice(i, nodes_limit));
            i := nodes_limit + 1;
	}
	if (frag = lst_frag)
	{
	    res.insert(frag, nodes.slice(i, j - 1));
            i := j;
	}
    }

    return res;
}

##
# Select all terms with the given value
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_term(str name, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var stemmer := bat("tj_"+ qenv.find(QENV_FTINAME) +"_param").find("stemmer");
    var term    := tj_normalizeTerm( toLower(name), stemmer );
    
    # Select the term positions from the global term dictionary.
    var tids := bat(tj_TermBat(qenv.find(QENV_FTINAME))).uselect(term).mark(0@0).sort().reverse();
    
    var result := indexfetchjoin( tids,
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_TermIndex"),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_Terms") );
    result := result.reverse().sort().project(dbl(qenv.find(QENV_SCOREBASE))); 
    

    return result;
}

##
# Select all terms with the given value, possibly performing stemming on the argument.
#
# This variant of the select_term function is present for compatibility reasons:
# at the moment, stemming is always performed using the same stemmer that was
# used to index the collection.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_term(str name, int stemming, BAT[oid,str] qenv) : bat[oid,dbl] := 
{
    return select_term( name,qenv );
}


##
# Select a number of terms by their term-id.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##
PROC select_phrase(bat[void,oid] terms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    # Select the term positions from the global term dictionary. 
   
    var tid := terms.fetch(0);
    var tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_TermIndex"),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_Terms") );
    var res := tmp.reverse();
    var j := terms.count();
    var i := 1; 
    while (i < j)
    {
        tid := terms.fetch(i);
        tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_TermIndex"),
    				  bat("tj_" + qenv.find(QENV_FTINAME) + "_Terms") );
        res := res.semijoin(tmp.[int]().[-](i).[oid]().reverse());   
	i :+= 1;
    }	
    
    res := res.sort().project(dbl(qenv.find(QENV_SCOREBASE))); 
    
    return res;
}


################################################################################
# CONTAINMENT
################################################################################


#####################################
# left CONTAINED_BY right:
#
#   +--------------------+
#   |       right        |
#   | +---------------+  |
#   | |      left     |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it is contained a region in right
#
#####################################

PROC contained_by(bat[oid,dbl] left, bat[oid,dbl] right, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(right) = 0 ) return new(oid,dbl);
    
    # Check for the virtual root
    if ( count(left) = 1 )
       if ( left.reverse().fetch(0) = virtRoot ) 
          return new(oid,dbl);
    if ( count( right ) = 1 )
       if ( right.reverse().fetch(0) = virtRoot ) 
          return left;
    
    var anc_desc := anc_desc( right, left, qenv );

    # Attach the scores to the resulting nodes again:
    var result;
    if (isnil(left.fetch(0))) {
       result := anc_desc.reverse().kunique().project(dbl(qenv.find(QENV_SCOREBASE)));
    } else {
       result := left.semijoin(anc_desc.reverse());
    }
    
    return result.sort();
}

##
# Returns all regions in the collection that are contained by the argument. 
# Equivalent with a descendant step in XPath.
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scorebase environment variable
##

PROC contained_by(bat[oid,dbl] region, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var all_nodes := select_node(qenv);
    var result := contained_by(all_nodes, region, qenv);
    
    return result;
}


#####################################
# left CONTAINING right:
#
#   +--------------------+
#   |       left         |
#   | +---------------+  |
#   | |      right    |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it contains a region in right
#
#####################################

PROC containing(bat[oid,dbl] left, bat[oid,dbl] right, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    # Check for the virtual root
    if ( count(left) = 1 )
       if ( left.reverse().fetch(0) = virtRoot ) 
          return right;
    if ( count( right ) = 1 )
       if ( right.reverse().fetch(0) = virtRoot ) 
          return new(oid,dbl);
    
    var anc_desc := anc_desc( left, right, qenv );
    
    # Attach the scores to the resulting nodes again:
    var result;
    if (isnil(left.fetch(0))) {
       result := anc_desc.project(dbl(qenv.find(QENV_SCOREBASE)));
    } else {
       result := left.semijoin(anc_desc);
    }
    
    return result.sort();
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

# returns the pre-order positions of the term t 
# in the collection of the documents
PROC _getTermPositions(oid tid, BAT[oid,str] qenv) : bat[void,oid] := {
     var cName := qenv.find(QENV_FTINAME);
     var index := bat("tj_" + cName + "_TermIndex");
     var offset1 := int(index.fetch(int(tid)));
     var offset2 := int(index.fetch(int(tid) + 1));
     var res := bat("tj_" + cName + "_Terms").slice(offset1, offset2 - 1);
     res := res.seqbase(0@0).chk_order();
     return res;
}

# returns the collection count cCnt(t) of term t
# in the background collection
# (the background collection can be different from collection
# the documents are coming from) 
PROC _getTermColCnt(oid tid, BAT[oid,str] qenv) : int := {
     var bg_cName := qenv.find(QENV_FTIBGNAME);
     var index := bat("tj_" + bg_cName + "_TermIndex");
     var offset1 := int(index.fetch(int(tid)));
     var offset2 := int(index.fetch(int(tid) + 1));
     return (offset2 - offset1);
}

# returns the collection count cCnt(t) of term t
# in the background collection
# (the background collection can be different from collection
# the documents are coming from) 
PROC _getTermDocCnt(oid tid, BAT[oid,oid] e_pre, BAT[void,int] e_size, BAT[oid,str] qenv) : BAT[oid,int] := {
     
        # get term positions in the entire collection
        var t_pre := _getTermPositions(tid, qenv);
	
	# get doc - term relation
        var e_tPre;
        if (nested) {
           e_tPre := treemergejoin_sort(e_pre, e_size, t_pre);
        } else {
           e_tPre := treemergejoin_sort_unnested(e_pre, e_size, t_pre);
        }
	t_pre := nil;
        return e_tPre.reverse().histogram().sort();
}


#             ___          qCnt(t) 
# LM(d|q) =   | |    dLH(t) 
#            t in q           
#
# where qCnt(t) = count of term t in query q
# where dLH(t) = likelihood of term t in doc d
#
# NOTE by Djoerd: The current implementation of LM might retrieve
# documents if one or more terms have zero frequency in background-col
# which should not happen

PROC _score_LM(int q_tCnt, int qSize, int c_tCnt, int cSize, BAT[oid,int] e_tCnt, BAT[void,int] e_size, dbl cLambda) : bat[oid,dbl] := {
    var e_tScores := e_tCnt.[dbl]().access(BAT_WRITE);
    e_tScores.left_div(e_size);
    var tmp := e_tScores;
    while (q_tCnt > 1) {
        e_tScores := e_tScores.[*](tmp);
	q_tCnt :-= 1;
    }
    return e_tScores;
}


#              ___                                         qCnt(t)      
# LMs(d|q) =   | |    ( (1-lambda) dLH(t) + lambda cLH(t) ) 
#             t in q           
#
# where qCnt(t) = count of term t in query q
# where dLH(t) = likelihood of term t in doc d
# where cLH(t) = likelihood of term t in (background) collection c
#

PROC _score_LMs(int q_tCnt, int qSize, int c_tCnt, int cSize, BAT[oid,int] e_tCnt, BAT[void,int] e_size, dbl cLambda) : bat[oid,dbl] := {
    var tmp1 := cLambda * c_tCnt / dbl(cSize);
    var tmp2 := dbl(1) - cLambda;
    var e_tScores := e_tCnt.[dbl]().access(BAT_WRITE);
    e_tScores.left_div(e_size);
    e_tScores := e_tScores.[*](tmp2);
    e_tScores := e_tScores.[+](tmp1);
    tmp1 := e_tScores;
    while (q_tCnt > 1) {
        e_tScores := e_tScores.[*](tmp1);
	q_tCnt :-= 1;
    }
    return e_tScores;
}

#               __     qCnt(t)       /  (1 - lambda) * dLH(t)       \  
# NLLR(d|q) =   >_     ------- * log |  ----------------------  + 1 |  
#              t in q   qSize        \      lambda * cLH(t)         /  
#
# where qCnt(t) = count of term t in query q
# where qSize = number of terms in query q
# where dLH(t) = likelihood of term t in doc d
# where cLH(t) = likelihood of term t in (background) collection c
#

PROC _score_NLLR(int q_tCnt, int qSize, int c_tCnt, int cSize, BAT[oid,int] e_tCnt, BAT[void,int] e_size, dbl cLambda) : bat[oid,dbl] := {
    var collFac := ((dbl(1) - cLambda) / cLambda) * cSize / dbl(c_tCnt);
    var q_tLH := dbl(q_tCnt) / dbl(qSize);
    var e_tScores := e_tCnt.[dbl]().access(BAT_WRITE);
    e_tScores.left_div(e_size);
    e_tScores := e_tScores.[*](collFac);
    e_tScores := e_tScores.[+](dbl(1));
    e_tScores := [log](e_tScores);
    e_tScores := e_tScores.[*](q_tLH);
    return e_tScores;
}

#             __                /  cNdoc  \            (cK1 + 1) tf(t)
# OKAPI(q) =  >_  qCnt(t) * log | ------- | * -------------------------------------
#            t in q             \  DF(t)  /   cK1*((1-cB) + cB*(DL / cAvgDL)) + tf(t)
#
# where cNdoc    = number of elements that is scored
# where cAvgDL   = average element length
# where DL       = element length
# where cIDF(t)  = idf instead of the Robertson/Sparck-Jones weight (variation on idf)
# where tf(t)    = term frequency (number of occurences of term t in element)
# where cK1      = tuning parameter k1
# where cB       = tuning parameter b
#

PROC _score_OKAPI(int q_tCnt, BAT[oid,int] e_tCnt, BAT[void,int] e_size, int cNdoc, dbl cAvgDL, dbl cK1, dbl cB) : bat[oid,dbl] := {
    
    # cIDF contains Robertson/Sparck-Jones relevance weight
    var cIDF := e_tCnt.count(); # df
    cIDF  := log((cNdoc + 0.5) / (cIDF + 0.5));

    # cK contains length normalization 
    var cK := e_size.semijoin(e_tCnt); # document lengths
    cK := [/](cK, cAvgDL / cB);
    cK := [+](cK, 1 - cB);
    cK := [*](cK, cK1);
    cK := [+](cK, e_tCnt);
    var tmp := [*](e_tCnt, cK1 + 1);
    tmp := [/](tmp, cK);
    
    var e_tScores := [*](tmp, cIDF * q_tCnt); 
    return e_tScores;
}

@= init_scoring
    var cName := qenv.find(QENV_FTINAME);
    var bg_cName := qenv.find(QENV_FTIBGNAME);
    
    # get term ids and drop all terms with zero frq in background-col and calculate query LM
    var terms := _terms2void_tid( Qterms, bg_cName );
    var qSize := terms.count();
    var t_qCnt := terms.histogram();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( qSize = 0 ) { if (returnAllElements) return left; else return new(oid,dbl); }
    
    # init further variables
    var nested := false;
    if (qenv.find(QENV_RECURSIVE_TAGS) = "1") {nested := true;}
    var cSize := bat("tj_" + bg_cName + "_Terms").count();
    var cLambda := dbl(qenv.find(QENV_C_LAMBDA));
    
    var e_pre;
    var e_size;
    if (isnil(left.fetch(0))) {
       var offset1 := int(left.reverse().fetch(0));
       var offset2 := int(left.reverse().fetch(1));
       e_pre := bat("tj_" + cName + "_Tags").slice(offset1, offset2).tsort();
       e_size := bat("tj_" + cName + "_TagSize").slice(offset1, offset2);
    } else {
       e_pre := bat("tj_" + cName + "_Tags").semijoin(left).tsort();
       e_size := bat("tj_" + cName + "_TagSize");
    }
@

@= end_scoring_addmodel
    var res;
    # score combination with prior scores
    if (isnil(left.fetch(0))) {
        if (returnAllElements) {
            left := e_pre.project(dbl(qenv.find(QENV_SCOREBASE)));
	    res := left_add(left,eScores);
        } else {
            res := eScores;
        }
    } else {
        if (returnAllElements) {
            res := left_add(left,eScores);
        } else {
            res := left_add(eScores,left);
        }
    }
@

@= end_scoring_mulmodel
    var res;
    # score combination with prior scores
    if (returnAllElements) {
        res := eScores;
    } else {
        var unchanged := eScores.uselect(score_base);
        res := eScores.kdiff(unchanged);
    }
    if (not(isnil(left.fetch(0)))) {
        res := [*](left,res);
    }
@mil

PROC p_containing_q_NLLR(bat[oid,dbl] left, bat[void,str] Qterms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();
  
@:init_scoring@

    var eScores := new(oid,dbl);
    
    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var c_tCnt := _getTermColCnt($h, qenv); 
        # get element count of term
	var e_tCnt := _getTermDocCnt($h, e_pre, e_size, qenv);
	# score elements by this term
        var e_tScores := _score_NLLR($t, qSize, c_tCnt, cSize, e_tCnt, e_size, cLambda);
        e_tCnt := nil;
        
	# aggregate term scores
        eScores := eScores.union_add(e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
@:end_scoring_addmodel@

    t_total :+= time();
    if (timing) printf("# NLLR timing: total: %d\n", t_total);
    return res;
}

PROC p_containing_q_LMs(bat[oid,dbl] left, bat[void,str] Qterms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();
    
@:init_scoring@

    var eScores := e_pre.project(dbl(1));
    var score_base := dbl(1);

    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var c_tCnt := _getTermColCnt($h, qenv); 
        # get element count of term
	var e_tCnt := _getTermDocCnt($h, e_pre, e_size, qenv);
	# score elements by this term
        var e_tScores := _score_LMs($t, qSize, c_tCnt, cSize, e_tCnt, e_size, cLambda);
        e_tCnt := nil;
        var base := cLambda * c_tCnt / dbl(cSize);
        score_base :*= base;
        e_tScores := e_tScores.union(eScores.kdiff(e_tScores).project(base));

	# aggregate term scores
        eScores := eScores.[*](e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
@:end_scoring_mulmodel@

    t_total :+= time();
    if (timing) printf("# LMs timing: total: %d\n", t_total);
    return res;
}

PROC p_containing_q_LM(bat[oid,dbl] left, bat[void,str] Qterms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();
    
@:init_scoring@

    var eScores := e_pre.project(dbl(1));
    var score_base := dbl(1);

    # loop over query terms
    t_qCnt@batloop()
    {
        # get collection count of term
        var c_tCnt := _getTermColCnt($h, qenv); 
        # get element count of term
	var e_tCnt := _getTermDocCnt($h, e_pre, e_size, qenv);
	# score elements by this term
        var e_tScores := _score_LM($t, qSize, c_tCnt, cSize, e_tCnt, e_size, cLambda);
        e_tCnt := nil;
        var base := dbl(0);
        score_base :*= base;
        e_tScores := e_tScores.union(eScores.kdiff(e_tScores).project(base));

	# aggregate term scores
        eScores := eScores.[*](e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
@:end_scoring_mulmodel@

    t_total :+= time();
    if (timing) printf("# LM timing: total: %d\n", t_total);
    return res;
}

PROC p_containing_q_OKAPI(bat[oid,dbl] left, bat[void,str] Qterms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();

@:init_scoring@

    var cNdoc := e_pre.count();
    var cAvgDL := e_size.semijoin(e_pre).[dbl]().avg();
    var cK1 := dbl(qenv.find(QENV_OKAPI_K1));
    var cB := dbl(qenv.find(QENV_OKAPI_B));
    var eScores := new(oid,dbl);
    
    # loop over query terms
    t_qCnt@batloop()
    {
        # get element count of term
	var e_tCnt := _getTermDocCnt($h, e_pre, e_size, qenv);
	# score elements by this term
        var e_tScores := _score_OKAPI($t, e_tCnt, e_size, cNdoc, cAvgDL, cK1, cB);
        e_tCnt := nil;
        
	# aggregate term scores
        eScores := eScores.union_add(e_tScores);
	e_tScores := nil;
    }
    eScores.access(BAT_READ);
    
@:end_scoring_addmodel@

    t_total :+= time();
    if (timing) printf("# OKAPI timing: total: %d\n", t_total);
    return res;
}


# Pseudo Relevance Feedback algorithm Implemented by 
# Stefan Teijgeler and Jan-Willem Beusink (added by Djoerd.)
#
PROC p_containing_q_PRF(bat[oid,dbl] left, bat[void,str] Qterms, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var t_total := 0;
    t_total :-= time();


    var qResults := left.p_containing_q_NLLR(Qterms, qenv);

    qResults := tj_nid2pre(qResults, qenv);
    qResults := qResults.tsort_rev();

    #Initialize variables
    var size, offset1, offset2, words, temp, score, tmp1, tmp2, test1, test2;
    var test_terms := new(int,oid);
    var new_terms := new(oid,dbl);
    var prfLambda := 0.0;
    var stopWoordLambda := 0.65;
    var dSize := dbl(0);                                                        # Sum of relevant document size
    var cSize := bat("tj_" + qenv.find(QENV_FTIBGNAME) + "_Terms").count();     # Total collection size
    var qSize := Qterms.count();                                                # Query size

    # Get new term candidates
    qResults.slice(0,9)@batloop()
    {
            size := bat("tj_" + qenv.find(QENV_FTINAME) +"_size1").find($h);
            dSize :+= size;
            offset1 := int($h);
            offset2 := offset1+size-1;
            words := bat("tj_" + qenv.find(QENV_FTINAME) +"_size1").slice(offset1, offset2);
            words := words.select(0,0);
            temp := words.reverse().join(bat("tj_" + qenv.find(QENV_FTINAME) +"_tid1"));
            test_terms.insert(temp);
    }

    # Calculate the score to the new terms, and select the top 10
    test_terms.histogram()@batloop()
    {

            # Count of term in total collection
            var c_tCnt := _getTermColCnt($h, qenv);

            #test1 := bat("tj_" + qenv.find(QENV_FTINAME) +"_termdict").find($h);
            test2 := (c_tCnt / dbl(cSize)) /  ($t / dSize);

            if ( test2 < dbl(stopWoordLambda) ) {

                    tmp1 := prfLambda * c_tCnt / dbl(cSize);
                    tmp2 := dbl(1) - prfLambda;

                    # Calculate score: ((1-prfLambda) * likeliness of t in d) + (prfLambda * likeliness of t in c)
                    score := $t / dSize;
                    score := score * tmp2;
                    score := score + tmp1;
            } else {
                    score := dbl(0);
            }

            new_terms.insert($h, score);
    }

    new_terms := new_terms.tsort_rev();
    #bat(new_terms).reverse().join(bat("tj_" + qenv.find(QENV_FTINAME) +"_termdict")).reverse().print();

    #Qterms := new(void,str).seqbase(oid(0));

    new_terms.slice(0,19)@batloop()
    {
            Qterms.append(find(bat("tj_" + qenv.find(QENV_FTINAME) +"_termdict"), $h));
    }

    qResults := left.p_containing_q_NLLR(Qterms, qenv);

    t_total :+= time();
    if (timing) printf("# PRF timing: total: %d\n", t_total);
    return qResults;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

# down propagation 
@:p_contained_by(max)@
@:p_contained_by(sum)@

@= p_contained_by
PROC p_contained_by_@1(bat[oid,dbl] region, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var candidates := select_node(qenv);
    return p_contained_by_@1(candidates, region, qenv);    
}

PROC p_contained_by_@1(bat[oid,dbl] left, bat[oid,dbl] right, BAT[oid,str] qenv) : bat[oid,dbl] := 
{
    var t := 0 - time();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(right) = 0 ) return new(oid,dbl);

    var a_d := anc_desc(right, left, qenv);
    var tmp := a_d.reverse().kunique();

    if (isnil(right.fetch(0))) { printf(" error in p_contained_by_@1 \n");}
    # if "right" is unnested, aggregation is not necessary"
    var reg_score;
    if (qenv.find(QENV_RECURSIVE_TAGS) = "0") {
    	reg_score := a_d.reverse().join(right);
    } else {
        reg_score := {@1}(right, a_d, tmp);
    }
    
    reg_score := reg_score.sort();
   
    if (not(isnil(left.fetch(0)))) {
        if (int(qenv.find(QENV_SCOREBASE)) = 0)
            reg_score := [+](left, reg_score);
        if (int(qenv.find(QENV_SCOREBASE)) = 1)
            reg_score := [*](left, reg_score);
    }

    t :+= time();
    if (timing) printf("# contained_by_@1 timing: %d\n", t);
    return reg_score.sort();
}
@mil

# up propagation 
@:p_containing(max)@
@:p_containing(sum)@

@= p_containing
PROC p_containing_@1(bat[oid,dbl] left, bat[oid,dbl] right, BAT[oid,str] qenv) : bat[oid,dbl] :=
{
    var t := 0 - time();
    
    if ( count(left) = 0 ) return new(oid,dbl);
    if ( count(right) = 0 ) return new(oid,dbl);

    var a_d := anc_desc( left, right, qenv );
   
    if (isnil(right.fetch(0))) { printf(" error in p_containing_@1 \n");}
    var tmp := a_d.kunique();
    var reg_score := {@1}(right, a_d.reverse(), tmp); 
    
    reg_score := reg_score.sort();

    if (not(isnil(left.fetch(0)))) {
        if (int(qenv.find(QENV_SCOREBASE)) = 0)
            reg_score := [+](left, reg_score);
        if (int(qenv.find(QENV_SCOREBASE)) = 1)
            reg_score := [*](left, reg_score);
    }

    t :+= time();
    if (timing) printf("# containing_@1 timing: %d\n", t);
    return reg_score.sort();
}
@mil

################################################################################
# SET OPERATORS
################################################################################

### UNION
PROC set_union(bat left, bat right, BAT[oid,str] qenv) : bat :=
{
    if ( count(left) = 0 ) return right;
    if ( count(right) = 0 ) return left;

    var cName := qenv.find(QENV_FTINAME);
    
    if (isnil(left.fetch(0))) {
       var offset1 := int(left.reverse().fetch(0));
       var offset2 := int(left.reverse().fetch(1));
       left := bat("tj_" + cName + "_Tags").slice(offset1, offset2).project( dbl(qenv.find(QENV_SCOREBASE)));
    }
    if (isnil(right.fetch(0))) {
       var offset1 := int(right.reverse().fetch(0));
       var offset2 := int(right.reverse().fetch(1));
       right := bat("tj_" + cName + "_Tags").slice(offset1, offset2).project( dbl(qenv.find(QENV_SCOREBASE)));
    }

    # set recurse tag flag to TRUE since the union might result in a nested set
    modify_qenv(qenv,QENV_RECURSIVE_TAGS,"1");

    return left.kunion(right).sort();
}

### INTERSECTION
PROC set_intersect(bat left, bat right, BAT[oid,str] qenv) : bat := 
{
    if ( count(left) = 0 ) return right;
    if ( count(right) = 0 ) return left;

    var cName := qenv.find(QENV_FTINAME);
    
    if (isnil(left.fetch(0))) {
       var offset1 := int(left.reverse().fetch(0));
       var offset2 := int(left.reverse().fetch(1));
       left := bat("tj_" + cName + "_Tags").slice(offset1, offset2).project( dbl(qenv.find(QENV_SCOREBASE)));
    }
    if (isnil(right.fetch(0))) {
       var offset1 := int(right.reverse().fetch(0));
       var offset2 := int(right.reverse().fetch(1));
       right := bat("tj_" + cName + "_Tags").slice(offset1, offset2).project( dbl(qenv.find(QENV_SCOREBASE)));
    }

    return left.kintersect(right).sort();
}


################################################################################
# SCALING
################################################################################

PROC scale(bat region, flt importance) : bat := 
{

	var res_reg := new(oid,dbl,ENTITY_NUM);
	res_reg := [*](dbl(importance),region);
	return res_reg;

}


################################################################################
# PROBABILISTIC SET OPERATORS
################################################################################

# Compute symmetric difference between two sets: all element that are not in the intersection
PROC ksymmdiff(bat left, bat right) : bat := 
{
    var onlyleft  := left.kdiff(right);
    var onlyright := right.kdiff(left);
    return onlyleft.kunion(onlyright);
}

PROC or_sum(bat left, bat right) : bat :=
{
    return left.union_add(right);
}

PROC or_max(bat left, bat right) : bat :=
{

    var inters := [max](left,right);

    return inters.kunion(ksymmdiff(left,right)).sort();

}

PROC or_prob(bat left, bat right) : bat :=
{

	var inters := [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

    return inters.kunion(ksymmdiff(left,right)).sort();

}

PROC or_exp(bat left, bat right, int A) : bat := 
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC or_min(bat left, bat right) : bat :=
{

    var inters := [min](left,right);

    return inters.kunion(ksymmdiff(left,right)).sort();

}

PROC or_prod(bat left, bat right) : bat :=
{
    return left.union_mul(right);
}

PROC and_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC and_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC and_exp(bat left, bat right, int A) : bat :=
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC and_max(bat left, bat right) : bat :=
{
	return [max](left,right);
}

PROC and_prob(bat left, bat right) : bat :=
{
	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));
}


################################################################################
# PRIOR
################################################################################

PROC prior_ls(BAT[oid,dbl] region, BAT[oid,str] qenv) : bat := 
{
    var cName := qenv.find(QENV_FTINAME);
    var tag_size := bat("tj_" + cName + "_TagSize");
    return [*](region, tag_size);
}
#ADDHELP("prior_ls", "vojkan", "March 16, 2005",
#"Adds element prior based on element length to the region score.",
#"TIJAH");

################################################################################
# OVERLAP REMOVAL
################################################################################

PROC rm_overlap(BAT ctx, BAT[oid,str] qenv) : bat := 
{
 if ( count( ctx ) = 0 ) {
   return ctx;
 }
 else {
   if (qenv.find(QENV_RECURSIVE_TAGS) = "0") {return ctx;}

   var a_d := anc_desc(ctx, ctx, qenv);
   var x_a := a_d.hmark(0@0);
   var x_d := a_d.tmark(0@0);
   var x_ascore := x_a.join(ctx);
   var x_dscore := x_d.join(ctx);

   # deselect all ancestors having a higher scored descendant
   var tmp := [<](x_ascore, x_dscore).uselect(true).mirror().join(x_a);
   var res1 := ctx.kdiff(tmp.reverse());

   # deselect all descendants having a higher scored ancestor
   tmp := x_a.kdiff(tmp).semijoin(res1).mirror().join(x_d); # select descendants having a higher scored ancestor in res1
   var res := res1.kdiff(tmp.reverse());

   return res;
 }
}
#ADDHELP("rm_overlap","henning", "Oktober, 2008",
#"Removes overlapping elements from result list.",
#"TIJAH");


################################################################################
# ORDER
################################################################################

PROC order_regions(bat region) : bat :=
{

	region := region.reverse().sort_rev().reverse();

	return region;

}
#ADDHELP("order_regions", "vojkan", "March 29, 2005",
#"Order regions in descending order based on their score values.",
#"TIJAH");

##########################################
# Collection Management Functions
#
##########################################

PROC _tj_chk_modified_fragments(str ftiName, BAT[str,bat] collBat) : BAT[void,str] :=
{
	var offset := oid(int(_tj_get_parameter(collBat, "_last_finalizedPre")) + 1);
        var fragments := collBat.find("_fragments");
	var frag_offset := int(find_lower(fragments.reverse(), offset));
	var frag_last := fragments.count();
	
	var mod_frags := new(void, str).seqbase(0@0);
	while (frag_offset < frag_last)
	{
		mod_frags.append("tj_" + ftiName + "_tid" + str(frag_offset));
		mod_frags.append("tj_" + ftiName + "_size" + str(frag_offset));
		frag_offset :+= 1;
	}
	
	return mod_frags;
}

PROC _buildIRindex(str ftiName, BAT[str,bat] collBat) : void :=
{
	var offset := oid(lng(_tj_get_parameter(collBat, "_last_finalizedPre")) + 1);
        var fragments := collBat.find("_fragments");
	var frag_offset := int(find_lower(fragments.reverse(), offset));
	var frag_last := fragments.count();
	
	var pre_tid := bat("tj_" + ftiName + "_tid" + str(frag_offset));
	var pre_size := bat("tj_" + ftiName + "_size" + str(frag_offset));
        var tids := pre_tid.slice(lng(offset) - lng(pre_tid.seqbase()), lng(pre_tid.count() - 1));
	var sizes := pre_size.slice(lng(offset) - lng(pre_size.seqbase()), lng(pre_size.count() - 1));
	tids.access(BAT_WRITE);
	sizes.access(BAT_WRITE);
	frag_offset :+= 1;
	while (frag_offset <= frag_last)
	{
	    	tids.append(bat("tj_" + ftiName + "_tid" + str(frag_offset)));
	    	sizes.append(bat("tj_" + ftiName + "_size" + str(frag_offset)));
		frag_offset :+= 1;
	}
	tids.access(BAT_READ);
	sizes.access(BAT_READ);
       
	# incremental index merge
	if (isnil(CATCH(bat("tj_" + ftiName + "_TermIndex").count()))) 
        {
    		var replaceBats := collBat.find("replaceBats");
		var tmp := tids.kdiff(collBat.find("_pfpre"));
                tmp := tmp.reverse().ssort();
		var i := mergeindex(tmp, collBat.find("_TermIndex"),
                                         collBat.find("_Terms"),
                                         collBat.find("_globalTerms").count() + 1);       
                collBat.replace("_TermIndex", i.fetch(0));
                collBat.replace("_Terms", i.fetch(1));
	        i := nil;
		tmp := nil;
		replaceBats.insert("_TermIndex", "tj_" + ftiName + "_TermIndex");
                replaceBats.insert("_Terms", "tj_" + ftiName + "_Terms");
	        collBat.find("_TermIndex").access(BAT_READ).mmap(1);
	        collBat.find("_Terms").access(BAT_READ).mmap(1);
		collBat.find("submitBats").append("tj_" + ftiName + "_TermIndex");
		collBat.find("submitBats").append("tj_" + ftiName + "_Terms");
	        
	        tmp := tids.semijoin(bat("tj_" + ftiName + "_pfpre"));
                tmp := tmp.reverse().ssort();
		var tmpsize := tmp.leftfetchjoin(sizes);
                i := mergeindex2(tmp, tmpsize,
		                 collBat.find("_TagIndex"),
                                 collBat.find("_Tags"),
                                 collBat.find("_TagSize"),
                                 collBat.find("_globalTags").count() + 1);
                collBat.replace("_TagIndex", i.fetch(0));
                collBat.replace("_Tags", i.fetch(1));
                collBat.replace("_TagSize", i.fetch(2));
	        i := nil;
		tmp := nil;
		tmpsize := nil;
		replaceBats.insert("_TagIndex", "tj_" + ftiName + "_TagIndex");
                replaceBats.insert("_Tags", "tj_" + ftiName + "_Tags");
                replaceBats.insert("_TagSize", "tj_" + ftiName + "_TagSize");
	        collBat.find("_TagIndex").access(BAT_READ).mmap(1);
	        collBat.find("_Tags").access(BAT_READ).mmap(1);
	        collBat.find("_TagSize").access(BAT_READ).mmap(1);
		collBat.find("submitBats").append("tj_" + ftiName + "_TagIndex");
		collBat.find("submitBats").append("tj_" + ftiName + "_Tags");
		collBat.find("submitBats").append("tj_" + ftiName + "_TagSize");
        }
        else # create new index
        {       
	        var tmp := tids.kdiff(bat("tj_" + ftiName + "_pfpre"));
                tmp := tmp.reverse().ssort();
	        var termindex := tmp.hmark(0@0).offsetindex(bat(_tj_TermBat(ftiName)).count() + 1);
	        var terms := tmp.tmark(0@0);
	        # create _TermIndex and _Terms here
	        termindex.persists(true).bbpname("tj_" + ftiName + "_TermIndex");
	        terms.persists(true).bbpname("tj_" + ftiName + "_Terms");
	        tmp := nil;
	        termindex.access(BAT_READ);
	        termindex.mmap(1);
	        terms.access(BAT_READ);
	        terms.mmap(1);
	        termindex := nil;
		terms := nil;
		collBat.find("submitBats").append("tj_" + ftiName + "_TermIndex");
		collBat.find("submitBats").append("tj_" + ftiName + "_Terms");
	        
	        tmp := tids.semijoin(bat("tj_" + ftiName + "_pfpre"));
                tmp := tmp.reverse().ssort();
	        var tagindex := tmp.hmark(1@0).offsetindex(bat(_tj_TagBat(ftiName)).count() + 1);
	        var tags := tmp.tmark(1@0);
	        # create _Tags and _Tagindex here
	        tagindex.persists(true).bbpname("tj_" + ftiName + "_TagIndex");
	        tags.persists(true).bbpname("tj_" + ftiName + "_Tags");
	        tmp := nil;
	        tagindex.access(BAT_READ);
	        tagindex.mmap(1);
	        tags.access(BAT_READ);
	        tags.mmap(1);
	        tagindex := nil;
		var tagsize := tags.leftfetchjoin(sizes);
		tags := nil;
	        tagsize.persists(true).bbpname("tj_" + ftiName + "_TagSize");
	        tagsize.access(BAT_READ);
	        tagsize.mmap(1);
		tagsize := nil;
		collBat.find("submitBats").append("tj_" + ftiName + "_TagIndex");
		collBat.find("submitBats").append("tj_" + ftiName + "_Tags");
		collBat.find("submitBats").append("tj_" + ftiName + "_TagSize");
        }

	var c_cid := bat("tj_" + ftiName + "_concept_tid");
	var c_pre := bat("tj_" + ftiName + "_concept_elem");
	var c_scr := bat("tj_" + ftiName + "_concept_score");
        var tmp := c_pre.tsort().mirror().leftfetchjoin(c_cid).reverse().ssort();
        c_cid := tmp.leftfetchjoin(c_cid).tmark(0@0).chk_order();
        var concepts := tmp.leftfetchjoin(c_pre).tmark(0@0);
        var conceptscore := tmp.leftfetchjoin(c_scr).tmark(0@0);
        tmp := nil;
	var conceptindex := offsetindex(c_cid, bat("tj_" + ftiName + "_conceptdict").count() + 1);
	# create _ConceptIndex and _Concepts here
	conceptindex.persists(true).bbpname("tj_" + ftiName + "_ConceptIndex");
	concepts.persists(true).bbpname("tj_" + ftiName + "_Concepts");
	conceptscore.persists(true).bbpname("tj_" + ftiName + "_ConceptScore");
	conceptindex.access(BAT_READ);
	conceptindex.mmap(1);
	concepts.access(BAT_READ);
	concepts.mmap(1);
	conceptscore.access(BAT_READ);
	conceptscore.mmap(1);
	conceptindex := nil;
        concepts := nil;
	conceptscore := nil;
	collBat.find("submitBats").append("tj_" + ftiName + "_ConceptIndex");
	collBat.find("submitBats").append("tj_" + ftiName + "_Concepts");
	collBat.find("submitBats").append("tj_" + ftiName + "_ConceptScore");
}

######################################
# PF interface functions
#
######################################

@h

#define ENABLE_TDEBUG

#ifdef ENABLE_TDEBUG
extern int pftijah_debug;
#define SET_TDEBUG(V) pftijah_debug = V
#define TDEBUG(V) (pftijah_debug && (((V<=pftijah_debug)&&(pftijah_debug<100)) || ((V==pftijah_debug)&&(pftijah_debug>=100))) )
#else
#define SET_TDEBUG(V)
#define TDEBUG(V) 0
#endif

#define TJ_TIMINGS 777

@c
#include <pf_config.h>

#include <monet.h>
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include <math.h>

#include <pathfinder.h>

#include "pftijah.h"

#include "termdb.h"

#ifdef ENABLE_TDEBUG
/* 
 * The main pftijah variable, settable from the command line by the
 * <TijahOptions debug=number ..... from the query env.
 * Current strategy is not to reset the debug variable after the query
 * finished and to make it a global for ease of use.
 * The number has three possiblilities:
 * 0             : no debug
 * 1   - 99      : leveled debug
 * 100 - INT_MAX : debug a specific event 
 *
 * usage: if (TDEBUG ) expression
 */
int pftijah_debug = 0;
#endif

int executeMIL(char* str) {
    return monet_exec(str);
}

/*
 * the CMDtj_log is created to be able to print in very difficult IO areas
 */

static char* tj_log_fileName = NULL; /* set by [CMD]tj_setlog(filename) */

int CMDtj_setlog(str filename) {
	FILE* f;
	
	if ( (f = fopen(filename,"w")) ) {
	    fprintf(f,"# Start TIJAH logger:\n");
	    fclose(f);
	    tj_log_fileName = (char*)GDKstrdup(filename);
	}
	return GDK_SUCCEED;
}

int CMDtj_log(str format, int* i) {
	FILE* f;
	
	if ( tj_log_fileName != NULL ) {
	    if ( (f = fopen(tj_log_fileName,"a")) ) {
	        fprintf(f,(const char*)format,*i);
	        fclose(f);
	    }
	}
	return GDK_SUCCEED;
}

int CMDtj_chk_dict_hash(BAT* b_tag, BAT* b_term)
{
	if ( b_tag->T->hash == NULL ) {
	     // stream_printf(GDKout,"C[]: ADD HASHTABLE TO TAG DICTIONARY\n");
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[]: CREATE NEW HASHTABLE ON TAG DICTIONARY\n");
#endif
	     if ( !BAThash(BATmirror(b_tag),0) ) {
                 GDKerror("CMDtj_chk_dict_hash: adding hashtable to Tag fails\n");
	         return GDK_FAIL;
	     }
	}
	if ( b_term->T->hash == NULL ) {
	     // stream_printf(GDKout,"C[]: ADD HASHTABLE TO TERM DICTIONARY\n");
#ifdef TJ_TRACE
	     if ( TJ_TRACE ) stream_printf(GDKout,"C[]: CREATE NEW HASHTABLE ON TERM DICTIONARY\n");
#endif
	     if ( !BAThash(BATmirror(b_term),0) ) {
                 GDKerror("CMDtj_chk_dict_hash: adding hashtable to Term fails\n");
	         return GDK_FAIL;
	     }
	}
	return GDK_SUCCEED;
}

extern char* tijahParse(BAT* optbat, char* startNodes_name, char** errBUFF);

extern char* tjc_new_parse(char* query, BAT* optbat, BAT* rtagbat, int use_sn, char** errBUFF);

int CMDcheckHashTable(BAT* b) {
    if ( b->H->hash == NULL ) {
         if ( !BAThash(b,0) ) {
                 stream_printf(GDKout,"#termdb:tdb_checkHashTable: fail to creat hashtable on [oid,str] bat.\n");
             return GDK_FAIL;
         } else {
            if(0) stream_printf(GDKout,"#termdb:tdb_checkHashTable(): created hashtable on [oid,str] bat.\n");
	}
    }
    return GDK_SUCCEED;
}

int CMDtijah_query(BAT* optbat, BAT *rtagbat, bit* use_startnodes) {
	char* err;
	char* mil;
	int use_sn;

        int parser_timing = 0;
	lng time_start = GDKusec();

	if (TDEBUG(1)) stream_printf(GDKout,"# CMDtijah_query: start.\n");

	use_sn = 0;
        if (*use_startnodes) use_sn = 1;

	if ( !optbat ) {
            GDKerror("CMDtijah_query: missing option bat.\n");
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: call tijahParse.\n");

        int newversion = 1;
        BUN bun;
        if ( (bun = BUNfnd(optbat,"newversion")) != BUN_NONE ) {
            BATiter bi = bat_iterator(optbat);
            str val = (str)BUNtail(bi,bun);
	    if (strcmp(val,"true")==0)
	        newversion = 1;
	    else if (strcmp(val,"false")==0)
	        newversion = 0;
        }
	str query_text = NULL;

        if ( (bun = BUNfnd(optbat,"_query")) != BUN_NONE ) {
            BATiter bi = bat_iterator(optbat);
            query_text = (str)BUNtail(bi,bun);
        } else
	    stream_printf(GDKerr,"Error: cannot find \"_query\" tag.\n");


	lng time_parse_start = GDKusec();
	if ( newversion ) {
	    if ( !(mil=tjc_new_parse(query_text,optbat,rtagbat,use_sn,&err)) ) {
                GDKerror("CMDtijah_query: %s.\n", err);
	        return GDK_FAIL;
	    }
	} else {
	    if ( !(mil=tijahParse(optbat,"nexi_sn_xfer",&err)) ) {
                GDKerror("CMDtijah_query: %s.\n", err);
	        return GDK_FAIL;
	    }
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: finish tijahParse.\n");
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: start MIL script.\n");
	if (TDEBUG(9)) {
		stream_printf(GDKout,"# CMDtijah_query: generated MIL script:\n");
		stream_printf(GDKout,"%s",mil);
		stream_printf(GDKout,"# CMDtijah_query: end of MIL script:\n");
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: start executing MIL script.\n");
	lng time_mil_start = GDKusec();
        if ( executeMIL(mil)<0 ) {
            GDKerror("CMDtijah_query: execute MIL failed.\n");
	    return GDK_FAIL;
	}
	if ( newversion )
		GDKfree(mil);
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: finish MIL script.\n");
	lng time_end = GDKusec();

	if (TDEBUG(1)) stream_printf(GDKout,"# CMDtijah_query: finish.\n");

	if ( parser_timing ) {
		long time_total = (time_end - time_start);
		long time_parse = (time_mil_start - time_parse_start);
		long time_mil   = (time_end - time_mil_start);
	        stream_printf(GDKout,"#! Tijah query timing: [total/parse/mil] = [ " "%ld" "us/" "%ld"  "us/" "%ld" "us]\n",time_total,time_parse,time_mil);
	}
        return GDK_SUCCEED;
}

char* tijah_tokenize_string(char* buf, int len, char* outbuf);

int CMDtijah_tokenize (str* res, str arg)
{
	int sz    = strlen(arg);
	char* buf = GDKmalloc(sz + 1);

	if (!buf) {
            GDKerror("CMDtijah_tokenize: GDKmalloc() failed.\n");
	    return GDK_FAIL;
	}

	buf[0] = 0;
	*res = tijah_tokenize_string(arg,sz,buf);

	return GDK_SUCCEED;
}


/**
 * In-place synchronized oid computation experiment by Henning and Jan
 *
 */

#define FIND_OID(FOID,BBAT,BPTR,BTAIL) \
        /* use peter's poor mans binary search here */ \
        while (BPTR+1048576 < BTAIL && (*(oid*)BUNhead(BBAT,BPTR+1048576)) < FOID) \
            BPTR += 1048576; \
        while (BPTR+32768 < BTAIL && (*(oid*)BUNhead(BBAT,BPTR+32768)) < FOID) \
            BPTR += 32768; \
        while (BPTR+1024 < BTAIL && (*(oid*)BUNhead(BBAT,BPTR+1024)) < FOID) \
            BPTR += 1024; \
        while (BPTR+32 < BTAIL && (*(oid*)BUNhead(BBAT,BPTR+32)) < FOID) \
            BPTR += 32; \
        do { \
                BPTR++; \
        } while ( (BPTR < BTAIL) && ((*(oid*)BUNhead(BBAT,BPTR))<FOID) );
 
#define INPLACE_OID_CALC_HEADER \
        BATiter li = bat_iterator(l);   \
        BATiter ri = bat_iterator(r);   \
        if ( !bat_oid_sort_chck(l) || !bat_oid_sort_chck(r) ) \
            return  GDK_FAIL; \
        *res = BATsetaccess(l,BAT_WRITE); \
        BUN lp = BUNfirst(l), ll = BUNlast(l); \
        BUN rp = BUNfirst(r), rl = BUNlast(r); \
        while ( (lp < ll) && (rp < rl) ) { \
                oid lv = *(oid*)BUNhead(li,lp); \
                oid rv = *(oid*)BUNhead(ri,rp); \
                if ( lv == rv ) { \
                    dbl* dres = (dbl*)Tloc(l,lp);

#define INPLACE_OID_CALC_FOOTER \
                    lp++; rp++; \
                } else if ( lv < rv ) { \
                    FIND_OID(rv,li,lp,ll); \
                } else /* lv > rv */ { \
                    FIND_OID(lv,ri,rp,rl); \
                } \
        } \
        BBPfix(BBPcacheid(*res)); \
        (*res)->batDirty = TRUE; \
        (*res)->tsorted = FALSE; \
        return GDK_SUCCEED;

static int bat_oid_sort_chck(BAT* b) {
	/* incomplete, the head should also be key */
	if ( !b->hsorted ) {
	    GDKerror("bat_oid_sort_chck: BAT should be head sorted.\n");
	    return 0;
	}
	if (BAThtype(b) != TYPE_oid ) {
	    GDKerror("bat_oid_sort_chck: BAT shouled have oid head type.\n");
	    return 0;
	}
	return 1;
}

int CMDleft_add_dbl(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
        *dres += *(dbl*)Tloc(r,rp);
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_sub_dbl(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
	*dres -= *(dbl*)Tloc(r,rp);
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_mul_dbl(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
	*dres *= *(dbl*)Tloc(r,rp);
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_div_dbl(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
	*dres /= *(dbl*)Tloc(r,rp);
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_div_dbl_int(BAT** res, BAT*l, BAT*r) {
        INPLACE_OID_CALC_HEADER;
	*dres = (dbl)(*dres / *(int*)Tloc(r,rp));
        INPLACE_OID_CALC_FOOTER;
}

int CMDleft_log_dbl(BAT** res, BAT*l) {
	if ( !bat_oid_sort_chck(l) )
	    return  GDK_FAIL;
	/* make the left/res bat writable */
	*res = BATsetaccess(l,BAT_WRITE);
	(*res)->batDirty = TRUE;
 
	dbl *lp = (dbl*)Tloc(l, BUNfirst(l)), *lq = (dbl*)Tloc(l, BUNlast(l)); 

	for (; lp < lq; lp++ ) {
		*lp = log(*lp);
	}
	/* BBPfix(BBPcacheid(*res)); ERROR, MEMORY LEAK */
	(*res)->tsorted = FALSE;
	return GDK_SUCCEED;
}

/*
 *
 * And now the union variant for Henning
 *
 */

#define UNION_FIND_OID(FOID,BBAT,BPTR,BTAIL,RESBAT) \
        do { \
		if (!BUNins(RESBAT,(oid*)BUNhead(BBAT,BPTR),(dbl*)BUNtail(BBAT,BPTR), FALSE) ) \
		    return GDK_FAIL; \
                BPTR++; \
        } while ( (BPTR < BTAIL) && ((*(oid*)BUNhead(BBAT,BPTR))<FOID) );

#define UNION_OID_CALC_HEADER \
        BATiter li = bat_iterator(l);   \
        BATiter ri = bat_iterator(r);   \
        if ( !bat_oid_sort_chck(l) || !bat_oid_sort_chck(r) ) \
            return  GDK_FAIL; \
        *res = BATnew(TYPE_oid,TYPE_dbl,0); \
        BUN lp = BUNfirst(l), ll = BUNlast(l); \
        BUN rp = BUNfirst(r), rl = BUNlast(r); \
        while ( (lp < ll) || (rp < rl) ) { \
		oid lv, rv; \
                lv = (lp < ll) ? *(oid*)BUNhead(li,lp) : oid_nil; \
                rv = (rp < rl) ? *(oid*)BUNhead(ri,rp) : oid_nil; \
                if ( lv == rv ) { \
                    dbl* dres = (dbl*)Tloc(l,lp); \
		    dbl  newdbl;

#define UNION_OID_CALC_FOOTER \
		    if ( !BUNins(*res, &lv, &newdbl, FALSE) ) \
		        return GDK_FAIL; \
                    lp++; rp++; \
                } else if ( (rv==oid_nil) || (lv < rv) ) { \
                    UNION_FIND_OID(rv,li,lp,ll,*res); \
                } else /* (lv==oid_nil) || (lv > rv) */ { \
                    UNION_FIND_OID(lv,ri,rp,rl,*res); \
                } \
        } \
        /* BBPfix(BBPcacheid(*res)); ERROR MEMORY LEAK */ \
        (*res)->batDirty = TRUE; \
        (*res)->tsorted = FALSE; \
        return GDK_SUCCEED;

int CMDunion_add_dbl(BAT** res, BAT*l, BAT*r) {
        UNION_OID_CALC_HEADER;
        newdbl = *dres + *(dbl*)Tloc(r,rp);
        UNION_OID_CALC_FOOTER;
}

int CMDunion_sub_dbl(BAT** res, BAT*l, BAT*r) {
        UNION_OID_CALC_HEADER;
        newdbl = *dres - *(dbl*)Tloc(r,rp);
        UNION_OID_CALC_FOOTER;
}

int CMDunion_mul_dbl(BAT** res, BAT*l, BAT*r) {
        UNION_OID_CALC_HEADER;
        newdbl = *dres * *(dbl*)Tloc(r,rp);
        UNION_OID_CALC_FOOTER;
}
int CMDunion_div_dbl(BAT** res, BAT*l, BAT*r) {
        UNION_OID_CALC_HEADER;
        newdbl = *dres / *(dbl*)Tloc(r,rp);
        UNION_OID_CALC_FOOTER;
}

/*
 *
 * END of experiment
 *
 *
 */

int CMDpf2tijah_node(BAT** res, BAT* doc_name, BAT* doc_firstpre, BAT* doc_pfpre, BAT* item, BAT* kind, BAT* doc_loaded ) {
        int debug = 0;

	int nDocs = BATcount(doc_loaded);
	BAT **rangeBAT = (BAT**)GDKmalloc(nDocs*sizeof(BAT*));
	if (!rangeBAT) {
            GDKerror("CMDpf2tijah_node: GDKmalloc() failed.\n");
	    return GDK_FAIL;
	}
	for(int i=0; i<nDocs; i++) {
	    rangeBAT[i] = NULL;
        }

	*res = BATnew(TYPE_void, TYPE_oid, BATcount(item));

        if ( debug ) stream_printf(GDKout,"* Start of CMDpf2tijah_node():\n");
	if ( 1 && debug ) {
	    stream_printf(GDKout,"#!BAT: item\n");
	    BATprintf(GDKout,item);
	    stream_printf(GDKout,"#!BAT: kind\n");
	    BATprintf(GDKout,kind);
	    stream_printf(GDKout,"#!BAT: doc_loaded\n");
	    BATprintf(GDKout,doc_loaded);
	}
	if ( 1 && debug ) {
	    stream_printf(GDKout,"#!BAT: tijah:doc_name\n");
	    BATprintf(GDKout,doc_name);
	    stream_printf(GDKout,"#!BAT: tijah:doc_firstpre\n");
	    BATprintf(GDKout,doc_firstpre);
	    stream_printf(GDKout,"#!BAT: tijah:doc_pfpre\n");
	    BATprintf(GDKout,doc_pfpre);
	}

	BUN p,q;
        BATiter itemi = bat_iterator(item);
	BATloop(item, p, q) {
	    oid idx      = *(oid*) BUNhead(itemi, p);
	    ptr itemTAIL = BUNtail(itemi, p);
	    oid pfpre    = *(oid*) itemTAIL;

	    BUN kindBUN = BUNfnd(kind,&idx);
	    if ( kindBUN == BUN_NONE ) {
	        stream_printf(GDKout,"READ KIND failed\n");
		return GDK_FAIL;
	    }
	    int kval = *(int*)Tloc(kind, kindBUN);
	    // ALGEBRA NODES ONLY CONTAIN THE FRAG
	    oid container;
	    if ( XTRACT_KIND(kval) != ELEM ) {
	        // stream_printf(GDKout,"CMDpf2tijah_node: startNodes: no node\n");
		// return GDK_FAIL;
		container = (oid)kval;
		if ( debug ) stream_printf(GDKout,"* container = %d.\n",container);
            } else {
	    	container = (oid)XTRACT_CONT(kval);
	    }

	    int myindex = container - 1;
	    /* make it a switch */
	    if ( rangeBAT[myindex] == NULL ) {

	      BAT* docs_in_cont = BATselect(BATmirror(doc_loaded),&container,&container);
              BATiter docs_in_conti = bat_iterator(docs_in_cont);
	      BUN p_dic,q_dic;
	      BATloop(docs_in_cont, p_dic, q_dic) {
	        oid doc_start;
		oid doc_end;

	        str docname = (str) BUNhead(docs_in_conti, p_dic);
		BAT* b = BATmirror(doc_name);
	        BUN yy = BUNfnd(b,docname);
		if ( yy != BUN_NONE ) {
                    BATiter bi = bat_iterator(b);
		    if ( debug ) stream_printf(GDKout,"* pf2tijah_index: preparing doc(%s)[] nodes for translation\n",docname);	
		    oid tj_docIndex = *(oid*)BUNtail(bi,yy);

		    BUN r;
		    r = BUNfnd(doc_firstpre,&tj_docIndex);
		    if ( r == BUN_NONE ) {
	    	        stream_printf(GDKout,"Cannot find tijah-firstpre @  %d.\n",tj_docIndex);
		        return GDK_FAIL;
		    }

                    bi.b = doc_firstpre;
	            doc_start = *(oid*)BUNtail(bi,r);
		    oid tj_nextIndex = tj_docIndex +  1;
		    if ( BATcount(doc_firstpre) > tj_nextIndex ) {
		        r = BUNfnd(doc_firstpre,&tj_nextIndex);
			if ( r == BUN_NONE ) {
	    	            stream_printf(GDKout,"Cannot do range for tijah-firstpre @  %d.\n",tj_docIndex);
			    return GDK_FAIL;
			}
	                doc_end = *(oid*)BUNtail(bi,r) - 1;
		    } else {
	                doc_end = oid_nil;
		    }
		    BAT* ds = BATselect(BATmirror(doc_pfpre),(ptr)&doc_start,(ptr)&doc_end);
		    if ( rangeBAT[myindex] == NULL ) {
		        rangeBAT[myindex] = BATsetaccess(ds, BAT_WRITE);
		    } else {
		        if ( !BATins(rangeBAT[myindex],ds,1) ) {
	    	           stream_printf(GDKout,"CMDpf2tijah_node: BATins in rangeBAT fails.\n");
			   return GDK_FAIL;
		        }
		    }
		} {
		} } }
	        if ( rangeBAT[myindex] ) {
		    BUN range_bun = BUNfnd(rangeBAT[myindex],&pfpre);
		    if ( range_bun != BUN_NONE ) {
			/* found the tijah index value */
                        BATiter bi = bat_iterator(rangeBAT[myindex]);
		        oid tj_index = *(oid*)BUNtail(bi,range_bun);
			BUNappend(*res,&tj_index,1);
			if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = tijah(%d@0).\n", pfpre, container,tj_index);
		    } else {
		        if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = NOT INDEXED.\n", pfpre, container);
		    }
		    
		} else {
			if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = NOT INDEXED.\n", pfpre, container);
		}
	}
	/* cleanup BAT's */
	for(int i=0; i<nDocs; i++) {
	    if ( rangeBAT[i] ) {
	        BBPunfix(BBPcacheid(rangeBAT[i]));
		rangeBAT[i] = NULL;
	    }
        }
	GDKfree(rangeBAT);

	*res = BATmirror(BATmark(BATmirror(*res), 0));

	/* */
	if ( debug ) 
	    BATprintf(GDKout,*res);
	/* */
        return GDK_SUCCEED;
}

int CMDoffsetindex ( BAT** result, BAT* tid, int* res_size)
{
	char *name = "TJoffsetindex";
	BAT *res = NULL;
        BUN p, q;
        oid *dst = NULL, *sdst = NULL;
	oid t, s;

	/* --------------------------- checks ---------------------------------- */

	BATcheck(tid, name);
	if (!(BATtordered(tid) & 1))
	{
		/* BUG#1732596 this test currently fails on Itanium */
        	GDKerror("%s: index-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}
	if (!(BAThdense(tid)))
    	{
        	GDKerror("%s: index-bat must have a dense head.\n", name);
    		return GDK_FAIL;
	}
		
	/* ---------------------------- inits ---------------------------------- */

	res = BATnew(TYPE_void, TYPE_oid, *res_size);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, *res_size);
            	return(GDK_FAIL);
        }
	sdst = dst = (oid*)Tloc(res, BUNlast(res));
    
	t = (oid)0;
	*(oid*)dst = (oid)0;
	dst++;
	
	/* ----------------------------- main ---------------------------------- */

        BATiter tidi = bat_iterator(tid);
	BATloop(tid, p, q)
	{
		s = *(oid*) BUNtail(tidi, p);
		if (t != s)
		{
			for(; t < s; t++, dst++)
			{
				*(oid*)dst = p;
			}
		}
	}

	s = (oid) (*res_size - 1);
	for(; t < s; t++, dst++)
	{
		*dst = p;
	}
	
	/* ---------------------------- tidy up --------------------------------- */
	
	BATsetcount(res, dst - sdst);
    	res->batDirty = TRUE;
        res->tsorted = GDK_SORTED;
        BATkey (res, TRUE);
	BATset(res, TRUE);
	BATseqbase(res, 0);
	
	*result = res;
	return GDK_SUCCEED;
}	

int CMDmergeindex ( BAT** result, BAT* tidpre, BAT* oldindex, BAT* oldpre, int* indsize )
{
        BATiter tidprei, oldindexi, oldprei;
	char *name = "TJmergeindex";
	BAT *res = NULL;
	BAT *newindex = NULL;
	BAT *newpre = NULL;
	int i,j, ressize = 0;
        BUN lst_tidpre, lst_oldindex, lst_copy, lst_res, cur_tidpre, cur_oldindex, cur_oldpre;
        oid *s_newindex, *lst_newindex, *s_newpre, *lst_newpre;
	oid tid;
	
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tidpre, name);
	BATcheck(oldindex, name);
	BATcheck(oldpre, name);
        
	if (!(BAThordered(tidpre) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	/* ---------------------------- inits ---------------------------------- */

	ressize = 2;
	res = BATnew(TYPE_void, TYPE_bat, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = BATcount(tidpre) + BATcount(oldpre);
	newpre = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = *indsize;
	newindex = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	lst_tidpre = BUNlast(tidpre);
	lst_oldindex = BUNlast(oldindex) - 1; /* last index is not a real term */
	s_newindex = lst_newindex = (oid*)Tloc(newindex, BUNlast(newindex));
	s_newpre = lst_newpre = (oid*)Tloc(newpre, BUNlast(newpre));
	lst_res = BUNlast(res);
	
	cur_tidpre = BUNfirst(tidpre);
	cur_oldindex = BUNfirst(oldindex);
	cur_oldpre = BUNfirst(oldpre);
	
        tidprei = bat_iterator(tidpre);
        oldindexi = bat_iterator(oldindex);
        oldprei = bat_iterator(oldpre);
	/* ----------------------------- main ---------------------------------- */
	
	j = *indsize - 1;
	for(i = 0; i < j; i++)
        {
	        tid = (oid) i;
		*lst_newindex++ = lst_newpre - s_newpre;
               
                /* copy old nodes to new index */
                if (cur_oldindex < lst_oldindex && tid == *(oid*)BUNhead(oldindexi, cur_oldindex))
                {
		        lst_copy = *(int*) BUNtail(oldindexi, cur_oldindex + 1);
		        while (cur_oldpre < lst_copy)
		        {
			        *lst_newpre++ = *(oid*)BUNtail(oldprei, cur_oldpre);
			        cur_oldpre++;
		        }
                        cur_oldindex++;
                }
                /* merge-in new nodes */
                while(cur_tidpre < lst_tidpre && tid == *(oid*)BUNhead(tidprei, cur_tidpre))
                {
                        *lst_newpre++ = *(oid*)BUNtail(tidprei, cur_tidpre);
	        	cur_tidpre++;
                }
        }

	/* write limit of index as last item to index bat */
	*lst_newindex = lst_newpre - s_newpre;
	lst_newindex++;

	/* ---------------------------- tidy up --------------------------------- */

	BATsetcount(newindex, lst_newindex - s_newindex);
    	newindex->batDirty = TRUE;
        newindex->hsorted = GDK_SORTED;
        newindex->tsorted = GDK_SORTED;
        BATkey(newindex, TRUE);
        BATkey(BATmirror(newindex), FALSE);
	BATseqbase(newindex, (oid)0);

	BATsetcount(newpre, lst_newpre - s_newpre);
    	newpre->batDirty = TRUE;
        newpre->hsorted = GDK_SORTED;
        newpre->tsorted = FALSE;
        BATkey(newpre, TRUE);
        BATkey(BATmirror(newpre), TRUE);
	BATseqbase(newpre, (oid)0);
	
        /* insert bats in result */		
	BATseqbase(res, (oid)0);
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newindex->batCacheid);
	BBPunfix(newindex->batCacheid);	
	lst_res++;
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newpre->batCacheid); 
	BBPunfix(newpre->batCacheid);	
	lst_res++;
	
	BATsetcount(res, 2);
	res->batDirty = TRUE;
	BATkey(res, TRUE);
	BATkey(BATmirror(res), TRUE);
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
        res->H->nonil = 1;
        res->T->nonil = 0;
	
	*result = res;
	return GDK_SUCCEED;
}

int CMDmergeindex2 ( BAT** result, BAT* tidpre, BAT* tidsize, BAT* oldindex, BAT* oldpre, BAT* oldsize, int* indsize )
{
	char *name = "TJmergeindex2";
	BAT *res = NULL;
	BAT *newindex = NULL;
	BAT *newpre = NULL;
	BAT *newsize = NULL;
	int i,j, ressize = 0;
        BUN lst_tidpre, lst_oldindex, lst_copy, lst_res, cur_tidpre, cur_tidsize, cur_oldindex, cur_oldpre, cur_oldsize;
        BATiter tidprei, tidsizei, oldindexi, oldprei, oldsizei;
        oid *s_newindex, *lst_newindex, *s_newpre, *lst_newpre;
	int *s_newsize, *lst_newsize;
	oid tid;
	
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tidpre, name);
	BATcheck(tidsize, name);
	BATcheck(oldindex, name);
	BATcheck(oldpre, name);
	BATcheck(oldsize, name);
        
	if (!(BAThordered(tidpre) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	/* ---------------------------- inits ---------------------------------- */

	ressize = 3;
	res = BATnew(TYPE_void, TYPE_bat, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = BATcount(tidpre) + BATcount(oldpre);
	newpre = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	newsize = BATnew(TYPE_void, TYPE_int, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,int] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = *indsize;
	newindex = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	lst_tidpre = BUNlast(tidpre);
	lst_oldindex = BUNlast(oldindex) - 1; /* last index is not a real term */
	s_newindex = lst_newindex = (oid*)Tloc(newindex, BUNlast(newindex));
	s_newpre = lst_newpre = (oid*)Tloc(newpre, BUNlast(newpre));
	s_newsize = lst_newsize = (int*)Tloc(newsize, BUNlast(newsize));
	lst_res = BUNlast(res);
	
	cur_tidpre = BUNfirst(tidpre);
	cur_tidsize = BUNfirst(tidsize);
	cur_oldindex = BUNfirst(oldindex);
	cur_oldpre = BUNfirst(oldpre);
	cur_oldsize = BUNfirst(oldsize);
	
        tidprei = bat_iterator(tidpre);
        tidsizei = bat_iterator(tidsize);
        oldindexi = bat_iterator(oldindex);
        oldprei = bat_iterator(oldpre);
        oldsizei = bat_iterator(oldsize);

	/* ----------------------------- main ---------------------------------- */
	
	j = *indsize - 1;
	for(i = 0; i < j; i++)
        {
	        tid = (oid) i;
		*lst_newindex++ = lst_newpre - s_newpre;
               
                /* copy old nodes to new index */
                if (cur_oldindex < lst_oldindex && tid == *(oid*)BUNhead(oldindexi, cur_oldindex))
                {
		        lst_copy = *(int*) BUNtail(oldindexi, cur_oldindex + 1);
		        while (cur_oldpre < lst_copy)
		        {
			        *lst_newpre++ = *(oid*)BUNtail(oldprei, cur_oldpre);
			        *lst_newsize++ = *(int*)BUNtail(oldsizei, cur_oldsize);
			        cur_oldpre++;
			        cur_oldsize++;
		        }
                        cur_oldindex++;
                }
                /* merge-in new nodes */
                while(cur_tidpre < lst_tidpre && tid == *(oid*)BUNhead(tidprei, cur_tidpre))
                {
                        *lst_newpre++ = *(oid*)BUNtail(tidprei, cur_tidpre);
                        *lst_newsize++ = *(int*)BUNtail(tidsizei, cur_tidsize);
	        	cur_tidpre++;
	        	cur_tidsize++;
                }
        }

	/* write limit of index as last item to index bat */
	*lst_newindex = lst_newpre - s_newpre;
	lst_newindex++;

	/* ---------------------------- tidy up --------------------------------- */

	BATsetcount(newindex, lst_newindex - s_newindex);
    	newindex->batDirty = TRUE;
        newindex->hsorted = GDK_SORTED;
        newindex->tsorted = GDK_SORTED;
        BATkey(newindex, TRUE);
        BATkey(BATmirror(newindex), FALSE);
	BATseqbase(newindex, (oid)0);

	BATsetcount(newpre, lst_newpre - s_newpre);
    	newpre->batDirty = TRUE;
        newpre->hsorted = GDK_SORTED;
        newpre->tsorted = FALSE;
        BATkey(newpre, TRUE);
        BATkey(BATmirror(newpre), TRUE);
	BATseqbase(newpre, (oid)0);
	
	BATsetcount(newsize, lst_newsize - s_newsize);
    	newsize->batDirty = TRUE;
        newsize->hsorted = GDK_SORTED;
        newsize->tsorted = FALSE;
        BATkey(newsize, TRUE);
	BATseqbase(newsize, (oid)0);
	
        /* insert bats in result */		
	BATseqbase(res, (oid)0);
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newindex->batCacheid);
	BBPunfix(newindex->batCacheid);	
	lst_res++;
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newpre->batCacheid); 
	BBPunfix(newpre->batCacheid);	
	lst_res++;
	voidfix_bunfastins_nocheck_noinc(res, lst_res, 0, (void*)&newsize->batCacheid); 
	BBPunfix(newsize->batCacheid);	
	lst_res++;
	
	BATsetcount(res, 3);
	res->batDirty = TRUE;
	BATkey(res, TRUE);
	BATkey(BATmirror(res), TRUE);
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
        res->H->nonil = 1;
        res->T->nonil = 0;
	
	*result = res;
	return GDK_SUCCEED;
}

int CMDindexfetchjoin ( BAT** result, BAT* tid, BAT* index, BAT* pre )
{
	char *name = "TJindexfetchjoin";
	BAT *res = NULL;
        oid *sdst = NULL, *hdst = NULL, *tdst = NULL;

	int ressize = 0;
	oid t, *ind;
	BUN p, q;
        int j, i = 0;
	/* bit one_tid = FALSE; */
    
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tid, name);
	BATcheck(index, name);
	BATcheck(pre, name);
	
        /* if (BATcount(tid) <= 1) one_tid = TRUE; */
	
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	/* ---------------------------- inits ---------------------------------- */

	ind = (oid*)GDKmalloc(sizeof(oid) * BATcount(tid) * 3);
        if (ind == NULL) 
        { 
            	GDKerror("%s: could not allocate a offset stack of size %d.\n", name, BATcount(tid));
            	return(GDK_FAIL);
        }
	
        BATiter tidi = bat_iterator(tid);
	BATloop(tid, p, q) {
		t = *(oid*) BUNtail(tidi, p);
		ind[i++] = t;
		ind[i++] = *(oid*) Tloc(index, (int)t);
		ind[i++] = *(oid*) Tloc(index, (int)t + 1);
		ressize += (ind[i - 1] - ind[i - 2]);
	}
	
	res = BATnew(TYPE_oid, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[oid,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	sdst = hdst = (oid*)Hloc(res, BUNlast(res));
               tdst = (oid*)Tloc(res, BUNlast(res));
	
	/* ----------------------------- main ---------------------------------- */

	j = 0;
	while (j < i) {
        	t = ind[j++];
		p = ind[j++];
		q = ind[j++];
		for (; p < q; p++) {
			*hdst++ = t;
			*tdst++ = *(oid*)Tloc(pre,p);
		}
	}

	/* ---------------------------- tidy up --------------------------------- */

	GDKfree(ind);
	BATsetcount(res, hdst - sdst);
    	res->batDirty = TRUE;
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
        BATkey (BATmirror(res), TRUE);
	BATset(res, TRUE);
	
	*result = res;
	return GDK_SUCCEED;
}

@= init_result
{
	REGISTER BUN _p = BUNlast(bn);

	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloop(e, p, q) {
		oiddbl_bunfastins_nocheck_noinc(bn, _p, Hloc(e,p), &zero);
		_p++;
	}
	ALGODEBUG THRprintf(GDKout, "#init_result(dbl): BAThordered(e)&1, \n");
	BATsetcount(bn, _p - BUNfirst(bn));
	if ( !BATprepareHash(bn) ) {
	    /* do nothing yet */;	
	}
	if (!bn->batDirty)
		bn->batDirty = TRUE;
}
@

@c
#define max_stack_size 128

typedef struct stack_item si;

struct stack_item {
    oid ctx;            /* ctx */
    oid eocs;           /* end of ctx scope (pre + size) */
};

int CMDtreemergejoin_sort(BAT **result, BAT *Astart, BAT *nid_size, BAT *Dstart) {

    /* ---------------------------- declarations ------------------------------------ */
    char *name = "TJ_treemergejoin_sort";
    BAT *res = *result;
    BUN D_cur, D_last, 
        A_cur, A_last;
    BATiter Ai, Di;
    oid D_cur_pre;

    si *stack; 
    BUN stack_top = 0, i;
	
    int *size;
    BUN free;	
    oid *sdst = NULL, *hdst = NULL, *tdst = NULL;
    
    /* ------------------------------- checks ---------------------------------------- */
    if (!(BATtordered(Astart)&1)) { 
        GDKerror("%s: Ancestor pre BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(Dstart)&1)) { 
        GDKerror("%s: Descendant BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (nid_size->ttype != TYPE_int) {
        GDKerror("%s: tail of size BAT must be type INT.\n", name);
        return(GDK_FAIL);
    }
    if (nid_size->htype != TYPE_void) {
        GDKerror("%s: head (oid) of size BAT must NOT be materialized.\n", name);
        return(GDK_FAIL);
    }
    if (BATcount(Astart) == 0 || BATcount(nid_size) == 0 || BATcount(Dstart) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_oid, 0);
        *result = res;    
        return(GDK_SUCCEED);
    }

    /* ----------------------------- initialize -------------------------------------- */
    // The maximum depth of the stack is the depth of the XML tree
    if ((stack = (si*)GDKmalloc(sizeof(si) * max_stack_size)) == NULL) {
        GDKerror("treemergejoin_sort: could not allocate memory for stack.\n"); 
        return(GDK_FAIL);
    }

    // the size of the bat may not be correct (could be more, could be less)
    free = BATcount(Dstart);
    res = BATnew(TYPE_oid, TYPE_oid, free); 
    if (res == NULL) 
    { 
       GDKerror("%s: could not allocate result BAT.\n", name);
       return(GDK_FAIL);
    }
    
    size = ((int*) Tloc(nid_size, BUNfirst(nid_size))) - (int)nid_size->hseqbase;
    D_cur = BUNfirst(Dstart);
    D_last = BUNlast(Dstart);  
    A_cur = BUNfirst(Astart);
    A_last = BUNlast(Astart);
    Ai = bat_iterator(Astart);
    Di = bat_iterator(Dstart);
    sdst = hdst = (oid*)Hloc(res, BUNlast(res));
           tdst = (oid*)Tloc(res, BUNlast(res));

    /* -------------------------------- main ---------------------------------------- */
    
    while(D_cur < D_last) {
      
      D_cur_pre = *(oid*)BUNtail(Di, D_cur);
      /* printf("0. eocs: %d, desc: %d\n", stack[stack_top-1].eocs, *(oid*)BUNtail(Di, D_cur)); */
      
      /* remove ancestor candidates that ended before D_cur */
      while (stack_top && D_cur_pre > stack[stack_top-1].eocs) {
        /* pop */
	stack_top--;
      }	
      
      /* printf("1.stacksize: %d\n", stack_top); */
      
      /* Put ancestors on stack until we reach the current descendent */ 
      while (A_cur < A_last && *(oid*)BUNtail(Ai, A_cur) < D_cur_pre){		
	if (D_cur_pre <= (*(oid*)BUNtail(Ai, A_cur) + size[*(oid*)BUNhead(Ai, A_cur)])) {
           /* push */
	   si new_stack_item;
           new_stack_item.ctx = *(oid*)BUNhead(Ai, A_cur);
           new_stack_item.eocs = *(oid*)BUNtail(Ai, A_cur) + size[*(oid*)BUNhead(Ai, A_cur)];
           stack[stack_top++] = new_stack_item;
	}
	A_cur++;
      }
      
      /* output everything that is on the stack (the ancestors) */
      /* It has started before Dstart and since it's a tree, */
      /* it has to end after Dend. */
      if (free < stack_top)
      {
     	BATsetcount(res, hdst - sdst);
        BUN sz = BATgrows(res);
        if (BATextend(res, sz) == NULL)
    	{ 
       	  GDKerror("%s: could not extend result BAT.\n", name);
          return(GDK_FAIL);
    	}
        sdst = (oid*)Hloc(res, BUNfirst(res));
        hdst = (oid*)Hloc(res, BUNlast(res));
        tdst = (oid*)Tloc(res, BUNlast(res));
        free = sz - BATcount(res) - stack_top;
      } else {
          free -= stack_top;
      }
     
      for (i=0;i<stack_top;i++) {
        /* printf("3. anc/desc: (%d/%d)\n", stack[i].ctx, *(oid*)BUNtail(Di, D_cur)); */
        *hdst++ = stack[i].ctx;
        *tdst++ = *(oid*)BUNhead(Di, D_cur);
      }
      D_cur++;
    }
     /* it is possible there are still ancestor candidates left on the stack, but we are out of descendants, so they starve... */
    
    /* ----------------------------- tidy up -------------------------------------- */
     GDKfree(stack); 
	
     BATsetcount(res, hdst - sdst);
     res->batDirty = TRUE;
     res->tsorted = FALSE;
     res->hsorted = FALSE;
     BATset(res, TRUE);
     
     *result = res;    
     return(GDK_SUCCEED);
}

int CMDtreemergejoin_nid(BAT **result, BAT *Astart, BAT *nid_size, BAT *Dstart) {

    /* ---------------------------- declarations ------------------------------------ */
    char *name = "TJ_treemergejoin_nid";
    BAT *res = *result;
    BUN D_cur, D_last, 
        A_cur, A_last;
    BATiter Ai, Di;
    oid D_cur_pre;

    si *stack; 
    BUN stack_top = 0, i;
	
    int *size;
    BUN free;	
    oid *sdst = NULL, *hdst = NULL, *tdst = NULL;
    
    /* ------------------------------- checks ---------------------------------------- */
    if (!(BATtordered(Astart)&1)) { 
        GDKerror("%s: Ancestor BAT not sorted on pre.\n",name); 
        return(GDK_FAIL);
    }
    if (!(BAThordered(Dstart)&1)) { 
        GDKerror("%s: Descendant BAT not sorted on nid.\n",name); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(Dstart)&1)) { 
        GDKerror("%s: Descendant BAT not sorted on pre.\n",name); 
        return(GDK_FAIL);
    }
    if (nid_size->ttype != TYPE_int) {
        GDKerror("%s: tail of size BAT must be type INT.\n", name);
        return(GDK_FAIL);
    }
    if (nid_size->htype != TYPE_void) {
        GDKerror("%s: head (oid) of size BAT must NOT be materialized.\n", name);
        return(GDK_FAIL);
    }
    if (BATcount(Astart) == 0 || BATcount(nid_size) == 0 || BATcount(Dstart) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_oid, 0);
        *result = res;    
        return(GDK_SUCCEED);
    }

    /* ----------------------------- initialize -------------------------------------- */
    // The maximum depth of the stack is the depth of the XML tree
    if ((stack = (si*)GDKmalloc(sizeof(si) * max_stack_size)) == NULL) {
        GDKerror("treemergejoin_sort: could not allocate memory for stack.\n"); 
        return(GDK_FAIL);
    }

    // the size of the bat may not be correct (could be more, could be less)
    free = BATcount(Dstart);
    res = BATnew(TYPE_oid, TYPE_oid, free); 
    if (res == NULL) 
    { 
       GDKerror("%s: could not allocate result BAT.\n", name);
       return(GDK_FAIL);
    }
    
    size = ((int*) Tloc(nid_size, BUNfirst(nid_size))) - (int)nid_size->hseqbase;
    D_cur = BUNfirst(Dstart);
    D_last = BUNlast(Dstart);  
    A_cur = BUNfirst(Astart);
    A_last = BUNlast(Astart);
    Ai = bat_iterator(Astart);
    Di = bat_iterator(Dstart);
    sdst = hdst = (oid*)Hloc(res, BUNlast(res));
           tdst = (oid*)Tloc(res, BUNlast(res));

    /* -------------------------------- main ---------------------------------------- */
    
    while(D_cur < D_last) {
      
      D_cur_pre = *(oid*)BUNtail(Di, D_cur);
      /* printf("0. eocs: %d, desc: %d\n", stack[stack_top-1].eocs, *(oid*)BUNtail(Di, D_cur)); */
      
      /* remove ancestor candidates that ended before D_cur */
      while (stack_top && D_cur_pre > stack[stack_top-1].eocs) {
        /* pop */
	stack_top--;
      }	
      
      /* printf("1.stacksize: %d\n", stack_top); */
      
      /* Put ancestors on stack until we reach the current descendent */ 
      while (A_cur < A_last && *(oid*)BUNtail(Ai, A_cur) < D_cur_pre){		
	if (D_cur_pre <= (*(oid*)BUNtail(Ai, A_cur) + size[*(oid*)BUNhead(Ai, A_cur)])) {
           /* push */
	   si new_stack_item;
           new_stack_item.ctx = *(oid*)BUNhead(Ai, A_cur);
           new_stack_item.eocs = *(oid*)BUNtail(Ai, A_cur) + size[*(oid*)BUNhead(Ai, A_cur)];
           stack[stack_top++] = new_stack_item;
	}
	A_cur++;
      }
      
      /* output everything that is on the stack (the ancestors) */
      /* It has started before Dstart and since it's a tree, */
      /* it has to end after Dend. */
      if (free < stack_top)
      {
     	BATsetcount(res, hdst - sdst);
        BUN sz = BATgrows(res);
        if (BATextend(res, sz) == NULL)
    	{ 
       	  GDKerror("%s: could not extend result BAT.\n", name);
          return(GDK_FAIL);
    	}
        sdst = (oid*)Hloc(res, BUNfirst(res));
        hdst = (oid*)Hloc(res, BUNlast(res));
        tdst = (oid*)Tloc(res, BUNlast(res));
        free = sz - BATcount(res) - stack_top;
      } else {
          free -= stack_top;
      }
     
      for (i=0;i<stack_top;i++) {
        /* printf("3. anc/desc: (%d/%d)\n", stack[i].ctx, *(oid*)BUNtail(Di, D_cur)); */
        *hdst++ = stack[i].ctx;
        *tdst++ = *(oid*)BUNhead(Di, D_cur);
      }
      D_cur++;
    }
     /* it is possible there are still ancestor candidates left on the stack, but we are out of descendants, so they starve... */
    
    /* ----------------------------- tidy up -------------------------------------- */
     GDKfree(stack); 
	
     BATsetcount(res, hdst - sdst);
     res->batDirty = TRUE;
     if (BAThordered(Dstart)&1) res->tsorted = GDK_SORTED;
     else res->tsorted = FALSE;
     res->hsorted = FALSE;
     BATset(res, TRUE);
     
     *result = res;    
     return(GDK_SUCCEED);
}

int CMDtreemergejoin_pre(BAT **result, BAT *Astart, BAT *pre_size, BAT *Dstart) {

    /* ---------------------------- declarations ------------------------------------ */
    char *name = "TJ_treemergejoin_pre";
    BAT *res = *result;
    BUN D_cur, D_last, 
        A_cur, A_last;
    BATiter Ai, Di;
    oid D_cur_pre, A_cur_pre;

    si *stack; 
    BUN stack_top = 0, i;
	
    int *size;
    BUN free;	
    oid *sdst = NULL, *hdst = NULL, *tdst = NULL;
    
    /* ------------------------------- checks ---------------------------------------- */
    if (!(BAThordered(Astart)&1)) { 
        GDKerror("%s: Ancestor pre BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (!(BAThordered(Dstart)&1)) { 
        GDKerror("%s: Descendant BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (pre_size->ttype != TYPE_int) {
        GDKerror("%s: tail of size BAT must be type INT.\n", name);
        return(GDK_FAIL);
    }
    if (pre_size->htype != TYPE_void) {
        GDKerror("%s: head (oid) of size BAT must NOT be materialized.\n", name);
        return(GDK_FAIL);
    }
    if (BATcount(Astart) == 0 || BATcount(pre_size) == 0 || BATcount(Dstart) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_oid, 0);
        *result = res;    
        return(GDK_SUCCEED);
    }

    /* ----------------------------- initialize -------------------------------------- */
    // The maximum depth of the stack is the depth of the XML tree
    if ((stack = (si*)GDKmalloc(sizeof(si) * max_stack_size)) == NULL) {
        GDKerror("treemergejoin_sort: could not allocate memory for stack.\n"); 
        return(GDK_FAIL);
    }

    // the size of the bat may not be correct (could be more, could be less)
    free = BATcount(Dstart);
    res = BATnew(TYPE_oid, TYPE_oid, free); 
    if (res == NULL) 
    { 
       GDKerror("%s: could not allocate result BAT.\n", name);
       return(GDK_FAIL);
    }
    
    size = ((int*) Tloc(pre_size, BUNfirst(pre_size))) - (int)pre_size->hseqbase;
    D_cur = BUNfirst(Dstart);
    D_last = BUNlast(Dstart);  
    A_cur = BUNfirst(Astart);
    A_last = BUNlast(Astart);
    Ai = bat_iterator(Astart);
    Di = bat_iterator(Dstart);
    sdst = hdst = (oid*)Hloc(res, BUNlast(res));
           tdst = (oid*)Tloc(res, BUNlast(res));

    /* -------------------------------- main ---------------------------------------- */
    
    while(D_cur < D_last) {
      
      D_cur_pre = *(oid*)BUNhead(Di, D_cur);
      /* printf("0. eocs: %d, desc: %d\n", stack[stack_top-1].eocs, *(oid*)BUNtail(Di, D_cur)); */
      
      /* remove ancestor candidates that ended before D_cur */
      while (stack_top && D_cur_pre > stack[stack_top-1].eocs) {
        /* pop */
	stack_top--;
      }	
      
      /* printf("1.stacksize: %d\n", stack_top); */
      
      /* Put ancestors on stack until we reach the current descendent */ 
      while (A_cur < A_last && D_cur_pre > (A_cur_pre = *(oid*)BUNhead(Ai, A_cur))){		
	if (D_cur_pre <= (A_cur_pre + size[A_cur_pre])) {
           /* push */
	   si new_stack_item;
           new_stack_item.ctx = A_cur_pre;
           new_stack_item.eocs = A_cur_pre + size[A_cur_pre];
           stack[stack_top++] = new_stack_item;
	}
	A_cur++;
      }
      
      /* output everything that is on the stack (the ancestors) */
      /* It has started before Dstart and since it's a tree, */
      /* it has to end after Dend. */
      if (free < stack_top)
      {
     	BATsetcount(res, hdst - sdst);
        BUN sz = BATgrows(res);
        if (BATextend(res, sz) == NULL)
    	{ 
       	  GDKerror("%s: could not extend result BAT.\n", name);
          return(GDK_FAIL);
    	}
        sdst = (oid*)Hloc(res, BUNfirst(res));
        hdst = (oid*)Hloc(res, BUNlast(res));
        tdst = (oid*)Tloc(res, BUNlast(res));
        free = sz - BATcount(res) - stack_top;
      } else {
          free -= stack_top;
      }
     
      for (i=0;i<stack_top;i++) {
        *hdst++ = stack[i].ctx;
        *tdst++ = D_cur_pre;
      }
      D_cur++;
    }
     /* it is possible there are still ancestor candidates left on the stack, but we are out of descendants, so they starve... */
    
    /* ----------------------------- tidy up -------------------------------------- */
     GDKfree(stack); 
	
     BATsetcount(res, hdst - sdst);
     res->batDirty = TRUE;
     res->tsorted = GDK_SORTED;
     res->hsorted = FALSE;
     BATset(res, TRUE);
     
     *result = res;    
     return(GDK_SUCCEED);
}

int CMDtreemergejoin_sort_unnested(BAT **result, BAT *Astart, BAT *nid_size, BAT *Dstart) {

    /* ---------------------------- declarations ------------------------------------ */
    char *name = "TJ_treemergejoin_sort_unnested";
    BAT *res = *result;
    BUN D_cur, D_last, 
        A_cur, A_last;
    BATiter Ai, Di;
    oid D_cur_pre;
    int *size;
    int free;	
    oid *sdst = NULL, *hdst = NULL, *tdst = NULL;
    
    /* ------------------------------- checks ---------------------------------------- */
    if (!(BATtordered(Astart)&1)) { 
        GDKerror("%s: Ancestor pre BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(Dstart)&1)) { 
        GDKerror("%s: Descendant BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (nid_size->ttype != TYPE_int) {
        GDKerror("%s: tail of size BAT must be type INT.\n", name);
        return(GDK_FAIL);
    }
    if (nid_size->htype != TYPE_void) {
        GDKerror("%s: head (oid) of size BAT must NOT be materialized.\n", name);
        return(GDK_FAIL);
    }
    if (BATcount(Astart) == 0 || BATcount(nid_size) == 0 || BATcount(Dstart) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_oid, 0);
        *result = res;    
        return(GDK_SUCCEED);
    }

    /* ----------------------------- initialize -------------------------------------- */
    // the size of the bat may not be correct (could be more, could be less)
    free = BATcount(Dstart);
    res = BATnew(TYPE_oid, TYPE_oid, free); 
    if (res == NULL) 
    { 
       GDKerror("%s: could not allocate result BAT.\n", name);
       return(GDK_FAIL);
    }
    
    size = ((int*) Tloc(nid_size, BUNfirst(nid_size))) - (int)nid_size->hseqbase;
    D_cur = BUNfirst(Dstart);
    D_last = BUNlast(Dstart);  
    A_cur = BUNfirst(Astart);
    A_last = BUNlast(Astart);
    Ai = bat_iterator(Astart);
    Di = bat_iterator(Dstart);
    sdst = hdst = (oid*)Hloc(res, BUNlast(res));
           tdst = (oid*)Tloc(res, BUNlast(res));

    /* -------------------------------- main ---------------------------------------- */
    
    /* skip descendant candidates before the next ancestor candidate */
    while(D_cur < D_last && *(oid*)Tloc(Dstart, D_cur) <= *(oid*)Tloc(Astart,A_cur))
      D_cur++; 
      
    while(D_cur < D_last && A_cur < A_last) {
      
      /* skip ancestor candidates before the next descendant candidate */
      D_cur_pre = *(oid*)Tloc(Dstart, D_cur);
      /* poor man's binary search / exploiting forward scan */ 
      while (A_cur+1048576 < A_last && *(oid*)Tloc(Astart, A_cur+1048576) < D_cur_pre)
          A_cur += 1048576; 
      while (A_cur+32768 < A_last && *(oid*)Tloc(Astart, A_cur+32768) < D_cur_pre)
          A_cur += 32768; 
      while (A_cur+1024 < A_last && *(oid*)Tloc(Astart, A_cur+1024) < D_cur_pre)
          A_cur += 1024;  
      while (A_cur+1 < A_last && *(oid*)Tloc(Astart, A_cur+1) < D_cur_pre)
          A_cur++;

      /* write to result */ 
      while (D_cur < D_last && *(oid*)Tloc(Dstart, D_cur) <= (*(oid*)Tloc(Astart, A_cur) + size[*(oid*)BUNhead(Ai, A_cur)])) {
          *hdst++ = *(oid*)BUNhead(Ai, A_cur);
          *tdst++ = *(oid*)BUNhead(Di, D_cur);
          D_cur++;
      }
      /* this ancestor cannot have further results (tree properties) */
      A_cur++;
    
      /* skip descendant candidates before the next ancestor candidate */
      if (A_cur < A_last)
          while(D_cur < D_last && *(oid*)Tloc(Dstart, D_cur) <= *(oid*)Tloc(Astart,A_cur))
              D_cur++; 
    }
    
    /* ----------------------------- tidy up -------------------------------------- */
    BATsetcount(res, hdst - sdst);
    res->batDirty = TRUE;
    if (BAThordered(Astart)&1) res->hsorted = GDK_SORTED;
    if (BAThordered(Dstart)&1) res->tsorted = GDK_SORTED;
    BATset(res, TRUE);
    
    *result = res;    
    return(GDK_SUCCEED);
}

int CMDtreemergejoin_unnested_nid(BAT **result, BAT *Astart, BAT *nid_size, BAT *Dstart) {

    /* ---------------------------- declarations ------------------------------------ */
    char *name = "TJ_treemergejoin_unnested_nid";
    BAT *res = *result;
    BUN D_cur, D_last, 
        A_cur, A_last;
    BATiter Ai, Di;
    oid D_cur_pre;
    int *size;
    int free;	
    oid *sdst = NULL, *hdst = NULL, *tdst = NULL;
    
    /* ------------------------------- checks ---------------------------------------- */
    if (!(BATtordered(Astart)&1)) { 
        GDKerror("%s: Ancestor BAT not sorted on pre.\n",name); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(Dstart)&1)) { 
        GDKerror("%s: Descendant BAT not sorted on pre.\n",name); 
        return(GDK_FAIL);
    }
    if (nid_size->ttype != TYPE_int) {
        GDKerror("%s: tail of size BAT must be type INT.\n", name);
        return(GDK_FAIL);
    }
    if (nid_size->htype != TYPE_void) {
        GDKerror("%s: head (oid) of size BAT must NOT be materialized.\n", name);
        return(GDK_FAIL);
    }
    if (BATcount(Astart) == 0 || BATcount(nid_size) == 0 || BATcount(Dstart) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_oid, 0);
        *result = res;    
        return(GDK_SUCCEED);
    }

    /* ----------------------------- initialize -------------------------------------- */
    // the size of the bat may not be correct (could be more, could be less)
    free = BATcount(Dstart);
    res = BATnew(TYPE_oid, TYPE_oid, free); 
    if (res == NULL) 
    { 
       GDKerror("%s: could not allocate result BAT.\n", name);
       return(GDK_FAIL);
    }
    
    size = ((int*) Tloc(nid_size, BUNfirst(nid_size))) - (int)nid_size->hseqbase;
    D_cur = BUNfirst(Dstart);
    D_last = BUNlast(Dstart);  
    A_cur = BUNfirst(Astart);
    A_last = BUNlast(Astart);
    Ai = bat_iterator(Astart);
    Di = bat_iterator(Dstart);
    sdst = hdst = (oid*)Hloc(res, BUNlast(res));
           tdst = (oid*)Tloc(res, BUNlast(res));

    /* -------------------------------- main ---------------------------------------- */
    
    /* skip descendant candidates before the next ancestor candidate */
    while(D_cur < D_last && *(oid*)Tloc(Dstart, D_cur) <= *(oid*)Tloc(Astart,A_cur))
      D_cur++; 
      
    while(D_cur < D_last && A_cur < A_last) {
      
      /* skip ancestor candidates before the next descendant candidate */
      D_cur_pre = *(oid*)Tloc(Dstart, D_cur);
      /* poor man's binary search / exploiting forward scan */ 
      while (A_cur+1048576 < A_last && *(oid*)Tloc(Astart, A_cur+1048576) < D_cur_pre)
          A_cur += 1048576; 
      while (A_cur+32768 < A_last && *(oid*)Tloc(Astart, A_cur+32768) < D_cur_pre)
          A_cur += 32768; 
      while (A_cur+1024 < A_last && *(oid*)Tloc(Astart, A_cur+1024) < D_cur_pre)
          A_cur += 1024;  
      while (A_cur+1 < A_last && *(oid*)Tloc(Astart, A_cur+1) < D_cur_pre)
          A_cur++;

      /* write to result */ 
      while (D_cur < D_last && *(oid*)Tloc(Dstart, D_cur) <= (*(oid*)Tloc(Astart, A_cur) + size[*(oid*)BUNhead(Ai, A_cur)])) {
          *hdst++ = *(oid*)BUNhead(Ai, A_cur);
          *tdst++ = *(oid*)BUNhead(Di, D_cur);
          D_cur++;
      }
      /* this ancestor cannot have further results (tree properties) */
      A_cur++;
    
      /* skip descendant candidates before the next ancestor candidate */
      if (A_cur < A_last)
          while(D_cur < D_last && *(oid*)Tloc(Dstart, D_cur) <= *(oid*)Tloc(Astart,A_cur))
              D_cur++; 
    }
    
    /* ----------------------------- tidy up -------------------------------------- */
    BATsetcount(res, hdst - sdst);
    res->batDirty = TRUE;
    if (BAThordered(Astart)&1) res->hsorted = GDK_SORTED;
    else res->hsorted = FALSE;
    if (BAThordered(Dstart)&1) res->tsorted = GDK_SORTED;
    else res->tsorted = FALSE;
    BATset(res, TRUE);
    
    *result = res;    
    return(GDK_SUCCEED);
}

int CMDtreemergejoin_unnested_pre(BAT **result, BAT *Astart, BAT *pre_size, BAT *Dstart) {

    /* ---------------------------- declarations ------------------------------------ */
    char *name = "TJ_treemergejoin_unnested_pre";
    BAT *res = *result;
    BUN D_cur, D_last, 
        A_cur, A_last;
    oid D_cur_pre;
    int *size;
    int free;	
    oid *sdst = NULL, *hdst = NULL, *tdst = NULL;
    
    /* ------------------------------- checks ---------------------------------------- */
    if (!(BAThordered(Astart)&1)) { 
        GDKerror("%s: Ancestor pre BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (!(BAThordered(Dstart)&1)) { 
        GDKerror("%s: Descendant BAT not sorted (on start).\n",name); 
        return(GDK_FAIL);
    }
    if (pre_size->ttype != TYPE_int) {
        GDKerror("%s: tail of size BAT must be type INT.\n", name);
        return(GDK_FAIL);
    }
    if (pre_size->htype != TYPE_void) {
        GDKerror("%s: head (oid) of size BAT must NOT be materialized.\n", name);
        return(GDK_FAIL);
    }
    if (BATcount(Astart) == 0 || BATcount(pre_size) == 0 || BATcount(Dstart) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_oid, 0);
        *result = res;    
        return(GDK_SUCCEED);
    }

    /* ----------------------------- initialize -------------------------------------- */
    // the size of the bat may not be correct (could be more, could be less)
    free = BATcount(Dstart);
    res = BATnew(TYPE_oid, TYPE_oid, free); 
    if (res == NULL) 
    { 
       GDKerror("%s: could not allocate result BAT.\n", name);
       return(GDK_FAIL);
    }
    
    size = ((int*) Tloc(pre_size, BUNfirst(pre_size))) - (int)pre_size->hseqbase;
    D_cur = BUNfirst(Dstart);
    D_last = BUNlast(Dstart);  
    A_cur = BUNfirst(Astart);
    A_last = BUNlast(Astart);
    sdst = hdst = (oid*)Hloc(res, BUNlast(res));
           tdst = (oid*)Tloc(res, BUNlast(res));

    /* -------------------------------- main ---------------------------------------- */
    
    /* skip descendant candidates before the next ancestor candidate */
    while(D_cur < D_last && *(oid*)Hloc(Dstart, D_cur) <= *(oid*)Hloc(Astart,A_cur))
      D_cur++; 
      
    while(D_cur < D_last && A_cur < A_last) {
      
      /* skip ancestor candidates before the next descendant candidate */
      D_cur_pre = *(oid*)Hloc(Dstart, D_cur);
      /* poor man's binary search / exploiting forward scan */ 
      while (A_cur+1048576 < A_last && *(oid*)Hloc(Astart, A_cur+1048576) < D_cur_pre)
          A_cur += 1048576; 
      while (A_cur+32768 < A_last && *(oid*)Hloc(Astart, A_cur+32768) < D_cur_pre)
          A_cur += 32768; 
      while (A_cur+1024 < A_last && *(oid*)Hloc(Astart, A_cur+1024) < D_cur_pre)
          A_cur += 1024;  
      while (A_cur+1 < A_last && *(oid*)Hloc(Astart, A_cur+1) < D_cur_pre)
          A_cur++;

      /* write to result */ 
      while (D_cur < D_last && *(oid*)Hloc(Dstart, D_cur) <= (*(oid*)Hloc(Astart, A_cur) + size[*(oid*)Hloc(Astart, A_cur)])) {
          *hdst++ = *(oid*)Hloc(Astart, A_cur);
          *tdst++ = *(oid*)Hloc(Dstart, D_cur);
          D_cur++;
      }
      /* this ancestor cannot have further results (tree properties) */
      A_cur++;
    
      /* skip descendant candidates before the next ancestor candidate */
      if (A_cur < A_last)
          while(D_cur < D_last && *(oid*)Hloc(Dstart, D_cur) <= *(oid*)Hloc(Astart,A_cur))
              D_cur++; 
    }
    
    /* ----------------------------- tidy up -------------------------------------- */
    BATsetcount(res, hdst - sdst);
    res->batDirty = TRUE;
    res->hsorted = GDK_SORTED;
    res->tsorted = GDK_SORTED;
    BATset(res, TRUE);
    
    *result = res;    
    return(GDK_SUCCEED);
}

bat *
pftijah_prelude(void)
{
    if (!TBL_module_lookup("pathfinder"))
        GDKerror("pathfinder must be loaded first.");
    termdb_prelude();
    return NULL;
}

void
pftijah_epilogue(void)
{
}

@
/* vim:set shiftwidth=4 expandtab: */
