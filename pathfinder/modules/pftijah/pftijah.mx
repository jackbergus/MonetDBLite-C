@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'

@f pftijah
@a Jan Flokstra
@a Henning Rode
@t pftijah

@m
.MODULE pftijah;

.USE pathfinder;

.COMMAND run_tijah_command(str s) : bit = CMDtijah_command;
 "INCOMPLETE"

.COMMAND run_tijah_query(BAT[str,str], str q) : BAT[oid,dbl] = CMDtijah_query;
 "INCOMPLETE"

.COMMAND tj_normalizeTerm(str, str) : str = CMDtj_normalizeTerm;
 "INCOMPLETE"

.COMMAND update_tijah_scores(BAT[void,bat], BAT[oid,bat], BAT[void,oid], BAT[void,int], BAT[oid,dbl]) : BAT[oid,bat] = CMDupdate_tijah_scores;
 "INCOMPLETE"

.COMMAND fill_tijah_scores(BAT[void,bat], BAT[oid,bat], BAT[void,oid], BAT[void,int], BAT[void,dbl]) : void = CMDfill_tijah_scores;
 "INCOMPLETE"

.COMMAND tj_add2collection(BAT[oid,bat],BAT[oid,bat],str,str) : void = CMDtj_add2collection;
 "INCOMPLETE"

.COMMAND tj_add2collection_index(BAT[oid,bat],str) : void = CMDtj_add2collection_index;
 "INCOMPLETE"
 
.COMMAND serialize_tijah_opt(
                      BAT[void,bat] ws,
                      int	    niters,
                      BAT[void,oid] loop,
                      BAT[void,oid] iter,
                      BAT[void,oid] item,
		      BAT[void,int] kind,
                      BAT[void,lng] int_values,
		      BAT[void,dbl] dbl_values,
		      BAT[void,str] str_values)
		       : BAT[str,str] = serialize_pftijah_options_DRIVER;
 "C interface to pftijah option serialize"

.COMMAND offsetindex( BAT[void,oid] offset_tid, int res_size)
		: BAT[void,oid] = CMDoffsetindex;

"PARAMETERS:
BAT[void,oid] - the offset index 
ressize       - the result size, equals number of different tids + 1
DESCRIPITON:
creates an offset index.
"

.COMMAND indexfetchjoin( BAT[any,oid] tid, BAT[void,oid] index, BAT[void, oid] pre)
		: BAT[oid,oid] = CMDindexfetchjoin;
"PARAMETERS:
BAT[any,oid] - bat with tail values which have to be joined (e.g. tid values)
BAT[void,oid] - join index bat with value-offset
BAT[void,oid] - bat with indexed offset and tail values to be returned
DESCRIPITON:
the join algorithm comes down to a repeated slice and insert operation.
"

.PRELUDE = pftijah_prelude;
.EPILOGUE = pftijah_epilogue;

.END pftijah;
@mil
module("pathfinder");

###
# This file contains implementations of some of the SRA operators 
# to run on the TIJAH Light index.
#
# Based on code by the TIJAH team (Vojkan, Thijs)
#
# Additional retrieval models by Henning Rode 
#
# Authors: Roel van Os <roel.van.os@glacimonto.nl>
#          Henning Rode <h.rode@cs.utwente.nl>
#
###

const DEBUG := false;

# Type of the size used
const SIZE_ENTITY := 1;
const SIZE_TERM := 2;

#default
var scoreBase := 0;

const ENTITY_NUM := 10000;

var collName := "PFX";
var collHeight := 10;
var retNum := 100;

if (view_bbp_name().reverse().exist("tj_collName")) {
	if (bat("tj_collName").count() > 0) {
		var name := bat("tj_collName").fetch(0);
		tj_setCollName(name);
	}
}

PROC tj_setCollName(str name) : void := 
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(name))) {
		printf("Error: Selected collection does not exist. Collection name is not changed.\n");
		fflush(stdout());
		quit(); 
	}
	collName := name;
	collHeight := bat("tj_" + collName + "_param").find("height").int();
	if ( DEBUG ) { 
        	printf("Work collection is set to %s (with height %d)\n", collName, collHeight);
        	fflush(stdout());
        } 
}

PROC tj_setScoreBase(int default) : void :=
{
	scoreBase := default;
}

const virtRoot := 0@0;


##
# Compute ancestor-descendant relation.
#
# The arguments anc and desc must contain preorder indices in their heads. 
# The tail values are discarded.
#
# Returns a bat containing [anc,desc] preorder index pairs
##
PROC anc_desc( bat[oid,any] anc, bat[oid,any] desc ) : bat[oid,oid] :=
{
   return anc_desc_llscj(anc,desc);
}

PROC anc_desc_llscj( bat[oid,any] anc, bat[oid,any] desc ) : bat[oid,oid] :=
{
    # Items contains the context nodes for the descendant step: this is the right side argument to contained_by.
    # The table must be [void,oid], so:
    var items := anc.mark(0@0).reverse();
    
    # Candidates contains the right side argument. This must also be [void,oid]:
    var candidates := desc.mark(0@0).reverse();
    
    # Load the pre-size table
    var pre_size := load( "tj_" + collName + "_size");
    
    # Check the order of the items:
    items.chk_order();
    
    # Call the descendant algorithm: it returns [ancestor, descendant] pairs if we pass items as the iteration argument
    var anc_desc := ll_descendant(items, items, pre_size, candidates, collHeight, false, false, min(items), max(items), false);
    
    candidates := nil;
    items := nil;
    pre_size := nil;
    
    return anc_desc;
}


PROC Qterms_to_tid_pre( bat[void,str] Qterms ): bat[oid,oid] :=
{
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var stemmed := [tj_normalizeTerm]( Qterms, stemmer );
    
    var tids    := bat("tj_globalTerms").join( stemmed.reverse() ).mark(oid(0)).reverse().sort();
    
    var result := indexfetchjoin( tids,
                                  bat("tj_" + collName + "_TermIndex"),
                                  bat("tj_" + collName + "_Terms") );
    return result;
}

PROC Qterms_to_void_tid( bat[void,str] Qterms ): bat[void,oid] :=
{
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var stemmed := [tj_normalizeTerm]( Qterms, stemmer );
    
    var tids    := bat("tj_globalTerms").join( stemmed.reverse() ).mark(oid(0)).reverse().sort();
    return tids;
}

################################################################################
# SELECTION
################################################################################

PROC select_root() : bat :=
{
    # Because TIJAH expects all documents in a collection to be contained by one 
    # "virtual root" element, his behaviour should be emulated by the light index. 
    # An element with preorder oid(0) will indicate that it is the collection root.
    var root_reg := new(oid,dbl,1);
    
    root_reg.insert( virtRoot, dbl(scoreBase) );
    return root_reg;
}

PROC select_node(str name) : bat :=
{
    var start_time := time();

    var tids := bat("tj_globalTags").select(name);
    if (tids.count() = 0) return new(oid,dbl);
    var tid := tids.reverse().fetch(0);
    var result := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TagIndex"),
    				  bat("tj_" + collName + "_Tags") );
    result := result.reverse().sort().project(dbl(scoreBase)); 

    var end_time := time();
    if (DEBUG) printf( "select_node: \t\t%d ms\n", end_time - start_time );
    return result;
}

PROC select_node(str name, bit e_class) : bat :=
{
    if ( e_class ) printf( "WARNING: equivalences are not yet supported!\n" );
    return select_node(name);
}

PROC select_term(str name) : bat :=
{
    var start_time := time();
    # 
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var term    := tj_normalizeTerm( name, stemmer );
    
    # Select the term positions from the global term dictionary.
    var tids := bat("tj_globalTerms").select(term).mark(0@0).sort().reverse();
    
    var result := indexfetchjoin( tids,
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    result := result.reverse().sort().project(dbl(scoreBase)); 
    
    var end_time := time();
    if (DEBUG) printf( "select_term: \t\t%d ms\n", end_time - start_time );
    return result;
}

PROC select_term(str name, int stemming) : bat := 
{
    return select_term( name );
}

PROC select_phrase(bat[void,oid] terms) : bat[oid,dbl] :=
{
    var start_time := time();
    # Select the term positions from the global term dictionary. 
   
    var tid := terms.fetch(0);
    var tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    var res := tmp.reverse();
    var j := terms.count();
    var i := 1; 
    while (i < j)
    {
        tid := terms.fetch(i);
        tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
        res := res.semijoin(tmp.[int]().[-](i).[oid]().reverse());   
	i :+= 1;
    }	
    
    res := res.sort().project(dbl(scoreBase)); 
    
    var end_time := time();
    if (DEBUG) printf( "select_phrase: \t\t%d ms\n", end_time - start_time );
    return res;
}


################################################################################
# CONTAINMENT
################################################################################


#####################################
# left CONTAINED_BY right:
#
#   +--------------------+
#   |       right        |
#   | +---------------+  |
#   | |      left     |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it is contained a region in right
#
#####################################
PROC contained_by(bat left, bat right) : bat :=
{
    var start_time := time();
    
    # Check for the virtual root
    if ( and((count( left ) = 1),(left.reverse().fetch(0) = virtRoot))) 
            return new(oid,dbl);
    if ( and((count( right ) = 1),(right.reverse().fetch(0) = virtRoot))) 
            return left;
    
    var anc_desc := anc_desc( right, left );
    
    # Attach the scores to the resulting nodes again:
    var result := anc_desc.reverse().mirror().join(left);
    
    var end_time := time();
    if (DEBUG) printf( "contained_by: \t\t%d ms\n", end_time - start_time );
    return result;
}


#####################################
# left CONTAINING right:
#
#   +--------------------+
#   |       left         |
#   | +---------------+  |
#   | |      right    |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it contains a region in right
#
#####################################
PROC containing(bat left, bat right) : bat :=
{
    var start_time := time();
    
    # Check for the virtual root
    if ( and((count( left ) = 1),(left.reverse().fetch(0) = virtRoot))) 
            return right;
    if ( and((count( right ) = 1),(right.reverse().fetch(0) = virtRoot))) 
            return new(oid,dbl);
    
    var anc_desc := anc_desc( left, right );

    # Attach the scores to the resulting nodes again:
    var result := anc_desc.mirror().kunique().join(left);
    
    var end_time := time();
    if (DEBUG) printf( "containing: \t\t%d ms\n", end_time - start_time );
    return result;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

PROC p_containing_q_NLLR_batloop_anc(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
     var terms := Qterms_to_void_tid( Qterms );
     var t1 := time();
     var tind := bat("tj_" + collName + "_TermIndex");
     var pres := bat("tj_" + collName + "_Terms");
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := pres.count();
     _lmbd :*= collFrq; 

     var t2 := time();
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var t5 := time();
	  var oid_min := int(tind.fetch($t));
	  var oid_max := int(tind.fetch(int($t) + 1)) - 1;
	  var tid_pre := pres.slice(oid_min, oid_max);
          var cands := tid_pre.reverse().sort().mark(0@0);
	  var fac := tid_pre.count();
	  tid_pre := nil;
	  if (fac > 0)
	  {
	       fac := _lmbd / fac;
               var elems := scj_anc(bat("tj_" + collName + "_size"), cands, collHeight, cands.count() * 4); 
	       var t6 := time();
	       elems := left.semijoin(elems);
               cands := cands.reverse();
               var elem_frq := bat("tj_" + collName + "_size").semijoin(elems);
               elems := elems.mark(0@0).reverse();
               var iter := elems.mirror();
               #printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size").count());
	       #fflush(stdout());
	       var elem_termpre := ll_descendant(iter, 
     						 elems, 
						 bat("tj_" + collName + "_size"), 
						 cands, 
						 collHeight, 
						 false, false, min(iter), max(iter), false);
               var t7 := time();
	       cands := nil;
	       iter := nil;
     	       elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
	       var tmp := elem_termpre.reverse().histogram();
               elem_termpre := nil;
	       tmp := [dbl](tmp);
	       tmp := [/](tmp, elem_frq);
	       tmp := [*](tmp, fac);
	       tmp := [+](tmp, 1);
	       tmp := [log](tmp);
	       var t8 := time();
	       doc_prob.insert(tmp);
	       var t9 := time();
         if (DEBUG) {
            printf("inside loop: ll_desc (%d), insert (%d), total (%d)\n", t7 - t6, t9 - t8, t9 - t5);
            fflush(stdout());
         }
	       
          }
     }
     var t3 := time();
     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), left.mark(0@0));
     res := res.[/](terms.count()).[+](left);
     var t4 := time();
     
     if (DEBUG) {
        printf("p_containing_q: loop (%d), total (%d)\n", t3 - t2, t4 - t1);
        fflush(stdout());
     }
     return res;
}

PROC p_containing_q_NLLR_batloop(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
     var terms := Qterms_to_void_tid( Qterms );
     var t1 := time();
     var tind := bat("tj_" + collName + "_TermIndex");
     var pres := bat("tj_" + collName + "_Terms");
     var elem_frq := bat("tj_" + collName + "_size").semijoin(left);
     var elems := left.mark(0@0).reverse();
     var iter := elems.mirror();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := pres.count();
     _lmbd :*= collFrq; 

     var t2 := time();
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var t5 := time();
	  var oid_min := int(tind.fetch($t));
	  var oid_max := int(tind.fetch(int($t) + 1)) - 1;
	  var tid_pre := pres.slice(oid_min, oid_max);
          var cands := tid_pre.reverse().sort().mark(0@0).reverse();
	  var fac := tid_pre.count();
	  if (fac > 0)
	  {
	       fac := _lmbd / fac;
	       var t6 := time();
               if (DEBUG) {
                    printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size").count());
                    fflush(stdout());
               }
	       var elem_termpre := ll_descendant(iter, 
     						 elems, 
						 bat("tj_" + collName + "_size"), 
						 cands, 
						 collHeight, 
						 false, false, min(iter), max(iter), false);
               var t7 := time();
	       cands := nil;
	       iter := nil;
	       tid_pre := nil;
     	       elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
	       var tmp := elem_termpre.reverse().histogram();
               elem_termpre := nil;
	       tmp := [dbl](tmp);
	       tmp := [/](tmp, elem_frq);
	       tmp := [*](tmp, fac);
	       tmp := [+](tmp, 1);
	       tmp := [log](tmp);
	       var t8 := time();
	       doc_prob.insert(tmp);
	       var t9 := time();
           if (DEBUG) {
               printf("inside loop: ll_desc (%d), insert (%d), total (%d)\n", t7 - t6, t9 - t8, t9 - t5);
               fflush(stdout());
	       }
          }
     }
     var t3 := time();
     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), elems.reverse());
     res := res.[/](terms.count()).[+](left);
     var t4 := time();
     
     if (DEBUG) {
        printf("p_containing_q: loop (%d), total (%d)\n", t3 - t2, t4 - t1);
        fflush(stdout());
     }
     return res;
}

PROC p_containing_q_NLLR_batloop_aggregation(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
     var terms := Qterms_to_void_tid( Qterms );
     var t1 := time();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := bat("tj_" + collName + "_Terms").count();
     _lmbd :*= collFrq; 
     var t2 := time();
     terms := terms.tsort().tmark(0@0);
     if (terms.count() = 0) return left;
     var tid_pre := indexfetchjoin(terms, bat("tj_" + collName + "_TermIndex"), bat("tj_" + collName + "_Terms") );
     var t3 := time();

     var elems := left;

     var tid_frq := histogram(tid_pre.reverse());
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;
     var elem_frq := bat("tj_" + collName + "_size").semijoin(elems);
     elems := elems.mark(0@0).reverse();
     var cands := tid_pre.reverse().sort().mark(0@0).reverse();
     var iter := elems.mirror();
     if (DEBUG){ 
        printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size").count());
	    fflush(stdout());
     }
     var t4 := time();
     var elem_termpre := ll_descendant(	iter, 
     					elems, 
					bat("tj_" + collName + "_size"), 
					cands, 
					collHeight, 
					false, false, min(iter), max(iter), false);
     var t5 := time();
     elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
     var elem_tid := elem_termpre.join(tid_pre.reverse());
     tid_pre := nil;
     elem_termpre := nil;
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var tmp := elem_tid.select($t);
	  var fac := _lmbd / tmp.count();
	  tmp := tmp.reverse().histogram();
	  tmp := [dbl](tmp);
	  tmp := [/](tmp, elem_frq);
	  tmp := [*](tmp, fac);
	  tmp := [+](tmp, 1);
	  tmp := [log](tmp);
	  doc_prob.insert(tmp);
     }

     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), elems.reverse());
     var fac := dbl(1.0) / dbl(terms.count());
     res := res.[*](fac).[+](left);
     
     var t6 := time();
    
     if (DEBUG) {
        printf("p_containing_q: indexfetchjoin (%d), ll_descendant (%d), total (%d)\n", t3 - t2, t5 - t4, t6 - t1);
        fflush(stdout());
     }
     return res;
}

PROC p_containing_q_NLLR_batloop_aggregation_anc(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
     var terms := Qterms_to_void_tid( Qterms );
     var t1 := time();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := bat("tj_" + collName + "_Terms").count();
     _lmbd :*= collFrq; 
     var t2 := time();
     terms := terms.tsort().tmark(0@0);
     if (terms.count() = 0) return left;
     var tid_pre := indexfetchjoin(terms, bat("tj_" + collName + "_TermIndex"), bat("tj_" + collName + "_Terms") );
     var t3 := time();

     var cands := tid_pre.reverse().sort().mark(0@0);
#     printf("scj_anc: #items: %d, #pre_size: %d, upperbound %d\n", cands.count(), bat("tj_" + collName + "_size").count(), cands.count() * 4);
#	       fflush(stdout());
     var t7 := time();
     var elems := scj_anc(bat("tj_" + collName + "_size"), cands, collHeight, cands.count() * 4); 
     var t8 := time();
     elems := left.semijoin(elems);
     cands := cands.reverse();

     var tid_frq := histogram(tid_pre.reverse());
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;
     var elem_frq := bat("tj_" + collName + "_size").semijoin(elems);
     elems := elems.mark(0@0).reverse();
     var iter := elems.mirror();
     if (DEBUG) {
        printf("ll_desc: #loops/items: %d, #cands: %d, #pre_size: %d\n", elems.count(), cands.count(), bat("tj_" + collName + "_size").count());
        fflush(stdout());
     }
     var t4 := time();
     var elem_termpre := ll_descendant(	iter, 
     					elems, 
					bat("tj_" + collName + "_size"), 
					cands, 
					collHeight, 
					false, false, min(iter), max(iter), true);
     var t5 := time();
     elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
     var elem_tid := elem_termpre.join(tid_pre.reverse());
     tid_pre := nil;
     elem_termpre := nil;
     
     var doc_prob := new(oid,dbl);
     terms@batloop()
     {
	  var tmp := elem_tid.select($t);
	  var fac := _lmbd / tmp.count();
	  tmp := tmp.reverse().histogram();
	  tmp := [dbl](tmp);
	  tmp := [/](tmp, elem_frq);
	  tmp := [*](tmp, fac);
	  tmp := [+](tmp, 1);
	  tmp := [log](tmp);
	  doc_prob.insert(tmp);
     }

     var res := {sum}(doc_prob.reverse().mark(0@0).reverse(), doc_prob.mark(0@0).reverse(), elems.reverse());
     res := res.[/](terms.count()).[+](left);
     
     var t6 := time();
    
     if (DEBUG) {
        printf("p_containing_q: indexfetchjoin (%d), scj_anc (%d), ll_descendant (%d), total (%d)\n", t3 - t2, t8 - t7, t5 - t4, t6 - t1);
        fflush(stdout());
     }
     return res;
}

PROC p_containing_q_NLLR(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd) : bat[oid,dbl] :=
{
     var terms := Qterms_to_void_tid( Qterms );
     var t1 := time();
     var _lmbd := (1.0 - lmbd) / lmbd;
     var collFrq := bat("tj_" + collName + "_Terms").count();
     _lmbd :*= collFrq; 
     var t2 := time();
     terms := terms.tsort().tmark(0@0);
     if (terms.count() = 0) return left;
     var tid_pre := indexfetchjoin(terms, bat("tj_" + collName + "_TermIndex"), bat("tj_" + collName + "_Terms") );
     var t3 := time();
     var tid_frq := histogram(tid_pre.reverse());
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;
     var elem_frq := bat("tj_" + collName + "_size").semijoin(left);
     var elems := left.mark(0@0).reverse().chk_order();
     var t4 := time();
     var elem_termpre := ll_descendant(	elems, 
     					elems, 
					bat("tj_" + collName + "_size"), 
					tid_pre.reverse().sort().mark(0@0).reverse(), 
					collHeight, 
					false, false, min(elems), max(elems), false);
     var t5 := time();
     var elem_tid := elem_termpre.join(tid_pre.reverse());
     tid_pre := nil;
     elem_termpre := nil; 
     var dtf_elem := elem_tid.mark(0@0).reverse();
     var dtf_tid := elem_tid.reverse().mark(0@0).reverse();
     elem_tid := nil;
     var tmp :=  CTderive(dtf_elem, dtf_tid);
     var dtf_frq := CThistogram(tmp).[dbl]();
     tmp := nil;
     dtf_frq := [/](dtf_frq, dtf_elem.join(elem_frq));
     elem_frq := nil;
     dtf_frq := [*](dtf_frq, dtf_tid.join(_tid_frq));
     _tid_frq := nil;
     dtf_frq := [+](dtf_frq, 1);
     dtf_frq := [log](dtf_frq);
     var res := {sum}(dtf_frq, dtf_elem, elems.reverse());
     res := res.[/](terms.count()).[+](left);
     var t6 := time();
    
     if (DEBUG) {
        printf("p_containing_q: indexfetchjoin (%d), ll_descendant (%d), total (%d)\n", t3 - t2, t5 - t4, t6 - t1);
        fflush(stdout());
     }
     return res;
}

PROC p_containing_t_LMs(bat left, bat right, flt lmbd, int size_type) : bat := 
{
    var start_time := time();
    var lambda;
    var m_lambda;
    var forgnd_prob := new(oid,dbl,ENTITY_NUM);
    var bckgnd_prob;

    var res_reg := new(oid,dbl,ENTITY_NUM);

    # Compute the foreground probability: how many regions from right does left contain?
    # This count is divided by the region size by reg_freq
    
    forgnd_prob := reg_freq(left,right,size_type);

    if (size_type = SIZE_ENTITY) {
        # Compute right size / collection entity size
        
        var pre_pfpre := bat("tj_" + collName + "_pfpre");
        bckgnd_prob := dbl(count(right))/dbl(count(pre_pfpre));

        pre_pfpre := nil;
    }

    else if (size_type = SIZE_TERM) {
        # Compute right size / collection term size
        
        var pre_tid  := bat("tj_" + collName + "_tid");
        var pre_pfpre := bat("tj_" + collName + "_pfpre");
        var terms := pre_tid.mirror().kdiff( pre_pfpre.mirror() );

        bckgnd_prob := dbl(count(right))/dbl(count(terms));
        
        var pre_tid := nil;
        var pre_pfpre := nil;
        var terms := nil;
    }

    if (bckgnd_prob = dbl(0)) {
        if (DEBUG) printf( "Minimum collection frequency has not been computed yet!\n" );
        # Assign minimum collection frequency
        
        bckgnd_prob := min(col_freq());
    }

    # Precompute lambda values
    lambda := dbl(lmbd);
    m_lambda := dbl(1)-lambda;

    if (scoreBase = 0)
        res_reg := [+](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));
    else if (scoreBase = 1)
        res_reg := [*](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));
    
    
    var end_time := time();
    if (DEBUG) printf( "p_containing_t_LMs: \t%d ms\n", end_time - start_time );
    return res_reg;
}

# Returns the collection frequency table (should be precomputed, but is calculated for now)
PROC col_freq() : bat :=
{
    var start_time := time();
    var allterms := bat("tj_globalTerms").sort().mark(0@0).reverse();
    var alltermpos := indexfetchjoin(allterms, bat("tj_"+collName+"_TermIndex"), bat("tj_"+collName+"_Terms"));
    var col_freqs := [dbl]({count}(alltermpos));

    if (DEBUG) printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return col_freqs;
}


# Returns the collection frequency of the term with the indicated tid
PROC col_freq(oid tid) : dbl :=
{
    var start_time := time();
    var alltermpos := indexfetchjoin(new(int,oid).insert(0,tid), bat("tj_"+collName+"_TermIndex"), bat("tj_"+collName+"_Terms"));
    var col_freqs := {count}(alltermpos);
    var result := dbl(col_freqs.fetch(0));
    if (DEBUG) printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return result;
}

# For each region in left, count the number of regions in right it contains.
PROC reg_freq(bat left, bat right, int size_type) : bat    :=    
{
    var start_time := time();
    
    var reg_size;
    
    var ctx_tmp2 := new( oid, int, ENTITY_NUM );
   
    ctx_tmp2 := anc_desc( left, right );
    
    # Containment count: for each region from left, count how many regions from right it contains
    var num_terms := {count}(ctx_tmp2);
    var prob_tmp  := [dbl](num_terms);
    
    # Region size: Determine the entity or term size of all regions from left that have descendants in right
    if (size_type = SIZE_ENTITY)
        reg_size := size_entity(prob_tmp);
    else if (size_type = SIZE_TERM)
        reg_size := size_term(prob_tmp);
    
    # prob_tmp := [/](prob_tmp,prob_tmp.mirror().join(reg_size));

    # Divide the containment count (left) by the region size (left)
    prob_tmp := [/](prob_tmp,reg_size);

    # Set all to zero regions from left that do not contain regions from right
	prob_tmp := prob_tmp.kunion( left.project(dbl(0)) );

    var end_time := time();
    if (DEBUG) printf( "reg_freq: \t\t%d ms\n", end_time - start_time );
    return prob_tmp;
}


# Calculate the term size of the region: how many terms does it contain?
PROC size_term( bat region ) : bat := 
{
    # For now, we use size_term = size_entity
    return size_entity( region );
    var start_time := time();
    
    # all terms:
    var pre_tid   := bat("tj_" + collName + "_tid");
    var pre_pfpre := bat("tj_" + collName + "_pfpre");
    var terms     := pre_tid.mirror().kdiff( pre_pfpre.mirror() );
    
    var items      := region.mirror().mark(0@0).reverse();
    var candidates := terms.mirror().mark(0@0).reverse();
    
    # Alternative:
    #var candidates      := bat("tj_" + collName + "_Terms" ).reverse().sort().mark(0@0).reverse();
    
    var pre_size := load( "tj_" + collName + "_size");
   
    # Check the order of the items:
    items.chk_order();
    
    var res := ll_descendant(items, items, pre_size, candidates, collHeight, false, false, min(items), max(items), false);
    
    var result := [dbl]({count}(res));
   
    var end_time := time();
    if (DEBUG) printf( "size_term: \t\t%d ms\n", end_time - start_time );
    return result;
}

# Calculate the entity size of the region: how many entities (tags and terms) does it contain?
PROC size_entity( bat region ) : bat :=
{
    var start_time := time();
    
    
    # Entity sizes:
    var pre_size := load( "tj_" + collName + "_size");
    
    var result := region.mirror().join( pre_size );

    var end_time := time();
    if (DEBUG) printf( "size_entity: \t\t%d ms\n", end_time - start_time );
    return result;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################


PROC p_contained_by_sum(bat left, bat right) : bat := 
{

    var ctx_res := anc_desc( right, left );
    
    var reg_score;
    var res_reg;
	var ctx := left.project(dbl(0));

    # calculating the score for each region
    reg_score := {sum}(ctx_res.reverse().join(right));
    reg_score := kunion(reg_score, ctx);

	if (scoreBase = 0)
		res_reg := [+](left, reg_score);
	else if (scoreBase = 1)
		res_reg := [*](left, reg_score);

	return res_reg;

}


PROC p_containing_wsumd(bat left, bat right, int size_type) : bat :=
{
    var ctx := left.project(dbl(0));
    var size_reg;
    var reg_score;
    var norm_reg;
    var res_reg;
    
    if (size_type = SIZE_ENTITY) {
        size_reg := size_entity(right);
    }
    else if (size_type = SIZE_TERM) {
        size_reg := size_term(right);
    }

    # Call the descendant algorithm: it returns [ancestor, descendant] pairs!
    var ctx_res := anc_desc( left, right );

    # calculating the score for each region
    reg_score := {sum}(ctx_res.join([*](size_reg,right)).sort());
    norm_reg := [dbl]({sum}(ctx_res.join(size_reg).sort()));

    # Select all values > 0
    norm_reg := norm_reg.select(dbl(0),dbl(nil),false,true);

    reg_score := norm_reg.mirror().join(reg_score);

    reg_score := [/](reg_score,norm_reg);

    reg_score := kunion(reg_score,ctx);

    if (scoreBase = 0)
        res_reg := [+](left, reg_score);
    else if (scoreBase = 1)
        res_reg := [*](left, reg_score);

    return res_reg;
}

#################################################################################
# SET BASED PROBABILISTIC TERM CONTAINING
#################################################################################


#proc p_containing_q(bat ctx, bat Qterms, bat modifiers, int stemming, int size_type) : bat {   
#    return p_containing_q(ctx, Qterms,modifiers, flt(1.0), stemming, size_type);
#}

proc p_containing_q_LMs(bat ctx, bat Qterms, bat modifiers, flt lambda, int stemming, int size_type) : bat {   
    var Qpositions := Qterms_to_tid_pre(Qterms).reverse().sort().project(dbl(scoreBase));
    
    var context := ctx.sort();
    
    var termscores := p_containing_t_LMs(context, Qpositions, lambda, size_type);
   
    return termscores;
}

# Smarter LM implementation that needs only a single treemergejoin per query
# Arguments: 
#   ctx: context regions
#   Qterms: query terms ([void,oid])
#
# Original code by: Thijs?
#
# The original code used [void,str] for Qterms. 
# Our code stems the query terms before calling this function (is this what we want?)
proc p_containing_q_LM_fast(bat ctx, bat Qterms, bat modifiers, flt lambda, int stemming, int size_type) : bat {   
    # TODO: add real weighting to avoid recomputation for duplicate query terms, 
    # or for morphological variants when stemming (can also be used to implement the modifiers)
    
	var QoidWeights := Qterms.project(dbl(1)); 
    
    #: var enum_word := load(col_name+"enum_word");
	#: if (stemming = STEM_OFF) {
    #: Qoids := Qterms.join(enum_word);
    #: 	    }
    #: else if (stemming = STEM_ON) {
    #: var word_stem := load(col_name+"word_stem");
    #: var Qstems := Qterms.join(word_stem.reverse());
    #: Qoids := Qstems.join(word_stem).join(enum_word);
    #: word_stem:=nil;
    #:     }

    #: enum_word := nil;
    if ( Qterms.count() = 0) {
	    #: return ctx.[*](min(bat(col_name+"col_freq")));
        return ctx.[*](min(col_freq()));
    }
    #: else
    #: {
    #: var word_name := load(col_name+"word_name");

	#: var Qpositions:=[uselect](const word_name,Qoids.reverse().mirror()).[sort]().[project](Qoids.reverse()).[reverse]();
    #: word_name := nil;
    
    var Qoid_pre := Qterms_to_tid_pre( Qterms );
    var pre_Qoid := Qoid_pre.reverse().sort();
  
	#: var allpositions:=new(oid,oid);
	#: [insert](const allpositions,Qpositions);
    #: allpositions.reverse().sort();

    #: var word_pre := load(col_name+"word_pre");
    #: var pre_Qoid := allpositions.join(word_pre).reverse().sort();

    #: var entity_pre := load(col_name+"entity_pre");  
    #: var entity_post := load(col_name+"entity_post");
	#: var ctx_oid :=ctx.sort().mark(oid(0)).reverse();
    #: var ctx_score := ctx.reverse().mark(oid(0)).reverse();
	#: var ctx_pre := ctx_oid.join(entity_pre);
    #: var ctx_post := ctx_oid.join(entity_post);
    #: entity_post:=nil;
    

	#: var res := treemergejoin_sort(ctx_pre,ctx_post,pre_Qoid.hmark(oid(0)),1);
    
    var res := anc_desc( ctx, pre_Qoid );

    # res    : [anc_pre, desc_pre]
    
    
	var res_ctx := res.hmark(oid(0));
    # res_ctx: [void, anc_pre]
    
    # res: [anc_pre, desc_pre]
    # res.tmark(oid(0)): [void,desc_pre]
    # pre_Qoid: [desc_pre, tid]
    # pre_Qoid.tmark(oid(0)): [void, tid]
    
	#: var res_Qoid := res.tmark(oid(0)).join(pre_Qoid.tmark(oid(0)));
    
    var res_Qoid := res.tmark(oid(0)).join(pre_Qoid.tmark(oid(0)));
	var termcounts := res_Qoid.CTgroup(res_ctx).CThistogram();
    
    #:var termcounts := {count}res;
    
    var ctx_size;

	if (size_type = SIZE_ENTITY)
        ctx_size:=res_oid.reverse().kunique().mirror().sort().size_entity();
	else if (size_type = SIZE_TERM)
		ctx_size :=ctx_oid.join(BAT(col_name+"entity_text_size"));

    var termprobs:=termcounts.[dbl]().[/](res_ctx.join(ctx_size).[dbl]());

	termprobs:=termprobs.[*](lambda);
	var prob;	

	if (lambda<1.0)
	{
        var BG;
        if (size_type = SIZE_ENTITY) {
            var col_root := load(col_name+"col_root");
            BG := pre_Qoid.reverse().{count}().[/](size_entity(entity_pre.join(col_root)).find(oid(0)));
        }  

        else if (size_type = SIZE_TERM) {

            BG := pre_Qoid.reverse().{count}().[/](dbl(count(word_pre)));
        }

        word_pre := nil;
        entity_pre := nil;

        BG:= BG.[*](1-lambda);
     
        var BGprobs := res_Qoid.join(BG);

        # This is the presence weighting scheme 
        # (cf. for example Eq. 3.22 in thesis Thijs)
        prob := termprobs.[/](BGprobs).[+](1); 	
        

        # Apply query term weights 
        # normalisation for number query terms not needed (does not influence ranking)

        prob:= prob.[dbl]().[pow](join(res_Qoid,QoidWeights));

        # convert to (ctx_ind,prob)
        prob := res_ctx.reverse().join(prob);
        
        # aggregate over query terms (joint probability)
        prob := prob.{prod}().sort(); # only scores for matchin nodes
        
        # non matching-score
        var NMS := BG.[pow](QoidWeights).prod();
        prob:=prob.[*](NMS); # multiply matching w. NMS (cv. presence weighting scheme)
        # non matching elements get NMS only;
        prob:=ctx_oid.project(NMS).access(BAT_WRITE).inplace(prob).access(BAT_READ);
	}
	else
	{

        # lambda = 1 -> do not use presence weighting to avoid division by zero; 
        # compute without rewriting (cf. eq. 3.20 and 3.21 in Thijs' thesis)
        prob := termprobs;

        # Apply query term weights 
        # normalisation for number query terms not needed (does not influence ranking)

        prob:= prob.[dbl]().[pow](join(res_Qoid,QoidWeights).[dbl]());

        # convert to (entity_oid,prob)
        prob := res_ctx.reverse().join(prob);
	
        # aggregate over query terms (joint probability)
        prob := prob.{prod}().sort(); # only scores for matchin nodes
	

        # add non-matching elements
        prob := ctx_oid.project(dbl(0)).access(BAT_WRITE).inplace(prob).access(BAT_READ);
    }

	if (scoreBase = 0)
		prob := [+](ctx_score,prob);
	else if (scoreBase = 1)
		prob := [*](ctx_score,prob);

	prob := ctx_oid.reverse().join(prob);

	return prob; 
    #: }
}

# The following functions have been copied without change from algebra_procs.mil


################################################################################
# SET OPERATORS
################################################################################

### UNION
PROC union(bat left, bat right) : bat :=
{

	return left.kunion(right);

}

### INTERSECTION
PROC intersect(bat left, bat right) : bat := 
{

	return left.kintersect(right);

}


################################################################################
# SCALING
################################################################################

PROC scale(bat region, flt importance) : bat := 
{

	var res_reg := new(oid,dbl,ENTITY_NUM);
	res_reg := [*](dbl(importance),region);
	return res_reg;

}


################################################################################
# PROBABILISTIC SET OPERATORS
################################################################################

PROC or_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC or_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC or_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

PROC or_exp(bat left, bat right, int A) : bat := 
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC or_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC or_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC and_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC and_exp(bat left, bat right, int A) : bat :=
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC and_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC and_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

################################################################################
# PRIOR
################################################################################

PROC prior_ls(bat region, int size_type) : bat := 
{

	var ctx_size := new(oid,dbl,ENTITY_NUM);
	var res_reg := new(oid,dbl,ENTITY_NUM);

	if (size_type = SIZE_ENTITY)
		ctx_size := size_entity(region);
	else if (size_type = SIZE_TERM)
		ctx_size := size_term(region);

	res_reg := [+]([log](region.select(dbl(0),dbl(nil),false,false)),[log](ctx_size));
	res_reg := [-](region.select(dbl(0)).project(min(res_reg)),dbl(1)).kunion(res_reg);

	# res_reg := [+]([log](region),[*](dbl(3.0),[log](ctx_size)));

	# var ref_reg := new(oid,dbl,ENTITY_NUM);
	# var ref_size := new(oid,dbl,ENTITY_NUM);

	# var entity_name := load(collName+"entity_name");

	# var ref_name := entity_name.join(region.mirror().join(entity_name).reverse().mirror());
	# ref_reg := ref_name.project(dbl(1));

	# if (size_type = SIZE_ENTITY) {
	#	ctx_size := size_entity(region);
	#	ref_size := size_entity(ref_reg);
	# }
	# else if (size_type = SIZE_TERM) {
	#	ctx_size := size_term(region);
	#	ref_size := size_term(ref_reg);
	# }

	# ref_size := region.mirror().join(entity_name).join({sum}(ref_size.reverse().join(ref_name).reverse()));

	# res_reg := [*](region,[/](ctx_size,ref_size));

	return res_reg;

}
#ADDHELP("prior_ls", "vojkan", "March 16, 2005",
#"Adds element prior based on element length to the region score.",
#"TIJAH");



################################################################################
# ORDER
################################################################################

PROC order_regions(bat region) : bat :=
{

	region := region.reverse().sort_rev().reverse();

	return region;

}
#ADDHELP("order_regions", "vojkan", "March 29, 2005",
#"Order regions in descending order based on their score values.",
#"TIJAH");



PROC tj_global_init() : void 
{
	if (DEBUG) printf("# Initializing Pathfinder-Tijah integration package.\n");
	new(oid,str).persists(true).bbpname("tj_globalTerms");
	new(oid,str).persists(true).bbpname("tj_globalTags");
	new(oid,str).persists(true).bbpname("tj_collName");
	commit();
}

##########################################
# Collection Management Functions
#
##########################################

PROC tj_coll_init(str collName, str stemmer) : void
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}

	new(void,str).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_name");
	new(void,int).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_firstpre");
	new(str,str).persists(true).bbpname("tj_" + collName + "_param");

	new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_tid");
	new(void,int).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_size"); # incomplete, should be void/int
	new( oid,oid).persists(true).bbpname("tj_" + collName + "_pfpre");
	
	var coll_oid;
	if (bat("tj_collName").count() = 0) { coll_oid := 0@0; }
     	else { coll_oid := oid(int(bat("tj_collName").reverse().max()) + 1); }
	bat("tj_collName").insert(coll_oid, collName);
	#
	# now set the parameters for this collection
	#
	bat("tj_" + collName + "_param").insert("name",collName);
	bat("tj_" + collName + "_param").insert("height","0");
	if (stemmer = "") bat("tj_" + collName + "_param").insert("stemmer","nostemming");
	else bat("tj_" + collName + "_param").insert("stemmer",stemmer);
	bat("tj_" + collName + "_param").insert("preExpansion","4");
	bat("tj_" + collName + "_param").insert("status","building");
	#
	commit();
}

PROC tj_global_remove() : void
{
	bat("tj_collName")@batloop(){
		tj_coll_remove($t);
	}
	bat("tj_globalTerms").persists(false);
	bat("tj_globalTags").persists(false);
	bat("tj_collName").persists(false);
	commit();
}

PROC tj_coll_remove() : void
{
	tj_coll_remove(collName);
}

PROC tj_coll_remove(str collName) : void
{
	bat("tj_" + collName + "_doc_name").persists(false);
	bat("tj_" + collName + "_doc_firstpre").persists(false);
	bat("tj_" + collName + "_param").persists(false);
	bat("tj_" + collName + "_tid").persists(false);
	bat("tj_" + collName + "_size").persists(false);
	bat("tj_" + collName + "_pfpre").persists(false);
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) {
		bat("tj_" + collName + "_TermIndex").persists(false);
		bat("tj_" + collName + "_Terms").persists(false);
		bat("tj_" + collName + "_TagIndex").persists(false);
		bat("tj_" + collName + "_Tags").persists(false);
	}
        
	var coll_oid := bat("tj_collName").reverse().find(collName);
	bat("tj_collName").delete(coll_oid);
	commit();
}

PROC tj_collection() : BAT[void,bat]
{
	return tj_collection(collName);
}

PROC tj_collection(str collName) : BAT[void,bat]
{
	var tjCollBat := new(void,bat).seqbase(0@0);

	tjCollBat.append(bat("tj_globalTerms"));
	tjCollBat.append(bat("tj_globalTags"));
	tjCollBat.append(bat("tj_" + collName + "_doc_name"));
	tjCollBat.append(bat("tj_" + collName + "_doc_firstpre"));
	tjCollBat.append(bat("tj_" + collName + "_param"));
	tjCollBat.append(bat("tj_" + collName + "_tid"));
	tjCollBat.append(bat("tj_" + collName + "_size"));
	tjCollBat.append(bat("tj_" + collName + "_pfpre"));
	return tjCollBat;
}

PROC tj_createCollection(str doc, str url, str stemmer) : BAT[void,bat]
{
	return tj_createCollection(collName, doc, url, stemmer);
}

PROC tj_createCollection(str collName, str doc, str url, str stemmer) : void
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(collName))) {
		tj_coll_init(stemmer);
	}
	
	tj_url2Collection(collName, doc, url, "");
	tj_finalize(collName);
}

PROC tj_url2Collection(str doc, str url, str selTagList) : void
{
	tj_url2Collection(collName, doc, url, selTagList);
}

PROC tj_url2Collection(str collName, str doc, str url, str selTagList) : void
{
	var ws := create_ws();
	if (not(bat("doc_name").reverse().exist(doc))) {
		shred_doc(url,doc);
	}
	add_doc(ws,doc);
        
	bat("tj_globalTerms").access(BAT_WRITE);
	bat("tj_globalTags").access(BAT_WRITE);
        
	tj_add2collection(tj_collection(collName),ws,doc,selTagList);
	destroy_ws(ws);
	var height1 := bat("doc_height").fetch(bat("doc_name").reverse().find(doc));
        
        var coll_oid := bat("tj_collName").reverse().find(collName);
	var height2 := bat("tj_" + collName + "_param").find("height").int();
	bat("tj_" + collName + "_param").replace("height", max(height1,height2).str());
	bat("tj_" + collName + "_param").replace("status","building");
        commit();	
}

PROC tj_url2Collection_index(str collName, str url, str selTagList) : void
{
	bat("tj_globalTerms").access(BAT_WRITE);
	bat("tj_globalTags").access(BAT_WRITE);
        
	tj_add2collection_index(tj_collection(collName),url);

	bat("tj_" + collName + "_param").replace("status","building");
        commit();	
}

PROC tj_finalize() : void
{
	tj_finalize(collName);
}

PROC tj_finalize(str collName) : void
{
	# Finalize one collection. No documents should be added after this
	tj_buildIRindex(collName);
	#
	bat("tj_" + collName + "_param").replace("status","finalized");
	#
	var gterm_sort := bat("tj_globalTerms").reverse().sort().reverse();
	bat("tj_globalTerms").persists(false);
	var gtag_sort := bat("tj_globalTags").reverse().sort().reverse();
	bat("tj_globalTags").persists(false);
	commit();
	gterm_sort.persists(true);
	gterm_sort.bbpname("tj_globalTerms");
	gtag_sort.persists(true);
	gtag_sort.bbpname("tj_globalTags");
	bat("tj_globalTerms").access(BAT_READ);
	bat("tj_globalTags").access(BAT_READ);
        
	commit(); 
}

PROC tj_dump() : void
{
	tj_dump(collName);
}

PROC tj_dump(str collName) : void
{
	bat("tj_" + collName + "_param").print();
	bat("tj_" + collName + "_doc_name").print();
	bat("tj_" + collName + "_doc_firstpre").print();
	# print(bat("tj_" + collName + "_doc_name"),bat("tj_" + collName + "_doc_firstpre"));
	bat("tj_globalTerms").print();
	bat("tj_globalTags").print();
	print(bat("tj_" + collName + "_tid"));
	print(bat("tj_" + collName + "_size"));
	print(bat("tj_" + collName + "_pfpre"));
	# print(bat("tj_" + collName + "_tid"),join(bat("tj_" + collName + "_tid"),bat("tj_globalTerms")));
	# print(bat("tj_" + collName + "_height"));
}

# mil-code to build faster IR indices
PROC tj_buildIRindex() : void :=
{
	tj_buildIRindex(collName);
}

PROC tj_buildIRindex(str collName) : void :=
{
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) {
		bat("tj_" + collName + "_TermIndex").persists(false);
		bat("tj_" + collName + "_Terms").persists(false);
		bat("tj_" + collName + "_TagIndex").persists(false);
		bat("tj_" + collName + "_Tags").persists(false);
		commit();
	}
	var tmp := bat("tj_" + collName + "_tid").kdiff(bat("tj_" + collName + "_pfpre"));
        tmp := tmp.reverse().sort();
	var termindex := tmp.mark(0@0).reverse().offsetindex(bat("tj_globalTerms").count() + 1);
	var terms := tmp.reverse().mark(0@0).reverse();
	termindex.persists(true).bbpname("tj_" + collName + "_TermIndex");
	terms.persists(true).bbpname("tj_" + collName + "_Terms");
	tmp := nil;
	termindex := nil;
	terms := nil;
	commit();
	
	tmp := bat("tj_" + collName + "_tid").semijoin(bat("tj_" + collName + "_pfpre"));
        tmp := tmp.reverse().sort();
	var tagindex := tmp.mark(0@0).reverse().offsetindex(bat("tj_globalTags").count() + 1);
	var tags := tmp.reverse().mark(0@0).reverse();
	tagindex.persists(true).bbpname("tj_" + collName + "_TagIndex");
	tags.persists(true).bbpname("tj_" + collName + "_Tags");
	tmp := nil;
	tagindex := nil;
	tags := nil;
	commit();
}

######################################
# PF interface functions
#
######################################

PROC tijah2pf(BAT[oid,dbl] pre_score) : BAT :=
{
	var docpre := bat("tj_" + collName + "_doc_firstpre").[oid]();
	var pfpre :=  bat("tj_" + collName + "_pfpre");
	
	var item := pre_score.hmark(0@0);
	var score := pre_score.tmark(0@0);
	var iter := item.mirror();
	var frag := [find_lower](const docpre.reverse().mark(0@0), item);
	item := item.join(pfpre).sort().tmark(0@0);
	
	var res := new(void,bat);
	res.append(iter);
	res.append(item);
	res.append(frag);
	res.append(score);
	return res;
}

# align_frag assumes the following variable to be global to its scope:
# frag, kind, ipik, ws
PROC align_frag() : void :=
{
	var needed_docs := bat("tj_" + collName + "_doc_name").semijoin(frag.tunique());
	var loaded_docs := ws.fetch(DOC_LOADED).reverse();
	needed_docs@batloop()
	{
		if (not(loaded_docs.exist($t))) {
			ws.add_doc($t); }
	}
	var fid_pffid := needed_docs.join(ws.fetch(DOC_LOADED).reverse());
	frag := frag.join(fid_pffid).sort().tmark(0@0);
	kind := set_kind(frag, ELEM);
	ipik := iter;
}

@h

@c
#include <monet.h>
#include <gdk.h>

#include <pathfinder.h>

int executeMIL(char* str) {
    return monet_exec(str);
}

int CMDtijah_command(bit* res, str command) {
	if ( 0 ) stream_printf(GDKout,"# tijah_command(%s)\n",(char*)command);
	*res = executeMIL(command); /* OK */
	return GDK_SUCCEED;
}

extern char* tijahParse(BAT* optbat, char* query, char** errBUFF);

static int oldScoreCounter = 0;

int CMDtijah_query(BAT** res, BAT* optbat, str q) {
	char* err;
	char* mil;

	if ( !optbat ) {
            GDKerror("CMDtijah_query: missing option bat.\n");
	    return GDK_FAIL;
	}
	if ( !(mil=tijahParse(optbat,q,&err)) ) {
            GDKerror("CMDtijah_query: %s.\n", err);
	    return GDK_FAIL;
	}
        if ( executeMIL(mil)<0 ) {
            GDKerror("CMDtijah_query: execute MIL failed.\n");
	    return GDK_FAIL;
	}
	BAT* scoreBAT = BATdescriptor( BBPindex("nexi_result") );

	if ( ! scoreBAT ) {
            GDKerror("CMDtijah_query: fail to load score bat: \"%s\".\n", "nexi_result");
	    return GDK_FAIL;
        }
	char buff[32];
	sprintf(&buff[0],"%s_del%d","nexi_result",oldScoreCounter++);
	if ( BATrename(scoreBAT,(str)&buff[0]) == str_nil ) {
            GDKerror("CMDtijah_query: fail to rename score bat: \"%s\".\n", &buff[0]);
	    return GDK_FAIL;
	}
	BATmode(scoreBAT,TRANSIENT);

	*res = scoreBAT;
        return GDK_SUCCEED;
}

#define SC_DEBUG 0

static BAT** initScoreBAT(int sz) {
	BAT** res = GDKmalloc(sz * sizeof(BAT*));

	if ( res ) for(int i=0; i<sz; i++) {
		res[i] = NULL;
	}
	return res;
}

static BAT* fetchScoreBAT(BAT* wts, oid idx) {
        BAT* res = NULL;
	BUN bun;
	if ( (bun = BUNfnd(wts,&idx)) )
            res = BATdescriptor(*(bat*)BUNtail(wts,bun));
	return res;
}

static BAT* createScoreBAT(BAT* wts, oid idx) {
	BAT* res;

	res = BATnew(TYPE_oid,TYPE_dbl,1024);
	if ( res && BATkey(res,TRUE)) {
	    BBPfix(BBPcacheid(res));
            if ( !BUNins(wts,&idx,&BBPcacheid(res),FALSE) ) 
	        res = NULL;
	}
	return res;
}

static int freeScoreBAT(BAT** sb) {
	GDKfree(sb);
	return 1;
}

int CMDupdate_tijah_scores(BAT** res, BAT* ws, BAT* ws_tijah_score, BAT* item, BAT* kind, BAT* score) {

	if (SC_DEBUG) stream_printf(GDKout,"* tijah-score-adm: start updating scores\n");
        if ( !BATkey(ws_tijah_score,TRUE) ) {
	        stream_printf(GDKout,"SETTING KEY ON SCOREBAT failed.\n");
		return GDK_FAIL;
	}
	BAT** scoreBAT;
	int ws_size = BATcount(ws);
	
	if ( !(scoreBAT = initScoreBAT(ws_size)) )
		return GDK_FAIL;

	int x;
	BUN p,q;
	BATloopFast(item, p, q, x) {
	   oid idx   = *(oid*) BUNhead(item, p);
	   oid pfpre = *(oid*) BUNtail(item, p);

	   BUN kindBUN = BUNfnd(kind,&idx);
	   if ( !kindBUN ) {
	        stream_printf(GDKout,"READ KIND failed\n");
		return GDK_FAIL;
	   }
	   int kval = *(int*)BUNtail(kind, kindBUN);
	   if ( XTRACT_KIND(kval) != ELEM ) {
	        stream_printf(GDKout,"READ KIND failed, NO ELEM\n");
		return GDK_FAIL;
	   }
	   oid cont = (oid)XTRACT_CONT(kval);
	   BUN scoreBUN = BUNfnd(score,&idx);
	   if ( !scoreBUN ) {
	        stream_printf(GDKout,"READ SCORE failed\n");
		return GDK_FAIL;
	   }
	   dbl sval = *(dbl*)BUNtail(score, scoreBUN);
	   /* */
	   if ( scoreBAT[cont] == NULL ) {
	        if ( !(scoreBAT[cont] = fetchScoreBAT(ws_tijah_score,cont)) ) {
	            if ( !(scoreBAT[cont] = createScoreBAT(ws_tijah_score,cont)) ) {
                      stream_printf(GDKout,"CMDupdate_tijah_scores: fail to load scorebat container(%d)\n",cont);
                      return GDK_FAIL;
		    }
		}
	    }
	    if ( !BUNfnd(scoreBAT[cont],&pfpre) ) {
	      if ( !BUNins(scoreBAT[cont],&pfpre,&sval,FALSE) ) {
		stream_printf(GDKout,"CMDupdate_tijah_scores: score replace failed.\n");
                return GDK_FAIL;
	       }
	       if (SC_DEBUG) stream_printf(GDKout,"* tijah-score-adm: node(%d@0) cont(%d)] = %f[inserted]\n",pfpre,cont,sval);
	    } else {
	      if ( !BUNreplace(scoreBAT[cont],&pfpre,&sval,1) ) {
		stream_printf(GDKout,"CMDupdate_tijah_scores: score replace failed.\n");
                return GDK_FAIL;
	      }
	      if (SC_DEBUG) stream_printf(GDKout,"* tijah-score-adm: node(%d@0) cont(%d)] = %f[replaced]\n",pfpre,cont,sval);
	    }
	}
	/* */
	/* for(int i=0; i<ws_size; i++) if (scoreBAT[i]) BATprintf(GDKout,scoreBAT[i]); */
	/* */
	if ( !freeScoreBAT(scoreBAT))
	     return GDK_FAIL;
	/* */
	BBPfix(BBPcacheid(ws_tijah_score));
	*res = ws_tijah_score;
	/* */
	if (SC_DEBUG) stream_printf(GDKout,"* tijah-score-adm: ready updating scores\n");
	/* */
	return GDK_SUCCEED;
}

int CMDfill_tijah_scores(BAT* ws, BAT* ws_tijah_score, BAT* item, BAT* kind, BAT* dbl_values) {
	if (SC_DEBUG) stream_printf(GDKout,"* CMDfill_tijah_scores: start filling scores\n");

	BAT** scoreBAT;
	int ws_size = BATcount(ws);
	BAT* dbl_values_mirror = BATmirror(dbl_values);

	if ( SC_DEBUG ) {
	  stream_printf(GDKout,"ARGUMENT ITEM BAT =\n");
	  BATprintf(GDKout,item);
	}
	
	if ( !(scoreBAT = initScoreBAT(ws_size)) )
		return GDK_FAIL;

	int x;
	BUN p,q;
	BATloopFast(item, p, q, x) {
	   oid idx      = *(oid*) BUNhead(item, p);
	   ptr itemTAIL = BUNtail(item, p);
	   oid pfpre    = *(oid*) itemTAIL;

	   BUN kindBUN = BUNfnd(kind,&idx);
	   if ( !kindBUN ) {
	        stream_printf(GDKout,"READ KIND failed\n");
		return GDK_FAIL;
	   }
	   ptr kindTAIL = BUNtail(kind, kindBUN);
	   int kval = *(int*)kindTAIL;
	   if ( XTRACT_KIND(kval) != ELEM ) {
	        stream_printf(GDKout,"READ KIND failed, NO ELEM\n");
		return GDK_FAIL;
	   }
	   oid cont = (oid)XTRACT_CONT(kval);
	   dbl sval;
	   /* */
	   if ( scoreBAT[cont] == NULL ) {
	        if ( (scoreBAT[cont] = fetchScoreBAT(ws_tijah_score,cont)) ) {
		    if ( SC_DEBUG ) {
		        stream_printf(GDKout,"FETCHED SCORE CONTAINER[%d] == \n",cont);
		        BATprintf(GDKout,scoreBAT[cont]);
		    }
		}
	   }
	   if ( scoreBAT[cont] ) {
		BUN bun;
	        if ( !(bun=BUNfnd(scoreBAT[cont],&pfpre)) ) {
		     sval = 0;
		} else {

		     sval = *(dbl*)BUNtail(scoreBAT[cont],bun);
		}
	   } else
	        sval = 0;

	   oid dbl_idx;
	   BUN b = BUNfnd(dbl_values_mirror,&sval);
	   if ( b ) { /* INCOMPLETE, CHECK DUPLICATES FIRST */
	     dbl_idx = *(oid*)BUNtail(dbl_values_mirror,b);
	   } else {
	     if ( !BUNappend(dbl_values,&sval,1) ) {
	       stream_printf(GDKout,"!!! SCORE APPEND FAILS.\n");
	       return GDK_FAIL;
	     }
	     dbl_idx = BATcount(dbl_values)-1;
	   }
	   if (SC_DEBUG) stream_printf(GDKout,"FETCHING pre=%d@0[c=%d] sc=%f @ dbl_values[%d@0]\n",pfpre,cont,sval,dbl_idx);
	   *(oid*)itemTAIL = dbl_idx;
	   *(int*)kindTAIL = DBL;
	}
	/* */
	if ( !freeScoreBAT(scoreBAT))
	     return GDK_FAIL;
	kind->batDirty        = TRUE;
	item->batDirty        = TRUE;
	dbl_values->batDirty = TRUE;
	/* */
	if ( SC_DEBUG ) {
		stream_printf(GDKout,"* RESULT ITEM:\n");
		BATprintf(GDKout,item);
		stream_printf(GDKout,"* RESULT KIND:\n");
		BATprintf(GDKout,kind);
		stream_printf(GDKout,"* RESULT DBL_VALUES:\n");
		BATprintf(GDKout,dbl_values);
	}
	if (SC_DEBUG) stream_printf(GDKout,"* CMDfill_tijah_scores: finish filling scores\n");
	/* */
	return GDK_SUCCEED;
}

int CMDoffsetindex ( BAT** result, BAT* tid, int* res_size )
{
	char *name = "TJoffsetindex";
	BAT *res = NULL;
        BUN p, q, dst = NULL;
	oid t, s;
	int bs_res, x;

	/* --------------------------- checks ---------------------------------- */

	BATcheck(tid, name);
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: index-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}
	if (!(BAThdense(tid)))
    	{
        	GDKerror("%s: index-bat must have a dense head.\n", name);
    		return GDK_FAIL;
	}
		
	res = BATnew(TYPE_void, TYPE_oid, *res_size);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, *res_size);
            	return(GDK_FAIL);
        }
	bs_res = BUNsize(res);
	dst = BUNlast(res);
    
	t = (oid)0;
	*(oid*)dst = (oid)0;
	dst += bs_res;
	
	BATloopFast(tid, p, q, x)
	{
		s = *(oid*) BUNtail(tid, p);
		if (t != s)
		{
			for(; t < s; t++)
			{
				*(oid*)dst = BUNindex(tid, p);
				dst += bs_res; 
			}
		}
	}

	s = (oid) (*res_size - 1);
	for(; t < s; t++)
	{
		*(oid*)dst = BUNindex(tid, p);
		dst += bs_res; 
	}
	
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->tsorted = GDK_SORTED;
        BATkey (res, TRUE);
	BATset(res, TRUE);
	BATseqbase(res, 0);
	
	*result = res;
	return GDK_SUCCEED;
}	
	
int CMDindexfetchjoin ( BAT** result, BAT* tid, BAT* index, BAT* pre )
{
	char *name = "TJindexfetchjoin";
	BAT *res = NULL;
        BUN dst = NULL;
	int bs_pre = BUNsize(pre);
	int bs_res;

	int ressize = 0;
	oid t, *ind;
	BUN p, q;
        int x, j, i = 0;
	bit one_tid = FALSE;
    
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tid, name);
	BATcheck(index, name);
	BATcheck(pre, name);
	
        if (BATcount(tid) <= 1) one_tid = TRUE;
	
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	ind = GDKmalloc(sizeof(oid) * BATcount(tid) * 3);
	
	BATloopFast(tid, p, q, x) {
		t = *(oid*) BUNtail(tid, p);
		ind[i++] = t;
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t));
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t + 1));
		ressize += (ind[i - 1] - ind[i - 2]);
	}
	
	res = BATnew(TYPE_oid, TYPE_oid, ressize);
	bs_res = BUNsize(res);
	dst = BUNlast(res);
	
	j = 0;
	while (j < i) {
        	t = ind[j++];
		p = BUNptr(pre, ind[j++]);
		q = BUNptr(pre, ind[j++]);
		for (; p < q; p += bs_pre) {
			*(oid*)dst = t;
			*(oid*)(dst + SIZEOF_OID) = *(oid*)p;
			dst += bs_res;
		}
	}

	GDKfree(ind);
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
        BATkey (BATmirror(res), TRUE);
	BATset(res, TRUE);
	
	*result = res;
	return GDK_SUCCEED;
}

bat* pftijah_prelude() {
    return NULL;
}

void pftijah_epilogue() {
}
@

/* vim:set shiftwidth=4 expandtab: */
