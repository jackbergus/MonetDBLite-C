@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the PfTijah Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://dbappl.cs.utwente.nl/Legal/PfTijah-1.1.html
@' 
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@' 
@' The Original Code is the PfTijah system.
@' 
@' The Initial Developer of the Original Code is the "University of Twente".
@' Portions created by the "University of Twente" are 
@' Copyright (C) 2006-2007 "University of Twente".
@' All Rights Reserved.
@'

@f pftijah
@a Jan Flokstra
@a Henning Rode
@t pftijah

@m
.MODULE pftijah;

.USE pathfinder;

.COMMAND run_tijah_command(str s) : bit = CMDtijah_command;
 "INCOMPLETE"

.COMMAND run_tijah_query(BAT[str,str], BAT[void,oid], str q) : BAT[oid,dbl] = CMDtijah_query;
 "INCOMPLETE"

.COMMAND tj_normalizeTerm(str, str) : str = CMDtj_normalizeTerm;
 "INCOMPLETE"

.COMMAND _tj_throw2collection(BAT[oid,bat],BAT[oid,bat],str,str) : void = CMDtj_throw2collection;
 "INCOMPLETE"

.COMMAND _tj_throw2collection_index(BAT[oid,bat],str) : void = CMDtj_throw2collection_index;
 "INCOMPLETE"
 
.COMMAND tijah_tokenize(str) : str = CMDtijah_tokenize;
 "INCOMPLETE"

.COMMAND tj_create_termdb(int, oid) : void = CMDtj_create_termdb;
 "INCOMPLETE"

.COMMAND tj_dispose_termdb() : void = CMDtj_dispose_termdb;
 "INCOMPLETE"

.COMMAND serialize_tijah_opt(
                      BAT[void,bat] ws,
                      int	    niters,
                      BAT[void,oid] loop,
                      BAT[void,oid] iter,
                      BAT[void,oid] item,
		      BAT[void,int] kind,
                      BAT[void,lng] int_values,
		      BAT[void,dbl] dbl_values,
		      BAT[void,str] str_values)
		       : BAT[str,str] = serialize_pftijah_options_DRIVER;
 "C interface to pftijah option serialize"

.COMMAND pf2tijah_node(
                      BAT[void,str] doc_name,
                      BAT[void,int] doc_firstpre,
                      BAT[oid,oid] pfpre,
                      BAT[void,oid] item,
		      BAT[void,int] kind,
                      BAT[void,str]  doc_loaded)
		       : BAT[void,oid] = CMDpf2tijah_node;
 "Translate Pathfinder node sequence to tijah node sequence"

.COMMAND offsetindex( BAT[void,oid] offset_tid, int res_size)
		: BAT[void,oid] = CMDoffsetindex;

"PARAMETERS:
BAT[void,oid] - the offset index 
ressize       - the result size, equals number of different tids + 1
DESCRIPTION:
creates an offset index.
"

.COMMAND mergeindex( BAT[oid,oid] tid_pre, BAT[void,oid] index, BAT[void, oid] pre, int indsize)
		: BAT[void,bat] = CMDmergeindex;
"PARAMETERS:
BAT[oid,oid] - new tid_pre to merge with the old index
BAT[void,oid] - old index bat with value-offset
BAT[void,oid] - old posting lists (pre order lists)
int - size of new (dense) offset index.
DESCRIPTION:
the operation merges a new sorted tid_pre with an existing offset index.
"

.COMMAND indexfetchjoin( BAT[any,oid] tid, BAT[void,oid] index, BAT[void, oid] pre)
		: BAT[void,oid] = CMDindexfetchjoin;
"PARAMETERS:
BAT[any,oid] - bat with tail values which have to be joined (e.g. tid values)
BAT[void,oid] - join index bat with value-offset
BAT[void,oid] - bat with indexed offset and tail values to be returned
DESCRIPTION:
the join algorithm comes down to a repeated slice and insert operation.
"

.COMMAND score_NLLR( BAT[oid,oid] elem_tid, BAT[void,int] pre_size, BAT[oid,int] tid_cnt, 
                     BAT[oid,int] tid_frq, BAT[oid,any] e, dbl _lmbd, int q_cnt)
		: BAT[oid,dbl] = CMDscore_NLLR;
"PARAMETERS:
BAT[oid,oid] elem_tid - pre-order / tid bat that results from containment-join
BAT[void,int] pre_size - the pre_size bat of the element nodes
BAT[oid,int] tid_cnt - tid histogram of the query
BAT[oid,int] tid_frq - coll frequencies of the query
BAT[oid,any] e - the extend bat, holding all pre-order identifiers of elements to score
dbl _lmbd - the lambda interpolation factor
q_cnt - the number of query terms
DESCRIPTION:
The function calculates NLLR scores for all elements in e and all terms in tid_cnt.
"

.COMMAND treemergejoin_sort(BAT[void,oid],BAT[void,int],BAT[void,oid]) : BAT[oid,oid] = CMDtreemergejoin_sort; 
"Stack tree merge join descendant"

.PRELUDE = pftijah_prelude;
.EPILOGUE = pftijah_epilogue;

.END pftijah;
@mil
module("pathfinder");
module("monettime");

###
# This file contains implementations of some of the SRA operators 
# to run on the TIJAH Light index.
#
# Based on code by the TIJAH team (Vojkan, Thijs)
#
# Additional retrieval models by Henning Rode 
#
# Authors: Roel van Os <roel.van.os@glacimonto.nl>
#          Henning Rode <h.rode@cs.utwente.nl>
#
###

const DEBUG := false;

# Type of the size used
const SIZE_ENTITY := 1;
const SIZE_TERM := 2;

# Comparisons
const GREATER := 10;
const LESS := 11;
const EQUAL := 12;
const GEQ := 13;
const LEQ := 14;

# Modifiers
const NORMAL := 71;
const PLUS := 72;
const MINUS := 73;
const MUST := 74;
const MUST_NOT := 75;

# Default score (0 or 1)
var scoreBase := 0;

const ENTITY_NUM := 10000;

var collName := "PFX";
var background_collName := "PFX";
var collHeight := 10;
var retNum := 100;

var trace := false;
var timing := false;

##
# For retrieval models: 
#   true:  return all elements from the context set
#   false: return only elements from the context set that contain one or more query terms
#
# Setting this variable to false has the advantage of smaller intermediate region sets.
# In theory, true has the advantage of better results, since it is possible that
# elements that don't match any term at the beginning of a query, contain descendants
# that do match terms.
##
var returnAllElements := true;

if (view_bbp_name().reverse().exist("tj_collName")) {
	if (bat("tj_collName").count() > 0) {
		var name := bat("tj_collName").fetch(0);
		tj_setCollName(name);
	}
}

#####################################################################
#                                                                   #
# Start of the new implementation of the interfaces                 #
#                                                                   #
#####################################################################

var verbose := false;


ADDHELP("tj_ping", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- none.\n\
DESCRIPTION:\n\
debugging, when this help is removed Mtest/Mapi fails ",
"pftijah");
PROC tj_ping() : void :=
{
  printf("# *** ping *****\n");
}

ADDHELP("tj_init_global", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- optional BAT[str,str] param: initialization parameter for global pftijah.\n\
  settings.\n\
DESCRIPTION:\n\
Initialize the global pftijah environment.",
"pftijah");
PROC tj_init_global(BAT[str,str] param) : void :=
{
    if ( verbose ) printf("#TJ: tj_init_global() called.\n");
    param@batloop() {
	if ( verbose ) printf("#TJ: tj_init_global():param[%s]=\"%s\"\n",$h,$t);
	if ( $h = "term_frag" ) {
	    # incomplete, handle term frag
	} else if ( $h = "term_frag_size" ) {
	    # incomplete, handle term frag
	} else {
	    ERROR("# tj_init_global() unkonwn parameter [%s].\n",$h);
	}
    }
    new(oid,str).persists(true).bbpname("tj_globalTerms");
    new(oid,str).persists(true).bbpname("tj_globalTags");
    new(oid,str).persists(true).bbpname("tj_collName");
}

PROC tj_init_global() : void :=
{
     tj_init_global(new(str,str));
}

ADDHELP("tj_delete_global", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
DESCRIPTION:\n\
Delete all pftijah collections and remove the global pftijah settings.",
"pftijah");
PROC tj_delete_global() : void :=
{
    if ( verbose ) printf("#TJ: tj_delete_global() called.\n");
    #
    bat("tj_collName")@batloop(){
    	tj_delete_collection($t);
    }
    bat("tj_globalTerms").persists(false);
    bat("tj_globalTags").persists(false);
    bat("tj_collName").persists(false);
    commit();
}

ADDHELP("tj_init_collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str collName: the name of the collection
- BAT[str,str] param: initialization parameter for collection.\n\
  possible values are:\n\
  stemmer = { nostemming, snowball-english, snowball-porter, snowball-dutch }\n\
  fragmentSize = [number] == the maximum size of a [pre|item] fragment\n\
  tagFilter = [comma seperated list of tags to be indexed]\n\
  etc.\n\
DESCRIPTION:\n\
Create a new tijah collection.",
"pftijah");
PROC tj_init_collection(str collName, BAT[str,str] param) : void :=
{
    if ( verbose ) printf("#TJ: tj_init_collection(\"%s\") called.\n",collName);

    if (not(view_bbp_name().reverse().exist("tj_collName"))) {
    	tj_init_global(); # just in case 
    }
    if (bat("tj_collName").reverse().exist(collName)) {
    	ERROR("tj_init_collection, pftijah collection already exists: %s\n",collName);
    }
    new(void,str).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_name");
    new(void,int).seqbase(0@0).persists(true).bbpname("tj_" + collName + "_doc_firstpre");
    new(str,str).persists(true).bbpname("tj_" + collName + "_param");
    
    new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_tid1");
    new(void,int).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_size1");
    # bat contains the start oid of every tid/size frag. Head is postfix
    # string to _tid/_size. Normally "", "2", "3"
    new(void,oid).seqbase(1@0).persists(true).bbpname("tj_" + collName + "_fragments");
    bat("tj_" + collName + "_fragments").append(1@0);
    new(oid,oid).persists(true).bbpname("tj_" + collName + "_pfpre");
       
    var coll_oid;
    if (bat("tj_collName").count() = 0) { coll_oid := 0@0; }
        	else { coll_oid := oid(int(bat("tj_collName").reverse().max()) + 1); }
    bat("tj_collName").insert(coll_oid, collName);
    #
    # now read the param file
    #
    var stemmer  := "nostemming";
    var tagfilter := "";

    param@batloop() {
	if ( verbose ) printf("#TJ: tj_init_global():param[%s]=\"%s\"\n",$h,$t);
	if ( $h = "stemmer" ) {
	    stemmer := $t;
	} else if ( $h = "fragmentSize" ) {
            bat("tj_" + collName + "_param").insert($h,$t);
	} else if ( $h = "tagFilter" ) {
            tagfilter := $t;
	} else {
	    ERROR("# tj_init_global() unkonwn parameter [%s].\n",$h);
	}
    }
    #
    # now set the parameters for this collection
    #
    bat("tj_" + collName + "_param").insert("_version","1.01");
    bat("tj_" + collName + "_param").insert("name",collName);
    bat("tj_" + collName + "_param").insert("height","0");
    bat("tj_" + collName + "_param").insert("stemmer",stemmer);
    bat("tj_" + collName + "_param").insert("tagFilter",tagfilter);
    bat("tj_" + collName + "_param").insert("preExpansion","4");
    bat("tj_" + collName + "_param").insert("status","building");
    bat("tj_" + collName + "_param").insert("_last_tijahPre","1");
    bat("tj_" + collName + "_param").insert("_last_finalizedPre","0");
    #
    commit();
}

ADDHELP("tj_delete_collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str collName: the name of the collection to be deleted.\n
DESCRIPTION:\n\
Delete the collection with name \"collName\".",
"pftijah");
PROC tj_delete_collection(str collName) : void
{
	bat("tj_" + collName + "_doc_name").persists(false);
	bat("tj_" + collName + "_doc_firstpre").persists(false);
	bat("tj_" + collName + "_param").persists(false);
	bat("tj_" + collName + "_pfpre").persists(false);
	bat("tj_" + collName + "_fragments")@batloop() {
	    var fpfx := str(int($h));
	    bat("tj_" + collName + "_tid"+fpfx).persists(false);
	    bat("tj_" + collName + "_size"+fpfx).persists(false);
	}
	bat("tj_" + collName + "_fragments").persists(false);
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) {
		bat("tj_" + collName + "_TermIndex").persists(false);
		bat("tj_" + collName + "_Terms").persists(false);
		bat("tj_" + collName + "_TagIndex").persists(false);
		bat("tj_" + collName + "_Tags").persists(false);
	}
        
	var coll_oid := bat("tj_collName").reverse().find(collName);
	bat("tj_collName").delete(coll_oid);
	commit();
}

# internal method which return all relevant data about a collection in a
# a single [void,bat] bat
PROC _tj_collection(str collName) : BAT[void,bat]
{
	var tjCollBat := new(void,bat).seqbase(0@0);

	var parbat := bat("tj_" + collName + "_param");
	var curversion;
	if ( parbat.exist("_version") ) {
	    curversion := parbat.find("_version");
	} else {
	    curversion := "0.0";
	}
	if ( curversion < "1.0" ) {
	     ERROR("_tj_collection(): pftijah index structure changed, reindex collection!!");
	}
	tjCollBat.append(bat("tj_globalTerms"));
	tjCollBat.append(bat("tj_globalTags"));
	tjCollBat.append(bat("tj_" + collName + "_doc_name"));
	tjCollBat.append(bat("tj_" + collName + "_doc_firstpre"));
	tjCollBat.append(parbat);
	# only load the top [pre|term|size] fragments
	var fpfx := str(bat("tj_" + collName + "_fragments").count());
	tjCollBat.append(bat("tj_" + collName + "_tid"+fpfx));
	tjCollBat.append(bat("tj_" + collName + "_size"+fpfx));
	tjCollBat.append(bat("tj_" + collName + "_pfpre"));
	tjCollBat.append(bat("tj_" + collName + "_fragments"));
	return tjCollBat;
}

ADDHELP("tj_add2collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str collName: the name of the collection.\n
- str uri_loc: the location of the xml document.\n
- str uri_name: the name of the xml document (optional).\n
- bit store: when true the doc is stored in pathfinder.\n\
DESCRIPTION:\n\
Add a document to a pftijah collection. The document is indexed and if the \n\
store parameter is true it is also stored in Pathfinder. When a document is\n\
not stored in Pathfinder it will be shredded on the fly when nodes from the\n\
document are returned by the XQUERY pftijah-node() function.\n\
The index is automatically finalized at the end of the method.",
"pftijah");
PROC tj_add2collection(str collName, str uri_loc, str uri_name, bit store) : void
{
    var t_start := usec();
    bat("tj_globalTerms").access(BAT_WRITE);
    bat("tj_globalTags").access(BAT_WRITE);
    _tj_add2collection(collName,_tj_collection(collName),uri_loc,uri_name,store);
    _tj_finalize_collection(collName);
    if ( timing ) {
       var ms := (usec()-t_start)/1000;
       printf("#C[%s]:tj_add2collection(): + aggregate time = %lld.%03llds.\n",collName,/(ms,1000),%(ms,1000));
     }
}

ADDHELP("tj_add2collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str collName: the name of the collection.\n
- BAT[str,str]: the bat containing the [location,name] pairs of the xml docs.\n\
- bit store: when true the documents are stored in Pathfinder.\n\
DESCRIPTION:\n\
The multidocument version of tj_add2collection. The main difference with the\n\
other method is the [str,str] bat which contains the location of the document\n\
in the head and the name in the tail.\n\
The advantage of this method is that the collection is finalized after all\n\
xml documents in the bat are added to the collection.",
"pftijah");
PROC tj_add2collection(str collName, BAT[str,str] uri, bit store) : void
{
    var t_start := usec();
    bat("tj_globalTerms").access(BAT_WRITE);
    bat("tj_globalTags").access(BAT_WRITE);
    # var cb := _tj_collection(collName);
    uri@batloop() {
      _tj_add2collection(collName,_tj_collection(collName),$h,$t,store);
    }
    _tj_finalize_collection(collName);
    if ( timing ) {
       var ms := (usec()-t_start)/1000;
       printf("#C[%s]:tj_add2collection(BAT): + aggregate time = %lld.%03llds.\n",collName,/(ms,1000),%(ms,1000));
     }
}

PROC _timestr(lng v) : str
{
    return str(v/1000000) + "." + str(v/1000) + "xs";
}

# main internal add2collection() function.
PROC _tj_add2collection(str collName, BAT[void,bat] collBats, str uri_loc, str uri_name, bit store) : void
{ 
    var ms;
    var t_start := usec();
    if ( verbose ) printf("#TJ: _tj_add2collection(\"%s\") start.\n",collName);

    var selTagList := bat("tj_" + collName + "_param").find("tagFilter");
           
    var i_start;
    if ( store ) {
        if ( isnil(uri_name) ) {
	  uri_name := uri_loc;
	} else if ( uri_name = "" ) {
	  uri_name := uri_loc;
	}
        var ws := ws_create();
        if (not(bat("doc_name").reverse().exist(uri_name))) {
            var s_start := usec();
    	    shred_doc(uri_loc,uri_name);
            if ( timing ) {
	      ms := (usec()-s_start)/1000;
              printf("#C[%s]:add2coll(\"%s\"): shred time = %lld.%03llds.\n",collName,uri_name,/(ms,1000),%(ms,1000));
            }
        }
        ws_opendoc(ws, bat(void,str,1).append(uri_name));
	i_start := usec();
        _tj_throw2collection(collBats,ws,uri_name,selTagList);
        ws_destroy(ws);
    } else {
	i_start := usec();
        _tj_throw2collection_index(collBats,uri_loc);
    }
    if ( timing ) {
	ms := (usec()-i_start)/1000;
        printf("#C[%s]:add2coll(\"%s\"): index time = %lld.%03llds.\n",collName,uri_name,/(ms,1000),%(ms,1000));
    }
    # var height1 := bat("doc_height").fetch(bat("doc_name").reverse().find(uri_name));
    var height1 := 999; # REMOVE
           
    var coll_oid := bat("tj_collName").reverse().find(collName);
    var height2 := bat("tj_" + collName + "_param").find("height").int();
    bat("tj_" + collName + "_param").replace("height", max(height1,height2).str());
    bat("tj_" + collName + "_param").replace("status","building");
    commit();	
    if ( verbose ) printf("#TJ:_tj_add2collectiontj_init_collection(\"%s\") finish.\n",collName);
    if ( timing ) {
	ms := (usec()-t_start)/1000;
        printf("#C[%s]:add2coll(\"%s\"): total time = %lld.%03llds.\n",collName,uri_name,/(ms,1000),%(ms,1000));
    }
}


ADDHELP("tj_finalize_collection", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- str collName: the name of the collection.\n
DESCRIPTION:\n\
Obsolete function which prepares the collection for usage of new documents\n\
added to the collection. This is now done automagically",
"pftijah");
PROC tj_finalize_collection(str collName) : void
{
    _tj_finalize_collection(collName);
}

# internal finalize function
PROC _tj_finalize_collection(str collName) : void
{
    var t_start := usec();
    if ( verbose ) printf("#TJ: _tj_finalize_collection(\"%s\") called.\n",collName);
    #
    # Finalize one collection. No documents should be added after this
    bat("tj_" + collName + "_fragments").access(BAT_READ);
    bat("tj_" + collName + "_fragments")@batloop()
    {
        var ind := str(int($h));
        bat("tj_" + collName + "_tid" + ind).access(BAT_READ);
        bat("tj_" + collName + "_tid" + ind).mmap(1);
        bat("tj_" + collName + "_size" + ind).access(BAT_READ);
        bat("tj_" + collName + "_size" + ind).mmap(1);
    }
    # bat("tj_" + collName + "_pfpre").access(BAT_READ); BUG CANNOT USE FINALIZED BAT, JF!!!
    bat("tj_" + collName + "_pfpre").mmap(1);
    commit();
    _buildIRindex(collName);
    #
    bat("tj_" + collName + "_param").replace("status","finalized");
    var lst_fpre := bat("tj_" + collName + "_param").find("_last_tijahPre");
    bat("tj_" + collName + "_param").replace("_last_finalizedPre", lst_fpre);
    #
    var gterm_sort := bat("tj_globalTerms").reverse().sort().reverse();
    bat("tj_globalTerms").persists(false);
    var gtag_sort := bat("tj_globalTags").reverse().sort().reverse();
    bat("tj_globalTags").persists(false);
    commit();
    gterm_sort.persists(true);
    gterm_sort.bbpname("tj_globalTerms");
    gtag_sort.persists(true);
    gtag_sort.bbpname("tj_globalTags");
    if ( false ) {
      # Monet error, server crashes on .acces(BAT_WRITE) when a new 
      # collection is created on a fresh Mserver.
      bat("tj_globalTerms").access(BAT_READ);
      bat("tj_globalTags").access(BAT_READ);
    }
    bat("tj_globalTerms").mmap(1);
    if ( false ) {
      # Monet error, server crashes on .acces(BAT_WRITE) when a new 
      # collection is created on a fresh Mserver.
      bat("tj_globalTags").mmap(1);
    }
    commit(); 
    if ( timing ) {
        var ms := (usec()-t_start)/1000;
        printf("#C[%s]:finalize(\"%s\"): total time = %lld.%03llds.\n",collName,uri_name,/(ms,1000),%(ms,1000));
    }
}

# set a collection parameter
PROC tj_set_parameter(str collName, str par, str val) : void
{
	var parbat := bat("tj_" + collName + "_param");

	if ( parbat.exist(par) ) {
	    parbat.replace(par,val);
	} else {
	    parbat.insert(par,val);
	}
}

PROC tj_dump_collection(str collName) : void
{
	bat("tj_" + collName + "_param").print();
	bat("tj_" + collName + "_doc_name").print();
	bat("tj_" + collName + "_doc_firstpre").print();
	# print(bat("tj_" + collName + "_doc_name"),bat("tj_" + collName + "_doc_firstpre"));
	bat("tj_globalTerms").print();
	bat("tj_globalTags").print();
	print(bat("tj_" + collName + "_tid1"));
	print(bat("tj_" + collName + "_size1"));
	print(bat("tj_" + collName + "_pfpre"));
	print(bat("tj_" + collName + "_fragments"));
	# print(bat("tj_" + collName + "_height"));
}

#####################################################################
#                                                                   #
# End of the new implementation of the interfaces                   #
#                                                                   #
#####################################################################

ADDHELP("tj_setCollName", "flokstra & rode", "Jan 2007",
"PARAMETERS:\n\
- the name of the collection to be set.\n\
DESCRIPTION:\n\
debugging, when this help is removed Mtest/Mapi fails ",
"pftijah");
# SUGAR: this function should not be necessary in the future but it
#        first has to be removed from the generated scripts.
PROC tj_setCollName(str name) : void := 
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(name))) {
		ERROR("collection \"%s\"does not exist",name);
	}
	collName := name;
	background_collName := name;
	collHeight := bat("tj_" + collName + "_param").find("height").int();
	if ( DEBUG ) { 
        	printf("Work collection is set to %s (with height %d)\n", collName, collHeight);
        	fflush(stdout());
        } 
}

# INCOMPLETE: henning, what should I do about this.
PROC tj_setBackgroundCollName(str name) : void := 
{
	if (not(view_bbp_name().reverse().exist("tj_collName"))) {
		tj_global_init();
	}
	if (not(bat("tj_collName").reverse().exist(name))) {
		ERROR("background collection \"%s\"does not exist",name);
	}
	background_collName := name;
	if ( DEBUG ) { 
        	printf("Background collection is set to %s (with height %d)\n", collName, collHeight);
        	fflush(stdout());
        } 
}

# INCOMPLETE: henning, what should I do about this.
PROC tj_setScoreBase(int default) : void :=
{
	scoreBase := default;
}


# INCOMPLETE: henning, what should I do about this.
var equivalences := new(str,str);
PROC tj_initEquivalences() : void := 
{
    equivalences := new(str,str);
}

PROC tj_addEquivalenceClass( bat elements ) : void := 
{
    # Create cross product of class elements
    var class := eqclass.reverse().cross( eqclass );
    # Append to equivalences table
    equivalences := equivalences.insert( class );
}

var tracefile_handle := nil;
PROC tj_trace( str s ) : void := 
{
    if ( not( tracefile = "" ) ) {
        if ( isnil( tracefile_handle ) )
            tracefile_handle := open_wastream(tracefile);
        
        tracefile_handle.stream_write( sprintf( "%d %s\n", int(msec()/1000), s ) );
        tracefile_handle.stream_flush();
    }
}

const virtRoot := 0@0;


##
# Compute ancestor-descendant relation. 
#
# Forwards to anc_desc_llscj: see below.
##
PROC anc_desc( bat[oid,any] anc, bat[oid,any] desc, bat[void,int] pre_size ) : bat[oid,oid] :=
{
   return anc_desc_llscj(anc,desc,pre_size);
}


##
# Compute ancestor-descendant relation using the loop-lifted staircase join.
#
# The arguments anc and desc must contain preorder indices in their heads. 
# The tail values are discarded.
#
# Returns a bat containing [anc,desc] preorder index pairs
##
PROC anc_desc_llscj( bat[oid,any] anc, bat[oid,any] desc, bat[void,int] pre_size ) : bat[oid,oid] :=
{
    if ( trace ) tj_trace( "BEGIN anc_desc_llscj" );
    
    # Items contains the context nodes for the descendant step: 
    # this is the right side argument to contained_by.
    # The table must be [void,oid], so:
    var items := anc.sort().mark(0@0).reverse();
    
    # Suggestion from Thijs: make iters a [void,void], with the same length as anc
    var iters := anc.hmark(oid(0)).mark(oid(0));
    
    # Candidates contains the right side argument. This must also be [void,oid]:
    var candidates := desc.sort().mark(0@0).reverse();
    
    # Call the descendant algorithm: it returns [ancestor, descendant] pairs 
    # if we pass items as the iteration argument
    var void_desc := ll_descendant(iters, items, pre_size, candidates, false, false, min(iters), max(iters), false, chr(nil));
    
    # Map back the ancestors
    var anc_desc  := anc.mark(oid(0)).join(void_desc);
    
    candidates := nil;
    items := nil;
    pre_size := nil;
    
    if ( trace ) tj_trace( "END   anc_desc_llscj" );
    return anc_desc;
}


## 
# Compute parent-child relation. 
# 
# Forwards to parent_child_llscj: see below.
##
PROC parent_child( bat[oid,any] parent, bat[oid,any] child ) : bat[oid,oid] :=
{
    return parent_child_llscj( parent, child );
}


## 
# Compute parent-child relation using the loop-lifted staircase join. 
# 
# The arguments parent and child must contain preorder indices in their heads. 
# The tail values are discarded.
#
# Returns a bat containing [parent,child] preorder index pairs
##
PROC parent_child_llscj( bat[oid,any] parent, bat[oid,any] child ) : bat[oid,oid] :=
{
    # Items contains the context nodes for the descendant step: 
    # this is the right side argument to contained_by.
    # The table must be [void,oid], so:
    var items := parent.mark(0@0).reverse();
    
    # Suggestion from Thijs: make iters a [void,void], with the same length as anc
    var iters := parent.hmark(oid(0)).mark(oid(0));
    
    # Candidates: all element nodes
    var candidates := child.sort().mark(0@0).reverse();
    
    # Load the pre-size table
    var pre_size := load( "tj_" + collName + "_size1");
    
    # Check the order of the items:
    items.chk_order();
    
    var void_chld := ll_child(iters, items, pre_size, candidates, collHeight, false, false, min(iters), max(iters), false);
    
    # Map back the ancestors
    var par_desc  := parent.mark(oid(0)).join(void_chld);
    
    candidates := nil;
    items := nil;
    pre_size := nil;
    
    return par_chld;
}


##
# Converts a list of query terms to a list of term id->document position mappings.
#
# Stemming on the query terms is performed using the same stemmer
# that was used for the collection.
#
# Results are sorted on the document position (tail)
##
PROC Qterms_to_tid_pre( bat[void,str] Qterms ): bat[oid,oid] :=
{
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var stemmed := [tj_normalizeTerm]( [toLower](Qterms), stemmer );
    
    var tids    := bat("tj_globalTerms").join( stemmed.reverse() ).sort().hmark(oid(0));
    
    var result := indexfetchjoin( tids,
                                  bat("tj_" + collName + "_TermIndex"),
                                  bat("tj_" + collName + "_Terms") );
    return result.tsort();
}


##
# Converts a list of query terms to a list of term ids
#
# Stemming on the query terms is performed using the same stemmer
# that was used for the collection.
##
PROC Qterms_to_void_tid( bat[void,str] Qterms ): bat[void,oid] :=
{
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var stemmed := [tj_normalizeTerm]( [toLower](Qterms), stemmer );
    
    var tids := bat("tj_globalTerms").join( stemmed.reverse() ).sort().hmark(oid(0));
    return tids;
}


##
# Return only the element nodes from region ctx
##
PROC nodes( bat[oid,any] ctx ) : bat[oid,any] :=
{
    # The pfpre table only stores element nodes, so we can use it as a filter:
    var pfpre  := bat( "tj_" + collName + "_pfpre");
    var result := pfpre.mirror().join( ctx );
    return result;
}


##
# Return only the terms from region ctx
##
PROC terms( bat[oid,any] ctx ) : bat[oid,any] :=
{
    # A term is everything that is not an element node
    var nodes  := nodes( ctx );
    var result := ctx.kdiff( nodes );
    return result;
}


################################################################################
# SELECTION
################################################################################

##
# Select the root node of the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_root() : bat[oid,dbl] :=
{
    if ( not( isnil( startNodes ) ) ) {
        # Start from a set of starting nodes if available. 
        # It is assumed that the startNodes are [any, pre]
        if ( count( startNodes ) > 0 ) {
            var root_reg := startNodes.reverse().sort().project( dbl(scoreBase) );
            return root_reg;
        } else {
            var root_reg := new(oid,dbl,1);
            
            root_reg.insert( virtRoot, dbl(scoreBase) );
            return root_reg;
        }
    } else {
        # Because TIJAH expects all documents in a collection to be contained by one 
        # "virtual root" element, this behaviour should be emulated by the light index. 
        # An element with preorder oid(0) will indicate that it is the collection root.
        var root_reg := new(oid,dbl,1);
        
        root_reg.insert( virtRoot, dbl(scoreBase) );
        return root_reg;
    }
}

PROC select_root_frag() : bat[oid,bat] := 
{
    var res := new(oid,bat);
    
    res.insert(0@0, select_root() );
    return res;
}

##
# Select all element nodes in the collection
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_node() : bat[oid,dbl] := 
{
    # The table pfpre only stores element nodes, so we can use it as a filter:
    var pfpre  := bat( "tj_" + collName + "_pfpre");
    
    return pfpre.project( dbl(scoreBase ) );
}

##
# Select all element nodes in the collection with the given name
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_node(str name) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( sprintf("BEGIN select_node('%s')", name) );

    var tids := bat("tj_globalTags").select(name);
    if (tids.count() = 0) return new(oid,dbl);
    var tid := tids.reverse().fetch(0);
    var result := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TagIndex"),
    				  bat("tj_" + collName + "_Tags") );
    result := result.reverse().sort().project(dbl(scoreBase)); 

    if ( trace ) tj_trace( sprintf("END   select_node('%s')", name) );
    return result;
}


##
# Select all element nodes in the collection with the given name.
#
# Equivalence classes are taken into account. 
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_node(str name, bit e_class) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( sprintf("BEGIN select_node('%s',%d)", name, e_class) );
    
    if ( e_class ) {
        var names := equivalences.uselect( name ).reverse();
        if ( count( names ) = 0 ) {
            # Apparently, there were no equivalent tags (not even the tag itself)
            #names := new(void,str).seqbase(oid(0));
            #names.append(name);
            return select_node(name);
        }
        
        var tids := bat("tj_globalTags").join(names.reverse()).mark(0@0).sort().reverse();
        
        var result := indexfetchjoin( tids,
                        bat("tj_" + collName + "_TagIndex"),
                        bat("tj_" + collName + "_Tags") );
        result := result.reverse().sort().project(dbl(scoreBase)); 

        if ( trace ) tj_trace( sprintf("END   select_node('%s',%d)", name, e_class) );
        return result;
    } else {
        if ( trace ) tj_trace( sprintf(" END select_node('%s',%d)", name, e_class) );
        return select_node(name);
    }
}

PROC select_node_frag(str name, bit e_class) : bat[oid,bat] := 
{
    var nodes := select_node(name, e_class);
    var res := split2frag(nodes, bat("tj_" + collName + "_fragments"));
   
    return res;
}

PROC split2frag(bat[oid,any] nodes, bat[void,oid] frags) : bat[oid,bat] :=
{
    var res := new(oid,bat);
    
    var lst_frag := frags.reverse().fetch(frags.count() - 1);
    var i := 0;
    var j := nodes.count();
    while( i < j)
    {
    	var frag := find_lower(frags.reverse(), nodes.reverse().fetch(i));
        if (frag < lst_frag)
	{
	    var frag_limit := oid(int(frags.fetch(int(frag))) -1); #only correct if frag numbering starts at 1
	    var nodes_limit := int(find_lower(nodes.mark(0@0), frag_limit));
	    res.insert(frag, nodes.slice(i, nodes_limit));
            i := nodes_limit + 1;
	}
	if (frag = lst_frag)
	{
	    res.insert(frag, nodes.slice(i, j - 1));
            i := j;
	}
    }

    return res;
}

##
# Select all terms with the given value
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_term(str name) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( sprintf("BEGIN select_term('%s')", name) );
    # 
    var stemmer := bat("tj_"+ collName +"_param").find("stemmer");
    var term    := tj_normalizeTerm( toLower(name), stemmer );
    
    # Select the term positions from the global term dictionary.
    var tids := bat("tj_globalTerms").select(term).mark(0@0).sort().reverse();
    
    var result := indexfetchjoin( tids,
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    result := result.reverse().sort().project(dbl(scoreBase)); 
    

    if ( trace ) tj_trace( sprintf("END   select_term('%s')", name) );
    return result;
}

PROC select_term_frag(str name) : bat[oid,bat] := 
{
    var nodes := select_term(name);
    var res := split2frag(nodes, bat("tj_" + collName + "_fragments"));
    return res;
}

##
# Select all terms with the given value, possibly performing stemming on the argument.
#
# This variant of the select_term function is present for compatibility reasons:
# at the moment, stemming is always performed using the same stemmer that was
# used to index the collection.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_term(str name, int stemming) : bat[oid,dbl] := 
{
    return select_term( name );
}


##
# Select a number of terms by their term-id.
# 
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC select_phrase(bat[void,oid] terms) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN select_phrase" );
    # Select the term positions from the global term dictionary. 
   
    var tid := terms.fetch(0);
    var tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
    var res := tmp.reverse();
    var j := terms.count();
    var i := 1; 
    while (i < j)
    {
        tid := terms.fetch(i);
        tmp := indexfetchjoin( new(int,oid).insert(0,tid),
    				  bat("tj_" + collName + "_TermIndex"),
    				  bat("tj_" + collName + "_Terms") );
        res := res.semijoin(tmp.[int]().[-](i).[oid]().reverse());   
	i :+= 1;
    }	
    
    res := res.sort().project(dbl(scoreBase)); 
    
    if ( trace ) tj_trace( "END   select_phrase" );
    return res;
}


################################################################################
# CONTAINMENT
################################################################################


#####################################
# left CONTAINED_BY right:
#
#   +--------------------+
#   |       right        |
#   | +---------------+  |
#   | |      left     |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it is contained a region in right
#
#####################################
PROC contained_by_frag(bat[oid,bat] left, bat[oid,bat] right) : bat[oid,bat] :=
{
    var res        := new(oid,bat);
    #exception for root in right
    if ( right.exist(0@0) ) return left; 
    left@batloop() {
      if ( right.exist($h) ) {
        res.insert($h, contained_by($t, right.find($h), str(int($h))) );
      }
    }
    return res;
}

PROC contained_by(bat[oid,dbl] left, bat[oid,dbl] right, str ind) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN contained_by_2" );
    var pre_size := bat("tj_"+collName+"_size"+ind);
    # Check for the virtual root
    if ( not( pre_size.exist(0@0) ) ) {
        # Exceptions for root in left or right argument. The case 
        # of region sets containing the root is not handled
        if ( count( left ) = 1 )
            if ( left.reverse().fetch(0) = virtRoot ) 
                return new(oid,dbl);
        
        if ( count( right ) = 1 )
            if ( right.reverse().fetch(0) = virtRoot ) 
                return left;
    }
    
    var anc_desc := anc_desc( right, left, pre_size);
    
    # Attach the scores to the resulting nodes again:
    var result := anc_desc.reverse().kunique().mirror().join(left);
    
    if ( trace ) tj_trace( "END   contained_by_2" );
    return result;
}

##
# Returns all regions in the collection that are contained by the argument. 
# Equivalent with a descendant step in XPath.
#
# Returns a bat [preorder rank,score].
# The score is initalized based on the scoreBase global variable.
##
PROC contained_by(bat[oid,dbl] region) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN contained_by_1" );
    if ( not( bat("tj_"+collName+"_size1").exist(0@0) ) ) {
        # Exceptions for root in argument. The case 
        # of region sets containing the root is not handled
        if ( count( region ) = 1 ) 
            if ( region.reverse().fetch(0) = virtRoot )
                return select_node();
    }


    var ctx      := region;
    var pre_size := load( "tj_" + collName + "_size1");    
    var desc     := scj_desc( pre_size, ctx, count(pre_size) );
    var result   := nodes( desc ).project( dbl(scoreBase) );
    
    if ( trace ) tj_trace( "END  contained_by_1" );
    return result;
}


#####################################
# left CONTAINING right:
#
#   +--------------------+
#   |       left         |
#   | +---------------+  |
#   | |      right    |  |
#   | +---------------+  |
#   |                    |
#   +--------------------+
#
# Returns: region from left if it contains a region in right
#
#####################################
PROC containing(bat[oid,dbl] left, bat[oid,dbl] right) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN containing_2" );
    
    # Check for the virtual root
    if ( not( bat("tj_"+collName+"_size1").exist(0@0) ) ) {
        # Exceptions for root in argument. The case 
        # of region sets containing the root is not handled
        if ( count( left ) = 1 )
            if ( left.reverse().fetch(0) = virtRoot )
                return right;
    
        if ( count( right ) = 1 )
            if ( right.reverse().fetch(0) = virtRoot )
                return new(oid,dbl);
    }
        
    var anc_desc := anc_desc( left, right );

    # Attach the scores to the resulting nodes again:
    var result := anc_desc.mirror().kunique().join(left);
    
    if ( trace ) tj_trace( "END   containing_2" );
    return result;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

PROC _containing_desc(bat[oid,void] left, bat[oid,oid] pre_tid, bat[void,int] pre_size) : bat[oid,oid] :=
{
    if ( trace ) tj_trace( "BEGIN _containing_desc" );    
     var elems := left.hmark(0@0);
     var cands := pre_tid.hmark(0@0);
     var iter := elems.mirror();
     var elem_termpre := ll_descendant(	iter, 
     					elems, 
					pre_size, 
					cands, 
					false, false, min(iter), max(iter), false, chr(nil));
     elem_termpre := elem_termpre.reverse().leftfetchjoin(elems).reverse();
     var elem_tid := elem_termpre.join(pre_tid);
     elem_termpre := nil;
     if ( trace ) tj_trace( "END   _containing_desc" );    
     return elem_tid;
}

PROC _containing_desc2(bat[oid,void] left, bat[oid,oid] pre_tid, bat[void,int] pre_size) : bat[oid,oid] :=
{
    if ( trace ) tj_trace( "BEGIN _containing_desc2" );    
     var elems := left.hmark(0@0);
     var cands := pre_tid.hmark(0@0);
     var iter := elems.mirror();
     var elem_termpre := ll_descendant2(iter, 
     					elems, 
					pre_size, 
					cands, 
					false, false, min(iter), max(iter), false, chr(nil));
     var elem_tid := elem_termpre.join(pre_tid);
     elem_termpre := nil;
     if ( trace ) tj_trace( "END   _containing_desc" );    
     return elem_tid;
}

PROC _containing_desc3(bat[oid,void] left, bat[oid,oid] pre_tid, bat[void,int] pre_size) : bat[oid,oid] :=
{
    if ( trace ) tj_trace( "BEGIN _containing_desc3" );    
     var elems := left.hmark(0@0);
     var cands := pre_tid.hmark(0@0);
     var elem_termpre := treemergejoin_sort( elems, 
					pre_size, 
					cands);
     var elem_tid := elem_termpre.join(pre_tid);
     elem_termpre := nil;
     if ( trace ) tj_trace( "END   _containing_desc" );    
     return elem_tid;
}

PROC _containing_anc(bat[oid,void] left, bat[oid,oid] pre_tid, bat[void,int] pre_size) : bat[oid,oid] :=
{
    if ( trace ) tj_trace( "BEGIN _containing_anc" );    
     var tmp_pre := pre_tid.hmark(0@0);
     var elems := ll_ancestor(tmp_pre, 
                              tmp_pre, 
                              pre_size, 
                              collHeight).reverse(); 
     tmp_pre := nil;
     elems := elems.semijoin(left);
     var elem_tid := elems.join(pre_tid);
     var elems := nil;
     
     print( "END   _containing_anc" );
     return elem_tid;
}

PROC collTermCount(str col, bat[oid,int] terms) : bat[oid,int] :=
{
     var tids := terms.mirror();
     var offsets1 := tids.leftfetchjoin(bat("tj_" + col + "_TermIndex"));
     tids := tids.[int]().[+](1).[oid]();
     var offsets2 := tids.leftfetchjoin(bat("tj_" + col + "_TermIndex"));
     var res := [-](offsets2.[int](),offsets1.[int]()).select(1,int(nil));
     return res;
}

PROC score_NLLR_mil(bat[oid,oid] elem_tid, bat[void,int] pre_size, bat[oid,int] tid_cnt, bat[oid,int] tid_frq, bat[oid,oid] elems, dbl _lmbd, int q_cnt) : bat[oid,dbl] :=
{
     # compute collection terms frequencies 
     var _tid_frq := [/](_lmbd, tid_frq);
     tid_frq := nil;

     # compute document sizes
     var elem_size := pre_size.semijoin(elems);

     # compute scores in batloop over terms
     var doc_prob := new(oid,dbl);
     _tid_frq@batloop()
     {
	  var tmp := elem_tid.select($h);
	  var fac := dbl(tid_cnt.find($h)) / dbl(q_cnt);
	  tmp := tmp.reverse().histogram();
	  tmp := [dbl](tmp);
	  tmp := [/](tmp, elem_size);
	  tmp := [*](tmp, $t);
	  tmp := [+](tmp, 1);
	  tmp := [log](tmp);
	  tmp := [*](tmp, fac);
	  doc_prob.insert(tmp);
     }
    
    var elements := left.mark(0@0);
    
    if ( not( returnAllElements ) ) 
        elements := elements.semijoin(elem_tid);
     
     # aggregate doc scores
     var res := {sum}(doc_prob.tmark(0@0), doc_prob.hmark(0@0), elements);
    
     #res := res.[/](_tid_frq.count());

     return res;
}

PROC p_containing_q_NLLR_frag(bat[oid,bat] left, bat[void,str] Qterms, flt lmbd) : bat[oid,bat] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_NLLR_frag" );
    var t1 := time();

     # get term ids and drop all terms with zero frq in col or background-col
     var terms := Qterms_to_void_tid( Qterms ).histogram();
     var q_cnt := Qterms.count();
     var tid_frq := collTermCount(background_collName, terms);
     var tid_cnt := terms.semijoin(tid_frq);
     terms := nil;
     if (tid_cnt.count() = 0) {return new(oid,bat);}
    
     # compute constant factor in score computation
     var _lmbd := dbl((1.0 - lmbd) / lmbd);
     var collFrq := bat("tj_" + background_collName + "_Terms").count();
     _lmbd :*= collFrq;
     
     # fetch term occurrences and sort them in preorder
     var pre_tid := indexfetchjoin(tid_cnt.hmark(0@0), 
                                   bat("tj_" + collName + "_TermIndex"), 
                                   bat("tj_" + collName + "_Terms") ).reverse();
     if (pre_tid.count() = 0) {return new(oid,dbl);}
     pre_tid := pre_tid.sort();

    var pre_tids := split2frag(pre_tid, bat("tj_" + collName + "_fragments"));

    var res := new(oid,bat);

    left@batloop() {
      if ( pre_tids.exist($h) ) {
        var tmp := NLLR_body($t, pre_tids.find($h), str(int($h)), tid_cnt, tid_frq, _lmbd, q_cnt);
	if (tmp.count() > 0) {res.insert($h, tmp);}
      }
    }
    
    if ( trace ) tj_trace( "END   p_containing_q_NLLR_frag" );
    var t2 := time();
    if (timing) printf("# p_containing_q_NLLR_frag(): total time: %d\n", t2 - t1);
    
    return res;
}

PROC NLLR_body(bat[oid,dbl] left, bat[oid,oid] pre_tid, str ind, bat[oid,int] tid_cnt, bat[oid,int] tid_frq, dbl _lmbd, int q_cnt) : bat[oid,dbl] :=
{
     var pre_size := bat("tj_" + collName + "_size" + ind);
     
     # evaluate doc/term (anc/desc) relationship
     var elem_tid := _containing_desc(left.mark(0@0), pre_tid, pre_size);
     pre_tid := nil;
     if (elem_tid.count() = 0) {return new(oid,dbl);}
     
     var res := score_NLLR(elem_tid, pre_size, tid_cnt, tid_frq, elem_tid.kunique(), _lmbd, q_cnt);
     
     # Obey scoreBase setting: 
     if ( scoreBase = 0 ) {
        res := [+](left, res);
     } else {
        res := [*](left, res);
     }
     return res;
}

PROC p_containing_q_NLLR(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd, str ind) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_NLLR" );
    var t1 := time();
    var pre_size := bat("tj_" + collName + "_size" + ind);
    
     # get term ids and drop all terms with zero frq in col or background-col
     var terms := Qterms_to_void_tid( Qterms ).histogram();
     var q_cnt := Qterms.count();
     var tid_frq := collTermCount(background_collName, terms);
     terms := terms.semijoin(tid_frq);
     if (terms.count() = 0) {return new(oid,dbl);}
    
     # compute constant factor in score computation
     var _lmbd := dbl((1.0 - lmbd) / lmbd);
     var collFrq := bat("tj_" + background_collName + "_Terms").count();
     _lmbd :*= collFrq;
     
     # fetch term occurrences and sort them in preorder
     var pre_tid := indexfetchjoin(terms.hmark(0@0), 
                                   bat("tj_" + collName + "_TermIndex"), 
                                   bat("tj_" + collName + "_Terms") ).reverse();
     if (pre_tid.count() = 0) {return new(oid,dbl);}
     var t1a := time();
     pre_tid := pre_tid.sort();
     
     # evaluate doc/term (anc/desc) relationship
     var t2 := time();
     var elem_tid := _containing_desc3(left.mark(0@0), pre_tid, pre_size);
     var t3 := time();
     pre_tid := nil;
     if (elem_tid.count() = 0) {return new(oid,dbl);}
     
     var res := score_NLLR(elem_tid, pre_size, terms, tid_frq, elem_tid.kunique(), _lmbd, q_cnt);
     # Obey scoreBase setting: 
     if ( scoreBase = 0 ) {
        res := [+](left, res);
     } else {
        res := [*](left, res);
     }
     if ( trace ) tj_trace( "END   p_containing_q_NLLR" );
     var t4 := time();

     if (timing) printf("# p_containing_q_NLLR(): total time: %d, term selection: %d, containmentjoin: %d, score computation: %d\n", t4 - t1, t1a - t1, t3 - t2, t4 - t3);
     return res;
}

PROC p_containing_q_NLLR_mil(bat[oid,dbl] left, bat[void,str] Qterms, flt lmbd, str ind) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_q_NLLR" );
    var t1 := time();
    var pre_size := bat("tj_" + collName + "_size" + ind);
    
     # get term ids and drop all terms with zero frq in col or background-col
     var terms := Qterms_to_void_tid( Qterms ).histogram();
     var q_cnt := Qterms.count();
     var tid_frq := collTermCount(background_collName, terms);
     terms := terms.semijoin(tid_frq);
     if (terms.count() = 0) {return new(oid,dbl);}
    
     # compute constant factor in score computation
     var _lmbd := dbl((1.0 - lmbd) / lmbd);
     var collFrq := bat("tj_" + background_collName + "_Terms").count();
     _lmbd :*= collFrq;
     
     # fetch term occurrences and sort them in preorder
     var pre_tid := indexfetchjoin(terms.hmark(0@0), 
                                   bat("tj_" + collName + "_TermIndex"), 
                                   bat("tj_" + collName + "_Terms") ).reverse();
     if (pre_tid.count() = 0) {return new(oid,dbl);}
     var t1a := time();
     pre_tid := pre_tid.sort();
     
     # evaluate doc/term (anc/desc) relationship
     var t2 := time();
     var elem_tid := _containing_desc(left.mark(0@0), pre_tid, pre_size);
     var t3 := time();
     pre_tid := nil;
     if (elem_tid.count() = 0) {return new(oid,dbl);}
     
     var res := score_NLLR_mil(elem_tid, pre_size, terms, tid_frq, elem_tid.kunique(), _lmbd, q_cnt);
     
     # Obey scoreBase setting: 
     if ( scoreBase = 0 ) {
        res := [+](left, res);
     } else {
        res := [*](left, res);
     }
     if ( trace ) tj_trace( "END   p_containing_q_NLLR" );
     var t4 := time();
     if (timing) printf("total time: %d, term selection: %d, containmentjoin: %d, score computation: %d\n", t4 - t1, t1a - t1, t3 - t2, t4 - t3);
     return res;
}

##
# Implementation of the Language Modeling retrieval model, with smoothing.
#
# This function is meant for term-at-a-time score computation (ASPECT algebra), e.g.:
#
# var R1 := select_node("article");
# var R2 := select_term("information");
# var R3 := p_containing_t_LMs(R1, R2, 0.5, SIZE_TERM);
#
# R3 now contains all regions in R1, however with scores attached according
# to the occurrence of the term "information" (R2)
#
#
# This function implements the following formula:
#                         tc(tm_i, doc)                  tc(tm_i,col)
#  S(doc|tm_i) = lambda * ------------- + (1 - lambda) * ------------
#                           len(doc)                       len(col)
#
#  tm_i         : query term
#  doc          : document or, in this case, region
#  tc(tm_i, doc): term count of query term tm_i in doc
#  len(doc)     : size of doc (term or element size)
##
PROC p_containing_t_LMs(bat[oid,dbl] left, bat[oid,dbl] right, flt lmbd, int size_type) : bat[oid,dbl] := 
{
    if ( trace ) tj_trace( "BEGIN p_containing_t_LMs_ASPECT" );
    
    var lambda;
    var m_lambda;
    var forgnd_prob := new(oid,dbl,ENTITY_NUM);
    var bckgnd_prob;

    var res_reg := new(oid,dbl,ENTITY_NUM);

    # Compute the foreground probability: how many regions from right does left contain?
    # This count is divided by the region size by reg_freq
    # 
    # This constitutes P(t|D), or tc(tm,doc)/len(doc)
    forgnd_prob := reg_freq(left,right,size_type);

    # Compute the background probability: how often does the query term occur in the collection
    # In this case, we know that count(right) = tc(tm,col)
    #
    # This constitutes P(t|C), or tc(tm,col)/len(col)
    var col_len := bat("tj_" + background_collName + "_Terms").count();
    bckgnd_prob := dbl(count(right))/dbl(col_len);

    #if (size_type = SIZE_ENTITY) {
    #    # Compute right size / collection entity size
    #    
    #    var pre_pfpre := bat("tj_" + collName + "_pfpre");
    #    bckgnd_prob := dbl(count(right))/dbl(count(pre_pfpre));
    #
    #    pre_pfpre := nil;
    #} else if (size_type = SIZE_TERM) {
    #    # Compute right size / collection term size
    #    
    #    var pre_tid  := bat("tj_" + collName + "_tid");
    #    var pre_pfpre := bat("tj_" + collName + "_pfpre");
    #    var terms := pre_tid.mirror().kdiff( pre_pfpre.mirror() );
    #
    #    bckgnd_prob := dbl(count(right))/dbl(count(terms));
    #    
    #    var pre_tid := nil;
    #    var pre_pfpre := nil;
    #    var terms := nil;
    #}

    if (bckgnd_prob = dbl(0)) {
        if (DEBUG) printf( "Minimum collection frequency has not been computed yet!\n" );
        # Assign minimum collection frequency
        
        bckgnd_prob := min(col_freq());
    }

    # Precompute lambda values
    lambda := dbl(lmbd);
    m_lambda := dbl(1)-lambda;

    if (scoreBase = 0)
        res_reg := [+](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));
    else if (scoreBase = 1)
        res_reg := [*](left, [+]([*](lambda,forgnd_prob),*(m_lambda,bckgnd_prob)));

    if ( trace ) tj_trace( "END   p_containing_t_LMs_ASPECT" );
    return res_reg;
}

##
# Implementation of the Language Modeling retrieval model.
#
# This function is meant for set-based score computation (COARSE2 algebra), e.g.:
#
# var R1 := select_node("article");
# var terms := new(void,str).seqbase(oid(0));
# var modifiers := new(void,int).seqbase(oid(0));
# terms.append("information");
# terms.append("retrieval");
# var R2 := p_containing_t_LMs(R1, terms, modifiers, 0.5, 1, SIZE_TERM);
#
# R2 now contains all regions in R1, however with scores attached according
# to the occurrence of the terms "information" and "retrieval"
#
#
# The score value for a single term and document is defined as follows:
#                                                  
#  S(doc|tm) = lambda * FG(tm) + (1 - lambda) * BG(tm)
#
# where 
#            tc(tm,doc)
#  FG(tm) = ------------       (foreground statistics)
#             len(doc)
#
#            tc(tm,col)
#  BG(tm) = ------------       (background statistics)
#             len(col)
#
# To compute score values for a set of terms at once, this function implements 
# presence weighting (thanks to Thijs for pointing this out), using the following 
# formula:
#
#            /    ___       lambda * FG(tm_i)         \        ___     
# S(doc|q) = |    | |     ----------------------  + 1 |  *     | |    (1 - lambda) * BG(tm_i)
#            \ tm_i in q  (1 - lambda) * BG(tm_i)     /     tm_i in q  
#
# where:                                                   
#  q            : query: set of query terms
#  tm_i         : query term
#  doc          : search document or, in this case, context region
#  tc(tm_i, doc): term count of query term tm_i in doc
#  len(doc)     : size of doc (term or element size)
##
PROC p_containing_q_LMs(bat[oid,dbl] ctx, bat[void,str] Qterms, bat modifiers, flt lambda, int stemming, int size_type) : bat[oid,dbl]
{   
    if ( trace ) tj_trace( "BEGIN p_containing_t_LMs_COARSE" );
    # To follow the naming in the formula above, context regions are named "documents".
    # For each term we need:
    #  - foreground probability (first term). This depends on the context region
    #  - background probability (second term). This is the same for every context region
    
    # Convert the query terms from [void,str] to [void,tid]
    var terms := Qterms_to_void_tid( Qterms );

    ### Background probability:
    # For each term: collection term frequency tc(tm_i, col):
    #var col_term_frq := tid_pre.reverse().histogram();
    #small hack to get LMs running again...
    var col_term_frq := collTermCount(background_collName, terms.reverse().project(int(0)));

    # Collection size len(col): int
    var col_len := bat("tj_" + background_collName + "_Terms").count();

    # Take only the terms that occur in the collection
    terms := terms.reverse().semijoin(col_term_frq).hmark(0@0);

    if (terms.count() = 0) { return new(oid,dbl); }
    
    ###
    
    ### Foreground probability: 
    # Find out the document positions of the terms for foreground probability
    var tid_pre := indexfetchjoin(terms, 
                                   bat("tj_" + collName + "_TermIndex"), 
                                   bat("tj_" + collName + "_Terms") );
    
    if (tid_pre.count() = 0) { return new(oid,dbl); }
    tid_pre := tid_pre.tsort();
    
    # See which document contain the query terms we create a bat of [doc, term-id]:
    var doc_tid := _containing_desc(ctx.mark(0@0), tid_pre);
    
    # len(doc): [doc, size]
    var doc_len := [dbl](bat("tj_" + collName + "_size1").semijoin(doc_tid));
    
    ###
    
    # Now, we need to compute the probability for each document->term pair
    var doc_termscore   := new(oid,dbl);
    var prod_background := dbl(1);
    
    # Iterate over all terms.
    terms@batloop() {
        # Compute the first factor
        # $t contains the term id 
        var occurrences := doc_tid.select($t).sort();
        
        # Count the occurrence of the term in all documents: tc(tm_i, doc), 
        # for all documents at once
        var tc_tm_doc  := [dbl](occurrences.reverse().histogram());
        var foreground := [/](tc_tm_doc, doc_len);

        # Compute the background probability: tc(tm_i,col)/len(col)
        var tc_tm_col  := col_term_frq.find($t); 
        var background := dbl(tc_tm_col) / dbl(col_len);
        
        # Compute the first factor. This generates a [doc, term score] table for
        # each combination of doc and term
        var total := [+]( [/]( [*](lambda, foreground), (1.0 - lambda) * background), dbl(1) );
        doc_termscore.insert( [dbl](total) );
        
        # Compute the second factor: product of background statistics over all terms
        prod_background := prod_background * background;
    }
    
    # We now have a table that lists [doc, term score] pairs. These need to be aggregated
    # into [doc, score] pairs: (this is the first aggregate product in the formula)
    #var res := {prod}(doc_termscore, ctx.mark(oid(0)));
    
    var elements := ctx.mark(0@0);
    
    if ( not( returnAllElements ) ) 
        elements := elements.semijoin(doc_tid);
        
    var res := {prod}(doc_termscore.tmark(0@0), doc_termscore.hmark(0@0), elements );
    
    # Now compute the final scores: multiply by the background score
    res := [*](res, (1.0 - lambda) * prod_background);

    if ( scoreBase = 0 ) {
        # Add the scores to the context set (this should have scores 0, so adding is OK)
        res := [+](ctx, res);
    } else {
        # Add the scores to the context set (this should have scores 1, so multiplying is OK)
        res := [*](ctx, res);
    }
    if ( trace ) tj_trace( "END   p_containing_t_LMs_COARSE" );
    return res;
}

##
# Returns the collection frequency table (should be precomputed, but is calculated for now)
##
PROC col_freq() : bat[oid,dbl] :=
{
    var start_time := time();
    var allterms := bat("tj_globalTerms").sort().mark(0@0).reverse();
    var alltermpos := indexfetchjoin(allterms, bat("tj_"+collName+"_TermIndex"), bat("tj_"+collName+"_Terms"));
    var col_freqs := [dbl]({count}(alltermpos));

    if (DEBUG) printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return col_freqs;
}

##
# Returns the collection frequency of the term with the indicated tid
##
PROC col_freq(oid tid) : dbl :=
{
    var start_time := time();
    var alltermpos := indexfetchjoin(new(int,oid).insert(0,tid), bat("tj_"+collName+"_TermIndex"), bat("tj_"+collName+"_Terms"));
    var col_freqs := {count}(alltermpos);
    var result := dbl(col_freqs.fetch(0));
    if (DEBUG) printf( "col_freq: \t\t%d ms\n", time() - start_time );
    return result;
}

##
# For each region in left, count the number of regions in right it contains.
##
PROC reg_freq(bat[oid,dbl] left, bat[oid,dbl] right, int size_type) : bat[oid,dbl]    :=    
{
    if ( trace ) tj_trace( "START reg_freq");
    
    var reg_size;
    
    var ctx_tmp2 := new( oid, int, ENTITY_NUM );
   
    ctx_tmp2 := anc_desc( left, right );
    
    # Containment count: for each region from left, count how many regions from right it contains
    var num_terms := {count}(ctx_tmp2);
    var prob_tmp  := [dbl](num_terms);
    
    # Region size: Determine the entity or term size of all regions from left that have descendants in right
    if (size_type = SIZE_ENTITY)
        reg_size := size_entity(prob_tmp);
    else if (size_type = SIZE_TERM)
        reg_size := size_term(prob_tmp);
    
    # prob_tmp := [/](prob_tmp,prob_tmp.mirror().join(reg_size));

    # Divide the containment count (left) by the region size (left)
    prob_tmp := [/](prob_tmp,reg_size);

    # Set all to zero regions from left that do not contain regions from right
    
    var result := prob_tmp.kunion( left.project(dbl(0)) );

    if ( trace ) tj_trace( "END   reg_freq " );
    
    return result;
}


# Calculate the term size of the region: how many terms does it contain?
PROC size_term( bat[oid,any] region ) : bat[oid,dbl] := 
{
    if ( trace ) tj_trace( "BEGIN size_term" );
    # For now, we use size_term = size_entity
    if ( trace ) tj_trace( "END   size_term" );
    return size_entity( region );
    var start_time := time();
    
    # all terms:
    var pre_tid   := bat("tj_" + collName + "_tid1");
    var pre_pfpre := bat("tj_" + collName + "_pfpre");
    var terms     := pre_tid.mirror().kdiff( pre_pfpre.mirror() );
    
    var items      := region.mirror().mark(0@0).reverse();
    var candidates := terms.mirror().mark(0@0).reverse();
    
    # Alternative:
    #var candidates      := bat("tj_" + collName + "_Terms" ).reverse().sort().mark(0@0).reverse();
    
    var pre_size := load( "tj_" + collName + "_size1");
   
    # Check the order of the items:
    items.chk_order();
    
    var res := ll_descendant(items, items, pre_size, candidates, false, false, min(items), max(items), false, chr(nil));
    
    var result := [dbl]({count}(res));
   
    var end_time := time();
    if (DEBUG) printf( "size_term: \t\t%d ms\n", end_time - start_time );
    if ( trace ) tj_trace( "END   size_term" );
    return result;
}

# Calculate the entity size of the region: how many entities (tags and terms) does it contain?
PROC size_entity( bat[oid,any] region ) : bat[oid,dbl] :=
{
    if ( trace ) {
        var trace_msg := sprintf("(receiving %d regions)", count(region));
        tj_trace( "START size_entity " + trace_msg );
    }
    
    # Entity sizes:
    var pre_size := load( "tj_" + collName + "_size1");
    
    var result := [dbl](region.mirror().join( pre_size ));

    if ( trace ) {
        var trace_msg := sprintf("(returning %d regions)", count(result));
        tj_trace( "END   size_entity " + trace_msg );
    }
    return result;
}


################################################################################
# PROBABILISTIC CONTAINMENT
################################################################################

PROC p_contained_by_sum(bat[oid,dbl] region) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_contained_by_sum_1" );
    # Candidates: all nodes
    var candidates := select_node();

    var ctx_res := anc_desc( region, candidates );

    var ctx := ctx_res.reverse().mirror();

    var reg_size := [dbl](size_term(ctx));

    reg_size:= reg_size.select(dbl(0),dbl(nil),false,true);

    ctx := reg_size.mirror();

    # calculating the score for each region
    var reg_score := {sum}(ctx_res.reverse().join(region));

    var res_reg := ctx.join(reg_score);
    
    if ( trace ) tj_trace( "END   p_contained_by_sum_1" );
    return res_reg;
}


PROC p_contained_by_sum(bat[oid,dbl] left, bat[oid,dbl] right) : bat[oid,dbl] := 
{
    if ( trace ) tj_trace( "BEGIN p_contained_by_sum_2" );
    var ctx_res := anc_desc( right, left );
    
    var reg_score;
    var res_reg;
    #var ctx := left.project(dbl(0));

    # calculating the score for each region
    reg_score := {sum}(ctx_res.reverse().join(right));
    #reg_score := kunion(reg_score, ctx);

	if (scoreBase = 0)
		res_reg := [+](reg_score, left);
	else if (scoreBase = 1)
		res_reg := [*](left, reg_score);
    
    if ( trace ) tj_trace( "END   p_contained_by_sum_2" );
	return res_reg;
}


PROC p_containing_wsumd(bat[oid,dbl] left, bat[oid,dbl] right, int size_type) : bat[oid,dbl] :=
{
    if ( trace ) tj_trace( "BEGIN p_containing_wsumd" );
    var ctx := left.project(dbl(0));
    var size_reg;
    var reg_score;
    var norm_reg;
    var res_reg;
    
    if (size_type = SIZE_ENTITY) {
        size_reg := size_entity(right);
    }
    else if (size_type = SIZE_TERM) {
        size_reg := size_term(right);
    }

    # Call the descendant algorithm: it returns [ancestor, descendant] pairs!
    var ctx_res := anc_desc( left, right );

    # calculating the score for each region
    # ERROR LINE BATkey must be dense
    reg_score := {sum}(ctx_res.join([*](size_reg,right)).sort());
    norm_reg := [dbl]({sum}(ctx_res.join(size_reg).sort()));

    # Select all values > 0
    norm_reg := norm_reg.select(dbl(0),dbl(nil),false,true);

    reg_score := norm_reg.mirror().join(reg_score);

    reg_score := [/](reg_score,norm_reg);

    reg_score := kunion(reg_score,ctx);

    if (scoreBase = 0)
        res_reg := [+](left, reg_score);
    else if (scoreBase = 1)
        res_reg := [*](left, reg_score);

    if ( trace ) tj_trace( "END   p_containing_wsumd" );
    return res_reg;
}

################################################################################
# SET OPERATORS
################################################################################

### UNION
PROC union(bat left, bat right) : bat :=
{
#TODO: perhaps do kunique here?
	return left.kunion(right).sort();

}

### INTERSECTION
PROC intersect(bat left, bat right) : bat := 
{

	return left.kintersect(right).sort();

}


################################################################################
# SCALING
################################################################################

PROC scale(bat region, flt importance) : bat := 
{

	var res_reg := new(oid,dbl,ENTITY_NUM);
	res_reg := [*](dbl(importance),region);
	return res_reg;

}


################################################################################
# PROBABILISTIC SET OPERATORS
################################################################################

PROC or_sum(bat left, bat right) : bat :=
{

	return [+](left,right);
	#var inters    := [+](left,right);
	#var onlyleft  := left.kdiff(inters);
	#var onlyright := right.kdiff(inters);
	#var result    := inters.kunion(onlyleft).kunion(onlyright).sort();

	#var inters := nil; var onlyleft := nil; var onlyright := nil;
	
        #return result;
}

PROC or_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC or_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

PROC or_exp(bat left, bat right, int A) : bat := 
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC or_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC or_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_prod(bat left, bat right) : bat :=
{

	return [*](left,right);

}

PROC and_min(bat left, bat right) : bat :=
{

	return [min](left,right);

}

PROC and_sum(bat left, bat right) : bat :=
{

	return [+](left,right);

}

PROC and_exp(bat left, bat right, int A) : bat :=
{

	var paramA := dbl(A-1);
	var eq_regions := new(oid,dbl,ENTITY_NUM);

	var res_reg := new(oid,dbl,ENTITY_NUM);

	eq_regions := [*](paramA, [+](left.mirror().join(right), right.mirror().join(left)));

	res_reg := {sum}(eq_regions.sunion(left).sunion(right));

	return res_reg;

}

PROC and_max(bat left, bat right) : bat :=
{

	return [max](left,right);

}

PROC and_prob(bat left, bat right) : bat :=
{

	return [-](dbl(1),[*]([-](dbl(1),left),[-](dbl(1),right)));

}

################################################################################
# VALUE SELECTION
################################################################################

PROC near_val(bat region, int command, str value) : bat :=
{
    print( "Sorry, near_val is not yet supported" );
    return region;

    var r_value;
    var reg_res := new(oid,dbl,ENTITY_NUM);
    var reg_tmp := new(oid,oid,ENTITY_NUM);

    var entity_pre := new(oid,oid,WORD_NUM);
    entity_pre := load(col_name+"entity_pre");

    # region:               [region-id, score]
    # region.mirror():      [region-id, region-id]
    # entity_pre:           [region-id, region pre-id]
    # reg_tmp:              [region-id, region pre-id]
    reg_tmp := region.mirror().join(entity_pre);

    entity_pre := nil;

    r_value := int(value);

    if (command = GREATER)
        reg_tmp := gt(reg_tmp, r_value);
    else if (command = LESS)
        reg_tmp := lt(reg_tmp, r_value);
    else if (command = EQUAL)
        reg_tmp := eq(reg_tmp, r_value);
    else if (command = GEQ)
        reg_tmp := gte(reg_tmp, r_value);
    else if (command = LEQ)
        reg_tmp := lte(reg_tmp, r_value);

    reg_res := reg_tmp.mirror().join(region);

    return reg_res;
}
#ADDHELP("near_val", "vojkan", "March 16, 2005",
#"Selects regions that satisfy the inequality (integer) test.",
#"TIJAH");

########################################################################################################
# Procudures for executing value comparison:
#       - eq            selects the regions with equal text content
#       - lt            selects the regions with less than text content
#       - gt            selects the regions with greater then text content
#       - lte           selects the regions with less than or equal text content
#       - gte           selects the regions with greater than or equal text content
#########################################################################################################

PROC gt(bat ctx, int comp) : bat :=
{

        var entity_pre := new(oid,oid,ENTITY_NUM);
        entity_pre := load(col_name+"entity_pre");
        var entity_type := new(oid,oid,ENTITY_NUM);
        entity_type := load(col_name+"entity_type");

        var word_pre := new(oid,oid,ENTITY_NUM);
        word_pre := load(col_name+"word_pre");
        var word_name := new(oid,oid,ENTITY_NUM);
        word_name := load(col_name+"word_name");
        var enum_word := new(str,int,ENTITY_NUM);
        enum_word := load(col_name+"enum_word");

        var cur_tmp := new(oid,oid,ENTITY_NUM);
        var ctx_tmp := new(oid,oid,TERM_NUM);
        var ctx_reg := new(oid,oid,ENTITY_NUM);

        cur_tmp:= ctx.child().mirror().join(entity_type).uselect('t').mirror().join(entity_pre);

        entity_type := nil;

        ctx_reg := [int]([str](word_pre.join(cur_tmp.reverse()).mirror().join(word_name).join(enum_word.reverse())));

        word_name := nil;
        enum_word := nil;

        var low := comp + 1;
        ctx_tmp := ctx_reg.select(comp,int(nil),false,false).mirror().join(word_pre);
        cur_tmp := entity_pre.join(ctx_tmp.reverse().mirror()).parent().mirror().join(ctx);

        word_pre := nil;
        entity_pre := nil;

        ctx := cur_tmp;

        return ctx;

}
#ADDHELP("gt", "vojkan", "Nov 14, 2003",
#"Performing greater than comparison between element content and integer.",
#"TIJAH");



################################################################################
# PRIOR
################################################################################

PROC prior_ls(bat region, int size_type) : bat := 
{

	var ctx_size := new(oid,dbl,ENTITY_NUM);
	var res_reg := new(oid,dbl,ENTITY_NUM);

	if (size_type = SIZE_ENTITY) {
		ctx_size := size_entity(region);
        # Make sure sizes are not zero      
        ctx_size := [+](ctx_size, dbl(0.5));
	} else if (size_type = SIZE_TERM) {
		ctx_size := size_term(region);
        # Make sure sizes are not zero      
        ctx_size := [+](ctx_size, dbl(0.5));
    }      
    

	res_reg := [+]([log](region.select(dbl(0),dbl(nil),false,false)),[log](ctx_size));
	res_reg := [-](region.select(dbl(0)).project(min(res_reg)),dbl(1)).kunion(res_reg);

	# res_reg := [+]([log](region),[*](dbl(3.0),[log](ctx_size)));

	# var ref_reg := new(oid,dbl,ENTITY_NUM);
	# var ref_size := new(oid,dbl,ENTITY_NUM);

	# var entity_name := load(collName+"entity_name");

	# var ref_name := entity_name.join(region.mirror().join(entity_name).reverse().mirror());
	# ref_reg := ref_name.project(dbl(1));

	# if (size_type = SIZE_ENTITY) {
	#	ctx_size := size_entity(region);
	#	ref_size := size_entity(ref_reg);
	# }
	# else if (size_type = SIZE_TERM) {
	#	ctx_size := size_term(region);
	#	ref_size := size_term(ref_reg);
	# }

	# ref_size := region.mirror().join(entity_name).join({sum}(ref_size.reverse().join(ref_name).reverse()));

	# res_reg := [*](region,[/](ctx_size,ref_size));

	return res_reg;

}
#ADDHELP("prior_ls", "vojkan", "March 16, 2005",
#"Adds element prior based on element length to the region score.",
#"TIJAH");



################################################################################
# ORDER
################################################################################

PROC order_regions(bat region) : bat :=
{

	region := region.reverse().sort_rev().reverse();

	return region;

}
#ADDHELP("order_regions", "vojkan", "March 29, 2005",
#"Order regions in descending order based on their score values.",
#"TIJAH");


##########################################
# Collection Management Functions
#
##########################################

# SUGAR, REMOVE IN FUTURE
PROC tj_global_init() : void 
{
	tj_init_global();
}

# SUGAR, REMOVE IN FUTURE
PROC tj_coll_init(str collName, str stemmer) : void
{
	var collpar := new(str,str);
	collpar.insert("stemmer",stemmer);
	tj_init_collection(collName,collpar);
}

# SUGAR, REMOVE IN FUTURE
PROC tj_global_remove() : void
{
	tj_delete_global();
}

# SUGAR, REMOVE IN FUTURE
PROC tj_coll_remove(str collName) : void
{
	tj_delete_collection(collName);
	commit();
}

# SUGAR, REMOVE IN FUTURE
PROC tj_collection(str collName) : BAT[void,bat]
{
	return _tj_collection(collName);
}

# SUGAR, REMOVE IN FUTURE
PROC tj_url2Collection(str doc, str url, str selTagList) : void
{
	tj_url2Collection(collName, doc, url, selTagList);
}

# SUGAR, REMOVE IN FUTURE
PROC tj_url2Collection(str collName, str doc, str url, str selTagList) : void
{ 
	tj_set_parameter(collName,"tagFilter",selTagList);
	_tj_add2collection(collName,_tj_collection(collName),url,doc,true);
}

# SUGAR, REMOVE IN FUTURE
PROC tj_url2Collection_index(str collName, str url, str selTagList) : void
{
	tj_set_parameter(collName,"tagFilter",selTagList);
	_tj_add2collection(collName,_tj_collection(collName),url,url,false);
}

# SUGAR, REMOVE IN FUTURE
PROC tj_finalize(str collName) : void
{
}

PROC _buildIRindex(str collName) : void :=
{
	var offset := oid(int(bat("tj_" + collName + "_param").find("_last_finalizedPre")) + 1);
	var frag_offset := int(find_lower(bat("tj_" + collName + "_fragments").reverse(), offset));
	var frag_last := bat("tj_" + collName + "_fragments").count();
	
	var pre_tid := bat("tj_" + collName + "_tid" + str(frag_offset));
	var tids := pre_tid.slice(int(offset), pre_tid.count() - 1);
	frag_offset :+= 1;
	while (frag_offset <= frag_last)
	{
	    	tids.append(bat("tj_" + collName + "_tid" + str(frag_offset)));
		frag_offset :+= 1;
	}	
	var tmp := tids.kdiff(bat("tj_" + collName + "_pfpre"));
        tmp := tmp.reverse().sort();

        # incremental index merge
	if (view_bbp_name().reverse().exist("tj_" + collName + "_TermIndex")) 
        {
	        var tmp := tids.kdiff(bat("tj_" + collName + "_pfpre"));
                tmp := tmp.reverse().sort();
                var i := mergeindex(tmp, bat("tj_" + collName + "_TermIndex"),
                                         bat("tj_" + collName + "_Terms"),
                                         bat("tj_globalTerms").count() + 1);       
	        bat("tj_" + collName + "_TermIndex").persists(false);
	        bat("tj_" + collName + "_Terms").persists(false);
                commit();
                # create _TermIndex and _Terms here
	        var newindex := i.fetch(0);
		newindex.persists(true).bbpname("tj_" + collName + "_TermIndex");
	        var newpre := i.fetch(1);
		newpre.persists(true).bbpname("tj_" + collName + "_Terms");
	        i := nil;
		tmp := nil;
	        newindex.access(BAT_READ);
	        newindex.mmap(1);
	        newpre.access(BAT_READ);
	        newpre.mmap(1);
	        newindex := nil;
	        newpre := nil;
	        commit();
	        
	        tmp := tids.semijoin(bat("tj_" + collName + "_pfpre"));
                tmp := tmp.reverse().sort();
                var i := mergeindex(tmp, bat("tj_" + collName + "_TagIndex"),
                                         bat("tj_" + collName + "_Tags"),
                                         bat("tj_globalTags").count() + 1);       
	        bat("tj_" + collName + "_TagIndex").persists(false);
	        bat("tj_" + collName + "_Tags").persists(false);
                commit();
                # create _TagIndex and _Tags here
	        var newindex := i.fetch(0);
	        newindex.persists(true).bbpname("tj_" + collName + "_TagIndex");
	        var newpre := i.fetch(1);
	        newpre.persists(true).bbpname("tj_" + collName + "_Tags");
	        i := nil;
		tmp := nil;
	        newindex.access(BAT_READ);
	        newindex.mmap(1);
	        newpre.access(BAT_READ);
	        newpre.mmap(1);
	        newindex := nil;
	        newpre := nil;
	        commit();
        }
        else # create new index
        {       
	        var tmp := tids.kdiff(bat("tj_" + collName + "_pfpre"));
                tmp := tmp.reverse().sort();
	        var termindex := tmp.hmark(0@0).offsetindex(bat("tj_globalTerms").count() + 1);
	        var terms := tmp.tmark(0@0);
	        # create _TermIndex and _Terms here
	        termindex.persists(true).bbpname("tj_" + collName + "_TermIndex");
	        terms.persists(true).bbpname("tj_" + collName + "_Terms");
	        tmp := nil;
	        termindex.access(BAT_READ);
	        termindex.mmap(1);
	        terms.access(BAT_READ);
	        terms.mmap(1);
	        termindex := nil;
	        terms := nil;
	        commit();
	        
	        tmp := tids.semijoin(bat("tj_" + collName + "_pfpre"));
                tmp := tmp.reverse().sort();
	        var tagindex := tmp.hmark(0@0).offsetindex(bat("tj_globalTags").count() + 1);
	        var tags := tmp.tmark(0@0);
	        # create _Tags and _Tagindex here
	        tagindex.persists(true).bbpname("tj_" + collName + "_TagIndex");
	        tags.persists(true).bbpname("tj_" + collName + "_Tags");
	        tmp := nil;
	        tagindex.access(BAT_READ);
	        tagindex.mmap(1);
	        tags.access(BAT_READ);
	        tags.mmap(1);
	        tagindex := nil;
	        tags := nil;
	        commit();
        }
}

######################################
# PF interface functions
#
######################################

#PROC tijah2pf(BAT[oid,dbl] pre_score) : BAT :=
#{
#	var docpre := bat("tj_" + collName + "_doc_firstpre").[oid]();
#	var pfpre :=  bat("tj_" + collName + "_pfpre");
#	
#	var item := pre_score.hmark(0@0);
#	var score := pre_score.tmark(0@0);
#	var iter := item.mirror();
#	var frag := [find_lower](const docpre.reverse().mark(0@0), item);
#	item := item.join(pfpre).sort().tmark(0@0);
#	
#	var res := new(void,bat);
#	res.append(iter);
#	res.append(item);
#	res.append(frag);
#	res.append(score);
#	return res;
#}

# align_frag assumes the following variable to be global to its scope:
# frag, kind, ipik, ws
# StM: 
# Is this a dead PROC? 
# At least I could not find any place where it is called or referred to.
# If so, it should be removed from the code base!
PROC align_frag() : void :=
{
	var needed_docs := bat("tj_" + collName + "_doc_name").semijoin(frag.tunique());
	var loaded_docs := ws.fetch(DOC_LOADED).reverse();
	var docs_to_load := kdiff(needed_docs.reverse(),loaded_docs).hmark(0@0);
	ws_opendoc(ws, docs_to_load);
	var fid_pffid := needed_docs.join(ws.fetch(DOC_LOADED).reverse());
	frag := frag.join(fid_pffid).sort().tmark(0@0);
	kind := set_kind(frag, ELEM);
	ipik := iter;
}

@h

#define ENABLE_TDEBUG

#ifdef ENABLE_TDEBUG
extern int pftijah_debug;
#define SET_TDEBUG(V) pftijah_debug = V
#define TDEBUG(V) (pftijah_debug && (((V<=pftijah_debug)&&(pftijah_debug<100)) || ((V==pftijah_debug)&&(pftijah_debug>=100))) )
#else
#define SET_TDEBUG(V)
#define TDEBUG(V) 0
#endif

#define TJ_TIMINGS 777

@c
#include <pf_config.h>

#include <monet.h>
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include <math.h>

#include <pathfinder.h>

#include "pftijah.h"

#include "termdb.h"

#ifdef ENABLE_TDEBUG
/* 
 * The main pftijah variable, settable from the command line by the
 * <TijahOptions debug=number ..... from the query env.
 * Current strategy is not to reset the debug variable after the query
 * finished and to make it a global for ease of use.
 * The number has three possiblilities:
 * 0             : no debug
 * 1   - 99      : leveled debug
 * 100 - INT_MAX : debug a specific event 
 *
 * usage: if (TDEBUG ) expression
 */
int pftijah_debug = 0;
#endif

int executeMIL(char* str) {
    return monet_exec(str);
}

int CMDtijah_command(bit* res, str command) {
	if ( 0 ) stream_printf(GDKout,"# tijah_command(%s)\n",(char*)command);
	*res = executeMIL(command); /* OK */
	return GDK_SUCCEED;
}

extern char* tijahParse(BAT* optbat, char* startNodes_name, char* query, char** errBUFF);

static int nexiTmpCounter = 0;

int CMDtijah_query(BAT** res, BAT* optbat, BAT* startNodes, str query) {
	char* err;
	char* mil;
	char  nameBUFF[32], *startNodes_name;
	int   use_startNodes;

	if (TDEBUG(1)) stream_printf(GDKout,"# CMDtijah_query: start, query=\"%s\".\n",query);
	use_startNodes = BATcount(optbat); /* INCOMPLETE, redesign this */
	if ( use_startNodes ) {
	    BATmode(startNodes,PERSISTENT);
	    sprintf(&nameBUFF[0],"%s%d","nexi_start",nexiTmpCounter++);
	    /* make persistent, the generated script should undo this again */
	    if ( BBPrename(startNodes->batCacheid,(str)&nameBUFF[0]) != 0) {
                GDKerror("CMDtijah_query: fail to name startNode bat: \"%s\".\n", &nameBUFF[0]);
	        return GDK_FAIL;
	    }
	    startNodes_name = &nameBUFF[0];
	} else {
	    startNodes_name = NULL;
	}

	if ( !optbat ) {
            GDKerror("CMDtijah_query: missing option bat.\n");
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: call tijahParse.\n");
	if ( !(mil=tijahParse(optbat,startNodes_name,query,&err)) ) {
            GDKerror("CMDtijah_query: %s.\n", err);
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: finish tijahParse.\n");
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: start MIL script.\n");
	if (TDEBUG(9)) {
		stream_printf(GDKout,"# CMDtijah_query: generated MIL script:\n");
		stream_printf(GDKout,"%s",mil);
		stream_printf(GDKout,"# CMDtijah_query: end of MIL script:\n");
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: start executing MIL script.\n");
        if ( executeMIL(mil)<0 ) {
            GDKerror("CMDtijah_query: execute MIL failed.\n");
	    return GDK_FAIL;
	}
	if (TDEBUG(2)) stream_printf(GDKout,"# CMDtijah_query: finish MIL script.\n");
	BAT* scoreBAT = BATdescriptor( BBPindex("nexi_result") );

	if (TDEBUG(3)) stream_printf(GDKout,"# CMDtijah_query: sizeof scoreBAT = %d.\n",BATcount(scoreBAT));
	if (TDEBUG(9)) {
	    stream_printf(GDKout,"# CMDtijah_query: scoreBAT:\n");
	    BATprintf(GDKout,scoreBAT);
	}

	if ( ! scoreBAT ) {
            GDKerror("CMDtijah_query: fail to load score bat: \"%s\".\n", "nexi_result");
	    return GDK_FAIL;
        }
	sprintf(&nameBUFF[0],"%s_del%d","nexi_result",nexiTmpCounter++);
	if ( BATrename(scoreBAT,(str)&nameBUFF[0]) == str_nil ) {
            GDKerror("CMDtijah_query: fail to rename score bat: \"%s\".\n", &nameBUFF[0]);
	    return GDK_FAIL;
	}
	BATmode(scoreBAT,TRANSIENT);

	*res = scoreBAT;

	if (TDEBUG(1)) stream_printf(GDKout,"# CMDtijah_query: finish.\n");
        return GDK_SUCCEED;
}

char* tijah_tokenize_string(char* buf, int len, char* outbuf);

int CMDtijah_tokenize (str* res, str arg)
{
	int sz    = strlen(arg);
	char* buf = GDKmalloc(sz + 1);

	buf[0] = 0;
	*res = tijah_tokenize_string(arg,sz,buf);

	return GDK_SUCCEED;
}

int CMDpf2tijah_node(BAT** res, BAT* doc_name, BAT* doc_firstpre, BAT* doc_pfpre, BAT* item, BAT* kind, BAT* doc_loaded ) {
        int debug = 0;

	int nDocs = BATcount(doc_loaded);
	BAT **rangeBAT = (BAT**)GDKmalloc(nDocs*sizeof(BAT*));
	for(int i=0; i<nDocs; i++) {
	    rangeBAT[i] = NULL;
        }

	*res = BATnew(TYPE_void, TYPE_oid, BATcount(item));

        if ( debug ) stream_printf(GDKout,"* Start of CMDpf2tijah_node():\n");
	if ( 1 && debug ) {
	    BATprintf(GDKout,item);
	    BATprintf(GDKout,kind);
	    BATprintf(GDKout,doc_loaded);
	}
	if ( 0 && debug ) {
	    BATprintf(GDKout,doc_name);
	    BATprintf(GDKout,doc_firstpre);
	    BATprintf(GDKout,doc_pfpre);
	}

	int x;
	BUN p,q;
	BATloopFast(item, p, q, x) {
	    oid idx      = *(oid*) BUNhead(item, p);
	    ptr itemTAIL = BUNtail(item, p);
	    oid pfpre    = *(oid*) itemTAIL;

	    BUN kindBUN = BUNfnd(kind,&idx);
	    if ( !kindBUN ) {
	        stream_printf(GDKout,"READ KIND failed\n");
		return GDK_FAIL;
	    }
	    ptr kindTAIL = BUNtail(kind, kindBUN);
	    int kval = *(int*)kindTAIL;
	    if ( XTRACT_KIND(kval) != ELEM ) {
	        stream_printf(GDKout,"CMDpf2tijah_node: startNodes: no node\n");
		return GDK_FAIL;
            }
	    oid container = (oid)XTRACT_CONT(kval);

	    int myindex = container - 1;
	    /* make it a switch */
	    if ( rangeBAT[myindex] == NULL ) {
	        oid doc_start;
		oid doc_end;

	        BUN xbun = BUNfnd(doc_loaded,&container);
		if ( ! xbun ) {
	    	    stream_printf(GDKout,"Cannot find cont %d.\n",container);
		    return GDK_FAIL;
		}
		str docname = (str)BUNtail(doc_loaded,xbun);
		BAT* b = BATmirror(doc_name);
	        BUN yy = BUNfnd(b,docname);
		if ( yy ) {
		    oid tj_docIndex = *(oid*)BUNtail(b,yy);

		    BUN r;
		    r = BUNfnd(doc_firstpre,&tj_docIndex);
		    if ( ! r ) {
	    	        stream_printf(GDKout,"Cannot find tijah-firstpre @  %d.\n",tj_docIndex);
		        return GDK_FAIL;
		    }

	            doc_start = *(oid*)BUNtail(doc_firstpre,r);
		    oid tj_nextIndex = tj_docIndex +  1;
		    if ( BATcount(doc_firstpre) > tj_nextIndex ) {
		        r = BUNfnd(doc_firstpre,&tj_nextIndex);
			if ( !r ) {
	    	            stream_printf(GDKout,"Cannot do range for tijah-firstpre @  %d.\n",tj_docIndex);
			    return GDK_FAIL;
			}
	                doc_end = *(oid*)BUNtail(doc_firstpre,r) - 1;
		    } else {
	                doc_end = oid_nil;
		    }
		    rangeBAT[myindex] = BATselect(BATmirror(doc_pfpre),(ptr)&doc_start,(ptr)&doc_end);
		    if ( 0 && debug ) BATprintf(GDKout,rangeBAT[myindex]);
		} {
		    /* else skip */
		} }
	        if ( rangeBAT[myindex] ) {
		    BUN range_bun = BUNfnd(rangeBAT[myindex],&pfpre);
		    if ( range_bun ) {
			/* found the tijah index value */
		        oid tj_index = *(oid*)BUNtail(rangeBAT[myindex],range_bun);
			BUNappend(*res,&tj_index,1);
			if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = tijah(%d@0).\n", pfpre, container,tj_index);
		    } else {
		        if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = NOT INDEXED.\n", pfpre, container);
		    }
		    
		} else {
			if ( debug ) stream_printf(GDKout,"* pf2tijah_index: pre(%d@0) @ cont(%d) = NOT INDEXED.\n", pfpre, container);
		}
	}
	/* cleanup BAT's */
	for(int i=0; i<nDocs; i++) {
	    if ( rangeBAT[i] ) {
	        BBPunfix(BBPcacheid(rangeBAT[i]));
		rangeBAT[i] = NULL;
	    }
        }
	GDKfree(rangeBAT);

	*res = BATmirror(BATmark(BATmirror(*res), 0));

	/* */
	if ( debug ) 
	    BATprintf(GDKout,*res);
	/* */
        return GDK_SUCCEED;
}

int CMDoffsetindex ( BAT** result, BAT* tid, int* res_size )
{
	char *name = "TJoffsetindex";
	BAT *res = NULL;
        BUN p, q, dst = NULL;
	oid t, s;
	int bs_res, x;

	/* --------------------------- checks ---------------------------------- */

	BATcheck(tid, name);
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: index-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}
	if (!(BAThdense(tid)))
    	{
        	GDKerror("%s: index-bat must have a dense head.\n", name);
    		return GDK_FAIL;
	}
		
	/* ---------------------------- inits ---------------------------------- */

	res = BATnew(TYPE_void, TYPE_oid, *res_size);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, *res_size);
            	return(GDK_FAIL);
        }
	bs_res = BUNsize(res);
	dst = BUNlast(res);
    
	t = (oid)0;
	*(oid*)dst = (oid)0;
	dst += bs_res;
	
	/* ----------------------------- main ---------------------------------- */

	BATloopFast(tid, p, q, x)
	{
		s = *(oid*) BUNtail(tid, p);
		if (t != s)
		{
			for(; t < s; t++)
			{
				*(oid*)dst = BUNindex(tid, p);
				dst += bs_res; 
			}
		}
	}

	s = (oid) (*res_size - 1);
	for(; t < s; t++)
	{
		*(oid*)dst = BUNindex(tid, p);
		dst += bs_res; 
	}
	
	/* ---------------------------- tidy up --------------------------------- */
	
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->tsorted = GDK_SORTED;
        BATkey (res, TRUE);
	BATset(res, TRUE);
	BATseqbase(res, 0);
	
	*result = res;
	return GDK_SUCCEED;
}	

int CMDmergeindex ( BAT** result, BAT* tidpre, BAT* oldindex, BAT* oldpre, int* indsize )
{
	char *name = "TJmergeindex";
	BAT *res = NULL;
	BAT *newindex = NULL;
	BAT *newpre = NULL;
	int bs_tidpre, bs_oldindex, bs_oldpre, bs_newindex, bs_newpre, bs_res;
	int i,j, ressize = 0;
        BUN lst_tidpre, lst_oldindex, lst_copy, lst_newindex, lst_newpre, lst_res, cur_tidpre, cur_oldindex, cur_oldpre;
	oid tid;
	
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tidpre, name);
	BATcheck(oldindex, name);
	BATcheck(oldpre, name);
        
	if (!(BAThordered(tidpre) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	/* ---------------------------- inits ---------------------------------- */

	ressize = 2;
	res = BATnew(TYPE_void, TYPE_bat, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = BATcount(tidpre) + BATcount(oldpre);
	newpre = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	ressize = *indsize;
	newindex = BATnew(TYPE_void, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[void,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	
	bs_tidpre = BUNsize(tidpre);
	bs_oldindex = BUNsize(oldindex);
	bs_oldpre = BUNsize(oldpre);
        bs_newindex = BUNsize(newindex);
        bs_newpre = BUNsize(newpre);
	bs_res = BUNsize(res);
	
	lst_tidpre = BUNlast(tidpre);
	lst_oldindex = BUNlast(oldindex) - bs_oldindex; /* last index is not a real term */
	lst_newindex = BUNlast(newindex);
	lst_newpre = BUNlast(newpre);
	lst_res = BUNlast(res);
	
	cur_tidpre = BUNfirst(tidpre);
	cur_oldindex = BUNfirst(oldindex);
	cur_oldpre = BUNfirst(oldpre);
	
	/* ----------------------------- main ---------------------------------- */
	
	j = *indsize - 1;
	for(i = 0; i < j; i++)
        {
	        tid = (oid) i;
		*(oid*)lst_newindex = BUNindex(newpre,lst_newpre);
		lst_newindex += bs_newindex;
               
                /* copy old nodes to new index */
                if (cur_oldindex < lst_oldindex && tid == *(oid*)BUNhead(oldindex, cur_oldindex))
                {
		        lst_copy = BUNptr(oldpre, *(int*) BUNtail(oldindex, cur_oldindex + bs_oldindex));
		        while (cur_oldpre < lst_copy)
		        {
			        *(oid*)lst_newpre = *(oid*)BUNtail(oldpre, cur_oldpre);
			        lst_newpre += bs_newpre;
			        cur_oldpre += bs_oldpre;
		        }
                        cur_oldindex += bs_oldindex;
                }
                /* merge-in new nodes */
                while(cur_tidpre < lst_tidpre && tid == *(oid*)BUNhead(tidpre, cur_tidpre))
                {
                        *(oid*)lst_newpre = *(oid*)BUNtail(tidpre, cur_tidpre);
			lst_newpre += bs_newpre;
	        	cur_tidpre += bs_tidpre;
                }
        }

	/* write limit of index as last item to index bat */
	*(oid*)lst_newindex = BUNindex(newpre,lst_newpre);
	lst_newindex += bs_newindex;

	/* ---------------------------- tidy up --------------------------------- */

	newindex->batBuns->free = lst_newindex - newindex->batBuns->base;
	BATsetcount(newindex, newindex->batBuns->free / bs_newindex);
    	newindex->batDirty = TRUE;
        newindex->hsorted = GDK_SORTED;
        newindex->tsorted = GDK_SORTED;
        BATkey(newindex, TRUE);
        BATkey(BATmirror(newindex), FALSE);
	BATseqbase(newindex, (oid)0);

	newpre->batBuns->free = lst_newpre - newpre->batBuns->base;
	BATsetcount(newpre, newpre->batBuns->free / bs_newpre);
    	newpre->batDirty = TRUE;
        newpre->hsorted = GDK_SORTED;
        newpre->tsorted = FALSE;
        BATkey(newpre, TRUE);
        BATkey(BATmirror(newpre), TRUE);
	BATseqbase(newpre, (oid)0);
	
        /* insert bats in result */		
	BATseqbase(res, (oid)0);
	voidany_bunfastins_nocheck_noinc(res, lst_res, 0, &newindex->batCacheid);
	BBPunfix(newindex->batCacheid);	
	lst_res += bs_res;
	voidany_bunfastins_nocheck_noinc(res, lst_res, 0, &newpre->batCacheid); 
	BBPunfix(newpre->batCacheid);	
	lst_res += bs_res;
	
	res->batBuns->free = lst_res - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
	res->batDirty = TRUE;
	BATkey(res, TRUE);
	BATkey(BATmirror(res), TRUE);
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
	
	*result = res;
	return GDK_SUCCEED;

bunins_failed:
        GDKerror("%s: BUN insert failed.\n", name);
        return(GDK_FAIL);
	
}

int CMDindexfetchjoin ( BAT** result, BAT* tid, BAT* index, BAT* pre )
{
	char *name = "TJindexfetchjoin";
	BAT *res = NULL;
        BUN dst = NULL;
	int bs_pre = BUNsize(pre);
	int bs_res;

	int ressize = 0;
	oid t, *ind;
	BUN p, q;
        int x, j, i = 0;
	/* bit one_tid = FALSE; */
    
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(tid, name);
	BATcheck(index, name);
	BATcheck(pre, name);
	
        /* if (BATcount(tid) <= 1) one_tid = TRUE; */
	
	if (!(BATtordered(tid) & 1))
	{
        	GDKerror("%s: term-bat must be ordered on tail.\n", name);
    		return GDK_FAIL;
	}

	/* ---------------------------- inits ---------------------------------- */

	ind = GDKmalloc(sizeof(oid) * BATcount(tid) * 3);
        if (ind == NULL) 
        { 
            	GDKerror("%s: could not allocate a offset stack of size %d.\n", name, BATcount(tid));
            	return(GDK_FAIL);
        }
	
	BATloopFast(tid, p, q, x) {
		t = *(oid*) BUNtail(tid, p);
		ind[i++] = t;
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t));
		ind[i++] = *(oid*) BUNtloc(index, BUNptr(index, (int)t + 1));
		ressize += (ind[i - 1] - ind[i - 2]);
	}
	
	res = BATnew(TYPE_oid, TYPE_oid, ressize);
        if (res == NULL) 
        { 
            	GDKerror("%s: could not allocate a result BAT[oid,oid] of size %d.\n", name, ressize);
            	return(GDK_FAIL);
        }
	bs_res = BUNsize(res);
	dst = BUNlast(res);
	
	/* ----------------------------- main ---------------------------------- */

	j = 0;
	while (j < i) {
        	t = ind[j++];
		p = BUNptr(pre, ind[j++]);
		q = BUNptr(pre, ind[j++]);
		for (; p < q; p += bs_pre) {
			*(oid*)dst = t;
			*(oid*)(dst + SIZEOF_OID) = *(oid*)p;
			dst += bs_res;
		}
	}

	/* ---------------------------- tidy up --------------------------------- */

	GDKfree(ind);
	res->batBuns->free = dst - res->batBuns->base;
	BATsetcount(res, res->batBuns->free / bs_res);
    	res->batDirty = TRUE;
        res->hsorted = GDK_SORTED;
        res->tsorted = FALSE;
        BATkey (BATmirror(res), TRUE);
	BATset(res, TRUE);
	
	*result = res;
	return GDK_SUCCEED;
}

@= init_result
{
	REGISTER BUN _p = BUNlast(bn);
	REGISTER int _bunsize = BUNsize(bn);

	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		oiddbl_bunfastins_nocheck_noinc(bn, _p, BUNhloc(e,p), &zero);
		_p += _bunsize;
	}
	ALGODEBUG THRprintf(GDKout, "#init_result(dbl): BAThordered(e)&1, \n");
	bn->batBuns->free = _p - bn->batBuns->base;
	BATsetcount(bn, bn->batBuns->free/_bunsize);
	if ( !BATprepareHash(bn) ) {
	    /* do nothing yet */;	
	}
	if (!bn->batDirty)
		bn->batDirty = TRUE;
}
@
@c
int CMDscore_NLLR ( BAT** result, BAT* elem_tid, BAT* pre_size, BAT* tid_cnt, BAT* tid_frq, BAT* e, dbl* _lmbd, int* q_cnt )
{
	char *name = "TJscore_NLLR";
	BAT *bn;
	dbl zero = (dbl)0;
	dbl score = (dbl)0; 
	BUN p, q, r, t;
	int xx, i;
	int term_cnt = (int)BATcount(tid_frq);
	int est;
	int *size = ((int*) BUNtloc(pre_size, BUNfirst(pre_size))) - (int)pre_size->hseqbase;
        int bs_x, bs_t;
	int tid_sum = 0;

	oid* terms = (oid*) GDKmalloc(term_cnt * sizeof(oid));
	dbl* facs = (dbl*) GDKmalloc(term_cnt * sizeof(dbl));
	BAT** bats = (BAT**) GDKmalloc(term_cnt * sizeof(BAT*)); 
        BUN* dsts = (BUN*) GDKmalloc(term_cnt * sizeof(BUN));
	int* bfrees = (int*) GDKmalloc(term_cnt * sizeof(int));
	
	/* --------------------------- checks ---------------------------------- */
	
	BATcheck(elem_tid, name);
	BATcheck(pre_size, name);
	BATcheck(tid_cnt, name);
	BATcheck(tid_frq, name);

	/* ---------------------------- main ----------------------------------- */

	i = 0;
	BATloopFast(tid_frq, p, q, xx) {
		int frq = *(int*) BUNtail(tid_frq, p);
		tid_sum += frq;
		facs[i] = *_lmbd / (dbl)frq;
		terms[i] = *(oid*) BUNhead(tid_frq, p);
		bfrees[i] = frq;
		/* printf("fac term: %f, _lambda %f, frq %d\n", facs[i], *_lmbd, *(int*) BUNtail(tid_frq, p)); */
		i++;
	}
	
	est = (int)BATcount(elem_tid);
	/* printf("term-count: %d\n",term_cnt); */

	for(i = 0; i < term_cnt; i++) {
	        dbl est2 = (est * (dbl)bfrees[i]) / (dbl)tid_sum;
		bats[i] = BATnew(TYPE_void, TYPE_oid, (int)est2);
		dsts[i] = BUNlast(bats[i]);
		bfrees[i] = (int)est2;
	}
        bs_x = BUNsize(bats[0]);
	
        /* init result */
 	bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	if (bn == NULL)
		return GDK_FAIL;
	@:init_result@
	

	BATloopFast(elem_tid, p, q, xx) {
		oid *h = (oid*) BUNhead(elem_tid, p);
		oid *t = (oid*) BUNtail(elem_tid, p);
		
		for(i = 0; i < term_cnt; i++)  
			if (terms[i] == *t) { 
				if (!bfrees[i]) {
					bats[i]->batBuns->free = dsts[i] - bats[i]->batBuns->base;
	        			BATsetcount(bats[i], (bats[i]->batBuns->free+Bunbase(bats[i])-BUNfirst(bats[i]))/bs_x);
				        int sz = BATcount(bats[i]);
					BATextend(bats[i],2*sz); 
					dsts[i] = BUNlast(bats[i]);
					bfrees[i] = sz;
				}
				*(oid*)dsts[i] = *h;
				dsts[i] += bs_x;
				bfrees[i]--;
				break;
			}
		if (i == term_cnt) {
			GDKerror("WARNING:%s: cannot find term " OIDFMT ".\n",name,*t);
	        }
	}

        t = BUNfirst(tid_cnt);
        bs_t = BUNsize(tid_cnt);
	for(i = 0; i < term_cnt; i++) {
		dbl fac = *(int*) BUNtail(tid_cnt, t) / (dbl)*q_cnt;
		/*printf("fac: %f\n", fac); */
		t += bs_t;
		bats[i]->batBuns->free = dsts[i] - bats[i]->batBuns->base;
	        BATsetcount(bats[i], (bats[i]->batBuns->free+Bunbase(bats[i])-BUNfirst(bats[i]))/bs_x);
		BAT *tmp = BAThistogram(bats[i]);
		BATloopFast(tmp, p, q, xx) {
			oid *h = (oid*) BUNhloc(tmp, p);
			int *t = (int*) BUNtloc(tmp, p);
			score = (dbl)*t / (dbl)size[*h];
			score *= facs[i];
			score++;
			score = log(score);
			score *= fac;
			HASHfnd_oid(r, bn, h);
			if (r) {
					dbl *dst = (dbl*) BUNtloc(bn,r);
					(*dst) += score;
			       } 
			else GDKerror("%s: jan was right again.\n",name);     
		}
		BBPreclaim(tmp);
		BBPreclaim(bats[i]);
	}
        
        GDKfree(terms);
	GDKfree(facs);
	GDKfree(bats);
	GDKfree(dsts);
	
	*result = bn;
	return GDK_SUCCEED;
}
@
@= push
    si new_stack_item;
    new_stack_item.ctx = *A_cur_start;
    new_stack_item.eocs = *A_cur_start + size[*A_cur_start];
    stack[stack_top++] = new_stack_item;
@
@= pop
    stack_top--;
@
@c
#define max_stack_size 128

typedef struct stack_item si;

struct stack_item {
    oid ctx;            /* ctx */
    oid eocs;           /* end of ctx scope (pre + size) */
};

int CMDtreemergejoin_sort(BAT **result, BAT *Astart, BAT *pre_size, BAT *Dstart) {

    /* ---------------------------- declarations ------------------------------------ */
    BAT *res = *result;
    oid *D_cur_start, *D_last_start, 
        *A_cur_start, *A_last_start;
   
    si *stack; 
    int stack_top = 0, i;
	
    int SAs;
    int SDs;
    int SRs;
    int *size;
    
    BUN dst = NULL;
    
    /* ------------------------------- checks ---------------------------------------- */
    if (!(BATtordered(Astart)&1)) { 
        GDKerror("treemergejoin_sort_proper: Ancestor pre BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(Dstart)&1)) { 
        GDKerror("treemergejoin_sort_proper: Descendant BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }

    /* ----------------------------- initialize -------------------------------------- */
    // The maximum depth of the stack is the depth of the XML tree
    if ((stack = (si*)GDKmalloc(sizeof(si) * max_stack_size)) == NULL) {
        GDKerror("treemergejoin_sort: could not allocate memory for stack.\n"); 
        return(GDK_FAIL);
    }

    // the size of the bat may not be correct (could be more, could be less)
    res = BATnew(TYPE_oid, TYPE_oid, BATcount(Dstart)); 
    
    /* todo: what if size is not a multiple of sizeof(oid)  (BUNsize(...) % sizeof(oid) != 0) */
    SAs = BUNsize(Astart) / SIZEOF_OID;
    SDs = BUNsize(Dstart) / SIZEOF_OID;
    SRs = BUNsize(res);
    size = ((int*) BUNtloc(pre_size, BUNfirst(pre_size))) - (int)pre_size->hseqbase;
    D_cur_start = (oid *) BUNtail(Dstart, BUNfirst(Dstart));
    D_last_start = (oid *) BUNtail(Dstart, BUNlast(Dstart));  
    A_cur_start = (oid *) BUNtail(Astart, BUNfirst(Astart));
    A_last_start = (oid *) BUNtail(Astart, BUNlast(Astart));
    dst = BUNlast(res);

    /* -------------------------------- main ---------------------------------------- */
    while(D_cur_start < D_last_start) {
      
      /* printf("0. eocs: %d, desc: %d\n", stack[stack_top-1].eocs, *D_cur_start); */
      
      /* remove ancestor candidates that ended before D_cur_start */
      while (stack_top && *D_cur_start > stack[stack_top-1].eocs) {
        @:pop@
      }	
      
      /* printf("1.stacksize: %d\n", stack_top); */
      
      /* Put ancestors on stack until we reach the current descendent */ 
      while (*A_cur_start < *D_cur_start && A_cur_start < A_last_start){		
	if (*D_cur_start <= (*A_cur_start + size[*A_cur_start])) {
	   @:push@
	}
	A_cur_start += SAs;
      }
      
      /* printf("2.stacksize: %d\n", stack_top); */

      /* output everything that is on the stack (the ancestors) */
      /* It has started before Dstart and since it's a tree, */
      /* it has to end after Dend. */
      /* for (; D_cur_start < D_last_start && *D_cur_start < *A_cur_start; D_cur_start += SDs) { */
        for (i=0;i<stack_top;i++) {
          /* printf("3. anc/desc: (%d/%d)\n", stack[i].ctx, *D_cur_start); */
          *(oid*)dst              = stack[i].ctx;
          *(oid*)(dst+SIZEOF_OID) = *D_cur_start;
          dst += SRs;
        }
      /*} */
        D_cur_start += SDs;
    }
    
    /* ----------------------------- tidy up -------------------------------------- */
     GDKfree(stack); 
	
     res->batBuns->free = dst - res->batBuns->base;
     BATsetcount(res, (res->batBuns->free+Bunbase(res)-BUNfirst(res))/SRs);
     res->batDirty = TRUE;
     res->tsorted = GDK_SORTED;
     BATset(res, TRUE);
     
     *result = res;    
     /* it is possible there are still ancestor candidates left on the stack, but we are out of descendants, so they starve... */
     return(GDK_SUCCEED);
}
@
@c
bat* pftijah_prelude() {
    termdb_prelude();
    return NULL;
}

void pftijah_epilogue() {
}
@

/* vim:set shiftwidth=4 expandtab: */
