==================
How SOAP RPC Works
==================

.. This document is written in reStructuredText (see
   http://docutils.sourceforge.net/ for more information).
   Use ``rst2html.py`` to convert this file to HTML.

In this document, we first explains how SOAP RPC can be use in MonetDB/XQuery
to carry out XQuery queries on remote hosts by several examples.  In the
second section, we elaborate how the examples given in the first section
are implemented.

*****
Usage
*****

The SOAP RPC support in MonetDB/XQuery consists of two parts, an SOAP
RPC receiver and an SOAP RPC sender (henceforth just SOAP receiver and
SOAP sender).


SOAP RPC receiver
-----------------

The SOAP receiver can be started in ``Mserver`` with the following
commands::

    MonetDB>module(pf_soap);
    MonetDB>soap_receiver_start();

By default, the SOAP receiver listens to the port number 8080, because
it runs on top of an HTTP connection.  The command
``soap_receiver_start(<portnr>)`` can be used to specify another port
number to use.


Make SOAP RPC calls
-------------------

The SOAP sender is automatically used if a RPC call is made in an XQuery
query.  An XQuery function call is interpreted as an RPC if a special
namespace identifier, currently 'soap', is used.  All RPC functions need
an additional leading string parameter, which provides the destination
URI in the form ``<uri>[:port]``.

All functions that can be called by using the RPC technique are
predefined.  In pathfinder, functions that are available for RPCs are
pre-declared in modules.  For all examples in this documentation, the
following module declaration is used::

    module namespace soap = "http://www.cwi.nl/~zhang/soap/";

    declare function soap:convert($v as xs:double?) as xs:double?
    {
        (: convert Dfl to Euro  :)
        2.20371 * $v
    };

    declare function soap:add($v1 as xs:decimal, $v2 as xs:decimal*) as
    xs:decimal* 
    {
        let $res := $v1 
        for $i in $v2  
            return $res + $i 
    }; 

    declare function soap:returnNode($v as xs:anyNode*) 
        as xs:anyNode*
    { 
        $v
    }; 

    declare function soap:concatStr($v1 as xs:string, $v2 as xs:string)
    as xs:string
    {
        concat($v1, $v2)
    };

    declare function soap:plays($actor as xs:string) as xs:string*
    {
        (: returns names of all films that have been played :)
        (: by the given actor :)
        (: see also "Example 4" below :)
        (: please correct me if this query contains error :)

        let $films := doc("filmDB.xml")
        for $f in $films//film
        where $f/actorName/text() = $actor
        return $f/filmName/text()
    };

Example 1: simple case
~~~~~~~~~~~~~~~~~~~~~~

If we want to let the host "bar.foo.org" carry out the function "add",
we use the "soap" namespace identifier to indicate that it is a SOAP RPC
call, pass an additional leading string as the destination URI::

    import module namespace soap = "http://www.cwi.nl/~zhang/soap/" at
        "http://www.cwi.nl/~zhang/soap/soap.xq";

    soap:add("bar.foo.org", 40, (20, 40))

If the output mode "xml" is used, this query should return the following
results::

    <?xml version="1.0" encoding="utf-8"?>
    <XQueryResult>
    60.000000 80.000000
    </XQueryResult>


Example 2: XML tree node as parameter
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

XML tree nodes can also be passed as function parameters.  It usage is
as simple as the previous example::

    import module namespace soap = "http://www.cwi.nl/~zhang/soap/" at
        "http://www.cwi.nl/~zhang/soap/soap.xq";

    soap:returnNode("bar.foo.org",
                    doc("http://www.cwi.nl/~zhang/soap/soap.xml"))

If the output mode "xml" is used, this query should return the following
results::

    <?xml version="1.0" encoding="utf-8"?>
    <XQueryResult>
    <foo>
        <hello>
        <world>
        </world>
        </hello>
    </foo><foo>
        <hello>
        <world>
        </world>
        </hello>
    </foo>
    </XQueryResult>


Example 3: multi-iterations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

SOAP RPC calls can be included in 'for' loops.  In the next section, we
will explain how the following multiple SOAP RPC calls can be handles by
sending only one message to the destination::

    import module namespace soap = "http://www.cwi.nl/~zhang/soap/" at
        "http://www.cwi.nl/~zhang/soap/soap.xq";

    for $i in (10, 20, 30)
        return soap:convert("bar.foo.org", $i)

If the output mode "xml" is used, this query should return the following
results::

    <?xml version="1.0" encoding="utf-8"?>
    <XQueryResult>
    22.037100 44.074200 66.111300
    </XQueryResult>

Example 4: multi-destinations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

'(Note: support for multi-destinations is not implemented yet, but it has
high priority on the TODO list)'

Sometimes, we might want to make the same RPC call to multiple hosts.
This is useful in case a big XML database is distributed among several
hosts, and we want to carry out our query on all those hosts to get all
necessary information.

For example, a big XML database, "filmDB.xml", in which actor names are
mapped to the film names they have played, is distributed between two
hosts.  The host "bar.org" has the following data::

    <filmDB>
      <film>
        <filmName>Notting Hill</filmName>
        <actorName>Hugh Grant</actorName>
      </film>

      <film>
        <filmName>Legends of the Fall</filmName>
        <actorName>Brad Pitt</actorName>
      </film>

      <film>
        <filmName>From Russia with Love</filmName>
        <actorName>Sean Connery</actorName>
      </film>

      <film>
        <filmName>The Rock</filmName>
        <actorName>Sean Connery</actorName>
      </film>
    </filmDB>
 
The host "foo.org" contains the other fraction of "filmDB.xml"::

    <filmDB>
      <film>
        <filmName>Seven Years In Tibet</filmName>
        <actorName>Brad Pitt</actorName>
      </film>

      <film>
        <filmName>Two Weeks Notice</filmName>
        <actorName>Hugh Grant</actorName>
      </film>

      <film>
        <filmName>Troy</filmName>
        <actorName>Brad Pitt</actorName>
      </film>

      <film>
        <filmName>You Only Live Twice</filmName>
        <actorName>Sean Connery</actorName>
      </film>

      <film>
        <filmName>First Knight</filmName>
        <actorName>Sean Connery</actorName>
      </film>
    </filmDB>

Suppose we only know that "filmDB.xml" is distributed between those two
hosts, and we want to search in "filmDB.xml" to see in which film Sean
Connery and Brad Pitt have acted.  In this case, we can use the
following query (please correct me if this query contains error)::

    import module namespace soap = "http://www.cwi.nl/~zhang/soap/" at
        "http://www.cwi.nl/~zhang/soap/soap.xq";

    for $dst in ("foo.org", "bar.org")
        for $actor in ("Sean Connery", "Hugh Grant")
            for $film in soap:plays($dst, $actor)
                return <actor>
                            $actor
                            <film>$film</film>
                        </actor>

If the output mode "xml" is used, this query should return the following
results (note: the node order is random)::

    <?xml version="1.0" encoding="utf-8"?>
    <XQueryResult>
    <actor>Hugh Grant
        <film>Notting Hill</film>
        <film>Two Weeks Notice</film>
    </actor>
    <actor>Sean Connery
        <film>From Russia with Love</film>
        <film>The Rock</film>
        <film>You Only Live Twice</film>
        <film>First Knight</film>
    </actor>
    </XQueryResult>

**************
Implementation
**************

The SOAP RPC support is implemented as a module, "pf_soap", in
pathfinder. 

Since the special namespace identifier "soap" is used in the above
XQuery query, the call to the function "add" is translated into the
following SOAP request message::

    <?xml version='1.0' ?>
    <env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope">
      <env:Header />
      <env:Body>
        <SoapRpcRequest
              module="http://www.cwi.nl/~zhang/soap/soap.xq"
              method="add">
          <iter>
            <param>
              <xs:decimal>40</xs:decimal>
            </param>
            <param>
              <xs:integer>20</xs:integer>
              <xs:integer>40</xs:integer>
            </param>
          </iter>
        </SoapRpcRequest>
      </env:Body>
    </env:Envelope>

The tag "iter" is used to separate different iterations, which use will
be explain in section "Loop-lifted RPC".  For now, it is clear that
there is only one iteration in this example.  Within an iteration, the
values of a parameter are separated by the "param" tag.  Since a
parameter can be a sequence, every value is separated by a tag, with the
actual type of this value as the name of the tag.

After having received a SOAP request message, the SOAP receiver
retrieves the following information from the message:
- URI of the module to load
- name of the called method
- number of iterations
- number of arguments
- convert all values from string into the specified type as tag name

Once the SOAP receiver has all these information, it calls a special
function ("xquery_method") to load the module and execute the function
call.  If no error occurs, this SOAP response message should be sent
back to the caller::

    <env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope">
      <env:Header />
      <env:Body>
        <SoapRpcResults
              module="http://www.cwi.nl/~zhang/soap/soap.xq"
              method="add">
          <iter>
            <xs:double>60.000000</xs:double>
            <xs:double>80.000000</xs:double>
          </iter>
        </SoapRpcResults>
      </env:Body>
    </env:Envelope>

But things can go wrong, then a SOAP Fault message will be sent back to
the caller.  For example, if the SOAP receiver can not load the module
specified in our example SOAP RPC call, it will send the following SOAP
Fault message::

    <env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope">
      <env:Header />
      <env:Body>
        <SoapRpcResults
          module="http://www.cwi.nl/~zhang/soap/soap.xq"
          method="add">
        <env:Fault>
          <env:Code>
            <env:Value>
              env:Sender
            </env:Value>
          </env:Code>
          <env:Reason>
            <env:Text xml:lang="en">
              http://www.cwi.nl/~zhang/ssoap/soap.xq:add:
              xquery_module_load: could not load module.
            </env:Text>
          </env:Reason>
        </env:Fault>
      </env:Body>
    </env:Envelope>

The structure and the meaning of each tag of a SOAP Fault message are
specified by W3C [reference].  The most important tags are "<env:Code>",
which tells who has cause the problem, the sender or the receiver; and
"<env:Reason>", which contains some human readable text to explain what
has gone wrong.


Automatic generation of RPC stub
--------------------------------

To call a remote function through SOAP RPC, the called function name
should be prefixed with a special namespace, currently "soap".  If the
pathfinder compiler sees such a function call, it generates a stub
implementation, instead of normal function implementation.  The
pathfinder compiler expects that the function is called with an
additional leading string parameter, which holds the destination URI.
The pathfinder compiler then pass the destination URI, the URI of the
module and the name of the function to the SOAP sender as strings.  The
values of the parameters are first translated into pathfinder's internal
representation, before they are passed to the SOAP sender.

The SOAP sender generates a SOAP RPC request message including the URI
of the module, the function name and the parameter values and sends the
message to the destination URI.  If the RPC call has been carried out
successfully, the SOAP sender retrieves the values from the response
message and converts them into the pathfinder's internal data
representation.

In the SOAP RPC implementation of another project, a new node is first
constructed by copying all parameters as its child nodes.  The new node
is then translated into SOAP RPC request message.  With the
automatically generated stub implementation, we avoid this step of
element reconstruction, which can be very expensive if a large XML
document is given as a parameter.  Thus in our implementation, we only
need to copy the values once, namely, from the pathfinder' internal data
representation to the SOAP request message.  We regard this copy step as
inevitable.


Handling of XML tree node as parameter
--------------------------------------

If a XML tree nodes is passed as arguments, I use
'xquery_print_result_main' to print the node into the outgoing buffer.
For example, we have the following module definition::

    module namespace soap = "http://www.cwi.nl/~zhang/soap/soap.xq";

    declare function soap:testnode($v1 as xs:double, $v2 as xs:anyNode*)
        as xs:double
    {
        $v1
    };

And we want to execute this query::

    import module namespace soap = "http://www.cwi.nl/~zhang/soap/soap.xq" at
        "http://www.cwi.nl/~zhang/soap/soap.xq";

    soap:testnode("localhost", 10,
                  doc("http://www.cwi.nl/~zhang/soap/soap.xml"))

where, 'http://www.cwi.nl/~zhang/soap/soap.xml' has the following
contents::

    <foo>
      <hello>
        <world>
        </world>
      </hello>
    </foo>

Then the query will be translated into the following request message::

    <?xml version='1.0' ?>
    <env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope">
      <env:Header />
      <env:Body>
        <SoapRpcRequest
            module="http://www.cwi.nl/~zhang/soap/soap.xq"
            method="testnode">
          <iter>
            <param>
              <val type="xs:integer">10</val>
            </param>
            <param>
              <val type="xs:anyNode">
                <foo>
                  <hello>
                    <world>
                    </world>
                  </hello>
                </foo>
              </val>
            </param>
          </iter>
        </SoapRpcRequest>
      </env:Body>
    </env:Envelope>

A SOAP response message is cut from "<env:Envelope" until
"</env:Envelope>" and then passed to 'CMDshred2bats' to shred it.  After
that, 'index_doc' and 'add_docbat' are used to add the temporary bats
into the working set.  With the returned 'frag_id' we can find the
proper portion of the just added document in the working set.  At last,
we construct the iter|item|kind bats by retrieving the right values from
the working set.  The iter|item|kind bats are then the return values of
the stub implementation.  

Loop-lifted RPC
---------------

Our intention is to use the SOAP RPC implementation for remote XQuery
execution in P2P environment.  In such an environment, it is of great
importance to minimize the number of messages between the sender and the
receiver, and the overhead per message.  

Example 2
~~~~~~~~~
Suppose we need to execute RPC calls in a 'for' loop like following::

    import module namespace
        soap = "http://www.cwi.nl/~zhang/soap/soap.xq"
        at "http://www.cwi.nl/~zhang/soap/soap.xq";

    for $i in (40, 50)
      return soap:add("a.b.cwi.nl", $i, (20, 40))

A naive implementation of such a 'for' loop would be to send a RPC
request to "a.b.cwi.nl" in each iteration with the corresponding values.
Obviously, if the number of iterations is large, communication will take
a lot of time; if there are very few values need to be send, say one
integer per iteration, a big percentage of band-width will be wasted on
message overhead.

We can easily improve the naive implementation by marshaling the
parameter values of all iterations into one SOAP RPC request message to
send to the destination.  The destination should then execute all
iterations and gather the results to send them back in one SOAP RPC
response message.  This way, we can reduce the number of message from
'2n' ('n' is number of iterations) to 2.  It is difficult to calculate
how much message overhead we can save, but it is clear that this
algorithm uses less band-width than the naive implementation.

We call the second implementation "loop-lifted RPC", since it is
inspired by pathfinder's "loop-lifted staircasejoin" algorithm
[reference], in which, a function in a 'for' loop is not called 'n'
times ('n' is the number of iterations) with each time the values of one
iteration, but called only once with values of all iterations passed to
the function in one time.

The "loop-lifted staircasejoin" makes it extremely easy to implement
the "loop-lifted RPC" algorithm.  When the stub of 'add' is called,
values of all iterations are already passed to it.  (Values are passed
in the order of per parameter and then per iteration).  All it needs to
do is reordering the values in the order of per iteration and then per
parameter and add XML tags where necessary.  The unmarshaling of the
response message is just the other way around.

The corresponding SOAP RPC request and response messages of Example 2
are as following::

    <?xml version='1.0' ?>
    <env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope">
      <env:Header />
      <env:Body>
        <SoapRpcRequest
              module="http://www.cwi.nl/~zhang/soap/soap.xq"
              method="add">
          <iter>
            <param>
              <xs:decimal>40</xs:decimal>
            </param>
            <param>
              <xs:integer>20</xs:integer>
              <xs:integer>40</xs:integer>
            </param>
          </iter>
          <iter>
            <param>
              <xs:decimal>50</xs:decimal>
            </param>
            <param>
              <xs:integer>20</xs:integer>
              <xs:integer>40</xs:integer>
            </param>
          </iter>
        </SoapRpcRequest>
      </env:Body>
    </env:Envelope>


    <env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope">
      <env:Header />
      <env:Body>
        <SoapRpcResults
              module="http://www.cwi.nl/~zhang/soap/soap.xq"
              method="add">
          <iter>
            <xs:double>60.000000</xs:double>
            <xs:double>80.000000</xs:double>
          </iter>
          <iter>
            <xs:double>70.000000</xs:double>
            <xs:double>90.000000</xs:double>
          </iter>
        </SoapRpcResults>
      </env:Body>
    </env:Envelope>


Parallel execution of SOAP RPC
------------------------------



**********
References
**********

- other pathfinder papers
- W3C SOAP spec
- The paper which also use SOAP RPC
