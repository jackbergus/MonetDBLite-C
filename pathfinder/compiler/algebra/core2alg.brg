%{

/**
 * @file
 *
 * Compile Core tree into relational algebra.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2006 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 *
 * $Id$
 */ 


#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "core.h"
#include "subtyping.h"
#include "qname.h"
#include "mem.h"

/* PFvar_t */
#include "variable.h"

#include "algebra.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFcnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/core.h!
 */
%term var                =  1 /**< variable */
%term lit_str            =  2 /**< string literal */
%term lit_int            =  3 /**< integer literal */
%term lit_dec            =  4 /**< decimal literal */
%term lit_dbl            =  5 /**< double literal */
%term nil                =  6 /**< end-of-sequence marker */

%term seq                =  7 /**< sequence construction */
%term ordered            =  8
%term unordered          =  9

%term flwr               = 10 /**< flwr expression */
%term let                = 11 /**< let expression */
%term letbind            = 12 /**< binding part of a let expression */
%term for_               = 13 /**< for expression */
%term forbind            = 14 /**< binding part of a for expression */
%term forvars            = 15 /**< variable pair (var + pos. var) of a for */

%term orderby            = 16 /**< orderby clause */
%term orderspecs         = 17 /**< list of order specs */

%term apply              = 18 /**< function application */
%term arg                = 19 /**< function argument (list) */

%term typesw             = 20 /**< typeswitch clause */
%term cases              = 21 /**< case concatenation for typeswitch */
%term case_              = 22 /**< single case for typeswitch */
%term default_           = 23 /**< default branch in typeswitch */
%term seqtype            = 24 /**< a SequenceType */
%term seqcast            = 25 /**< cast along <: */
/* %term proof           = 26      typechecker only: prove <: relationship */
/* %term subty           = 27      subtype condition for proof() */
/* %term stattype        = 28      static type of expression. Required for
                                   fs:convert-operand. Will be removed during
                                   typechecking and replaced by seqtype, as
                                   soon as types are known. */

%term if_                = 29 /**< if-then-else conditional */
%term then_else          = 30 /**< then- and else-branches of an
                                   if-then-else conditional */

%term locsteps           = 31 /**< path of location steps only */
%term ancestor           = 32 /**< the parent, the parent's parent,... */
%term ancestor_or_self   = 33 /**< the parent, the parent's parent,... + self */
%term attribute          = 34 /**< attributes of the context node */
%term child              = 35 /**< children of the context node */
%term descendant         = 36 /**< children, children's children,... + self */
%term descendant_or_self = 37 /**< children, children's children,... */
%term following          = 38 /**< nodes after current node (document order) */
%term following_sibling  = 39 /**< all following nodes with same parent */
%term parent             = 40 /**< parent node (exactly one or none) */
%term preceding          = 41 /**< nodes before context node (document order) */
%term preceding_sibling  = 42 /**< all preceding nodes with same parent */
%term self               = 43 /**< the context node itself */

%term elem               = 44 /**< the element constructor */
%term attr               = 45 /**< the attribute constructor */
%term text               = 46 /**< the text constructor */
%term doc                = 47 /**< the document constructor */
%term comment            = 48 /**< the comment constructor */
%term pi                 = 49 /**< the processing-instruction constructor */
%term tag                = 50 /**< the tagname for elem. and attr. constr. */

%term true_              = 51 /**< built-in function `fn:true ()' */
%term false_             = 52 /**< built-in function `fn:false ()' */
%term empty              = 53 /**< built-in function `empty' */
%term main               = 54 /**< tree root
                                   Separates function declarations from
                                   the query body. */
%term fun_decls          = 55 /**< list of function declarations */
%term fun_decl           = 56 /**< function declaration */
%term params             = 57 /**< function declaration parameter list */
%term param              = 58 /**< function declaration parameter */
%term cast               = 59 /**< XQuery `cast as' operation */

%term recursion          = 60 /**< "with $v seeded by..." expression */
%term seed               = 61
%%

Query:              main (FunctionDecls, CoreExpr)              =   1 (10);
Query:              CoreExpr                                    =   2 (10);
                                                                     
CoreExpr:           Atom                                        =   3 (10);
                                                                     
Atom:               var                                         = 100 (10);
Atom:               LiteralValue                                = 101 (10);
                                                                     
LiteralValue:       lit_str                                     = 102 (10);
LiteralValue:       lit_int                                     = 103 (10);
LiteralValue:       lit_dec                                     = 104 (10);
LiteralValue:       lit_dbl                                     = 105 (10);
LiteralValue:       true_                                       = 106 (10);
LiteralValue:       false_                                      = 107 (10);
LiteralValue:       empty                                       = 108 (10);
                                                                     
CoreExpr:           flwr (OptBindExpr, CoreExpr)                =   4 (10);

OptBindExpr:        for_ (forbind (forvars (var, OptVar),            
                                   Atom),                            
                          OptBindExpr)                          =   5 (10);
                                                                     
OptVar:             var                                         = 200 (10);
OptVar:             nil                                         = 201 (10);
                                                                     
OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr)  =   6 (10);
OptBindExpr:        nil                                         =   7 (10);
                                                                     
CoreExpr:           if_ (Atom, then_else (CoreExpr, CoreExpr))  =   8 (10);
                                                                     
CoreExpr:           seq (CoreExpr, SeqCoreExpr)                 =   9 (10);
CoreExpr:           seq (CoreExpr, CoreExpr)                    =  10 (10);
SeqCoreExpr:        seq (CoreExpr, SeqCoreExpr)                 =  11 (10);
SeqCoreExpr:        seq (CoreExpr, CoreExpr)                    =  12 (10);
                                                                     
CoreExpr:           orderby (OrderSpecs, CoreExpr)              =  13 (10);
                                                                     
OrderSpecs:         orderspecs (CoreExpr, nil)                  = 300 (10);
OrderSpecs:         orderspecs (CoreExpr, OrderSpecs)           = 301 (10);
                                                                     
CoreExpr:           ordered (CoreExpr)                          =  14 (10);
CoreExpr:           unordered (CoreExpr)                        =  15 (10);
                                                                     
CoreExpr:           typesw (Atom,                                    
                            cases (case_ (seqtype,                   
                                          CoreExpr),                 
                                   default_ (CoreExpr)))        =  20 (10);
                                                                     
CoreExpr:           cast (seqtype, CoreExpr)                    =  21 (10);
CoreExpr:           seqcast (seqtype, CoreExpr)                 =  22 (10);
                                                                     
CoreExpr:     locsteps (ancestor (seqtype), CoreExpr)           =  30 (10);
CoreExpr:     locsteps (ancestor_or_self (seqtype), CoreExpr)   =  31 (10);
CoreExpr:     locsteps (attribute (seqtype), CoreExpr)          =  32 (10);
CoreExpr:     locsteps (child (seqtype), CoreExpr)              =  33 (10);
CoreExpr:     locsteps (descendant (seqtype), CoreExpr)         =  34 (10);
CoreExpr:     locsteps (descendant_or_self (seqtype), CoreExpr) =  35 (10);
CoreExpr:     locsteps (following (seqtype), CoreExpr)          =  36 (10);
CoreExpr:     locsteps (following_sibling (seqtype), CoreExpr)  =  37 (10);
CoreExpr:     locsteps (parent (seqtype), CoreExpr)             =  38 (10);
CoreExpr:     locsteps (preceding (seqtype), CoreExpr)          =  39 (10);
CoreExpr:     locsteps (preceding_sibling (seqtype), CoreExpr)  =  40 (10);
CoreExpr:     locsteps (self (seqtype), CoreExpr)               =  41 (10);

CoreExpr:           elem (TagName, CoreExpr)                    =  50 (10);
CoreExpr:           attr (TagName, CoreExpr)                    =  51 (10);
                                                                     
TagName:            tag                                         = 400 (10);
TagName:            CoreExpr                                    = 401 (10);
                                                                     
CoreExpr:           text (CoreExpr)                             =  52 (10);
CoreExpr:           doc (CoreExpr)                              =  53 (10);
CoreExpr:           comment (CoreExpr)                          =  54 (10);
CoreExpr:           pi (CoreExpr)                               =  55 (10);
                                                                     
CoreExpr:           apply (FunctionArgs)                        =  60 (10);
                                                                     
FunctionArgs:       nil                                         = 500 (10);
FunctionArgs:       arg (FunctionArg, FunctionArgs)             = 501 (10);
                                                                     
FunctionArg:        Atom                                        = 502 (10);
                                                                     
                                                                     
FunctionDecls:      nil                                         =  70 (10);
FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls)     =  71 (10);
                                                                     
FunctionDecl:       fun_decl (ParamList, FunctionBody)          = 600 (10);
                                                                     
ParamList:          nil                                         = 601 (10);
ParamList:          params (FunParam, ParamList)                = 602 (10);
                                                                     
FunctionBody:       CoreExpr                                    = 603 (10);
                                                                     
FunParam:           param (seqtype, var)                        = 604 (10);

CoreExpr:           recursion (var, seed (Atom, CoreExpr))      =  72 (10);

%%

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))
#define LLR(p) R(L(L(p)))
#define RRR(p) R(R(R(p)))
#define LLL(p) L(L(L(p)))
#define LLLL(p) L(L(L(L(p))))
#define LLLLL(p) L(L(L(L(L(p)))))
#define LLLLR(p) R(L(L(L(L(p)))))
#define LLLR(p) R(L(L(L(p))))
#define RLL(p) L(L(R(p)))
#define RLLR(p) R(L(L(R(p))))
#define RLLL(p) L(L(L(R(p))))
#define RLR(p) R(L(R(p)))
#define RRLL(p) L(L(R(R(p))))
#define RRLR(p) R(L(R(R(p))))

/** Algebra equivalent of a Core tree node */
#define A(p) ((p)->alg)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

/** mnemonic algebra constructors */
#include "logical_mnemonic.h"

/**
 * Variable environment (Gamma in our papers)
 */
static PFarray_t  *env = NULL;

/**
 * Current loop relation
 */
static PFla_op_t *loop = NULL;

/**
 * Current map relation
 */
static PFla_op_t *map = NULL;

/**
 * Attribute counter of current map relation
 */
static unsigned int map_count = 0;

/**
 * ordering mode indicator
 */
static bool ordering = false;

/**
 * sequence item counter
 */
static unsigned int seq_count = 0;

/* Constructor for staircase join */
static struct PFla_pair_t locstep (PFalg_axis_t axis, PFty_t seqty, 
                                   struct PFla_pair_t p);

/* Constructor for environment entry */
static PFla_env_t enventry (PFvar_t *var, PFla_op_t *rel, 
                            PFla_op_t *map, PFarray_t *doc);

/* worker to implement type tests */
static PFla_op_t *type_test (PFty_t ty, PFla_pair_t e, PFla_op_t *loop);

/**
 * Function parameter variable names (from PFfun_t).
 * Required to translate function calls.
 */
static PFarray_t *fun_args = NULL;

/**
 * Stack recording the active user-defined functions
 */
static PFarray_t *fun_active = NULL;

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFcnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFcnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */

    assert(p);

    /* determine rule that matches for this non-terminal */
    rule = PFcore2alg_rule (STATE_LABEL (p), goalnt);

    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFcore2alg_nts[rule];
    PFcore2alg_kids (p, rule, kids);

    /*
     * Few translation rules require top-down processing. We figure
     * them out here and skip the recursive compilation. The respective
     * rules will explicitly trigger the compilation of their kids.
     */
    switch (rule) {
        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:

        /* CoreExpr:           flwr (OptBindExpr, CoreExpr) */
        case 4:

        /* CoreExpr:           for_ (forbind (forvars (var, nil),
                                              Atom),
                                     CoreExpr) */
        case 5:

        /* CoreExpr:           let (letbind (var, CoreExpr), CoreExpr) */
        case 6:

        /* CoreExpr:           if_ (Atom, then_else (CoreExpr, CoreExpr)) */
        case 8:

        /* CoreExpr:           seq (CoreExpr, SeqCoreExpr) */
        case 9:

        /* SeqCoreExpr:        seq (CoreExpr, SeqCoreExpr) */
        case 11:

        /* SeqCoreExpr:        seq (CoreExpr, CoreExpr) */
        case 12:

        /* CoreExpr:           orderby (OrderSpecs, CoreExpr) */
        case 13:

        /* OrderSpecs:         orderspecs (CoreExpr, nil) */
        case 300:

        /* OrderSpecs:         orderspecs (CoreExpr, OrderSpecs) */
        case 301:

        /* CoreExpr:           ordered (CoreExpr) */
        case 14:

        /* CoreExpr:           unordered (CoreExpr) */
        case 15:

        /* CoreExpr:           typesw (Atom,
                                       cases (case_ (seqtype,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 20:

        /* CoreExpr:           apply (FunctionArgs) */
        case 60:
            
        /* FunctionArgs:       arg (FunctionArg, FunctionArgs) */
        case 501:
            
        /* CoreExpr:           recursion (var, seed (Atom, CoreExpr)) */
        case 72:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    if (!topdown)
        for (unsigned short i = 0; nts[i]; i++)
            reduce (kids[i], nts[i]);

    switch (rule) {

        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:
            /* TOPDOWN */

            /*
             * Only the real XQuery expression is of interest, not the
             * function declaration part. Apply serialize() to the
             * XQuery Core result.
             */
            reduce (kids[1], nts[1]);
            A(p) = (PFla_pair_t) {
                     .rel = serialize (PFla_set_to_la (A(R(p)).frag),
                                       A(R(p)).rel, att_pos, att_item),
                     .frag = NULL };
            break;

        /* Query:              CoreExpr */
        case 2:
            /*
             * Defining CoreExpr also as a top-level non-terminal
             * allows us to recursively invoke matching for function
             * calls.
             */
            break;

        /* CoreExpr:           Atom */
        case 3:
            break;
            
        /* Atom:               var */
        case 100:
        {
            /*
             * Reference to variable, so look it up in the environment. It
             * was inserted into the environment by a let or for expression.
             *
             * ---------------------------------------------------------------
             * env, (v -> q(v)) e env, loop: v => (q(v), 0)
             */
            unsigned int i;
            PFla_op_t *rel;
        
            /* 
             * look up the variable in the environment;
             * since it has already been ensured beforehand, that
             * each variable was declared before being used, we are
             * guarenteed to find the required binding in the
             * environment
             */

            /*
             * The variable representations in the variable environment
             * consist of 4 parts:
             *  - var: the variable name
             *  - rel: the initial relation representing the variable
             *  - map: the mapping information needed to map the relation
             *         rel to the current scope
             *  - frag: the document fragment information
             *
             * In constrast to the variable mapping described in our
             * papers we do not map the relation representing the variable
             * in each new scope, but first create a chain of mapping
             * joins. The variable representations therefore have to
             * be mapped to the current scope -- if necessary 
             * (map != NULL) -- (via map) only during look-up (here).
             *
             * The reason is that this makes the optimization of such
             * chains of joins easier in later phases.
             */ 
            for (i = 0; i < PFarray_last (env); i++) {
                PFla_env_t e = *((PFla_env_t *) PFarray_at (env, i));
            
                if (p->sem.var == e.var) {
                    if (!e.map)
                        rel = e.rel;
                    else
                        rel = project (
                                  eqjoin (
                                      e.rel,
                                      e.map,
                                      att_iter,
                                      att_outer),
                                  proj (att_iter, att_inner),
                                  proj (att_pos,  att_pos),
                                  proj (att_item, att_item));

                    A(p) = (struct  PFla_pair_t) { .rel = rel, .frag = e.frag };
                    break;
                }
            }

            assert (A(p).rel); assert (A(p).frag);

        } break;

        /* Atom:               LiteralValue */
        case 101:
            break;

        /* LiteralValue:       lit_str */
        case 102:
        {
            /* 
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (loop,
                                        att_pos, lit_nat (1)),
                                att_item, lit_str (p->sem.str)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       lit_int */
        case 103:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (loop,
                                        att_pos, lit_nat (1)),
                                att_item, lit_int (p->sem.num)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       lit_dec */
        case 104:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (loop,
                                        att_pos, lit_nat (1)),
                                att_item, lit_dec (p->sem.dec)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       lit_dbl */
        case 105:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (loop,
                                        att_pos, lit_nat (1)),
                                att_item, lit_dbl (p->sem.dbl)),
                     .frag = PFla_empty_set () };
        } break;


        /* LiteralValue:       true_ */
        case 106:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (loop,
                                        att_pos, lit_nat (1)),
                                att_item, lit_bln (true)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       false_ */
        case 107:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (loop,
                                        att_pos, lit_nat (1)),
                                att_item, lit_bln (false)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       empty */
        case 108:
        {
            /*
             *  -------------------------------------------------------------
             *                       iter | pos | item
             *  env, loop: empty => ------+-----+------ , 0
             * 
             */
            PFalg_schema_t schema;
            schema.count = 3;
            schema.items = PFmalloc (3 * sizeof (PFalg_schema_t));

            /* We know that iter and pos would have type nat.
               For item on the other side we have no type. */
            schema.items[0].name = att_iter;
            schema.items[0].type = aat_nat;
            schema.items[1].name = att_pos;
            schema.items[1].type = aat_nat;
            schema.items[2].name = att_item;
            schema.items[2].type = 0;
            
            A(p) = (struct  PFla_pair_t) {
                     .rel = PFla_empty_tbl_ (schema),
                     .frag = PFla_empty_set () };
        } break;

        /* CoreExpr:           flwr (OptBindExpr, CoreExpr) */
        case 4:
        {   /* TOPDOWN */
            /**
             * The flwr expression maps back the result of
             * one or more nested for-loops at once. It therefore
             * distincts between the ordering mode ordered and 
             * unordered.
             *
             * unordered:
             *
             *        pi_(iter, pos:pos1, item)
             *        |
             *       row_(pos1:<iter, pos>/outer)
             *        |
             *       |X|_(iter, inner)
             *      /  \
             *    /      \
             * result    map
             *
             * ordered:
             *
             *        pi_(iter, pos:pos1, item)
             *        |
             *       row_(pos1:<sort_0, sort_1, ..., sort_n, pos>/outer)
             *        |
             *       |X|_(iter, inner)
             *      /  \
             *    /      \
             * result    map
             *
             * In the ordered case each for-loop adds one sort criterion 
             * to the map relation (sort_0, sort_1, ..., sort_n) 
             *      or if an order by is present it removes all sort
             * criteria introduced by the for-loop and adds for each
             * order specification a sort attribute (sort_0, sort_1, 
             * ..., sort_n)
             */

            /* store current state information */
            PFla_op_t   *old_loop      = loop;
            PFla_op_t   *old_map       = map;
            unsigned int old_map_count = map_count;
            PFarray_t    *old_env      = env;
        
            /* start with empty map relation */
            map = 0;
            map_count = 0;

            /* initiate translation of bindings */
            reduce (kids[0], nts[0]);

            /* as side effect from the bindings a possibly
               new loop relation is input to the return expression */

            /* initiate translation of return expression */
            reduce (kids[1], nts[1]);

            /* the map relation has been changed by a for loop
               (and an order by) and therefore backmapping is
               required */
            if (map) {
                /* Note that ordering mode has no effect on a FLWOR 
                   expression if an order by clause is present, 
                   since order by takes precedence over ordering mode. */
                if (!ordering && R(p)->kind != c_orderby)
                    /* in unordered context the new numbering only
                       needs to respect the sequence order 
                       (in- and outside the flwor block). */
                    A(p) = (struct PFla_pair_t) {
                            .rel = project (rownum (eqjoin (A(R(p)).rel,
                                                            map,
                                                            att_iter,
                                                            att_inner),
                                                    att_pos1,
                                                    sortby (att_iter, att_pos),
                                                    att_outer),
                                            proj (att_iter, att_outer),
                                            proj (att_pos, att_pos1),
                                            proj (att_item, att_item)),
                            .frag = A(R(p)).frag };
                else {
                    /**
                     * If an order by clause is present we need 
                     * the iter column as a row number criterion
                     * (sort_0, sort_1, ..., sort_n, iter, pos).
                     *
                     * Without an order by the combination of sort
                     * columns and partitioning column outer already
                     * contain the information of column iter. Thus
                     * the row numbering needs to sort on:
                     * (sort_0, sort_1, ..., sort_n, pos).
                     */
                    /* create sortby attribute list: */
                    PFalg_attlist_t sortby;
                    if (R(p)->kind == c_orderby)
                    {
                        /* don't include columns inner and outer */
                        sortby.count = map_count - 2 + 2;
                        sortby.atts = PFmalloc (sortby.count *
                                                sizeof (PFalg_attlist_t));

                        /* starting from attribute sort add consecutive
                           attributes ... */
                        for (unsigned int i = 0; i < sortby.count - 2; i++)
                            sortby.atts[i] = att_sort << i;
                        /* ... and complete sortby list with attributes
                           iter and  pos */
                        sortby.atts[sortby.count - 2] = att_iter;
                        sortby.atts[sortby.count - 1] = att_pos;
                    } else {
                        /* don't include columns inner and outer */
                        sortby.count = map_count - 2 + 1;
                        sortby.atts = PFmalloc (sortby.count *
                                                sizeof (PFalg_attlist_t));

                        /* starting from attribute sort add consecutive
                           attributes ... */
                        for (unsigned int i = 0; i < sortby.count - 1; i++)
                            sortby.atts[i] = att_sort << i;
                        /* ... and complete sortby list with attribute pos */
                        sortby.atts[sortby.count - 1] = att_pos;
                    }

                    A(p) = (struct PFla_pair_t) {
                            .rel = project (rownum (eqjoin (A(R(p)).rel,
                                                            map,
                                                            att_iter,
                                                            att_inner),
                                                    att_pos1,
                                                    sortby,
                                                    att_outer),
                                            proj (att_iter, att_outer),
                                            proj (att_pos, att_pos1),
                                            proj (att_item, att_item)),
                            .frag = A(R(p)).frag };
                }
            } else
                A(p) = A(R(p));
            
            /* restore loop relation */
            loop = old_loop;
            /* restore map relation and its attribute counter */
            map = old_map;
            map_count = old_map_count;
            /* restore old environment */
            env = old_env;

        }   break;

        /* OptBindExpr:        for_ (forbind (forvars (var, OptVar),
                                              Atom),
                                     OptBindExpr) */
        case 5:
        {   /* TOPDOWN */

            /*
             * for $v in e1 return e2                    OR
             * for $v at $p in e1 return e2
             *
             * Given the current environment (which may or may not contain
             * bindings), the current loop relation and delta with e1
             * already compiled:
             * - declare variable $v by loop lifting the result of q1,
             *(- declare variable $p if present)
             * - create a new loop relation and
             * - a new var_map relation,
             * - as the for expression opens up a scope, update all existing
             *   bindings to the new scope and add the binding of $v
             * Given the updated environment and the new loop relation
             * compile e2. Return the (possibly intermediate) result.
             *
             * env,loop: e1 => q1,delta1
             *
             *        pos
             * q(v) = --- X proj_iter:inner,item(row_inner:<iter,pos> q1)
             *         1
             *
             * loop(v) = proj_iter(q(v))
             *
             * var_map = proj_outer:iter,inner(row_inner:<iter,pos> q1)
             *
             * updated_env,(v->q(v)) e updated_env,loop(v): e2 => (q2,delta2)
             * -----------------------------------------------------------------
             * env,loop: for &v in e1 return e2 =>
             * (proj_iter:outer, pos:pos1,item
             *   (row_pos1:<iter,pos>/outer (q2 |X| (iter = inner) var_map)),
             *  delta2)
             */
            PFla_op_t   *var;
            PFla_op_t   *opt_var;
            PFla_op_t   *var_map;
            PFla_op_t   *number;
            unsigned int  i;
            PFla_env_t   e;
            PFla_op_t   *new_map;
            /* save old environment */
            PFarray_t  *old_env = env;

            /* initiate translation of e1 */
            reduce (kids[1], nts[1]);

            number = number (A(LR(p)).rel, att_inner, att_NULL);

            /* translate $v */
            var = attach (project (number,
                                   proj (att_iter, att_inner),
                                   proj (att_item, att_item)),
                          att_pos, lit_nat (1));

            /* create new environment */
            env = PFarray (sizeof (PFla_env_t));

            /* insert $v and "its document" into NEW environment */
            *((PFla_env_t *) PFarray_add (env))
                = enventry (LLL(p)->sem.var, var, NULL, A(LR(p)).frag);

            /* create new loop operator */
            loop = project (var, proj (att_iter, att_iter));

            /* create var_map relation. */
            var_map = project (number,
                               proj (att_outer, att_iter),
                               proj (att_sort, att_pos),
                               proj (att_inner, att_inner));

            /*
             * handle optional variable ($p); we need map operator
             * for this purpose
             * note that the rownum () routine is used to create
             * the 'item' column of $p's operator; since this
             * column must be of type integer instead of nat, we
             * cast it accordingly
             */
            if (LLR(p)->kind == c_var) {
                assert (LLR(p)->sem.var);
                opt_var = attach (project (cast (rownum (var_map, att_item,
                                                         sortby (att_sort),
                                                         att_outer),
                                                 att_cast, att_item, aat_int),
                                           proj (att_iter, att_inner),
                                           proj (att_item, att_cast)),
                                  att_pos, lit_nat (1));

                /* insert $p into NEW environment */
                *((PFla_env_t *) PFarray_add (env)) =
                    enventry (LLR(p)->sem.var, opt_var, NULL, PFla_empty_set ());
            }

            /* update all variable bindings in old environment and put
             * them into new environment */
            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));
                
                if (!e.map)
                    new_map = project (var_map,
                                       proj (att_outer, att_outer),
                                       proj (att_inner, att_inner));
                else
                    new_map = project (
                                  eqjoin (
                                      project (
                                          e.map,
                                          proj (att_iter, att_inner),
                                          proj (att_outer, att_outer)),
                                      project (
                                          var_map,
                                          proj (att_iter2, att_outer),
                                          proj (att_inner, att_inner)),
                                      att_iter,
                                      att_iter2),
                                  proj (att_outer, att_outer),
                                  proj (att_inner, att_inner));

                *((PFla_env_t *) PFarray_add (env)) =
                    enventry (e.var, e.rel, new_map, e.frag);
            }

            if (!map) {
                /* create a first backmapping relation */
                map = var_map;
                map_count = 3;
            } else {
                /* extend the backmapping relation map with
                 * (a) position information of the for-loop input sequence and
                 * (b) the current iteration values */

                map_count++;
                PFalg_proj_t *atts = PFmalloc (map_count *
                                               sizeof (PFalg_proj_t));
                /* column outer remains the same */
                atts[0].new = att_outer;
                atts[0].old = att_outer;
                /* column iter1 becomes the new inner column */
                atts[1].new = att_inner;
                atts[1].old = att_iter1;
                /* copy all old sort columns */
                for (unsigned i = 2; i < map_count - 1; i++)
                    atts[i].new = 
                    atts[i].old = att_sort << (i - 2);
                /* we now have on additional sort column generated 
                   from column pos */
                /* the first sort criterion is column sort itself */
                atts[map_count -1].new = att_sort << (map_count - 3);
                atts[map_count -1].old = att_pos;

                map = PFla_project_ (eqjoin (map, 
                                             project (number,
                                                      proj (att_iter1, att_inner),
                                                      proj (att_iter, att_iter),
                                                      proj (att_pos, att_pos)),
                                             att_inner,
                                             att_iter),
                                     map_count, atts);
            }
            
            /* translate e2 under the specified conditions (updated
             * environment, loop(v))
             */
            reduce (kids[2], nts[2]);

            /* compute result using old env and old loop. */
            /* backmapping is now done in flwr
            A(p) = (struct PFla_pair_t) {
                     .rel = project (rownum (eqjoin(A(R(p)).rel,
                                                    var_map, 
                                                    att_iter,
                                                    att_inner),
                                             att_pos1,
                                             sortby (att_sort, att_pos),
                                             att_outer),
                                     proj (att_iter, att_outer),
                                     proj (att_pos, att_pos1),
                                     proj (att_item, att_item)),
                     .frag = A(R(p)).frag };
            */
        } break;

        /* OptVar:             var */
        case 200:
            /* (will never be called anyway, Rule 5 is top-down) */
            break;

        /* OptVar:             nil */
        case 201:
            /* (will never be called anyway, Rule 5 is top-down) */
            break;

        /* OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr) */
        case 6:
        {   /* TOPDOWN */

            /*
             * let $v := e1 return e2
             *
             * Translate e1 in the current environment, translate the
             * variable $v and add the resulting binding to the environment.
             * Compile e2 in the enriched environment.
             *
             * env,loop: e1 => (q1,delta1)
             *
             * env + (v -> q(v)),loop: e2 => (q2,delta2)
             * ------------------------------------------------------------------
             * env,loop: let $v := e1 return e2 => (q2,delta2)
             *
             * NB: Translation of variable is:
             *
             *         /pos                                                   \
             * q(v) = | --- X proj_iter:inner,item(row_inner:<iter,pos>(q(e1)))|
             *         \ 1                                                    /
             *
             */

            /* initiate translation of e1 */
            reduce (kids[0], nts[0]);

            /* assign result of e1 to $v, i.e. add resulting binding to
             * environment together with the currently live nodes
             */
            *((PFla_env_t *) PFarray_add (env))
                = enventry (LL(p)->sem.var, A(LR(p)).rel, NULL, A(LR(p)).frag);

            /* now translate remaining bindings in the new context */
            reduce (kids[1], nts[1]);

            /* let is embedded in a flwr expression - a
               return expression therefore is not needed 
            A(p) = A(R(p));
            */
        } break;

        /* OptBindExpr:        nil */
        case 7:
            /* we don't need a translation -- it would be ignored anyway */
            break;

        /* CoreExpr:           if_ (Atom, then_else (CoreExpr, CoreExpr)) */
        case 8:
        {   /* TOPDOWN */

            /*
             * if e1 then e2 else e3
             *
             * NB: SEL: select those rows where column value != 0
             *     
             *
             * {..., $v -> q(v), ...},loop: e1 => q1,delta1
             * loop2 = proj_iter (SEL item q1)
             * loop3 = proj_iter (SEL res (NOT res item q1))
             * {..., $v -> 
             *  proj_iter,pos,item (q(v)|X|(iter=iter1)(proj_iter1:iter loop2)),
             *                      ...},loop2: e2 => (q2,delta2) 
             * {..., $v ->
             *  proj_iter,pos,item (q(v)|X|(iter=iter1)(proj_iter1:iter loop3)),
             *                      ...},loop3: e3 => (q3,delta3) 
             * -----------------------------------------------------------------
             * {..., $v -> q(v), ...},loop,delta: if e1 then e2 else e3 =>
             *                        (q2 U q3, delta2 U delta3)
             */
            PFla_op_t *old_loop;
            PFarray_t  *old_env;
            unsigned int i;
            PFla_env_t e;
            PFla_op_t *new_map;

            /* initiate translation of e1 */
            reduce (kids[0], nts[0]);

            /* save old loop operator */
            old_loop = loop;

            /* create loop2 relation */
            loop = project (select_ (A(L(p)).rel, att_item),
                            proj (att_iter, att_iter));

            /* save old environment */
            old_env = env;

            /* update the environment for translation of e2 */
            env = PFarray (sizeof (PFla_env_t));

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (
                                  loop,
                                  proj (att_outer, att_iter),
                                  proj (att_inner, att_iter));
                else
                    new_map = project (
                                  eqjoin (
                                      e.map,
                                      loop,
                                      att_inner,
                                      att_iter),
                                  proj (att_outer, att_outer),
                                  proj (att_inner, att_inner));

                *((PFla_env_t *) PFarray_add (env))
                    = enventry (e.var, e.rel, new_map, e.frag);
            }

            /* translate e2 */
            reduce (kids[1], nts[1]);

            /* create loop3 relation */
            loop = project (select_ (not (A(L(p)).rel,
                                         att_res,
                                         att_item),
                                    att_res),
                            proj (att_iter, att_iter));

            /* update the environment for translation of e3 */
            env = PFarray (sizeof (PFla_env_t));

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (
                                  loop,
                                  proj (att_outer, att_iter),
                                  proj (att_inner, att_iter));
                else
                    new_map = project (
                                  eqjoin (
                                      e.map,
                                      loop,
                                      att_inner,
                                      att_iter),
                                  proj (att_outer, att_outer),
                                  proj (att_inner, att_inner));

                *((PFla_env_t *) PFarray_add (env))
                    = enventry (e.var, e.rel, new_map, e.frag);
            }

            /* translate e3 */
            reduce (kids[2], nts[2]);

            /* reset loop relation and environment */
            loop = old_loop;
            env = old_env;

            A(p) = (struct  PFla_pair_t) {
                     .rel  = disjunion (A(RL(p)).rel, A(RR(p)).rel),
                     .frag = PFla_set_union (A(RL(p)).frag, A(RR(p)).frag) };

        } break;

        /* CoreExpr:           seq (CoreExpr, SeqCoreExpr) */
        case 9:
        {   /* TOPDOWN */

            /*
             *     env,loop: e1 => q1,delta1      env,loop: e2 => q2,delta2
             * -----------------------------------------------------------------
             *                        env,loop: (e1, e2) =>
             *
             *                      proj_iter,pos:pos1,item
             *  /                          / ord       \     / ord       \ \
             * |  row_pos1:<ord,pos>/iter | ----- X q1  | U | ----- X q2  | |
             *  \                          \  1        /     \  2        / /
             *
             */
            unsigned int old_seq_count;

            /* initiate translation of e1 */
            reduce (kids[0], nts[0]);
            
            /* save seq_count and start a new sequence counter */
            old_seq_count = seq_count;
            seq_count = 2;
            
            /* initiate translation of e2 */
            reduce (kids[1], nts[1]);
            
            /* re-set seq_count */
            seq_count = old_seq_count;
            
            A(p) = (struct  PFla_pair_t) {
                     .rel = project (
                                rownum (
                                    disjunion (
                                        attach (
                                            A(L(p)).rel,
                                            att_ord, lit_nat (1)),
                                        A(R(p)).rel),
                                    att_pos1,
                                    sortby (att_ord, att_pos),
                                    att_iter),
                                proj (att_iter, att_iter),
                                proj (att_pos, att_pos1),
                                proj (att_item, att_item)),
                     .frag = PFla_set_union (A(L(p)).frag, A(R(p)).frag) };
        } break;

        /* CoreExpr:           seq (CoreExpr, CoreExpr) */
        case 10:
        {
            /*
             *     env,loop: e1 => q1,delta1      env,loop: e2 => q2,delta2
             * -----------------------------------------------------------------
             *                        env,loop: (e1, e2) =>
             *
             *                      proj_iter,pos:pos1,item
             *  /                          / ord       \     / ord       \ \
             * |  row_pos1:<ord,pos>/iter | ----- X q1  | U | ----- X q2  | |
             *  \                          \  1        /     \  2        / /
             *
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = project (
                                rownum (
                                    disjunion (
                                        attach (
                                            A(L(p)).rel,
                                            att_ord, lit_nat (1)),
                                        attach (
                                            A(R(p)).rel,
                                            att_ord, lit_nat (2))),
                                    att_pos1,
                                    sortby (att_ord, att_pos),
                                    att_iter),
                                proj (att_iter, att_iter),
                                proj (att_pos, att_pos1),
                                proj (att_item, att_item)),
                     .frag = PFla_set_union (A(L(p)).frag, A(R(p)).frag) };
        } break;

        /* SeqCoreExpr:        seq (CoreExpr, SeqCoreExpr) */
        case 11:
        {   /* TOPDOWN */

            unsigned int cur_seq_count = seq_count++;

            /* initiate translation of e1 and e2 */
            reduce (kids[0], nts[0]);
            reduce (kids[1], nts[1]);

            A(p) = (struct  PFla_pair_t) {
                     .rel = disjunion (
                                attach (
                                    A(L(p)).rel,
                                    att_ord, lit_nat (cur_seq_count)),
                                A(R(p)).rel),
                     .frag = PFla_set_union (A(L(p)).frag, A(R(p)).frag) };
        } break;
            
        /* SeqCoreExpr:        seq (CoreExpr, CoreExpr) */
        case 12:
            /* TOPDOWN */

            /* initiate translation of e1 and e2 */
            reduce (kids[0], nts[0]);
            reduce (kids[1], nts[1]);

            A(p) = (struct  PFla_pair_t) {
                     .rel = disjunion (
                                attach (
                                    A(L(p)).rel,
                                    att_ord, lit_nat (seq_count)),
                                attach (
                                    A(R(p)).rel,
                                    att_ord, lit_nat (seq_count+1))),
                     .frag = PFla_set_union (A(L(p)).frag, A(R(p)).frag) };
            break;

        /* CoreExpr:           orderby (OrderSpecs, CoreExpr) */
        case 13:
        {   /* TOPDOWN */

            /* throw away all sort criteria -- each orderspec
               adds a new one instead */
            map = project (map,
                           proj (att_outer, att_outer),
                           proj (att_inner, att_inner));
            map_count = 2;

            /* translate OrderSpecs */
            reduce (kids[0], nts[0]);

            /* translate return expression */
            reduce (kids[1], nts[1]);

            A(p) = A(R(p));
        } break;

        /* OrderSpecs:         orderspecs (CoreExpr, nil) */
        case 300:
        /* OrderSpecs:         orderspecs (CoreExpr, OrderSpecs) */
        case 301: /* NOTE: some code specific to rule 301 stands
                     at the end of this block */
        {   /* TOPDOWN */
            PFla_op_t          *sort_attr;
            PFalg_proj_t       *atts;
            PFty_t              t;
            PFalg_simple_type_t algty;
            PFalg_atom_t        atom;
            unsigned int        empty = 0;

            /* translate order expression */
            reduce (kids[0], nts[0]);

            sort_attr = project (A(L(p)).rel,
                                 proj (att_iter, att_iter),
                                 proj (att_item, att_item));
            
            if (p->sem.mode.dir == p_desc) {
                if (PFty_subtype (L(p)->type, PFty_opt(PFty_numeric ())))
                    /* just negate the items and sort it ascending afterwards */
                    sort_attr = project (neg (sort_attr,
                                              att_res,
                                              att_item),
                                         proj (att_iter, att_iter),
                                         proj (att_item, att_res));
                else
                    /* apply rownum based on items and negate the rownum
                       values to support descending sorting with ascending
                       sort only */
                    sort_attr = project (neg (cast (rownum (sort_attr,
                                                            att_item1,
                                                            sortby (att_item),
                                                            att_NULL),
                                                    att_res,
                                                    att_item1,
                                                    aat_int),
                                              att_pos1, att_res),
                                         proj (att_iter, att_iter),
                                         proj (att_item, att_pos1));
            }

            /*
             * If we we know (from static typing) that all
             * iterations allways have a sequence length of 1
             * we do not need to add min/max values.
             */
            if (!PFty_subtype (L(p)->type, PFty_xs_anyItem ())) {
                t = PFty_prime (PFty_defn (L(p)->type));
                /*
                 * Unfortunately, we only know how to cast atomic types
                 * into (exactly) one of our builtin atomic types. We
                 * cannot sensibly cast, e.g., into subtypes thereof.
                 */
                if (PFty_equality (t, PFty_xs_string ())) {
                    algty = aat_str;
                    atom = lit_str ("");
                }
                else if (PFty_equality (t, PFty_xs_integer ())) {
                    algty = aat_int;
                    atom = lit_int (0);
                }
                else if (PFty_equality (t, PFty_xs_decimal ())) {
                    algty = aat_dec;
                    atom = lit_dec (0);
                }
                else if (PFty_subtype (t, PFty_xs_decimal ())) {
                    algty = aat_dec;
                    atom = lit_dec (0);
                }
                else if (PFty_equality (t, PFty_xs_double ())) {
                    algty = aat_dbl;
                    atom = lit_dbl (0);
                }
                else if (PFty_equality (t, PFty_xs_boolean ())) {
                    algty = aat_bln;
                    atom = lit_bln (true);
                }
                else if (PFty_equality (t, PFty_untypedAtomic ())) {
                    atom = lit_str ("");
                    algty = atom.type = aat_uA;
                }
                else
                    PFoops (OOPS_FATAL,
                            "don't know the algebra equivalent of type %s",
                            PFty_str (L(p)->type));

                sort_attr = disjunion (
                                attach (
                                    project (cast (sort_attr,
                                                   att_cast, att_item, algty),
                                             proj (att_iter, att_iter),
                                             proj (att_item, att_cast)),
                                    att_pos,
                                    lit_nat ((p->sem.mode.dir == p_desc) ^
                                             (p->sem.mode.empty == p_least))),
                                attach (
                                    attach (
                                        difference (
                                            loop,
                                            project (A(L(p)).rel, 
                                                     proj (att_iter,
                                                           att_iter))),
                                        att_item, atom),
                                    att_pos,
                                    lit_nat ((p->sem.mode.dir == p_desc) ^
                                             (p->sem.mode.empty != p_least))));
                empty = 1;
            }

            /* extend the backmapping relation map with
             * (a) position information of the for-loop input sequence and
             * (b) the current iteration values */
            map_count++;
            atts = PFmalloc ((map_count + empty) * sizeof (PFalg_proj_t));
            /* columns outer and inner remain the same */
            atts[0].new = att_outer;
            atts[0].old = att_outer;
            atts[1].new = att_inner;
            atts[1].old = att_inner;
            /* copy all old sort columns */
            for (unsigned i = 2; i < map_count - 1; i++)
                atts[i].new = 
                atts[i].old = att_sort << (i - 2);
            /* we now have on additional sort column generated 
               from column item (and possible pos) */
            if (empty) {
                atts[map_count -1].new = att_sort << (map_count - 3);
                atts[map_count -1].old = att_pos;
                map_count++;
            }
            /* the first sort criterion is column sort itself */
            atts[map_count -1].new = att_sort << (map_count - 3);
            atts[map_count -1].old = att_item;
            

            map = PFla_project_ (eqjoin (map, sort_attr, att_inner, att_iter),
                                 map_count, atts);

        /* OrderSpecs:         orderspecs (CoreExpr, OrderSpecs) */
        /* case 301: */
            /* complete rule 301 */
            if (rule == 301)
                /* translate remaining OrderSpecs */
                reduce (kids[1], nts[1]);
            
        } break;

        /* CoreExpr:           ordered (CoreExpr) */
        case 14:
        {   /* TOPDOWN */
 
            /* use `ordered' information */
            bool old_ordering = ordering;
            ordering = true;

            reduce (kids[0], nts[0]);

            A(p) = A(L(p));

            /* reset ordering mode */
            ordering = old_ordering;
        } break;

        /* CoreExpr:           unordered (CoreExpr) */
        case 15:
        {   /* TOPDOWN */
 
            /* use `ordered' information */
            bool old_ordering = ordering;
            ordering = false;

            reduce (kids[0], nts[0]);

            A(p) = A(L(p));

            /* reset ordering mode */
            ordering = old_ordering;
        } break;

        /* CoreExpr:           typesw (Atom,
                                       cases (case_ (seqtype,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 20:
        {   /* TOPDOWN */

            /*
             * CoreExpr1 is the expression to be switched. CoreExpr2 
             * compiles one (the current) case branch. CoreExpr3 is
             * either another typeswitch representing the next case
             * branch or the default branch of the overall typeswitch.
             *
             * A lot of work for this translation is captured in the
             * function type_test(). Given an algebra expression and
             * an XQuery sequence type, it will return a relation
             * with columns `iter' and `subty', with `subty' set to
             * true or false, depending on whether for this iteration
             * the sequence type test succeeds or not.
             *
             * env,loop: e1 => q1,delta1
             * tested_q1 = type_test (ty, q1, loop)
             * 
             * -- translate stuff in the `case' branch
             *  loop2 = proj_iter (select_subty (tested_q1))
             *  {..., $v -> proj_iter,pos,item (
             *    qv |X| (iter = iter1) (proj_iter1:iter loop2))},
             *   loop2: e2 => q2,delta2
             * 
             * -- and in the `default' branch
             *  loop3 = proj_iter (select_notsub (not_notsub:subty (tested_q1)))
             *  {..., $v -> proj_iter,pos,item (
             *    qv |X| (iter = iter1) (proj_iter1:iter loop3))},
             *   loop3: e3 => q3,delta3
             * 
             * ---------------------------------------------------------------
             *  env,loop:
             *  typeswitch (e1) case ty return e2 default return e3 =>
             *    (q2 U q3, delta2 U delta3)
             *
             * NB: the TYPE operator creates a new column of type boolean;
             * it examines whether the specified column is of given type "ty";
             * if this is the case, it sets the new column to true, otherwise
             * to false.
             */

            PFla_op_t   *tested_q1;  /* true/false if iterat. satisfies test */
            PFarray_t   *old_env;    /* backup of surrounding environment */
            PFla_op_t   *old_loop;   /* backup of surrounding loop relation */
            PFla_env_t   e;          /* helper variable */
            PFla_op_t   *new_map;    /* helper variable */
            unsigned int  i;

            /* translate CoreExpr1 */
            reduce (kids[0], nts[0]);

            tested_q1 = type_test (RLL(p)->sem.type, A(L(p)), loop);

            /* translate stuff in the `case' branch */

            /* map `loop' relation */
            old_loop = loop;
            loop = project (select_ (tested_q1, att_subty),
                            proj (att_iter, att_iter));

            /* map variable environment */
            old_env = env;
            env = PFarray (sizeof (PFla_env_t));

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (
                                  loop,
                                  proj (att_outer, att_iter),
                                  proj (att_inner, att_iter));
                else
                    new_map = project (
                                  eqjoin (
                                      e.map,
                                      loop,
                                      att_inner,
                                      att_iter),
                                  proj (att_outer, att_outer),
                                  proj (att_inner, att_inner));

                *((PFla_env_t *) PFarray_add (env))
                    = enventry (e.var, e.rel, new_map, e.frag);
            }

            /* translate CoreExpr2 */
            reduce (kids[1], nts[1]);

            /* translate stuff in the `default' branch (equivalently) */

            /* map `loop' relation */
            loop = project (select_ (not (tested_q1, att_notsub, att_subty),
                                     att_notsub),
                            proj (att_iter, att_iter));

            env = PFarray (sizeof (PFla_env_t));

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (
                                  loop,
                                  proj (att_outer, att_iter),
                                  proj (att_inner, att_iter));
                else
                    new_map = project (
                                  eqjoin (
                                      e.map,
                                      loop,
                                      att_inner,
                                      att_iter),
                                  proj (att_outer, att_outer),
                                  proj (att_inner, att_inner));

                *((PFla_env_t *) PFarray_add (env))
                    = enventry (e.var, e.rel, new_map, e.frag);
            }

            /* translate CoreExpr3 */
            reduce (kids[2], nts[2]);

            /* reset loop relation and environment */
            loop = old_loop;
            env = old_env;

            A(p) = (struct PFla_pair_t) {
                .rel  = disjunion (A(RLR(p)).rel, A(RRL(p)).rel),
                .frag = PFla_set_union (A(RLR(p)).frag, A(RRL(p)).frag)
            };

        } break;

        /* CoreExpr:           cast (seqtype, CoreExpr) */
        case 21:
        {
            PFty_t              t;
            PFalg_simple_type_t algty;

            t = PFty_prime (PFty_defn (L(p)->sem.type));

            /*
             * Unfortunately, we only know how to cast atomic types
             * into (exactly) one of our builtin atomic types. We
             * cannot sensibly cast, e.g., into subtypes thereof.
             */
            if (PFty_equality (t, PFty_xs_string ()))
                algty = aat_str;
            else if (PFty_equality (t, PFty_untypedAtomic ()))
                algty = aat_uA;
            else if (PFty_equality (t, PFty_xs_integer ()))
                algty = aat_int;
            else if (PFty_equality (t, PFty_xs_decimal ()))
                algty = aat_dec;
            else if (PFty_equality (t, PFty_xs_double ()))
                algty = aat_dbl;
            else if (PFty_equality (t, PFty_xs_boolean ()))
                algty = aat_bln;
            else
                PFoops (OOPS_FATAL,
                        "don't know the algebra equivalent of type %s",
                        PFty_str (L(p)->sem.type));

            A(p) = (struct PFla_pair_t) {
                .rel  = project (cast (A(R(p)).rel, att_cast, att_item, algty),
                                 proj (att_iter, att_iter),
                                 proj (att_pos, att_pos),
                                 proj (att_item, att_cast)),
                .frag = A(R(p)).frag };

        } break;

        /* CoreExpr:           seqcast (seqtype, CoreExpr) */
        case 22:
            /*
             * `seqcast' nodes are only introduced for static typing.
             * They are not meant to be executed.
             */
            A(p) = A(R(p));
            break;

        /* CoreExpr:     locsteps (ancestor (seqtype), CoreExpr) */
        case 30:
            A(p) = locstep (alg_anc, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (ancestor_or_self (seqtype), CoreExpr) */
        case 31:
            A(p) = locstep (alg_anc_s, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (attribute (seqtype), CoreExpr) */
        case 32:
            A(p) = locstep (alg_attr, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (child (seqtype), CoreExpr) */
        case 33:
            A(p) = locstep (alg_chld, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (descendant (seqtype), CoreExpr) */
        case 34:
            A(p) = locstep (alg_desc, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (descendant_or_self (seqtype), CoreExpr) */
        /* LocationStep:       descendant_or_self (seqtype) */
        case 35:
            A(p) = locstep (alg_desc_s, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (following (seqtype), CoreExpr) */
        case 36:
            A(p) = locstep (alg_fol, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (following_sibling (seqtype), CoreExpr) */
        case 37:
            A(p) = locstep (alg_fol_s, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (parent (seqtype), CoreExpr) */
        case 38:
            A(p) = locstep (alg_par, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (preceding (seqtype), CoreExpr) */
        case 39:
            A(p) = locstep (alg_prec, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (preceding_sibling (seqtype), CoreExpr) */
        case 40:
            A(p) = locstep (alg_prec_s, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (self (seqtype), CoreExpr) */
        case 41:
            A(p) = locstep (alg_self, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:           elem (TagName, CoreExpr) */
        case 50:
        {
            /*
             * CoreExpr (q2) evaluates to a sequence of nodes. TagName (q1)
             * is the name of a new node which becomes the common root of
             * the constructed nodes.
             *
             * env, loop: e1 => q1, doc (q1)
             * env, loop: e2 => q2, doc (q2)
             *
             * n = element (doc (q2), q1, q2)
             * -----------------------------------------------------------------
             * env, loop: element e1 {e2} =>
             *                                               pos
             * result:    (proj_iter,item:pre (roots (n))) x -----
             *                                                1
             *                                                          zero
             *    where roots (n) = sel (res)(= res:(level, zero) (n x ------))
             *                                                            0
             *
             * frag:       proj_pre,size,level,kind,prop,frag (n)
             */

            PFla_op_t *elem = element (PFla_set_to_la (A(R(p)).frag),
                                       A(L(p)).rel, A(R(p)).rel,
                                       att_iter, att_item,
                                       att_iter, att_pos, att_item,
                                       att_iter, att_item);

            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (roots (elem),
                                    att_pos, lit_nat (1)),
                     .frag = PFla_set (fragment (elem))};
        } break;

        /* CoreExpr:           attr (TagName, CoreExpr) */
        case 51:
        {
            /*
             * CoreExpr (q2) evaluates to a sequence of attributes. TagName
             * (q1) is the name of a new node which becomes the common root
             * of the constructed attributes.
             *
             * env, loop: e1 => q1, doc (q1)
             * env, loop: e2 => q2, doc (q2)
             *
             * n = attribute (doc (q2), q1, q2)
             * ----------------------------------------------------------------
             * env, loop: attribute e1 {e2} =>
             *                                               pos
             * result:    (proj_iter,item:pre (roots (n))) x -----
             *                                                1
             *                                                          zero
             *    where roots (n) = sel (res)(= res:(level, zero) (n x ------))
             *                                                            0
             *
             * frag:       proj_pre,size,level,kind,prop,frag (n)
             */

            PFla_op_t *attr = attribute (
                                  eqjoin (
                                      A(L(p)).rel,
                                      project (A(R(p)).rel,
                                               proj (att_iter1, att_iter),
                                               proj (att_item1, att_item)),
                                      att_iter, att_iter1),
                                  att_res, att_item, att_item1);

            A(p) = (struct  PFla_pair_t) {
                     .rel = project(roots (attr),
                                    proj (att_iter, att_iter),
                                    proj (att_pos, att_pos),
                                    proj (att_item, att_res)),
                     .frag = PFla_set (fragment (attr))};
        } break;

        /* TagName:            tag */
        case 400:
            A(p) = (struct PFla_pair_t) {
                .rel = attach (
                           attach (loop,
                                   att_pos, lit_nat (1)),
                           att_item, lit_qname (p->sem.qname)),
                .frag = PFla_empty_set () };
            break;

        /* TagName:            CoreExpr */
        case 401:
            break;

        /* CoreExpr:           text (CoreExpr) */
        case 52:
        {
            /*
             * env, loop: e => q, doc (q)
             *
             * n = textnode (doc (q), q)
             * ----------------------------------------------------------------
             * env, loop: textnode e =>
             *                                               pos
             * result:    (proj_iter,item:pre (roots (n))) x -----
             *                                                1
             *                                                          zero
             *    where roots (n) = sel (res)(= res:(level, zero) (n x ------))
             *                                                            0
             *
             * frag:       proj_pre,size,level,kind,prop,frag (n)
             */
            PFla_op_t *textnode = textnode (A(L(p)).rel, att_res, att_item);

            A(p) = (struct  PFla_pair_t) {
                     .rel = project(roots (textnode),
                                    proj (att_iter, att_iter),
                                    proj (att_pos, att_pos),
                                    proj (att_item, att_res)),
                     .frag = PFla_set (fragment (textnode))};
        } break;

        /* CoreExpr:           doc (CoreExpr) */
        case 53:
        {
            /*
             * env, loop: e => q, doc (q)
             *
             * n = docnode (doc (q), q)
             * ----------------------------------------------------------------
             * env, loop: docnode e =>
             *                                               pos
             * result:    (proj_iter,item:pre (roots (n))) x -----
             *                                                1
             *                                                          zero
             *    where roots (n) = sel (res)(= res:(level, zero) (n x ------))
             *                                                            0
             *
             * frag:       proj_pre,size,level,kind,prop,frag (n)
             */
            PFla_op_t *docnode = docnode (PFla_set_to_la (A(L(p)).frag),
                                           A(L(p)).rel);

            A(p) = (struct  PFla_pair_t) {
                     .rel = roots (docnode),
                     .frag = PFla_set (fragment (docnode))};
        } break;

        /* CoreExpr:           comment (CoreExpr) */
        case 54:
            /* FIXME: to do */
            PFoops (OOPS_FATAL, "Comment not implemented");
            break;

        /* CoreExpr:           pi (CoreExpr) */
        case 55:
            /* FIXME: to do */
            PFoops (OOPS_FATAL, "Processing Instruction not implemented");
            break;

        /* CoreExpr:           apply (FunctionArgs) */
        case 60:
        {   /* TOPDOWN*/

            /*
             * Function application (user-defined functions):
             *
             * (1) Save current variable environment.
             * (2) Enter bindings for all variables in the function
             *     signature to the variable environment.
             * (3) Invoke compilation for the function body (accessible
             *     via the PFfun_t struct).
             * (4) Restore variable environment.
             */

            PFarray_t  *old_env;
            PFarray_t  *old_fun_args;

            /* (1) Save current variable environment and create a new one. */
            old_env = env;

            env = PFarray (sizeof (PFla_env_t));

            for (unsigned int i = 0; i < PFarray_last (old_env); i++)
                *((PFla_env_t *) PFarray_add (env))
                    = *((PFla_env_t *) PFarray_at (old_env, i));

            /* (2) Enter bindings for function parameters.
             *     We do this by reducing our child nodes in a
             *     top-down fashion.
             */

            old_fun_args = fun_args;

            /* We will collect the argument values here */
            fun_args = PFarray (sizeof (struct PFla_pair_t));

            /* Top-down processing puts all argument values into this array */
            reduce (kids[0], nts[0]);

            /* All function arguments are now in the array `fun_args'. */

            if (p->sem.fun->builtin) {
                /*
                 * For built-in functions use this array to call the
                 * algebraic representation of the function (builtins.c)
                 */
                if (!p->sem.fun->alg)
                    PFoops (OOPS_FATAL,
                            "Algebra implementation for function `%s' unknown.",
                            PFqname_str (p->sem.fun->qname));

                A(p) = p->sem.fun->alg (loop, ordering, fun_args->base);

            }
            else {
                /*
                 * Otherwise bind parameter variables to the argument
                 * values and invoke compilation for function body.
                 */
                for (unsigned int i = 0; i < p->sem.fun->arity; i++) {

                    PFla_pair_t curr_arg
                        = *(PFla_pair_t *) PFarray_at (fun_args, i);

                    *((PFla_env_t *) PFarray_add (env))
                        = enventry (p->sem.fun->params[i],
                                    curr_arg.rel,
                                    NULL,
                                    curr_arg.frag);
                }
                                
                fun_args = old_fun_args;

                /* check active user-defined functions */
                for (unsigned int i = 0; i < PFarray_last (fun_active); i++)
                    if (*((PFcnode_t **) PFarray_at (fun_active, i)) ==
                        p->sem.fun->core)
                        PFoops (OOPS_FATAL, 
                                "Algebra implementation cannot cope "
                                "with recursive functions yet.");

                /* add function to the active ones */ 
                *((PFcnode_t **) PFarray_add (fun_active)) =
                    p->sem.fun->core;

                /* (3) Invoke compilation of the function body. */
                reduce (p->sem.fun->core, 1);

                /* remove function from the active ones */
                PFarray_del (fun_active);

                A(p) = A(p->sem.fun->core);
            }

            /* (4) Restore variable environment. */
            env = old_env;

        } break;

        /* FunctionArgs:       nil */
        case 500:
            break;

        /* FunctionArgs:       arg (FunctionArg, FunctionArgs) */
        case 501:
        {   /* TOPDOWN */

            /* translate the argument itself */
            reduce (kids[0], nts[0]);

            /* Append the new argument to function argument list */
            *((PFla_pair_t *) PFarray_add (fun_args)) = A(L(p));

            /* go on to next arguments */
            reduce (kids[1], nts[1]);

        } break;

        /* FunctionArg:        Atom */
        case 502:
            break;

        /* CoreExpr:           recursion (var, seed (Atom, CoreExpr)) */
        case 72:
        {   /* TOPDOWN */
            /*
             * with $x seeded by e1 return e2
             *
             * There are two approaches to translate the above pattern:
             *  * a delta based approach
             *  * an approach that uses the result of the current recursion
             *    step as input for next one
             *  * an approach that uses the overall result as input for the
             *    next recursion step
             *
             * We choose to translate the recursion with the third approach
             * as XQuery allows positional access as well as aggregates inside
             * the recursion body -- a delta approach would thus return the
             * wrong results. Whenever all the operators inside the recursion
             * body do not rely on the result size and positions we can choose
             * the (probably cheaper) delta approach.
             * The delta and the last result approach both need to change
             * the environment as well as the loop relation as less iterations
             * may be required in the next recursive call.
             *
             * The recursion is translated with the help of the following
             * algebra nodes:
             *  * rec_fix:   the head of the recursion referring
             *               to the overall result
             *  * rec_param: one item of a variable length parameter list 
             *               (thus coping with UDFs that have an arbitrary
             *                number or arguments)
             *  * rec_nil:   the end of the parameter list
             *  * rec_arg:   the operator that manages the connections
             *               between seed argument, the recursive call, and
             *               both its input to the next recursion (base)
             *  * rec_base:  a dummy operator representing the algebraic
             *               expression representing the input of the recursion
             *               (either seed or recursive call)
             * 
             * The recursion (translated based on the more general approach)
             * will be mapped into the following DAG (e1 -> q1; e2 -> q2;
             * child edges: '---'; 'semantical' edges: '- -')
             *
             *         rownum_(pos:<item>||iter)
             *            |
             *         distinct
             *            |
             *         rec_fix
             *            |  \_____________________________
             *        rec_param                            \
             *        /       \________________             \
             *    rec_arg                      \            |
             *    /  |  \                  rec_param        |
             *    |      \                  /      \        |
             *   / \  \   \             rec_arg  rec_nil    /
             *  /q1 \      \            /  \  \___   ______/
             * /_____\ |    |     iter|item       \ /
             *              |     ----|----  \     U (2)
             *         |    |         |           / \
             *              |           (base)|  /  diff (1)
             *         | rownum_                 |   | \
             *          (pos:<item>||iter)    |  | __|__\
             *         |    |                    |/  |
             *           (use (1), (2), or    \  |   |
             *         |  (3) as input)     rec_base |
             *   (base)     | ______________________/ 
             *         |    |/
             *           distinct (3)
             *         |    |
             *           pi_(iter, item)
             *         |    |   
             *             / \  
             *         |  /q1 \
             *           /_____\
             *          \   |
             *             /
             *         rec_base
             *
             */

/* different strategies to process the recursion */
#define DELTA 1
#define TC 2
#define IFP 0 /* choose 0 to ensure that the loop mapping is discarded */
/* different strategies to include the seed */
#define STAR 3
#define PLUS 4
             
/* choose strategy */
#define STRATEGY IFP
#define RESULT STAR

            unsigned int   i;
            PFla_op_t     *base_x, *base_res;
            PFla_op_t     *res_seed, *res_body, *delta, *res;
            PFalg_schema_t schema, res_schema;
#if STRATEGY
            PFla_env_t     e;
            PFarray_t     *old_env;
            PFla_op_t     *new_map;    
            PFla_op_t     *old_loop, *base_loop, *updated_loop;
#endif

            /* initiate translation of e1 */
            reduce (kids[0], nts[0]);

            /* We know that the order of the result is only required
               outside the recursive function. Thus we throw away the
               pos column. */
            res_schema.count = 2;
            res_schema.items = PFmalloc (2 * sizeof (PFalg_schema_t));

            schema = A(RL(p)).rel->schema;
            assert (schema.count == 3);
            for (i = 0; i < 3; i++) {
                if (schema.items[i].name == att_iter)
                    res_schema.items[0] = schema.items[i];
                else if (schema.items[i].name == att_item)
                    res_schema.items[1] = schema.items[i];
                else if (schema.items[i].name == att_pos)
                    /* do nothing */;
                else
                    PFoops (OOPS_FATAL,
                            "Input schema contains other "
                            "columns than iter, pos, item");
            }

            /* create a new base for variable $x */
            base_x = rec_base (schema);
            
            /* create a new result seed */
            res_seed = PFla_empty_tbl_ (res_schema);
            /* create a new result base */
            base_res = rec_base (res_schema);

#if RESULT == STAR
            /* ensure that res_seed is also used
               for the strategy IFP */
            (void) res_seed;
#endif

#if STRATEGY
            /* create a new base_loop relation */
            base_loop = rec_base (loop->schema);
            
            /* save old enviroment */
            old_env = env;
            /* save old loop operator */
            old_loop = loop;

            /* create new environment */
            env = PFarray (sizeof (PFla_env_t));

            /* update all variable bindings in old environment and put
             * them into new environment */
            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (
                                  loop,
                                  proj (att_outer, att_iter),
                                  proj (att_inner, att_iter));
                else
                    new_map = project (
                                  eqjoin (
                                      e.map,
                                      loop,
                                      att_inner,
                                      att_iter),
                                  proj (att_outer, att_outer),
                                  proj (att_inner, att_inner));

                *((PFla_env_t *) PFarray_add (env))
                    = enventry (e.var, e.rel, new_map, e.frag);
            }

            loop = base_loop;
#endif
            
            /* insert $x and "its document" into the NEW environment */
            *((PFla_env_t *) PFarray_add (env))
                = enventry (L(p)->sem.var, base_x, NULL, A(RL(p)).frag);

            /* translate e2 under the specified conditions 
             * (updated environment, updated loop)
             */
            reduce (kids[1], nts[1]);

            /* the result of the recursion body */
            res_body = distinct (project (A(RR(p)).rel,
                                          proj (att_iter, att_iter),
                                          proj (att_item, att_item)));
            
            /* get the really new nodes */
            delta = difference (res_body,
                                project (base_res,
                                         proj (att_iter, att_iter),
                                         proj (att_item, att_item)));

            /* add the new nodes (of this recursion step) 
               to our already collected result */
            res = disjunion (delta,
                             project (base_res,
                                      proj (att_iter, att_iter),
                                      proj (att_item, att_item)));
            
#if STRATEGY
            updated_loop = project (eqjoin (distinct (
                                                project (delta, 
                                                         proj (att_iter1, 
                                                               att_iter))),
                                            base_loop,
                                            att_iter1,
                                            att_iter),
                                    proj (att_iter, att_iter));
#endif

            A(p) = (struct PFla_pair_t) {
                     .rel = rownum (
                                rec_fix (
                                    rec_param (
                                        rec_arg (
                                            A(RL(p)).rel,
                                            rownum (
            /* using 'distinct (delta)' or 'distinct (res_body)'
               instead of 'res' changes the evaluation strategy:
                - 'delta': only the really new nodes are the input
                  for the next recursion
                - 'res_body': the result of the current recursion
                  is the input for the next recursion
                - 'res': the whole result collected until now
                  is input to the next recurstion step */
#if STRATEGY == DELTA
                    /* (1) */                   delta,
#elif STRATEGY == IFP
                    /* (2) */                   res,
#else /* STRATEGY == TC */
                    /* (3) */                   res_body,
#endif
                                                att_pos,
                                                sortby (att_item),
                                                att_iter),
                                            base_x),
                                        rec_param (
                                            rec_arg (
#if RESULT == STAR
                                                project (A(RL(p)).rel,
                                                         proj (att_iter, 
                                                               att_iter),
                                                         proj (att_item,
                                                               att_item)),
#else /* PLUS */
                                                res_seed,
#endif
                                                res,
                                                base_res),
#if STRATEGY
            /* using 'delta' instead of 'res_body' changes the evaluation
               strategy: the loop relation cannot be changed */
                                            rec_param (
                                                rec_arg (
                                                    old_loop,
                                                    updated_loop,
                                                    base_loop),
                                                rec_nil ()))),   
#else
                                            rec_nil ())),
#endif
                                    res),
                                att_pos, sortby (att_item), att_iter),
                     .frag = A(RR(p)).frag };
            
#if STRATEGY
            env = old_env;
            loop = old_loop;
#endif
        } break;

        default:
            PFoops (OOPS_FATAL, "untranslated expression (rule %i)", rule);
            break;
    }

    /* check consistency of our iter|pos|item interface */
    switch (p->kind) {
        case c_main:
        case c_for:
        case c_let:
        case c_nil:
        case c_orderspecs:
        case c_arg:
            break;
        default:
        {
            unsigned int count = 0;
            for (unsigned int i = 0; i < A(p).rel->schema.count; i++)
                if (A(p).rel->schema.items[i].name == att_iter ||
                    A(p).rel->schema.items[i].name == att_pos  ||
                    A(p).rel->schema.items[i].name == att_item)
                    count++;
            if (A(p).rel->schema.count != 3 && count !=3)
                PFoops (OOPS_FATAL,
                        "We require each core construct (also %i) to "
                        "return a relation with an iter|pos|item schema.",
                        p->kind);
        }
    }
}

/**
 * Construct a relational expression for a staircase join
 */
static struct PFla_pair_t
locstep (PFalg_axis_t axis, PFty_t seqty, struct PFla_pair_t p)
{
    /*
     *                  env, loop: e => (q(e), delta)
     * ------------------------------------------------------------
     *                       env, loop: e/a::n =>
     * (row_pos<item>/iter (SCJ (proj_iter,item (q(e)), delta)), delta)
     *
     * A(L(p)).rel contains a axis node with information on the
     * location step. Will be read out in PFla_scjoin().
     */
    PFla_op_t *scjoin = scjoin (PFla_set_to_la (p.frag),
                                project (p.rel,
                                         proj (att_iter, att_iter),
                                         proj (att_item, att_item)),
                                axis, seqty, att_iter, att_item, att_item);

    if (ordering)
        return (struct  PFla_pair_t) {
                   .rel = rownum (scjoin, att_pos, sortby (att_item), att_iter),
                   .frag = p.frag };
    else
        return (struct  PFla_pair_t) {
                   .rel = number (scjoin, att_pos, att_iter),
                   .frag = p.frag };
}

/**
 * Construct a new entry to be inserted into the variable environment.
 * Called whenever a new variable is declared.
 */
static PFla_env_t
enventry (PFvar_t *var, PFla_op_t *rel, PFla_op_t *map, PFarray_t *doc)
{
    return (PFla_env_t) { .var = var, .rel = rel, .map = map, .frag = doc };
}

/**
 * Given an XQuery type @a ty, an algebra expression @a e, and the
 * loop relation @a loop, return an algebra expression that returns
 * the relation with schema (iter, subty), so that for each iter value
 * in @a loop there exists one tuple, with the subty attribute set to
 * true, if @a e has a subtype of @a ty, and false otherwise.
 */
static PFla_op_t *
type_test (PFty_t ty, PFla_pair_t e, PFla_op_t *loop)
{
    PFla_op_t *itemty;

    /*
     * Collect algebra expression with schema (iter,pos,itemty)
     * so that itemty is true for any item that is a subtype of
     * ty, and false otherwise.
     *
     * The surface language only allows QNames for predefined
     * types, or node kind tests. Fortunately, only few atomic
     * types are predefined: xs:integer, xs:decimal, xs:double,
     * xs:boolean, xs:string. For all of them we have an algebra
     * correspondance.
     * 
     * We first consider the case that ty is the empty sequence.
     * (This cannot be entered on the surface language. But it
     * may be introduced during core generation/optimization.
     * And we want to avoid nasty bugs here, when that case would
     * be caught in the following cases.)
     *
     *        /                        subty \
     *       | dist (proj_iter (e)) X ------- |       (non-empty iters)
     *        \                        false /
     *                           U
     *    /                                 subty \
     *   | (loop \ dist (proj_iter (e))) X ------- |  (empty iters)
     *    \                                 false /
     *
     */
    if (PFty_subtype (ty, PFty_empty ()))
        return
            disjunion (
                attach (
                    distinct (project (e.rel, proj (att_iter, att_iter))),
                    att_subty, lit_bln (false)),
                attach (
                    difference (
                        loop,
                        distinct (project (e.rel, proj (att_iter, att_iter)))),
                    att_subty, lit_bln (true)));
    /*
     * To test, e.g., for integer values, use
     *
     *   proj_iter,pos,itemty (type_itemty:item/int (e))
     *
     */
    else if (PFty_subtype (ty, PFty_star (PFty_xs_integer ())))
        itemty = project (type (e.rel, att_itemty, att_item, aat_int),
                          proj (att_iter, att_iter),
                          proj (att_pos, att_pos),
                          proj (att_itemty, att_itemty));
    else if (PFty_subtype (ty, PFty_star (PFty_xs_decimal ())))
        /* xs:integer is a subtype of xs:decimal.
         * Test for both types. The `type' operator merely adds a boolean
         * column. We OR them after testing for for both types.
         */
        itemty =
            project (
                or (type (type (e.rel, att_isint, att_item, aat_int),
                          att_isdec, att_item, aat_dec),
                    att_itemty, att_isint, att_isdec),
                proj (att_iter, att_iter),
                proj (att_pos, att_pos),
                proj (att_itemty, att_itemty));
    else if (PFty_subtype (ty, PFty_star (PFty_xs_double ())))
        itemty = project (type (e.rel, att_itemty, att_item, aat_dbl),
                          proj (att_iter, att_iter),
                          proj (att_pos, att_pos),
                          proj (att_itemty, att_itemty));
    else if (PFty_subtype (ty, PFty_star (PFty_xs_boolean ())))
        itemty = project (type (e.rel, att_itemty, att_item, aat_bln),
                          proj (att_iter, att_iter),
                          proj (att_pos, att_pos),
                          proj (att_itemty, att_itemty));
    else if (PFty_subtype (ty, PFty_star (PFty_xs_string ())))
        itemty = project (type (e.rel, att_itemty, att_item, aat_str),
                          proj (att_iter, att_iter),
                          proj (att_pos, att_pos),
                          proj (att_itemty, att_itemty));
    else if (PFty_subtype (ty, PFty_star (PFty_untypedAtomic ())))
        itemty = project (type (e.rel, att_itemty, att_item, aat_uA),
                          proj (att_iter, att_iter),
                          proj (att_pos, att_pos),
                          proj (att_itemty, att_itemty));
    else
        PFoops (OOPS_FATAL,
                "Sorry, I cannot translate the test for type `%s'",
                PFty_str (ty));


    /*
     * Second part is the test for the occurence indicator.
     */

    /*
     * Ocurrence indicator `1' (exactly one item).
     *
     * seqty1_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty\
     * | (loop \ proj_iter (itemty)) X ----- |
     *  \                              false/
     *
     * (First part considers all iterations with length of at
     * least one: The itemty expression contains true/false values
     * as determined above. The seqty1 operator sets true for all
     * those `iter' groups, where there is exactly one tuple with
     * value `true', and false otherwise. The second part of the
     * union considers all the empty sequences. They do not match
     * the occurrence indicator and are thus set to false.)
     */
    if (PFty_subtype (ty, PFty_item ()))
        return
            disjunion (
                seqty1 (project (itemty,
                                 proj (att_iter, att_iter),
                                 proj (att_item, att_itemty)),
                        att_subty, att_item, att_iter),
                attach (
                    difference (
                        loop,
                        project (itemty, proj (att_iter, att_iter))),
                    att_subty, lit_bln (false)));

    /*
     * Ocurrence indicator `?' (zero or one item).
     *
     * seqty1_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty\
     * | (loop \ proj_iter (itemty)) X ----- |
     *  \                              true /
     *
     * In contrast to `1', we return true for all empty sequences.
     */
    if (PFty_subtype (ty, PFty_opt (PFty_item ())))
        return
            disjunion (
                seqty1 (project (itemty,
                                 proj (att_iter, att_iter),
                                 proj (att_item, att_itemty)),
                        att_subty, att_item, att_iter),
                attach (
                    difference (
                        loop,
                        project (itemty, proj (att_iter, att_iter))),
                    att_subty, lit_bln (true)));

    /*
     * Ocurrence indicator `+' (one or more items).
     *
     * all_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty \
     * | (loop \ proj_iter (itemty)) X -----  |
     *  \                              false /
     *
     * Groupwise test if all tuples in itemty carry a `true'.
     * This makes all iterations true that contain only items
     * that satisfy the type test, and false all those that
     * contain at least one item that does not satisfy the
     * type test. We are left with considering the empty sequences
     * that do not qualify for the name test. We return false for
     * them.
     */
    if (PFty_subtype (ty, PFty_plus (PFty_item ())))
        return
            disjunion (
                all (project (itemty,
                              proj (att_iter, att_iter),
                              proj (att_item, att_itemty)),
                     att_subty, att_item, att_iter),
                attach (
                    difference (
                        loop,
                        project (itemty, proj (att_iter, att_iter))),
                    att_subty, lit_bln (false)));

    /*
     * Ocurrence indicator `*' (zero or more items).
     *
     * all_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty\
     * | (loop \ proj_iter (itemty)) X ----  |
     *  \                              true /
     *
     * Almost the same as `+', but return true for empty sequences.
     */
    if (PFty_subtype (ty, PFty_star (PFty_item ())))
        return
            disjunion (
                all (project (itemty,
                              proj (att_iter, att_iter),
                              proj (att_item, att_itemty)),
                     att_subty, att_item, att_iter),
                attach (
                    difference (
                        loop,
                        project (itemty, proj (att_iter, att_iter))),
                    att_subty, lit_bln (true)));

    /*
     * We should never reach this point.
     */
    PFoops (OOPS_FATAL, "Error in type_test().");
    assert(0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}


/**
 * Compile XQuery Core tree into relational algebra tree.
 *
 * @param r root of the Core tree.
 * @return the algebra equivalent of @a r
 */
PFla_op_t *
PFcore2alg (PFcnode_t *r)
{
    assert (r);

    /* yet empty environment */
    env = PFarray (sizeof (PFla_env_t));

    /* loop is initially a table with just one tuple */
    loop = lit_tbl (attlist (att_iter), tuple (lit_nat (1)));

    /* set ordering mode */
    ordering = PFquery.ordering;

    /* Pointer to array of function parameter values */
    fun_args = NULL;

    /* Initialize stack recording the active user-defined functions */
    fun_active = PFarray (sizeof (PFcnode_t *));

    /* label the core tree bottom up */
    PFcore2alg_label (r);

    /* invoke compilation */
    reduce (r, 1);

    return A(r).rel;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
