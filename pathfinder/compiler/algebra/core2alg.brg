%{

/**
 * @file
 *
 * Compile Core tree into relational algebra.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * the Database Group at the Technische Universitaet Muenchen, Germany.
 * It is now maintained by the Database Systems Group at the Eberhard
 * Karls Universitaet Tuebingen, Germany.  Portions created by the
 * University of Konstanz, the Technische Universitaet Muenchen, and the
 * Universitaet Tuebingen are Copyright (C) 2000-2005 University of
 * Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
 * 2008-2010 Eberhard Karls Universitaet Tuebingen, respectively.  All
 * Rights Reserved.
 *
 *
 * $Id$
 */


#include "pf_config.h"
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "compile.h"
#include "oops.h"
#include "core.h"
#include "subtyping.h"
#include "qname.h"
#include "mem.h"
#include "alg_dag.h"
/* recursion-depth option */
#include "options.h"

/* PFvar_t */
#include "variable.h"

#include "algebra.h"
#include "builtins.h"

/* Easily access subtree-parts */
#include "child_mnemonic.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFcnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/core.h!
 */
%term var                =  1 /**< variable */
%term lit_str            =  2 /**< string literal */
%term lit_int            =  3 /**< integer literal */
%term lit_dec            =  4 /**< decimal literal */
%term lit_dbl            =  5 /**< double literal */
%term nil                =  6 /**< end-of-sequence marker */

%term seq                =  7 /**< sequence construction */
%term twig_seq           =  8 /**< sequence construction within twigs */
%term ordered            =  9
%term unordered          = 10

%term flwr               = 14 /**< flwr expression */
%term let                = 15 /**< let expression */
%term letbind            = 16 /**< binding part of a let expression */
%term for_               = 17 /**< for expression */
%term forbind            = 18 /**< binding part of a for expression */
%term forvars            = 19 /**< variable pair (var + pos. var) of a for */

%term where              = 20 /**< where clause */
%term orderby            = 21 /**< orderby clause */
%term orderspecs         = 22 /**< list of order specs */

%term apply              = 23 /**< function application */
%term arg                = 24 /**< function argument (list) */

%term typesw             = 25 /**< typeswitch clause */
%term cases              = 26 /**< case concatenation for typeswitch */
%term case_              = 27 /**< single case for typeswitch */
%term default_           = 28 /**< default branch in typeswitch */
%term seqtype            = 29 /**< a SequenceType */
%term seqcast            = 30 /**< cast along <: */

%term if_                = 34 /**< if-then-else conditional */
%term then_else          = 35 /**< then- and else-branches of an
                                if-then-else conditional */

%term locsteps           = 40 /**< path of location steps only */

  /* XPath axes */
%term ancestor           = 41 /**< the parent, the parent's parent,... */
%term ancestor_or_self   = 42 /**< the parent, the parent's parent,... + self */
%term attribute          = 43 /**< attributes of the context node */
%term child              = 44 /**< children of the context node */
%term descendant         = 45 /**< children, children's children,... + self */
%term descendant_or_self = 46 /**< children, children's children,... */
%term following          = 47 /**< nodes after current node (document order) */
%term following_sibling  = 48 /**< all following nodes with same parent */
%term parent             = 49 /**< parent node (exactly one or none) */
%term preceding          = 50 /**< nodes before context node (document order) */
%term preceding_sibling  = 51 /**< all preceding nodes with same parent */
%term self               = 52 /**< the context node itself */
/* StandOff axes */
%term so_select_narrow      = 53 /**< the context node itself */
%term so_select_wide        = 54 /**< the context node itself */

  /* Constructor Nodes */
%term elem               = 55 /**< the element constructor */
%term attr               = 56 /**< the attribute constructor */
%term text               = 57 /**< the text constructor */
%term doc                = 58 /**< the document constructor */
%term comment            = 59 /**< the comment constructor */
%term pi                 = 60 /**< the processing-instruction constructor */
%term tag                = 61 /**< the tagname for elem. and attr. constr. */

%term true_              = 65 /**< built-in function `fn:true ()' */
%term false_             = 66 /**< built-in function `fn:false ()' */
%term empty              = 67 /**< built-in function `empty' */

%term main               = 68 /**< tree root.
                                   Separates function declarations from
                                   the query body. */
%term fun_decls          = 69 /**< list of function declarations */
%term fun_decl           = 70 /**< function declaration */
%term params             = 71 /**< function declaration parameter list */
%term param              = 72 /**< function declaration parameter */
%term cast               = 73 /**< function declaration parameter */

  /* Pathfinder extension: recursion */
%term recursion          = 74 /**< "with $v seeded by..." expression */
%term seed               = 75

  /* Pathfinder extension: XRPC */
%term xrpc               = 76 /**< XRPC calls: "execute at" */

%%

Query:              main (FunctionDecls, CoreExpr)              =   1 (10);
Query:              CoreExpr                                    =   2 (10);

CoreExpr:           Atom                                        =   3 (10);

Atom:               var                                         = 100 (10);
Atom:               LiteralValue                                = 101 (10);

LiteralValue:       lit_str                                     = 102 (10);
LiteralValue:       lit_int                                     = 103 (10);
LiteralValue:       lit_dec                                     = 104 (10);
LiteralValue:       lit_dbl                                     = 105 (10);
LiteralValue:       true_                                       = 106 (10);
LiteralValue:       false_                                      = 107 (10);
LiteralValue:       empty                                       = 108 (10);

CoreExpr:           flwr (OptBindExpr, WhereExpr)               =   4 (10);
CoreExpr:           flwr (OptBindExpr, OrdWhereExpr)            =   5 (10);

OptBindExpr:        for_ (forbind (forvars (var, OptVar),
                                   CoreExpr),
                          OptBindExpr)                          =   6 (10);

OptVar:             var                                         = 200 (10);
OptVar:             nil                                         = 201 (10);

OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr)  =   7 (10);
OptBindExpr:        nil                                         =   8 (10);

OrdWhereExpr:       where (CoreExpr, OrdWhereExpr)              =   9 (10);
OrdWhereExpr:       orderby (OrderSpecs, CoreExpr)              =  10 (10);

WhereExpr:          where (CoreExpr, WhereExpr)                 =  11 (10);
WhereExpr:          CoreExpr                                    =  12 (10);

OrderSpecs:         orderspecs (CoreExpr, nil)                  = 300 (10);
OrderSpecs:         orderspecs (CoreExpr, OrderSpecs)           = 301 (10);

CoreExpr:           if_ (CoreExpr,
                         then_else (CoreExpr, CoreExpr))        =  13 (10);

CoreExpr:           seq (CoreExpr, SeqCoreExpr)                 =  14 (10);
CoreExpr:           seq (CoreExpr, CoreExpr)                    =  15 (10);
SeqCoreExpr:        seq (CoreExpr, SeqCoreExpr)                 =  16 (10);
SeqCoreExpr:        seq (CoreExpr, CoreExpr)                    =  17 (10);

CoreExpr:           ordered (CoreExpr)                          =  18 (10);
CoreExpr:           unordered (CoreExpr)                        =  19 (10);

CoreExpr:           typesw (CoreExpr,
                            cases (case_ (seqtype,
                                          CoreExpr),
                                   default_ (CoreExpr)))        =  20 (10);

CoreExpr:           cast (seqtype, CoreExpr)                    =  21 (10);
CoreExpr:           seqcast (seqtype, CoreExpr)                 =  22 (10);

CoreExpr:     locsteps (ancestor (seqtype), CoreExpr)           =  30 (10);
CoreExpr:     locsteps (ancestor_or_self (seqtype), CoreExpr)   =  31 (10);
CoreExpr:     locsteps (attribute (seqtype), CoreExpr)          =  32 (10);
CoreExpr:     locsteps (child (seqtype), CoreExpr)              =  33 (10);
CoreExpr:     locsteps (descendant (seqtype), CoreExpr)         =  34 (10);
CoreExpr:     locsteps (descendant_or_self (seqtype), CoreExpr) =  35 (10);
CoreExpr:     locsteps (following (seqtype), CoreExpr)          =  36 (10);
CoreExpr:     locsteps (following_sibling (seqtype), CoreExpr)  =  37 (10);
CoreExpr:     locsteps (parent (seqtype), CoreExpr)             =  38 (10);
CoreExpr:     locsteps (preceding (seqtype), CoreExpr)          =  39 (10);
CoreExpr:     locsteps (preceding_sibling (seqtype), CoreExpr)  =  40 (10);
CoreExpr:     locsteps (self (seqtype), CoreExpr)               =  41 (10);
CoreExpr:     locsteps (so_select_narrow (seqtype), CoreExpr)   =  42 (10);
CoreExpr:     locsteps (so_select_wide (seqtype), CoreExpr)     =  43 (10);

CoreExpr:           TwigExpr                                    =  45 (20);

TwigSeq:            twig_seq (TwigExpr, TwigSeq)                =  46 (10);
TwigSeq:            TwigExpr                                    =  47 (10);

/* the following rule has to be more expensive then
   the normal empty rule as otherwise empty is mapped
   into an empty constructor */
TwigExpr:           empty                                       =  48 (20);
TwigExpr:           CoreExpr                                    =  49  (0);

TwigExpr:           doc (TwigSeq)                               =  50 (10);
TwigExpr:           elem (TagName, TwigSeq)                     =  51 (10);
TwigExpr:           attr (TagName, CoreExpr)                    =  52 (10);
TwigExpr:           text (CoreExpr)                             =  53 (10);
TwigExpr:           comment (CoreExpr)                          =  54 (10);
TwigExpr:           pi (CoreExpr, CoreExpr)                     =  55 (10);

TagName:            tag                                         = 400 (10);
TagName:            CoreExpr                                    = 401 (10);

CoreExpr:           apply (FunctionArgs)                        =  60 (10);
CoreExpr:           xrpc (CoreExpr, apply (FunctionArgs))       =  61 (10);

FunctionArgs:       nil                                         = 500 (10);
FunctionArgs:       arg (FunctionArg, FunctionArgs)             = 501 (10);

FunctionArg:        CoreExpr                                    = 502 (10);


FunctionDecls:      nil                                         =  70 (10);
FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls)     =  71 (10);

FunctionDecl:       fun_decl (ParamList, FunctionBody)          = 600 (10);

ParamList:          nil                                         = 601 (10);
ParamList:          params (FunParam, ParamList)                = 602 (10);

FunctionBody:       CoreExpr                                    = 603 (10);

FunParam:           param (seqtype, var)                        = 604 (10);

CoreExpr:           recursion (var, seed (CoreExpr, CoreExpr))  =  72 (10);

%%

/** Algebra equivalent of a Core tree node */
#define A(p) ((p)->alg)

#define SEEN(n) ((n)->bit_dag)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

/** mnemonic algebra constructors */
#include "logical_mnemonic.h"

struct map_rel_info_t {
    PFla_op_t   *map;   /* map relation */
    unsigned int count; /* column counter of the map relation */
    unsigned int dir;   /* sort direction of the columns in the
                           map relation */
};
typedef struct map_rel_info_t map_rel_info_t;

/**
 * Current map relation
 */
#define MAP (((map_rel_info_t *) PFarray_top (ctx->mapping))->map)

/**
 * Attribute counter of current map relation
 */
#define MAP_COUNT (((map_rel_info_t *) PFarray_top (ctx->mapping))->count)

/**
 * Sort direction of the columns
 * of the current map relation
 */
#define MAP_DIR (((map_rel_info_t *) PFarray_top (ctx->mapping))->dir)

/**
 * Remember the result of the initial algebra translation
 * (@a rel and @a frag) for core operators @a core
 * whose algebra translation is inferred a second time.
 */
struct core2alg_map_t {
    PFcnode_t *core;
    PFla_op_t *rel;
    PFarray_t *frag;
};
typedef struct core2alg_map_t core2alg_map_t;

#define CORE2ALG_MAP_AT(i) (*(core2alg_map_t *) PFarray_at (ctx->core2alg_map, \
                                                            (i)))

/**
 * structure to collect the active recursive functions
 * and their current ``unfold'' count
 */
struct fun_active_t {
    PFcnode_t   *node;
    unsigned int count;
};
typedef struct fun_active_t fun_active_t;

#define FUN_ACTIVE_AT(i) (*((fun_active_t *) PFarray_at (ctx->fun_active, (i))))

/**
 * Store global context information
 */
struct core2alg_ctx_t {
    PFarray_t   *env;          /* Variable environment (Gamma in our papers) */
    PFla_op_t   *loop;         /* Current loop relation */
    PFla_op_t   *side_effects; /* list of side effects (error or trace nodes) */
    PFarray_t   *mapping;      /* Mapping stack */
    bool         ordering;     /* ordering mode indicator */
    unsigned int seq_count;    /* sequence item counter (for long sequences) */

    PFarray_t   *fun_args;     /* Algebraic representations of the function
                                  arguments. (Aligned with the PFfun_t function
                                  parameters) */
    unsigned int recursion_depth; /* depth of how often we unfold a recursive
                                     function*/
    PFarray_t   *fun_active;   /* List recording all active user-defined
                                  functions as well as their unfold count. */
    PFarray_t   *core2alg_map; /* List of core to algebra translation mappings.
                                  (Used to clean up the side effects of a
                                   recursive traversal of the core tree.) */
};
typedef struct core2alg_ctx_t core2alg_ctx_t;

#define ENV          (ctx->env)
#define LOOP         (ctx->loop)
#define SIDE_EFFECTS (ctx->side_effects)
#define ORDERING     (ctx->ordering)
#define SEQ_COUNT    (ctx->seq_count)
#define FUN_ARGS     (ctx->fun_args)
#define CORE2ALG_MAP (ctx->core2alg_map)



/* Constructor for a path step */
static struct PFla_pair_t locstep (core2alg_ctx_t *ctx,
                                   PFalg_axis_t axis, PFty_t seqty,
                                   struct PFla_pair_t p);

/* Constructor for environment entry */
static PFla_env_t enventry (PFvar_t *var, PFla_op_t *rel,
                            PFla_op_t *map, PFarray_t *doc);

/* worker to implement type tests */
static PFla_op_t *type_test (PFty_t ty, PFla_pair_t e, PFla_op_t *loop);

/* Extract all possible algebra types from the XQuery type.  */
static PFalg_simple_type_t PFalg_type (PFty_t ty);

/* Extract occurrence indicator from the XQuery type.  */
static PFalg_occ_ind_t PFalg_type_occ (PFty_t ty);


typedef PFla_op_t * (rec_strategy_t) (
                                 int strategy,
                                 PFla_op_t *body,
                                 PFla_op_t *seed,
                                 PFla_op_t *res_seed,
                                 PFla_op_t *base,
                                 PFla_op_t *base_res,
                                 bool x_used,
                                 bool loop_used,
                                 PFla_op_t *old_loop,
                                 PFla_op_t *base_loop,
                                 PFla_op_t *side_effects);

/* recursion translation strategy for SQL */
static PFla_op_t *recursion_sql (int strategy,
                                 PFla_op_t *body,
                                 PFla_op_t *seed,
                                 PFla_op_t *res_seed,
                                 PFla_op_t *base,
                                 PFla_op_t *base_res,
                                 bool x_used,
                                 bool loop_used,
                                 PFla_op_t *old_loop,
                                 PFla_op_t *base_loop,
                                 PFla_op_t *side_effects);

/* recursion translation strategy for Monet */
static PFla_op_t *recursion_mil (int strategy,
                                 PFla_op_t *body,
                                 PFla_op_t *seed,
                                 PFla_op_t *res_seed,
                                 PFla_op_t *base,
                                 PFla_op_t *base_res,
                                 bool x_used,
                                 bool loop_used,
                                 PFla_op_t *old_loop,
                                 PFla_op_t *base_loop,
                                 PFla_op_t *side_effects);

enum PFoutput_format_t PFoutput_format;

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (core2alg_ctx_t *ctx, PFcnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFcnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */
    PFla_op_t    *rel  = NULL;
    PFarray_t    *frag = NULL;

    /* guard against too dep recursion */
    PFrecursion_fence();

    assert(p);

    /* determine rule that matches for this non-terminal */
    rule = PFcore2alg_rule (STATE_LABEL (p), goalnt);

    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFcore2alg_nts[rule];
    PFcore2alg_kids (p, rule, kids);

    /* In case we recursively generate the algebra plan
       we need to record the mappings that have changed
       to ensure that we are able to clean up the side
       effects again. */
    if (CORE2ALG_MAP) {
        rel  = A(p).rel;
        frag = A(p).frag;
    }

    /*
     * Few translation rules require top-down processing. We figure
     * them out here and skip the recursive compilation. The respective
     * rules will explicitly trigger the compilation of their kids.
     */
    switch (rule) {
        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:

        /* CoreExpr:           flwr (OptBindExpr, WhereExpr) */
        case 4:

        /* CoreExpr:           flwr (OptBindExpr, OrdWhereExpr) */
        case 5:

        /* OptBindExpr:        for_ (forbind (forvars (var, nil),
                                              CoreExpr),
                                     CoreExpr) */
        case 6:

        /* OptBindExpr:        let (letbind (var, CoreExpr), CoreExpr) */
        case 7:

        /* OrdWhereExpr:       where (CoreExpr, OrdWhereExpr) */
        case 9:

        /* OrdCoreExpr:        orderby (OrderSpecs, CoreExpr) */
        case 10:

        /* WhereExpr:          where (CoreExpr, WhereExpr) */
        case 11:

        /* OrderSpecs:         orderspecs (CoreExpr, nil) */
        case 300:

        /* OrderSpecs:         orderspecs (CoreExpr, OrderSpecs) */
        case 301:

        /* CoreExpr:           if_ (CoreExpr, then_else (CoreExpr, CoreExpr)) */
        case 13:

        /* CoreExpr:           seq (CoreExpr, SeqCoreExpr) */
        case 14:

        /* SeqCoreExpr:        seq (CoreExpr, SeqCoreExpr) */
        case 16:

        /* SeqCoreExpr:        seq (CoreExpr, CoreExpr) */
        case 17:

        /* CoreExpr:           ordered (CoreExpr) */
        case 18:

        /* CoreExpr:           unordered (CoreExpr) */
        case 19:

        /* CoreExpr:           typesw (CoreExpr,
                                       cases (case_ (seqtype,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 20:

        /* CoreExpr:           apply (FunctionArgs) */
        case 60:

        /* CoreExpr:           xrpc (CoreExpr, apply (FunctionArgs)) */
        case 61:

        /* FunctionArgs:       arg (FunctionArg, FunctionArgs) */
        case 501:

        /* CoreExpr:           recursion (var, seed (CoreExpr, CoreExpr)) */
        case 72:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    if (!topdown)
        for (unsigned short i = 0; nts[i]; i++)
            reduce (ctx, kids[i], nts[i]);

    switch (rule) {

        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:
            /* TOPDOWN */

            /*
             * Only the real XQuery expression is of interest, not the
             * function declaration part. Apply serialize_seq() to the
             * XQuery Core result.
             */
            reduce (ctx, kids[1], nts[1]);
            A(p) = (PFla_pair_t) {
                     .rel = serialize_seq (PFla_side_effects (
                                               SIDE_EFFECTS,
                                               PFla_set_to_la (A(R(p)).frag)),
                                           A(R(p)).rel, col_pos, col_item),
                     .frag = NULL };
            break;

        /* Query:              CoreExpr */
        case 2:
            /*
             * Defining CoreExpr also as a top-level non-terminal
             * allows us to recursively invoke matching for function
             * calls.
             */
            break;

        /* CoreExpr:           Atom */
        case 3:
            break;

        /* Atom:               var */
        case 100:
        {
            /*
             * Reference to variable, so look it up in the environment. It
             * was inserted into the environment by a let or for expression.
             *
             * ---------------------------------------------------------------
             * ENV, (v -> q(v)) e env, loop: v => (q(v), 0)
             */
            unsigned int i;
            PFla_op_t *var_rel;

            /*
             * look up the variable in the environment;
             * since it has already been ensured beforehand, that
             * each variable was declared before being used, we are
             * guarenteed to find the required binding in the
             * environment
             */

            /*
             * The variable representations in the variable environment
             * consist of 4 parts:
             *  - var: the variable name
             *  - rel: the initial relation representing the variable
             *  - map: the mapping information needed to map the relation
             *         rel to the current scope
             *  - frag: the document fragment information
             *
             * In constrast to the variable mapping described in our
             * papers we do not map the relation representing the variable
             * in each new scope, but first create a chain of mapping
             * joins. The variable representations therefore have to
             * be mapped to the current scope -- if necessary
             * (map != NULL) -- (via map) only during look-up (here).
             *
             * The reason is that this makes the optimization of such
             * chains of joins easier in later phases.
             */
            for (i = 0; i < PFarray_last (ENV); i++) {
                PFla_env_t e = *((PFla_env_t *) PFarray_at (ENV, i));

                if (p->sem.var == e.var) {
                    if (!e.map)
                        var_rel = e.rel;
                    else
                        var_rel = project (
                                      eqjoin (
                                          e.rel,
                                          e.map,
                                          col_iter,
                                          col_outer),
                                      proj (col_iter, col_inner),
                                      proj (col_pos,  col_pos),
                                      proj (col_item, col_item));

                    A(p) = (struct  PFla_pair_t) { .rel  = var_rel,
                                                   .frag = e.frag };
                    break;
                }
            }

            assert (A(p).rel); assert (A(p).frag);

        } break;

        /* Atom:               LiteralValue */
        case 101:
            break;

        /* LiteralValue:       lit_str */
        case 102:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (LOOP,
                                        col_pos, lit_nat (1)),
                                col_item, lit_str (p->sem.str)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       lit_int */
        case 103:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (LOOP,
                                        col_pos, lit_nat (1)),
                                col_item, lit_int (p->sem.num)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       lit_dec */
        case 104:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (LOOP,
                                        col_pos, lit_nat (1)),
                                col_item, lit_dec (p->sem.dec)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       lit_dbl */
        case 105:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (LOOP,
                                        col_pos, lit_nat (1)),
                                col_item, lit_dbl (p->sem.dbl)),
                     .frag = PFla_empty_set () };
        } break;


        /* LiteralValue:       true_ */
        case 106:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (LOOP,
                                        col_pos, lit_nat (1)),
                                col_item, lit_bln (true)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       false_ */
        case 107:
        {
            /*
             *  -------------------------------------------------------------
             *                   /        / pos | item \     \
             *  env, loop: c => | loop X | -----+------ | , 0 |
             *                   \        \   1 |   c  /     /
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (
                                attach (LOOP,
                                        col_pos, lit_nat (1)),
                                col_item, lit_bln (false)),
                     .frag = PFla_empty_set () };
        } break;

        /* LiteralValue:       empty */
        case 108:
        {
            /*
             *  -------------------------------------------------------------
             *                       iter | pos | item
             *  env, loop: empty => ------+-----+------ , 0
             *
             */
            PFalg_schema_t schema;
            schema.count = 3;
            schema.items = PFmalloc (3 * sizeof (PFalg_schema_t));

            /* We know that iter and pos would have type nat.
               For item on the other side we have no type. */
            schema.items[0].name = col_iter;
            schema.items[0].type = aat_nat;
            schema.items[1].name = col_pos;
            schema.items[1].type = aat_nat;
            schema.items[2].name = col_item;
            schema.items[2].type = 0;

            A(p) = (struct  PFla_pair_t) {
                     .rel = PFla_empty_tbl_ (schema),
                     .frag = PFla_empty_set () };
        } break;

        /* CoreExpr:           flwr (OptBindExpr, WhereExpr) */
        case 4:
        /* CoreExpr:           flwr (OptBindExpr, OrdWhereExpr) */
        case 5:
        /* Note: Rule 4 and Rule 5 differ with respect to the ordering.
                 Adjust the code if the rule number changes!!! */
        {   /* TOPDOWN */
            /**
             * The flwr expression maps back the result of
             * one or more nested for-loops at once. It therefore
             * distincts between the ordering mode ordered and
             * unordered.
             *
             * unordered:
             *
             *        pi_(iter, pos:pos1, item)
             *        |
             *       row_(pos1:<iter, pos>/outer)
             *        |
             *       |X|_(iter, inner)
             *      /  \
             *    /      \
             * result    map
             *
             * ordered:
             *
             *        pi_(iter, pos:pos1, item)
             *        |
             *       row_(pos1:<sort_0, sort_1, ..., sort_n, pos>/outer)
             *        |
             *       |X|_(iter, inner)
             *      /  \
             *    /      \
             * result    map
             *
             * In the ordered case each for-loop adds one sort criterion
             * to the map relation (sort_0, sort_1, ..., sort_n)
             *      or if an order by is present it removes all sort
             * criteria introduced by the for-loop and adds for each
             * order specification a sort column (sort_0, sort_1,
             * ..., sort_n)
             */

            /* store current state information */
            PFla_op_t   *old_loop      = LOOP;
            PFarray_t    *old_env      = ENV;

            /* start with empty map relation */
            *((map_rel_info_t *) PFarray_add (ctx->mapping))
                = (map_rel_info_t) { .map = NULL, .count = 0, .dir = 0 };

            /* initiate translation of bindings */
            reduce (ctx, kids[0], nts[0]);

            /* as side effect from the bindings a possibly
               new loop relation is input to the return expression */

            /* initiate translation of return expression */
            reduce (ctx, kids[1], nts[1]);

            /* the map relation has been changed by a for loop
               (and an order by) and therefore backmapping is
               required */
            if (MAP) {
                /* Note that ordering mode has no effect on a FLWOR
                   expression if an order by clause is present,
                   since order by takes precedence over ordering mode. */
                if (!ORDERING && rule == 4 /* without ordering */)
                    /* in unordered context the new numbering only
                       needs to respect the sequence order
                       (in- and outside the flwor block). */
                    A(p) = (struct PFla_pair_t) {
                            .rel = project (rank (eqjoin (A(R(p)).rel,
                                                          MAP,
                                                          col_iter,
                                                          col_inner),
                                                  col_pos1,
                                                  sortby (col_iter, col_pos)),
                                            proj (col_iter, col_outer),
                                            proj (col_pos, col_pos1),
                                            proj (col_item, col_item)),
                            .frag = A(R(p)).frag };
                else {
                    /**
                     * If an order by clause is present we need
                     * the iter column as a row ranking criterion
                     * (sort_0, sort_1, ..., sort_n, iter, pos).
                     *
                     * Without an order by the combination of sort
                     * columns and partitioning column outer already
                     * contain the information of column iter. Thus
                     * the row numbering needs to sort on:
                     * (sort_0, sort_1, ..., sort_n, pos).
                     */
                    /* create sortby column list: */
                    PFord_ordering_t sortby = PFordering ();
                    if (rule == 5 /* with ordering */)
                    {
                        PFalg_col_t cur;

                        /* don't include columns inner and outer */
                        /* starting from column sort add consecutive
                           columns ... */
                        for (unsigned int i = 0; i < MAP_COUNT - 2; i++) {
                            cur = col_sort << i;
                            sortby = PFord_refine (sortby,
                                                   cur,
                                                   cur & MAP_DIR
                                                   ? DIR_DESC : DIR_ASC);
                        }

                        /* ... and complete sortby list with columns
                           iter and  pos */
                        sortby = PFord_refine (sortby, col_iter, DIR_ASC);
                        sortby = PFord_refine (sortby, col_pos, DIR_ASC);
                    } else {
                        /* don't include columns inner and outer */
                        /* starting from column sort add consecutive
                           columns ... */
                        for (unsigned int i = 0; i < MAP_COUNT - 2; i++)
                            sortby = PFord_refine (sortby,
                                                   col_sort << i,
                                                   DIR_ASC);

                        /* ... and complete sortby list with column pos */
                        sortby = PFord_refine (sortby, col_pos, DIR_ASC);
                    }

                    A(p) = (struct PFla_pair_t) {
                            .rel = project (rank (eqjoin (A(R(p)).rel,
                                                          MAP,
                                                          col_iter,
                                                          col_inner),
                                                  col_pos1,
                                                  sortby),
                                            proj (col_iter, col_outer),
                                            proj (col_pos, col_pos1),
                                            proj (col_item, col_item)),
                            .frag = A(R(p)).frag };
                }
            } else
                A(p) = A(R(p));

            /* restore loop relation */
            LOOP = old_loop;
            /* restore map relation and its column counter */
            PFarray_del (ctx->mapping);
            /* restore old environment */
            ENV = old_env;

        }   break;

        /* OptBindExpr:        for_ (forbind (forvars (var, OptVar),
                                              CoreExpr),
                                     OptBindExpr) */
        case 6:
        {   /* TOPDOWN */

            /*
             * for $v in e1 return e2                    OR
             * for $v at $p in e1 return e2
             *
             * Given the current environment (which may or may not contain
             * bindings), the current loop relation and delta with e1
             * already compiled:
             * - declare variable $v by loop lifting the result of q1,
             *(- declare variable $p if present)
             * - create a new loop relation and
             * - a new var_map relation,
             * - as the for expression opens up a scope, update all existing
             *   bindings to the new scope and add the binding of $v
             * Given the updated environment and the new loop relation
             * compile e2. Return the (possibly intermediate) result.
             *
             * env,loop: e1 => q1,delta1
             *
             *        pos
             * q(v) = --- X proj_iter:inner,item(row_inner:<iter,pos> q1)
             *         1
             *
             * loop(v) = proj_iter(q(v))
             *
             * var_map = proj_outer:iter,inner(row_inner:<iter,pos> q1)
             *
             * updated_env,(v->q(v)) e updated_env,loop(v): e2 => (q2,delta2)
             * -----------------------------------------------------------------
             * env,loop: for &v in e1 return e2 =>
             * (proj_iter:outer, pos:pos1,item
             *   (row_pos1:<iter,pos>/outer (q2 |X| (iter = inner) var_map)),
             *  delta2)
             */
            PFla_op_t   *var;
            PFla_op_t   *opt_var;
            PFla_op_t   *var_map;
            PFla_op_t   *rowid;
            unsigned int  i;
            PFla_env_t   e;
            PFla_op_t   *new_map;
            /* save old environment */
            PFarray_t  *old_env = ENV;

            /* initiate translation of e1 */
            reduce (ctx, kids[1], nts[1]);

            /*
             * Add 'real' positions and the new iter values.
             * (Note: We add the positions outside as some proxy rewrites
             *        expect that no rownum can escape its 'scope'. The
             *        result of the rownum operator is discarded in the
             *        first icols optimization if no positional variable
             *        exists.)
             */
            rowid = rowid (rownum (A(LR(p)).rel,
                                   col_pos1,
                                   sortby (col_pos),
                                   col_iter),
                           col_inner);

            /* translate $v */
            var = attach (project (rowid,
                                   proj (col_iter, col_inner),
                                   proj (col_item, col_item)),
                          col_pos, lit_nat (1));

            /* create new environment */
            ENV = PFarray (sizeof (PFla_env_t), 50);

            /* insert $v and "its document" into NEW environment */
            *((PFla_env_t *) PFarray_add (ENV))
                = enventry (LLL(p)->sem.var, var, NULL, A(LR(p)).frag);

            /* create new loop operator */
            LOOP = project (var, proj (col_iter, col_iter));

            /* create var_map relation. */
            var_map = project (rowid,
                               proj (col_outer, col_iter),
                               proj (col_sort, col_pos),
                               proj (col_inner, col_inner));

            /*
             * Handle optional variable ($p).
             * (Note: The rownum () routine was used to create
             *        the 'item' column of $p's operator. Since this
             *        column must be of type integer instead of nat, we
             *        cast it accordingly.)
             */
            if (LLR(p)->kind == c_var) {
                assert (LLR(p)->sem.var);
                opt_var = attach (project (cast (rowid,
                                                 col_cast,
                                                 col_pos1,
                                                 aat_int),
                                           proj (col_iter, col_inner),
                                           proj (col_item, col_cast)),
                                  col_pos, lit_nat (1));

                /* insert $p into NEW environment */
                *((PFla_env_t *) PFarray_add (ENV)) =
                    enventry (LLR(p)->sem.var,
                              opt_var,
                              NULL,
                              PFla_empty_set ());
            }

            /* update all variable bindings in old environment and put
             * them into new environment */
            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (var_map,
                                       proj (col_outer, col_outer),
                                       proj (col_inner, col_inner));
                else
                    new_map = project (
                                  eqjoin (
                                      project (
                                          e.map,
                                          proj (col_iter, col_inner),
                                          proj (col_outer, col_outer)),
                                      project (
                                          var_map,
                                          proj (col_iter2, col_outer),
                                          proj (col_inner, col_inner)),
                                      col_iter,
                                      col_iter2),
                                  proj (col_outer, col_outer),
                                  proj (col_inner, col_inner));

                *((PFla_env_t *) PFarray_add (ENV)) =
                    enventry (e.var, e.rel, new_map, e.frag);
            }

            if (!MAP) {
                /* create a first backmapping relation */
                MAP = var_map;
                MAP_COUNT = 3;
            } else {
                /* extend the backmapping relation map with
                 * (a) position information of the for-loop input sequence and
                 * (b) the current iteration values */

                MAP_COUNT++;
                PFalg_proj_t *cols = PFmalloc (MAP_COUNT *
                                               sizeof (PFalg_proj_t));
                /* column outer remains the same */
                cols[0].new = col_outer;
                cols[0].old = col_outer;
                /* column iter1 becomes the new inner column */
                cols[1].new = col_inner;
                cols[1].old = col_iter1;
                /* copy all old sort columns */
                for (unsigned i = 2; i < MAP_COUNT - 1; i++)
                    cols[i].new =
                    cols[i].old = col_sort << (i - 2);
                /* we now have on additional sort column generated
                   from column pos */
                /* the first sort criterion is column sort itself */
                cols[MAP_COUNT -1].new = col_sort << (MAP_COUNT - 3);
                cols[MAP_COUNT -1].old = col_pos;

                MAP = PFla_project_ (
                          eqjoin (MAP,
                                  project (rowid,
                                           proj (col_iter1, col_inner),
                                           proj (col_iter, col_iter),
                                           proj (col_pos, col_pos)),
                                  col_inner,
                                  col_iter),
                          MAP_COUNT, cols);
            }

            /* translate e2 under the specified conditions (updated
             * environment, loop(v))
             */
            reduce (ctx, kids[2], nts[2]);

            /* compute result using old env and old loop. */
            /* backmapping is now done in flwr
            A(p) = (struct PFla_pair_t) {
                     .rel = project (rownum (eqjoin(A(R(p)).rel,
                                                    var_map,
                                                    col_iter,
                                                    col_inner),
                                             col_pos1,
                                             sortby (col_sort, col_pos),
                                             col_outer),
                                     proj (col_iter, col_outer),
                                     proj (col_pos, col_pos1),
                                     proj (col_item, col_item)),
                     .frag = A(R(p)).frag };
            */
        } break;

        /* OptVar:             var */
        case 200:
            /* (will never be called anyway, Rule 6 is top-down) */
            break;

        /* OptVar:             nil */
        case 201:
            /* (will never be called anyway, Rule 6 is top-down) */
            break;

        /* OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr) */
        case 7:
        {   /* TOPDOWN */

            /*
             * let $v := e1 return e2
             *
             * Translate e1 in the current environment, translate the
             * variable $v and add the resulting binding to the environment.
             * Compile e2 in the enriched environment.
             *
             * env,loop: e1 => (q1,delta1)
             *
             * env + (v -> q(v)),loop: e2 => (q2,delta2)
             * -----------------------------------------------------------------
             * env,loop: let $v := e1 return e2 => (q2,delta2)
             *
             * NB: Translation of variable is:
             *
             *         /pos                                                   \
             * q(v) = | --- X proj_iter:inner,item(row_inner:<iter,pos>(q(e1)))|
             *         \ 1                                                    /
             *
             */

            /* initiate translation of e1 */
            reduce (ctx, kids[0], nts[0]);

            /* assign result of e1 to $v, i.e. add resulting binding to
             * environment together with the currently live nodes
             */
            *((PFla_env_t *) PFarray_add (ENV))
                = enventry (LL(p)->sem.var, A(LR(p)).rel, NULL, A(LR(p)).frag);

            /* now translate remaining bindings in the new context */
            reduce (ctx, kids[1], nts[1]);

            /* let is embedded in a flwr expression - a
               return expression therefore is not needed
            A(p) = A(R(p));
            */
        } break;

        /* OptBindExpr:        nil */
        case 8:
            /* we don't need a translation -- it would be ignored anyway */
            break;

        /* OrdWhereExpr:       where (CoreExpr, OrdWhereExpr) */
        case 9:
        /* WhereExpr:          where (CoreExpr, WhereExpr) */
        case 11:
        {   /* TOPDOWN */

            /*
             * where e1 'return' e2
             *
             * NB: SEL: select those rows where column value = true
             *
             *
             * {..., $v -> q(v), ...},loop: e1 => q1,delta1
             *
             * map  = rowid_inner (proj_outer:iter (SEL item q1))
             * loop = proj_iter:inner (map)
             *
             * { ...,
             *   $v -> proj_iter:inner,pos,item (q(v)|X|(iter=outer)(map)),
             *   ...}, hen_loop: e2 => (q2,delta2)
             * -----------------------------------------------------------------
             * {..., $v -> q(v), ...},loop,delta: where e1 'return' e2 =>
             *                         proj_iter:outer,pos,item (
             *                             q2 |X|(iter=inner) (map)),
             *                         delta2)
             */
            PFarray_t *old_env;
            unsigned int i;
            PFla_env_t e;
            PFla_op_t *new_map,
                      *rowid,
                      *var_map;

            /* initiate translation of e1 */
            reduce (ctx, kids[0], nts[0]);

            /* prepare the loop relation for the then-branch */
            rowid    = rowid (select_ (A(L(p)).rel, col_item),
                              col_inner);
            /* create new loop operator */
            LOOP     = project (rowid, proj (col_iter, col_inner));
            /* create var_map relation. */
            var_map  = project (rowid,
                                proj (col_outer, col_iter),
                                proj (col_inner, col_inner));

            /* save old environment */
            old_env = ENV;

            /* update the environment for translation of e2 */
            ENV = PFarray (sizeof (PFla_env_t), 50);

            /* update all variable bindings in old environment and put
             * them into new environment */
            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (var_map,
                                       proj (col_outer, col_outer),
                                       proj (col_inner, col_inner));
                else
                    new_map = project (
                                  eqjoin (
                                      project (
                                          e.map,
                                          proj (col_iter, col_inner),
                                          proj (col_outer, col_outer)),
                                      project (
                                          var_map,
                                          proj (col_iter2, col_outer),
                                          proj (col_inner, col_inner)),
                                      col_iter,
                                      col_iter2),
                                  proj (col_outer, col_outer),
                                  proj (col_inner, col_inner));

                *((PFla_env_t *) PFarray_add (ENV)) =
                    enventry (e.var, e.rel, new_map, e.frag);
            }

            if (!MAP) {
                /* create a first backmapping relation */
                MAP = var_map;
                MAP_COUNT = 2;
            } else {
                /* extend the backmapping relation map with
                 * (a) position information of the for-loop input sequence and
                 * (b) the current iteration values */

                PFalg_proj_t *cols = PFmalloc (MAP_COUNT *
                                               sizeof (PFalg_proj_t));

                /* column outer remains the same */
                cols[0].new = col_outer;
                cols[0].old = col_outer;
                /* column iter1 becomes the new inner column */
                cols[1].new = col_inner;
                cols[1].old = col_iter1;

                for (unsigned i = 2; i < MAP_COUNT; i++)
                    cols[i].new =
                    cols[i].old = col_sort << (i - 2);

                MAP = PFla_project_ (
                          eqjoin (MAP,
                                  project (rowid,
                                           proj (col_iter1, col_inner),
                                           proj (col_iter, col_iter)),
                                  col_inner,
                                  col_iter),
                          MAP_COUNT, cols);
            }

            /* translate return expression */
            reduce (ctx, kids[1], nts[1]);

            A(p) = A(R(p));
        } break;

        /* OrdWhereExpr:       orderby (OrderSpecs, CoreExpr) */
        case 10:
        {   /* TOPDOWN */

            /* Having no map relation indicates that we have no
               for loop. We have at most one item and thus can
               skip sorting. */
            if (MAP) {
                /* throw away all sort criteria -- each orderspec
                   adds a new one instead */
                MAP = project (MAP,
                               proj (col_outer, col_outer),
                               proj (col_inner, col_inner));
                MAP_COUNT = 2;

                /* translate OrderSpecs */
                reduce (ctx, kids[0], nts[0]);
            }

            /* translate return expression */
            reduce (ctx, kids[1], nts[1]);

            A(p) = A(R(p));
        } break;

        /* WhereExpr:          CoreExpr */
        case 12:
            break;

        /* OrderSpecs:         orderspecs (CoreExpr, nil) */
        case 300:
        /* OrderSpecs:         orderspecs (CoreExpr, OrderSpecs) */
        case 301: /* NOTE: some code specific to rule 301 stands
                     at the end of this block */
        {   /* TOPDOWN */
            PFla_op_t          *sort_attr,
                               *empty_case;
            PFalg_proj_t       *cols;
            PFty_t              t;
            PFalg_simple_type_t algty;
            PFalg_col_t         sort_col;
            unsigned int        empty = 0;

            /* translate order expression */
            reduce (ctx, kids[0], nts[0]);

            sort_attr = project (A(L(p)).rel,
                                 proj (col_iter, col_iter),
                                 proj (col_item, col_item));

            /*
             * If we we know (from static typing) that all
             * iterations allways have a sequence length of 1
             * we do not need to add min/max values.
             */
            if (!PFty_subtype (L(p)->type, PFty_xs_anyItem ())) {
                t = PFty_prime (PFty_defn (L(p)->type));
                empty_case = difference (
                                 LOOP,
                                 project (A(L(p)).rel,
                                          proj (col_iter,
                                                col_iter)));
                /*
                 * Unfortunately, we only know how to cast atomic types
                 * into (exactly) one of our builtin atomic types. We
                 * cannot sensibly cast, e.g., into subtypes thereof.
                 */
                if (PFty_equality (t, PFty_xs_string ())) {
                    algty = aat_str;
                    empty_case = attach (empty_case, col_item, lit_str (""));
                }
                else if (PFty_equality (t, PFty_xs_integer ())) {
                    algty = aat_int;
                    empty_case = attach (empty_case, col_item, lit_int (0));
                }
                else if (PFty_subtype (t, PFty_xs_decimal ())) {
                    algty = aat_dec;
                    empty_case = attach (empty_case, col_item, lit_dec (0));
                }
                else if (PFty_equality (t, PFty_xs_double ())) {
                    algty = aat_dbl;
                    empty_case = attach (empty_case, col_item, lit_dbl (0));
                }
                else if (PFty_equality (t, PFty_xs_boolean ())) {
                    algty = aat_bln;
                    empty_case = attach (empty_case, col_item, lit_bln (true));
                }
                else if (PFty_equality (t, PFty_xs_datetime ())) {
                    algty = aat_dtime;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("1-01-01")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_date ())) {
                    algty = aat_date;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("1-01-01")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_time ())) {
                    algty = aat_time;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("0:0:0")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_gyearmonth ())) {
                    algty = aat_gymonth;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("1-01")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_gyear ())) {
                    algty = aat_gyear;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("1")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_gmonthday ())) {
                    algty = aat_gmday;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("01-01")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_gmonth ())) {
                    algty = aat_gmonth;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("01")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_gday ())) {
                    algty = aat_gday;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("01")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_duration ())) {
                    algty = aat_duration;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("PT0S")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_yearmonthduration ())) {
                    algty = aat_ymduration;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("P0M")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_xs_daytimeduration ())) {
                    algty = aat_dtduration;
                    empty_case = project (cast (attach (
                                                    empty_case,
                                                    col_item,
                                                    lit_str("PT0S")),
                                                col_cast, col_item, algty),
                                          proj (col_iter, col_iter),
                                          proj (col_item, col_cast));
                }
                else if (PFty_equality (t, PFty_untypedAtomic ())) {
                    algty = aat_uA;
                    empty_case = attach (empty_case, col_item, lit_uA (""));
                }
                else
                    PFoops (OOPS_FATAL,
                            "don't know the algebra equivalent of type %s",
                            PFty_str (L(p)->type));

                sort_attr = disjunion (
                                attach (
                                    project (cast (sort_attr,
                                                   col_cast, col_item, algty),
                                             proj (col_iter, col_iter),
                                             proj (col_item, col_cast)),
                                    col_pos,
                                    lit_nat ((p->sem.mode.dir == p_desc) ^
                                             (p->sem.mode.empty == p_least))),
                                attach (
                                    empty_case,
                                    col_pos,
                                    lit_nat ((p->sem.mode.dir == p_desc) ^
                                             (p->sem.mode.empty != p_least))));
                empty = 1;
            }

            /* extend the backmapping relation map with
             * (a) position information of the for-loop input sequence and
             * (b) the current iteration values */
            MAP_COUNT++;
            cols = PFmalloc ((MAP_COUNT + empty) * sizeof (PFalg_proj_t));
            /* columns outer and inner remain the same */
            cols[0].new = col_outer;
            cols[0].old = col_outer;
            cols[1].new = col_inner;
            cols[1].old = col_inner;

            /* copy all old sort columns */
            for (unsigned i = 2; i < MAP_COUNT - 1; i++)
                cols[i].new =
                cols[i].old = col_sort << (i - 2);

            /* we now have on additional sort column generated
               from column item (and possible pos) */
            if (empty) {
                sort_col = col_sort << (MAP_COUNT - 3);
                cols[MAP_COUNT -1].new = sort_col;
                cols[MAP_COUNT -1].old = col_pos;
                MAP_COUNT++;
            }
            /* the first sort criterion is column sort itself */
            sort_col = col_sort << (MAP_COUNT - 3);
            cols[MAP_COUNT -1].new = sort_col;
            cols[MAP_COUNT -1].old = col_item;

            if (p->sem.mode.dir == p_desc)
                /* mark the bit corresponding to the last
                   entry to cope with descending order */
                MAP_DIR |= sort_col;

            MAP = PFla_project_ (eqjoin (MAP, sort_attr, col_inner, col_iter),
                                 MAP_COUNT, cols);

        /* OrderSpecs:         orderspecs (CoreExpr, OrderSpecs) */
        /* case 301: */
            /* complete rule 301 */
            if (rule == 301)
                /* translate remaining OrderSpecs */
                reduce (ctx, kids[1], nts[1]);

        } break;

        /* CoreExpr:           if_ (CoreExpr, then_else (CoreExpr, CoreExpr)) */
        case 13:
        {   /* TOPDOWN */

            /*
             * if e1 then e2 else e3
             *
             * NB: SEL: select those rows where column value != 0
             *
             *
             * {..., $v -> q(v), ...},loop: e1 => q1,delta1
             *
             * then_map  = rowid_inner (proj_outer:iter (SEL item q1))
             * then_loop = proj_iter:inner (then_map)
             *
             * { ...,
             *   $v -> proj_iter:inner,pos,item (q(v)|X|(iter=outer)(then_map)),
             *   ...}, then_loop: e2 => (q2,delta2)
             *
             * else_map  = rowid_inner (proj_outer:iter (SEL res (NOT res item q1))
             * else_loop = proj_iter:inner (else_map)
             *
             * { ...,
             *   $v -> proj_iter:inner,pos,item (q(v)|X|(iter=outer)(else_map)),
             *   ...}, else_loop: e3 => (q3,delta3)
             * -----------------------------------------------------------------
             * {..., $v -> q(v), ...},loop,delta: if e1 then e2 else e3 =>
             *                        ((proj_iter:outer,pos,item (
             *                              q2 |X|(iter=inner) (then_map)))
             *                         U
             *                         (proj_iter:outer,pos,item (
             *                              q3 |X|(iter=inner) (else_map))),
             *                         delta2 U delta3)
             */
            PFla_op_t *old_loop;
            PFarray_t  *old_env;
            unsigned int i;
            PFla_env_t e;
            PFla_op_t *new_map,
                      *rowid,
                      *var_map,
                      *then_map,
                      *else_map,
                      *then_res,
                      *else_res;

            /* initiate translation of e1 */
            reduce (ctx, kids[0], nts[0]);

            /* save old loop operator */
            old_loop = LOOP;

            /* prepare the loop relation for the then-branch */
            rowid    = rowid (select_ (A(L(p)).rel, col_item),
                              col_inner);
            /* create new loop operator */
            LOOP     = project (rowid, proj (col_iter, col_inner));
            /* create var_map relation. */
            var_map  = project (rowid,
                                proj (col_outer, col_iter),
                                proj (col_inner, col_inner));
            /* store the variable map to retrieve the old iter values */
            then_map = var_map;

            /* save old environment */
            old_env = ENV;

            /* update the environment for translation of e2 */
            ENV = PFarray (sizeof (PFla_env_t), 50);

            /* update all variable bindings in old environment and put
             * them into new environment */
            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (var_map,
                                       proj (col_outer, col_outer),
                                       proj (col_inner, col_inner));
                else
                    new_map = project (
                                  eqjoin (
                                      project (
                                          e.map,
                                          proj (col_iter, col_inner),
                                          proj (col_outer, col_outer)),
                                      project (
                                          var_map,
                                          proj (col_iter2, col_outer),
                                          proj (col_inner, col_inner)),
                                      col_iter,
                                      col_iter2),
                                  proj (col_outer, col_outer),
                                  proj (col_inner, col_inner));

                *((PFla_env_t *) PFarray_add (ENV)) =
                    enventry (e.var, e.rel, new_map, e.frag);
            }

            /* translate e2 (then-branch) */
            reduce (ctx, kids[1], nts[1]);

            /* prepare the loop relation for the else-branch */
            rowid    = rowid (select_ (not (A(L(p)).rel, col_res, col_item),
                                       col_res),
                              col_inner);
            /* create new loop operator */
            LOOP     = project (rowid, proj (col_iter, col_inner));
            /* create var_map relation. */
            var_map  = project (rowid,
                                proj (col_outer, col_iter),
                                proj (col_inner, col_inner));
            /* store the variable map to retrieve the old iter values */
            else_map = var_map;

            /* update the environment for translation of e3 */
            ENV = PFarray (sizeof (PFla_env_t), 50);

            /* update all variable bindings in old environment and put
             * them into new environment */
            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (var_map,
                                       proj (col_outer, col_outer),
                                       proj (col_inner, col_inner));
                else
                    new_map = project (
                                  eqjoin (
                                      project (
                                          e.map,
                                          proj (col_iter, col_inner),
                                          proj (col_outer, col_outer)),
                                      project (
                                          var_map,
                                          proj (col_iter2, col_outer),
                                          proj (col_inner, col_inner)),
                                      col_iter,
                                      col_iter2),
                                  proj (col_outer, col_outer),
                                  proj (col_inner, col_inner));

                *((PFla_env_t *) PFarray_add (ENV)) =
                    enventry (e.var, e.rel, new_map, e.frag);
            }

            /* translate e3 (else-branch) */
            reduce (ctx, kids[2], nts[2]);

            /* reset loop relation and environment */
            LOOP = old_loop;
            ENV = old_env;

            /* merge back the old iter values */
            then_res = project (
                           eqjoin (A(RL(p)).rel, then_map, col_iter, col_inner),
                           proj (col_iter, col_outer),
                           proj (col_pos, col_pos),
                           proj (col_item, col_item));

            /* merge back the old iter values */
            else_res = project (
                           eqjoin (A(RR(p)).rel, else_map, col_iter, col_inner),
                           proj (col_iter, col_outer),
                           proj (col_pos, col_pos),
                           proj (col_item, col_item));

            A(p) = (struct  PFla_pair_t) {
                     .rel  = disjunion (then_res, else_res),
                     .frag = PFla_set_union (A(RL(p)).frag, A(RR(p)).frag) };

        } break;

        /* CoreExpr:           seq (CoreExpr, SeqCoreExpr) */
        case 14:
        {   /* TOPDOWN */

            /*
             *     env,loop: e1 => q1,delta1      env,loop: e2 => q2,delta2
             * -----------------------------------------------------------------
             *                        env,loop: (e1, e2) =>
             *
             *                      proj_iter,pos:pos1,item
             *  /                          / ord       \     / ord       \ \
             * |  row_pos1:<ord,pos>/iter | ----- X q1  | U | ----- X q2  | |
             *  \                          \  1        /     \  2        / /
             *
             */
            unsigned int old_seq_count;

            /* initiate translation of e1 */
            reduce (ctx, kids[0], nts[0]);

            /* save seq_count and start a new sequence counter */
            old_seq_count = SEQ_COUNT;
            SEQ_COUNT = 2;

            /* initiate translation of e2 */
            reduce (ctx, kids[1], nts[1]);

            /* re-set seq_count */
            SEQ_COUNT = old_seq_count;

            A(p) = (struct  PFla_pair_t) {
                     .rel = project (
                                rank (
                                    disjunion (
                                        attach (
                                            A(L(p)).rel,
                                            col_ord, lit_nat (1)),
                                        A(R(p)).rel),
                                    col_pos1,
                                    sortby (col_ord, col_pos)),
                                proj (col_iter, col_iter),
                                proj (col_pos, col_pos1),
                                proj (col_item, col_item)),
                     .frag = PFla_set_union (A(L(p)).frag, A(R(p)).frag) };
        } break;

        /* CoreExpr:           seq (CoreExpr, CoreExpr) */
        case 15:
        {
            /*
             *     env,loop: e1 => q1,delta1      env,loop: e2 => q2,delta2
             * -----------------------------------------------------------------
             *                        env,loop: (e1, e2) =>
             *
             *                      proj_iter,pos:pos1,item
             *  /                          / ord       \     / ord       \ \
             * |  row_pos1:<ord,pos>/iter | ----- X q1  | U | ----- X q2  | |
             *  \                          \  1        /     \  2        / /
             *
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = project (
                                rank (
                                    disjunion (
                                        attach (
                                            A(L(p)).rel,
                                            col_ord, lit_nat (1)),
                                        attach (
                                            A(R(p)).rel,
                                            col_ord, lit_nat (2))),
                                    col_pos1,
                                    sortby (col_ord, col_pos)),
                                proj (col_iter, col_iter),
                                proj (col_pos, col_pos1),
                                proj (col_item, col_item)),
                     .frag = PFla_set_union (A(L(p)).frag, A(R(p)).frag) };
        } break;

        /* SeqCoreExpr:        seq (CoreExpr, SeqCoreExpr) */
        case 16:
        {   /* TOPDOWN */

            unsigned int cur_seq_count = SEQ_COUNT++;

            /* initiate translation of e1 and e2 */
            reduce (ctx, kids[0], nts[0]);
            reduce (ctx, kids[1], nts[1]);

            A(p) = (struct  PFla_pair_t) {
                     .rel = disjunion (
                                attach (
                                    A(L(p)).rel,
                                    col_ord, lit_nat (cur_seq_count)),
                                A(R(p)).rel),
                     .frag = PFla_set_union (A(L(p)).frag, A(R(p)).frag) };
        } break;

        /* SeqCoreExpr:        seq (CoreExpr, CoreExpr) */
        case 17:
            /* TOPDOWN */

            /* initiate translation of e1 and e2 */
            reduce (ctx, kids[0], nts[0]);
            reduce (ctx, kids[1], nts[1]);

            A(p) = (struct  PFla_pair_t) {
                     .rel = disjunion (
                                attach (
                                    A(L(p)).rel,
                                    col_ord, lit_nat (SEQ_COUNT)),
                                attach (
                                    A(R(p)).rel,
                                    col_ord, lit_nat (SEQ_COUNT+1))),
                     .frag = PFla_set_union (A(L(p)).frag, A(R(p)).frag) };
            break;

        /* CoreExpr:           ordered (CoreExpr) */
        case 18:
        {   /* TOPDOWN */

            /* use `ordered' information */
            bool old_ordering = ORDERING;
            ORDERING = true;

            reduce (ctx, kids[0], nts[0]);

            A(p) = A(L(p));

            /* reset ordering mode */
            ORDERING = old_ordering;
        } break;

        /* CoreExpr:           unordered (CoreExpr) */
        case 19:
        {   /* TOPDOWN */

            /* use `ordered' information */
            bool old_ordering = ORDERING;
            ORDERING = false;

            reduce (ctx, kids[0], nts[0]);

            A(p) = A(L(p));

            /* reset ordering mode */
            ORDERING = old_ordering;
        } break;

        /* CoreExpr:           typesw (CoreExpr,
                                       cases (case_ (seqtype,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 20:
        {   /* TOPDOWN */

            /*
             * CoreExpr1 is the expression to be switched. CoreExpr2
             * compiles one (the current) case branch. CoreExpr3 is
             * either another typeswitch representing the next case
             * branch or the default branch of the overall typeswitch.
             *
             * A lot of work for this translation is captured in the
             * function type_test(). Given an algebra expression and
             * an XQuery sequence type, it will return a relation
             * with columns `iter' and `subty', with `subty' set to
             * true or false, depending on whether for this iteration
             * the sequence type test succeeds or not.
             *
             * env,loop: e1 => q1,delta1
             * tested_q1 = type_test (ty, q1, loop)
             *
             * -- translate stuff in the `case' branch
             *  loop2 = proj_iter (select_subty (tested_q1))
             *  {..., $v -> proj_iter,pos,item (
             *    qv |X| (iter = iter1) (proj_iter1:iter loop2))},
             *   loop2: e2 => q2,delta2
             *
             * -- and in the `default' branch
             *  loop3 = proj_iter (select_notsub (not_notsub:subty (tested_q1)))
             *  {..., $v -> proj_iter,pos,item (
             *    qv |X| (iter = iter1) (proj_iter1:iter loop3))},
             *   loop3: e3 => q3,delta3
             *
             * ---------------------------------------------------------------
             *  env,loop:
             *  typeswitch (e1) case ty return e2 default return e3 =>
             *    (q2 U q3, delta2 U delta3)
             *
             * NB: the TYPE operator creates a new column of type boolean;
             * it examines whether the specified column is of given type "ty";
             * if this is the case, it sets the new column to true, otherwise
             * to false.
             */

            PFla_op_t   *tested_q1;  /* true/false if iterat. satisfies test */
            PFarray_t   *old_env;    /* backup of surrounding environment */
            PFla_op_t   *old_loop;   /* backup of surrounding loop relation */
            PFla_env_t   e;          /* helper variable */
            PFla_op_t   *new_map;    /* helper variable */
            unsigned int  i;

            /* translate CoreExpr1 */
            reduce (ctx, kids[0], nts[0]);

            tested_q1 = type_test (RLL(p)->sem.type, A(L(p)), LOOP);

            /* translate stuff in the `case' branch */

            /* map `loop' relation */
            old_loop = LOOP;
            LOOP = project (select_ (tested_q1, col_subty),
                            proj (col_iter, col_iter));

            /* map variable environment */
            old_env = ENV;
            ENV = PFarray (sizeof (PFla_env_t), 50);

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (
                                  LOOP,
                                  proj (col_outer, col_iter),
                                  proj (col_inner, col_iter));
                else
                    new_map = project (
                                  eqjoin (
                                      e.map,
                                      LOOP,
                                      col_inner,
                                      col_iter),
                                  proj (col_outer, col_outer),
                                  proj (col_inner, col_inner));

                *((PFla_env_t *) PFarray_add (ENV))
                    = enventry (e.var, e.rel, new_map, e.frag);
            }

            /* translate CoreExpr2 */
            reduce (ctx, kids[1], nts[1]);

            /* translate stuff in the `default' branch (equivalently) */

            /* map `loop' relation */
            LOOP = project (select_ (not (tested_q1, col_notsub, col_subty),
                                     col_notsub),
                            proj (col_iter, col_iter));

            ENV = PFarray (sizeof (PFla_env_t), 50);

            for (i = 0; i < PFarray_last (old_env); i++) {
                e = *((PFla_env_t *) PFarray_at (old_env, i));

                if (!e.map)
                    new_map = project (
                                  LOOP,
                                  proj (col_outer, col_iter),
                                  proj (col_inner, col_iter));
                else
                    new_map = project (
                                  eqjoin (
                                      e.map,
                                      LOOP,
                                      col_inner,
                                      col_iter),
                                  proj (col_outer, col_outer),
                                  proj (col_inner, col_inner));

                *((PFla_env_t *) PFarray_add (ENV))
                    = enventry (e.var, e.rel, new_map, e.frag);
            }

            /* translate CoreExpr3 */
            reduce (ctx, kids[2], nts[2]);

            /* reset loop relation and environment */
            LOOP = old_loop;
            ENV = old_env;

            A(p) = (struct PFla_pair_t) {
                .rel  = disjunion (A(RLR(p)).rel, A(RRL(p)).rel),
                .frag = PFla_set_union (A(RLR(p)).frag, A(RRL(p)).frag)
            };

        } break;

        /* CoreExpr:           cast (seqtype, CoreExpr) */
        case 21:
        {
            struct  PFla_pair_t pair = A(R(p));
            PFty_t              t;
            PFalg_simple_type_t algty;

            t = PFty_prime (PFty_defn (L(p)->sem.type));

            /*
             * Unfortunately, we only know how to cast atomic types
             * into (exactly) one of our builtin atomic types. We
             * cannot sensibly cast, e.g., into subtypes thereof.
             */
            if (PFty_equality (t, PFty_xs_string ()))
                algty = aat_str;
            else if (PFty_equality (t, PFty_untypedAtomic ()))
                algty = aat_uA;
            else if (PFty_equality (t, PFty_xs_integer ()))
                algty = aat_int;
            else if (PFty_equality (t, PFty_xs_decimal ()))
                algty = aat_dec;
            else if (PFty_equality (t, PFty_xs_double ()))
                algty = aat_dbl;
            else if (PFty_equality (t, PFty_xs_boolean ()))
                algty = aat_bln;
            else if (PFty_equality (t, PFty_xs_datetime ()))
                algty = aat_dtime;
            else if (PFty_equality (t, PFty_xs_date ()))
                algty = aat_date;
            else if (PFty_equality (t, PFty_xs_time ()))
                algty = aat_time;
            else if (PFty_equality (t, PFty_xs_gyearmonth ()))
                algty = aat_gymonth;
            else if (PFty_equality (t, PFty_xs_gyear ()))
                algty = aat_gyear;
            else if (PFty_equality (t, PFty_xs_gmonthday ()))
                algty = aat_gmday;
            else if (PFty_equality (t, PFty_xs_gmonth ()))
                algty = aat_gmonth;
            else if (PFty_equality (t, PFty_xs_gday ()))
                algty = aat_gday;
            else if (PFty_equality (t, PFty_xs_duration ()))
                algty = aat_duration;
            else if (PFty_equality (t, PFty_xs_yearmonthduration ()))
                algty = aat_ymduration;
            else if (PFty_equality (t, PFty_xs_daytimeduration ()))
                algty = aat_dtduration;
            else
                PFoops (OOPS_FATAL,
                        "don't know the algebra equivalent of type %s",
                        PFty_str (L(p)->sem.type));

            /* in case we require a single item and the input
               may be less or more than a single item add a runtime check */
            if (PFty_subtype (L(p)->sem.type, PFty_item ()) &&
                !PFty_subtype (R(p)->type, PFty_item ()))
                pair = PFbui_fn_exactly_one (LOOP,
                                             ORDERING,
                                             &SIDE_EFFECTS,
                                             &pair);
            /* in case we require zero or one items and the input
               may be more than a single item add a runtime check */
            else if (PFty_subtype (L(p)->sem.type, PFty_opt (PFty_item ())) &&
                     !PFty_subtype (R(p)->type, PFty_opt (PFty_item ())))
                pair = PFbui_fn_zero_or_one (LOOP,
                                             ORDERING,
                                             &SIDE_EFFECTS,
                                             &pair);

            A(p) = (struct PFla_pair_t) {
                .rel  = project (cast (pair.rel, col_cast, col_item, algty),
                                 proj (col_iter, col_iter),
                                 proj (col_pos, col_pos),
                                 proj (col_item, col_cast)),
                .frag = pair.frag };

        } break;

        /* CoreExpr:           seqcast (seqtype, CoreExpr) */
        case 22:
        {
            /*
             * `seqcast' nodes are only introduced for static typing.
             * They are not meant to be executed.
             */
            struct  PFla_pair_t pair = A(R(p));
            PFty_t              t;
            PFalg_simple_type_t algty;

            t = PFty_prime (PFty_defn (L(p)->sem.type));

            /*
             * Unfortunately, we only know how to cast atomic types
             * into (exactly) one of our builtin atomic types. We
             * cannot sensibly cast, e.g., into subtypes thereof.
             */
            if (PFty_equality (t, PFty_xs_string ()))
                algty = aat_str;
            else if (PFty_equality (t, PFty_untypedAtomic ()))
                algty = aat_uA;
            else if (PFty_equality (t, PFty_xs_integer ()))
                algty = aat_int;
            else if (PFty_equality (t, PFty_xs_decimal ()))
                algty = aat_dec;
            else if (PFty_equality (t, PFty_xs_double ()))
                algty = aat_dbl;
            else if (PFty_equality (t, PFty_xs_boolean ()))
                algty = aat_bln;
            else if (PFty_equality (t, PFty_xs_datetime ()))
                algty = aat_dtime;
            else if (PFty_equality (t, PFty_xs_date ()))
                algty = aat_date;
            else if (PFty_equality (t, PFty_xs_time ()))
                algty = aat_time;
            else if (PFty_equality (t, PFty_xs_gyearmonth ()))
                algty = aat_gymonth;
            else if (PFty_equality (t, PFty_xs_gyear ()))
                algty = aat_gyear;
            else if (PFty_equality (t, PFty_xs_gmonthday ()))
                algty = aat_gmday;
            else if (PFty_equality (t, PFty_xs_gmonth ()))
                algty = aat_gmonth;
            else if (PFty_equality (t, PFty_xs_gday ()))
                algty = aat_gday;
            else if (PFty_equality (t, PFty_xs_duration ()))
                algty = aat_duration;
            else if (PFty_equality (t, PFty_xs_yearmonthduration ()))
                algty = aat_ymduration;
            else if (PFty_equality (t, PFty_xs_daytimeduration ()))
                algty = aat_dtduration;
            else
                algty = 0;

            if (algty)
                A(p) = (struct PFla_pair_t) {
                    .rel  = type_assert_pos (pair.rel, col_item, algty),
                    .frag = pair.frag };
            else
                A(p) = pair;
        }   break;

        /* CoreExpr:     locsteps (ancestor (seqtype), CoreExpr) */
        case 30:
            A(p) = locstep (ctx, alg_anc, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (ancestor_or_self (seqtype), CoreExpr) */
        case 31:
            A(p) = locstep (ctx, alg_anc_s, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (attribute (seqtype), CoreExpr) */
        case 32:
            A(p) = locstep (ctx, alg_attr, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (child (seqtype), CoreExpr) */
        case 33:
            A(p) = locstep (ctx, alg_chld, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (descendant (seqtype), CoreExpr) */
        case 34:
            A(p) = locstep (ctx, alg_desc, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (descendant_or_self (seqtype), CoreExpr) */
        /* LocationStep:       descendant_or_self (seqtype) */
        case 35:
            A(p) = locstep (ctx, alg_desc_s, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (following (seqtype), CoreExpr) */
        case 36:
            A(p) = locstep (ctx, alg_fol, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (following_sibling (seqtype), CoreExpr) */
        case 37:
            A(p) = locstep (ctx, alg_fol_s, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (parent (seqtype), CoreExpr) */
        case 38:
            A(p) = locstep (ctx, alg_par, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (preceding (seqtype), CoreExpr) */
        case 39:
            A(p) = locstep (ctx, alg_prec, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (preceding_sibling (seqtype), CoreExpr) */
        case 40:
            A(p) = locstep (ctx, alg_prec_s, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:     locsteps (self (seqtype), CoreExpr) */
        case 41:
            A(p) = locstep (ctx, alg_self, LL(p)->sem.type, A(R(p)));
            break;

        /* StandOff axes */
        /* CoreExpr:     locsteps (select_narrow (seqtype), CoreExpr) */
        case 42:
            A(p) = locstep (ctx, alg_so_select_narrow, LL(p)->sem.type, A(R(p)));
            break;
        /* CoreExpr:     locsteps (select_wide (seqtype), CoreExpr) */
        case 43:
            A(p) = locstep (ctx, alg_so_select_wide, LL(p)->sem.type, A(R(p)));
            break;

        /* CoreExpr:           TwigExpr */
        case 45:
        {   /*
             * Introduce a twig operator that generates
             * the correct new pre values and provides a result
             * and a new document fragment.
             *
             * env, loop: e => q
             *
             * n = twig (q)
             * ----------------------------------------------------------------
             * env, loop: twig e =>
             *                                           pos
             * rel:  (proj_iter,item:pre (roots (n))) x -----
             *                                            1
             *                                                          zero
             *    where roots (n) = sel (res)(= res:(level, zero) (n x ------))
             *                                                            0
             *
             * frag: proj_pre,size,level,kind,prop,frag (n)
             */

            PFla_op_t *twig = twig (A(p).rel,
                                    col_iter,
                                    col_item);

            A(p) = (struct  PFla_pair_t) {
                     .rel = attach (roots (twig),
                                    col_pos, lit_nat (1)),
                     .frag = PFla_set (fragment (twig))};
        }   break;

        /* TwigExpr:           twig_seq (TwigExpr, TwigSeq) */
        case 46:
            /* Represent a sequence in a twig constructor by
               the special operator fcns (first-child-next-sibling) */

            A(p) = (struct  PFla_pair_t) {
                     .rel = fcns (A(L(p)).rel, A(R(p)).rel),
                     .frag = PFla_empty_set () };
            break;

        /* TwigSeq:            TwigExpr: */
        case 47:
            /* Represent the end of a twig sequence by nil token:
               fcns (expr, nil). */

            A(p) = (struct  PFla_pair_t) {
                     .rel = fcns (A(p).rel, nil ()),
                     .frag = PFla_empty_set () };
            break;

        /* TwigExpr:           empty */
        case 48:
            /* Represent the empty content of a document or element
               constructor by the nil token. */

            A(p) = (struct  PFla_pair_t) {
                     .rel = nil (),
                     .frag = PFla_empty_set () };
            break;

        /* TwigExpr:           CoreExpr */
        case 49:
            /* Represent the (already generated) node content of a document
               or element constructor (e.g., nodes from a queried document)
               by a content operator. The task of this operator is to collect
               all subtree nodes and prepare them for a subtree copy. */

            A(p) = (struct  PFla_pair_t) {
                     .rel = content (PFla_set_to_la (A(p).frag), A(p).rel,
                                     col_iter, col_pos, col_item),
                     .frag = PFla_empty_set () };
            break;

        /* TwigExpr:           doc (TwigSeq) */
        case 50:
            /*
             * env, loop: e => q, doc (q)
             * ----------------------------------------------------------------
             * env, loop: docnode e =>
             *
             * rel:       docnode (loop, q)
             * frag:      _
             *
             * Inside a twig constructor every node constructor produces
             * neither a schema nor a fragment information. This allows
             * different implementations to use whatever document layout
             * they prefer. Only after the complete twig is constructed
             * the twig operator provides a schema and the new fragment
             * information.
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = docnode (LOOP, A(L(p)).rel, col_iter),
                     .frag = PFla_empty_set () };
            break;

        /* TwigExpr:           elem (TagName, TwigSeq) */
        case 51:
            /*
             * CoreExpr (q2) evaluates to a sequence of nodes (fcns operators).
             * TagName (q1) is the name of a new node which becomes the common
             * root of the constructed tree.
             *
             * env, loop: e1 => q1, doc (q1)
             * env, loop: e2 => q2, _
             * -----------------------------------------------------------------
             * env, loop: element e1 {e2} =>
             *
             * rel:       element (q1, q2)
             * frag:      _
             *
             * Inside a twig constructor every node constructor produces
             * neither a schema nor a fragment information. This allows
             * different implementations to use whatever document layout
             * they prefer. Only after the complete twig is constructed
             * the twig operator provides a schema and the new fragment
             * information.
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = element (A(L(p)).rel, A(R(p)).rel,
                                     col_iter,
                                     col_item),
                     .frag = PFla_empty_set () };
            break;

        /* TwigExpr:           attr (TagName, CoreExpr) */
        case 52:
            /*
             * CoreExpr (q2) evaluates to a sequence of attribute values.
             * TagName (q1) is the name of a new node.
             *
             * env, loop: e1 => q1, doc (q1)
             * env, loop: e2 => q2, doc (q2)
             * ----------------------------------------------------------------
             * env, loop: attribute e1 {e2} =>
             *
             * rel:       attribute (q1
             *                       |X|_iter1,iter
             *                       (proj_iter1:iter,item1:item (q2)))
             * frag:      _
             *
             * Inside a twig constructor every node constructor produces
             * neither a schema nor a fragment information. This allows
             * different implementations to use whatever document layout
             * they prefer. Only after the complete twig is constructed
             * the twig operator provides a schema and the new fragment
             * information.
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = attribute (
                                eqjoin (
                                    A(L(p)).rel,
                                    project (A(R(p)).rel,
                                             proj (col_iter1, col_iter),
                                             proj (col_item1, col_item)),
                                    col_iter, col_iter1),
                                col_iter, col_item, col_item1),
                     .frag = PFla_empty_set () };
            break;

        /* TagName:            tag */
        case 400:
            A(p) = (struct PFla_pair_t) {
                .rel = attach (
                           attach (LOOP,
                                   col_pos, lit_nat (1)),
                           col_item, lit_qname (p->sem.qname)),
                .frag = PFla_empty_set () };
            break;

        /* TagName:            CoreExpr */
        case 401:
            break;

        /* TwigExpr:           text (CoreExpr) */
        case 53:
            /*
             * env, loop: e => q, doc (q)
             * ----------------------------------------------------------------
             * env, loop: textnode e =>
             *
             * rel:       textnode (q)
             * frag:      _
             *
             * Inside a twig constructor every node constructor produces
             * neither a schema nor a fragment information. This allows
             * different implementations to use whatever document layout
             * they prefer. Only after the complete twig is constructed
             * the twig operator provides a schema and the new fragment
             * information.
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = textnode (A(L(p)).rel, col_iter, col_item),
                     .frag = PFla_empty_set () };
            break;

        /* TwigExpr:           comment (CoreExpr) */
        case 54:
            /*
             * env, loop: e => q, doc (q)
             * ----------------------------------------------------------------
             * env, loop: comment e =>
             *
             * rel:       comment (q)
             * frag:      _
             *
             * Inside a twig constructor every node constructor produces
             * neither a schema nor a fragment information. This allows
             * different implementations to use whatever document layout
             * they prefer. Only after the complete twig is constructed
             * the twig operator provides a schema and the new fragment
             * information.
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = comment (A(L(p)).rel, col_iter, col_item),
                     .frag = PFla_empty_set () };
            break;

        /* TwigExpr:           pi (CoreExpr, CoreExpr) */
        case 55:
            /*
             * CoreExpr (q2) evaluates to the string content.
             * CoreExpr (q1) is the target of a new node.
             *
             * env, loop: e1 => q1, doc (q1)
             * env, loop: e2 => q2, doc (q2)
             * ----------------------------------------------------------------
             * env, loop: processi {e1}{e2} =>
             *
             * rel:       processi (q1
             *                      |X|_iter1,iter
             *                      (proj_iter1:iter,item1:item (q2)))
             * frag:      _
             *
             * Inside a twig constructor every node constructor produces
             * neither a schema nor a fragment information. This allows
             * different implementations to use whatever document layout
             * they prefer. Only after the complete twig is constructed
             * the twig operator provides a schema and the new fragment
             * information.
             */
            A(p) = (struct  PFla_pair_t) {
                     .rel = processi (
                                eqjoin (
                                    A(L(p)).rel,
                                    project (A(R(p)).rel,
                                             proj (col_iter1, col_iter),
                                             proj (col_item1, col_item)),
                                    col_iter, col_iter1),
                                col_iter, col_item, col_item1),
                     .frag = PFla_empty_set () };
            break;

        /* CoreExpr:           apply (FunctionArgs) */
        case 60:
        {   /* TOPDOWN*/

            /*
             * Function application (user-defined functions):
             *
             * (1) Save current variable and function parameter environment.
             * (2) Enter bindings for all variables in the function
             *     signature to the variable environment.
             * (3) Invoke compilation for the function body (accessible
             *     via the PFfun_t struct).
             * (4) Restore variable and function parameter environment.
             */

            PFarray_t  *old_env;
            PFarray_t  *old_fun_args;

            /* (1) Save current variable and function parameter environment
               and create new ones. */
            old_env = ENV;

            ENV = PFarray (sizeof (PFla_env_t), 50);

            for (unsigned int i = 0; i < PFarray_last (old_env); i++)
                *((PFla_env_t *) PFarray_add (ENV))
                    = *((PFla_env_t *) PFarray_at (old_env, i));

            old_fun_args = FUN_ARGS;

            /* We will collect the argument values here */
            FUN_ARGS = PFarray (sizeof (struct PFla_pair_t), 10);

            /* (2) Enter bindings for function parameters.
             *     We do this by reducing our child nodes in a
             *     top-down fashion.
             */

            /* Top-down processing puts all argument values into this array */
            reduce (ctx, kids[0], nts[0]);

            /* All function arguments are now in the array `fun_args'. */

            if (p->sem.fun->builtin) {
                /**
                 * Translation of fn:trace ()
                 */
                if (! PFqname_eq (p->sem.fun->qname,
                                  PFqname (PFns_fn, "trace"))) {
                    /* For fn:trace we need to introduce for each map relation
                       an additional trace operator. */
                    PFla_pair_t seq = *(PFla_pair_t *) PFarray_at (FUN_ARGS, 0);
                    PFla_pair_t str = *(PFla_pair_t *) PFarray_at (FUN_ARGS, 1);
                    PFla_op_t  *map_traces = nil ();

                    unsigned int i = 0;
                    for (; i < PFarray_last (ctx->mapping); i++) {
                        PFla_op_t *map =
                            ((map_rel_info_t *) PFarray_at (ctx->mapping,
                                                            i))->map;

                        if (map) {
                            map_traces = trace_map (map,
                                                    map_traces,
                                                    col_inner,
                                                    col_outer);
                        }
                    }

                    SIDE_EFFECTS = trace (SIDE_EFFECTS,
                                          trace_items (seq.rel,
                                                       trace_msg (str.rel,
                                                                  map_traces,
                                                                  col_iter,
                                                                  col_item),
                                                       col_iter,
                                                       col_pos,
                                                       col_item));

                    A(p) = (struct PFla_pair_t) {
                        .rel  = seq.rel,
                        .frag = seq.frag };
                } else {
                    /*
                     * For built-in functions use this array to call the
                     * algebraic representation of the function (builtins.c)
                     */
                    if (!p->sem.fun->alg)
                        PFoops (
                            OOPS_FATAL,
                            "Algebra implementation for function `%s' unknown.",
                            PFqname_str (p->sem.fun->qname));

                    A(p) = p->sem.fun->alg (LOOP,
                                            ORDERING,
                                            &SIDE_EFFECTS,
                                            FUN_ARGS->base);
                }
            }
            else {
                /* check for active (recursive) user-defined functions */
                unsigned int i = 0;
                for (; i < PFarray_last (ctx->fun_active); i++)
                    if (FUN_ACTIVE_AT(i).node == p->sem.fun->core)
                        break;

                /* if this function appears the first time */
                if (i == PFarray_last (ctx->fun_active)) {
                    /* add function to the active ones */
                    *((fun_active_t *) PFarray_add (ctx->fun_active)) =
                        (fun_active_t) { .node  = p->sem.fun->core,
                                         .count = 1 };

                    /* Bind parameter variables to the argument values
                       and ... */
                    for (unsigned int j = 0; j < p->sem.fun->arity; j++) {
                        PFla_pair_t curr_arg
                            = *(PFla_pair_t *) PFarray_at (FUN_ARGS, j);

                        *((PFla_env_t *) PFarray_add (ENV))
                            = enventry (p->sem.fun->params[j],
                                        curr_arg.rel,
                                        NULL,
                                        curr_arg.frag);
                    }

                    /* (3) invoke compilation of the function body. */
                    reduce (ctx, p->sem.fun->core, 1);

                    /* remove function from the active ones */
                    PFarray_del (ctx->fun_active);

                    A(p) = A(p->sem.fun->core);
                }
                /* cope with recursive functions */
                else if (ctx->recursion_depth == 0) {
                    PFoops (OOPS_FATAL,
                            "Algebra implementation cannot cope with recursive"
                            " functions yet.\n             "
                            "(If the recursion depth is known at compile time"
                            " adding the option\n              "
                            "'declare option pf:recursion-depth \"<number>\";'"
                            " to the query text\n              "
                            "will ensure that the recursive function is"
                            " unfolded <number> times.)");
                }
                /* unfold recursive function as long as
                   we haven't hit the unfold boundary */
                else if (FUN_ACTIVE_AT(i).count < ctx->recursion_depth) {
                    unsigned int j, k;
                    PFarray_t *old_core2alg_map = CORE2ALG_MAP;
                    CORE2ALG_MAP = PFarray (sizeof (core2alg_map_t), 50);

                    /* replace the variables that are not visible
                       anymore due to the recursive call */
                    for (j = 0; j < PFarray_last (ENV); j++) {
                        PFla_env_t e = *((PFla_env_t *) PFarray_at (ENV, j));

                        for (k = 0; k < p->sem.fun->arity; k++)
                            if (e.var == p->sem.fun->params[k]) {
                                PFla_pair_t curr_arg
                                    = *(PFla_pair_t *) PFarray_at (FUN_ARGS, k);

                                *(PFla_env_t *) PFarray_at (ENV, j)
                                    = enventry (p->sem.fun->params[k],
                                                curr_arg.rel,
                                                NULL,
                                                curr_arg.frag);
                                break;
                            }
                    }

                    /* add function once more to the active ones */
                    FUN_ACTIVE_AT(i).count += 1;

                    /* (3) Invoke compilation of the function body. */
                    reduce (ctx, p->sem.fun->core, 1);

                    /* remove function once from the active ones */
                    FUN_ACTIVE_AT(i).count -= 1;

                    /* store the resulting algebra expression */
                    PFla_op_t *res_rel  = A(p->sem.fun->core).rel;
                    PFarray_t *res_frag = A(p->sem.fun->core).frag;

                    /* clean up the side effects introduced
                       by the recursive core tree traversal */
                    for (j = 0; j < PFarray_last (CORE2ALG_MAP); j++)
                        A(CORE2ALG_MAP_AT(j).core) =
                            (struct PFla_pair_t) {
                                .rel  = CORE2ALG_MAP_AT(j).rel,
                                .frag = CORE2ALG_MAP_AT(j).frag };

                    CORE2ALG_MAP = old_core2alg_map;

                    A(p) = (struct PFla_pair_t) {
                               .rel  = res_rel,
                               .frag = res_frag };
                }
                /* we hit the unfold boundary for recursive functions
                   and add a runtime error in case this recursion depth
                   is reached */
                else {
                    SIDE_EFFECTS = error (SIDE_EFFECTS,
                                          attach (LOOP,
                                                  col_item,
                                                  lit_str ("recursion to deep")),
                                          col_item);

                    A(p) = (struct PFla_pair_t) {
                        .rel  = PFla_empty_tbl_ (ipi_schema (PFalg_type (p->type))),
                        .frag = PFla_empty_set () };
                }
            }

            /* (4) Restore variable and function parameter environments. */
            ENV = old_env;
            FUN_ARGS = old_fun_args;

        } break;

        /* CoreExpr:           xrpc (CoreExpr, apply (FunctionArgs)) */
        case 61:
        {   /* TOPDOWN*/
            PFla_op_t     *param_list = PFla_nil (),
                          *fun_call;
            PFalg_schema_t schema;
            PFarray_t     *old_env;
            PFarray_t     *old_fun_args;

            /* prepare the standard in/output schema */
            schema.count = 3;
            schema.items = PFmalloc (schema.count *
                                     sizeof (PFalg_schm_item_t));
            schema.items[0].name = col_iter;
            schema.items[0].type = aat_nat;
            schema.items[1].name = col_pos;
            schema.items[1].type = aat_nat;
            schema.items[2].name = col_item;
            /* Note: the item type has to be adjusted for each parameter */
            schema.items[2].type = 0;

            PFty_t ty = p->type;

            /* Collect the destinations */
            reduce (ctx, kids[0], nts[0]);

            /*
             * Function application:
             *
             * (1) Save current variable and function parameter environment.
             * (2) Enter bindings for all variables in the function
             *     signature to the variable environment.
             * (3) Transform the function parameters
             *     into an XRPC function call.
             * (4) Restore variable and function parameter environment.
             */

            /* (1) Save current variable and function parameter environment
               and create new ones. */
            old_env = ENV;

            ENV = PFarray (sizeof (PFla_env_t), 50);

            for (unsigned int i = 0; i < PFarray_last (old_env); i++)
                *((PFla_env_t *) PFarray_add (ENV))
                    = *((PFla_env_t *) PFarray_at (old_env, i));

            old_fun_args = FUN_ARGS;

            /* We will collect the argument values here */
            FUN_ARGS = PFarray (sizeof (struct PFla_pair_t), 10);

            /* (2) Enter bindings for function parameters.
             *     We do this by reducing our child nodes in a
             *     top-down fashion.
             */

            /* Top-down processing puts all argument values into this array */
            reduce (ctx, kids[1], nts[1]);

            /* All function arguments are now in the array `fun_args'. */

            /* (3) Transform the function parameters into an XRPC function
             *     call.
             */

            /* Create a linked list of parameters. */
            for (unsigned int i = R(p)->sem.fun->arity; i > 0; i--) {
                PFla_pair_t curr_arg
                    = *(PFla_pair_t *) PFarray_at (FUN_ARGS, i-1);

                /* adjust the item type */
                schema.items[2].type = PFprop_type_of (curr_arg.rel, col_item);
                /* create a new parameter */
                param_list = fun_param (curr_arg.rel, param_list, schema);

                /* create a new fragment parameter if the parameter
                   represents a sequence with nodes */
                if (schema.items[2].type & aat_node)
                    param_list = fun_frag_param (
                                     PFla_set_to_la (curr_arg.frag),
                                     param_list,
                                     2 /* referencing column item */);
            }

            /* As the top-most argument add the XRPC destination strings */
            schema.items[2].type = PFprop_type_of (A(L(p)).rel, col_item);
            param_list = fun_param (A(L(p)).rel, param_list, schema);

            /* Collect all result types */
            schema.items[2].type = PFalg_type (ty);

            /* Construct the complete function call */
            fun_call = fun_call (LOOP,                 /* loop relation */
                                 param_list,           /* parameter list */
                                 schema,               /* result schema */
                                 alg_fun_call_xrpc,    /* function call kind */
                                 R(p)->sem.fun->qname, /* function name */
                                 R(p),                 /* context info */
                                 col_iter,             /* loop column */
                                 PFalg_type_occ (ty)); /* occurrence
                                                          indicator */

            /* To correctly reference the fragment information of
               resulting items of kind node we introduce an additional
               frag_extract operator that refers to column item */
            if (schema.items[2].type & aat_node)
                A(p) = (struct  PFla_pair_t) {
                         .rel = fun_call,
                         .frag = PFla_set (frag_extract (fun_call, 2)) };
            else
                A(p) = (struct  PFla_pair_t) {
                         .rel = fun_call,
                         .frag = PFla_empty_set () };

            /* (4) Restore variable and function parameter environments. */
            ENV = old_env;
            FUN_ARGS = old_fun_args;
        } break;

        /* FunctionArgs:       nil */
        case 500:
            break;

        /* FunctionArgs:       arg (FunctionArg, FunctionArgs) */
        case 501:
        {   /* TOPDOWN */

            /* translate the argument itself */
            reduce (ctx, kids[0], nts[0]);

            /* Append the new argument to function argument list */
            *((PFla_pair_t *) PFarray_add (FUN_ARGS)) = A(L(p));

            /* go on to next arguments */
            reduce (ctx, kids[1], nts[1]);

        } break;

        /* FunctionArg:        CoreExpr */
        case 502:
            break;

        /* CoreExpr:           recursion (var, seed (CoreExpr, CoreExpr)) */
        case 72:
        {   /* TOPDOWN */
            /*
             * with $x seeded by e1 return e2
             *
             * There are two approaches to translate the above pattern:
             *  * a delta based approach
             *  * an approach that uses the result of the current recursion
             *    step as input for next one
             *  * an approach that uses the overall result as input for the
             *    next recursion step
             *
             * We choose to translate the recursion with the third approach
             * as XQuery allows positional access as well as aggregates inside
             * the recursion body -- a delta approach would thus return the
             * wrong results. Whenever all the operators inside the recursion
             * body do not rely on the result size and positions we can choose
             * the (probably cheaper) delta approach.
             * The delta and the last result approach both need to change
             * the environment as well as the loop relation as less iterations
             * may be required in the next recursive call.
             *
             * The recursion is translated with the help of the following
             * algebra nodes:
             *  * rec_fix:   the head of the recursion referring
             *               to the overall result
             *  * rec_param: one item of a variable length parameter list
             *               (thus coping with UDFs that have an arbitrary
             *                number or arguments)
             *  * nil:       the end of the parameter list
             *  * rec_arg:   the operator that manages the connections
             *               between seed argument, the recursive call, and
             *               both its input to the next recursion (base)
             *  * rec_base:  a dummy operator representing the algebraic
             *               expression representing the input of the recursion
             *               (either seed or recursive call)
             *
             * The recursion (translated based on the more general approach)
             * will be mapped into the following DAG (e1 -> q1; e2 -> q2;
             * child edges: '---'; 'semantical' edges: '- -')
             *
             *          rank_(pos:<item>)
             *            |
             *         distinct
             *            |
             *         rec_fix
             *            |  \_____________________________
             *        rec_param                            \
             *        /       \________________             \
             *    rec_arg                      \            |
             *    /  |  \                  rec_param        |
             *    |      \                  /      \        |
             *   / \  \   \             rec_arg    nil      /
             *  /q1 \      \            /  \  \___   ______/
             * /_____\ |    |     iter|item       \ /
             *              |     ----|----  \     U (2)
             *         |    |         |           / \
             *              |           (base)|  /  diff (1)
             *         |  rank_                  |   | \
             *          (pos:<item>)          |  | __|__\
             *         |    |                    |/  |
             *           (use (1), (2), or    \  |   |
             *         |  (3) as input)     rec_base |
             *   (base)     | ______________________/
             *         |    |/
             *           distinct (3)
             *         |    |
             *           pi_(iter, item)
             *         |    |
             *             / \
             *         |  /q1 \
             *           /_____\
             *          \   |
             *             /
             *         rec_base
             *
             */

/* different strategies to process the recursion */
#define DELTA 1
#define TC 2
#define IFP 3
#define SQL 4
#define TC_OR_DELTA 5
#define IFP_OR_DELTA 6
/* different strategies to include the seed */
#define STAR 7
#define PLUS 8

/* check whether variable strategy is allowed or not */
#define VAR_STRATEGY(i) ((i) >= TC_OR_DELTA)

/* choose strategy */
#define STRATEGY IFP_OR_DELTA
#define RESULT STAR

            unsigned int   i;
            int            strategy = (PFoutput_format == PFoutput_format_sql)
                                      ? SQL
                                      : STRATEGY;
            /* recursion strategy depending on the output format */
            rec_strategy_t *recursion_strategy = (strategy == SQL)
                                                ? recursion_sql
                                                : recursion_mil;

            bool           x_used, loop_used;
            PFla_env_t     e;
            PFarray_t     *old_env = NULL;
            PFalg_schema_t schema, res_schema;
            PFla_op_t     *base_x, *base_res;
            PFla_op_t     *seed, *res_seed;
            PFla_op_t     *new_map;
            PFla_op_t     *old_loop, *base_loop;
            PFla_op_t     *old_side_effects;

            /* initiate translation of e1 */
            reduce (ctx, kids[0], nts[0]);

            /* We know that the order of the result is only required
               outside the recursive function. Thus we throw away the
               pos column. */
            res_schema.count = 2;
            res_schema.items = PFmalloc (2 * sizeof (PFalg_schema_t));

            schema = A(RL(p)).rel->schema;
            assert (schema.count == 3);
            for (i = 0; i < 3; i++) {
                if (schema.items[i].name == col_iter)
                    res_schema.items[0] = schema.items[i];
                else if (schema.items[i].name == col_item)
                    res_schema.items[1] = schema.items[i];
                else if (schema.items[i].name == col_pos)
                    /* do nothing */;
                else
                    PFoops (OOPS_FATAL,
                            "Input schema contains other "
                            "columns than iter, pos, item");
            }

            seed = distinct (
                       project (A(RL(p)).rel,
                                proj (col_iter,
                                      col_iter),
                                proj (col_item,
                                      col_item)));

            /* create a new base for variable $x */
            base_x = rec_base (schema);

            /* create a new result base */
            base_res = rec_base (res_schema);

            /* create a new base_loop relation */
            base_loop = rec_base (LOOP->schema);

            /* save old loop operator */
            old_loop = LOOP;
            /* and overwrite it with the new one */
            LOOP = base_loop;

            /* for strategy IFP we do not need to introduce
               new map relations */
            if (strategy != IFP) {
                /* save old enviroment */
                old_env = ENV;

                /* create new environment */
                ENV = PFarray (sizeof (PFla_env_t), 50);

                /* update all variable bindings in old environment and put
                 * them into new environment */
                for (i = 0; i < PFarray_last (old_env); i++) {
                    e = *((PFla_env_t *) PFarray_at (old_env, i));

                    if (!e.map)
                        new_map = project (
                                      LOOP,
                                      proj (col_outer, col_iter),
                                      proj (col_inner, col_iter));
                    else
                        new_map = project (
                                      eqjoin (
                                          e.map,
                                          LOOP,
                                          col_inner,
                                          col_iter),
                                      proj (col_outer, col_outer),
                                      proj (col_inner, col_inner));

                    *((PFla_env_t *) PFarray_add (ENV))
                        = enventry (e.var, e.rel, new_map, e.frag);
                }
            }

            /* insert $x and "its document" into the NEW environment */
            *((PFla_env_t *) PFarray_add (ENV))
                = enventry (L(p)->sem.var, base_x, NULL, A(RL(p)).frag);

            /* save old side effects list ... */
            old_side_effects = SIDE_EFFECTS;
            /* ... and prepare a new side effects list */
            SIDE_EFFECTS = nil ();

            /* translate e2 under the specified conditions
             * (updated environment, updated loop)
             */
            reduce (ctx, kids[1], nts[1]);

            /* check whether $x and loop are used
               (the result of the checks are used later
               to discard recursion parameters if possible) */
            PFla_dag_mark (A(RR(p)).rel);
            PFla_dag_mark (SIDE_EFFECTS);
            x_used = SEEN(base_x);
            loop_used = SEEN(base_loop);
            PFla_dag_reset (A(RR(p)).rel);
            PFla_dag_reset (SIDE_EFFECTS);

#if RESULT == STAR
    res_seed = seed;
#else /* PLUS */
    /* create a new result seed */
    res_seed = PFla_empty_tbl_ (res_schema);
#endif

            A(p) = (struct PFla_pair_t) {
                        .rel  = recursion_strategy (strategy,
                                                    A(RR(p)).rel,
                                                    seed,
                                                    res_seed,
                                                    base_x,
                                                    base_res,
                                                    x_used,
                                                    loop_used,
                                                    old_loop,
                                                    base_loop,
                                                    SIDE_EFFECTS),
                        .frag = A(RR(p)).frag
                   };

            SIDE_EFFECTS = old_side_effects;

            /* clean up environment and loop relation */
            if (strategy != IFP) {
                ENV = old_env;
            }
            LOOP = old_loop;
        } break;

        default:
            PFoops (OOPS_FATAL, "untranslated expression (rule %i)", rule);
            break;
    }

    /* check consistency of our iter|pos|item interface */
    switch (rule) {
        /* result: pos|item */
        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:

        /* flwr intermediates */
        /* OptBindExpr:        for_ (forbind (forvars (var, nil),
                                              CoreExpr), CoreExpr) */
        case 6:
        /* OptBindExpr:        let (letbind (var, CoreExpr), CoreExpr) */
        case 7:
        /* OptBindExpr:        nil */
        case 8:

        /* order by */
        /* OrderSpecs:         orderspecs (CoreExpr, nil) */
        case 300:
        /* OrderSpecs:         orderspecs (CoreExpr, OrderSpecs) */
        case 301:

        /* twig constructors */
        /* TwigExpr:           twig_seq (TwigExpr, TwigSeq) */
        case 46:
        /* TwigSeq:            TwigExpr: */
        case 47:
        /* TwigExpr:           empty */
        case 48:
        /* TwigExpr:           CoreExpr */
        case 49:
        /* TwigExpr:           doc (TwigSeq) */
        case 50:
        /* TwigExpr:           elem (TagName, TwigSeq) */
        case 51:
        /* TwigExpr:           attr (TagName, CoreExpr) */
        case 52:
        /* TwigExpr:           text (CoreExpr) */
        case 53:
        /* TwigExpr:           comment (CoreExpr) */
        case 54:
        /* TwigExpr:           pi (CoreExpr, CoreExpr) */
        case 55:

        /* function application */
        /* FunctionArgs:       nil */
        case 500:
        /* FunctionArgs:       arg (FunctionArg, FunctionArgs) */
        case 501:
            break;

        default:
        {
            unsigned int count = 0;
            for (unsigned int i = 0; i < A(p).rel->schema.count; i++)
                if (A(p).rel->schema.items[i].name == col_iter ||
                    A(p).rel->schema.items[i].name == col_pos  ||
                    A(p).rel->schema.items[i].name == col_item)
                    count++;
            if (A(p).rel->schema.count != 3 && count !=3)
                PFoops (OOPS_FATAL,
                        "We require each core construct (also %i) to "
                        "return a relation with an iter|pos|item schema.",
                        p->kind);
        }
    }

    /* In case we recursively generate the algebra plan
       we need to record the mappings that have changed
       to ensure that we are able to clean up the side
       effects again. */
    if (CORE2ALG_MAP && (rel != A(p).rel || frag != A(p).frag))
        /* Add the mappings in bottom up order to ensure that we
           can consistently patch the changes again. */
        *((core2alg_map_t *) PFarray_add (CORE2ALG_MAP))
            = (core2alg_map_t) { .core = p, .rel = rel, .frag = frag};
}

/* recursion strategy for SQL */
static PFla_op_t *
recursion_sql (int strategy,
               PFla_op_t *body,
               PFla_op_t *seed,
               PFla_op_t *res_seed,
               PFla_op_t *base,
               PFla_op_t *base_res,
               bool x_used,
               bool loop_used,
               PFla_op_t *old_loop,
               PFla_op_t *base_loop,
               PFla_op_t *side_effects)
{
    (void)strategy;
    (void)base_res;
    (void)x_used;
    (void)res_seed;
    assert (strategy == SQL);


    /* check whether we may modify the strategy and
       if the DELTA approach is allowed */
    if (!PFprop_check_rec_delta (body) ||
        !PFprop_check_rec_delta (side_effects))
        PFoops (OOPS_FATAL, "SQL cannot cope with this query");

    PFla_op_t *res_body = NULL;
    PFla_op_t *res_rec_param = NULL;
    PFla_op_t *loop_rec_param = NULL;

    /* the result of the recursion body */
    res_body = distinct (
                   project (body,
                       proj (col_iter, col_iter),
                       proj (col_item, col_item)));

    /* ------------------- BODY ----------------- */

    res_rec_param = rec_param (
                        rec_arg (
                            rowid (seed, col_pos),
                            rowid (res_body, col_pos),
                            base
                        ),
                        nil ());

    /* ------------------ LOOP ------------------ */

    if (loop_used)
        /* for SQL the LOOP doesn't change */
        loop_rec_param = rec_param (
                            rec_arg (old_loop,
                                     base_loop,
                                     base_loop),
                            res_rec_param);
    else
        loop_rec_param = res_rec_param;

    /* ---------------RECURSION ---------------- */
    return rank (
               project (
                   rec_fix (
                       PFla_side_effects (
                           side_effects,
                           loop_rec_param),
                       res_body),
                   proj (col_iter, col_iter),
                   proj (col_item, col_item)),
               col_pos,
               sortby (col_item));
}

/* recursion strategy for Monet */
static PFla_op_t *
recursion_mil (int strategy,
               PFla_op_t *body,
               PFla_op_t *seed,
               PFla_op_t *res_seed,
               PFla_op_t *base,
               PFla_op_t *base_res,
               bool x_used,
               bool loop_used,
               PFla_op_t *old_loop,
               PFla_op_t *base_loop,
               PFla_op_t *side_effects)
{
    PFla_op_t  *res_body,
               *delta,
               *res;
    PFla_op_t  *res_rec_param,
               *loop_rec_param,
               *x_rec_param;
    PFla_op_t  *updated_loop;

    (void)strategy;
    assert (strategy == DELTA       ||
            strategy == TC          ||
            strategy == IFP         ||
            strategy == TC_OR_DELTA ||
            strategy == IFP_OR_DELTA);

    /* check whether we may modify the strategy and
       if the DELTA approach is allowed */
    if (VAR_STRATEGY(strategy) &&
        PFprop_check_rec_delta (body) &&
        PFprop_check_rec_delta (side_effects))
        strategy = DELTA;

    /* the result of the recursion body */
    res_body = distinct (project (body,
                                  proj (col_iter, col_iter),
                                  proj (col_item, col_item)));

    /* get the really new nodes */
    delta = difference (res_body,
                        project (base_res,
                                 proj (col_iter, col_iter),
                                 proj (col_item, col_item)));

    /* add the new nodes (of this recursion step)
       to our already collected result */
    res = disjunion (delta,
                     project (base_res,
                              proj (col_iter, col_iter),
                              proj (col_item, col_item)));

    /* ------------------- BODY ------------------- */

    /* using 'distinct (delta)' or 'distinct (res_body)'
       instead of 'res' changes the evaluation strategy:
        - 'delta': only the really new nodes are the input
          for the next recursion
        - 'res_body': the result of the current recursion
          is the input for the next recursion
        - 'res': the whole result collected until now
          is input to the next recurstion step */
    if (strategy == DELTA)
        body = delta;
    else if (strategy == TC ||
        strategy == TC_OR_DELTA)
        body = res_body;
    else if (strategy == IFP ||
        strategy == IFP_OR_DELTA)
        body = res;
    else
        PFoops (OOPS_FATAL,
                "unknown strategy in algebra translation "
                "of the recursion primitive");

    /* ------------------ RESULT ------------------ */
    res_rec_param = rec_param (
                        rec_arg (
                            res_seed,
                            res,
                            base_res),
                        nil ());

    /* ------------------- LOOP ------------------- */

    /* In case the loop relation was not used
       we don't need the recursion parameter */
    if (!loop_used) {
        loop_rec_param = res_rec_param;
    } else if (strategy == IFP || strategy == IFP_OR_DELTA) {
        /* for IFP the loop doesn't change */
        loop_rec_param = rec_param (rec_arg (old_loop,
                                             base_loop,
                                             base_loop),
                                    res_rec_param);
    } else {
        /* update the loop relation after the recursion body
           has been processed ... */
        updated_loop = project (eqjoin (distinct (
                                            project (delta,
                                                     proj (col_iter1,
                                                           col_iter))),
                                        base_loop,
                                        col_iter1,
                                        col_iter),
                                proj (col_iter, col_iter));

        /* ... and integrate the loop maintenance in the recursion */
        loop_rec_param = rec_param (rec_arg (old_loop,
                                             updated_loop,
                                             base_loop),
                                    res_rec_param);
    }

    /* -------------------- $x -------------------- */
    if (x_used)
        x_rec_param = rec_param (
                          rec_arg (
                              rank (
                                  seed,
                                  col_pos,
                                  sortby (col_item)),
                              rank (
                                  body,
                                  col_pos,
                                  sortby (col_item)),
                              base),
                          loop_rec_param);
    else
        x_rec_param = loop_rec_param;

    /* ---------------- RECURSION ----------------- */
    return rank (
                rec_fix (PFla_side_effects (side_effects, x_rec_param), res),
                col_pos, sortby (col_item));
}

static PFalg_step_spec_t
locstep_spec (PFalg_axis_t axis, PFty_t ty)
{
    PFalg_step_spec_t spec;

    spec.axis = axis;
    /* missing QName */
    spec.qname = PFqname (PFns_wild, NULL);

    if (PFty_subtype (ty, PFty_xs_anyAttribute ())) {
        /* This is a test for attribute nodes */
        spec.kind = node_kind_attr;
        spec.qname = PFty_name (ty);
    }
    else if (PFty_subtype (ty, PFty_xs_anyElement ())) {
        /* This is a test for element nodes */
        spec.kind = node_kind_elem;
        spec.qname = PFty_name (ty);
    }
    else if (PFty_subtype (ty, PFty_doc (PFty_xs_anyType ()))) {
        /* This is a test for document nodes */
        spec.kind = node_kind_doc;
    }
    else if (PFty_subtype (ty, PFty_text ())) {
        /* This is a test for text nodes */
        spec.kind = node_kind_text;
    }
    else if (PFty_subtype (ty, PFty_comm ())) {
        /* This is a test for comment nodes */
        spec.kind = node_kind_comm;
    }
    else if (PFty_subtype (ty, PFty_pi (NULL))) {
        /* This is a test for processing-instruction nodes */
        spec.kind = node_kind_pi;
        spec.qname = PFty_name (ty);
    }
    else if (PFty_subtype (PFty_xs_anyNode (), ty)) {
        /* If all these cases did not apply, it is probably a node() test. */
        spec.kind = node_kind_node;
    }
    /* If we still couldn't find out, we probably need to give up. */
    else {
        PFoops (OOPS_FATAL,
                "Problem with an XPath step: cannot evaluate "
                "node test `%s'", PFty_str (ty));
        spec.kind = node_kind_node;
    }

    return spec;
}

/**
 * Construct a relational expression for a path step
 */
static struct PFla_pair_t
locstep (core2alg_ctx_t *ctx,
         PFalg_axis_t axis, PFty_t ty,
         struct PFla_pair_t p)
{
    if (PFprop_type_of (p.rel, col_item) == aat_error)
        return p;
    else if (!(PFprop_type_of (p.rel, col_item) & aat_node))
        PFoops (OOPS_FATAL,
                "err:XP0019: Argument to location step must be a node sequence.");

    /*
     *                  env, loop: e => (q(e), delta)
     * ------------------------------------------------------------
     *                       env, loop: e/a::n =>
     * (row_pos<item>/iter (SCJ (proj_iter,item (q(e)), delta)), delta)
     *
     * A(L(p)).rel contains a axis node with information on the
     * location step. Will be read out in PFla_step().
     */
    PFla_op_t *step = PFla_project (
                          PFla_step_join_simple (
                              PFla_set_to_la (p.frag),
                              project (p.rel,
                                       proj (col_iter, col_iter),
                                       proj (col_item, col_item)),
                              locstep_spec (axis, ty),
                              col_item,
                              col_item1),
                          PFalg_proj (col_iter, col_iter),
                          PFalg_proj (col_item, col_item1));

    if (ORDERING)
        return (struct  PFla_pair_t) {
                   .rel = rank (step, col_pos, sortby (col_item)),
                   .frag = p.frag };
    else
        return (struct  PFla_pair_t) {
                   .rel = rowid (step, col_pos),
                   .frag = p.frag };
}

/**
 * Construct a new entry to be inserted into the variable environment.
 * Called whenever a new variable is declared.
 */
static PFla_env_t
enventry (PFvar_t *var, PFla_op_t *rel, PFla_op_t *map, PFarray_t *doc)
{
    return (PFla_env_t) { .var = var, .rel = rel, .map = map, .frag = doc };
}

/**
 * Given an XQuery type @a ty, an algebra expression @a e, and the
 * loop relation @a loop, return an algebra expression that returns
 * the relation with schema (iter, subty), so that for each iter value
 * in @a loop there exists one tuple, with the subty column set to
 * true, if @a e has a subtype of @a ty, and false otherwise.
 */
static PFla_op_t *
type_test (PFty_t ty, PFla_pair_t e, PFla_op_t *loop)
{
    PFalg_aggr_t aggr_item;
    PFla_op_t   *itemty,
                *aggr;

    /*
     * Collect algebra expression with schema (iter,pos,itemty)
     * so that itemty is true for any item that is a subtype of
     * ty, and false otherwise.
     *
     * The surface language only allows QNames for predefined
     * types, or node kind tests. Fortunately, only few atomic
     * types are predefined: xs:integer, xs:decimal, xs:double,
     * xs:boolean, xs:string. For all of them we have an algebra
     * correspondance.
     *
     * We first consider the case that ty is the empty sequence.
     * (This cannot be entered on the surface language. But it
     * may be introduced during core generation/optimization.
     * And we want to avoid nasty bugs here, when that case would
     * be caught in the following cases.)
     *
     *        /                        subty \
     *       | dist (proj_iter (e)) X ------- |       (non-empty iters)
     *        \                        false /
     *                           U
     *    /                                 subty \
     *   | (loop \ dist (proj_iter (e))) X ------- |  (empty iters)
     *    \                                 false /
     *
     */
    if (PFty_subtype (ty, PFty_empty ()))
        return
            disjunion (
                attach (
                    distinct (project (e.rel, proj (col_iter, col_iter))),
                    col_subty, lit_bln (false)),
                attach (
                    difference (
                        loop,
                        distinct (project (e.rel, proj (col_iter, col_iter)))),
                    col_subty, lit_bln (true)));
    /*
     * To test, e.g., for integer values, use
     *
     *   proj_iter,pos,itemty (type_itemty:item/int (e))
     *
     */
    else if (PFty_subtype (ty, PFty_star (PFty_xs_integer ())))
        itemty = type (e.rel, col_itemty, col_item, aat_int);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_decimal ())))
        /* xs:integer is a subtype of xs:decimal.
         * Test for both types. The `type' operator merely adds a boolean
         * column. We OR them after testing for for both types.
         */
        itemty = or (type (type (e.rel, col_item2, col_item, aat_int),
                           col_item3, col_item, aat_dec),
                     col_itemty, col_item2, col_item3);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_double ())))
        itemty = type (e.rel, col_itemty, col_item, aat_dbl);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_boolean ())))
        itemty = type (e.rel, col_itemty, col_item, aat_bln);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_string ())))
        itemty = type (e.rel, col_itemty, col_item, aat_str);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_datetime ())))
        itemty = type (e.rel, col_itemty, col_item, aat_dtime);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_date ())))
        itemty = type (e.rel, col_itemty, col_item, aat_date);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_time ())))
        itemty = type (e.rel, col_itemty, col_item, aat_time);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_gyearmonth ())))
        itemty = type (e.rel, col_itemty, col_item, aat_gymonth);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_gyear ())))
        itemty = type (e.rel, col_itemty, col_item, aat_gyear);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_gmonthday ())))
        itemty = type (e.rel, col_itemty, col_item, aat_gmday);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_gmonth ())))
        itemty = type (e.rel, col_itemty, col_item, aat_gmonth);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_gday ())))
        itemty = type (e.rel, col_itemty, col_item, aat_gday);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_yearmonthduration ())))
        itemty = type (e.rel, col_itemty, col_item, aat_ymduration);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_daytimeduration ())))
        itemty = type (e.rel, col_itemty, col_item, aat_dtduration);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_duration ())))
       itemty = or (type (or (type (type (e.rel, col_iter2,
                                          col_item, aat_ymduration),
                                    col_iter3,
                                    col_item,
                                    aat_dtduration),
                              col_iter4, col_iter2, col_iter3),
                          col_iter5, col_item, aat_duration),
                    col_itemty, col_iter4, col_iter5);
    else if (PFty_subtype (ty, PFty_star (PFty_untypedAtomic ())))
        itemty = type (e.rel, col_itemty, col_item, aat_uA);
    else if (PFty_subtype (ty, PFty_star (PFty_xs_anyNode ()))) {
        PFla_op_t *filter, *number, *in_loop;

        /* create a key for all rows */
        number  = rowid (e.rel, col_inner);
        /* use this key as inner loop relation */
        in_loop = project (number, proj (col_iter1, col_inner));
        /* evaluate for all nodes a self step that filters the correct
           kind and name */
        filter  = project (
                      step_join (
                          PFla_set_to_la (e.frag),
                          type_assert_pos (
                              select_ (
                                  type (number, col_itemty, col_item, aat_node),
                                  col_itemty),
                              col_item, aat_node),
                          locstep_spec (alg_self, PFty_prime (ty)), -1,
                          col_item, col_item2),
                      proj (col_iter1, col_inner));

        /* Attach the Boolean value true for all rows that matched the
           self step filter and the value false for all other rows.
           Map back the old iter values to the new Boolean item column */
        itemty = eqjoin (number,
                         disjunion (attach (filter,
                                            col_itemty,
                                            lit_bln (true)),
                                    attach (difference (in_loop, filter),
                                            col_itemty,
                                            lit_bln (false))),
                         col_inner,
                         col_iter1);
    }
    else
        PFoops (OOPS_FATAL,
                "Sorry, I cannot translate the test for type `%s'",
                PFty_str (ty));

    itemty = project (itemty,
                      proj (col_iter, col_iter),
                      proj (col_itemty, col_itemty));

    /*
     * Second part is the test for the occurence indicator.
     */

    /* build a seqty1 aggregate */
    aggr_item = PFalg_aggr (alg_aggr_seqty1, col_subty, col_itemty);
    aggr      = aggr (itemty, col_iter, 1, &aggr_item);

    /*
     * Ocurrence indicator `1' (exactly one item).
     *
     * seqty1_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty\
     * | (loop \ proj_iter (itemty)) X ----- |
     *  \                              false/
     *
     * (First part considers all iterations with length of at
     * least one: The itemty expression contains true/false values
     * as determined above. The seqty1 operator sets true for all
     * those `iter' groups, where there is exactly one tuple with
     * value `true', and false otherwise. The second part of the
     * union considers all the empty sequences. They do not match
     * the occurrence indicator and are thus set to false.)
     */
    if (PFty_subtype (ty, PFty_item ()))
        return
            disjunion (
                aggr,
                attach (
                    difference (
                        loop,
                        project (itemty, proj (col_iter, col_iter))),
                    col_subty, lit_bln (false)));

    /*
     * Ocurrence indicator `?' (zero or one item).
     *
     * seqty1_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty\
     * | (loop \ proj_iter (itemty)) X ----- |
     *  \                              true /
     *
     * In contrast to `1', we return true for all empty sequences.
     */
    if (PFty_subtype (ty, PFty_opt (PFty_item ())))
        return
            disjunion (
                aggr,
                attach (
                    difference (
                        loop,
                        project (itemty, proj (col_iter, col_iter))),
                    col_subty, lit_bln (true)));

    /* turn the seqty1 aggregate into an all aggregate */
    aggr->sem.aggr.aggr[0].kind = alg_aggr_all;

    /*
     * Ocurrence indicator `+' (one or more items).
     *
     * all_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty \
     * | (loop \ proj_iter (itemty)) X -----  |
     *  \                              false /
     *
     * Groupwise test if all tuples in itemty carry a `true'.
     * This makes all iterations true that contain only items
     * that satisfy the type test, and false all those that
     * contain at least one item that does not satisfy the
     * type test. We are left with considering the empty sequences
     * that do not qualify for the name test. We return false for
     * them.
     */
    if (PFty_subtype (ty, PFty_plus (PFty_item ())))
        return
            disjunion (
                aggr,
                attach (
                    difference (
                        loop,
                        project (itemty, proj (col_iter, col_iter))),
                    col_subty, lit_bln (false)));

    /*
     * Ocurrence indicator `*' (zero or more items).
     *
     * all_subty:item/iter (proj_iter,item:itemty (itemty))
     *                    U
     *  /                              subty\
     * | (loop \ proj_iter (itemty)) X ----  |
     *  \                              true /
     *
     * Almost the same as `+', but return true for empty sequences.
     */
    if (PFty_subtype (ty, PFty_star (PFty_item ())))
        return
            disjunion (
                aggr,
                attach (
                    difference (
                        loop,
                        project (itemty, proj (col_iter, col_iter))),
                    col_subty, lit_bln (true)));

    /*
     * We should never reach this point.
     */
    PFoops (OOPS_FATAL, "Error in type_test().");
    assert(0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * Extract all possible algebra types from the XQuery type.
 */
static PFalg_simple_type_t
PFalg_type (PFty_t ty)
{
    PFalg_simple_type_t alg_ty = 0;

    ty = PFty_prime (PFty_defn (ty));

    if (!PFty_disjoint (ty, PFty_xs_integer ()))
        alg_ty |= aat_int;
    if (!PFty_disjoint (ty, PFty_xs_string ()))
        alg_ty |= aat_str;
    if (!PFty_disjoint (ty, PFty_xs_double ()))
        alg_ty |= aat_dbl;
    if (!PFty_disjoint (ty, PFty_xs_decimal ()))
        alg_ty |= aat_dec;
    if (!PFty_disjoint (ty, PFty_xs_boolean ()))
        alg_ty |= aat_bln;
    if (!PFty_disjoint (ty, PFty_xs_QName ()))
        alg_ty |= aat_qname;
    if (!PFty_disjoint (ty, PFty_untypedAtomic ()))
        alg_ty |= aat_uA;
    if (!PFty_disjoint (ty, PFty_xs_anyAttribute ()))
        alg_ty |= aat_anode;
    if (!PFty_disjoint (ty, PFty_xs_anyElement ()) ||
        !PFty_disjoint (ty, PFty_doc (PFty_xs_anyNode ())) ||
        !PFty_disjoint (ty, PFty_pi (NULL)) ||
        !PFty_disjoint (ty, PFty_comm ()) ||
        !PFty_disjoint (ty, PFty_text ()))
        alg_ty |= aat_pnode;
    if (!PFty_disjoint (ty, PFty_stmt ())) {
        alg_ty |= aat_update;
        alg_ty |= aat_node;
        alg_ty |= aat_node1;
        alg_ty |= aat_uA;
        alg_ty |= aat_qname;
    }
    if (!PFty_disjoint (ty, PFty_docmgmt ())) {
        alg_ty |= aat_docmgmt;
        alg_ty |= aat_path;
        alg_ty |= aat_docnm;
        alg_ty |= aat_colnm;
    }
    if (!PFty_disjoint (ty, PFty_xs_datetime ()))
        alg_ty |= aat_dtime;
    if (!PFty_disjoint (ty, PFty_xs_date ()))
        alg_ty |= aat_date;
    if (!PFty_disjoint (ty, PFty_xs_time ()))
        alg_ty |= aat_time;
    if (!PFty_disjoint (ty, PFty_xs_gyearmonth ()))
        alg_ty |= aat_gymonth;
    if (!PFty_disjoint (ty, PFty_xs_gyear ()))
        alg_ty |= aat_gyear;
    if (!PFty_disjoint (ty, PFty_xs_gmonthday ()))
        alg_ty |= aat_gmday;
    if (!PFty_disjoint (ty, PFty_xs_gmonth ()))
        alg_ty |= aat_gmonth;
    if (!PFty_disjoint (ty, PFty_xs_gday ()))
        alg_ty |= aat_gday;
    if (!PFty_disjoint (ty, PFty_xs_duration ()))
        alg_ty |= aat_duration;
    if (!PFty_disjoint (ty, PFty_xs_yearmonthduration ()))
        alg_ty |= aat_ymduration;
    if (!PFty_disjoint (ty, PFty_xs_daytimeduration ()))
        alg_ty |= aat_dtduration;
    return alg_ty;
}

/**
 * Extract occurrence indicator from the XQuery type.
 */
static PFalg_occ_ind_t
PFalg_type_occ (PFty_t ty)
{
    if (PFty_subtype (ty, PFty_item ()))
        return alg_occ_exactly_one;
    else if (PFty_subtype (ty, PFty_plus (PFty_item ())))
        return alg_occ_one_or_more;
    else if (PFty_subtype (ty, PFty_opt(PFty_item ())))
        return alg_occ_zero_or_one;
    else
        return alg_occ_unknown;
}


/**
 * Compile XQuery Core tree into relational algebra tree.
 *
 * @param r root of the Core tree.
 * @return the algebra equivalent of @a r
 */
PFla_op_t *
PFcore2alg (PFcnode_t *r, PFquery_t *query,
            enum PFoutput_format_t output_format)
{
    PFarray_t *options = NULL;

    /* create a new context */
    core2alg_ctx_t ctx;

    assert (r);

    /* label the core tree bottom up */
    PFcore2alg_label (r);

    /* get empty environment */
    ctx.env  = PFarray (sizeof (PFla_env_t), 50);
    /* loop is initially a table with just one tuple */
    ctx.loop = lit_tbl (collist (col_iter), tuple (lit_nat (1)));
    /* side_effects is initally an empty list */
    ctx.side_effects = nil ();
    /* Create a stack for the map relation information */
    ctx.mapping = PFarray (sizeof (map_rel_info_t), 50);
    /* set ordering mode */
    ctx.ordering = query->ordering;
    /* initialize the sequence count with a dummy value */
    ctx.seq_count = 0;

    /* Pointer to array of function parameter values */
    ctx.fun_args = NULL;

    /* Read recursion depth information as option */
    options = PFenv_lookup (PFoptions, PFqname (PFns_lib, "recursion-depth"));
    if (!options)
        ctx.recursion_depth = 0;
    else {
        if (PFarray_last (options) > 1)
            PFoops (OOPS_WARNING,
                    "Only the last recursion depth option is used.");

        ctx.recursion_depth = atoi (*((char **) PFarray_top (options)));
    }

    /* Initialize stack recording the active user-defined functions */
    ctx.fun_active = PFarray (sizeof (fun_active_t), 50);

    /* initially do not memorize algebra translations */
    ctx.core2alg_map = NULL;

    /* depending on the output format we choose a different
     * recursion strategy */
    PFoutput_format = output_format;

    /* invoke compilation */
    reduce (&ctx, r, 1);

    return A(r).rel;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
