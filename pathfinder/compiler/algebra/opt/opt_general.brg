%{

/**
 * @file
 *
 * Optimize relational algebra expression DAG
 * based on general patterns.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2006 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 * $Id$
 */

/* always include pathfinder.h first! */
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "algopt.h"
#include "properties.h"
#include "alg_dag.h"
#include "oops.h"         /* PFoops() */
#include "mem.h"          /* PFmalloc() */
#include "subtyping.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFla_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p) ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* the state of the children determined during 
   bottom-up labeling is backed up here */
#define CHILD_STATE_LABEL(p,i) ((p)->child_state_label[i])

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/logical.h!
 */
%term  serialize      =   1
%term  lit_tbl        =   2
%term  empty_tbl      =   3
%term  attach         =   4
%term  cross          =   5
%term  eqjoin         =   6
%term  project        =   7
%term  select_        =   8
%term  disjunion      =   9
%term  intersect      =  10
%term  difference     =  11
%term  distinct       =  12
%term  num_add        =  20
%term  num_subtract   =  21
%term  num_multiply   =  22
%term  num_divide     =  23
%term  num_modulo     =  24
%term  num_eq         =  25
%term  num_gt         =  26
%term  num_neg        =  27
%term  bool_and       =  28
%term  bool_or        =  29
%term  bool_not       =  30
%term  avg            =  31
%term  max_           =  32
%term  min_           =  33
%term  sum            =  34
%term  count          =  35
%term  rownum         =  36
%term  number         =  37
%term  type           =  40
%term  type_assert    =  41
%term  cast           =  42
%term  seqty1         =  43
%term  all            =  44
%term  scjoin         =  50
%term  dup_scjoin     =  51
%term  doc_tbl        =  52
%term  doc_access     =  53
%term  element        =  60
%term  element_tag    =  61
%term  attribute      =  62
%term  textnode       =  63
%term  docnode        =  64
%term  comment        =  65
%term  processi       =  66
%term  merge_adjacent =  67
%term  roots_         =  70
%term  fragment       =  71
%term  frag_union     =  72
%term  empty_frag     =  73
%term  cond_err       =  80
%term  rec_fix        =  81
%term  rec_param      =  82
%term  rec_nil        =  83
%term  rec_arg        =  84
%term  rec_base       =  85
%term  concat         = 100
%term  contains       = 101
%term  string_join    = 102
%term  dummy          = 120

%%

Query:  serialize (Frag, Rel)                     =   1 (10);

Rel:    lit_tbl                                   =   2 (10);
Rel:    attach (Rel)                              =   3 (10);
Rel:    cross (Rel, Rel)                          =   4 (10);
Rel:    cross (Rel, lit_tbl)                      =   5 (10);
Rel:    cross (lit_tbl, Rel)                      =   6 (10);
Rel:    eqjoin (Rel, Rel)                         =   8 (10);
Rel:    project (Rel)                             =  10 (10);
Rel:    project (attach (Rel))                    =  11 (10);
Rel:    project (project (Rel))                   =  13  (1);
Rel:    select_ (Rel)                             =  19 (10);
Rel:    disjunion (Rel, Rel)                      =  20 (10);
Rel:    disjunion (EmptyRel, Rel)                 =  21  (5);
Rel:    disjunion (Rel, EmptyRel)                 =  22  (5);
Rel:    intersect (Rel, Rel)                      =  23 (10);
Rel:    difference (Rel, Rel)                     =  24 (10);
Rel:    difference (Rel, EmptyRel)                =  25  (5);
Rel:    distinct (Rel)                            =  26 (10);
Rel:    distinct (scjoin (Frag, Rel))             =  27 (5);
Rel:    num_add (Rel)                             =  30 (10);
Rel:    num_subtract (Rel)                        =  31 (10);
Rel:    num_multiply (Rel)                        =  32 (10);
Rel:    num_divide (Rel)                          =  33 (10);
Rel:    num_modulo (Rel)                          =  34 (10);
Rel:    num_neg (Rel)                             =  35 (10);
Rel:    num_gt (Rel)                              =  36 (10);
Rel:    num_eq (Rel)                              =  37 (10);
Rel:    bool_and (Rel)                            =  38 (10);
Rel:    bool_or (Rel)                             =  39 (10);
Rel:    bool_not (Rel)                            =  40 (10);
Rel:    avg (Rel)                                 =  41 (10);
Rel:    max_ (Rel)                                =  42 (10);
Rel:    min_ (Rel)                                =  43 (10);
Rel:    sum (Rel)                                 =  44 (10);
Rel:    count (Rel)                               =  45 (10);
Rel:    rownum (Rel)                              =  50 (10);
Rel:    number (Rel)                              =  51 (10);
Rel:    number (number (Rel))                     =  52 (10);
Rel:    number (project (number (Rel)))           =  53 (10);
Rel:    type (Rel)                                =  54 (10);
Rel:    type_assert (Rel)                         =  55 (10);
Rel:    cast (cast (Rel))                         =  56 (10);
Rel:    cast (project (cast (Rel)))               =  57 (10);
Rel:    cast (Rel)                                =  58 (10);
Rel:    seqty1 (Rel)                              =  59 (10);
Rel:    all (Rel)                                 =  60 (10);
Rel:    ScjRel                                    =  61 (10);
ScjRel: scjoin (Frag, Rel)                        =  62 (10);
ScjRel: scjoin (Frag, ScjRel)                     =  63 (10);
ScjRel: scjoin (Frag, distinct (Rel))             =  64 (10);
Rel:    dup_scjoin (Frag, Rel)                    =  65 (10);
Rel:    doc_access (Frag, Rel)                    =  66 (10);

Rel:    roots_ (doc_tbl (Rel))                    =  70 (10);
Rel:    roots_ (element (Frag,                       
                         element_tag (Rel, Rel))) =  71 (10);
Rel:    roots_ (attribute (Rel))                  =  72 (10);
Rel:    roots_ (textnode (Rel))                   =  73 (10);
Rel:    roots_ (docnode (Frag, Rel))              =  74 (10);
Rel:    roots_ (comment (Rel))                    =  75 (10);
Rel:    roots_ (processi (Rel))                   =  76 (10);
Rel:    roots_ (merge_adjacent (Frag, Rel))       =  77 (10);

Rel:    cond_err (Rel, Rel)                       =  80 (10);

Rel:    rec_fix (Rec, Rel)                        =  81 (10);
Rel:    rec_base                                  =  82 (10);
Rec:    rec_param (Arg, Rec)                      =  83 (10);
Rec:    rec_nil                                   =  84 (10);
Arg:    rec_arg (Rel, Rel)                        =  85 (10);

Rel:    concat (Rel)                              =  86 (10);
Rel:    contains (Rel)                            =  87 (10);
Rel:    string_join (Rel, Rel)                    =  88 (10);
Rel:    dummy (Rel)                               =  89 (10);

Rel:    EmptyRel                                  =  90  (0);


Frag:    fragment (doc_tbl (Rel))                 = 100 (10);
Frag:    fragment (element (Frag, 
                            element_tag (Rel,
                                         Rel)))   = 101 (10);
Frag:    fragment (attribute (Rel))               = 102 (10);
Frag:    fragment (textnode (Rel))                = 103 (10);
Frag:    fragment (docnode (Frag, Rel))           = 104 (10);
Frag:    fragment (comment (Rel))                 = 105 (10);
Frag:    fragment (processi (Rel))                = 106 (10);
Frag:    fragment (merge_adjacent (Frag, Rel))    = 107 (10);

Frag:    frag_union (Frag, Frag)                  = 111 (10);
Frag:    empty_frag                               = 112 (10);


EmptyRel:    empty_tbl                            = 120  (0);

EmptyRel:    attach (EmptyRel)                    = 121  (0);
EmptyRel:    cross (EmptyRel, Rel)                = 122  (0);
EmptyRel:    cross (Rel, EmptyRel)                = 123  (0);
EmptyRel:    eqjoin (EmptyRel, Rel)               = 124  (0);
EmptyRel:    eqjoin (Rel, EmptyRel)               = 125  (0);
EmptyRel:    project (EmptyRel)                   = 126  (0);
EmptyRel:    select_ (EmptyRel)                   = 127  (0);
EmptyRel:    disjunion (EmptyRel, EmptyRel)       = 130  (0);
EmptyRel:    intersect (EmptyRel, Rel)            = 131  (0);
EmptyRel:    intersect (Rel, EmptyRel)            = 132  (0);
EmptyRel:    difference (EmptyRel, Rel)           = 133  (0);
EmptyRel:    distinct (EmptyRel)                  = 134  (0);
EmptyRel:    num_add (EmptyRel)                   = 140  (0);
EmptyRel:    num_subtract (EmptyRel)              = 141  (0);
EmptyRel:    num_multiply (EmptyRel)              = 142  (0);
EmptyRel:    num_divide (EmptyRel)                = 143  (0);
EmptyRel:    num_modulo (EmptyRel)                = 144  (0);
EmptyRel:    num_neg (EmptyRel)                   = 145  (0);
EmptyRel:    num_gt (EmptyRel)                    = 146  (0);
EmptyRel:    num_eq (EmptyRel)                    = 147  (0);
EmptyRel:    bool_and (EmptyRel)                  = 148  (0);
EmptyRel:    bool_or (EmptyRel)                   = 149  (0);
EmptyRel:    bool_not (EmptyRel)                  = 150  (0);
EmptyRel:    avg (EmptyRel)                       = 151  (0);
EmptyRel:    max_ (EmptyRel)                      = 152  (0);
EmptyRel:    min_ (EmptyRel)                      = 153  (0);
EmptyRel:    sum (EmptyRel)                       = 154  (0);
EmptyRel:    count (EmptyRel)                     = 155  (0);
EmptyRel:    rownum (EmptyRel)                    = 160  (0);
EmptyRel:    number (EmptyRel)                    = 161  (0);
EmptyRel:    type (EmptyRel)                      = 162  (0);
EmptyRel:    type_assert (EmptyRel)               = 163  (0);
EmptyRel:    cast (EmptyRel)                      = 164  (0);
EmptyRel:    seqty1 (EmptyRel)                    = 165  (0);
EmptyRel:    all (EmptyRel)                       = 166  (0);
EmptyRel:    scjoin (Frag, EmptyRel)              = 170  (0);
EmptyRel:    doc_access (Frag, EmptyRel)          = 171  (0);
EmptyRel:    roots_ (element (Frag, 
                              element_tag (EmptyRel,
                                          Rel)))  = 180  (0);
EmptyRel:    roots_ (attribute (EmptyRel))        = 182  (0);
EmptyRel:    roots_ (textnode (EmptyRel))         = 184  (0);
EmptyRel:    roots_ (comment (EmptyRel))          = 185  (0);
EmptyRel:    roots_ (processi (EmptyRel))         = 186  (0);
EmptyRel:    roots_ (merge_adjacent (Frag,                   
                                     EmptyRel))   = 187  (0);
EmptyRel:    cond_err (EmptyRel, Rel)             = 190  (0);
EmptyRel:    concat (EmptyRel)                    = 200  (0);
EmptyRel:    string_join (EmptyRel, Rel)          = 201  (0);
EmptyRel:    dummy (EmptyRel)                     = 202  (0);

%%

#include "algebra_mnemonic.h"

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/** and so on... */
#define RL(p) (L(R(p)))
#define LLL(p) (LL(L(p)))
#define RLL(p) (LL(R(p)))

#define MAX_KIDS 10

#define SEEN(p) ((p)->bit_dag)

/* mark all nodes in the pattern of node p as seen 
   if it is not contained in kids. */
static void mark_pattern_SEEN (PFla_op_t *p,  PFla_op_t **kids);

/* Check consistency of the state label in the pattern rooted in p */
static bool changed_label (PFla_op_t *p,  PFla_op_t **kids);

/* Relabel node p if it is not contained in kids. */
static void relabel (PFla_op_t *p,  PFla_op_t **kids);

static void
label (PFla_op_t *p);
/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFla_op_t *p, int goalnt)
{
    int              rule;       /* rule number that matches for this node */
    short           *nts;        /* target non-terminals for the leaf nodes of
                                    the current rule */
    PFla_op_t       *kids[MAX_KIDS];   /* leaf nodes of this rule */
    bool             rewritten = false;

    short            old_state_label;
    unsigned short   i;

    do {
        assert (STATE_LABEL (p));

        /* determine rule that matches for this non-terminal */
        rule = PFopt_general_rule (STATE_LABEL (p), goalnt);

        assert (rule);

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFopt_general_nts[rule];
        PFopt_general_kids (p, rule, kids);

        /* check consistency of pattern labels */
        rewritten = changed_label (p, kids);

        /*
         * prune already optimized branch of the tree
         * (we try to treat the tree plan as DAG)
         */
        if (!SEEN(p) && !rewritten)
            /* recursively translate all leaf expressions */
            for (i = 0; nts[i]; i++)
                if ((rewritten = reduce (kids[i], nts[i])))
                    break;  /* abort if a subtree was rewritten */

        if (rewritten) {

            /*
             * If a subtree has been rewritten, we have to
             *  - re-label that part of the tree, and
             *  - possibly propagate the `rewritten' information upwards.
             */

            /* remember our old state_label (so we know if it has changed) */
            old_state_label = STATE_LABEL(p);

            /*
             * Re-label current tree pattern.
             * (at most down to the pattern leaves, as they should already be
             * correctly labeled by the above reduce() call)
             */
            relabel (p, kids);

            /* If our own state_label has changed, notify our caller. */
            if (old_state_label != STATE_LABEL(p)) {
                SEEN(p)= false;
                return true;
            }
        }
    } while (rewritten);

    /* save old_state_label to detect structural changes introduced
       by the following action code */
    old_state_label = STATE_LABEL(p);

    /* mark all nodes in the current pattern as visited 
       to avoid tree traversals */
    mark_pattern_SEEN (p, kids);

    /* action code */
    switch (rule) {

        /* Rel:    cross (Rel, lit_tbl) */
        case 5:
            /* replace cross product with a literal table that contains
               only one row by a number of attach operators (one for each
               tuple). */
            if (R(p)->sem.lit_tbl.count == 1) {
                PFla_op_t *ret = L(p);
                for (unsigned int i = 0; i < R(p)->schema.count; i++)
                    ret = PFla_attach (ret, R(p)->schema.items[i].name,
                                       R(p)->sem.lit_tbl.tuples[0].atoms[i]);
                *p = *(ret);
                break;
            } 
        /* Rel:    cross (lit_tbl, Rel) */
        case 6:
            /* replace cross product with a literal table that contains
               only one row by a number of attach operators (one for each
               tuple). */
            if (L(p)->sem.lit_tbl.count == 1) {
                PFla_op_t *ret = R(p);
                for (unsigned int i = 0; i < L(p)->schema.count; i++)
                    ret = PFla_attach (ret, L(p)->schema.items[i].name,
                                       L(p)->sem.lit_tbl.tuples[0].atoms[i]);
                *p = *(ret);
                break;
            } 

        /* Rel:    project (Rel) */
        case 10:
        {   /**
             * we can skip every project operator that is not needed.
             * Therefore it has to fulfill two conditions:
             * 1. no column is renamed
             * 2. the number of columns does not change
             * (The first condition also ensures that no
             *  column is referenced twice thus allowing us to 
             *  avoid a 1:1 column check.)
             */
            bool renamed = false;
            
            for (unsigned int i = 0; i < p->schema.count; i++)
                renamed = renamed ||
                          (p->sem.proj.items[i].new !=
                           p->sem.proj.items[i].old);

            if (!renamed && L(p)->schema.count == p->schema.count) {
                *p = *PFla_dummy (L(p));
                break;
            }
        }   break;

        /* Rel:    project (attach (Rel)) */
        case 11:
            /* only rewrite if there are more than one columns */
            if (p->schema.count > 1) {
                bool found = false, rewrite = true;
                for (unsigned int i = 0; i < p->schema.count; i++)
                    if (p->sem.proj.items[i].old == L(p)->sem.attach.attname) {
                        found = true;
                        rewrite = rewrite &&
                                  (p->sem.proj.items[i].old 
                                   == p->sem.proj.items[i].new);
                    }
                    
                /* if the projection neither discards nor renames
                   the attach result we can switch both operands  */
                if (found && rewrite) {
                    PFalg_proj_t *proj = PFmalloc ((p->schema.count - 1) *
                                                   sizeof (PFalg_proj_t));
                    unsigned int count = 0;
                    
                    for (unsigned int j = 0; j < p->schema.count; j++)
                        if (L(p)->sem.attach.attname
                            != p->sem.proj.items[j].old)
                            proj[count++] = p->sem.proj.items[j];

                    *p = *PFla_attach (PFla_project_ (LL(p), count, proj),
                                       L(p)->sem.attach.attname,
                                       L(p)->sem.attach.value);
                    SEEN(L(p)) = false;
                    SEEN(p) = false;
                    relabel (p, kids);
                    break;
                }
            }
            break;
            
        /* Rel:    project (project (Rel)) */
        case 13:
        {   /* combine two projections */            
            PFalg_proj_t *proj = PFmalloc (p->schema.count *
	                                       sizeof (PFalg_proj_t));

            unsigned int i, j, count = 0;
            for (i = 0; i < p->schema.count; i++)
                for (j = 0; j < L(p)->schema.count; j++)
                    if (p->sem.proj.items[i].old ==
                        L(p)->sem.proj.items[j].new) {
                        proj[count++] = PFalg_proj (
                                            p->sem.proj.items[i].new,
                                            L(p)->sem.proj.items[j].old);
                        break;
                    }

            /* ensure that at least one column remains! */
            if (!count)
                for (j = 0; j < L(p)->schema.count; j++)
                    if (p->sem.proj.items[0].old ==
                        L(p)->sem.proj.items[j].new) {
                        proj[count++] = PFalg_proj (
                                            p->sem.proj.items[0].new,
                                            L(p)->sem.proj.items[j].old);
                        break;
                    }

            *p = *PFla_project_ (L(L(p)), count, proj);

            SEEN(p) = false;
            relabel (p, kids);
        } break;

        /* Rel:    select_ (Rel) */
        case 19:
        {
            /**
             *  introduce thetajoin based on 
             *  one of the following patterns:
             *    
             *    sel (res)    sel (res)   sel (res)   sel (res)
             *     |            |           |           |
             *   eq,gt       project      eq,gt      project
             *     |            |           |           |
             *     X          eq,gt      project      eq,gt 
             *    / \           |           |           |
               rel1 rel2     project        X           X
             *                  |          / \         / \   
             *                  X       rel1 rel2   rel1 rel2
             *                 / \
             *              rel1 rel2
             *    
             * The result will be either:
             *    
             *     @ (res, true)
             *     |
             *    |X| (eq|gt, rel.att1, rel.att2)
             *    / \
             * rel1 rel2
             *    
             * or:
             *    
             *     @ (res, true)
             *     |
             *  project
             *     |
             *    |X| (eq|gt, rel.att1, rel.att2)
             *    / \
             * rel1 rel2
             *   
             */
            PFla_op_t *node;
            PFla_op_t *left = NULL;
            PFla_op_t *right = NULL;
            PFla_op_t *proj = NULL;
            PFla_op_t *proj2 = NULL;

            PFalg_att_t sel = p->sem.select.att;
            PFalg_att_t item1, item2;
            unsigned int i;

            node = L(p);

            if (node->kind == la_project) {
                proj = node;
                /* update the name of the selection */
                for (i = 0; i < node->sem.proj.count; i++)
                    if (sel == node->sem.proj.items[i].new) {
                        sel = node->sem.proj.items[i].old;
                        break;
                    }
                node = L(node);
            }
            
            /* the selection column has to match the
               result column of the comparison operator */
            if (node->kind != la_num_eq ||
                node->sem.binary.res != sel)
                break;

            item1 = node->sem.binary.att1;
            item2 = node->sem.binary.att2;
            node = L(node);

            if (node->kind == la_project) {
                proj2 = node;
                /* update the names of the comparison input */
                for (i = 0; i < node->sem.proj.count; i++) {
                    if (item1 == node->sem.proj.items[i].new)
                        item1 = node->sem.proj.items[i].old;
                    if (item2 == node->sem.proj.items[i].new)
                        item2 = node->sem.proj.items[i].old;
                }
                node = L(node);
            }

            /* match the pattern */
            if (node->kind != la_cross)
                break;

            /* lookup the corresponding subtrees for the
               comparison inputs */
            for (i = 0; i < L(node)->schema.count; i++)
                if (L(node)->schema.items[i].name == item1)
                    left = L(node);
                else if (L(node)->schema.items[i].name == item2)
                    right = L(node);

            for (i = 0; i < R(node)->schema.count; i++)
                if (R(node)->schema.items[i].name == item1)
                    left = R(node);
                else if (R(node)->schema.items[i].name == item2)
                    right = R(node);

            /* the two comparison inputs are from the same relation
               -- multi-value dependency analysis will thus move the
               cross product up */
            if (!left || !right || left == right)
                break;

            /* Now all constraints are checked and the pattern 
               can be replaced by an theta-join and an attach operator
               that adds the missing res column */
            if (!proj && !proj2) {
                *p = *PFla_attach (
                          PFla_eqjoin (left, right, item1, item2),
                          p->sem.select.att, PFalg_lit_bln (true));
                SEEN(p) = false;
                SEEN(L(p)) = false;
                relabel (p, kids);
                break;
            } else {
                /* if at least one projection was in between we
                   have to apply the projection between theta-join
                   and attach operator */
                PFalg_proj_t *proj_list;
                unsigned int j, count = 0;
                
                /* create projection list */
                proj_list = PFmalloc ((p->schema.count - 1)*
                                      sizeof (*(proj_list)));
                
                for (i = 0; i < p->schema.count; i++) {
                    /* use current schema as starting point
                       (discarding the result column of the comparison) */
                    if (p->schema.items[i].name != p->sem.select.att)
                        proj_list[count] = PFalg_proj (
                                               p->schema.items[i].name,
                                               p->schema.items[i].name);

                    /* apply the renaming of the first projection */
                    if (proj)
                        for (j = 0; j < proj->sem.proj.count; j++)
                            if (proj->sem.proj.items[j].new ==
                                proj_list[count].old)
                                proj_list[count].old
                                    = proj->sem.proj.items[j].old;

                    /* apply the renaming of the second projection */
                    if (proj2)
                        for (j = 0; j < proj2->sem.proj.count; j++)
                            if (proj2->sem.proj.items[j].new ==
                                proj_list[count].old)
                                proj_list[count].old
                                    = proj2->sem.proj.items[j].old;
                    
                    /* increase the counter analogously */
                    if (p->schema.items[i].name != p->sem.select.att)
                        count++;
                }
                                                   
                *p = *PFla_attach (
                          PFla_project_ (
                              PFla_eqjoin (left, right, item1, item2),
                              p->schema.count - 1, proj_list),
                          p->sem.select.att, PFalg_lit_bln (true));
                SEEN(p) = false;
                SEEN(L(p)) = false;
                SEEN(LL(p)) = false;
                relabel (p, kids);
                break;
            }
        }   break;

        /* Rel:    disjunion (EmptyRel, Rel) */
        case 21:
            /* return right child */
            *p = *PFla_dummy (R(p));
            break;

        /* Rel:    disjunion (Rel, EmptyRel) */
        case 22:
        /* Rel:    difference (Rel, EmptyRel) */
        case 25:
            /* return left child */
            *p = *PFla_dummy (L(p));
            break;

        /* Rel:    distinct (Rel) */
        case 26:
        /* Remove unnecessary nested distinct operations.
           Because of the many versions of this pattern
           we do not check it with burg. */
        {
            PFla_op_t *proj = NULL, *lp = NULL, *rp = NULL,
                      *op, *res = NULL;
            PFalg_att_t latt, ratt;                

            op = L(p);
            if (op->kind == la_project) {
                proj = op;
                op = L(op);
            }
            if (op->kind == la_distinct)
                res = L(op);
            else if (op->kind == la_eqjoin) {
                if (L(op)->kind == la_distinct &&
                    L(op)->schema.count == 1) {
                    rp = LL(op);
                    lp = R(op);
                    latt = op->sem.eqjoin.att2;
                    ratt = op->sem.eqjoin.att1;
                }
                else if (L(op)->kind == la_project &&
                    LL(op)->kind == la_distinct &&
                    LL(op)->schema.count == 1 &&
                    L(op)->schema.count == 1) {
                    rp = PFla_project_ (LLL(op), 1, L(op)->sem.proj.items);
                    SEEN(rp) = false;
                    lp = R(op);
                    latt = op->sem.eqjoin.att2;
                    ratt = op->sem.eqjoin.att1;
                }
                else if (R(op)->kind == la_distinct &&
                    R(op)->schema.count == 1) {
                    rp = RL(op);
                    lp = L(op);
                    latt = op->sem.eqjoin.att1;
                    ratt = op->sem.eqjoin.att2;
                }
                else if (R(op)->kind == la_project &&
                    RL(op)->kind == la_distinct &&
                    RL(op)->schema.count == 1 &&
                    R(op)->schema.count == 1) {
                    rp = PFla_project_ (RLL(op), 1, R(op)->sem.proj.items);
                    SEEN(rp) = false;
                    lp = L(op);
                    latt = op->sem.eqjoin.att1;
                    ratt = op->sem.eqjoin.att2;
                }
                
                if (lp) {
                    res = PFla_eqjoin (lp, rp, latt, ratt);
                    SEEN(res) = false;
                }
            }
                
            if (res) {
                if (proj) {
                    res = PFla_project_ (res, 
                                         proj->sem.proj.count,
                                         proj->sem.proj.items);
                    SEEN(res) = false;
                }
            
                *p = *PFla_distinct (res);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
        } break;

        /* Rel:    distinct (scjoin (Frag, Rel)) */
        case 27:
            /* return left child */
            *p = *PFla_dummy (L(p));
            break;

        /* Rel:    rownum (Rel) */
        case 50:
            /* replace rownum by projection if it only contains one
               sort (and no partioning) criterion that is of type nat */ 
            if (!p->sem.rownum.part &&
                p->sem.rownum.sortby.count == 1)
                for (unsigned int i = 0; i < p->schema.count; i++) {
                    PFalg_att_t cur_col = p->schema.items[i].name;
                    
                    if (cur_col == p->sem.rownum.sortby.atts[0] &&
                        p->schema.items[i].type == aat_nat) {
                        PFalg_proj_t *proj = PFmalloc (
                                                 p->schema.count
                                                 * sizeof (PFalg_proj_t));
                        /* copy property list */
                        for (i = 0; i < p->schema.count; i++)
                            if (p->sem.rownum.attname ==
                                p->schema.items[i].name)
                                /* as rownum column we use the single
                                   sort criterion */
                                proj[i] = PFalg_proj (p->sem.number.attname,
                                                      cur_col);
                            else
                                proj[i] = PFalg_proj (p->schema.items[i].name,
                                                      p->schema.items[i].name);
                                                      
                        *p = *PFla_project_ (L(p), p->schema.count, proj);
                        SEEN(p) = false;
                        relabel (p, kids);
                        break;
                    }
                }
            break;

        /* Rel:    number (number (Rel)) */
        case 52:
            if (! p->sem.number.part && 
                ! L(p)->sem.number.part) {
                PFalg_proj_t *proj = PFmalloc (
                                         p->schema.count
                                         * sizeof (PFalg_proj_t));
                /* copy property list */
                for (unsigned int i = 0; i < p->schema.count; i++)
                    if (p->sem.number.attname == p->schema.items[i].name)
                        proj[i] = PFalg_proj (p->sem.number.attname,
                                              L(p)->sem.number.attname);
                    else
                        proj[i] = PFalg_proj (p->schema.items[i].name,
                                              p->schema.items[i].name);
                                              
                *p = *PFla_project_ (L(p), p->schema.count, proj);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
            break;

        /* Rel:    number (project (number (Rel))) */
        case 53:
            if (! p->sem.number.part && 
                ! LL(p)->sem.number.part) {
                unsigned int count = L(p)->sem.proj.count;
                PFalg_proj_t *proj = PFmalloc (
                                         (count + 1)
                                         * sizeof (PFalg_proj_t));
                /* copy property list */
                for (unsigned int i = 0; i < count; i++)
                    proj[i] = L(p)->sem.proj.items[i];

                proj[count] = PFalg_proj (p->sem.number.attname,
                                          LL(p)->sem.number.attname);

                *p = *PFla_project_ (LL(p), count + 1, proj);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
            break;

        /* Rel:    cast (cast (Rel)) */
        case 56:
        /* Rel:    cast (project (cast (Rel))) */
        case 57:
            /* Discard the casts if the cast maps from string
               to untypedAtomic and back to string. */
        {
            PFla_op_t *cast;
            bool proj = false, found = false;
            unsigned int i;
            PFalg_att_t att = p->sem.type.att;
            
            /* check for a projection in between and update
               the name of the outer cast input */
            if (L(p)->kind == la_project) {
                proj = true;
                for (i = 0; i < L(p)->sem.proj.count; i++)
                    if (att == L(p)->sem.proj.items[i].new) {
                        att = L(p)->sem.proj.items[i].old;
                        break;
                    }
                cast = LL(p);
            }
            else
                cast = L(p);

            /* make sure the input of the first cast 
               is of type string */
            for (i = 0; i < cast->schema.count; i++)
                if (cast->schema.items[i].name == cast->sem.type.att &&
                    cast->schema.items[i].type == aat_str) {
                    found = true;
                    break;
                }
            
            /* enforce the constraints: child node is a cast,
               the output of the nested cast and the input of
               the outer cast match, the inner cast applies a
               cast to untypedAtomic, and the outer to string */
            if (found &&
                att == cast->sem.type.res &&
                cast->sem.type.ty == aat_uA &&
                p->sem.type.ty == aat_str) {
            
                PFalg_proj_t *proj_list;
                /* create projection list */
                proj_list = PFmalloc (p->schema.count *
                                      sizeof (*(proj_list)));
                                      
                if (proj) {
                    /* if there was already a projection keep that
                       one and extend it with the result column of the
                       outer cast that refers to the orginal input column */
                    for (i = 0; i < L(p)->sem.proj.count; i++)
                        proj_list[i] = L(p)->sem.proj.items[i];
                        
                    proj_list[i] = PFalg_proj (p->sem.type.res,
                                               cast->sem.type.att);
                }
                else
                    /* keep all column and link the result column of the
                       outer cast to the input column of the nested cast */
                    for (i = 0; i < p->schema.count; i++)
                        if (p->schema.items[i].name == p->sem.type.res)
                            proj_list[i] = PFalg_proj (p->sem.type.res,
                                                       cast->sem.type.att);
                        else
                            proj_list[i] = PFalg_proj (p->schema.items[i].name,
                                                       p->schema.items[i].name);
                                                       
                /* Replace the outer cast (and the project) by a new project
                   that avoids the unnecessary casts. (The second cast will
                   be removed by an icols optimization phase.) */
                *p = *PFla_project_ (cast, p->schema.count, proj_list);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
        } /* fall trough otherwise */
                
        /* Rel:    cast (Rel) */
        case 58:
        {
            /*
             * If an algebra expression already has the requested
             * type, replace it by a projection.
             */
            bool cast_req = true;
            for (unsigned int i = 0; i < p->schema.count; i++)
                if (p->sem.type.att == p->schema.items[i].name &&
                    p->sem.type.ty == p->schema.items[i].type) {
                    cast_req = false;
                    break;
                }

            if (!cast_req) { 
                PFalg_proj_t *proj = PFmalloc (p->schema.count
                                               * sizeof (PFalg_proj_t));

                for (unsigned int j = 0; j < p->schema.count; j++)
                    if (p->schema.items[j].name != p->sem.type.res) {
                        proj[j] = PFalg_proj (p->schema.items[j].name,
                                              p->schema.items[j].name);
                    } else {
                        proj[j] = PFalg_proj (p->sem.type.res,
                                              p->sem.type.att);
                    }

                *p = *PFla_project_ (L(p), p->schema.count, proj);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
        } break;

        /* ScjRel: scjoin (Frag, ScjRel) */
        case 63:
            /* combine scjoins if they are of the form:
               ``/descandent-or-self::node()/child::element()'' */
            if (R(p)->sem.scjoin.axis == alg_desc_s &&
                PFty_equality (R(p)->sem.scjoin.ty, PFty_xs_anyNode ()) &&
                p->sem.scjoin.axis == alg_chld) {
                /* rewrite child into descendant
                   and discard descendant-or-self step */
                *p = *PFla_scjoin (L(p), RR(p), alg_desc, p->sem.scjoin.ty,
                                   p->sem.scjoin.iter, R(p)->sem.scjoin.item,
                                   p->sem.scjoin.item_res);
                SEEN(p) = false;
                relabel (p, kids);
                break;
            }
            break;

        /* ScjRel: scjoin (Frag, distinct (Rel)) */
        case 64:
            R(p) = L(R(p));
            SEEN(p) = false;
            relabel (p, kids);
            break;

        /* Rel:    EmptyRel */
        case 90:
        {
            /*
             * Replace any sub-tree that we determined empty with these
             * rules by the literal empty table.
             */
            *p = *PFla_empty_tbl_ (p->schema);
            SEEN(p) = true;
            relabel (p, kids);
        } break;

        /* every occurrence of EmptyRel already copes with
           the empty relation - we therefore do not rewrite
           any of the below rules (they are pruned anyway) */

        /* EmptyRel:    empty_tbl */
        case 120:
        /* EmptyRel:    attach (EmptyRel) */
        case 121:
        /* EmptyRel:    cross (EmptyRel, Rel) */
        case 122:
        /* EmptyRel:    cross (Rel, EmptyRel) */
        case 123:
        /* EmptyRel:    eqjoin (EmptyRel, Rel) */
        case 124:
        /* EmptyRel:    eqjoin (Rel, EmptyRel) */
        case 125:
        /* EmptyRel:    project (EmptyRel) */
        case 126:
        /* EmptyRel:    select_ (EmptyRel) */
        case 127:
        /* EmptyRel:    disjunion (EmptyRel, EmptyRel) */
        case 130:
        /* EmptyRel:    intersect (EmptyRel, Rel) */
        case 131:
        /* EmptyRel:    intersect (Rel, EmptyRel) */
        case 132:
        /* EmptyRel:    difference (EmptyRel, Rel) */
        case 133:
        /* EmptyRel:    distinct (EmptyRel) */
        case 134:
        /* EmptyRel:    num_add (EmptyRel) */
        case 140:
        /* EmptyRel:    num_subtract (EmptyRel) */
        case 141:
        /* EmptyRel:    num_multiply (EmptyRel) */
        case 142:
        /* EmptyRel:    num_divide (EmptyRel) */
        case 143:
        /* EmptyRel:    num_modulo (EmptyRel) */
        case 144:
        /* EmptyRel:    num_neg (EmptyRel) */
        case 145:
        /* EmptyRel:    num_gt (EmptyRel) */
        case 146:
        /* EmptyRel:    num_eq (EmptyRel) */
        case 147:
        /* EmptyRel:    bool_and (EmptyRel) */
        case 148:
        /* EmptyRel:    bool_or (EmptyRel) */
        case 149:
        /* EmptyRel:    bool_not (EmptyRel) */
        case 150:
        /* EmptyRel:    avg (EmptyRel) */
        case 151:
        /* EmptyRel:    max_ (EmptyRel) */
        case 152:
        /* EmptyRel:    min_ (EmptyRel) */
        case 153:
        /* EmptyRel:    sum (EmptyRel) */
        case 154:
        /* EmptyRel:    count (EmptyRel) */
        case 155:
        /* EmptyRel:    rownum (EmptyRel) */
        case 160:
        /* EmptyRel:    number (EmptyRel) */
        case 161:
        /* EmptyRel:    type (EmptyRel) */
        case 162:
        /* EmptyRel:    type_assert (EmptyRel) */
        case 163:
        /* EmptyRel:    cast (EmptyRel) */
        case 164:
        /* EmptyRel:    seqty1 (EmptyRel) */
        case 165:
        /* EmptyRel:    all (EmptyRel) */
        case 166:
        /* EmptyRel:    scjoin (Frag, EmptyRel) */
        case 170:
        /* EmptyRel:    doc_access (Frag, EmptyRel) */
        case 171:
        /* EmptyRel:    roots_ (element (Frag, element_tag (EmptyRel, Rel))) */
        case 180:
        /* EmptyRel:    roots_ (attribute (EmptyRel)) */
        case 182:
        /* EmptyRel:    roots_ (textnode (EmptyRel)) */
        case 184:
        /* EmptyRel:    roots_ (comment (EmptyRel)) */
        case 185:
        /* EmptyRel:    roots_ (processi (EmptyRel)) */
        case 186:
        /* EmptyRel:    roots_ (merge_adjacent (Frag, EmptyRel)) */
        case 187:
        /* EmptyRel:    cond_err (EmptyRel, Rel) */
        case 190:
        /* EmptyRel:    concat (EmptyRel) */
        case 200:
        /* EmptyRel:    string_join (EmptyRel, Rel) */
        case 201:
            break;

        default:
            break;
    }

    /* if we introduced a structural change the state labels
       will differ (before != after). Therefore the caller will
       start matching once more */
    return old_state_label != STATE_LABEL(p);
}

/* mark all nodes in the pattern of node p as seen 
   if it is not contained in kids. */
static void
mark_pattern_SEEN (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    for (i = 0; i < PFLA_OP_MAXCHILD; i++)
        if (p->child[i])
            mark_pattern_SEEN (p->child[i], kids);
 
    SEEN (p) = true;
}

/**
 * Check label of pattern rooted in p. 
 * (Every change in the state labels is reported)
 */
static bool
changed_label (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int i;
    bool res = false;

    for (i = 0; i < MAX_KIDS; i++)
        if (kids[i] && p == kids[i])
            return false;

    for (i = 0; i < PFLA_OP_MAXCHILD; i++)
        if (p->child[i])
            res = res ||
                  CHILD_STATE_LABEL(p, i) != STATE_LABEL(p->child[i]) ||
                  changed_label (p->child[i], kids);
    return res;
}

/* Relabel node p if it is not contained in kids. */
static void
relabel (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i] && STATE_LABEL(p))
            return;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        relabel (L(p), kids);
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
    }
    else if (!L(p) && R(p)) {
        relabel (R(p), kids);
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    else {
        relabel (L(p), kids);
        relabel (R(p), kids);
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }

    assert (STATE_LABEL (p));
}

/* Attach node labels in a DAG walk bottom-up */
static void
label (PFla_op_t *p)
{
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        if (!SEEN(L(p))) label (L(p));
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
    }
    else if (!L(p) && R(p)) {
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    else {
        if (!SEEN(L(p))) label (L(p));
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFopt_general_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    SEEN(p) = true;

    assert (STATE_LABEL (p));
}

/**
 * Invoke algebra optimization.
 */
PFla_op_t *
PFalgopt_general (PFla_op_t *root)
{
    /* Attach node labels in a DAG walk bottom-up */
    label (root);
    PFla_dag_reset (root);

    /* Optimize algebra tree */
    while (reduce (root, 1));
    PFla_dag_reset (root);

    return root;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
