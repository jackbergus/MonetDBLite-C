%{

/**
 * @file
 *
 * Optimize relational algebra expression tree.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2005 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */

/* always include pathfinder.h first! */
#include "pathfinder.h"
#include "oops.h"         /* PFoops() */
#include "algebra.h"
#include "algopt.h"
#include "mem.h"          /* PFmalloc() */

#include "properties.h"

#include <assert.h>
#include <stdio.h>

/*
 * Accessors for the burg matcher
 */
typedef struct PFla_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p) ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/algebra.h!
 */
%term  serialize      =   1
%term  lit_tbl        =   2
%term  empty_tbl      =   3
%term  cross          =   4
%term  eqjoin         =   5
%term  project        =   6
%term  select_        =   7
%term  disjunion      =   8
%term  intersect      =   9
%term  difference     =  10
%term  distinct       =  11
%term  num_add        =  20
%term  num_subtract   =  21
%term  num_multiply   =  22
%term  num_divide     =  23
%term  num_modulo     =  24
%term  num_eq         =  25
%term  num_gt         =  26
%term  num_neg        =  27
%term  bool_and       =  28
%term  bool_or        =  29
%term  bool_not       =  30
%term  sum            =  31
%term  count          =  32
%term  rownum         =  35
%term  number         =  36
%term  type           =  40
%term  type_assert    =  41
%term  cast           =  42
%term  seqty1         =  43
%term  all            =  44
%term  scjoin         =  50
%term  doc_tbl        =  51
%term  doc_access     =  52
%term  element        =  60
%term  element_tag    =  61
%term  attribute      =  62
%term  textnode       =  63
%term  docnode        =  64
%term  comment        =  65
%term  processi       =  66
%term  merge_adjacent =  67
%term  roots_         =  70
%term  fragment       =  71
%term  frag_union     =  72
%term  empty_frag     =  73
%term  cond_err       =  80
%term  concat         = 100
%term  string_join    = 101

%%

Query:  serialize (Frag, Rel)                     =   1 (10);

Rel:    lit_tbl                                   =   2 (10);
Rel:    cross (Rel, Rel)                          =   3 (10);
Rel:    eqjoin (Rel, Rel)                         =   4 (10);
Rel:    project (Rel)                             =  10 (10);
Rel:    project (                                            
            rownum (                                         
                disjunion (                                  
                    cross (lit_tbl,                          
                           cross (Rel,                       
                                  lit_tbl)),                 
                    cross (lit_tbl,                          
                           cross(Rel,                        
                                 lit_tbl)))))     =  11 (40);
Rel:    project (project (Rel))                   =  13  (1);
Rel:    project (distinct (Rel))                  =  14 (10);
Rel:    project (scjoin (Frag, Rel))              =  15 (10);
Rel:    select_ (Rel)                             =  19 (10);
Rel:    disjunion (Rel, Rel)                      =  20 (10);
Rel:    disjunion (EmptyRel, Rel)                 =  21  (5);
Rel:    disjunion (Rel, EmptyRel)                 =  22  (5);
Rel:    intersect (Rel, Rel)                      =  23 (10);
Rel:    difference (Rel, Rel)                     =  24 (10);
Rel:    difference (Rel, EmptyRel)                =  25  (5);
Rel:    distinct (Rel)                            =  26 (10);
Rel:    num_add (Rel)                             =  30 (10);
Rel:    num_subtract (Rel)                        =  31 (10);
Rel:    num_multiply (Rel)                        =  32 (10);
Rel:    num_divide (Rel)                          =  33 (10);
Rel:    num_modulo (Rel)                          =  34 (10);
Rel:    num_neg (Rel)                             =  35 (10);
Rel:    num_gt (Rel)                              =  36 (10);
Rel:    num_eq (Rel)                              =  37 (10);
Rel:    bool_and (Rel)                            =  38 (10);
Rel:    bool_or (Rel)                             =  39 (10);
Rel:    bool_not (Rel)                            =  40 (10);
Rel:    sum (Rel)                                 =  41 (10);
Rel:    count (Rel)                               =  42 (10);
Rel:    rownum (Rel)                              =  50 (10);
Rel:    number (Rel)                              =  51 (10);
Rel:    number (rownum (Rel))                     =  52 (10);
Rel:    type (Rel)                                =  53 (10);
Rel:    type_assert (Rel)                         =  54 (10);
Rel:    cast (Rel)                                =  55 (10);
Rel:    seqty1 (Rel)                              =  56 (10);
Rel:    all (Rel)                                 =  57 (10);
Rel:    scjoin (Frag, Rel)                        =  60 (10);
Rel:    scjoin (Frag, distinct (Rel))             =  61 (10);
Rel:    doc_access (Frag, Rel)                    =  62 (10);
Rel:    element_tag (Rel, Rel)                    =  63 (10);
Rel:    element_tag (Rel, EmptyRel)               =  64 (5); 
Rel:    roots_ (FragRel)                          =  65 (10);
Rel:    cond_err (Rel, Rel)                       =  70 (10);
Rel:    concat (Rel)                              =  80 (10);
Rel:    string_join (Rel, Rel)                    =  81 (10);

Rel:    EmptyRel                                  =  90  (0);


FragRel:    doc_tbl (Rel)                         = 100 (10);
FragRel:    element (Frag, Rel)                   = 101 (10);
FragRel:    attribute (Rel, Rel)                  = 102 (10);
FragRel:    textnode (Rel)                        = 103 (10);
FragRel:    docnode (Frag, Rel)                   = 104 (10);
FragRel:    comment (Rel)                         = 105 (10);
FragRel:    processi (Rel)                        = 106 (10);
FragRel:    merge_adjacent (Frag, Rel)            = 107 (10);


Frag:    fragment (FragRel)                       = 110 (10);
Frag:    frag_union (Frag, Frag)                  = 111 (10);
Frag:    frag_union (empty_frag, empty_frag)      = 112 (10);
Frag:    empty_frag                               = 113 (10);


EmptyRel:    empty_tbl                            = 120  (0);

EmptyRel:    cross (EmptyRel, Rel)                = 121  (0);
EmptyRel:    cross (Rel, EmptyRel)                = 122  (0);
EmptyRel:    eqjoin (EmptyRel, Rel)               = 123  (0);
EmptyRel:    eqjoin (Rel, EmptyRel)               = 124  (0);
EmptyRel:    project (EmptyRel)                   = 125  (0);
EmptyRel:    select_ (EmptyRel)                   = 126  (0);
EmptyRel:    disjunion (EmptyRel, EmptyRel)       = 130  (0);
EmptyRel:    intersect (EmptyRel, Rel)            = 131  (0);
EmptyRel:    intersect (Rel, EmptyRel)            = 132  (0);
EmptyRel:    difference (EmptyRel, Rel)           = 133  (0);
EmptyRel:    distinct (EmptyRel)                  = 134  (0);
EmptyRel:    num_add (EmptyRel)                   = 140  (0);
EmptyRel:    num_subtract (EmptyRel)              = 141  (0);
EmptyRel:    num_multiply (EmptyRel)              = 142  (0);
EmptyRel:    num_divide (EmptyRel)                = 143  (0);
EmptyRel:    num_modulo (EmptyRel)                = 144  (0);
EmptyRel:    num_neg (EmptyRel)                   = 145  (0);
EmptyRel:    num_gt (EmptyRel)                    = 146  (0);
EmptyRel:    num_eq (EmptyRel)                    = 147  (0);
EmptyRel:    bool_and (EmptyRel)                  = 148  (0);
EmptyRel:    bool_or (EmptyRel)                   = 149  (0);
EmptyRel:    bool_not (EmptyRel)                  = 150  (0);
EmptyRel:    sum (EmptyRel)                       = 151  (0);
EmptyRel:    count (EmptyRel)                     = 152  (0);
EmptyRel:    rownum (EmptyRel)                    = 160  (0);
EmptyRel:    number (EmptyRel)                    = 161  (0);
EmptyRel:    type (EmptyRel)                      = 162  (0);
EmptyRel:    type_assert (EmptyRel)               = 163  (0);
EmptyRel:    cast (EmptyRel)                      = 164  (0);
EmptyRel:    seqty1 (EmptyRel)                    = 165  (0);
EmptyRel:    all (EmptyRel)                       = 166  (0);
EmptyRel:    scjoin (Frag, EmptyRel)              = 170  (0);
EmptyRel:    doc_access (Frag, EmptyRel)          = 171  (0);
EmptyRel:    roots_ (element (Frag, EmptyRel))    = 180  (0);
EmptyRel:    element_tag (EmptyRel, Rel)          = 181  (0);
EmptyRel:    roots_ (attribute (EmptyRel, Rel))   = 182  (0);
EmptyRel:    roots_ (attribute (Rel, EmptyRel))   = 183  (0);
EmptyRel:    roots_ (textnode (EmptyRel))         = 184  (0);
EmptyRel:    roots_ (comment (EmptyRel))          = 185  (0);
EmptyRel:    roots_ (processi (EmptyRel))         = 186  (0);
EmptyRel:    roots_ (merge_adjacent (Frag,                   
                                     EmptyRel))   = 187  (0);
EmptyRel:    cond_err (EmptyRel, Rel)             = 190  (0);
EmptyRel:    concat (EmptyRel)                    = 200 (10);
EmptyRel:    string_join (EmptyRel, Rel)          = 201 (10);

%%

#include "algebra_mnemonic.h"

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
#define LRL(p) L(R(L(p)))
#define LRR(p) R(R(L(p)))
#define RRL(p) L(R(R(p)))
#define RRR(p) R(R(R(p)))

#define MAX_KIDS 10

/* Relabel node p if it is not contained in kids. */
static void relabel (PFla_op_t *p,  PFla_op_t **kids);

/*
 * Check whether the second input projection list @a p1 is contained
 * in the first projection list @a p2. @a n1 and @a n2 are the number
 * of projection items in both lists, respecitvely.
 */
static bool contains_projlist (PFalg_proj_t *p1, int n1,
                               PFalg_proj_t *p2, int n2);

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFla_op_t *p, int goalnt)
{
    int              rule;       /* rule number that matches for this node */
    short           *nts;        /* target non-terminals for the leaf nodes of
                                    the current rule */
    PFla_op_t       *kids[MAX_KIDS];   /* leaf nodes of this rule */
    bool             rewritten = false;

    short            old_state_label;
    unsigned short   i;

    do {
        /* determine rule that matches for this non-terminal */
        rule = PFalgopt_rule (STATE_LABEL (p), goalnt);

        assert (rule);

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFalgopt_nts[rule];
        PFalgopt_kids (p, rule, kids);


        rewritten = false;
        /*
         * prune already optimized branch of the tree
         * (we try to treat the tree plan as DAG)
         */
        if (!p->opt)
            /* recursively translate all leaf expressions */
            for (i = 0; nts[i]; i++)
                if ((rewritten = reduce (kids[i], nts[i])))
                    break;  /* abort if a subtree was rewritten */

        if (rewritten) {

            /*
             * If a subtree has been rewritten, we have to
             *  - re-label that part of the tree, and
             *  - possibly propagate the `rewritten' information upwards.
             */

            /* remember our old state_label (so we know if it has changed) */
            old_state_label = STATE_LABEL(p);

            /*
             * Re-label current tree pattern.
             * (at most down to the pattern leaves, as they should already be
             * correctly labeled by the above reduce() call)
             */
            relabel (p, kids);

            /* If our own state_label has changed, notify our caller. */
            if (old_state_label != STATE_LABEL(p))
                return true;
        }
    } while (rewritten);


    switch (rule) {

        /* Rel:    project (                                      
                       rownum (                                   
                           disjunion (                            
                               cross (lit_tbl,                    
                                      cross (Rel,                 
                                             lit_tbl)),           
                               cross (lit_tbl,                    
                                      cross(Rel,                  
                                            lit_tbl))))) */
        case 11:
            /* concatenate tuples of base relations instead
               of applying a more expensive sequence construction */

            if (/* project (iter,pos:pos1,item) */
                p->schema.count == 3 &&
                p->sem.proj.items[0].old == att_iter &&
                p->sem.proj.items[0].new == att_iter &&
                p->sem.proj.items[1].old == att_pos1 &&
                p->sem.proj.items[1].new == att_pos &&
                p->sem.proj.items[2].old == att_item &&
                p->sem.proj.items[2].new == att_item &&
                /* row_num (pos1:<ord,pos>/iter) */ 
                L(p)->sem.rownum.attname == att_pos1 &&
                L(p)->sem.rownum.part ==    att_iter &&
                L(p)->sem.rownum.sortby.count == 2 &&
                L(p)->sem.rownum.sortby.atts[0] == att_ord &&
                L(p)->sem.rownum.sortby.atts[1] == att_pos &&
                /*
                                              ord
                  compare with base relation: --- 
                                               1
                */ 
                LL(LL(p))->sem.lit_tbl.count == 1 &&
                LL(LL(p))->schema.count == 1 &&
                LL(LL(p))->schema.items[0].name == att_ord &&
                LL(LL(p))->sem.lit_tbl.tuples[0].count == 1 &&
                LL(LL(p))->sem.lit_tbl.tuples[0].atoms[0].type == aat_nat &&
                LL(LL(p))->sem.lit_tbl.tuples[0].atoms[0].val.nat == 1 &&
                /*
                                              ord
                  compare with base relation: --- 
                                               2
                */ 
                RL(LL(p))->sem.lit_tbl.count == 1 &&
                RL(LL(p))->schema.count == 1 &&
                RL(LL(p))->schema.items[0].name == att_ord &&
                RL(LL(p))->sem.lit_tbl.tuples[0].count == 1 &&
                RL(LL(p))->sem.lit_tbl.tuples[0].atoms[0].type == aat_nat &&
                RL(LL(p))->sem.lit_tbl.tuples[0].atoms[0].val.nat == 2 &&
                /* compare loop relations */
                LRL(LL(p)) == RRL(LL(p)) &&
                /* ckeck schema of literal table */
                LRR(LL(p))->schema.count == 2 &&
                LRR(LL(p))->schema.items[0].name == att_pos &&
                LRR(LL(p))->schema.items[1].name == att_item &&
                /* ckeck schema of literal table */
                RRR(LL(p))->schema.count == 2 &&
                RRR(LL(p))->schema.items[0].name == att_pos &&
                RRR(LL(p))->schema.items[1].name == att_item)
            {
                unsigned int i, j;
                PFla_op_t *ret;
                PFalg_tuple_t *tuples 
                                = PFmalloc ((LRR(LL(p))->sem.lit_tbl.count +
                                             RRR(LL(p))->sem.lit_tbl.count) *
                                            sizeof (PFalg_tuple_t));
                /* copy tuples of first literal table */
                for (i = 0; i < LRR(LL(p))->sem.lit_tbl.count; i++)
                {
                    tuples[i] = LRR(LL(p))->sem.lit_tbl.tuples[i];
                    /* set new position value (starting from 1) */
                    tuples[i].atoms[0].val.nat = i + 1; 
                }
                /* copy tuples of second literal table */
                for (j = 0; j < RRR(LL(p))->sem.lit_tbl.count; j++)
                {
                    tuples[i+j] = RRR(LL(p))->sem.lit_tbl.tuples[j];
                    /* set new position value 
                       (starting from next free position: i+1) */
                    tuples[i+j].atoms[0].val.nat = i + j + 1;
                }

                /* cross (loop, lit_tbl (tuples) */
                ret = PFla_cross (LRL(LL(p)), 
                                  PFla_lit_tbl_ (PFalg_attlist (att_pos, att_item),
                                                 i+j,
                                                 tuples));
                *p = *(ret);
                rewritten = true;
                p->opt = false;
                R(p)->opt = false;
                relabel (p, kids);
            } else {
                PFoops (OOPS_FATAL,
                        "the pattern '(loop x lit_tbl, loop x lit_tbl)' "
                        "is too fragile.");
            }
            break;

        /* Rel:    project (project (Rel)) */
        case 13:
        {
            PFalg_proj_t *atts = PFmalloc (p->schema.count *
	                                       sizeof (PFalg_proj_t));

            unsigned int i, j;
            for (i = 0; i < p->schema.count; i++)
                for (j = 0; j < L(p)->schema.count; j++)
                    if (p->sem.proj.items[i].old ==
                        L(p)->sem.proj.items[j].new) {
                        atts[i] = PFalg_proj (
                                     p->sem.proj.items[i].new,
                                     L(p)->sem.proj.items[j].old);
                        break;
                    }

            PFla_op_t *project = PFla_project_ (L(L(p)), i, atts);

            /* FIXME: copy properties to avoid exception */
            project->prop = p->prop;

            *p = *(project);
            rewritten = true;
            p->opt = false;
            relabel (p, kids);
        }
            break;

        /* Rel:    project (distinct (Rel)) */
        case 14:
        {
            if (p->schema.count == LL(p)->schema.count)
            {
                unsigned int i, j, check = 0;
                for (i = 0; i < L(p)->schema.count; i++)
                    for (j = 0; j < p->schema.count; j++)
                        if (p->sem.proj.items[j].old ==
                            p->sem.proj.items[j].new &&
                            p->sem.proj.items[j].old ==
                            L(p)->schema.items[i].name) {
                            check++;
                            break;
                        }

                if (check == p->schema.count) {
                    *p = *(L(p));
                    rewritten = true;
                    p->opt = false;
                    break;
                }
            }
            p->opt = true;
            L(p)->opt = true;
        }
            break;

        /* Rel:    project (scjoin (Frag, Rel)) */
        case 15:
        {
            if (p->schema.count == 2)
            {
                unsigned int i, check = 0;
                for (i = 0; i < p->schema.count; i++)
                    if (p->sem.proj.items[i].old ==
                        p->sem.proj.items[i].new &&
                        (p->sem.proj.items[i].old == att_iter ||
                         p->sem.proj.items[i].old == att_item))
                        check++;

                if (check == 2) {
                    *p = *(L(p));
                    rewritten = true;
                    p->opt = false;
                    break;
                }
            }
            p->opt = true;
            L(p)->opt = true;
        }
            break;

        /* Rel:    disjunion (EmptyRel, Rel) */
        case 21:
            /* return right child */
            assert (p->kind == la_disjunion);
            *p = *(R(p));
            rewritten = true;
            break;

        /* Rel:    disjunion (Rel, EmptyRel) */
        case 22:
            /* return left child */
            assert (p->kind == la_disjunion);
            *p = *(L(p));
            rewritten = true;
            break;

        /* Rel:    difference (Rel, EmptyRel) */
        case 25:
            /* return right child */
            *p = *(R(p));
            rewritten = true;
            break;

        /* Rel:    number (rownum (Rel)) */
        case 52:
        {
            PFla_op_t *rownum = PFla_rownum (
                                    PFla_number (
                                        LL(p),
                                        p->sem.number.attname,
                                        p->sem.number.part),
                                    L(p)->sem.rownum.attname,
                                    L(p)->sem.rownum.sortby,
                                    L(p)->sem.rownum.part);

            rownum->prop = L(p)->prop;
            L(rownum)->prop = p->prop;
            *p = *rownum;
            rewritten = true;
            p->opt = true;
            L(p)->opt = true;
            relabel (p, kids);
        }
            break;

        /* Rel:    cast (Rel) */
        case 55:
            /*
             * If an algebra expression already has the requested
             * type, replace it by a projection.
             */
            for (unsigned int i = 0; i < L(p)->schema.count; i++)
                if (p->sem.cast.att == L(p)->schema.items[i].name &&
                    p->sem.cast.ty == L(p)->schema.items[i].type) {
                    PFla_op_t *ret;
                    ret = PFla_project (L(p),
                              PFalg_proj (att_iter, att_iter),
                              PFalg_proj (att_pos, att_pos),
                              PFalg_proj (p->sem.cast.res, p->sem.cast.att));

                    /* FIXME: copy properties to avoid exception */
                    ret->prop = p->prop;

                    *p = *(ret);
                    rewritten = true;
                    p->opt = false;
                    relabel (p, kids);
                    break;
                }
            break;

        /* Rel:    scjoin (Frag, distinct (Rel)) */
        case 61:
            R(p) = L(R(p));
            rewritten = true;
            p->opt = false;
            relabel (p, kids);
            break;

        /* Rel:    EmptyRel */
        case 90:
        {
            /*
             * Replace any sub-tree that we determined empty with these
             * rules by the literal empty table.
             */
            unsigned int   i;
            PFalg_att_t   *atts = PFmalloc (p->schema.count *
	                                    sizeof (PFalg_att_t));

            for (i = 0; i < p->schema.count; i++)
                 atts[i] = p->schema.items[i].name;

            *p = *(PFla_lit_tbl_ (PFalg_attlist_ (p->schema.count, atts),
                                0 /* no of tuples */, NULL /* tuples */));
            p->opt = false;
            rewritten = true;
        }
            break;

        /* Frag:    frag_union (empty_frag, empty_frag) */
        case 112:
            *p = *(L(p));
            rewritten = true;
            break;

        /* Query:  serialize (Frag, Rel) */
        case 1:
        /* Rel:    lit_tbl */
        case 2:
        /* Rel:    cross (Rel, Rel) */
        case 3:
        /* Rel:    eqjoin (Rel, Rel) */
        case 4:
        /* Rel:    project (Rel) */
        case 10:
        /* Rel:    select_ (Rel) */
        case 19:
        /* Rel:    disjunion (Rel, Rel) */
        case 20:
        /* Rel:    intersect (Rel, Rel) */
        case 23:
        /* Rel:    difference (Rel, Rel) */
        case 24:
        /* Rel:    distinct (Rel) */
        case 26:
        /* Rel:    num_add (Rel) */
        case 30:
        /* Rel:    num_subtract (Rel) */
        case 31:
        /* Rel:    num_multiply (Rel) */
        case 32:
        /* Rel:    num_divide (Rel) */
        case 33:
        /* Rel:    num_modulo (Rel) */
        case 34:
        /* Rel:    num_neg (Rel) */
        case 35:
        /* Rel:    num_gt (Rel) */
        case 36:
        /* Rel:    num_eq (Rel) */
        case 37:
        /* Rel:    bool_and (Rel) */
        case 38:
        /* Rel:    bool_or (Rel) */
        case 39:
        /* Rel:    bool_not (Rel) */
        case 40:
        /* Rel:    sum (Rel) */
        case 41:
        /* Rel:    count (Rel) */
        case 42:
        /* Rel:    rownum (Rel) */
        case 50:
        /* Rel:    number (Rel) */
        case 51:
        /* Rel:    type (Rel) */
        case 53:
        /* Rel:    type_assert (Rel) */
        case 54:
        /* Rel:    seqty1 (Rel) */
        case 56:
        /* Rel:    all (Rel) */
        case 57:
        /* Rel:    scjoin (Frag, Rel) */
        case 60:
        /* Rel:    doc_access (Frag, Rel) */
        case 62:
        /* Rel:    element_tag (Rel, Rel) */
        case 63:
        /* Rel:    element_tag (Rel, EmptyRel) */
        case 64:
        /* Rel:    roots_ (FragRel) */
        case 65:
        /* Rel:    cond_err (Rel, Rel) */
        case 70:
        /* Rel:    concat (Rel) */
        case 80:
        /* Rel:    string_join (Rel, Rel) */
        case 81:

        /* FragRel:    doc_tbl (Rel) */
        case 100:
        /* FragRel:    element (Frag, Rel) */
        case 101:
        /* FragRel:    attribute (Rel, Rel) */
        case 102:
        /* FragRel:    textnode (Rel) */
        case 103:
        /* FragRel:    docnode (Frag, Rel) */
        case 104:
        /* FragRel:    comment (Rel) */
        case 105:
        /* FragRel:    processi (Rel) */
        case 106:
        /* FragRel:    merge_adjacent (Frag, Rel) */
        case 107:

        /* Frag:    fragment (FragRel) */
        case 110:
        /* Frag:    frag_union (Frag, Frag) */
        case 111:
        /* Frag:    empty_frag */
        case 113:

        /* EmptyRel:    empty_tbl */
        case 120:
        /* EmptyRel:    cross (EmptyRel, Rel) */
        case 121:
        /* EmptyRel:    cross (Rel, EmptyRel) */
        case 122:
        /* EmptyRel:    eqjoin (EmptyRel, Rel) */
        case 123:
        /* EmptyRel:    eqjoin (Rel, EmptyRel) */
        case 124:
        /* EmptyRel:    project (EmptyRel) */
        case 125:
        /* EmptyRel:    select_ (EmptyRel) */
        case 126:
        /* EmptyRel:    disjunion (EmptyRel, EmptyRel) */
        case 130:
        /* EmptyRel:    intersect (EmptyRel, Rel) */
        case 131:
        /* EmptyRel:    intersect (Rel, EmptyRel) */
        case 132:
        /* EmptyRel:    difference (EmptyRel, Rel) */
        case 133:
        /* EmptyRel:    distinct (EmptyRel) */
        case 134:
        /* EmptyRel:    num_add (EmptyRel) */
        case 140:
        /* EmptyRel:    num_subtract (EmptyRel) */
        case 141:
        /* EmptyRel:    num_multiply (EmptyRel) */
        case 142:
        /* EmptyRel:    num_divide (EmptyRel) */
        case 143:
        /* EmptyRel:    num_modulo (EmptyRel) */
        case 144:
        /* EmptyRel:    num_neg (EmptyRel) */
        case 145:
        /* EmptyRel:    num_gt (EmptyRel) */
        case 146:
        /* EmptyRel:    num_eq (EmptyRel) */
        case 147:
        /* EmptyRel:    bool_and (EmptyRel) */
        case 148:
        /* EmptyRel:    bool_or (EmptyRel) */
        case 149:
        /* EmptyRel:    bool_not (EmptyRel) */
        case 150:
        /* EmptyRel:    sum (EmptyRel) */
        case 151:
        /* EmptyRel:    count (EmptyRel) */
        case 152:
        /* EmptyRel:    rownum (EmptyRel) */
        case 160:
        /* EmptyRel:    number (EmptyRel) */
        case 161:
        /* EmptyRel:    type (EmptyRel) */
        case 162:
        /* EmptyRel:    type_assert (EmptyRel) */
        case 163:
        /* EmptyRel:    cast (EmptyRel) */
        case 164:
        /* EmptyRel:    seqty1 (EmptyRel) */
        case 165:
        /* EmptyRel:    all (EmptyRel) */
        case 166:
        /* EmptyRel:    scjoin (Frag, EmptyRel) */
        case 170:
        /* EmptyRel:    doc_access (Frag, EmptyRel) */
        case 171:
            p->opt = true;
            break;

        /* EmptyRel:    roots_ (element (Frag, EmptyRel)) */
        case 180:
            p->opt = true;
            L(p)->opt = true;
            break;

        /* EmptyRel:    element_tag (EmptyRel, Rel) */
        case 181:
            p->opt = true;
            break;

        /* EmptyRel:    roots_ (attribute (EmptyRel, Rel)) */
        case 182:
        /* EmptyRel:    roots_ (attribute (Rel, EmptyRel)) */
        case 183:
        /* EmptyRel:    roots_ (textnode (EmptyRel)) */
        case 184:
        /* EmptyRel:    roots_ (comment (EmptyRel)) */
        case 185:
        /* EmptyRel:    roots_ (processi (EmptyRel)) */
        case 186:
        /* EmptyRel:    roots_ (merge_adjacent (Frag, EmptyRel)) */
        case 187:
            p->opt = true;
            L(p)->opt = true;
            break;

        /* EmptyRel:    cond_err (EmptyRel, Rel) */
        case 190:
        /* EmptyRel:    concat (EmptyRel) */
        case 200:
        /* EmptyRel:    string_join (EmptyRel, Rel) */
        case 201:
            p->opt = true;
            break;

        default:
            PFinfo (OOPS_NOTICE, "unknown expression during algebra "
                    "optimization (rule %i)", rule);
            break;
    }

    return rewritten;
}

/* Relabel node p if it is not contained in kids. */
static void
relabel (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        relabel (L(p), kids);
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
    }
    else if (!L(p) && R(p)) {
        relabel (R(p), kids);
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
    }
    else {
        relabel (L(p), kids);
        relabel (R(p), kids);
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
    }
}


/**
 * Invoke algebra optimization.
 */
PFla_op_t *
PFalgopt (PFla_op_t *root)
{
    /* Attach node labels in a tree walk bottom-up */
    PFalgopt_label (root);

    /* Optimize algebra tree */
    reduce (root, 1);

    return root;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
