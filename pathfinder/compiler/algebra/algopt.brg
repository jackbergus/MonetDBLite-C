%{

/**
 * @file
 *
 * Optimize relational algebra expression tree.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2005 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */

/* always include pathfinder.h first! */
#include "pathfinder.h"
#include "oops.h"         /* PFoops() */
#include "algebra.h"
#include "algopt.h"
#include "mem.h"          /* PFmalloc() */

#include "properties.h"

#include <assert.h>
#include <stdio.h>

/*
 * Accessors for the burg matcher
 */
typedef struct PFla_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p) ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/algebra.h!
 */
%term lit_tbl        =  1
%term empty_tbl      =  2
%term disjunion      =  3
%term intersect      =  4
%term difference     =  5
%term cross          =  6
%term eqjoin         =  7
%term scjoin         =  8
%term select_        =  9
%term type           = 10
%term cast           = 11
%term project        = 12
%term rownum         = 13
%term serialize      = 14
%term num_add        = 15
%term num_subtract   = 16
%term num_multiply   = 17
%term num_divide     = 18
%term num_modulo     = 19
%term num_eq         = 20
%term num_gt         = 21
%term num_neg        = 22
%term bool_and       = 23
%term bool_or        = 24
%term bool_not       = 25
%term sum            = 26
%term count          = 27
%term distinct       = 28
%term element        = 29
%term element_tag    = 30
%term attribute      = 31
%term textnode       = 32
%term docnode        = 33
%term comment        = 34
%term processi       = 35
%term concat         = 36
%term merge_adjacent = 37
%term doc_access     = 38
%term string_join    = 39
%term seqty1         = 40
%term all            = 41
%term roots_         = 42
%term fragment       = 43
%term frag_union     = 44
%term empty_frag     = 45
%term doc_tbl        = 46

%%

Query:  serialize (Frag, Rel)                     =  1 (10);

Rel:    lit_tbl                                   =  2 (10);
Rel:    disjunion (Rel, Rel)                      =  3 (10);
Rel:    disjunion (EmptyRel, Rel)                 =  4 (5);
Rel:    disjunion (Rel, EmptyRel)                 =  5 (5);
Rel:    difference (Rel, Rel)                     =  6 (10);
Rel:    difference (Rel, EmptyRel)                =  7 (5);
Rel:    intersect (Rel, Rel)                      =  8 (10);
Rel:    cross (Rel, Rel)                          =  9 (10);
Rel:    eqjoin (Rel, Rel)                         = 10 (10);
Rel:    scjoin (Frag, Rel)                        = 11 (10);
Rel:    rownum (Rel)                              = 12 (10);
Rel:    project (
            rownum (
                disjunion (
                    cross (lit_tbl,
                           cross (Rel,
                                  lit_tbl)),
                    cross (lit_tbl,
                           cross(Rel,
                                 lit_tbl)))))     = 13 (40);
Rel:    project (Rel)                             = 14 (10);
Rel:    select_ (Rel)                             = 15 (10);
Rel:    sum (Rel)                                 = 16 (10);
Rel:    count (Rel)                               = 17 (10);
Rel:    distinct (Rel)                            = 18 (10);
Rel:    type (Rel)                                = 19 (10);
Rel:    cast (Rel)                                = 20 (10);
Rel:    num_add (Rel)                             = 21 (10);
Rel:    num_subtract (Rel)                        = 22 (10);
Rel:    num_multiply (Rel)                        = 23 (10);
Rel:    num_divide (Rel)                          = 24 (10);
Rel:    num_modulo (Rel)                          = 25 (10);
Rel:    num_neg (Rel)                             = 26 (10);
Rel:    num_gt (Rel)                              = 27 (10);
Rel:    num_eq (Rel)                              = 28 (10);
Rel:    bool_and (Rel)                            = 29 (10);
Rel:    bool_or (Rel)                             = 30 (10);
Rel:    bool_not (Rel)                            = 31 (10);
Rel:    concat (Rel)                              = 32 (10);
Rel:    seqty1 (Rel)                              = 33 (10);
Rel:    all (Rel)                                 = 34 (10);
Rel:    doc_access (Frag, Rel)                    = 35 (10);
Rel:    string_join (Rel, Rel)                    = 36 (10);

Rel:    roots_ (FragRel)                          = 37 (10);
Rel:    element_tag (Rel, Rel)                    = 38 (10);
Rel:    element_tag (Rel, EmptyRel)               = 39 (5);


FragRel:    element (Frag, Rel)                   = 40 (10);
FragRel:    attribute (Rel, Rel)                  = 41 (10);
FragRel:    textnode (Rel)                        = 42 (10);
FragRel:    docnode (Frag, Rel)                   = 43 (10);
FragRel:    comment (Rel)                         = 44 (10);
FragRel:    processi (Rel)                        = 45 (10);
FragRel:    merge_adjacent (Frag, Rel)            = 46 (10);
FragRel:    doc_tbl (Rel)                         = 47 (10);


Frag:    fragment (FragRel)                       = 48 (10);
Frag:    frag_union (Frag, Frag)                  = 49 (10);
Frag:    frag_union (empty_frag, empty_frag)      = 50 (10);
Frag:    empty_frag                               = 51 (10);


EmptyRel:    empty_tbl                            = 52 (0);

EmptyRel:    disjunion (EmptyRel, EmptyRel)       = 53 (0);
EmptyRel:    difference (EmptyRel, Rel)           = 54 (0);
EmptyRel:    intersect (EmptyRel, Rel)            = 56 (0);
EmptyRel:    intersect (Rel, EmptyRel)            = 57 (0);
EmptyRel:    cross (EmptyRel, Rel)                = 58 (0);
EmptyRel:    cross (Rel, EmptyRel)                = 59 (0);
EmptyRel:    eqjoin (EmptyRel, Rel)               = 60 (0);
EmptyRel:    eqjoin (Rel, EmptyRel)               = 61 (0);
EmptyRel:    scjoin (Frag, EmptyRel)              = 62 (0);
EmptyRel:    rownum (EmptyRel)                    = 63 (0);
EmptyRel:    project (EmptyRel)                   = 64 (0);
EmptyRel:    select_ (EmptyRel)                   = 65 (0);
EmptyRel:    sum (EmptyRel)                       = 66 (0);
EmptyRel:    count (EmptyRel)                     = 67 (0);
EmptyRel:    distinct (EmptyRel)                  = 68 (0);
EmptyRel:    type (EmptyRel)                      = 69 (0);
EmptyRel:    cast (EmptyRel)                      = 70 (0);
EmptyRel:    num_add (EmptyRel)                   = 71 (0);
EmptyRel:    num_subtract (EmptyRel)              = 72 (0);
EmptyRel:    num_multiply (EmptyRel)              = 73 (0);
EmptyRel:    num_divide (EmptyRel)                = 74 (0);
EmptyRel:    num_modulo (EmptyRel)                = 75 (0);
EmptyRel:    num_neg (EmptyRel)                   = 76 (0);
EmptyRel:    num_gt (EmptyRel)                    = 77 (0);
EmptyRel:    num_eq (EmptyRel)                    = 78 (0);
EmptyRel:    bool_and (EmptyRel)                  = 79 (0);
EmptyRel:    bool_or (EmptyRel)                   = 80 (0);
EmptyRel:    bool_not (EmptyRel)                  = 81 (0);
EmptyRel:    concat (EmptyRel)                    = 82 (0);
EmptyRel:    seqty1 (EmptyRel)                    = 83 (0);
EmptyRel:    all (EmptyRel)                       = 84 (0);

EmptyRel:    element_tag (EmptyRel, Rel)          = 85 (0);


EmptyRel:    roots_ (element (Frag, EmptyRel))    = 86 (0);
EmptyRel:    roots_ (attribute (EmptyRel, Rel))   = 87 (0);
EmptyRel:    roots_ (attribute (Rel, EmptyRel))   = 88 (0);
EmptyRel:    roots_ (textnode (EmptyRel))         = 89 (0);
EmptyRel:    roots_ (comment (EmptyRel))          = 90 (0);
EmptyRel:    roots_ (processi (EmptyRel))         = 91 (0);
EmptyRel:    roots_ (merge_adjacent (Frag, EmptyRel)) = 92 (0);

Rel:    EmptyRel                                  = 93 (0);

Rel:    project (project (Rel))                   = 94 (1);

%%

#include "algebra_mnemonic.h"

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
#define LRL(p) L(R(L(p)))
#define LRR(p) R(R(L(p)))
#define RRL(p) L(R(R(p)))
#define RRR(p) R(R(R(p)))

#define MAX_KIDS 10

/* Relabel node p if it is not contained in kids. */
static void relabel (PFla_op_t *p,  PFla_op_t **kids);

/*
 * Check whether the second input projection list @a p1 is contained
 * in the first projection list @a p2. @a n1 and @a n2 are the number
 * of projection items in both lists, respecitvely.
 */
static bool contains_projlist (PFalg_proj_t *p1, int n1,
                               PFalg_proj_t *p2, int n2);

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFla_op_t *p, int goalnt)
{
    int              rule;       /* rule number that matches for this node */
    short           *nts;        /* target non-terminals for the leaf nodes of
                                    the current rule */
    PFla_op_t       *kids[MAX_KIDS];   /* leaf nodes of this rule */
    bool             rewritten = false;

    short            old_state_label;
    unsigned short   i;

    do {
        /* determine rule that matches for this non-terminal */
        rule = PFalgopt_rule (STATE_LABEL (p), goalnt);

        assert (rule);

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFalgopt_nts[rule];
        PFalgopt_kids (p, rule, kids);

        /* recursively translate all leaf expressions */
        rewritten = false;
        for (i = 0; nts[i]; i++)
            if ((rewritten = reduce (kids[i], nts[i])))
                break;  /* abort if a subtree was rewritten */

        if (rewritten) {

            /*
             * If a subtree has been rewritten, we have to
             *  - re-label that part of the tree, and
             *  - possibly propagate the `rewritten' information upwards.
             */

            /* remember our old state_label (so we know if it has changed) */
            old_state_label = STATE_LABEL(p);

            /*
             * Re-label current tree pattern.
             * (at most down to the pattern leaves, as they should already be
             * correctly labeled by the above reduce() call)
             */
            relabel (p, kids);

            /* If our own state_label has changed, notify our caller. */
            if (old_state_label != STATE_LABEL(p))
                return true;
        }
    } while (rewritten);


    switch (rule) {

        /* Query:    serialize (Frag, Rel) */
        case 1:
            break;

        /* Rel:    lit_tbl */
        case 2:
            break;

        /* Rel:  disjunion (Rel, Rel) */
        case 3:
            break;

        /*
         * Rel:  disjunion (EmptyRel, Rel);
         * return right child
	 */
        case 4:
            assert (p->kind == la_disjunion);
            *p = *(R(p));
            rewritten = true;
            break;

        /*
         * Rel:  disjunion (Rel, EmptyRel);
         * return left child
	 */ 
        case 5:
            assert (p->kind == la_disjunion);
            *p = *(L(p));
            rewritten = true;
            break;

        /* Rel:    difference (Rel, Rel) */
        case 6:
            break;

        /*
         * Rel:    difference (Rel, EmptyRel)
         * return right child
	 */ 
        case 7:
            *p = *(R(p));
            rewritten = true;
            break;

        /* Rel:    intersect (Rel, Rel) */
        case 8:

        /* Rel:    cross (Rel, Rel) */
        case 9:

        /* Rel:    eqjoin (Rel, Rel) */
        case 10:

        /* Rel:    scjoin (Frag, Rel) */
        case 11:

        /* Rel:    rownum (Rel) */
        case 12:
            break;

        /* Rel:    project (
                       rownum (
                           disjunion (
                               cross (lit_tbl,
                                      cross (Rel,
                                             lit_tbl)),
                               cross (lit_tbl,
                                      cross(Rel,
                                            lit_tbl))))) */
        case 13:
            /* concatenate tuples of base relations instead
               of applying a more expensive sequence construction */

            if (/* project (iter,pos:pos1,item) */
                p->schema.count == 3 &&
                p->sem.proj.items[0].old == att_iter &&
                p->sem.proj.items[0].new == att_iter &&
                p->sem.proj.items[1].old == att_pos1 &&
                p->sem.proj.items[1].new == att_pos &&
                p->sem.proj.items[2].old == att_item &&
                p->sem.proj.items[2].new == att_item &&
                /* row_num (pos1:<ord,pos>/iter) */ 
                L(p)->sem.rownum.attname == att_pos1 &&
                L(p)->sem.rownum.part ==    att_iter &&
                L(p)->sem.rownum.sortby.count == 2 &&
                L(p)->sem.rownum.sortby.atts[0] == att_ord &&
                L(p)->sem.rownum.sortby.atts[1] == att_pos &&
                /*
                                              ord
                  compare with base relation: --- 
                                               1
                */ 
                LL(LL(p))->sem.lit_tbl.count == 1 &&
                LL(LL(p))->schema.count == 1 &&
                LL(LL(p))->schema.items[0].name == att_ord &&
                LL(LL(p))->sem.lit_tbl.tuples[0].count == 1 &&
                LL(LL(p))->sem.lit_tbl.tuples[0].atoms[0].type == aat_nat &&
                LL(LL(p))->sem.lit_tbl.tuples[0].atoms[0].val.nat == 1 &&
                /*
                                              ord
                  compare with base relation: --- 
                                               2
                */ 
                RL(LL(p))->sem.lit_tbl.count == 1 &&
                RL(LL(p))->schema.count == 1 &&
                RL(LL(p))->schema.items[0].name == att_ord &&
                RL(LL(p))->sem.lit_tbl.tuples[0].count == 1 &&
                RL(LL(p))->sem.lit_tbl.tuples[0].atoms[0].type == aat_nat &&
                RL(LL(p))->sem.lit_tbl.tuples[0].atoms[0].val.nat == 2 &&
                /* compare loop relations */
                LRL(LL(p)) == RRL(LL(p)) &&
                /* ckeck schema of literal table */
                LRR(LL(p))->schema.count == 2 &&
                LRR(LL(p))->schema.items[0].name == att_pos &&
                LRR(LL(p))->schema.items[1].name == att_item &&
                /* ckeck schema of literal table */
                RRR(LL(p))->schema.count == 2 &&
                RRR(LL(p))->schema.items[0].name == att_pos &&
                RRR(LL(p))->schema.items[1].name == att_item)
            {
                unsigned int i, j;
                PFla_op_t *ret;
                PFalg_tuple_t *tuples 
                                = PFmalloc ((LRR(LL(p))->sem.lit_tbl.count +
                                             RRR(LL(p))->sem.lit_tbl.count) *
                                            sizeof (PFalg_tuple_t));
                /* copy tuples of first literal table */
                for (i = 0; i < LRR(LL(p))->sem.lit_tbl.count; i++)
                {
                    tuples[i] = LRR(LL(p))->sem.lit_tbl.tuples[i];
                    /* set new position value (starting from 1) */
                    tuples[i].atoms[0].val.nat = i + 1; 
                }
                /* copy tuples of second literal table */
                for (j = 0; j < RRR(LL(p))->sem.lit_tbl.count; j++)
                {
                    tuples[i+j] = RRR(LL(p))->sem.lit_tbl.tuples[j];
                    /* set new position value 
                       (starting from next free position: i+1) */
                    tuples[i+j].atoms[0].val.nat = i + j + 1;
                }

                /* cross (loop, lit_tbl (tuples) */
                ret = PFla_cross (LRL(LL(p)), 
                                  PFla_lit_tbl_ (PFalg_attlist (att_pos, att_item),
                                                 i+j,
                                                 tuples));
                *p = *(ret);
                rewritten = true;
                relabel (p, kids);
            }
            break;

        /* Rel:    project (Rel) */
        case 14:

        /* Rel:    select_ (Rel) */
        case 15:

        /* Rel:    sum (Rel) */
        case 16:

        /* Rel:    count (Rel) */
        case 17:

        /* Rel:    distinct (Rel) */
        case 18:

        /* Rel:    type (Rel) */
        case 19:
            break;

        /* Rel:    cast (Rel) */
        case 20:
        {
            /*
             * If an algebra expression already has the requested
             * type, remove the cast.
             */
            unsigned int i;

            for (i = 0; i < L(p)->schema.count; i++)
                if (p->sem.cast.att == L(p)->schema.items[i].name) {
                    if (p->sem.cast.ty == L(p)->schema.items[i].type) {
                        *p = *(L(p));
                        rewritten = true;
                        break;
                    }
                }
        } break;

        /* Rel:    num_add (Rel) */
        case 21:

        /* Rel:    num_subtract (Rel) */
        case 22:

        /* Rel:    num_multiply (Rel) */
        case 23:

        /* Rel:    num_divide (Rel) */
        case 24:

        /* Rel:    num_modulo (Rel) */
        case 25:

        /* Rel:    num_neg (Rel) */
        case 26:

        /* Rel:    num_gt (Rel) */
        case 27:

        /* Rel:    num_eq (Rel) */
        case 28:

        /* Rel:    bool_and (Rel) */
        case 29:

        /* Rel:    bool_or (Rel) */
        case 30:

        /* Rel:    bool_not (Rel) */
        case 31:

        /* Rel:    concat (Rel) */
        case 32:

        /* Rel:    seqty1 (Rel) */
        case 33:

        /* Rel:    all (Rel) */
        case 34:

        /* Rel:    doc_access (FragRel, Rel) */
        case 35:

        /* Rel:    string_join (Rel, Rel) */
        case 36:

        /* Rel:    roots_ (FragRel) */
        case 37:

        /* Rel:    element_tag (Rel, Rel) */
        case 38:

        /* Rel:    element_tag (Rel, EmptyRel) */
        case 39:

        /* FragRel:    element (Frag, Rel) */
        case 40:

        /* FragRel:    attribute (Rel, Rel  */
        case 41:

        /* FragRel:    textnode (Rel) */
        case 42:

        /* FragRel:    docnode (Frag, Rel) */
        case 43:

        /* FragRel:    comment (Rel) */
        case 44:

        /* FragRel:    processi (Rel) */
        case 45:

        /* FragRel:    merge_adjacent (Frag, Rel) */
        case 46:

        /* FragRel:    doc_tbl (Rel) */
        case 47:

        /* Frag:    fragment (FragRel) */
        case 48:

        /* Frag:    frag_union (Frag, Frag) */
        case 49:
            break;

        /* Frag:    frag_union (empty_frag, empty_frag) */
        case 50:
            *p = *(L(p));
            rewritten = true;
            break;

        /* Frag:    empty_frag */
        case 51:
            break;

        /* EmptyRel:    empty_tbl */
        case 52:

        /* EmptyRel:    disjunion (EmptyRel, EmptyRel) */
        case 53:

        /* EmptyRel:    difference (EmptyRel, Rel) */
        case 54:

        /* EmptyRel:    difference (EmptyRel, EmptyRel) */
        case 55:

        /* EmptyRel:    intersect (EmptyRel, Rel) */
        case 56:

        /* EmptyRel:    intersect (Rel, EmptyRel) */
        case 57:

        /* EmptyRel:    cross (EmptyRel, Rel) */
        case 58:

        /* EmptyRel:    cross (Rel, EmptyRel) */
        case 59:

        /* EmptyRel:    eqjoin (EmptyRel, Rel) */
        case 60:

        /* EmptyRel:    eqjoin (Rel, EmptyRel) */
        case 61:

        /* EmptyRel:    scjoin (Frag, EmptyRel) */
        case 62:

        /* EmptyRel:    rownum (EmptyRel) */
        case 63:

        /* EmptyRel:    project (EmptyRel) */
        case 64:

        /* EmptyRel:    select_ (EmptyRel) */
        case 65:

        /* EmptyRel:    sum (EmptyRel) */
        case 66:

        /* EmptyRel:    count (EmptyRel) */
        case 67:

        /* EmptyRel:    distinct (EmptyRel) */
        case 68:

        /* EmptyRel:    type (EmptyRel) */
        case 69:

        /* EmptyRel:    cast (EmptyRel) */
        case 70:

        /* EmptyRel:    num_add (EmptyRel) */
        case 71:

        /* EmptyRel:    num_subtract (EmptyRel) */
        case 72:

        /* EmptyRel:    num_multiply (EmptyRel) */
        case 73:

        /* EmptyRel:    num_divide (EmptyRel) */
        case 74:

        /* EmptyRel:    num_modulo (EmptyRel) */
        case 75:

        /* EmptyRel:    num_neg (EmptyRel) */
        case 76:

        /* EmptyRel:    num_gt (EmptyRel) */
        case 77:

        /* EmptyRel:    num_eq (EmptyRel) */
        case 78:

        /* EmptyRel:    bool_and (EmptyRel) */
        case 79:

        /* EmptyRel:    bool_or (EmptyRel) */
        case 80:

        /* EmptyRel:    bool_not (EmptyRel) */
        case 81:

        /* EmptyRel:    concat (EmptyRel) */
        case 82:

        /* EmptyRel:    seqty1 (EmptyRel) */
        case 83:

        /* EmptyRel:    all (EmptyRel) */
        case 84:

        /* EmptyRel:    element_tag (EmptyRel, Rel) */
        case 85:

        /* EmptyRel:    roots_ (element (Frag, EmptyRel)) */
        case 86:

        /* EmptyRel:    roots_ (attribute (EmptyRel, Rel)) */
        case 87:

        /* EmptyRel:    roots_ (attribute (Rel, EmptyRel)) */
        case 88:

        /* EmptyRel:    roots_ (textnode (EmptyRel)) */
        case 89:

        /* EmptyRel:    roots_ (comment (EmptyRel)) */
        case 90:

        /* EmptyRel:    roots_ (processi (EmptyRel)) */
        case 91:

        /* EmptyRel:    roots_ (merge_adjacent (Frag, EmptyRel)) */
        case 92:
            break;

        /* Rel:    EmptyRel */
        case 93:
        {
            /*
             * Replace any sub-tree that we determined empty with these
             * rules by the literal empty table.
             */
            unsigned int   i;
            PFalg_att_t   *atts = PFmalloc (p->schema.count *
	                                    sizeof (PFalg_att_t));

            for (i = 0; i < p->schema.count; i++)
                 atts[i] = p->schema.items[i].name;

            *p = *(PFla_lit_tbl_ (PFalg_attlist_ (p->schema.count, atts),
                                0 /* no of tuples */, NULL /* tuples */));
            rewritten = true;
        }
            break;

        /* Rel:    project (project (Rel)) */
        case 94:
        {
            /* If projlist2 is contained in projlist1, the second
             * projection is redundant.
             */
            break;
#if 0
            /* THIS IS ONLY A TEST! */
            PFalg_proj_t *projlist1 = p->sem.proj.items;
            PFalg_proj_t *projlist2 = L(p)->sem.proj.items;
            int n1 = p->sem.proj.count;
            int n2 = L(p)->sem.proj.count;

            if (contains_projlist (projlist1, n1, projlist2, n2)) {
                L(p) = L(L(p));
                rewritten = true;
            }
            break;
#endif
        }

        default:
            PFinfo (OOPS_NOTICE, "unknown expression during algebra "
                    "optimization (rule %i)", rule);
            break;
    }

    return rewritten;
}


/*
 * Check whether the second input projection list @a p1 is contained
 * in the first projection list @a p2. @a n1 and @a n2 are the number
 * of projection items in both lists, respecitvely.
 */
static bool
contains_projlist (PFalg_proj_t *p1, int n1,
                   PFalg_proj_t *p2, int n2)
{
    int i, j;
    bool item_contained;

    for (i = 0; i < n1; i++) {
        item_contained = false;

        for (j = 0; j < n2; j++) {
            if ((p1[i].old == p2[j].new &&
                p1[i].old == p2[j].old) ||
                (p1[i].new == p2[j].new &&
                p1[i].old == p2[j].old))
                item_contained = true;
        }
        if (!item_contained)
            return false;
    }

    return true;
}

/* Relabel node p if it is not contained in kids. */
static void
relabel (PFla_op_t *p,  PFla_op_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        relabel (L(p), kids);
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
    }
    else if (!L(p) && R(p)) {
        relabel (R(p), kids);
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
    }
    else {
        relabel (L(p), kids);
        relabel (R(p), kids);
        STATE_LABEL(p) = PFalgopt_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
    }
}


/**
 * Invoke algebra optimization.
 */
PFla_op_t *
PFalgopt (PFla_op_t *root)
{
    /* Infer interesting properties about algebra expressions. */
    PFprop_infer (root);

    /* Attach node labels in a tree walk bottom-up */
    PFalgopt_label (root);

    /* Optimize algebra tree */
    reduce (root, 1);

    return root;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
