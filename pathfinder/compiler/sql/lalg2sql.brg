%{

/**
 * @file
 *
 * Transforms the logical algebra tree into a tree that represents
 * sql statements.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2006 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 * $Id$
 */

/* always include pathfinder first */
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "lalg2sql.h"
#include "sql.h"
#include "algebra.h"
#include "oops.h"       /* PFoops() */
/**
 * Accessors for the burg pattern matcher */ 
typedef struct PFla_op_t* NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)     ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)   ((p)->child[0])
#define RIGHT_CHILD(p)  ((p)->child[1])

/* the state, burg determines during the bottom up graph
 * traversal
 */
#define STATE_LABEL(p) ((p)->state_label)

/* if an error occurs, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start with non-terminal */
%start Query

/**
 * Node identifiers, corresponding to the node kinds in
 * include/logical.h
 */
%term serialize      =  1 /**< serialize algebra expression
                           * (Placed on the very top of the tree.)
                           */
%term lit_tbl        =  2 /**< literal table */
%term empty_tbl      =  3 /**< empty literal table */
%term attach         =  4 /**< attach constant column */
%term cross          =  5 /**< cross product (Cartesian product) */
%term eqjoin         =  6 /**< equi-join */
%term project        =  7 /**< algebra projection and renaming operator */
%term select_         =  8 /**< selection of rows where column value != 0 */
%term disjunion      =  9 /**< union two relations with same schema */
%term intersect      = 10 /**< intersect two relations with same schema */
%term difference     = 11 /**< difference of two relations w/ same schema */
%term distinct       = 12 /**< duplicate elimination operator */
%term num_add        = 20 /**< arithmetic plus operator */
%term num_subtract   = 21 /**< arithmetic minus operator */
%term num_multiply   = 22 /**< arithmetic times operator */
%term num_divide     = 23 /**< arithmetic divide operator */
%term num_modulo     = 24 /**< arithmetic modulo operator */
%term num_eq         = 25 /**< numeric equal operator */
%term num_gt         = 26 /**< numeric greater-than operator */
%term num_neg        = 27 /**< numeric negation operator */
%term bool_and       = 28 /**< boolean AND operator */
%term bool_or        = 29 /**< boolean OR operator */
%term bool_not       = 30 /**< boolean NOT operator */
%term avg            = 31 /**< operator for (partitioned) avg of a column */
%term max_            = 32 /**< operator for (partitioned) max of a column */
%term min_            = 33 /**< operator for (partitioned) min of a column */
%term sum            = 34 /**< operator for (partitioned) sum of a column */
%term count          = 35 /**< (partitioned) row counting operator */
%term rownum         = 36 /**< consecutive number generation */
%term number         = 37 /**< consecutive number generation */
%term type           = 40 /**< selection of rows where a column is of a
                           *   certain type
                           */
%term type_assert    = 41 /**< restricts the type of a relation */
%term cast           = 42 /**< type cast of an attribute */
%term seqty1         = 43 /**< test for exactly one type occurrence in one
                           *   iteration (Pathfinder extension) */
%term all            = 44 /**< test if all items in an iteration are true */
%term scjoin         = 50 /**< staircase join */
%term doc_tbl        = 51 /**< document relation (is also a fragment) */
%term doc_access     = 52 /**< document access necessary for pf:string-value */
%term element        = 60 /**< element-constructing operator */
%term element_tag    = 61 /**< part of the element-constructing operator;
                           *   connecting element tag and content;
                           *   due to Burg we use two "wire2" operators
                           *   now instead of one "wire3 operator "
                           */
%term attribute      = 62 /**< attribute-constructing operator */
%term textnode       = 63 /**< text node-constructing operator */
%term docnode        = 64 /**< document node-constructing operator */
%term comment        = 65 /**< comment-constructing operator */
%term processi       = 66 /**< processing instruction-constr. operator */
%term merge_adjacent = 67 /**< operator for pf:merge-adjacent-text-nodes
                           *  builtin function
                           */
%term roots_          = 70 /**< algebraic repres. of the roots of newly
                           *   created xml nodes (e.g. element());
                           *   schema: iter | pos | item
                           */
/* all operators below represent xml node fragments with no schema */
%term fragment       = 71 /**< representation of a node fragment */
%term frag_union     = 72 /**< special node type used to form an algebraic
                           *   union of fragments
                           */
%term empty_frag     = 73 /**< representation of an empty fragment */
%term cond_err       = 80 /**< facility to trigger runtime errors */
%term rec_fix        = 81 /**< operator representing a tail recursion */
%term rec_param      = 82 /**< list of parameters of the recursion */
%term rec_nil        = 83 /**< end of the list of parameters of the 
                           *   recursion
                           */
%term rec_arg        = 84 /**< reference to the arguments of a parameter
                           *   in the recursion
                           */
%term rec_base       = 85 /**< base of the DAG describing the recursion */
%term proxy          = 96 /**< proxy operator that represents a group
                           *   of operators
                           */
%term proxy_base     = 97 /**< completes the content of the proxy 
                           *   (a virtual base table)
                           */
%term cross_mvd      = 98 /**< clone column aware cross product */
%term eqjoin_unq     = 99 /**< clone column aware equi-join */                            
/* builtin support for XQuery functions */
%term concat         =100 /**< fn:concat */
%term contains       =101 /**< fn:contains */
%term string_join    =102 /**< fn:string-join */
%term dummy          =120 /**< dummy operator that does nothing */

%%

Query:  serialize (Frag, Rel)                     =   1 (10);

Rel:    lit_tbl                                   =   2 (10);
Rel:    attach (Rel)                              =   3 (10);
Rel:    cross (Rel, Rel)                          =   4 (10);
Rel:    cross (Rel, lit_tbl)                      =   5 (10);
Rel:    cross (lit_tbl, Rel)                      =   6 (10);
Rel:    eqjoin (Rel, Rel)                         =   8 (10);
Rel:    project (Rel)                             =  10 (10);
Rel:    project (attach (Rel))                    =  11 (10);
Rel:    project (project (Rel))                   =  13  (1);
Rel:    select_ (Rel)                             =  19 (10);
Rel:    disjunion (Rel, Rel)                      =  20 (10);
Rel:    disjunion (EmptyRel, Rel)                 =  21  (5);
Rel:    disjunion (Rel, EmptyRel)                 =  22  (5);
Rel:    intersect (Rel, Rel)                      =  23 (10);
Rel:    difference (Rel, Rel)                     =  24 (10);
Rel:    difference (Rel, EmptyRel)                =  25  (5);
Rel:    distinct (Rel)                            =  26 (10);
Rel:    distinct (scjoin (Frag, Rel))             =  27 (5);
Rel:    num_add (Rel)                             =  30 (10);
Rel:    num_subtract (Rel)                        =  31 (10);
Rel:    num_multiply (Rel)                        =  32 (10);
Rel:    num_divide (Rel)                          =  33 (10);
Rel:    num_modulo (Rel)                          =  34 (10);
Rel:    num_neg (Rel)                             =  35 (10);
Rel:    num_gt (Rel)                              =  36 (10);
Rel:    num_eq (Rel)                              =  37 (10);
Rel:    bool_and (Rel)                            =  38 (10);
Rel:    bool_or (Rel)                             =  39 (10);
Rel:    bool_not (Rel)                            =  40 (10);
Rel:    avg (Rel)                                 =  41 (10);
Rel:    max_ (Rel)                                =  42 (10);
Rel:    min_ (Rel)                                =  43 (10);
Rel:    sum (Rel)                                 =  44 (10);
Rel:    count (Rel)                               =  45 (10);
Rel:    rownum (Rel)                              =  50 (10);
Rel:    number (Rel)                              =  51 (10);
Rel:    number (number (Rel))                     =  52 (10);
Rel:    number (project (number (Rel)))           =  53 (10);
Rel:    type (Rel)                                =  54 (10);
Rel:    type_assert (Rel)                         =  55 (10);
Rel:    cast (cast (Rel))                         =  56 (10);
Rel:    cast (project (cast (Rel)))               =  57 (10);
Rel:    cast (Rel)                                =  58 (10);
Rel:    seqty1 (Rel)                              =  59 (10);
Rel:    all (Rel)                                 =  60 (10);
Rel:    ScjRel                                    =  61 (10);
ScjRel: scjoin (Frag, Rel)                        =  62 (10);
ScjRel: scjoin (Frag, ScjRel)                     =  63 (10);
ScjRel: scjoin (Frag, distinct (Rel))             =  64 (10);
Rel:    doc_access (Frag, Rel)                    =  65 (10);

Rel:    roots_ (doc_tbl (Rel))                    =  70 (10);
Rel:    roots_ (element (Frag,                       
                         element_tag (Rel, Rel))) =  71 (10);
Rel:    roots_ (attribute (Rel))                  =  72 (10);
Rel:    roots_ (textnode (Rel))                   =  73 (10);
Rel:    roots_ (docnode (Frag, Rel))              =  74 (10);
Rel:    roots_ (comment (Rel))                    =  75 (10);
Rel:    roots_ (processi (Rel))                   =  76 (10);
Rel:    roots_ (merge_adjacent (Frag, Rel))       =  77 (10);

Rel:    cond_err (Rel, Rel)                       =  80 (10);

Rel:    rec_fix (Rec, Rel)                        =  81 (10);
Rel:    rec_base                                  =  82 (10);
Rec:    rec_param (Arg, Rec)                      =  83 (10);
Rec:    rec_nil                                   =  84 (10);
Arg:    rec_arg (Rel, Rel)                        =  85 (10);

Rel:    concat (Rel)                              =  86 (10);
Rel:    contains (Rel)                            =  87 (10);
Rel:    string_join (Rel, Rel)                    =  88 (10);
Rel:    dummy (Rel)                               =  89 (10);

Rel:    EmptyRel                                  =  90  (0);


Frag:    fragment (doc_tbl (Rel))                 = 100 (10);
Frag:    fragment (element (Frag, 
                            element_tag (Rel,
                                         Rel)))   = 101 (10);
Frag:    fragment (attribute (Rel))               = 102 (10);
Frag:    fragment (textnode (Rel))                = 103 (10);
Frag:    fragment (docnode (Frag, Rel))           = 104 (10);
Frag:    fragment (comment (Rel))                 = 105 (10);
Frag:    fragment (processi (Rel))                = 106 (10);
Frag:    fragment (merge_adjacent (Frag, Rel))    = 107 (10);

Frag:    frag_union (Frag, Frag)                  = 111 (10);
Frag:    empty_frag                               = 112 (10);


EmptyRel:    empty_tbl                            = 120  (0);

EmptyRel:    attach (EmptyRel)                    = 121  (0);
EmptyRel:    cross (EmptyRel, Rel)                = 122  (0);
EmptyRel:    cross (Rel, EmptyRel)                = 123  (0);
EmptyRel:    eqjoin (EmptyRel, Rel)               = 124  (0);
EmptyRel:    eqjoin (Rel, EmptyRel)               = 125  (0);
EmptyRel:    project (EmptyRel)                   = 126  (0);
EmptyRel:    select_ (EmptyRel)                   = 127  (0);
EmptyRel:    disjunion (EmptyRel, EmptyRel)       = 130  (0);
EmptyRel:    intersect (EmptyRel, Rel)            = 131  (0);
EmptyRel:    intersect (Rel, EmptyRel)            = 132  (0);
EmptyRel:    difference (EmptyRel, Rel)           = 133  (0);
EmptyRel:    distinct (EmptyRel)                  = 134  (0);
EmptyRel:    num_add (EmptyRel)                   = 140  (0);
EmptyRel:    num_subtract (EmptyRel)              = 141  (0);
EmptyRel:    num_multiply (EmptyRel)              = 142  (0);
EmptyRel:    num_divide (EmptyRel)                = 143  (0);
EmptyRel:    num_modulo (EmptyRel)                = 144  (0);
EmptyRel:    num_neg (EmptyRel)                   = 145  (0);
EmptyRel:    num_gt (EmptyRel)                    = 146  (0);
EmptyRel:    num_eq (EmptyRel)                    = 147  (0);
EmptyRel:    bool_and (EmptyRel)                  = 148  (0);
EmptyRel:    bool_or (EmptyRel)                   = 149  (0);
EmptyRel:    bool_not (EmptyRel)                  = 150  (0);
EmptyRel:    avg (EmptyRel)                       = 151  (0);
EmptyRel:    max_ (EmptyRel)                      = 152  (0);
EmptyRel:    min_ (EmptyRel)                      = 153  (0);
EmptyRel:    sum (EmptyRel)                       = 154  (0);
EmptyRel:    count (EmptyRel)                     = 155  (0);
EmptyRel:    rownum (EmptyRel)                    = 160  (0);
EmptyRel:    number (EmptyRel)                    = 161  (0);
EmptyRel:    type (EmptyRel)                      = 162  (0);
EmptyRel:    type_assert (EmptyRel)               = 163  (0);
EmptyRel:    cast (EmptyRel)                      = 164  (0);
EmptyRel:    seqty1 (EmptyRel)                    = 165  (0);
EmptyRel:    all (EmptyRel)                       = 166  (0);
EmptyRel:    scjoin (Frag, EmptyRel)              = 170  (0);
EmptyRel:    doc_access (Frag, EmptyRel)          = 171  (0);
EmptyRel:    roots_ (element (Frag, 
                              element_tag (EmptyRel,
                                          Rel)))  = 180  (0);
EmptyRel:    roots_ (attribute (EmptyRel))        = 182  (0);
EmptyRel:    roots_ (textnode (EmptyRel))         = 184  (0);
EmptyRel:    roots_ (comment (EmptyRel))          = 185  (0);
EmptyRel:    roots_ (processi (EmptyRel))         = 186  (0);
EmptyRel:    roots_ (merge_adjacent (Frag,                   
                                     EmptyRel))   = 187  (0);
EmptyRel:    cond_err (EmptyRel, Rel)             = 190  (0);
EmptyRel:    concat (EmptyRel)                    = 200  (0);
EmptyRel:    string_join (EmptyRel, Rel)          = 201  (0);
EmptyRel:    dummy (EmptyRel)                     = 202  (0);

%%

#include "sql_mnemonic.h"

#define MAX_KIDS  10

/**
 * Reduce function. This is the core of this source file, containing
 * the actions that should be executed whenever a burg-pattern matches.
 */
static void
reduce(PFla_op_t *p, int goalnt, int indent)
{
    int           rule;             /* rule number that matches this node */
    short         *nts;             /* target non-terminals for the leaf node
                                     * of the current rule */
    PFla_op_t    *kids[MAX_KIDS];   /* leaf node of this rule */
    
    /* determine rule that matches for this non-terminal */
    rule = PFlalg2sql_rule(STATE_LABEL(p), goalnt);

    /* error if a rule with value zero is determined */
    assert(rule);
    
    /* initializing the kids vector */
    for(unsigned short i = 0; i < MAX_KIDS; i++) {
        kids[i] = NULL;
    } 
   
    /* get information for dag-traversal */
    nts  = PFlalg2sql_nts[rule];

    //printf("rule: %i\n",rule);
    PFlalg2sql_kids(p, rule, kids);

    for(unsigned short i = 0; nts[i]; i++)
        reduce(kids[i], nts[i], indent++);
        
    for(unsigned short i = 0; i < indent; i++)
        printf(".");

    printf("string: %s, rule: %i\n", PFlalg2sql_string[rule],rule);
     
    switch(rule) {
        /* QUERY:    serialize(Frag,Rel)  */
        case 1:
            break;
        /* Rel:      lit_tbl              */ 
        case 2:
        {
            /* replace the algebraic expression lit_tbl, with
             * with a temporary table sql expression */
            printf("Replace lit_tbl with tmp_table.\n");
            (void)PFsql_alg_schema_conv( p->schema );
        } break;
    }
}

static void
parse(PFla_op_t *p)
{
    /* label the algebra tree to determine optimal code generation */
    PFlalg2sql_label(p);
    /* traverse algebra tree */
    reduce(p, 1, 0);
}

void
PFlalg2sql(PFla_op_t *p)
{
   parse(p);
}
/* vim:set shiftwidth=4 expandtab filetype=c: */  
