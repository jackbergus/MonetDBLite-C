%{

/**
 * @file
 *
 * Transforms the logical algebra tree into a tree that represents
 * sql statements.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2006 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 * $Id$
 */

/* always include pathfinder first */
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "lalg2sql.h"
#include "sql.h"
#include "algebra.h"
#include "alg_dag.h"
#include "mem.h"
#include "oops.h"       /* PFoops() */
/**
 * Accessors for the burg pattern matcher */ 
typedef struct PFla_op_t* NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)     ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)   ((p)->child[0])
#define RIGHT_CHILD(p)  ((p)->child[1])

/* the state, burg determines during the bottom up graph
 * traversal
 */
#define STATE_LABEL(p) ((p)->state_label)

/* if an error occurs, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start with non-terminal */
%start Query
/**
 * Node identifiers, corresponding to the node kinds in
 * include/logical.h
 */

%term serialize      =  1 /**< serialize algebra expression
                              (Placed on the very top of the tree.) */
%term lit_tbl        =  2 /**< literal table */
%term empty_tbl      =  3 /**< empty literal table */
%term attach         =  4 /**< attach constant column */
%term cross          =  5 /**< cross product (Cartesian product) */
%term eqjoin         =  6 /**< equi-join */
%term semijoin       =  7 /**< semi-join */
%term project        =  8 /**< algebra projection and renaming operator */
%term select_        =  9 /**< selection of rows where column value != 0 */
%term disjunion      = 10 /**< union two relations with same schema */
%term intersect      = 11 /**< intersect two relations with same schema */
%term difference     = 12 /**< difference of two relations w/ same schema */
%term distinct       = 13 /**< duplicate elimination operator */
%term num_add        = 20 /**< arithmetic plus operator */
%term num_subtract   = 21 /**< arithmetic minus operator */
%term num_multiply   = 22 /**< arithmetic times operator */
%term num_divide     = 23 /**< arithmetic divide operator */
%term num_modulo     = 24 /**< arithmetic modulo operator */
%term num_eq         = 25 /**< numeric equal operator */
%term num_gt         = 26 /**< numeric greater-than operator */
%term num_neg        = 27 /**< numeric negation operator */
%term bool_and       = 28 /**< boolean AND operator */
%term bool_or        = 29 /**< boolean OR operator */
%term bool_not       = 30 /**< boolean NOT operator */
%term avg            = 31 /**< operator for (partitioned) avg of a column */
%term max_           = 32 /**< operator for (partitioned) max of a column */
%term min_           = 33 /**< operator for (partitioned) min of a column */
%term sum            = 34 /**< operator for (partitioned) sum of a column */
%term count          = 35 /**< (partitioned) row counting operator */
%term rownum         = 36 /**< consecutive number generation */
%term number         = 37 /**< consecutive number generation */
%term type           = 40 /**< selection of rows where a column is of a
                                 certain type */
%term type_assert    = 41 /**< restricts the type of a relation */
%term cast           = 42 /**< type cast of an attribute */
%term seqty1         = 43 /**< test for exactly one type occurrence in one
                                 iteration (Pathfinder extension) */
%term all            = 44 /**< test if all items in an iteration are true */
%term scjoin         = 50 /**< staircase join */
%term dup_scjoin     = 51 /**< staircase join */
%term doc_tbl        = 52 /**< document relation (is also a fragment) */
%term doc_access     = 53 /**< document access necessary for pf:string-value */
%term element        = 60 /**< element-constructing operator */
%term element_tag    = 61 /**< part of the element-constructing operator;
                              connecting element tag and content;
                              due to Burg we use two "wire2" operators
                              now instead of one "wire3 operator "*/
%term attribute      = 62 /**< attribute-constructing operator */
%term textnode       = 63 /**< text node-constructing operator */
%term docnode        = 64 /**< document node-constructing operator */
%term comment        = 65 /**< comment-constructing operator */
%term processi       = 66 /**< processing instruction-constr. operator */
%term merge_adjacent = 67 /**< operator for pf:merge-adjacent-text-nodes
                              builtin function */
%term roots_         = 70 /**< algebraic repres. of the roots of newly
                         created xml nodes (e.g. element());
                         schema: iter | pos | item */
/* all operators below represent xml node fragments with no schema */
%term fragment       = 71 /**< representation of a node fragment */
%term frag_union     = 72 /**< special node type used to form an algebraic
                             union of fragments */
%term empty_frag     = 73 /**< representation of an empty fragment */

%term cond_err       = 80 /**< facility to trigger runtime errors */
%term rec_fix        = 81 /**< operator representing a tail recursion */
%term rec_param      = 82 /**< list of parameters of the recursion */
%term rec_nil        = 83 /**< end of the list of parameters of the 
                             recursion */
%term rec_arg        = 84 /**< reference to the arguments of a parameter
                             in the recursion */
%term rec_base       = 85 /**< base of the DAG describing the recursion */

%term proxy          = 96 /**< proxy operator that represents a group
                              of operators */
%term proxy_base     = 97 /**< completes the content of the proxy 
                              (a virtual base table) */
%term cross_mvd      = 98 /**< clone column aware cross product */
%term eqjoin_unq     = 99 /**< clone column aware equi-join */                            
/* builtin support for XQuery functions */
%term concat         =100 /**< fn:concat */
%term contains       =101 /**< fn:contains */
%term string_join    =102 /**< fn:string-join */

%term dummy          =120 /**< dummy operator that does nothing */

%%

Query:  serialize (Frag, Rel)                     =   1 (10);

Rel:    lit_tbl                                   =   2 (10);
Rel:    attach (Rel)                              =   3 (10);
Rel:    cross (Rel, Rel)                          =   4 (10);
Rel:    cross (Rel, lit_tbl)                      =   5 (10);
Rel:    cross (lit_tbl, Rel)                      =   6 (10);
Rel:    eqjoin (Rel, Rel)                         =   8 (10);
Rel:    project (Rel)                             =  10 (10);
Rel:    project (attach (Rel))                    =  11 (10);
Rel:    project (project (Rel))                   =  13  (1);
Rel:    select_ (Rel)                             =  19 (10);
Rel:    disjunion (Rel, Rel)                      =  20 (10);
Rel:    disjunion (EmptyRel, Rel)                 =  21  (5);
Rel:    disjunion (Rel, EmptyRel)                 =  22  (5);
Rel:    intersect (Rel, Rel)                      =  23 (10);
Rel:    difference (Rel, Rel)                     =  24 (10);
Rel:    difference (Rel, EmptyRel)                =  25  (5);
Rel:    distinct (Rel)                            =  26 (10);
Rel:    distinct (scjoin (Frag, Rel))             =  27 (5);
Rel:    num_add (Rel)                             =  30 (10);
Rel:    num_subtract (Rel)                        =  31 (10);
Rel:    num_multiply (Rel)                        =  32 (10);
Rel:    num_divide (Rel)                          =  33 (10);
Rel:    num_modulo (Rel)                          =  34 (10);
Rel:    num_neg (Rel)                             =  35 (10);
Rel:    num_gt (Rel)                              =  36 (10);
Rel:    num_eq (Rel)                              =  37 (10);
Rel:    bool_and (Rel)                            =  38 (10);
Rel:    bool_or (Rel)                             =  39 (10);
Rel:    bool_not (Rel)                            =  40 (10);
Rel:    avg (Rel)                                 =  41 (10);
Rel:    max_ (Rel)                                =  42 (10);
Rel:    min_ (Rel)                                =  43 (10);
Rel:    sum (Rel)                                 =  44 (10);
Rel:    count (Rel)                               =  45 (10);
Rel:    rownum (Rel)                              =  50 (10);
Rel:    number (Rel)                              =  51 (10);
Rel:    number (number (Rel))                     =  52 (10);
Rel:    number (project (number (Rel)))           =  53 (10);
Rel:    type (Rel)                                =  54 (10);
Rel:    type_assert (Rel)                         =  55 (10);
Rel:    cast (cast (Rel))                         =  56 (10);
Rel:    cast (project (cast (Rel)))               =  57 (10);
Rel:    cast (Rel)                                =  58 (10);
Rel:    seqty1 (Rel)                              =  59 (10);
Rel:    all (Rel)                                 =  60 (10);
Rel:    ScjRel                                    =  61 (10);
ScjRel: scjoin (Frag, Rel)                        =  62 (10);
ScjRel: scjoin (Frag, ScjRel)                     =  63 (10);
ScjRel: scjoin (Frag, distinct (Rel))             =  64 (10);
Rel:    doc_access (Frag, Rel)                    =  65 (10);

Rel:    roots_ (doc_tbl (Rel))                    =  70 (10);
Rel:    roots_ (element (Frag,                       
                         element_tag (Rel, Rel))) =  71 (10);
Rel:    roots_ (attribute (Rel))                  =  72 (10);
Rel:    roots_ (textnode (Rel))                   =  73 (10);
Rel:    roots_ (docnode (Frag, Rel))              =  74 (10);
Rel:    roots_ (comment (Rel))                    =  75 (10);
Rel:    roots_ (processi (Rel))                   =  76 (10);
Rel:    roots_ (merge_adjacent (Frag, Rel))       =  77 (10);

Rel:    cond_err (Rel, Rel)                       =  80 (10);

Rel:    rec_fix (Rec, Rel)                        =  81 (10);
Rel:    rec_base                                  =  82 (10);
Rec:    rec_param (Arg, Rec)                      =  83 (10);
Rec:    rec_nil                                   =  84 (10);
Arg:    rec_arg (Rel, Rel)                        =  85 (10);

Rel:    concat (Rel)                              =  86 (10);
Rel:    contains (Rel)                            =  87 (10);
Rel:    string_join (Rel, Rel)                    =  88 (10);
Rel:    dummy (Rel)                               =  89 (10);

Rel:    EmptyRel                                  =  90  (0);
Rel:    semijoin(Rel, Rel)                        = 203  (0);


Frag:    fragment (doc_tbl (Rel))                 = 100 (10);
Frag:    fragment (element (Frag, 
                            element_tag (Rel,
                                         Rel)))   = 101 (10);
Frag:    fragment (attribute (Rel))               = 102 (10);
Frag:    fragment (textnode (Rel))                = 103 (10);
Frag:    fragment (docnode (Frag, Rel))           = 104 (10);
Frag:    fragment (comment (Rel))                 = 105 (10);
Frag:    fragment (processi (Rel))                = 106 (10);
Frag:    fragment (merge_adjacent (Frag, Rel))    = 107 (10);

Frag:    frag_union (Frag, Frag)                  = 111 (10);
Frag:    empty_frag                               = 112 (10);


EmptyRel:    empty_tbl                            = 120  (0);

EmptyRel:    attach (EmptyRel)                    = 121  (0);
EmptyRel:    cross (EmptyRel, Rel)                = 122  (0);
EmptyRel:    cross (Rel, EmptyRel)                = 123  (0);
EmptyRel:    eqjoin (EmptyRel, Rel)               = 124  (0);
EmptyRel:    eqjoin (Rel, EmptyRel)               = 125  (0);
EmptyRel:    project (EmptyRel)                   = 126  (0);
EmptyRel:    select_ (EmptyRel)                   = 127  (0);
EmptyRel:    disjunion (EmptyRel, EmptyRel)       = 130  (0);
EmptyRel:    intersect (EmptyRel, Rel)            = 131  (0);
EmptyRel:    intersect (Rel, EmptyRel)            = 132  (0);
EmptyRel:    difference (EmptyRel, Rel)           = 133  (0);
EmptyRel:    distinct (EmptyRel)                  = 134  (0);
EmptyRel:    num_add (EmptyRel)                   = 140  (0);
EmptyRel:    num_subtract (EmptyRel)              = 141  (0);
EmptyRel:    num_multiply (EmptyRel)              = 142  (0);
EmptyRel:    num_divide (EmptyRel)                = 143  (0);
EmptyRel:    num_modulo (EmptyRel)                = 144  (0);
EmptyRel:    num_neg (EmptyRel)                   = 145  (0);
EmptyRel:    num_gt (EmptyRel)                    = 146  (0);
EmptyRel:    num_eq (EmptyRel)                    = 147  (0);
EmptyRel:    bool_and (EmptyRel)                  = 148  (0);
EmptyRel:    bool_or (EmptyRel)                   = 149  (0);
EmptyRel:    bool_not (EmptyRel)                  = 150  (0);
EmptyRel:    avg (EmptyRel)                       = 151  (0);
EmptyRel:    max_ (EmptyRel)                      = 152  (0);
EmptyRel:    min_ (EmptyRel)                      = 153  (0);
EmptyRel:    sum (EmptyRel)                       = 154  (0);
EmptyRel:    count (EmptyRel)                     = 155  (0);
EmptyRel:    rownum (EmptyRel)                    = 160  (0);
EmptyRel:    number (EmptyRel)                    = 161  (0);
EmptyRel:    type (EmptyRel)                      = 162  (0);
EmptyRel:    type_assert (EmptyRel)               = 163  (0);
EmptyRel:    cast (EmptyRel)                      = 164  (0);
EmptyRel:    seqty1 (EmptyRel)                    = 165  (0);
EmptyRel:    all (EmptyRel)                       = 166  (0);
EmptyRel:    scjoin (Frag, EmptyRel)              = 170  (0);
EmptyRel:    doc_access (Frag, EmptyRel)          = 171  (0);
EmptyRel:    roots_ (element (Frag, 
                              element_tag (EmptyRel,
                                          Rel)))  = 180  (0);
EmptyRel:    roots_ (attribute (EmptyRel))        = 182  (0);
EmptyRel:    roots_ (textnode (EmptyRel))         = 184  (0);
EmptyRel:    roots_ (comment (EmptyRel))          = 185  (0);
EmptyRel:    roots_ (processi (EmptyRel))         = 186  (0);
EmptyRel:    roots_ (merge_adjacent (Frag,                   
                                     EmptyRel))   = 187  (0);
EmptyRel:    cond_err (EmptyRel, Rel)             = 190  (0);
EmptyRel:    concat (EmptyRel)                    = 200  (0);
EmptyRel:    string_join (EmptyRel, Rel)          = 201  (0);
EmptyRel:    dummy (EmptyRel)                     = 202  (0);

%%

#include "sql_mnemonic.h"

#define MAX_KIDS 2 

static PFalg_simple_type_t type_of(PFla_op_t *, PFalg_att_t);
static PFsql_t* bin_arith(PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p);
static PFsql_t* bin_comp(PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p);
static void column_env_copy(PFarray_t *srccolmap, PFarray_t *destcolmap);
static void where_env_copy(PFarray_t *srcwheremap,
        PFarray_t *destwheremap);

/** 
 * We collect the SQL statements during compilation here
 */
static PFsql_t *sql_stmts = NULL;

#define execute(...) sql_stmts = (sql_stmts == NULL)? \
                                 common_table_expr( __VA_ARGS__ ):\
                                 common_table_expr(sql_stmts, __VA_ARGS__)

static PFsql_t* literal(PFalg_atom_t);

/*
 * Easily access subtree parts.
 */
/** starting from p, make a left step */
#define L(p)      (LEFT_CHILD(p))
/** starting from p, make a right step */
#define R(p)      (RIGHT_CHILD(p))
#define LL(p)     L(L(p))
#define RL(p)     R(L(p))
/** Macro determining if a node is just visited */
#define SEEN(p)   ((p)->bit_dag)
/** a node is dirty and has to be bind to
  a table name */
#define DIRTY(p)  (((p)->refctr > 1) \
                  || (((p)->sql_ann->sfw)? \
                     ((p)->sql_ann->sfw->kind != sql_select):true) \
                  || ((p)->dirty == true))

/*................. SQL Variable ................ */
    
/**
 * Represents a pseudo SQL table_name.
 *
 * @note
 *   The variable has a name (that is automatically generated).
 */
struct sql_table_name_t {
    PFsql_ident_t    name;
};
typedef struct sql_table_name_t sql_table_name_t;

/**
 * Return a new valid variable. We will try to reuse an old one
 */
static sql_table_name_t*
sql_table_name_new()
{
    static unsigned int varno =  PF_SQL_RES_TABLE_COUNT;
    sql_table_name_t           *var  =
       (sql_table_name_t*)PFmalloc( sizeof( sql_table_name_t ) );
    
    var->name = varno++;
    
    return var;
}

/* ........ SQL Loc Var ................*/

struct sql_correlation_name_t {
    PFsql_ident_t    name;
};
typedef struct sql_correlation_name_t sql_correlation_name_t;

static sql_correlation_name_t*
sql_correlation_name_new(unsigned int cnt)
{
    sql_correlation_name_t  *var = NULL;
    var = (sql_correlation_name_t*)
        PFmalloc( sizeof( sql_correlation_name_t ) );
    var->name = cnt;
    return var;
}

/* .............. SQL Columns ................ */

struct sql_column_name_t {
    PFsql_ident_t ident;
};
typedef struct sql_column_name_t sql_column_name_t;

struct sql_column_env_t {
    PFalg_simple_type_t type;
    PFalg_att_t         att;
    PFsql_t             *expression;
};
typedef struct sql_column_env_t sql_column_env_t;

static sql_column_name_t*
sql_column_name_new(PFalg_att_t att, PFalg_simple_type_t ty)
{
    unsigned int i;
    static unsigned int varno = PF_SQL_RES_COLUMN_COUNT;
    sql_column_name_t *ret = NULL; 

    i = 0; /* satisfy pick compilers */
    
    /* bit position of attribute a. */
    unsigned int a = 0;
    /* bit position of type t */
    unsigned int t = 0;

    /* determine the bit position of att */
    if( att != (unsigned int)0 ) {
        for(PFalg_att_t attmask=1, i = 0;
                attmask; attmask<<=1, i++) {
            if( attmask & att) {
                a = i + 1;
                break;
            }
        }
    }

    /* determine bit position of type */
    for(PFalg_simple_type_t tmask = 1, i = 0;
            tmask; tmask<<=1, i++) {
        if( tmask & ty ) {
            t = i;
            break;
        }
    }

    ret = (sql_column_name_t*)
        PFmalloc( sizeof(sql_column_name_t) );
    
    *ret = (sql_column_name_t) {
        .ident = a + (t << ATT_BITS) +
            ((varno++) << (ATT_BITS+TYPE_BITS))
    };

    return ret;
}

static PFarray_t*
sql_column_env_new(void)
{
    return PFarray( sizeof( sql_column_env_t ) );
}

void
sql_column_env_add(PFarray_t *env, PFalg_att_t att,
        PFalg_simple_type_t ty, PFsql_t *expr)
{
    assert( ty == aat_nat || ty == aat_int || ty == aat_str );

    *(sql_column_env_t*)PFarray_add(env) =
        (sql_column_env_t) { .type = ty, .att = att,
            .expression = expr };
}

sql_column_env_t
sql_column_env_at(const PFarray_t *env, unsigned int i)
{
    assert( i < PFarray_last( env ) );

    return *(sql_column_env_t*)PFarray_at((PFarray_t*)env, i);
}

unsigned int
sql_column_env_count(const PFarray_t *env)
{
    return PFarray_last(env);
}

static PFsql_t*
sql_expression_unsafe(const PFarray_t *env, PFalg_att_t att,
        PFalg_simple_type_t ty)
{
    for( unsigned int i = 0; i < PFarray_last(env); i++) {
        sql_column_env_t entry = 
            *(sql_column_env_t*)PFarray_at((PFarray_t*)env, i);

        if(entry.att == att && entry.type == ty )
            return entry.expression;
    }
    return NULL;
}

static PFsql_t*
sql_expression(const PFarray_t *env, PFalg_att_t att,
        PFalg_simple_type_t ty)
{
    PFsql_t *expr =
        sql_expression_unsafe(env, att, ty);

    if(expr)
        return expr;

    PFoops( OOPS_FATAL,
            "attribute '%s' with type '0x%X' not found in environment",
            PFatt_str(att), ty);

    return NULL; /* satisfy picky compilers */
}

static void
sql_override_expr(PFarray_t *env, PFalg_att_t att,
        PFalg_simple_type_t ty, PFsql_ident_t colname)
{
    for( unsigned int i = 0; i < PFarray_last(env); i++) {
        sql_column_env_t *entry = 
            (sql_column_env_t*)PFarray_at((PFarray_t*)env, i);

        if(entry->att == att && entry->type == ty ) {
            entry->expression = column_name(colname);
            return;
        }
    }

    PFoops(OOPS_FATAL, "attribute '%s' with type '%u' not found"
            " in environment", PFatt_str(att), ty);
}

struct sql_where_env_t {
    PFsql_t *expression;
};
typedef struct sql_where_env_t sql_where_env_t;

static PFarray_t*
sql_where_env_new(void)
{
    return PFarray( sizeof( sql_where_env_t ) );
}

sql_where_env_t
sql_where_env_at(const PFarray_t *env, unsigned int i)
{
    assert( i < PFarray_last( env ) );

    return *(sql_where_env_t*)PFarray_at((PFarray_t*)env, i);
}

static void
sql_where_env_add(PFarray_t *env, PFsql_t *expr)
{
    *(sql_where_env_t*)PFarray_add(env) =
        (sql_where_env_t) {
            .expression = expr};
}

static PFsql_alg_ann_t*
sql_alg_ann_new(void)
{
    PFsql_alg_ann_t *ret =
        (PFsql_alg_ann_t*)PFmalloc( sizeof(PFsql_alg_ann_t) );

    ret->tabname = NULL;
    ret->sfw = NULL;
    ret->colmap = sql_column_env_new(); 
    ret->wheremap = sql_where_env_new();

    return ret;
}

/**
 * Does a DAG preorder traversal and determines the incoming
 * edges of each node.
 */
static void
inc_refctr(PFla_op_t *n)
{
    assert( n );

    /* count number of incoming edges */
    n->refctr++;

    /* only descend once */
    if( SEEN(n) )
        return;
    else
        SEEN(n) = true;

    for( unsigned int i = 0; i < PFLA_OP_MAXCHILD && n->child[i]; i++ )
        inc_refctr( n->child[i] );
}

static bool
binding(PFsql_t *n)
{
    assert( n );

    if( n->kind == sql_bind)
        return true;
    else {
        for( unsigned int i = 0; i < PFSQL_OP_MAXCHILD &&
                n->child[i]; i++) {
            return binding( n->child[i] );
        }
    }
    return false;
}

/**
 * Reduce function. This is the core of this source file, containing
 * the actions that should be executed whenever a burg-pattern matches.
 */
static void
reduce(PFla_op_t *p, int goalnt)
{
    int           rule;             /* rule number that matches this node */
    short         *nts;             /* target non-terminals for the leaf node
                                       of the current rule */
    PFsql_t    *sql_stmt;        /* SQL statment we construct in this
                                       function */
    PFla_op_t     *kids[MAX_KIDS];  /* leaf node of this rule */
    bool topdown;

    sql_stmt = NULL;

    if( p->sql_ann ) {
        return;
    }
    
    /* determine rule that matches for this non-terminal */
    rule = PFlalg2sql_rule(STATE_LABEL(p), goalnt);

    /* error if a rule with value zero is determined */
    assert(rule);
    
    /* initializing the kids vector */
    for(unsigned short i = 0; i < MAX_KIDS; i++) {
        kids[i] = NULL;
    } 
   
    /* get information for dag-traversal */
    nts  = PFlalg2sql_nts[rule];
    PFlalg2sql_kids(p, rule, kids);

    switch( rule ) {
        /* Query:    serialize(Frag,Rel)  */
        case 1:
        case 4:
        /* Rel: eqjoin(Rel) */
        case 8:
        /* Rel: semijoin(Rel) */
        case 203:
        {
            topdown = true;
        } break;
        default:
        {
            topdown = false;
        } break;
    }

    if( !topdown ) { 
        for(unsigned short i = 0; nts[i]; i++)
            reduce(kids[i], nts[i]);
    }
        
    if( p->sql_ann ) {
        return;
    }

    /* initialize SQL annotations */
    p->sql_ann = sql_alg_ann_new(); 

#ifndef NDEBUG
    execute( comment( "Begin rule (reduce): \"%s\" (%i)",
                PFlalg2sql_string[rule], rule ) );
#endif
        
    switch(rule) {
        /* Query:    serialize(Frag,Rel)  */
        case 1:
        {
            for(unsigned short i = 0; nts[i]; i++)
            {
                 /* make subsequent nodes of serialize dirty to force
                    a binding */
                 kids[i]->dirty = true;
                 reduce(kids[i], nts[i]);
            }
            sql_stmts = with(sql_stmts, R(p)->sql_ann->sfw); 
        } break;
        /* empty frag */
        case 112:
        {
        } break;
        /* Rel:      lit_tbl              */ 
        case 2:
        {
#ifndef NDEBUG
            execute( comment( "create SQL temporary table" ) );
#endif
            for( unsigned int row = 0;
                    row < p->sem.lit_tbl.count; row++ ) {
                for(unsigned int col = 0;
                        col < p->schema.count; col++) {
                    for(PFalg_simple_type_t t = 1; t; t <<= 1) {
                        if( t & p->schema.items[col].type ) {
                            sql_column_env_add(p->sql_ann->colmap,
                                   p->schema.items[col].name,
                                   t,
                                   ( t == p->sem.lit_tbl.tuples[row]
                                           .atoms[col].type )?
                                           literal(p->sem.lit_tbl.tuples[row]
                                               .atoms[col]):
                                           cast(null(),type(t))
                                    );
                        }       
                    }
                }
            }
            
            /* FIXME there has to be an union to support tables */
            sql_stmt = select
                       (
                        NULL, /* no selectlist provided */
                        from_list
                        (
                         tab_name(schema(SYSIBM), sysdummy1())
                        ),
                        NULL
                       );
        } break;
        /* Rel: attach(Rel) */
        case 3:
        {
#ifndef NDEBUG
            execute( comment( "Attach new column" ));
#endif
            assert( L(p)->sql_ann->sfw != NULL );

            /* copy all existing expressions */
            for(unsigned int i = 0;
                    i < PFarray_last(L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at(
                        L(p)->sql_ann->colmap,
                        i);
                sql_column_env_add(p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }
            /* copy the existing wheremap */
            where_env_copy( L(p)->sql_ann->wheremap,
                    p->sql_ann->wheremap);

            /* add expression for attach to the column environment */
            sql_column_env_add(p->sql_ann->colmap,
                    p->sem.attach.attname,
                    p->sem.attach.value.type,
                    literal(p->sem.attach.value));

            if( L(p)->sql_ann->sfw ) {
                sql_stmt = select
                    (
                     NULL, /* no selectlist provided */
                     L(p)->sql_ann->sfw->sem.select.from_list,
                     NULL
                    );
            }
        } break;
        /* Rel:      cross(Rel,Rel) */
        case 4:
        {
#ifndef NDEBUG
            execute( comment( "cross two relations" ) );
#endif
            for(unsigned short i = 0; nts[i]; i++)
            {
                 /* make subsequent nodes of cross dirty to force
                    a binding */
                 kids[i]->dirty = true;
                 reduce(kids[i], nts[i]);
            }

            /* copy all existing expressions */
            for(unsigned int i = 0;
                    i < PFarray_last(L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at(
                        L(p)->sql_ann->colmap,
                        i);
                sql_column_env_add(p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }
            for(unsigned int i = 0;
                    i < PFarray_last(R(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at(
                        R(p)->sql_ann->colmap,
                        i);
                if( !sql_expression_unsafe(p->sql_ann->colmap,
                            entry.att,entry.type) ) {
                    sql_column_env_add(p->sql_ann->colmap,
                            entry.att, entry.type,
                            entry.expression);
                } 
            }

            if( L(p)->sql_ann->tabname && R(p)->sql_ann->tabname )
            sql_stmt = select
                (
                 NULL,
                 from_list
                 (
                   L(p)->sql_ann->tabname,
                   R(p)->sql_ann->tabname
                 ),
                 NULL
                );

        } break;
        case 203:
        case 8:
        {
            for(unsigned short i = 0; nts[i]; i++)
            {
                 /* make subsequent nodes of cross dirty to force
                    a binding */
                 kids[i]->dirty = true;
                 reduce(kids[i], nts[i]);
            }

            /* copy all existing expressions */
            for(unsigned int i = 0;
                    i < PFarray_last(L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at(
                        L(p)->sql_ann->colmap,
                        i);
                sql_column_env_add(p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            for(unsigned int i = 0;
                    i < PFarray_last(R(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at(
                        R(p)->sql_ann->colmap,
                        i);
                if( !sql_expression_unsafe(p->sql_ann->colmap,
                            entry.att,entry.type) ) {
                    sql_column_env_add(p->sql_ann->colmap,
                            entry.att, entry.type,
                            entry.expression);
                } 
            }

            sql_where_env_add(p->sql_ann->wheremap,
                    eq
                    (
                     sql_expression(L(p)->sql_ann->colmap,
                         p->sem.eqjoin.att1,
                         type_of(L(p), p->sem.eqjoin.att1)),
                     sql_expression(R(p)->sql_ann->colmap,
                         p->sem.eqjoin.att2,
                         type_of(R(p), p->sem.eqjoin.att2))
                    ));

            if( L(p)->sql_ann->tabname && R(p)->sql_ann->tabname )
            sql_stmt = select
                (
                 NULL,
                 from_list
                 (
                   L(p)->sql_ann->tabname,
                   R(p)->sql_ann->tabname
                 ),
                 NULL
                );
        } break;
        /* Rel:      select_(Rel) */
        case 19:
        {
            /* copy all existing expressions */
            for( unsigned int i = 0; i < PFarray_last(
                        L(p)->sql_ann->colmap); i++ ) {
                sql_column_env_t entry = sql_column_env_at(
                        L(p)->sql_ann->colmap,
                        i);
                sql_column_env_add(p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            /* copy existing wheremap */
            where_env_copy(L(p)->sql_ann->wheremap,
                    p->sql_ann->wheremap);

            sql_where_env_add(p->sql_ann->wheremap,
                    sql_expression( p->sql_ann->colmap,
                        p->sem.select.att,
                        type_of(p, p->sem.select.att)));

            if( L(p)->sql_ann->sfw )
                sql_stmt = select
                    (
                     NULL,
                     L(p)->sql_ann->sfw->sem.select.from_list,
                     NULL
                    );
        } break;
        /* fragunion */
        case 111:
        /* Rel:      disjunion(Rel,Rel) */
        case 20:
        {
#ifndef NDEBUG 
            execute( comment("union two tables") );
#endif

            PFsql_t *selectlist1 = select_list_empty();
            PFsql_t *selectlist2 = select_list_empty();
            for(unsigned int i = 0; i < p->schema.count; i++) {
                for(PFalg_simple_type_t t=1; t; t<<=1) {
                    if( t & p->schema.items[i].type ) {
                        /*
                         * Type t is in the result relation.
                         * See if it is also in the left
                         * operand.
                         */
                        if( !(t & type_of(L(p), 
                                    p->schema.items[i].name)) ) {
                            /* add null to the colmap */
                            sql_column_env_add(
                                    L(p)->sql_ann->colmap,
                                    p->schema.items[i].name,
                                    t,
                                    cast(null(),type(t)));
                        }

                        PFsql_t *sqlnode = 
                            sql_expression(
                                    L(p)->sql_ann->colmap,
                                    p->schema.items[i].name, t);

                        selectlist1 = select_list_add(
                                selectlist1,
                                (sqlnode->kind == sql_clmn_name)?
                                sqlnode:
                                column_assign
                                (
                                 sqlnode,
                                 column_name(
                                     sql_column_name_new(
                                         p->schema.items[i].name,
                                         t)->ident
                                     )
                                ));
                                

                        /*
                         * Type t is in the result relation.
                         * See if it is also in the left
                         * operand.
                         */
                        if( !(t & type_of(R(p),
                                        p->schema.items[i].name)) ) {
                            /* add null to the colmap */
                            sql_column_env_add(
                                    R(p)->sql_ann->colmap,
                                    p->schema.items[i].name,
                                    t,
                                    cast(null(),type(t)));
                        }

                        sqlnode =
                            sql_expression(
                                    R(p)->sql_ann->colmap,
                                    p->schema.items[i].name, t);

                        selectlist2 = select_list_add(
                                selectlist2,
                                (sqlnode->kind == sql_clmn_name)?
                                sqlnode:
                                column_assign
                                (
                                 sqlnode,
                                 column_name(
                                     sql_column_name_new(
                                         p->schema.items[i].name,
                                         t)->ident
                                     )
                                ));

                        sql_column_env_add(
                                p->sql_ann->colmap,
                                p->schema.items[i].name,
                                t,
                                column_name(
                                    sql_column_name_new(
                                        p->schema.items[i].name,
                                        t)->ident));
                    }
                }
            }

            PFsql_t *wherelist1 = where_list_empty();
            PFsql_t *wherelist2 = where_list_empty();

            for( unsigned int i = 0; i < PFarray_last(
                        L(p)->sql_ann->wheremap); i++) {
                sql_where_env_t entry = sql_where_env_at(
                        L(p)->sql_ann->wheremap, i);
                wherelist1 = where_list_add(wherelist1,
                            entry.expression);
            }

            for( unsigned int i = 0; i < PFarray_last(
                        R(p)->sql_ann->wheremap); i++) {
                sql_where_env_t entry = sql_where_env_at(
                    R(p)->sql_ann->wheremap, i);
                wherelist2 = where_list_add(wherelist2,
                        entry.expression);
            }

            /* create an union from two selects */
            if( L(p)->sql_ann->sfw && R(p)->sql_ann->sfw )
                sql_stmt =
                    disjunion
                    (
                     select
                     (
                      selectlist1,
                      L(p)->sql_ann->sfw->sem.select.from_list,
                      (wherelist1->kind != sql_list_terminator)?
                      wherelist1:NULL
                     ),
                     select
                     (
                      selectlist2,
                      R(p)->sql_ann->sfw->sem.select.from_list,
                      (wherelist2->kind != sql_list_terminator)?
                      wherelist2:NULL
                     ) 
                    );
        } break;
        case 26:
        {
            /* copy all existing expressions */
            for( unsigned int i = 0; i < PFarray_last(
                        L(p)->sql_ann->colmap); i++ ) {
                sql_column_env_t entry = sql_column_env_at(
                        L(p)->sql_ann->colmap,
                        i);
                sql_column_env_add(p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            /* copy existing wheremap */
            where_env_copy(L(p)->sql_ann->wheremap,
                    p->sql_ann->wheremap);

            sql_stmt = select_distinct
                (
                 NULL,
                 L(p)->sql_ann->sfw->sem.select.from_list,
                 NULL
                );
            p->dirty = true;
        } break;
        /* Rel: project(Rel) */
        case 10:
        {
#ifndef NDEBUG
            execute( comment( "projection" ) );
#endif

            for( unsigned int i=0; i < p->sem.proj.count; i++) {
                for(PFalg_simple_type_t t=1; t; t<<=1) {
                    if(t & type_of(L(p), p->sem.proj.items[i].old)) {
                            PFsql_t *sqlnode = sql_expression(
                                L(p)->sql_ann->colmap,
                                p->sem.proj.items[i].old,
                                t);
                            sql_column_env_add(
                                p->sql_ann->colmap,
                                p->sem.proj.items[i].new, 
                                t,
                                sqlnode);
                    }
                }
            }

            where_env_copy(L(p)->sql_ann->wheremap,
                    p->sql_ann->wheremap);

            if( L(p)->sql_ann->sfw )
            sql_stmt = select
                (
                 NULL, /* no selectlist provided */
                 L(p)->sql_ann->sfw->sem.select.from_list,
                 NULL
                );
        } break;
        /* Rel:         num_add(Rel) */
        case 30:
        {
#ifndef NDEBUG
            execute( comment( "num_add" ) );
#endif
            if( L(p)->sql_ann->sfw )
            sql_stmt = bin_arith(PFsql_add, p);
        } break;
        /* Rel:         num_subtract(Rel) */
        case 31:
        {
#ifndef NDEBUG
            execute( comment( "num_subtract" ) );
#endif
            if( L(p)->sql_ann->sfw )
            sql_stmt = bin_arith(PFsql_sub, p);
        } break;
        /* Rel:         num_multiply(Rel) */
        case 32:
        {
#ifndef NDEBUG
            execute( comment( "num_multiply" ) );
#endif
            if( L(p)->sql_ann->sfw )
                sql_stmt = bin_arith(PFsql_mul, p);
        } break;
        /* Rel: num_gt(Rel) */
        case 36:
        {
             if( L(p)->sql_ann->sfw )
                sql_stmt = bin_comp(PFsql_gt, p);
        } break;
        /* Rel: num_eq(Rel) */
        case 37:
        {
#ifndef NDEBUG
            execute( comment( "num_eq" ) );    
#endif
            if( L(p)->sql_ann->sfw )
                sql_stmt = bin_comp(PFsql_eq, p);
        } break;
        /* Rel:      rownum(Rel) */
        case 50:
        {
             for( unsigned int i = 0; i < p->schema.count; i++ ) {
                 for( PFalg_att_t t = 1; t; t <<= 1 ) {
                     if(t & p->schema.items[i].type) {
                         
                         if( p->schema.items[i].name ==
                                 p->sem.rownum.attname ) {

                             PFsql_t *srtbylist =
                                 sortkey_expressions_empty();
                             for( unsigned int j = 0; j < p->sem.rownum.
                                     sortby.count; j++ ) {
                                 srtbylist = 
                                     sortkey_expressions_add(
                                             srtbylist,
                                         sql_expression(
                                             L(p)->sql_ann->
                                             colmap, p->sem.rownum.
                                             sortby.atts[j],
                                             type_of(
                                                 L(p), p->sem.rownum
                                                 .sortby.atts[j])));
                             }
                             sql_column_env_add( p->sql_ann->colmap,
                                     p->schema.items[i].name,
                                     t,
                                     over
                                     (
                                      rownumber(),
                                      window_clause
                                      (
                                       (p->sem.rownum.part == 0)?
                                       NULL:
                                       partition
                                       (
                                        part_expressions
                                        ( 
                                         sql_expression( L(p)->sql_ann->
                                             colmap, p->sem.rownum.part,
                                                type_of( L(p),
                                                 p->sem.rownum.part))
                                        )
                                       ),
                                       order_by
                                       (
                                        srtbylist
                                       )
                                      )
                                     ));
                         }
                         else {
                             PFsql_t *sqlnode =
                                 sql_expression(L(p)->sql_ann->colmap,
                                         p->schema.items[i].name,
                                         t);
                             sql_column_env_add( p->sql_ann->colmap,
                                     p->schema.items[i].name,
                                     t,
                                     sqlnode );
                         }
                     }
                 }
             }

             where_env_copy( L(p)->sql_ann->wheremap, 
                     p->sql_ann->wheremap);
            
             if( L(p)->sql_ann->sfw )
                 sql_stmt = select
                     (
                      NULL,
                      L(p)->sql_ann->sfw->sem.select.from_list,
                      NULL
                     );
        } break;
        case 51:
        {
               for( unsigned int i = 0; i < p->schema.count; i++ ) {
                 for( PFalg_att_t t = 1; t; t <<= 1 ) {
                     if(t & p->schema.items[i].type) {
                         
                         if( p->schema.items[i].name ==
                                 p->sem.number.attname ) {

                             sql_column_env_add( p->sql_ann->colmap,
                                     p->schema.items[i].name,
                                     t,
                                     over
                                     (
                                      rownumber(),
                                      window_clause
                                      (
                                       (p->sem.number.part == 0)?
                                       NULL:
                                       partition
                                       (
                                        part_expressions
                                        ( 
                                         sql_expression( L(p)->sql_ann->
                                             colmap, p->sem.number.part,
                                                type_of( L(p),
                                                 p->sem.number.part))
                                        )
                                       ),
                                       NULL
                                      )
                                     ));
                         }
                         else {
                             PFsql_t *sqlnode =
                                 sql_expression(L(p)->sql_ann->colmap,
                                         p->schema.items[i].name,
                                         t);
                             sql_column_env_add( p->sql_ann->colmap,
                                     p->schema.items[i].name,
                                     t,
                                     sqlnode );
                         }
                     }
                 }
             }

             where_env_copy( L(p)->sql_ann->wheremap, 
                     p->sql_ann->wheremap);
            
             if( L(p)->sql_ann->sfw )
                 sql_stmt = select
                     (
                      NULL,
                      L(p)->sql_ann->sfw->sem.select.from_list,
                      NULL
                     );
        } break;
        default:
        {
            /** TODO add OOPS here to indicate an unimplemented rule */
            PFoops( OOPS_FATAL,
                    "Logical algebra rule (%u) not supported by "
                    "SQL generation", rule);
        } break;
    }

    /* override sfw only when is not dirty */
    if( sql_stmt ) {
        p->sql_ann->sfw = sql_stmt;
        p->sql_ann->sfw = ( DIRTY(p) )?NULL:sql_stmt;
    }
 
#ifndef NDEBUG
    if( p->sql_ann->sfw ) 
        execute( comment( "dirty node: \"%s\"",
                    DIRTY(p)?"yes":"no" ) ); 
#endif

    /* BINDING */
    /* execute the statement at the end if the node is dirty,
       and bind it to a new SQL variable */
    if( sql_stmt )
    if( DIRTY(p) ) {
#ifndef NDEBUG
        execute( comment( "Dirty node -> bind it" ) );
#endif
        /* create a new table name for binding */ 
        sql_table_name_t   *newvar = sql_table_name_new();
        /* bind the new variable to the sql annotation */
        p->sql_ann->tabname = table_name_default(newvar->name);
        
        /* first selectlist for select statement in p */
        PFsql_t* selectlist1 = select_list_empty();
        PFsql_t* selectlist2 = select_list_empty();
        PFsql_t* columnlist  = column_list_empty();
        PFsql_t* wherelist   = where_list_empty();
 
        for( unsigned int i = 0;
                i < PFarray_last(p->sql_ann->wheremap); i++ ) {
            sql_where_env_t entry = sql_where_env_at(
                    p->sql_ann->wheremap, i);
            wherelist = where_list_add(wherelist,
                        entry.expression);
        }
        
        for( unsigned int i = 0; i < p->schema.count; i++ ) {
            for(PFalg_simple_type_t t = 1; t; t <<= 1) {
                if( t & p->schema.items[i].type ) {
                    
                    /* get the sql operation bound to
                     * att/type tuple */
                    PFsql_t   *sqlnode = sql_expression(
                            p->sql_ann->colmap,
                            p->schema.items[i].name,
                            t);
                    
                    sql_column_name_t *colname =
                        (sqlnode->kind == sql_clmn_name)?
                        NULL:sql_column_name_new(
                                p->schema.items[i].name,
                                t);

                    /* add the sql operation to the select list */
                    selectlist1 = select_list_add(selectlist1,
                            (sqlnode->kind == sql_clmn_name)?
                            sqlnode:
                            /* generate a new column name only
                               if the operation is not a 
                               column name */
                            column_assign(
                                sqlnode,
                                column_name(
                                    colname->ident)));

                    /* create a column list for the variable
                       and for the select automatic generated
                       sfw statement in annotations. */
                   selectlist2 = select_list_add(selectlist2,
                           (sqlnode->kind == sql_clmn_name)?
                           sqlnode:
                           column_name(colname->ident));

                   /* create columnlist for the table name */
                   columnlist = column_list_add(columnlist,
                           (sqlnode->kind == sql_clmn_name)?
                           sqlnode:
                           column_name(colname->ident));
                   
                   /* override expression with columnname */
                   if(sqlnode->kind != sql_clmn_name)
                       sql_override_expr(p->sql_ann->colmap,
                           p->schema.items[i].name,
                           t, colname->ident);

                }
            }
        }

        p->sql_ann->wheremap = sql_where_env_new();
       
        if(sql_stmt->kind == sql_select) {
            sql_stmt->sem.select.select_list = selectlist1;
            sql_stmt->sem.select.where_list  = 
                (wherelist->kind != sql_list_terminator)?
                wherelist:NULL;
        }

        execute( 
                  bind
                  (
                      table_name(newvar->name, columnlist ),
                      sql_stmt
                  )
               );

        /** override sfw node with a valid select node */
        p->sql_ann->sfw =
            select
            (
             selectlist2,
             from_list
             (
              p->sql_ann->tabname
             ),
             NULL
            );
    }
    
#ifndef NDEBUG
    execute( comment( "End rule (reduce): \"%s\" (%i)",
                PFlalg2sql_string[rule], rule ) );
#endif
}

static PFsql_t*
literal(PFalg_atom_t atom)
{
    switch( atom.type ) {
        case aat_nat:
        case aat_int: return lit_int(atom.val.nat_);
        case aat_str: return lit_str(atom.val.str);
        case aat_bln: return lit_bln(atom.val.bln);
        default:
            break;
    }

    PFoops( OOPS_FATAL,
            "A relational algebra type (%u) has not "
            "been implemented", atom.type);

    return NULL; /* satisfy picky compilers */
}

static PFalg_simple_type_t
type_of(PFla_op_t *n, PFalg_att_t att)
{
    assert( n );

    for( unsigned int i = 0; i < n->schema.count; i++ ) {
        if( n->schema.items[i].name == att) {
            return n->schema.items[i].type;
        }
    }

    PFoops( OOPS_FATAL,
            "cannot determine implementation type of "
            "algebra expression");

    return aat_nat; /* satisfy picky compilers */ 
}

static PFsql_t* 
bin_op( PFsql_t* (*op) (const PFsql_t *, const PFsql_t*),
        PFla_op_t *p, PFalg_simple_type_t arg_ty,
        PFalg_simple_type_t res_ty)
{
    for( unsigned int i=0;
            i < PFarray_last( L(p)->sql_ann->colmap ); i++ ) {
        sql_column_env_t entry = sql_column_env_at(
                L(p)->sql_ann->colmap, i);

        sql_column_env_add(p->sql_ann->colmap,
                entry.att, entry.type, entry.expression);
    }

    where_env_copy(L(p)->sql_ann->wheremap,
            p->sql_ann->wheremap);

    for( unsigned int col = 0; col < p->schema.count; col++ ) {
        for( PFalg_simple_type_t t = 1; t; t<<=1 ) {
            if( t & p->schema.items[col].type ) {
                sql_column_env_add(p->sql_ann->colmap,
                        p->schema.items[col].name,
                        t,
                        op
                        (
                         sql_expression(p->sql_ann->colmap,
                             p->sem.binary.att1,
                             arg_ty),
                         sql_expression(p->sql_ann->colmap,
                             p->sem.binary.att2,
                             arg_ty)
                        ));
            }
        }
    }

    res_ty = res_ty;

    return select
        (
         NULL, /* no selectlist provided */
         L(p)->sql_ann->sfw->sem.select.from_list,
         NULL
        );
}

/**
 * Generic binary arithmetic operator. In addition to bin_op()
 * does addition type checks.
 */
static PFsql_t* 
bin_arith(PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p)
{
    PFalg_simple_type_t ty = type_of(L(p), p->sem.binary.att1 );

    /* second operand must have the same type as the first */
    assert( ty == type_of( L(p), p->sem.binary.att1) );
    assert( ty == aat_int || ty == aat_dec || ty == aat_dbl ||
            ty == aat_str );

    return bin_op(op, p, ty, ty);
}

static PFsql_t*
bin_comp(PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p)
{
    PFalg_simple_type_t ty = type_of(L(p), p->sem.binary.att1 );

    /* second operand must have the same type as the first */
    assert( ty == type_of(L(p), p->sem.binary.att1) );
    assert( ty == aat_int || ty == aat_dec ||
            ty == aat_dbl || ty == aat_str ||
            ty == aat_bln);
    return bin_op(op, p, ty, aat_bln);
}

static void
column_env_copy(PFarray_t *srccolmap, PFarray_t *destcolmap)
{
    for(unsigned int i = 0; i < PFarray_last(srccolmap); i++) {
        sql_column_env_t entry = sql_column_env_at(
                srccolmap, i);
        sql_column_env_add(destcolmap,
                entry.att, entry.type, entry.expression);
    }
}

static void
where_env_copy(PFarray_t *srcwheremap, PFarray_t *destwheremap)
{
    for(unsigned int i = 0; i < PFarray_last(srcwheremap); i++) {
        sql_where_env_t entry = sql_where_env_at(
                srcwheremap, i);
        sql_where_env_add(destwheremap,
                entry.expression);
    }
}

static void
parse(PFla_op_t *n)
{
    /* label the algebra tree to determine optimal code generation */
    PFlalg2sql_label( n );
    /* traverse algebra tree */
    reduce(n, 1);
}

PFsql_t*
PFlalg2sql(PFla_op_t *n)
{
   sql_stmts = NULL;
   
   assert( n ); 

   /* set reference counters in algebra tree nodes */
   inc_refctr( n );
   PFla_dag_reset( n );

   parse( n );
   
   return sql_stmts;
}
/* vim:set shiftwidth=4 expandtab filetype=c: */  
