%{

/**
 * @file
 *
 * Transforms the logical algebra tree into a tree that represents
 * sql statements.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2007 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 * $Id$
 */

/* always include pathfinder first */
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "lalg2sql.h"
#include "sql.h"
#include "algebra.h"
#include "alg_dag.h"
#include "mem.h"
#include "oops.h"       /* PFoops() */
#include "subtyping.h"

/**
 * Accessors for the burg pattern matcher */ 
typedef struct PFla_op_t* NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)     ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)   ((p)->child[0])
#define RIGHT_CHILD(p)  ((p)->child[1])

/* the state, burg determines during the bottom up graph
 * traversal
 */
#define STATE_LABEL(p) ((p)->state_label)

/* if an error occurs, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start with non-terminal */
%start Query
/**
 * Node identifiers, corresponding to the node kinds in
 * include/logical.h
 */

%term serialize      =  1 /**< serialize algebra expression
                              (Placed on the very top of the tree.) */
%term lit_tbl        =  2 /**< literal table */
%term empty_tbl      =  3 /**< empty literal table */
%term attach         =  4 /**< attach constant column */
%term cross          =  5 /**< cross product (Cartesian product) */
%term eqjoin         =  6 /**< equi-join */
%term semijoin       =  7 /**< semi-join */
%term project        =  8 /**< algebra projection and renaming operator */
%term select_        =  9 /**< selection of rows where column value != 0 */
%term disjunion      = 10 /**< union two relations with same schema */
%term intersect      = 11 /**< intersect two relations with same schema */
%term difference     = 12 /**< difference of two relations w/ same schema */
%term distinct       = 13 /**< duplicate elimination operator */
%term num_add        = 20 /**< arithmetic plus operator */
%term num_subtract   = 21 /**< arithmetic minus operator */
%term num_multiply   = 22 /**< arithmetic times operator */
%term num_divide     = 23 /**< arithmetic divide operator */
%term num_modulo     = 24 /**< arithmetic modulo operator */
%term num_eq         = 25 /**< numeric equal operator */
%term num_gt         = 26 /**< numeric greater-than operator */
%term num_neg        = 27 /**< numeric negation operator */
%term bool_and       = 28 /**< boolean AND operator */
%term bool_or        = 29 /**< boolean OR operator */
%term bool_not       = 30 /**< boolean NOT operator */
%term avg            = 31 /**< operator for (partitioned) avg of a column */
%term max_           = 32 /**< operator for (partitioned) max of a column */
%term min_           = 33 /**< operator for (partitioned) min of a column */
%term sum            = 34 /**< operator for (partitioned) sum of a column */
%term count          = 35 /**< (partitioned) row counting operator */
%term rownum         = 36 /**< consecutive number generation */
%term number         = 37 /**< consecutive number generation */
%term type           = 40 /**< selection of rows where a column is of a
                                 certain type */
%term type_assert    = 41 /**< restricts the type of a relation */
%term cast           = 42 /**< type cast of an attribute */
%term seqty1         = 43 /**< test for exactly one type occurrence in one
                                 iteration (Pathfinder extension) */
%term all            = 44 /**< test if all items in an iteration are true */
%term scjoin         = 50 /**< staircase join */
%term dup_scjoin     = 51 /**< staircase join */
%term doc_tbl        = 52 /**< document relation (is also a fragment) */
%term doc_access     = 53 /**< document access necessary for pf:string-value */
%term element        = 60 /**< element-constructing operator */
%term element_tag    = 61 /**< part of the element-constructing operator;
                              connecting element tag and content;
                              due to Burg we use two "wire2" operators
                              now instead of one "wire3 operator "*/
%term attribute      = 62 /**< attribute-constructing operator */
%term textnode       = 63 /**< text node-constructing operator */
%term docnode        = 64 /**< document node-constructing operator */
%term comment        = 65 /**< comment-constructing operator */
%term processi       = 66 /**< processing instruction-constr. operator */
%term merge_adjacent = 67 /**< operator for pf:merge-adjacent-text-nodes
                              builtin function */
%term roots_         = 70 /**< algebraic repres. of the roots of newly
                         created xml nodes (e.g. element());
                         schema: iter | pos | item */
/* all operators below represent xml node fragments with no schema */
%term fragment       = 71 /**< representation of a node fragment */
%term frag_union     = 72 /**< special node type used to form an algebraic
                             union of fragments */
%term empty_frag     = 73 /**< representation of an empty fragment */

%term cond_err       = 80 /**< facility to trigger runtime errors */
%term rec_fix        = 81 /**< operator representing a tail recursion */
%term rec_param      = 82 /**< list of parameters of the recursion */
%term rec_nil        = 83 /**< end of the list of parameters of the 
                             recursion */
%term rec_arg        = 84 /**< reference to the arguments of a parameter
                             in the recursion */
%term rec_base       = 85 /**< base of the DAG describing the recursion */

%term proxy          = 96 /**< proxy operator that represents a group
                              of operators */
%term proxy_base     = 97 /**< completes the content of the proxy 
                              (a virtual base table) */
%term cross_mvd      = 98 /**< clone column aware cross product */
%term eqjoin_unq     = 99 /**< clone column aware equi-join */                            
/* builtin support for XQuery functions */
%term concat         =100 /**< fn:concat */
%term contains       =101 /**< fn:contains */
%term string_join    =102 /**< fn:string-join */

%term dummy          =120 /**< dummy operator that does nothing */

%%

Query:  serialize (Frag, Rel)                     =   1 (10);

Rel:    lit_tbl                                   =   2 (10);
Rel:    attach (Rel)                              =   3 (10);
Rel:    cross (Rel, Rel)                          =   4 (10);
Rel:    cross (Rel, lit_tbl)                      =   5 (10);
Rel:    cross (lit_tbl, Rel)                      =   6 (10);
Rel:    eqjoin (Rel, Rel)                         =   8 (10);
Rel:    project (Rel)                             =  10 (10);
Rel:    select_ (Rel)                             =  19 (10);
Rel:    disjunion (Rel, Rel)                      =  20 (10);
Rel:    disjunion (EmptyRel, Rel)                 =  21  (5);
Rel:    disjunion (Rel, EmptyRel)                 =  22  (5);
Rel:    intersect (Rel, Rel)                      =  23 (10);
Rel:    difference (Rel, Rel)                     =  24 (10);
Rel:    difference (Rel, EmptyRel)                =  25  (5);
Rel:    distinct (Rel)                            =  26 (10);
Rel:    distinct (scjoin (Frag, Rel))             =  27 (5);
Rel:    num_add (Rel)                             =  30 (10);
Rel:    num_subtract (Rel)                        =  31 (10);
Rel:    num_multiply (Rel)                        =  32 (10);
Rel:    num_divide (Rel)                          =  33 (10);
Rel:    num_modulo (Rel)                          =  34 (10);
Rel:    num_neg (Rel)                             =  35 (10);
Rel:    num_gt (Rel)                              =  36 (10);
Rel:    num_eq (Rel)                              =  37 (10);
Rel:    bool_and (Rel)                            =  38 (10);
Rel:    bool_or (Rel)                             =  39 (10);
Rel:    bool_not (Rel)                            =  40 (10);
Rel:    avg (Rel)                                 =  41 (10);
Rel:    max_ (Rel)                                =  42 (10);
Rel:    min_ (Rel)                                =  43 (10);
Rel:    sum (Rel)                                 =  44 (10);
Rel:    count (Rel)                               =  45 (10);
Rel:    rownum (Rel)                              =  50 (10);
Rel:    number (Rel)                              =  51 (10);
Rel:    type (Rel)                                =  54 (10);
Rel:    type_assert (Rel)                         =  55 (10);
Rel:    cast (cast (Rel))                         =  56 (10);
Rel:    cast (Rel)                                =  58 (10);
Rel:    seqty1 (Rel)                              =  59 (10);
Rel:    all (Rel)                                 =  60 (10);
Rel:    ScjRel                                    =  61 (10);
ScjRel: scjoin (Frag, Rel)                        =  62 (10);
ScjRel: scjoin (Frag, ScjRel)                     = 550 (10);
Rel:    doc_access (Frag, Rel)                    =  65 (10);

Rel:    roots_ ( FragRel )                        =  70 (10);
Rel:    roots_ (attribute (Rel))                  =  72 (10);
FragRel:    textnode (Rel)                            =  73 (1);
Rel:    roots_ (docnode (Frag, Rel))              =  74 (10);
Rel:    roots_ (comment (Rel))                    =  75 (10);
Rel:    roots_ (processi (Rel))                   =  76 (10);

Rel:    cond_err (Rel, Rel)                       =  80 (10);

Rel:    rec_fix (Rec, Rel)                        =  81 (10);
Rel:    rec_base                                  =  82 (10);
Rec:    rec_param (Arg, Rec)                      =  83 (10);
Rec:    rec_nil                                   =  84 (10);
Arg:    rec_arg (Rel, Rel)                        =  85 (10);

Rel:    concat (Rel)                              =  86 (10);
Rel:    contains (Rel)                            =  87 (10);
Rel:    string_join (Rel, Rel)                    =  88 (10);
Rel:    dummy (Rel)                               =  89 (10);

Rel:    EmptyRel                                  =  90  (0);
Rel:    semijoin(Rel, Rel)                        = 203  (0);

FragRel: doc_tbl(Rel)                             = 300  (1);

Frag:    fragment ( FragRel )                     = 100 (10);
FragRel:    element (Frag, Rel)                   = 101 (1);
Rel:     element_tag( Rel, Rel)                   = 500 (1);
Frag:    fragment (attribute (Rel))               = 102 (10);
Frag:    fragment (docnode (Frag, Rel))           = 104 (10);
Frag:    fragment (comment (Rel))                 = 105 (10);
Frag:    fragment (processi (Rel))                = 106 (10);
FragRel:    merge_adjacent (Frag, Rel)               = 107 (10);

Frag:    frag_union (Frag, Frag)                  = 111 (10);
Frag:    frag_union (empty_frag, Frag)             = 350 (10);
Frag:    empty_frag                               = 112 (10);


EmptyRel:    empty_tbl                            = 120  (0);

EmptyRel:    attach (EmptyRel)                    = 121  (0);
EmptyRel:    cross (EmptyRel, Rel)                = 122  (0);
EmptyRel:    cross (Rel, EmptyRel)                = 123  (0);
EmptyRel:    eqjoin (EmptyRel, Rel)               = 124  (0);
EmptyRel:    eqjoin (Rel, EmptyRel)               = 125  (0);
EmptyRel:    project (EmptyRel)                   = 126  (0);
EmptyRel:    select_ (EmptyRel)                   = 127  (0);
EmptyRel:    disjunion (EmptyRel, EmptyRel)       = 130  (0);
EmptyRel:    intersect (EmptyRel, Rel)            = 131  (0);
EmptyRel:    intersect (Rel, EmptyRel)            = 132  (0);
EmptyRel:    difference (EmptyRel, Rel)           = 133  (0);
EmptyRel:    distinct (EmptyRel)                  = 134  (0);
EmptyRel:    num_add (EmptyRel)                   = 140  (0);
EmptyRel:    num_subtract (EmptyRel)              = 141  (0);
EmptyRel:    num_multiply (EmptyRel)              = 142  (0);
EmptyRel:    num_divide (EmptyRel)                = 143  (0);
EmptyRel:    num_modulo (EmptyRel)                = 144  (0);
EmptyRel:    num_neg (EmptyRel)                   = 145  (0);
EmptyRel:    num_gt (EmptyRel)                    = 146  (0);
EmptyRel:    num_eq (EmptyRel)                    = 147  (0);
EmptyRel:    bool_and (EmptyRel)                  = 148  (0);
EmptyRel:    bool_or (EmptyRel)                   = 149  (0);
EmptyRel:    bool_not (EmptyRel)                  = 150  (0);
EmptyRel:    avg (EmptyRel)                       = 151  (0);
EmptyRel:    max_ (EmptyRel)                      = 152  (0);
EmptyRel:    min_ (EmptyRel)                      = 153  (0);
EmptyRel:    sum (EmptyRel)                       = 154  (0);
EmptyRel:    count (EmptyRel)                     = 155  (0);
EmptyRel:    rownum (EmptyRel)                    = 160  (0);
EmptyRel:    number (EmptyRel)                    = 161  (0);
EmptyRel:    type (EmptyRel)                      = 162  (0);
EmptyRel:    type_assert (EmptyRel)               = 163  (0);
EmptyRel:    cast (EmptyRel)                      = 164  (0);
EmptyRel:    seqty1 (EmptyRel)                    = 165  (0);
EmptyRel:    all (EmptyRel)                       = 166  (0);
EmptyRel:    scjoin (Frag, EmptyRel)              = 170  (0);
EmptyRel:    doc_access (Frag, EmptyRel)          = 171  (0);
EmptyRel:    roots_ (element (Frag, 
                              element_tag (EmptyRel,
                                          Rel)))  = 180  (0);
EmptyRel:    roots_ (attribute (EmptyRel))        = 182  (0);
EmptyRel:    roots_ (comment (EmptyRel))          = 185  (0);
EmptyRel:    roots_ (processi (EmptyRel))         = 186  (0);
EmptyRel:    roots_ (merge_adjacent (Frag,                   
                                     EmptyRel))   = 187  (0);
EmptyRel:    cond_err (EmptyRel, Rel)             = 190  (0);
EmptyRel:    concat (EmptyRel)                    = 200  (0);
EmptyRel:    string_join (EmptyRel, Rel)          = 201  (0);
EmptyRel:    dummy (EmptyRel)                     = 202  (0);

%%

#include "sql_mnemonic.h"

#define MAX_KIDS 10 

static PFalg_simple_type_t type_of(PFla_op_t *, PFalg_att_t);
static PFsql_t* bin_arith(PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p);
static PFsql_t* bin_rel(PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p, PFla_op_t *l, PFla_op_t *r);
static PFsql_t* bin_comp(PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p);
static void where_env_copy(PFarray_t *srcwheremap,
        PFarray_t *destwheremap);
static struct PFsql_alg_ann_t* llscj(PFalg_axis_t axis, const PFla_op_t *p,
        const PFla_op_t *frag);
static PFsql_t* doc_access(PFla_op_t *p);
static PFsql_t* collect_fragments(PFla_op_t *p);

/** 
 * We collect the SQL statements during compilation here
 */
static PFsql_t *sql_stmts = NULL;

#define execute(...) sql_stmts = (sql_stmts == NULL)? \
                                 common_table_expr( __VA_ARGS__ ):\
                                 common_table_expr(sql_stmts, __VA_ARGS__)

/**
 * We define the fragment with the maximum pre value here.
 */
static PFsql_t *max_pre_frag = NULL;

static PFsql_t* literal(PFalg_atom_t);

/*
 * Easily access subtree parts.
 */
/** starting from p, make a left step */
#define L(p)      (LEFT_CHILD(p))
/** starting from p, make a right step */
#define R(p)      (RIGHT_CHILD(p))
#define LL(p)     L(L(p))
#define RL(p)     R(L(p))
#define LR(p)     L(R(p))
#define RR(p)     R(R(p))
/** Macro determining if a node is just visited */
#define SEEN(p)   ((p)->bit_dag)
/** a node is dirty and has to be bind to
  a table name */
#define DIRTY(p)  (((p)->refctr > 1) || \
                    (((p)->sql_ann->sfw)? \
                    ((p)->sql_ann->sfw->kind != sql_select):true) || \
                    ((p)->dirty == true))
#define TYPE_MASK(t) ( (t) & (0xFFFF ^ (aat_anode | aat_pfrag)))
#define IS_PRE(ident)   ( ((ident) >> (ATT_BITS+TYPE_BITS) \
            & 0x00000007) == 1) 

#define ELEM   1
#define ATTR   2
#define TEXT   3
#define COMM   4
#define PI     5
#define DOC    6
typedef unsigned int sql_kind_t;

/*................. SQL Variable ................ */
    
/**
 * Represents a pseudo SQL table_name.
 *
 * @note
 *   The variable has a name (that is automatically generated).
 */
struct sql_table_name_t {
    PFsql_ident_t name;
};
typedef struct sql_table_name_t sql_table_name_t;

/**
 * Return a new valid variable. We will try to reuse an old one
 */
static sql_table_name_t*
sql_table_name_new ()
{
    static unsigned int varno =  PF_SQL_RES_TABLE_COUNT;
    sql_table_name_t *var  =
        (sql_table_name_t*)PFmalloc (sizeof (sql_table_name_t));
    
    /* increment the variables name property */
    var->name = varno++;
    return var;
}

/* ........ SQL Loc Var ................*/

struct sql_correlation_name_t {
    PFsql_correlation_name_t name;
};
typedef struct sql_correlation_name_t sql_correlation_name_t;

static sql_correlation_name_t*
sql_correlation_name_new (void)
{
    static unsigned int varno =  PF_SQL_RES_CORRELATION_COUNT;
    sql_correlation_name_t *var  =
        (sql_correlation_name_t*)PFmalloc (sizeof (sql_correlation_name_t));

    /* increment the variables name property */
    var->name = varno++;
    return var;
}

/* .............. SQL Columns ................ */

struct sql_column_name_t {
    PFsql_ident_t ident;
};
typedef struct sql_column_name_t sql_column_name_t;

struct sql_column_env_t {
    PFalg_simple_type_t    type;
    PFalg_att_t            att;
    PFsql_t               *expression;
};
typedef struct sql_column_env_t sql_column_env_t;

static sql_column_name_t*
sql_special_name_new (PFsql_special_t spc)
{
    unsigned int sp = 0;
    
    /* determine position of special bit */
    for (PFsql_special_t spmask = 1, i = 0; spmask; spmask<<=1, i++) {
        if (spc & spmask) {
            sp = (unsigned int)i;
            break;
        }
    }

    sql_column_name_t *ret =
        (sql_column_name_t*)PFmalloc (sizeof (sql_column_name_t));

    *ret = (sql_column_name_t) {
        .ident = ((unsigned int)sp) << (ATT_BITS + TYPE_BITS)
    };
    
    return ret;
}

static sql_column_name_t*
sql_column_name_new (PFalg_att_t att, PFalg_simple_type_t ty)
{
    static unsigned int varno = PF_SQL_RES_COLUMN_COUNT;
    sql_column_name_t *ret = NULL; 
    
    /* bit position of attribute a. */
    unsigned int a = 0;
    /* bit position of type t */
    unsigned int t = 0;

    /* determine the bit position of att */
    if (att != (unsigned int)0) {
        for (PFalg_att_t attmask=1, i = 0; attmask; attmask<<=1, i++) {
            if (attmask & att) {
                a = i + 1;
                break;
            }
        }
    }

    /* determine bit position of type */
    for (PFalg_simple_type_t tmask = 1, i = 0; tmask; tmask<<=1, i++) {
        if (tmask & ty) {
            t = i;
            break;
        }
    }

    ret = (sql_column_name_t*)PFmalloc (sizeof (sql_column_name_t));
    
    *ret = (sql_column_name_t) {
        .ident = a + (t << ATT_BITS) +
            ((varno++) << (ATT_BITS+TYPE_BITS+SPEC_BITS))
    };

    return ret;
}

static bool
special (PFsql_ident_t ident)
{
    return (((ident >> (ATT_BITS + TYPE_BITS)) & 0x00000007) >= 1); 
}

static bool
eq_type (PFalg_att_t att, PFalg_simple_type_t ty, PFsql_ident_t ident)
{
    ty = TYPE_MASK(ty);
    
    /* first create a new column name with the given parameters */
    sql_column_name_t *new = sql_column_name_new (att, ty);

    return special (ident) ||
        (((new->ident & 0x000001FF) ^ (ident & 0x000001FF)) == 0);
}

static PFarray_t*
sql_column_env_new (void)
{
    return PFarray (sizeof (sql_column_env_t));
}

static void
sql_column_env_add (PFarray_t *env, PFalg_att_t att,
        PFalg_simple_type_t ty, PFsql_t *expr)
{
    ty = TYPE_MASK(ty); 

    assert (ty == aat_nat || ty == aat_int ||
            ty == aat_str || ty == aat_bln ||
            ty == aat_pre || ty == aat_qname ||
            ty == aat_dec || ty == aat_uA ||
            ty == aat_dbl);

    *(sql_column_env_t*)PFarray_add (env) = (sql_column_env_t) {
        .type = ty,
        .att = att,
        .expression = expr
    };
}

static sql_column_env_t
sql_column_env_at (const PFarray_t *env, unsigned int i)
{
    assert (i < PFarray_last (env));

    return *(sql_column_env_t*)PFarray_at ((PFarray_t*)env, i);
}

#if 0
    GCC: defined but never used
static unsigned int
sql_column_env_count(const PFarray_t *env)
{
    return PFarray_last(env);
}
#endif

static PFsql_t*
sql_expression_unsafe (const PFarray_t *env, PFalg_att_t att,
        PFalg_simple_type_t ty)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        sql_column_env_t entry =
            *(sql_column_env_t*)PFarray_at ((PFarray_t*)env, i);

        if (entry.att == att && TYPE_MASK(entry.type) == TYPE_MASK(ty) )
            return entry.expression;
    }
    return NULL;
}

static PFsql_t*
sql_expression (const PFarray_t *env, PFalg_att_t att,
        PFalg_simple_type_t ty)
{
    ty = TYPE_MASK(ty);
    PFsql_t *expr =
        sql_expression_unsafe(env, att, ty);

    if (expr)
        return expr;

    PFoops (OOPS_FATAL,
            "SQLgen: attribute '%s' with type '0x%X' "
            "not found in environment",
            PFatt_str (att), ty);

    return NULL; /* satisfy picky compilers */
}

static void
sql_override_expr (PFarray_t *env, PFalg_att_t att,
        PFalg_simple_type_t ty, PFsql_ident_t colname,
        PFsql_correlation_name_t crrln)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        sql_column_env_t *entry = 
            (sql_column_env_t*)PFarray_at ((PFarray_t*)env, i);

        if (entry->att == att && entry->type == ty) {
            entry->expression = crrl_deco (column_name (colname), crrln);
            return;
        }
    }

    PFoops (OOPS_FATAL,
            "SQLgen: attribute '%s' with type '0x%X' "
            "not found in environment",
            PFatt_str (att), ty);
}

struct sql_where_env_t {
    PFsql_t *expression;
};
typedef struct sql_where_env_t sql_where_env_t;

static PFarray_t*
sql_where_env_new (void)
{
    return PFarray (sizeof (sql_where_env_t));
}

static sql_where_env_t
sql_where_env_at (const PFarray_t *env, unsigned int i)
{
    assert (i < PFarray_last (env));

    return *(sql_where_env_t*)PFarray_at ((PFarray_t*)env, i);
}

static void
sql_where_env_add (PFarray_t *env, PFsql_t *expr)
{
    *(sql_where_env_t*)PFarray_add (env) = (sql_where_env_t) {
            .expression = expr
    };
}

static PFsql_alg_ann_t*
sql_alg_ann_new (void)
{
    PFsql_alg_ann_t *ret =
        (PFsql_alg_ann_t*)PFmalloc (sizeof (PFsql_alg_ann_t));

    ret->tabname = NULL;
    ret->sfw = NULL;
    ret->fragment = NULL; 
    ret->colmap = sql_column_env_new(); 
    ret->wheremap = sql_where_env_new();

    return ret;
}

/**
 * Does a DAG preorder traversal and determines the incoming
 * edges of each node.
 */
static void
inc_refctr (PFla_op_t *n)
{
    assert (n);

    /* count number of incoming edges */
    n->refctr++;

    /* only descend once */
    if (SEEN (n))
        return;
    else
        SEEN (n) = true;

    for (unsigned int i = 0; i < PFLA_OP_MAXCHILD && n->child[i]; i++)
        inc_refctr (n->child[i]);
}

static bool
binding (PFsql_t *n)
{
    assert (n);

    if (n->kind == sql_bind)
        return true;
    else {
        for (unsigned int i = 0; i < PFSQL_OP_MAXCHILD &&
                n->child[i]; i++) {
            return binding (n->child[i]);
        }
    }
    return false;
}

/**
 * Reduce function. This is the core of this source file, containing
 * the actions that should be executed whenever a burg-pattern matches.
 */
static void
reduce(PFla_op_t *p, int goalnt)
{
    int        rule;             /* rule number that matches this node */
    short     *nts;             /* target non-terminals for the leaf node
                                       of the current rule */
    PFsql_t   *sql_stmt;        /* SQL statment we construct in this
                                       function */
    PFla_op_t *kids[MAX_KIDS];  /* leaf node of this rule */
    bool       topdown;

    sql_stmt = NULL;

    if (p->sql_ann) {
        return;
    }
    
    /* determine rule that matches for this non-terminal */
    rule = PFlalg2sql_rule (STATE_LABEL (p), goalnt);

    /* error if a rule with value zero is determined */
    assert (rule);
    
    /* initializing the kids vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++) {
        kids[i] = NULL;
    } 
   
    /* get information for dag-traversal */
    nts  = PFlalg2sql_nts[rule];
    PFlalg2sql_kids (p, rule, kids);

    switch (rule) {
        /* Query:    serialize(Frag,Rel)  */
        case 1:
        case 4:
        /* Rel: eqjoin(Rel) */
        case 8:
        /* Rel: semijoin(Rel) */
        case 203:
        /* Rel: element_tag(Rel, Rel) */
        case 500:
            topdown = true;
            break;
        default:
            topdown = false;
            break;
    }

    /* make a top down traversal */
    if (!topdown) { 
        for (unsigned short i = 0; nts[i]; i++)
            reduce (kids[i], nts[i]);
    }
        
    /* check if the sql annotations just exists in the algebra
       node */
    if (p->sql_ann && rule != 61) {
        return;
    }

    /* initialize SQL annotations */
    if( rule != 61) p->sql_ann = sql_alg_ann_new (); 

    switch (rule) {
        /* Query:    serialize (Frag,Rel)  */
        case 1:
        {
            /* For the SQL generation the only purpose of
             * the serialize operator is to bind the
             * underlying nodes to a table name and 
             * construct some default tables for 
             * the externalized serializer. */
            for (unsigned short i = 0; nts[i]; i++)
            {
                /* make subsequent nodes of serialize dirty to force
                 * a binding */
                 kids[i]->dirty = true;
                 reduce(kids[i], nts[i]);
            }

            /* construct schema information for serializer */
            PFsql_t *schm_inf = NULL;
            schm_inf = schema_information (
                    schm_inf, schema_comment (
                        "END SCHEMA INFORMATION ** "
                        "DO NOT EDIT THESE LINES"));

            PFsql_t* clmnlist = NULL;
            /* adding information about the result relation */
            for (unsigned int col = 0; col < R(p)->schema.count; col++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if(t & TYPE_MASK(R(p)->schema.items[col].type)) {
                        schm_inf = schema_information (schm_inf,
                            schema_expression
                            (
                             schema_result (),
                             column_name (sql_column_name_new (
                                 R(p)->schema.items[col].name, t)->ident)
                            ));
                        clmnlist = column_list (clmnlist,
                            column_name (sql_column_name_new(
                                R(p)->schema.items[col].name, t)->ident));
                    }
                }
            }

            PFsql_t *result = result (clmnlist);

            schm_inf = schema_information (schm_inf,
                    schema_expression (schema_result (), result));

            /* adding information about the document relation */
            schm_inf = schema_information (schm_inf,
                schema_expression (schema_doc (),
                    column_name (
                        sql_special_name_new (sql_col_tag)->ident)),
                schema_expression (schema_doc (),
                    column_name (
                        sql_special_name_new (sql_col_prop)->ident)),
                schema_expression (schema_doc (),
                    column_name (
                        sql_special_name_new (sql_col_kind)->ident)),
                schema_expression (schema_doc (),
                    column_name (
                        sql_special_name_new (sql_col_level)->ident)),
                schema_expression (schema_doc (),
                    column_name (
                        sql_special_name_new (sql_col_size)->ident)),
                schema_expression (schema_doc (),
                    column_name (
                        sql_special_name_new (sql_col_pre)->ident)),
                schema_expression (schema_doc (),
                    document (NULL)),
                schema_comment (
                    "START SCHEMA INFORMATION "
                    "** DO NOT EDIT THESE LINES" ));

            execute (bind
                    (
                     result,
                     R(p)->sql_ann->sfw
                    ));

            sql_correlation_name_t *coll_crrl = sql_correlation_name_new ();
            
            execute (bind
                    (
                     document
                     (
                      column_list
                      (
                       column_name (
                           sql_special_name_new (sql_col_tag)->ident),
                       column_name (
                           sql_special_name_new (sql_col_prop)->ident),
                       column_name (
                           sql_special_name_new (sql_col_kind)->ident),
                       column_name (
                           sql_special_name_new (sql_col_level)->ident),
                       column_name (
                           sql_special_name_new (sql_col_size)->ident),
                       column_name (
                           sql_special_name_new (sql_col_pre)->ident)
                      )
                     ),
                     select
                     (
                      select_list
                      (
                       column_name (
                           sql_special_name_new (sql_col_prop)->ident),
                       column_name (
                           sql_special_name_new (sql_col_prop)->ident),
                       column_name (
                           sql_special_name_new (sql_col_kind)->ident),
                       column_name (
                           sql_special_name_new (sql_col_level)->ident),
                       column_name (
                           sql_special_name_new (sql_col_size)->ident),
                       column_name (
                           sql_special_name_new (sql_col_pre)->ident)
                      ),
                      from_list
                      (
                       alias
                       (
                        collect_fragments (L(p)),
                        correlation_name (coll_crrl->name)
                       )
                      ),
                      NULL,
                      NULL
                     )
                    ));
                            
            /* construct the final query from schema information 
             * and `with'-statement */
            sql_stmts = seq (schm_inf, with (sql_stmts)); 
        } break;
        /* empty frag */
        case 112:
        {
            /* empty frag is a no-op */
        } break;
        /* Rel:      lit_tbl              */ 
        case 2:
        {
            /* declare a new correlation name
             * used for this expression */
            sql_correlation_name_t *crrl = sql_correlation_name_new();
            
            for (unsigned int row = 0; row < p->sem.lit_tbl.count; row++) {
                for (unsigned int col = 0; col < p->schema.count; col++) {
                    for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                        if (t & TYPE_MASK(p->schema.items[col].type)) {
                            sql_column_env_add (p->sql_ann->colmap,
                                p->schema.items[col].name, t,
                                crrl_deco (
                                    (t == p->sem.lit_tbl.tuples[row]
                                     .atoms[col].type)?
                                        literal (p->sem.lit_tbl
                                            .tuples[row].atoms[col]):
                                        cast (null (), type (t)),
                                   crrl->name));
                        }       
                    }
                }
            }

            /* FIXME there has to be an union to support tables */
            sql_stmt = select
                       (
                        NULL, /* no selectlist provided */
                        from_list
                        (
                         alias
                         (
                          tab_name (schema (SYSIBM), sysdummy1 ()),
                          correlation_name (crrl->name)
                         )
                        ),
                        NULL,
                        NULL
                       );
        } break;
        /* Rel: attach (Rel) */
        case 3:
        {
            /* copy all existing expressions */
            for (unsigned int i = 0;
                    i < PFarray_last (L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        L(p)->sql_ann->colmap, i);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            /* copy the existing wheremap */
            where_env_copy (L(p)->sql_ann->wheremap, p->sql_ann->wheremap);

            /* add expression for attach to the column environment */
            sql_column_env_add (p->sql_ann->colmap,
                    p->sem.attach.attname, p->sem.attach.value.type,
                    literal (p->sem.attach.value));

            assert (L(p)->sql_ann->sfw->child[1]);

            sql_stmt = select
                (
                 NULL, /* no selectlist provided */
                 L(p)->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                );
        } break;
        /* Rel: roots_( FragRel ) */
        case 70:
        {
            /* copy environment */
            for (unsigned int i = 0;
                    i < PFarray_last (L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry =
                    sql_column_env_at (L(p)->sql_ann->colmap, i);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            /* copy where environment */
            for (unsigned int i = 0;
                    i < PFarray_last(L(p)->sql_ann->wheremap); i++) {
                sql_where_env_t entry =
                    sql_where_env_at (L(p)->sql_ann->wheremap, i);
                sql_where_env_add (p->sql_ann->wheremap, entry.expression);
            }

            assert (L(p)->sql_ann->sfw);
            
            sql_stmt = select
                (
                 NULL,
                 L(p)->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                );
        } break;
        /* FragRel: doc_tbl( Rel ) */
        case 300:
        {
            sql_correlation_name_t *crrl1 = sql_correlation_name_new ();

            /* add iter to the column environment */
            sql_column_env_add (p->sql_ann->colmap,
                    p->sem.doc_tbl.iter,
                    type_of (p, p->sem.doc_tbl.iter),
                    crrl_deco (
                        sql_expression (L(p)->sql_ann->colmap,
                            p->sem.doc_tbl.iter,
                            type_of (L(p), p->sem.doc_tbl.iter)),
                        crrl1->name));

            /* add column to store the document nodes to
             * the environment */
            sql_column_env_add (p->sql_ann->colmap, 
                    p->sem.doc_tbl.item_res, TYPE_MASK(type_of (
                        p, p->sem.doc_tbl.item_res)),
                    crrl_deco (
                        column_name (
                            sql_special_name_new (sql_col_pre)->ident),
                        crrl1->name));

            sql_where_env_add (p->sql_ann->wheremap,
                    eq
                    (
                     crrl_deco (
                         column_name (
                             sql_special_name_new(sql_col_kind)->ident),
                         crrl1->name),
                     lit_int (DOC)
                    ));

            sql_where_env_add (p->sql_ann->wheremap,
                    eq
                    (
                     crrl_deco (
                         column_name (
                             sql_special_name_new (sql_col_prop)->ident),
                         crrl1->name),
                     sql_expression (L(p)->sql_ann->colmap,
                         p->sem.doc_tbl.item,
                         type_of (L(p), p->sem.doc_tbl.item))
                    ));
                            


            /* set the fragment relation */
            p->sql_ann->fragment = 
                select
                (
                 select_list
                 (
                  column_name (sql_special_name_new(sql_col_prop)->ident),
                  column_name (sql_special_name_new(sql_col_kind)->ident),
                  column_name (sql_special_name_new(sql_col_level)->ident),
                  column_name (sql_special_name_new(sql_col_size)->ident),
                  column_name (sql_special_name_new(sql_col_pre)->ident),

                 ),
                 from_list
                 (
                  fragrelation ()
                 ),
                 NULL,
                 NULL
                );

            /* preparing fromlist */
            PFsql_t *fromlist = L(p)->sql_ann->sfw->child[1];
            fromlist = from_list_add(fromlist,
                    alias
                    (
                     fragrelation (),
                     correlation_name (crrl1->name)
                    ));

            sql_stmt = select
                (
                 NULL,
                 fromlist,
                 NULL,
                 NULL
                );
        } break;
        /* FragRel: textnode(Rel) */
        case 73:
        {
            sql_correlation_name_t *crrl = sql_correlation_name_new ();

            for (unsigned int i = 0; i < p->schema.count; i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & TYPE_MASK(p->schema.items[i].type)) {
                        if (p->schema.items[i].name ==
                                p->sem.textnode.res) {
                            sql_column_env_add (p->sql_ann->colmap,
                                    p->sem.textnode.res, t,
                                    add
                                    (
                                     crrl_deco (
                                         column_name (
                                            sql_special_name_new (
                                                sql_col_pre)->ident),
                                         crrl->name),
                                     lit_int (1)
                                    ));
                        }
                        else sql_column_env_add (p->sql_ann->colmap,
                                    p->schema.items[i].name, t,
                                    sql_expression (L(p)->sql_ann->colmap,
                                        p->schema.items[i].name, t)
                                    );
                    }
                }
            }
            
            where_env_copy (L(p)->sql_ann->wheremap, p->sql_ann->wheremap);

            sql_correlation_name_t *crrl1 = sql_correlation_name_new ();
            sql_correlation_name_t *max_pre_crrl =
                sql_correlation_name_new ();

            p->sql_ann->fragment = select
                (
                 select_list
                 (
                  column_assign (sql_expression (L(p)->sql_ann->colmap,
                      p->sem.textnode.item,
                      type_of (L(p), p->sem.textnode.item)),
                      column_name (sql_special_name_new (
                              sql_col_prop)->ident)), /* prop */
                  column_assign (lit_int(TEXT),
                      column_name (sql_special_name_new (
                              sql_col_kind)->ident)), /* kind */
                  column_assign (lit_int (0),
                      column_name (sql_special_name_new (
                              sql_col_level)->ident)), /* level */
                  column_assign (lit_int (0),
                      column_name (sql_special_name_new (
                              sql_col_size)->ident)), /* size */
                  column_assign (
                      add
                      (
                       crrl_deco (
                           column_name (
                               sql_special_name_new (sql_col_pre)->ident),
                           crrl1->name),
                       lit_int (1)
                      ),
                      column_name (sql_special_name_new (
                              sql_col_pre)->ident))
                 ),
                 from_list
                 (
                  L(p)->sql_ann->sfw->child[1],
                  alias
                  (
                   select
                   (
                    select_list
                    (
                     column_assign (
                         max
                         (
                          column_name (sql_special_name_new (
                              sql_col_pre)->ident)
                         ),
                         column_name (sql_special_name_new (
                              sql_col_pre)->ident))
                    ),
                    from_list
                    (
                     alias
                     (
                      max_pre_frag,
                      correlation_name (max_pre_crrl->name)
                     )
                    ),
                    NULL,
                    NULL
                   ), 
                   correlation_name (crrl1->name)),
                 ),
                 NULL,
                 NULL
                );

            sql_stmt = select
                (
                 NULL,
                 from_list
                 (
                  L(p)->sql_ann->sfw->child[1],
                  /* get maximal pre value from current max_pre_frag
                   * relation */
                  alias
                  (
                   select
                   (
                    select_list
                    (
                     column_assign (
                         max
                         (
                          column_name (
                              sql_special_name_new (
                                  sql_col_pre)->ident)
                         ),
                         column_name (sql_special_name_new (
                             sql_col_pre)->ident))
                    ),
                    from_list
                    (
                     alias
                     (
                      max_pre_frag,
                      correlation_name (max_pre_crrl->name)
                     )
                    ),
                    NULL,
                    NULL
                   ),
                   correlation_name (crrl->name)
                  )
                 ),
                 NULL,
                 NULL
                );

            /* a new node becomes the fragment with the highest pre
               value */
            max_pre_frag = p->sql_ann->fragment;
        } break;
        /* Frag: fragment (FragRel) */
        case 100: 
        {
            p->sql_ann->fragment = L(p)->sql_ann->fragment;
        } break;
        /* Frag: frag_union (empty_frag, Frag) */
        case 350:
        {
            /* each frag_union turns out to be a absolutely
             * noop */
            p->sql_ann->fragment = R(p)->sql_ann->fragment;
        } break;
        /* Rel: count(Rel) */
        case 45:
        {
            for (unsigned int i = 0;
                    i < PFarray_last(L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        L(p)->sql_ann->colmap, i++);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type, entry.expression);
            }

            sql_column_env_add (p->sql_ann->colmap,
                    p->sem.aggr.res, type_of (p, p->sem.aggr.res),
                    count
                    (
                     false, 
                     star ()
                    ));

            where_env_copy (L(p)->sql_ann->wheremap, p->sql_ann->wheremap);

            sql_stmt = select
                (
                 NULL,
                 L(p)->sql_ann->sfw->child[1],
                 NULL,
                 (p->sem.aggr.part)?
                     column_list (sql_expression (L(p)->sql_ann->colmap,
                         p->sem.aggr.part, type_of (p, p->sem.aggr.part))):
                     NULL
                );

            p->dirty = true;
        } break;
        /* Rel: scjoin(Frag, Rel) */
        case 62:
        {
            p->sql_ann = llscj (p->sem.scjoin.axis, RL(p), p);

            for (PFla_op_t *loop = LL(p); loop->kind != la_empty_frag;
                    loop = L(loop)) {
                *(p->sql_ann) = (PFsql_alg_ann_t) {
                    .sfw = disjunion
                        (
                         llscj (p->sem.scjoin.axis, R(loop), p)->sfw,
                         p->sql_ann->sfw
                        )
                };
            }

            sql_stmt = (p->sql_ann->sfw->kind == sql_select)?
                select_distinct
                (
                 NULL,
                 p->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                ):
                p->sql_ann->sfw;
        } break;
        /* ScjRel:   scjoin( Frag, Scjoin) */
        case 550:
        {
            /* combine more than one staircase join steps */
            p->sql_ann = llscj (p->sem.scjoin.axis, RL(p), p);

            for (PFla_op_t *loop = LL(p); loop->kind != la_empty_frag;
                    loop = L(loop)) {
                *(p->sql_ann) = (PFsql_alg_ann_t) {
                    .sfw = disjunion
                        (
                         llscj (p->sem.scjoin.axis, R(loop), p)->sfw,
                         p->sql_ann->sfw
                        )
                };
            }

            sql_stmt = (p->sql_ann->sfw->kind == sql_select)?
                select_distinct
                (
                 NULL,
                 p->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                ):
                p->sql_ann->sfw;
        } break;
        /* Rel: Scjoin */
        case 61:
        {
            sql_stmt = select_distinct
                (
                 NULL,
                 p->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                );
            p->dirty = true;
        } break;
        /* Rel:      cross (Rel,Rel) */
        case 4:
        {
            for (unsigned short i = 0; nts[i]; i++) {
                 /* make subsequent nodes of cross dirty to force
                  * a binding */
                 kids[i]->dirty = true;
                 reduce (kids[i], nts[i]);
            }

            sql_correlation_name_t *crrl1 = sql_correlation_name_new ();
            sql_correlation_name_t *crrl2 = sql_correlation_name_new ();

            /* copy all existing expressions */
            for (unsigned int i = 0;
                    i < PFarray_last (L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        L(p)->sql_ann->colmap,
                        i);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type,
                        crrl_deco(
                            column_name (
                                entry.expression->sem.column.ident),
                            crrl1->name));
            }
            for (unsigned int i = 0;
                    i < PFarray_last (R(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        R(p)->sql_ann->colmap,
                        i);
                if (!sql_expression_unsafe (p->sql_ann->colmap,
                            entry.att,entry.type)) {
                    sql_column_env_add (p->sql_ann->colmap,
                            entry.att, entry.type,
                            crrl_deco (
                                column_name (
                                    entry.expression->sem.column.ident),
                                crrl2->name));
                } 
            }

            assert (L(p)->sql_ann->tabname && R(p)->sql_ann->tabname);
            
            sql_stmt = select
                (
                 NULL,
                 from_list
                 (
                   alias
                   (
                    L(p)->sql_ann->tabname,
                    correlation_name (crrl1->name)
                   ), 
                   alias
                   (
                    R(p)->sql_ann->tabname,
                    correlation_name( crrl2->name )
                   ) 
                 ),
                 NULL,
                 NULL
                );

        } break;
        /* Rel: semijoin(Rel) */
        case 203:
        /* Rel: eqjoin(Rel) */
        case 8:
        {
            for (unsigned short i = 0; nts[i]; i++)
            {
                 /* make subsequent nodes of cross dirty to force
                  * a binding */
                 kids[i]->dirty = true;
                 reduce (kids[i], nts[i]);
            }

            sql_correlation_name_t *crrl1 = sql_correlation_name_new ();
            sql_correlation_name_t *crrl2 = sql_correlation_name_new ();

            /* copy all existing expressions */
            for (unsigned int i = 0;
                    i < PFarray_last (L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        L(p)->sql_ann->colmap, i);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type,
                        crrl_deco (
                            column_name (
                               entry.expression->sem.column.ident),
                            crrl1->name));
            }

            for (unsigned int i = 0;
                    i < PFarray_last (R(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        R(p)->sql_ann->colmap, i);
                if (!sql_expression_unsafe (p->sql_ann->colmap,
                            entry.att,entry.type)) {
                    sql_column_env_add (p->sql_ann->colmap,
                            entry.att, entry.type,
                            crrl_deco (
                                column_name (
                                    entry.expression->sem.column.ident),
                                crrl2->name));
                } 
            }

            sql_where_env_add (p->sql_ann->wheremap,
                    eq
                    (
                     crrl_deco (
                         column_name (
                             sql_expression (L(p)->sql_ann->colmap,
                                 p->sem.eqjoin.att1,
                                 type_of (L(p), p->sem.eqjoin.att1))->
                                 sem.column.ident),
                         crrl1->name),
                     crrl_deco (
                         column_name (
                             sql_expression (R(p)->sql_ann->colmap,
                                 p->sem.eqjoin.att2,
                                 type_of (R(p), p->sem.eqjoin.att2))->
                                 sem.column.ident),
                         crrl2->name)
                    ));

            assert (L(p)->sql_ann->tabname && R(p)->sql_ann->tabname);

            sql_stmt = select
                (
                 NULL,
                 from_list
                 (
                  alias
                  (
                   L(p)->sql_ann->tabname,
                   correlation_name (crrl1->name)
                  ),
                  alias
                  (
                   R(p)->sql_ann->tabname,
                   correlation_name (crrl2->name)
                  )
                 ),
                 NULL,
                 NULL
                );
        } break;
        /* Rel:      select_ (Rel) */
        case 19:
        {
            /* copy all existing expressions */
            for (unsigned int i = 0;
                    i < PFarray_last (L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        L(p)->sql_ann->colmap, i);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            /* copy existing wheremap */
            where_env_copy (L(p)->sql_ann->wheremap, p->sql_ann->wheremap);

            sql_where_env_add (p->sql_ann->wheremap,
                    sql_expression (p->sql_ann->colmap,
                        p->sem.select.att,
                        type_of (p, p->sem.select.att)));

            assert (L(p)->sql_ann->sfw);

            sql_stmt = select
                (
                 NULL,
                 L(p)->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                );
        } break;
        /* Rel:      difference (Rel, Rel) */
        case 24:
        {
            sql_stmt = bin_rel (PFsql_difference, p, L(p), R(p));
        } break;
        /* Rel:      disjunion (Rel,Rel) */
        case 20:
        {
            sql_stmt = bin_rel (PFsql_union, p, L(p), R(p));
        } break;
        /*  Rel: distinct (Rel)    */
        case 26:
        {
            /* copy all existing expressions */
            for (unsigned int i = 0;
                    i < PFarray_last (L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        L(p)->sql_ann->colmap, i);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            /* copy existing wheremap */
            where_env_copy (L(p)->sql_ann->wheremap, p->sql_ann->wheremap);

            sql_stmt = select_distinct
                (
                 NULL,
                 L(p)->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                );

            p->dirty = true;
        } break;
        /* Rel: project (Rel) */
        case 10:
        {

            for (unsigned int i=0; i < p->sem.proj.count; i++) {
                for (PFalg_simple_type_t t=1; t; t<<=1) {
                    if (t & TYPE_MASK(type_of(L(p),
                                p->sem.proj.items[i].old))) {
                        PFsql_t *sqlnode = sql_expression (
                            L(p)->sql_ann->colmap,
                            p->sem.proj.items[i].old, t);
                        sql_column_env_add (p->sql_ann->colmap,
                            p->sem.proj.items[i].new, t,
                            sqlnode);
                    }
                }
            }

            where_env_copy (L(p)->sql_ann->wheremap, p->sql_ann->wheremap);

            assert (L(p)->sql_ann->sfw);
                
            sql_stmt = select
                (
                 NULL, /* no selectlist provided */
                 L(p)->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                );
        } break;
        /* Rel:         num_add (Rel) */
        case 30:
        {
            assert (L(p)->sql_ann->sfw);
            switch (p->sem.fun_1to1.kind) {
                case alg_fun_num_add:
                    sql_stmt = bin_arith(PFsql_add, p);
                    break;
                case alg_fun_num_subtract:
                    sql_stmt = bin_arith(PFsql_sub, p);
                    break;
                case alg_fun_num_multiply:
                    sql_stmt = bin_arith(PFsql_mul, p);
                    break;
                case alg_fun_num_divide:
                    sql_stmt = bin_arith(PFsql_div, p);
                    break;
                default:
                    PFoops (OOPS_FATAL,
                            "SQLgen: Pathfinder doesn't support "
                            "this function");
            }
        } break;
        /* Rel:         num_subtract(Rel) */
        case 31:
        {
            assert (L(p)->sql_ann->sfw);
            sql_stmt = bin_arith (PFsql_sub, p);
        } break;
        /* Rel:         num_multiply(Rel) */
        case 32:
        {
            assert (L(p)->sql_ann->sfw);
            sql_stmt = bin_arith (PFsql_mul, p);
        } break;
        /* Rel: num_gt(Rel) */
        case 36:
        {
            assert (L(p)->sql_ann->sfw);
            sql_stmt = bin_comp (PFsql_gt, p);
        } break;
        /* Rel: num_eq(Rel) */
        case 37:
        {
            assert (L(p)->sql_ann->sfw);
            sql_stmt = bin_comp (PFsql_eq, p);
        } break;
        /* Rel:      rownum(Rel) */
        case 50:
        {
            /* copy all existing expressions */
            for  (unsigned int i = 0;
                    i < PFarray_last (L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        L(p)->sql_ann->colmap, i);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            where_env_copy (L(p)->sql_ann->wheremap, p->sql_ann->wheremap);
                    
            PFsql_t *srtbylist = NULL; 
            for (unsigned int j = 0; j < PFord_count (p->sem.rownum.
                            sortby); j++) {
                /* FIXME: cope with direction
                   PFord_order_dir_at(p->sem.rownum.sortby.j) */
                srtbylist = 
                        sortkey_expressions
                        (
                            srtbylist,
                            sql_expression (
                                L(p)->sql_ann->colmap,
                                PFord_order_col_at (p->sem.rownum.sortby, j),
                                type_of (L(p),
                                    PFord_order_col_at (p->sem.rownum.sortby,
                                        j)))
                        );
            }


            sql_column_env_add (p->sql_ann->colmap,
                p->sem.rownum.attname,
                type_of (p, p->sem.rownum.attname),
                over
                (
                 rownumber (),
                 window_clause
                 (
                  (p->sem.rownum.part == 0)?
                  NULL:
                  partition
                  (
                   part_expressions
                   ( 
                       sql_expression (L(p)->sql_ann->colmap,
                           p->sem.rownum.part,
                           type_of (L(p), p->sem.rownum.part))
                   )
                  ),
                  order_by
                  (
                   srtbylist
                  )
                 )
                ));
             
                assert (L(p)->sql_ann->sfw);

                sql_stmt = select
                    (
                     NULL,
                     L(p)->sql_ann->sfw->child[1],
                     NULL,
                     NULL
                    );

                p->dirty = true;
        } break;
        /* Rel:      number (Rel) */
        case 51:
        {
            /* copy all existing expressions */
            for (unsigned int i = 0; i < PFarray_last (
                    L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        L(p)->sql_ann->colmap, i);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            sql_column_env_add (p->sql_ann->colmap,
                    p->sem.number.attname,
                    type_of(p, p->sem.number.attname),
                    over
                    (
                     rownumber (),
                     window_clause
                     (
                      (p->sem.number.part == 0)?
                      NULL:
                      partition
                      (
                       part_expressions
                       ( 
                        sql_expression (L(p)->sql_ann->colmap,
                            p->sem.number.part,
                            type_of (L(p), p->sem.number.part))
                       ) 
                      ),
                      NULL
                     )
                    ));

             where_env_copy( L(p)->sql_ann->wheremap, p->sql_ann->wheremap);
            
             assert (L(p)->sql_ann->sfw);
             sql_stmt = select
                 (
                  NULL,
                  L(p)->sql_ann->sfw->child[1],
                  NULL,
                  NULL
                 );

             p->dirty = true;
        } break;
        /* Rel:   doc_access (Frag, Rel) */
        case 65:
        {
            sql_stmt = doc_access (p);
            p->dirty = true;
        } break;
        /* Rel:   element_tag (Rel, Rel) */
        case 500:
        {
            for (unsigned short i = 0; nts[i]; i++)
            {
                 /* make subsequent nodes of cross dirty to force
                    a binding */
                 kids[i]->dirty = true;
                 reduce (kids[i], nts[i]);
            }
        } break;
        /* FragRel: element (Frag, element_tag (Rel, Rel)) */ 
        case 101:
        {
            /* translating */
            sql_correlation_name_t *max_crrl = sql_correlation_name_new ();
            sql_correlation_name_t *e_crrl = sql_correlation_name_new ();
            sql_correlation_name_t *eloc_crrl = sql_correlation_name_new ();
            sql_correlation_name_t *t1loc_crrl =
                sql_correlation_name_new ();
            sql_correlation_name_t *t2loc_crrl =
                sql_correlation_name_new ();
            sql_correlation_name_t *t3loc_crrl =
                sql_correlation_name_new ();
            sql_correlation_name_t *qn_crrl = sql_correlation_name_new ();

            PFsql_t* new_elements =
                disjunion
                (
                 select
                 (
                  select_list
                  (
                   column_assign
                   (
                    crrl_deco (
                        column_name (
                            sql_expression (LR(p)->sql_ann->colmap,
                                p->sem.elem.item_qn, aat_qname)
                            ->sem.column.ident),
                        qn_crrl->name),
                        column_name (sql_special_name_new (
                                sql_col_prop)->ident)
                   ), /* prop */
                   column_assign
                   (
                    lit_int(ELEM),
                    column_name (sql_special_name_new (
                            sql_col_kind)->ident)
                   ), /* kind */
                   column_assign
                   (
                    lit_int (0),
                    column_name (sql_special_name_new (
                        sql_col_level)->ident)
                   ), /* level */
                   column_assign
                   (
                     sum
                     (
                      add
                      (
                       column_name (sql_special_name_new (
                           sql_col_size)->ident),
                       lit_int (1)
                      )
                     ),
                    column_name (sql_special_name_new (
                        sql_col_size)->ident)
                   ), /* size */
                   column_assign
                   (
                    lit_int (-2),
                    column_name (sql_special_name_new (
                        sql_col_pre)->ident)
                   ), /* pre */
                   column_assign
                   (
                    lit_int (0),
                    column_name (
                        sql_column_name_new (
                            att_pos, aat_nat)->ident)
                   ), 
                   column_assign
                   (
                    crrl_deco(
                        column_name (
                            sql_expression (LR(p)->sql_ann->colmap,
                                p->sem.elem.iter_qn,
                                type_of (LR(p), p->sem.elem.iter_qn))
                            ->sem.column.ident),
                        qn_crrl->name),
                        column_name (sql_column_name_new (
                                  att_iter, aat_nat)->ident)
                   )
                  ),
                  from_list
                  (
                   on
                   (
                    right_outer_join
                    (
                     on
                     (
                      inner_join
                      (
                       alias
                       (
                        RR(p)->sql_ann->tabname,
                        correlation_name (eloc_crrl->name)
                       ),
                       alias
                       (
                        collect_fragments (L(p)),
                        correlation_name (t1loc_crrl->name)
                       )
                      ),
                      eq
                      (
                       crrl_deco ( 
                           column_name (
                               sql_expression (RR(p)->sql_ann->colmap,
                                   p->sem.elem.item_val, aat_pre)
                               ->sem.column.ident),
                           eloc_crrl->name),
                       crrl_deco(
                           column_name (sql_special_name_new (
                               sql_col_pre)->ident),
                           t1loc_crrl->name)
                      )
                     ),
                     alias
                     (
                      LR(p)->sql_ann->tabname,
                      correlation_name (qn_crrl->name)
                     )
                    ),
                    eq
                    (
                     crrl_deco (
                         column_name (
                             sql_expression (LR(p)->sql_ann->colmap,
                                   p->sem.elem.iter_qn,
                                   type_of (LR(p), p->sem.elem.iter_qn))
                             ->sem.column.ident),
                         qn_crrl->name),
                     crrl_deco (
                         column_name (
                             sql_expression (RR(p)->sql_ann->colmap,
                                 p->sem.elem.iter_val,
                                 type_of (RR(p), p->sem.elem.iter_val))
                             ->sem.column.ident),
                         eloc_crrl->name)
                    ) 
                   )
                  ),
                  NULL,
                  column_list
                  (
                   crrl_deco(
                       column_name (
                           sql_expression (LR(p)->sql_ann->colmap,
                               p->sem.elem.iter_qn,
                               type_of (LR(p), p->sem.elem.iter_qn))
                           ->sem.column.ident),
                       qn_crrl->name),
                   crrl_deco(
                       column_name (
                           sql_expression (LR(p)->sql_ann->colmap,
                               p->sem.elem.item_qn,
                               type_of (LR(p), p->sem.elem.item_qn))
                           ->sem.column.ident),
                       qn_crrl->name))
                  ),
                  select
                  (
                   select_list
                   (
                    column_assign
                    (
                     crrl_deco (
                         column_name (sql_special_name_new (
                             sql_col_prop)->ident),
                         t3loc_crrl->name),
                     column_name (sql_special_name_new (
                         sql_col_prop)->ident)
                    ),
                    column_assign
                    (
                        crrl_deco (
                            column_name (sql_special_name_new (
                                sql_col_kind)->ident),
                            t3loc_crrl->name),
                        column_name(sql_special_name_new(
                            sql_col_kind)->ident)
                    ),
                    column_assign
                    (
                     add
                     (
                      sub
                      (
                       crrl_deco (
                           column_name (sql_special_name_new (
                               sql_col_level)->ident),
                           t3loc_crrl->name),
                       crrl_deco (
                           column_name (sql_special_name_new (
                               sql_col_level)->ident),
                           t2loc_crrl->name)
                      ),
                      lit_int (1)
                     ),
                     column_name (sql_special_name_new (
                         sql_col_level)->ident)
                    ),
                    column_assign
                    (
                     crrl_deco (
                         column_name (sql_special_name_new (
                             sql_col_size)->ident),
                         t3loc_crrl->name),
                     column_name(sql_special_name_new(
                         sql_col_size)->ident)
                    ),
                    column_assign
                    (
                     crrl_deco (
                         column_name (sql_special_name_new (
                             sql_col_pre)->ident),
                         t3loc_crrl->name),
                     column_name (sql_special_name_new (
                         sql_col_pre)->ident)
                    ),
                    column_assign
                    (
                        crrl_deco (
                            column_name (
                                sql_expression ( RR(p)->sql_ann->colmap,
                                     p->sem.elem.pos_val,
                                     type_of (RR(p), p->sem.elem.pos_val))
                                ->sem.column.ident),
                             eloc_crrl->name),
                         column_name (sql_column_name_new (
                                 att_pos, aat_nat)->ident)
                    ),
                    column_assign
                    (
                        crrl_deco (
                            column_name (
                                sql_expression (RR(p)->sql_ann->colmap,
                                    p->sem.elem.iter_val, type_of (
                                    RR(p), p->sem.elem.iter_val))
                                ->sem.column.ident),
                             eloc_crrl->name),
                         column_name (sql_column_name_new (
                                 att_iter, aat_nat)->ident))
                    ),
                    from_list
                    (
                     alias
                     (
                      RR(p)->sql_ann->tabname,
                      correlation_name (eloc_crrl->name)
                     ),
                     alias
                     (
                      collect_fragments (L(p)),
                      correlation_name (t2loc_crrl->name)
                     ),
                     alias
                     (
                      collect_fragments (L(p)),
                      correlation_name (t3loc_crrl->name)
                     )
                    ),
                    and_ 
                    (
                     eq
                     (
                      crrl_deco(
                          column_name (sql_special_name_new (
                              sql_col_pre)->ident),
                          t2loc_crrl->name),
                      crrl_deco (
                          column_name (
                              sql_expression (RR(p)->sql_ann->colmap,
                                  p->sem.elem.item_val, aat_pre)
                              ->sem.column.ident),
                          eloc_crrl->name)
                     ),
                     and_
                     (
                      gteq
                      (
                       crrl_deco (
                           column_name(sql_special_name_new(
                               sql_col_pre)->ident),
                           t3loc_crrl->name),
                       crrl_deco (
                           column_name (sql_special_name_new (
                               sql_col_pre)->ident),
                           t2loc_crrl->name)
                      ),    
                      gteq
                      (
                       add
                       (
                        crrl_deco (
                            column_name (sql_special_name_new (
                                sql_col_pre)->ident),
                            t2loc_crrl->name),
                        crrl_deco (
                            column_name (sql_special_name_new (
                                sql_col_size)->ident),
                            t2loc_crrl->name)
                       ),
                       crrl_deco (
                           column_name (sql_special_name_new (
                               sql_col_pre)->ident),
                           t3loc_crrl->name)
                      ) 
                     ) 
                    ),
                    NULL));

            sql_correlation_name_t *max_pre_crrl =
                sql_correlation_name_new ();

            PFsql_t *max_pre = select
                         (
                          select_list( column_assign(
                                  max
                                  (
                                   column_name(sql_special_name_new(
                                           sql_col_pre)->ident)
                                  ),
                                  column_name(sql_special_name_new(
                                          sql_col_pre)->ident))),
                          from_list( alias(
                                  max_pre_frag,
                                  correlation_name(
                                      max_pre_crrl->name))),
                          NULL,
                          NULL
                         );

            PFsql_t *new_elems =
                select
                (
                 select_list
                 (
                  column_assign
                  (
                   crrl_deco (
                       column_name (sql_special_name_new (
                               sql_col_prop)->ident),
                       e_crrl->name),
                   column_name(sql_special_name_new(
                       sql_col_prop) ->ident)
                  ), /* prop */
                  column_assign
                  (
                   crrl_deco (
                       column_name (sql_special_name_new (
                               sql_col_kind)->ident),
                       e_crrl->name),
                   column_name (sql_special_name_new (
                       sql_col_kind)->ident)
                  ), /* kind */
                  column_assign
                  (
                   crrl_deco (
                       column_name (sql_special_name_new (
                           sql_col_level)->ident),
                       e_crrl->name),
                   column_name (sql_special_name_new (
                       sql_col_level)->ident)
                  ), /*level */
                  column_assign
                  (
                   crrl_deco (
                       column_name (sql_special_name_new (
                           sql_col_size)->ident),
                       e_crrl->name),
                       column_name (sql_special_name_new (
                           sql_col_size)->ident)
                  ), /* size */
                  column_assign
                  (
                   add
                   (
                    crrl_deco (
                        column_name (sql_special_name_new (
                            sql_col_pre)->ident),
                        max_crrl->name),
                    over
                    (
                     rownumber (),
                     window_clause
                     (
                      NULL,
                      order_by
                      (
                       sortkey_expressions
                       (
                        crrl_deco (
                            column_name (sql_special_name_new (
                                sql_col_pre)->ident),
                            e_crrl->name),
                        crrl_deco (
                            column_name (sql_column_name_new (
                                att_pos, aat_nat)->ident),
                            e_crrl->name),
                        column_name (sql_column_name_new (
                            att_iter, aat_nat)->ident)
                       )
                      )
                     )
                    )
                   ),
                   column_name (sql_special_name_new (
                       sql_col_pre)->ident)), /* pre */
                   column_assign
                   (
                    crrl_deco (
                        column_name (sql_column_name_new (
                            att_iter, aat_nat)->ident),
                        e_crrl->name),
                    column_name (sql_column_name_new (
                        att_iter, aat_nat)->ident)
                   )
                  ),
                  from_list
                  (
                   alias
                   (
                    max_pre,
                    correlation_name (max_crrl->name)
                   ),
                   alias
                   (
                    new_elements,
                    correlation_name (e_crrl->name)
                   )
                  ),
                  NULL,
                  NULL
                 ); 

            sql_table_name_t *elem_tbl = sql_table_name_new ();

            execute( bind
                    (
                     table_name
                     (
                      elem_tbl->name,
                      column_list
                      (
                       column_name (sql_special_name_new (sql_col_prop)->ident),
                       column_name (sql_special_name_new (sql_col_kind)->ident),
                       column_name (sql_special_name_new (
                               sql_col_level)->ident),
                       column_name (sql_special_name_new (sql_col_size)->ident),
                       column_name (sql_special_name_new (sql_col_pre)->ident),
                       column_name (sql_column_name_new (
                               att_iter, aat_nat)->ident)
                      )
                     ),
                     new_elems
                    ) );

            p->sql_ann->fragment = select
                (
                 select_list
                 (
                  column_name (sql_special_name_new (sql_col_prop)->ident),
                  column_name (sql_special_name_new (sql_col_kind)->ident),
                  column_name (sql_special_name_new (sql_col_level)->ident),
                  column_name (sql_special_name_new (sql_col_size)->ident),
                  column_name (sql_special_name_new (sql_col_pre)->ident)
                 ),
                 from_list
                 (
                  alias
                  (
                   table_name_default (elem_tbl->name),
                   correlation_name (sql_correlation_name_new ()->name)
                  )
                 ),
                 NULL,
                 NULL
                );

            max_pre_frag = table_name_default (elem_tbl->name);

            sql_column_env_add( p->sql_ann->colmap,
                            p->sem.elem.item_res,
                            type_of(p, p->sem.elem.item_res),
                            crrl_deco(
                                column_name(sql_special_name_new(
                                        sql_col_pre)->ident),
                                e_crrl->name)
                            );

                 sql_column_env_add( p->sql_ann->colmap,
                         p->sem.elem.iter_res,
                         type_of(p, p->sem.elem.iter_res),
                         crrl_deco(
                             column_name(sql_column_name_new(
                                     att_iter, aat_nat)->ident),
                         e_crrl->name));
                 sql_where_env_add( p->sql_ann->wheremap,
                         eq
                         (
                          crrl_deco(
                              column_name(
                                  sql_special_name_new(
                                      sql_col_level)->ident),
                              e_crrl->name),
                          lit_int(0)
                         ));

                sql_stmt = select
                     (
                      NULL,
                      from_list
                      (
                       alias
                       (
                        table_name_default (elem_tbl->name),
                        correlation_name(e_crrl->name)
                       )
                      ),
                      
                      NULL,
                      NULL
                     );

                 p->dirty = true;

        } break;
        /* Rel:   string_join (Rel, Rel) */
        case 88:
        {
        /* even string_join is implemented as identity operator,
         * so it will handle most of the queries */
         sql_column_env_add (p->sql_ann->colmap,
                 p->sem.string_join.iter_res,
                 type_of (p, p->sem.string_join.iter_res),
                 sql_expression (L(p)->sql_ann->colmap,
                     p->sem.string_join.iter,
                     type_of (L(p), p->sem.string_join.iter))
                 );

         sql_column_env_add (p->sql_ann->colmap,
                 p->sem.string_join.item_res,
                 type_of (p, p->sem.string_join.item_res),
                 sql_expression (L(p)->sql_ann->colmap,
                     p->sem.string_join.item,
                     type_of (L(p), p->sem.string_join.item))
                 );
         
         sql_stmt = select
             (
              NULL,
              from_list (L(p)->sql_ann->sfw->child[1]),
              NULL,
              NULL
             );
        } break;
        /* FragRel:  merge_adjacent (Frag, Rel) */
        case 107:
        {
            /* implement this rule as identity operator */
            for (unsigned int col = 0; col < p->schema.count; col++) {
                for (PFalg_simple_type_t t = 1; t; t<<=1) {
                    if (t & TYPE_MASK(p->schema.items[col].type)) {
                        PFsql_t *sqlnode = sql_expression_unsafe (
                                R(p)->sql_ann->colmap,
                                p->schema.items[col].name, t);
                        if (!sqlnode) {
                            sqlnode = sql_expression (
                                    L(p)->sql_ann->colmap,
                                    p->schema.items[col].name, t);
                        }
                        sql_column_env_add (p->sql_ann->colmap,
                                p->schema.items[col].name, t,
                                sqlnode);
                    }
                }
            }

            p->sql_ann->fragment = collect_fragments (L(p));

            sql_stmt = select
                (
                 NULL,
                 R(p)->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                );
        } break;
        /* Frag:  frag_union(Frag, Frag) */
        case 111:
        {
            /* frag_union turns out to be an absolutely noop,
               the magic is implemented in those operations
               accessing this kind of node, to use the advantage
               of indexes */
        } break;
        /* Rel: cast (Rel) */
        case 58:
        {
            for (unsigned int i = 0; i < p->schema.count; i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & TYPE_MASK(p->schema.items[i].type)) {
                        if (p->schema.items[i].name ==
                                p->sem.type.res) {
                            sql_column_env_add (p->sql_ann->colmap,
                                    p->sem.type.res, t,
                                    cast
                                    (
                                     sql_expression (L(p)->sql_ann->colmap,
                                         p->sem.type.att,
                                         type_of (L(p), p->sem.type.att)),
                                     type (p->sem.type.ty)
                                    ));
                        }
                        else sql_column_env_add (p->sql_ann->colmap,
                                    p->schema.items[i].name, t,
                                    sql_expression (L(p)->sql_ann->colmap,
                                        p->schema.items[i].name, t)
                                    );
                    }
                }
            }

            where_env_copy (p->sql_ann->wheremap, L(p)->sql_ann->wheremap);

            sql_stmt = select
                (
                 NULL,
                 L(p)->sql_ann->sfw->child[1],
                 NULL,
                 NULL
                );
        } break;
        /* Rel: conderr (Rel) */
        case 80:
        {
            for (unsigned int i = 0; i < PFarray_last (
                    L(p)->sql_ann->colmap); i++) {
                sql_column_env_t entry = sql_column_env_at (
                        L(p)->sql_ann->colmap, i);
                sql_column_env_add (p->sql_ann->colmap,
                        entry.att, entry.type,
                        entry.expression);
            }

            sql_stmt = select
                (
                 NULL,
                 from_list (L(p)->sql_ann->sfw->child[1]),
                 NULL,
                 NULL
                );
        } break;
        /* Rel: bool_not (Rel) */
        case 40:
        {
             /* copy all existing expressions */
             for (unsigned int i = 0;
                     i < PFarray_last (L(p)->sql_ann->colmap); i++) {
                 sql_column_env_t entry = sql_column_env_at (
                         L(p)->sql_ann->colmap, i);
                 sql_column_env_add (p->sql_ann->colmap,
                         entry.att, entry.type,
                         entry.expression);
             }   

             sql_column_env_add (p->sql_ann->colmap,
                     p->sem.unary.res, type_of (p, p->sem.unary.res),
                     not_
                     (
                      sql_expression (L(p)->sql_ann->colmap,
                          p->sem.unary.att,
                          type_of (L(p), p->sem.unary.att))
                     )
                     );
             where_env_copy (p->sql_ann->wheremap, L(p)->sql_ann->wheremap);

             sql_stmt = select
                 (
                  NULL,
                  from_list (L(p)->sql_ann->sfw->child[1]),
                  NULL,
                  NULL
                 );
        } break;
        default:
        {
            /** add OOPS here to indicate an unimplemented rule */
            PFoops (OOPS_FATAL,
                    "SQLgen: Logical algebra rule (%u) not supported",
                    rule);
        } break;
    }

    /* override sfw only when is not dirty */
    if (sql_stmt) {
        p->sql_ann->sfw = sql_stmt;
        p->sql_ann->sfw = (DIRTY(p) && rule != 300)?NULL:sql_stmt;
    }
 
    /* BINDING */
    /* execute the statement at the end if the node is dirty,
       and bind it to a new SQL variable */
    if (sql_stmt)
    if (DIRTY(p) && rule != 300) {
        /* create a new table name for binding */ 
        sql_table_name_t   *newvar = sql_table_name_new ();
        /* bind the new variable to the sql annotation */
        p->sql_ann->tabname = table_name_default (newvar->name);
        
        /* first selectlist for select statement in p */
        PFsql_t* selectlist1 = NULL; 
        PFsql_t* selectlist2 = NULL; 
        PFsql_t* columnlist  = NULL; 
        PFsql_t* wherelist   = NULL; 

        /* correlation name for bounded table */
        sql_correlation_name_t *crrl = sql_correlation_name_new ();
 
        for (unsigned int i = 0;
                i < PFarray_last (p->sql_ann->wheremap); i++) {
            sql_where_env_t entry = sql_where_env_at (
                    p->sql_ann->wheremap, i);
            wherelist = where_list (wherelist, entry.expression);
        }
        
        for (unsigned int i = 0; i < p->schema.count; i++) {
            for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                if (t & TYPE_MASK(p->schema.items[i].type)) {
                    /* get the sql operation bound to
                     * att/type tuple */
                    PFsql_t *sqlnode = sql_expression (p->sql_ann->colmap,
                            p->schema.items[i].name, t);
                    
                    sql_column_name_t *colname =
                        ((sqlnode->kind == sql_clmn_name ) &&
                            (eq_type(p->schema.items[i].name,t,
                                     sqlnode->sem.column.ident)))?
                        NULL:
                        sql_column_name_new (p->schema.items[i].name, t);

                    /* add the sql operation to the select list */
                    selectlist1 = select_list (selectlist1,
                            ((sqlnode->kind == sql_clmn_name ) &&
                            (eq_type(p->schema.items[i].name,t,
                                     sqlnode->sem.column.ident)))?
                            /* the column name get not affected
                               by the new correlation name */
                            crrl_deco (
                                column_name (sqlnode->sem.column.ident),
                                sqlnode->crrlname):
                            column_assign (sqlnode,
                                column_name (colname->ident)));

                    /* create a column list for the variable
                       and for the select automatic generated
                       sfw statement in annotations. */
                   selectlist2 = select_list (selectlist2,
                           crrl_deco (
                               ((sqlnode->kind == sql_clmn_name ) &&
                               (eq_type(p->schema.items[i].name,t,
                                     sqlnode->sem.column.ident)))?
                               column_name (
                                   IS_PRE(sqlnode->sem.column.ident)?
                                   sql_column_name_new(p->schema.
                                       items[i].name,t)->ident:
                               sqlnode->sem.column.ident):
                               column_name (IS_PRE(colname->ident)?
                                   sql_column_name_new(p->schema.
                                       items[i].name, t)->ident:
                               colname->ident),
                               crrl->name));

                   /* create columnlist for the table name */
                   columnlist = column_list (columnlist,
                        ((sqlnode->kind == sql_clmn_name ) &&
                            (eq_type(p->schema.items[i].name,t,
                                     sqlnode->sem.column.ident)))?
                           /* regarding the correlation
                              names both columns are unbounded */
                             column_name(
                                 IS_PRE(sqlnode->sem.column.ident)?
                                 sql_column_name_new (p->schema.
                                     items[i].name, t)->ident:
                                     sqlnode->sem.column.ident):
                             column_name(
                                 IS_PRE(colname->ident)?
                                 sql_column_name_new (
                                     p->schema.items[i].name, t)->ident:
                                 colname->ident));
                   
                   /* override expression with columnname */
                   sql_override_expr (p->sql_ann->colmap,
                       p->schema.items[i].name, t,
                       ((sqlnode->kind == sql_clmn_name ) &&
                       (eq_type(p->schema.items[i].name,t,
                       sqlnode->sem.column.ident)))?
                       IS_PRE(sqlnode->sem.column.ident)?
                       sql_column_name_new(p->schema.items[i].name,
                               t)->ident:
                       sqlnode->sem.column.ident:
                       IS_PRE(colname->ident)?
                       sql_column_name_new(
                           p->schema.items[i].name, t)->ident:
                       colname->ident, crrl->name);
                }
            }
        }

        p->sql_ann->wheremap = sql_where_env_new ();
       
        if (sql_stmt->kind == sql_select) {
            sql_stmt->child[0] = selectlist1;
            sql_stmt->child[3] = 
                (!wherelist)?
                NULL:
                wherelist;
        }

        execute( 
                  bind
                  (
                      table_name (newvar->name, columnlist),
                      sql_stmt
                  )
               );

        /** override sfw node with a valid select node */
        p->sql_ann->sfw =
            select
            (
             selectlist2,
             from_list
             (
              alias(p->sql_ann->tabname,
                  correlation_name(crrl->name))
             ),
             NULL,
             NULL
            );
    }
    
}

static PFsql_t*
gen_select (const PFla_op_t *p, PFsql_alg_ann_t *ann)
{
    /* first selectlist for select statement in p */
    PFsql_t* selectlist1 = NULL; 
    PFsql_t* wherelist   = NULL; 

    for (unsigned int i = 0;
                i < PFarray_last(ann->wheremap); i++) {
        sql_where_env_t entry = sql_where_env_at (
                ann->wheremap, i);
        wherelist = where_list (wherelist, entry.expression);
    }
    for (unsigned int i = 0; i < p->schema.count; i++) {
        for (PFalg_simple_type_t t = 1; t; t <<= 1) {
            if (t & TYPE_MASK(p->schema.items[i].type)) {
                    
                /* get the sql operation bound to
                 * att/type tuple */
                PFsql_t   *sqlnode = sql_expression (
                        ann->colmap,
                        p->schema.items[i].name, t);
                    
                sql_column_name_t *colname =
                    ((sqlnode->kind == sql_clmn_name ) &&
                        (eq_type(p->schema.items[i].name,t,
                                 sqlnode->sem.column.ident)))?
                    NULL:
                    sql_column_name_new (
                        p->schema.items[i].name, t);

                /* add the sql operation to the select list */
                selectlist1 = select_list(selectlist1,
                        ((sqlnode->kind == sql_clmn_name ) &&
                        (eq_type(p->schema.items[i].name,t,
                                 sqlnode->sem.column.ident)))?
                        /* the column name get not affected
                           by the new correlation name */
                        crrl_deco(
                        column_name(sqlnode->sem.column
                            .ident),
                        sqlnode->crrlname):
                        column_assign(
                            sqlnode,
                            /* column is unbounded because */
                            column_name(
                                colname->ident
                                )));

            }
        }
    }

    return select
        (
            selectlist1,
            NULL,
            wherelist,
            NULL
        );

}

static PFsql_t*
literal (PFalg_atom_t atom)
{
    switch( atom.type ) {
        case aat_nat:
        case aat_int:   return lit_int (atom.val.nat_);
        case aat_str:   return lit_str (atom.val.str);
        case aat_bln:   return lit_bln (atom.val.bln);
        case aat_dbl:
        case aat_dec:   return lit_dec (atom.val.dec_);
        case aat_qname: return lit_str (PFqname_loc (atom.val.int_));
        default:
            break;
    }

    PFoops( OOPS_FATAL,
            "SQLgen: a relational algebra type (0x%X) has not "
            "been implemented", atom.type);

    return NULL; /* satisfy picky compilers */
}

static PFalg_simple_type_t
type_of(PFla_op_t *n, PFalg_att_t att)
{
    assert( n );

    for (unsigned int i = 0; i < n->schema.count; i++) {
        if (n->schema.items[i].name == att) {
            return TYPE_MASK(n->schema.items[i].type);
        }
    }

    PFoops (OOPS_FATAL,
            "SQLgen: cannot determine implementation type of "
            "algebra expression");

    return aat_nat; /* satisfy picky compilers */ 
}

static PFsql_t* 
bin_cmp (PFsql_t* (*op) (const PFsql_t *, const PFsql_t*),
         PFla_op_t *p, PFalg_simple_type_t arg_ty)
{
    for (unsigned int i=0;
            i < PFarray_last (L(p)->sql_ann->colmap); i++) {
        sql_column_env_t entry = sql_column_env_at (
                L(p)->sql_ann->colmap, i);
        sql_column_env_add(p->sql_ann->colmap,
                entry.att, entry.type, entry.expression);
    }

    where_env_copy (L(p)->sql_ann->wheremap, p->sql_ann->wheremap);

    for (unsigned int col = 0; col < p->schema.count; col++) {
        for (PFalg_simple_type_t t = 1; t; t<<=1) {
            if (t & TYPE_MASK(p->schema.items[col].type)) {
                sql_column_env_add(p->sql_ann->colmap,
                        p->schema.items[col].name, t,
                        op
                        (
                         sql_expression(p->sql_ann->colmap,
                             p->sem.binary.att1,
                             arg_ty),
                         sql_expression(p->sql_ann->colmap,
                             p->sem.binary.att2,
                             arg_ty)
                        ));
            }
        }
    }

    return select
        (
         NULL, /* no selectlist provided */
         L(p)->sql_ann->sfw->child[1],
         NULL,
         NULL
        );
}

static PFsql_t* 
bin_op (PFsql_t* (*op) (const PFsql_t *, const PFsql_t*),
        PFla_op_t *p, PFalg_simple_type_t arg_ty,
        PFalg_simple_type_t res_ty)
{
    for (unsigned int i=0;
            i < PFarray_last (L(p)->sql_ann->colmap); i++) {
        sql_column_env_t entry = sql_column_env_at(
                L(p)->sql_ann->colmap, i);

        sql_column_env_add(p->sql_ann->colmap,
                entry.att, entry.type, entry.expression);
    }

    where_env_copy(L(p)->sql_ann->wheremap,
            p->sql_ann->wheremap);

    for( unsigned int col = 0; col < p->schema.count; col++ ) {
        for( PFalg_simple_type_t t = 1; t; t<<=1 ) {
            if( t & TYPE_MASK(p->schema.items[col].type) ) {
                sql_column_env_add(p->sql_ann->colmap,
                        p->schema.items[col].name,
                        t,
                        op
                        (
                         sql_expression(p->sql_ann->colmap,
                             p->sem.fun_1to1.refs.atts[0],
                             arg_ty),
                         sql_expression(p->sql_ann->colmap,
                             p->sem.fun_1to1.refs.atts[1],
                             arg_ty)
                        ));
            }
        }
    }

    res_ty = res_ty;

    return select
        (
         NULL, /* no selectlist provided */
         from_list (L(p)->sql_ann->sfw->child[1]),
         NULL,
         NULL
        );
}

static PFsql_t*
bin_rel(PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p, PFla_op_t *l, PFla_op_t *r)
{
    PFsql_t *selectlist1 = NULL; 
    PFsql_t *selectlist2 = NULL; 

    for(unsigned int i = 0; i < p->schema.count; i++) {
        for(PFalg_simple_type_t t=1; t; t<<=1) {
            if( t & TYPE_MASK(p->schema.items[i].type) ) {
                /*
                 * Type t is in the result relation.
                 * See if it is also in the left
                 * operand.
                 */
                if( !(t & type_of(l, 
                            p->schema.items[i].name)) ) {
                    /* add null to the colmap */
                    sql_column_env_add(
                            L(p)->sql_ann->colmap,
                            p->schema.items[i].name,
                            t,
                            cast(null(),type(t)));
                }

                PFsql_t *sqlnode = 
                    sql_expression(
                            l->sql_ann->colmap,
                            p->schema.items[i].name, t);

                selectlist1 = select_list(
                        selectlist1,
                        ((sqlnode->kind == sql_clmn_name ) &&
                        (eq_type(p->schema.items[i].name,t,
                                 sqlnode->sem.column.ident)))?
                        crrl_deco(
                        column_name(sqlnode->sem.column.ident),
                        sqlnode->crrlname):
                        column_assign
                        (
                         sqlnode,
                         column_name(
                             sql_column_name_new(
                                 p->schema.items[i].name,
                                 t)->ident
                             )
                        ));
                        

                /*
                 * Type t is in the result relation.
                 * See if it is also in the left
                 * operand.
                 */
                if( !(t & type_of(R(p),
                                p->schema.items[i].name)) ) {
                    /* add null to the colmap */
                    sql_column_env_add(
                            r->sql_ann->colmap,
                            p->schema.items[i].name,
                            t,
                            cast(null(),type(t)));
                }

                sqlnode =
                    sql_expression(
                            r->sql_ann->colmap,
                            p->schema.items[i].name, t);

                selectlist2 = select_list(
                        selectlist2,
                        ((sqlnode->kind == sql_clmn_name ) &&
                        (eq_type(p->schema.items[i].name,t,
                                 sqlnode->sem.column.ident)))?
                        crrl_deco(
                        column_name(sqlnode->sem.column.ident),
                        sqlnode->crrlname):
                        column_assign
                        (
                         sqlnode,
                         column_name(
                             sql_column_name_new(
                                 p->schema.items[i].name,
                                 t)->ident
                             )
                        ));

                sql_column_env_add(
                        p->sql_ann->colmap,
                        p->schema.items[i].name,
                        t,
                        column_name(
                            sql_column_name_new(
                                p->schema.items[i].name,
                                t)->ident));
            }
        }
}

PFsql_t *wherelist1 = NULL; 
PFsql_t *wherelist2 = NULL; 

for( unsigned int i = 0; i < PFarray_last(
            l->sql_ann->wheremap); i++) {
    sql_where_env_t entry = sql_where_env_at(
            l->sql_ann->wheremap, i);
    wherelist1 = where_list(wherelist1,
                entry.expression);
}

for( unsigned int i = 0; i < PFarray_last(
            r->sql_ann->wheremap); i++) {
    sql_where_env_t entry = sql_where_env_at(
        r->sql_ann->wheremap, i);
    wherelist2 = where_list(wherelist2,
            entry.expression);
}

/* create an union from two selects */
if( L(p)->sql_ann->sfw && R(p)->sql_ann->sfw )
    return op 
        (
         select
         (
          selectlist1,
          l->sql_ann->sfw->child[1],
          wherelist1,
          NULL
         ),
         select
         (
          selectlist2,
          r->sql_ann->sfw->child[1],
          wherelist2,
          NULL
         ) 
        );
        else return NULL;
}

/**
 * Generic binary arithmetic operator. In addition to bin_op()
 * does addition type checks.
 */
static PFsql_t* 
bin_arith(PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p)
{
    PFalg_simple_type_t ty = type_of(L(p), p->sem.fun_1to1.refs.atts[0] );

    /* second operand must have the same type as the first */
    assert( ty == type_of( L(p), p->sem.fun_1to1.refs.atts[0]) );
    assert( ty == aat_int || ty == aat_dec || ty == aat_dbl ||
            ty == aat_str );

    return bin_op(op, p, ty, ty);
}

static PFsql_t*
bin_comp (PFsql_t* (*op) (const PFsql_t*, const PFsql_t*),
        PFla_op_t *p)
{
    PFalg_simple_type_t ty = type_of (L(p), p->sem.binary.att1 );

    /* second operand must have the same type as the first */
    assert ( ty == type_of(L(p), p->sem.binary.att1));
    assert ( ty == aat_int || ty == aat_dec ||
            ty == aat_dbl || ty == aat_str ||
            ty == aat_bln || ty == aat_nat ||
            ty == aat_qname || aat_pre);
    return bin_cmp (op, p, ty);
}

#if 0
        gcc: defined but never used

static void
column_env_copy(PFarray_t *srccolmap, PFarray_t *destcolmap)
{
    for(unsigned int i = 0; i < PFarray_last(srccolmap); i++) {
        sql_column_env_t entry = sql_column_env_at(
                srccolmap, i);
        sql_column_env_add(destcolmap,
                entry.att, entry.type, entry.expression);
    }
}
#endif

static void
where_env_copy(PFarray_t *srcwheremap, PFarray_t *destwheremap)
{
    for(unsigned int i = 0; i < PFarray_last(srcwheremap); i++) {
        sql_where_env_t entry = sql_where_env_at(
                srcwheremap, i);
        sql_where_env_add(destwheremap,
                entry.expression);
    }
}

#if 0
   gcc: defined but not used
static PFsql_t*
llscj_desc_self_elem()
{
    return NULL;
}

static PFsql_t*
llscj_elem(PFalg_axis_t axis)
{
    switch( axis ) {
        case alg_desc_s:
            return llscj_desc_self_elem();
        default:
            return NULL;
    }
    return NULL;
}

static PFsql_t*
llscj_desc_self_elem_nsloc()
{
    return NULL;
}

static PFsql_t*
llscj_elem_nsloc(PFalg_axis_t axis)
{
    switch( axis ) {
        case alg_desc_s:
            return llscj_desc_self_elem_nsloc();
        default:
            return NULL;
    }
    return NULL;
}

static PFsql_t*
llscj_desc_self_elem_loc()
{
    return NULL;
}
#endif

static void
llscj_axis(PFalg_axis_t axis, PFsql_correlation_name_t c1,
        PFsql_correlation_name_t c2, 
        PFsql_t **fromlist, const PFla_op_t *frag,
        struct PFsql_alg_ann_t *ann)
{
    assert( frag->sql_ann->fragment );
    switch( axis ) {
        /* ancestor axis */
        case alg_anc:
        {
            sql_where_env_add( ann->wheremap,
                    gt
                    (
                     crrl_deco(
                         column_name(
                              sql_special_name_new(sql_col_level)->ident),
                         c2),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_level)->ident),
                         c1)
                    ));
            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c2),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c2)
                     ),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c1)
                    ));
            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c2),
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c1),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c1)
                     )
                    ));
        } break;
        /* ancestor-or-self axis */
        case alg_anc_s:
        {
            sql_where_env_add( ann->wheremap,
                    gt
                    (
                     crrl_deco(
                         column_name(
                              sql_special_name_new(sql_col_level)->ident),
                         c2),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_level)->ident),
                         c1)
                    ));
            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c2),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c2)
                     ),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c1)
                    ));
            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c2),
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c1),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c1)
                     )
                    ));

        } break;
        /* child axis */
        case alg_chld:
        {
            sql_where_env_add( ann->wheremap,
                    gt
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c1),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c2)
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c2),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c2)
                     ),
                     crrl_deco( column_name (
                             sql_special_name_new(sql_col_pre)->ident),
                         c1)
                    ));

            sql_where_env_add( ann->wheremap,
                    eq
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_level)->ident),
                         c1),
                     add(
                         crrl_deco(
                             column_name(
                                 sql_special_name_new(sql_col_level)->ident),
                             c2),
                         lit_int(1)
                        )
                    ));
        } break;
        /* descendant axis */
        case alg_desc:
        {
            sql_where_env_add( ann->wheremap,
                    gt
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c1),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c2)
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c2),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c2)
                     ),
                     crrl_deco( column_name (
                             sql_special_name_new(sql_col_pre)->ident),
                         c1)
                    ));
        } break;
        /* descendant-or-self axis */
        case alg_desc_s:
        {
            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c1),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c2)
                     /*sql_expression(R(p)->sql_ann->colmap,
                         p->sem.scjoin.item, aat_pre)*/
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c2),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c2)
                     ),
                     crrl_deco( column_name (
                             sql_special_name_new(sql_col_pre)->ident),
                         c1)
                    ));
        } break;
        /* following-sibling axis */
        case alg_fol_s:
        {
            sql_where_env_add( ann->wheremap,
                    eq
                    (
                     crrl_deco(
                         column_name(sql_special_name_new(sql_col_level)->ident
                             ),
                         c1),
                     crrl_deco(
                         column_name(sql_special_name_new(sql_col_level)->ident
                             ),
                         c2)
                    ));
        } /* continue with follwing */
        /* following axis */
        case alg_fol:
        {
            sql_where_env_add( ann->wheremap,
                    gt
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c1),
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c2),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c2)
                     )
                    ));

            sql_correlation_name_t *crrl = sql_correlation_name_new();

            *fromlist = from_list_add( *fromlist, 
                    alias(frag->sql_ann->fragment,
                        correlation_name(crrl->name)));

            /* get parent of context node */
            sql_where_env_add( ann->wheremap,
                    eq
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_level)->ident),
                         crrl->name),
                     sub
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_level)->ident),
                          c2),
                      lit_int(1)
                     )
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          crrl->name),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          crrl->name)
                     ),
                     crrl_deco(
                         column_name( sql_special_name_new(sql_col_pre)->ident
                             ),
                         c2)
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c2),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c2)
                     ),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident
                             ),
                         crrl->name)
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          crrl->name),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          crrl->name)
                     ),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c1)
                    ));
 
        } break;
        /* parent axis */
        case alg_par:
        {
            sql_where_env_add( ann->wheremap,
                    eq
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_level)->ident),
                         c1),
                     sub
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_level)->ident),
                          c2),
                      lit_int(1)
                     )
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c1),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c1)
                     ),
                     crrl_deco(
                         column_name( sql_special_name_new(sql_col_pre)->ident
                             ),
                         c2)
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c2),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c2)
                     ),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident
                             ),
                         c1)
                    ));
        } break;
        /* preceding-sibling axis */
        case alg_prec_s:
        {
            sql_where_env_add( ann->wheremap,
                    eq
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_level)->ident),
                         c1),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_level)->ident),
                         c2)
                    ));

            sql_correlation_name_t *crrl = sql_correlation_name_new();

            *fromlist = from_list_add( *fromlist, 
                    alias(frag->sql_ann->fragment,
                        correlation_name(crrl->name)));

            /* get parent of context node */
            sql_where_env_add( ann->wheremap,
                    eq
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_level)->ident),
                         crrl->name),
                     sub
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_level)->ident),
                          c2),
                      lit_int(1)
                     )
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          crrl->name),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          crrl->name)
                     ),
                     crrl_deco(
                         column_name( sql_special_name_new(sql_col_pre)->ident
                             ),
                         c2)
                    ));

            sql_where_env_add( ann->wheremap,
                    gteq
                    (
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c2),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c2)
                     ),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident
                             ),
                         crrl->name)
                    ));

            sql_where_env_add( ann->wheremap,
                    gt
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c1),
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         crrl->name)
                    ));

        } /* continue with preceding axis */
        /* preceding axis */
        case alg_prec:
        {
            sql_where_env_add( ann->wheremap,
                    gt
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c2),
                     add
                     (
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_pre)->ident),
                          c1),
                      crrl_deco(
                          column_name(
                              sql_special_name_new(sql_col_size)->ident),
                          c1)
                     )
                    ));
        } break;
        /* self axis */
        case alg_self:
        {
            sql_where_env_add( ann->wheremap,
                    eq
                    (
                     crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c1),
                    crrl_deco(
                         column_name(
                             sql_special_name_new(sql_col_pre)->ident),
                         c2)
                    ));
        } break;
        default:
            PFoops( OOPS_FATAL,
                    "SQLgen: axis not supported");
    }
}

static void
llscj_elem(PFalg_axis_t axis, PFsql_correlation_name_t c1,
        PFsql_correlation_name_t c2, const PFla_op_t *frag,
        PFsql_t **fromlist, struct PFsql_alg_ann_t *ann)
{
    assert( frag->sql_ann->fragment );
    
    sql_where_env_add( ann->wheremap,
        eq
        (
         crrl_deco(
             column_name(
                 sql_special_name_new(sql_col_kind)->ident),
             c1),
         lit_int(ELEM)
        ));

    llscj_axis( axis, c1, c2, fromlist, frag, ann);
}

static void
llscj_text(PFalg_axis_t axis, PFsql_correlation_name_t c1,
        PFsql_correlation_name_t c2, const PFla_op_t *frag,
        PFsql_t **fromlist, struct PFsql_alg_ann_t *ann)
{
    assert( frag->sql_ann->fragment );
    sql_where_env_add( ann->wheremap,
        eq
        (
         crrl_deco(
             column_name(
                 sql_special_name_new(sql_col_kind)->ident),
             c1),
         lit_int(TEXT)
        ));

    llscj_axis(axis, c1, c2, fromlist, frag, ann);    
}

static void
llscj_comm(PFalg_axis_t axis, PFsql_correlation_name_t c1,
        PFsql_correlation_name_t c2, const PFla_op_t *frag,
        PFsql_t **fromlist, struct PFsql_alg_ann_t *ann)
{
    assert( frag->sql_ann->fragment );
    
    sql_where_env_add( ann->wheremap,
            eq
            (
             crrl_deco(
                 column_name(
                     sql_special_name_new(sql_col_kind)->ident),
                 c1),
             lit_int(COMM)
            ));

    llscj_axis(axis, c1, c2, fromlist, frag, ann);
}

#define llscj_elem_nsloc(ax, ns, loc, c1, c2, frag, fr, ann) \
   llscj_elem_loc(ax, loc, c1, c2, frag, fr, ann)
static void
llscj_elem_loc(PFalg_axis_t axis, PFsql_t *loc, PFsql_correlation_name_t c1,
        PFsql_correlation_name_t c2, const PFla_op_t *frag,
        PFsql_t **fromlist, struct PFsql_alg_ann_t *ann)
{
    assert( frag->sql_ann->fragment );

    sql_where_env_add( ann->wheremap,
            eq
            (
             crrl_deco(
                 column_name(
                     sql_special_name_new(sql_col_kind)->ident),
                 c1),
             lit_int(ELEM)
            ));

    sql_where_env_add( ann->wheremap,
            eq
            (
             crrl_deco(
                 column_name(
                     sql_special_name_new(sql_col_prop)->ident),
                 c1),
             loc
            ));

    llscj_elem( axis, c1, c2, frag, fromlist, ann);
}

static struct PFsql_alg_ann_t*
llscj(PFalg_axis_t axis, const PFla_op_t *frag, const PFla_op_t *p)
{
    assert( frag->sql_ann->fragment );
    
    /* initialize the environment to fill */
    PFsql_alg_ann_t *ret = sql_alg_ann_new();
    
    /* abbreviations for input expressions */
    PFty_t ty = p->sem.scjoin.ty;
    PFsql_t *iter;
    PFsql_t *item;

    /* get attribute names of scj */
    PFalg_att_t pa_iter = p->sem.scjoin.iter;
    PFalg_att_t pa_item = p->sem.scjoin.item;

    /*
     * Determine generic input arguments.
     */
    assert(p); assert(R(p)); assert( R(p)->sql_ann->colmap );
    iter = sql_expression( R(p)->sql_ann->colmap,
            pa_iter, aat_nat); assert( iter );
    item = sql_expression( R(p)->sql_ann->colmap,
            pa_item, aat_pre); assert( item );

    /*PFsql_correlation_name_t crrl = item->crrlname;*/ 
    /* get new correlation name for frag expression */
    sql_correlation_name_t *crrl1 = sql_correlation_name_new();
    sql_correlation_name_t *crrl2 = sql_correlation_name_new();

    /* copy iter and item expression to current environment */
    sql_column_env_add(ret->colmap,
                pa_iter, aat_nat,
                iter
            );
    sql_column_env_add(ret->colmap,
                pa_item, aat_pre,
                crrl_deco(
                    column_name(sql_special_name_new(sql_col_pre)->ident),
                    crrl1->name
                )
            );

    /* copy existing wheremap */
    for( unsigned int i = 0; i < PFarray_last(
                R(p)->sql_ann->wheremap); i++ ) {
        sql_where_env_t entry = sql_where_env_at(
                R(p)->sql_ann->wheremap, i);
        sql_where_env_add( ret->wheremap,
                entry.expression );
    }

    sql_where_env_add( ret->wheremap,
            eq
            (
             crrl_deco(
                 column_name(
                     sql_special_name_new(sql_col_pre)->ident),
                 crrl2->name),
             item
            ));


    PFsql_t *fromlist = R(p)->sql_ann->sfw->child[1];
    /* this new relation we need to get the attributes beside the pre
       value */
    fromlist = from_list_add( fromlist, alias(frag->sql_ann->fragment,
                correlation_name(crrl2->name)));
    /* this relation we need to get the new elements we want to find
       with the axis steps */
    fromlist = from_list_add( fromlist, alias(frag->sql_ann->fragment,
                correlation_name(crrl1->name)));

    if( PFty_subtype( ty, PFty_xs_anyElement ())) {
        /* This is a test for element nodes */

        /* This is just a generic element kind test */
        if( PFty_subtype( PFty_xs_anyElement(), ty) ) {
            llscj_elem( axis, crrl1->name, crrl2->name, frag,
                    &fromlist, ret);
        }
        /* test on element kind and local name only */
        else if( PFty_subtype(
                    PFty_elem( PFqname( PFns_wild,
                            PFqname_loc (PFty_name( PFty_defn (ty)))),
                        PFty_xs_anyType()),
                    ty)) {
            llscj_elem_loc( axis,
                    lit_str( PFqname_loc( PFty_name( PFty_defn( ty ) ))),
                    crrl1->name, crrl2->name, frag, &fromlist, ret);
        }
        /* test on element kind and namespace only */
        else if (PFty_subtype(
                    PFty_elem (PFqname( PFqname_ns (PFty_name( PFty_defn(ty))),
                            NULL),
                        PFty_xs_anyType()),
                    ty)) {
            PFoops( OOPS_FATAL,
                    "SQLgen: namespace tests only not supported");
        }
        /* test on element and full QName */
        else if (PFty_subtype (
                    PFty_elem (PFty_name (PFty_defn (ty)),
                        PFty_xs_anyType()),
                    ty)) {
            /* we simply ignore the namespace here */
            llscj_elem_nsloc( axis, 
                    lit_str(""),
                    lit_str( PFqname_loc( PFty_name( PFty_defn( ty ) ))),
                    crrl1->name, crrl2->name, frag, &fromlist, ret);
        }
        /*
         * We couldn't figure out what element test we got, give up.
         */
        else {
            PFoops( OOPS_FATAL,
                    "SQLgen: problem with an XPath step: cannot evaluate "
                    "node test `%s'", PFty_str( ty ));
        }
    }
    else if( PFty_subtype( ty, PFty_text()) ) {
        llscj_text( axis, crrl1->name, crrl2->name, frag, &fromlist,
                ret); 
    }
    else if( PFty_subtype( ty, PFty_comm()) ) {
        llscj_comm( axis, crrl1->name, crrl2->name, frag, &fromlist, ret);
    }
    else {
        PFoops( OOPS_FATAL,
                "SQLgen: we couldn't figure out what we test "
                "in staircase join");
    }

    ret->sfw = gen_select(p, ret);
    ret->sfw->child[1] = fromlist;
 
    return ret;
}

#if 0
static PFsql_t*
llscj_rec(PFalg_axis_t axis, PFla_op_t *frag, PFla_op_t *p)
{
      /* condition to terminate the recursion */
      if( frag->kind == la_fragment ) {
          /* perform a scj on the actual fragment */
          return llscj(axis, p, frag);
      } else if( frag->kind == la_empty_frag ) {
          PFsql_t* fromlist = from_list_empty();
          fromlist = from_list_add(fromlist,
                         alias( tab_name( schema(SYSIBM),
                                 sysdummy1()),
                             correlation_name(
                                 sql_correlation_name_new()->name) ) );

          return select(
                     select_list(
                         column_assign(
                             cast(null(), type(aat_nat)),
                             column_name(
                                 sql_column_name_new(att_iter, aat_nat)
                                 ->ident)), 
                         column_assign(
                             cast(null(), type(aat_int)),
                             column_name(
                                 sql_column_name_new(att_item, aat_pre)
                                 ->ident)
                             )),
                     from_list(
                         alias(tab_name(schema(SYSIBM), sysdummy1()),
                             correlation_name(
                                 sql_correlation_name_new()->name))),
                     NULL,
                     NULL
                  );
      }
      else if( (frag->kind == la_frag_union) &&
              (L(frag)->kind == la_empty_frag)) {
          return llscj(axis, p, R(frag));
      }
      /* go on with the recursion if we find a
         frag_union */
      else if( frag->kind == la_frag_union ) {
          return disjunion
              (
               llscj_rec(axis, L(frag), p),
               llscj_rec(axis, R(frag), p)
              );
      }
      /* we should never reach this codeline */
      assert( 0 );
      return NULL; /* satisfy sticky compilers */
}
#endif

static PFsql_t*
doc_access (PFla_op_t *p)
{
    /* copying environment */
    for (unsigned int i = 0;
            i < PFarray_last (R(p)->sql_ann->colmap); i++) {
        sql_column_env_t entry = sql_column_env_at (
                R(p)->sql_ann->colmap, i);
        sql_column_env_add (p->sql_ann->colmap,
                entry.att, entry.type,
                entry.expression);
    }
    /* get new correlation name */
    sql_correlation_name_t *crrl = sql_correlation_name_new ();
    
    /* adding prop column containing the property we
       are connecting */
    sql_column_env_add (p->sql_ann->colmap,
            p->sem.doc_access.res, type_of (p, p->sem.doc_access.res),
            crrl_deco (
                column_name (
                    sql_special_name_new (sql_col_prop)->ident),
                crrl->name));

    /* copy wheremaps */
    for (unsigned int i = 0;
            i < PFarray_last (R(p)->sql_ann->wheremap); i++) {
        sql_where_env_t entry = sql_where_env_at (
                R(p)->sql_ann->wheremap, i);
        sql_where_env_add (p->sql_ann->wheremap,
                entry.expression);
    }

    /* add constraint to get only the rows we are interested in */
    sql_where_env_add (p->sql_ann->wheremap,
            eq
            (
             sql_expression (R(p)->sql_ann->colmap,
                 p->sem.doc_access.att,
                 type_of (p, p->sem.doc_access.att)),
             crrl_deco (
                 column_name (sql_special_name_new (sql_col_pre)->ident),
                 crrl->name)
            ));

    switch (p->sem.doc_access.doc_col)
    {
        case doc_text:
            /* add constraints to get text nodes */
            sql_where_env_add (p->sql_ann->wheremap,
                eq
                (
                 crrl_deco (
                     column_name (
                         sql_special_name_new (sql_col_kind)->ident),
                     crrl->name),
                 lit_int (TEXT)
                ));
            break;
        default:
            PFoops (OOPS_FATAL,
                    "SQLgen: this kind (%u) by doc access",
                    p->sem.doc_access.doc_col);
            break;
    }
    
    PFsql_t * fromlist = R(p)->sql_ann->sfw->child[1];
    fromlist = from_list_add
        (
         fromlist,
         alias
         (
          L(p)->sql_ann->fragment,
          correlation_name(crrl->name)
         )
        );

    return select
        (
         NULL,
         fromlist,
         NULL,
         NULL
        );
}

static PFsql_t*
collect_fragments (PFla_op_t *p)
{
    assert (p);
    if (p->kind == la_empty_frag)
        return select
            (
             select_list
             (
              column_name(sql_special_name_new(sql_col_prop)->ident),
              column_name(sql_special_name_new(sql_col_kind)->ident),
              column_name(sql_special_name_new(sql_col_level)->ident),
              column_name(sql_special_name_new(sql_col_size)->ident),
              column_name(sql_special_name_new(sql_col_pre)->ident),
             ),
             fragrelation(),
             NULL,
             NULL
            );

    assert (p->kind == la_frag_union);
    /* for every fragment the assumption that a binding already
     *  exists is correct, so we do not have to do a late binding
     */  
    PFsql_t *ret = R(p)->sql_ann->fragment; 
    
    /* the structure of fragment and frag_union operations is a lefty 
       tree */
    for (PFla_op_t *frag = L(p); frag->kind != la_empty_frag;
            frag=L(frag)) {
        assert (R(frag));
        ret = disjunion (ret, R(frag)->sql_ann->fragment); 
    }

    assert (ret);

    return ret;
}

static void
parse (PFla_op_t *n)
{
    /* label the algebra tree to determine optimal code generation */
    PFlalg2sql_label (n);
    /* traverse algebra tree */
    reduce (n, 1);
}

PFsql_t*
PFlalg2sql (PFla_op_t *n)
{
   sql_stmts = NULL;
   
   assert (n); 

   /* set reference counters in algebra tree nodes */
   inc_refctr (n);
   PFla_dag_reset (n);

   max_pre_frag = fragrelation ();

   parse (n);
   
   return sql_stmts;
}
/* vim:set shiftwidth=4 expandtab filetype=c: */  
