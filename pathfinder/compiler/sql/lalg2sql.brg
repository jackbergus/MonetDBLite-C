%{

    /**
     * @file
     *
     * Transforms the logical algebra tree into a tree that represents
     * sql statements.
     *
     * Copyright Notice:
     * -----------------
     *
     * The contents of this file are subject to the Pathfinder Public License
     * Version 1.1 (the "License"); you may not use this file except in
     * compliance with the License.  You may obtain a copy of the License at
     * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
     *
     * Software distributed under the License is distributed on an "AS IS"
     * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
     * the License for the specific language governing rights and limitations
     * under the License.
     *
     * The Original Code is the Pathfinder system.
     *
     * The Original Code has initially been developed by the Database &
     * Information Systems Group at the University of Konstanz, Germany and
     * is now maintained by the Database Systems Group at the Technische
     * Universitaet Muenchen, Germany.  Portions created by the University of
     * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
     * 2000-2005 University of Konstanz and (C) 2005-2007 Technische
     * Universitaet Muenchen, respectively.  All Rights Reserved.
     *
     * $Id$
     */

  /* always include pathfinder first */
  #include "pathfinder.h"
  #include <assert.h>
  #include <stdio.h>
  
  #include "lalg2sql.h"
  #include "sql.h"
  #include "algebra.h"
  #include "alg_dag.h"
  #include "mem.h"
  #include "oops.h"		/* PFoops() */
  #include "subtyping.h"
  /**
   * Accessors for the burg pattern matcher
   */
  typedef struct PFla_op_t *NODEPTR_TYPE;

  /* accessor to the node kind */
  #define OP_LABEL(p)     ((p)->kind)

  /* accessors to left and right child node */
  #define LEFT_CHILD(p)   ((p)->child[0])
  #define RIGHT_CHILD(p)  ((p)->child[1])

  /* the state, burg determines during the bottom up graph
   * traversal
   */
  #define STATE_LABEL(p) ((p)->state_label)

  /* the state of the children determined during 
     bottom-up labeling is backed up here */
  #define CHILD_STATE_LABEL(p,i) ((p)->child_state_label[i])

  /* if an error occurs, call PFoops */
  #define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start with non-terminal */
%start Query

%term serialize       =  1 /**< serialize algebra expression
                                (Placed on the very top of the tree.) */
%term lit_tbl         =  2 /**< literal table */
%term empty_tbl       =  3 /**< empty literal table */
%term attach          =  4 /**< attach constant column */
%term cross           =  5 /**< cross product (Cartesian product) */
%term eqjoin          =  6 /**< equi-join */
%term semijoin        =  7 /**< semi-join */
%term thetajoin       =  8 /**< theta-join (with possibly multiple
                                predicates) */
%term project         =  9 /**< algebra projection and renaming operator */
%term select_         = 10 /**< selection of rows where column value != 0 */
%term disjunion       = 11 /**< union two relations with same schema */
%term intersect       = 12 /**< intersect two relations with same schema */
%term difference      = 13 /**< difference of two relations w/ same schema */
%term distinct        = 14 /**< duplicate elimination operator */
%term fun_1to1        = 20 /**< generic operator that extends the schema with
                                a new column where each value is determined 
                                by the values of a single row (cardinality 
                                stays the same) */
%term num_eq          = 25 /**< numeric equal operator */
%term num_gt          = 26 /**< numeric greater-than operator */
%term bool_and        = 28 /**< boolean AND operator */
%term bool_or         = 29 /**< boolean OR operator */
%term bool_not        = 30 /**< boolean NOT operator */
%term to              = 31 /**< op:to operator */
%term avg             = 32 /**< operator for (partitioned) avg of a column */
%term max_            = 33 /**< operator for (partitioned) max of a column */
%term min_            = 34 /**< operator for (partitioned) min of a column */
%term sum             = 35 /**< operator for (partitioned) sum of a column */
%term count           = 36 /**< (partitioned) row counting operator */
%term rownum          = 37 /**< consecutive number generation */
%term rank            = 38 /**< arbitrary but ordered number generation */
%term number          = 39 /**< arbitrary, unordered number generation */
%term type            = 40 /**< selection of rows where a column is of a
                                certain type */
%term type_assert     = 41 /**< restricts the type of a relation */
%term cast            = 42 /**< type cast of an attribute */
%term seqty1          = 43 /**< test for exactly one type occurrence in one
                                iteration (Pathfinder extension) */
%term all             = 44 /**< test if all items in an iteration are true */
%term step            = 49 /**< XPath location step */
%term step_join       = 50 /**< duplicate generating path step */
%term guide_step      = 51 /**< XPath location step 
                                (with guide information) */
%term guide_step_join = 52 /**< duplicate generating path step 
                                (with guide information) */
%term id              = 53 /**< Operator representing a fn:id node lookup */
%term idref           = 54 /**< Operator representing a fn:idref node 
                                lookup */
%term doc_tbl         = 55 /**< document relation (is also a fragment) */
%term doc_access      = 56 /**< document access necessary 
                                for pf:string-value */
%term twig            = 60 /**< twig root operator */
%term fcns            = 61 /**< twig constructor sequence */
%term docnode         = 62 /**< document node-constructing operator */
%term element         = 63 /**< element-constructing operator */
%term attribute       = 64 /**< attribute-constructing operator */
%term textnode        = 65 /**< text node-constructing operator */
%term comment         = 66 /**< comment-constructing operator */
%term processi        = 67 /**< processing instruction-constr. operator */
%term content         = 68 /**< constructor content operator (elem|doc) */
%term merge_adjacent  = 69 /**< operator for pf:merge-adjacent-text-nodes
                                builtin function */
%term roots_          = 70 /**< algebraic repres. of the roots of newly
                                created xml nodes (e.g. element());
                                schema: iter | pos | item */
/* all operators below represent xml node fragments with no schema */
%term fragment        = 71 /**< representation of a node fragment */
%term frag_union      = 72 /**< special node type used to form an algebraic
                                union of fragments */
%term empty_frag      = 73 /**< representation of an empty fragment */
                             
%term cond_err        = 80 /**< facility to trigger runtime errors */
%term nil             = 81 /**< end of the list of parameters */
%term trace           = 82 /**< debug operator */
%term trace_msg       = 83 /**< debug operator */
%term trace_map       = 84 /**< debug relation map operator */
%term rec_fix         = 85 /**< operator representing a tail recursion */
%term rec_param       = 86 /**< list of parameters of the recursion */
%term rec_arg         = 87 /**< reference to the arguments of a parameter
                                in the recursion */
%term rec_base        = 88 /**< base of the DAG describing the recursion */
                         
%term proxy           = 96 /**< proxy operator that represents a group
                                of operators */
%term proxy_base      = 97 /**< completes the content of the proxy 
                                (a virtual base table) */
%term cross_mvd       = 98 /**< clone column aware cross product */
%term eqjoin_unq      = 99 /**< clone column aware equi-join */
/* builtin support for XQuery functions */
%term string_join     =102 /**< fn:string-join */
                         
%term dummy           =120 /**< dummy operator that does nothing */

%% 

Query:  serialize (Frag, Rel)                        = 1 (10);
Query:  serialize (Frag, empty_tbl)                  = 2 (10);

Rel:    lit_tbl                                      = 3 (10);
Rel:    attach (Rel)                                 = 4 (10);

Rel:    cross (Rel, Rel)                             = 5   (10);
Rel:    eqjoin (Rel, Rel)                            = 6   (10);
Rel:    semijoin (Rel, Rel)                          = 7   (10);
Rel:    project (Rel)                                = 8   (10);
Rel:    select_ (Rel)                                = 9   (10);

Rel:    disjunion (Rel, Rel)                         = 10  (10);
Rel:    intersect (Rel, Rel)                         = 11  (10);
Rel:    difference (Rel, Rel)                        = 12  (10);
Rel:    distinct (Rel)                               = 13  (10);

Rel:    fun_1to1 (Rel)                               = 20  (10);
Rel:    num_gt (Rel)                                 = 21  (10);
Rel:    num_eq (Rel)                                 = 22  (10);
Rel:    bool_and (Rel)                               = 23  (10);
Rel:    bool_or (Rel)                                = 24  (10);
Rel:    bool_not (Rel)                               = 25  (10);
Rel:    type (Rel)                                   = 26  (10);
Rel:    type_assert (Rel)                            = 27  (10);
Rel:    cast (Rel)                                   = 28  (10);

Rel:    avg (Rel)                                    = 35  (10);
Rel:    max_ (Rel)                                   = 36  (10);
Rel:    min_ (Rel)                                   = 37  (10);
Rel:    sum (Rel)                                    = 38  (10);
Rel:    count (Rel)                                  = 39  (10);
Rel:    seqty1 (Rel)                                 = 41  (10);
Rel:    all (Rel)                                    = 42  (10);

Rel:    string_join (Rel, Rel)                       = 43  (10);

Rel:    rownum (Rel)                                 = 50  (10);
Rel:    number (Rel)                                 = 51  (10);
Rel:    rank (Rel)                                   = 223 (10);
Rel:    StRel                                        = 52  (50);

StRel:  step (Frag, Rel)                             = 53  (10);
StRel:  step (Frag, StRel)                           = 54  (10);
Rel:    guide_step (Frag, Rel)                       = 225 (10);
Rel:    step_join (Frag, Rel)                        = 224 (10);
Rel:    guide_step_join (Frag, Rel)                  = 226 (10);

Rel:    doc_access (Frag, Rel)                       = 55  (10);

Rel:    roots_ (Constr)                              = 60  (10);
Frag:   fragment (Constr)                            = 61  (10);
Frag:   frag_union (Frag, Frag)                      = 62  (10);
Frag:   frag_union (empty_frag, Frag)                = 63  (10);
Frag:   empty_frag                                   = 64  (10);

List:   fcns (Constra, List)                         = 219 (10);
List:   nil                                          = 220 (10);

Constr: doc_tbl (Rel)                                = 70  (10);
Constr: twig (Constra)                                = 218 (10);

Constra: docnode (List)                               = 75  (10);
Constra: element (Rel, List)                          = 216 (10); 
Constra: element (Rel, fcns (nil, nil))               = 221 (10); 
Constra: attribute (Rel)                              = 73  (10);
Constra: textnode (Rel)                               = 74  (10);
Constra: comment (Rel)                                = 76  (10);
Constra: processi (Rel)                               = 77  (10);
Constra: content (Frag, Rel)                          = 217 (10);

Constr: merge_adjacent (Frag, Rel)                   = 78  (10);

Rel:    cond_err (Rel, Rel)                          = 80  (10);

Rel:    trace (Rel, Msg)                             = 100 (10);
Msg:    trace_msg (Rel, Map)                         = 101 (10);
Map:    trace_map (Rel, Map)                         = 102 (10);
Map:    nil                                          = 103 (10);

Rel:    rec_fix (Rec, Rel)                           = 105 (10);
Rel:    rec_base                                     = 106 (10);
Rec:    rec_param (Arg, Rec)                         = 107 (10);
Rec:    nil                                          = 108 (10);
Arg:    rec_arg (Rel, Rel)                           = 109 (10);

Rel:    dummy (Rel)                                  = 110 (10);
Rel:    proxy (Rel)                                  = 111 (10);
Rel:    proxy_base (Rel)                             = 112 (10);
Rel:    eqjoin_unq (Rel, Rel)                        = 113 (10);
Rel:    cross_mvd (Rel, Rel)                         = 114 (10);
Rel:    thetajoin (Rel, Rel)                         = 115 (10);

Rel:    disjunion (count(Rel), attach(difference(Rel, project(count(Rel))))) = 222 (5);

%%

#include "sql_mnemonic.h"

#define MAX_KIDS 10

/* Prototypes */
static PFalg_simple_type_t type_of (const PFla_op_t *, PFalg_att_t);

static PFsql_t *bin_arith (PFsql_t * (*op) (const PFsql_t *, const PFsql_t *),
			   PFla_op_t * p);

static PFsql_t *bin_rel (PFsql_t * (*op) (const PFsql_t *, const PFsql_t *),
			 PFla_op_t * p, PFla_op_t * l, PFla_op_t * r);

static PFsql_t *bin_comp (PFsql_t * (*op) (const PFsql_t *, const PFsql_t *),
			  PFla_op_t * p);

static void where_env_copy (PFarray_t * srcwheremap,
			    PFarray_t * destwheremap);

static struct PFsql_alg_ann_t *llscj (const PFla_op_t * frag,
				      const PFla_op_t * p);

static struct PFsql_alg_ann_t *dup_step (const PFla_op_t * frag,
                        const PFla_op_t * p);

static struct PFsql_alg_ann_t *guide_llscj (const PFla_op_t * frag, 
            const PFla_op_t * p);

static PFsql_alg_ann_t *doc_access (PFla_op_t * frag, PFla_op_t * p);

static PFsql_t *collect (PFla_op_t * p);

/**
 * We collect the SQL statements during compilation here.
 */
static PFsql_t *sql_stmts = NULL;

/* The execute is used to construct the sequence
 * of `common table expressions'.
 */
#define execute(...) sql_stmts = (sql_stmts == NULL)? \
    common_table_expr( __VA_ARGS__ ):\
    common_table_expr(sql_stmts, __VA_ARGS__)

/**
 * We define the fragment with the maximum pre value here.
 */
static PFsql_t *max_pre_frag = NULL;

/**
 * Construct a new literal given an algebraic atom.
 */
static PFsql_t *literal (PFalg_atom_t);

/*
 * Easily access subtree parts.
 */
/** starting from p, make a left step */
#define L(p)      (LEFT_CHILD(p))
/** starting from p, make a right step */
#define R(p)      (RIGHT_CHILD(p))
#define LL(p)     L(L(p))
#define LR(p)     R(L(p))
#define RL(p)     L(R(p))
#define RR(p)     R(R(p))
#define RLR(p)    R(L(R(p)))
#define RLL(p)    L(L(R(p)))
#define RLLL(p)   L(L(L(R(p)))) 
#define RLRL(p)   L(R(L(R(p))))
#define RLRLL(p)  L(L(R(L(R(p)))))

/** Macro determining if a node is just visited */
#define SEEN(p)   ((p)->bit_dag)


#define COLUMN_SPEC(col)    (column_name (sql_special_name_new ( \
                                            col)->ident))
#define COLUMN_NAME(att,ty) (column_name (sql_column_name_new ( \
                                            (att), (ty))->ident))
#define WHEREMAP(p) ((p)->sql_ann->wheremap)

#define COLMAP(p) ((p)->sql_ann->colmap)

#define constr(p) ((p->kind == la_attribute) || (p->kind == la_element) || \
                   (p->kind == la_textnode))

#define constructors(p) (((p)->kind == la_attribute) \
                          || ((p)->kind == la_element) \
                          || ((p)->kind == la_textnode) \
                          || ((p)->kind == la_comment) \
                          || ((p)->kind == la_processi) \
                          || ((p)->kind == la_doc_tbl) \
                          || ((p)->kind == la_docnode) \
                          || ((p)->kind == la_merge_adjacent) \
                          || ((p)->kind == la_twig) \
                          || ((p)->kind == la_content))



/* We use the term dirty to denote an operator that is
 * supposed to be bound immediatly to a `common table expression'.
 * A dirty node has to meet any of the following criteria:
 *  - Since the plan is a DAG, we split nodes marked with
 *    a reference counter > 1.
 *  - The generated statement is not a SQL-select. 
 *  - We can mark some operators explicit with the dirty flag,
 *    to indicate that it has to be bound immediatly.*/
#define DIRTY(p)  (((p)->refctr > 1) || \
                  (((p)->sql_ann->sfw)? \
                  ((p)->sql_ann->sfw->kind != sql_select):true) || \
                  ((p)->dirty == true))

#define NUM_TYPE(t) ((t == aat_nat) || (t == aat_int) || \
    (t == aat_dec) || (t == aat_dbl))
#define CHAR_TYPE(t) ((t == aat_str) || (t == aat_uA))
#define NUM_NOTEXPR(t) (t == aat_int)
#define LEVEL_SET(p) ((p)->sem.step.level >= 0)

/* we "mask out" the flags regarding the generation of attributes,
 * up to now we don't support attributes */
#define TYPE_MASK(t) ( (t) & (0xFFFF ^ (aat_afrag | aat_pfrag)))
#define IS_PRE(ident)   ( ((ident) >> (ATT_BITS+TYPE_BITS) \
                            & 0x00000007) == 1)

/* shortcuts for selectlist, fromlist, wherelist,
 * and group_by */
#define SELECT(p) ((p)->sql_ann->sfw->child[0])
#define FROM(p)   ((p)->sql_ann->sfw->child[1])
#define WHERE(p)  ((p)->sql_ann->sfw->child[2])
#define GROUP(p)  ((p)->sql_ann->sfw->child[3])

#define ELEM    1
#define ATTR    2
#define PF_TEXT 3
#define COMM    4
#define PI      5
#define DOC     6
typedef unsigned int sql_kind_t;

/*................. SQL Variable ................ */

/**
 * Represents a SQL table_name.
 *
 * @note
 *   The variable has a name (that is automatically generated).
 */
struct sql_table_name_t
{
    PFsql_ident_t name;
};
typedef struct sql_table_name_t sql_table_name_t;

/**
 * Returns a new valid variable.
 *
 * @node
 */
static sql_table_name_t *
sql_table_name_new ()
{
    /* static variable that holds the actual
     * variable-number */
    static unsigned int varno = PF_SQL_RES_TABLE_COUNT;
    sql_table_name_t *var =
        (sql_table_name_t *) PFmalloc (sizeof (sql_table_name_t));

    /* simply increment the variables name property */
    var->name = varno++;
    return var;
}


/* ........... SQL correlation name ............ */


struct sql_correlation_name_t
{
    PFsql_correlation_name_t name;
};
typedef struct sql_correlation_name_t sql_correlation_name_t;

/**
 * Returns a new valid correlation name.
 */
static sql_correlation_name_t *
sql_correlation_name_new (void)
{
    static unsigned int varno = PF_SQL_RES_CORRELATION_COUNT;
    sql_correlation_name_t *var =
        (sql_correlation_name_t *) PFmalloc (sizeof (sql_correlation_name_t));

    /* increment the variables name property */
    var->name = varno++;
    return var;
}


/* .............. SQL Columns ................ */

struct sql_column_name_t
{
    PFsql_ident_t ident;
};
typedef struct sql_column_name_t sql_column_name_t;

/* in our SQL generation each attribut/type pair
 * is associated with an expression.
 */
struct sql_column_env_t
{
    PFalg_simple_type_t type;
    PFalg_att_t att;
    PFsql_t *expression;
};
typedef struct sql_column_env_t sql_column_env_t;

/**
 * Returns a special columnname,
 * like pre or size, following our
 * encoding scheme.
 */
static sql_column_name_t *
sql_special_name_new (PFsql_special_t spc)
{
    unsigned int sp = 0;

    /* determine position of special bit */
    for (PFsql_special_t spmask = 1, i = 0; spmask; spmask <<= 1, i++) {
        if (spc & spmask) {
            sp = (unsigned int) i;
            break;
        }
    }

    sql_column_name_t *ret =
        (sql_column_name_t *) PFmalloc (sizeof (sql_column_name_t));

    *ret = 
        (sql_column_name_t)
        {
            .ident = ((unsigned int) sp) << (ATT_BITS + TYPE_BITS)
        };

    return ret;
}


/**
 * Create an identifier with an attribut and type given.
 */
static sql_column_name_t *
sql_column_name_new (PFalg_att_t att, PFalg_simple_type_t ty)
{
    static unsigned int varno = PF_SQL_RES_COLUMN_COUNT;
    sql_column_name_t *ret = NULL;

    /* bit position of attribute a. */
    unsigned int a = 0;
    /* bit position of type t */
    unsigned int t = 0;

    /* determine the bit position of att */
    if (att != (unsigned int) 0) {
        for (PFalg_att_t attmask = 1, i = 0; attmask; attmask <<= 1, i++) {
            if (attmask & att) {
                a = i + 1;
                break;
            }
        }
    }

    /* determine bit position of type */
    for (PFalg_simple_type_t tmask = 1, i = 0; tmask; tmask <<= 1, i++) {
        if (tmask & ty) {
            t = i;
            break;
        }
    }

    ret = (sql_column_name_t *) PFmalloc (sizeof (sql_column_name_t));

    *ret =
        (sql_column_name_t)
        {
            .ident = a + (t << ATT_BITS) +
                        ((varno++) << (ATT_BITS + TYPE_BITS + SPEC_BITS))
        };

    return ret;
}

/**
 * Check if the column_name is a special name or produced
 * by a simple attribute/type pair
 */
static bool
special (PFsql_ident_t ident)
{
    return (((ident >> (ATT_BITS + TYPE_BITS)) & 0x00000007) >= 1);
}


/**
 * Check an identifier originated from a specific attribute/type pair
 */
static bool
eq_type (PFalg_att_t att, PFalg_simple_type_t ty, PFsql_ident_t ident)
{
    ty = TYPE_MASK (ty);

    /* first create a new column name with the given parameters */
    sql_column_name_t *new = sql_column_name_new (att, ty);

    return special (ident) ||
        (((new->ident & 0x000001FF) ^ (ident & 0x000001FF)) == 0);
}


/**
 * Returns a new column environment.
 */
static PFarray_t *
sql_column_env_new (void)
{
    return PFarray (sizeof (sql_column_env_t));
}


/**
 * Adds a (attribute/type -> expression)
 * mapping to the column-environment.
 */
static void
sql_column_env_add (PFarray_t * env, PFalg_att_t att,
		    PFalg_simple_type_t ty, PFsql_t * expr)
{
    ty = TYPE_MASK (ty);

    /* we can add only the types specified here */
    assert (ty == aat_nat || ty == aat_int ||
            ty == aat_str || ty == aat_bln ||
            ty == aat_pre || ty == aat_qname ||
            ty == aat_dec || ty == aat_uA ||
            ty == aat_dbl || ty == aat_attr);

    *(sql_column_env_t *) PFarray_add (env) =
        (sql_column_env_t)
        {
            .type = ty,
            .att = att,
            .expression = expr
        };
}


/**
 * Returns an environment item at a specific position
 */
static sql_column_env_t
sql_column_env_at (const PFarray_t * env, unsigned int i)
{
  assert (i < PFarray_last (env));

  return *(sql_column_env_t *) PFarray_at ((PFarray_t *) env, i);
}


/**
 * Returns the expression associated with a given attribute/type
 * pair. If there doesn't exist an expression, simply return NULL.
 */
static PFsql_t *
sql_expression_unsafe (const PFarray_t * env, PFalg_att_t att,
		       PFalg_simple_type_t ty)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        sql_column_env_t entry =
            *(sql_column_env_t *) PFarray_at ((PFarray_t *) env, i);

        if (entry.att == att && TYPE_MASK (entry.type) == TYPE_MASK (ty))
            return entry.expression;
    }
    return NULL;
}


/**
 * Returns the expression associated with a given attribute/type
 * pair. Abort the codegeneration and produce an error message,
 * when there is no expression, for the att/type pair.
 */
static PFsql_t *
sql_expression (const PFarray_t * env, PFalg_att_t att,
		PFalg_simple_type_t ty)
{
    ty = TYPE_MASK (ty);
    PFsql_t *expr = sql_expression_unsafe (env, att, ty);

    if (expr)
        return expr;

    PFoops (OOPS_FATAL,
            "SQLgen: attribute '%s' with type '0x%X' "
            "not found in environment", PFatt_str (att), ty);

    return NULL;			/* satisfy picky compilers */
}


/**
 * Returns the correlation name of a table marked with
 * the frag flag. It is used mainly in the bundling of
 * PathStep-Operators.
 */
static PFsql_correlation_name_t
sql_search_frag (PFsql_t * n, sql_correlation_name_t crrl)
{
    PFsql_correlation_name_t ret;
    assert (n);
    switch (n->kind)
    {
        case sql_frm_list:
            ret = sql_search_frag (n->child[0], crrl);

            if (ret)
                return ret;

            return sql_search_frag (n->child[1], crrl);

        case sql_alias:
            if (n->frag)
                return (n->child[1]->sem.correlation.ident == crrl.name)?
                            n->child[1]->sem.correlation.ident : 0;
        default:
            return 0;
    }
    return 0;			/* satisfy picky compilers */
}


/**
 * Override an expression with a column_name, and a
 * correlation name.
 */
static void
sql_override_expr (PFarray_t * env, PFalg_att_t att,
		   PFalg_simple_type_t ty, PFsql_ident_t colname,
		   PFsql_correlation_name_t crrln)
{
    /* look for all items in the environment */
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        sql_column_env_t *entry =
            (sql_column_env_t *) PFarray_at ((PFarray_t *) env, i);
        if (entry->att == att && entry->type == ty) {
            entry->expression = crrl_deco (column_name (colname), crrln);
            return;
        }
    }

    PFoops (OOPS_FATAL,
            "SQLgen: attribute '%s' with type '0x%X' "
            "not found in environment", PFatt_str (att), ty);
}


/* .............. Where Environment ........... */

/**
 * Where environment to handle the where-clause during
 * the codegeneration phase.
 */
struct sql_where_env_t
{
    PFsql_t *expression;
};
typedef struct sql_where_env_t sql_where_env_t;

/**
 * Returns a new where environment.
 */
static PFarray_t *
sql_where_env_new (void)
{
    return PFarray (sizeof (sql_where_env_t));
}

/**
 * Returns a predicate at a specific position.
 */
static sql_where_env_t
sql_where_env_at (const PFarray_t * env, unsigned int i)
{
    assert (i < PFarray_last (env));

    return *(sql_where_env_t *) PFarray_at ((PFarray_t *) env, i);
}

/**
 * Add a predicate to the where-environment.
 */
static void
sql_where_env_add (PFarray_t * env, PFsql_t * expr)
{
    *(sql_where_env_t *) PFarray_add (env) =
        (sql_where_env_t)
        {
            .expression = expr
        };
}

/*............ Annotations ...........*/

/**
 * Return a new algebra annotation.
 * @note
 *     Each node of the algebra contains annotations regarding the 
 *     SQL-Codegeneration.  
 */
static PFsql_alg_ann_t *
sql_alg_ann_new (void)
{
    PFsql_alg_ann_t *ret =
        (PFsql_alg_ann_t *) PFmalloc (sizeof (PFsql_alg_ann_t));

    ret->tabname = NULL;
    ret->sfw = NULL;
    ret->fragment = NULL;
    ret->colmap = sql_column_env_new ();
    ret->wheremap = sql_where_env_new ();

    return ret;
}



/* horrible hack to handle split nodes for using them
   in joins */
/* TODO fix this weird hack */
void
substitute (PFla_op_t * p)
{
  /* check if this node splits */
  if (p->refctr > 1) {
      if (p->sql_ann && p->kind != la_frag_union
          && p->kind != la_fragment
          && p->kind != la_empty_frag
          && p->kind != la_doc_tbl
	  /*&&
	     num_gt && p->kind != la_num_eq
	     && p->kind != la_bool_not */
        ) {
            sql_correlation_name_t *crrl = sql_correlation_name_new ();
            PFarray_t *colmap = sql_column_env_new ();

            for (unsigned int i = 0;
                    i < PFarray_last (COLMAP (p)); i++) {
                sql_column_env_t entry =
                            sql_column_env_at (COLMAP (p), i);
                assert (entry.expression->kind == sql_clmn_name);
                PFsql_t *col =
                        crrl_deco (
                            column_name (entry.expression->sem.column.ident),
                            crrl->name);
                sql_column_env_add (colmap, entry.att, entry.type, col);
            }

            COLMAP (p) = colmap;
            PFsql_t *fromlist = FROM (p);

            assert (fromlist->kind == sql_alias);

            FROM (p) = alias (
                    table_name_default (fromlist->child[0]->sem.tablename.ident),
                    correlation_name (crrl->name));
        }
    }
}

static void
assign_delta_pre (PFla_op_t *n)
{
    static int dpre = 0;
    static int level = 0;
    assert (n);

    /* only descend once */
    if (SEEN (n))
        return;
    else {
        SEEN (n) = true;
        if (n->kind == la_twig) { dpre = 0; level = 0; }
        else if (constructors (n)) {
            n->delta_pre = ++dpre;
            n->delta_level = level;

            if ( n->kind == la_element) {
                    ++level;
                    assign_delta_pre (R (n));
                    --level;
            }
            return;
        }
    }

    for (unsigned int i = 0; i < PFLA_OP_MAXCHILD && n->child[i]; i++)
        assign_delta_pre (n->child[i]);
}

/*
 * Count the number of content tuples for an element constructor.
 * For attributes and textnode it is possible to count the number
 * of underlying nodes at compile time. For element and content
 * constructors we have to calculate them on running time.
 */
static int 
count_content(PFla_op_t *n)
{
    int sum = 0; 
    assert (n);

    for (PFla_op_t *la = n;  la->kind == la_fcns; la = R(la)) {
        if (L (la)->kind == la_element || L(la)->kind == la_content) return -1;
        else sum++;
    }
    return sum; 
}

static PFsql_t* 
get_twig_constr (PFla_op_t *p, PFla_op_t *n)
{
    assert (n);

    PFsql_t *selectlist = 
        select_list
        (
         COLUMN_SPEC (sql_col_name),
         COLUMN_SPEC (sql_col_value),
         COLUMN_SPEC (sql_col_kind),
         COLUMN_SPEC (sql_col_level),
         COLUMN_SPEC (sql_col_size),
         COLUMN_SPEC (sql_col_dpre),
         COLUMN_SPEC (sql_col_pre),
         COLUMN_NAME (att_pos,  aat_nat),
         COLUMN_NAME (att_iter,
                     type_of (p, p->sem.iter_item.iter))
        );

    PFsql_t *tbl_list = NULL;

    /* only descend once */
    if (SEEN (n))
        return NULL;
    else {
        SEEN (n) = true;
        if (constructors (n) && n->kind != la_twig ) {

            PFsql_t *temp = NULL;

            tbl_list = 
                        select
                        (
                            selectlist,
                            n->sql_ann->tabname,
                            NULL,
                            NULL
                        );

            if (n->kind == la_element)  {
                temp = get_twig_constr (p, R (n));
                if (temp)
                    tbl_list = disjunion (tbl_list, temp);
            }

            return tbl_list;
        }
    }

    PFsql_t *temp = NULL;
    for (unsigned int i = 0; i < PFLA_OP_MAXCHILD && n->child[i]; i++) {
        temp = get_twig_constr (p, n->child[i]);
        if (temp) {
            if (tbl_list)
                tbl_list = disjunion (tbl_list, temp);
            else
                tbl_list = temp;
        }
    }

    return tbl_list;
}

/**
 * Does a DAG preorder traversal and determines the incoming
 * edges of each node.
 */
static void
inc_refctr (PFla_op_t * n)
{
    assert (n);

    /* count number of incoming edges */
    n->refctr++;

    /* only descend once */
    if (SEEN (n))
        return;
    else {
        SEEN (n) = true;
        n->refctr = 1;
    }

    for (unsigned int i = 0; i < PFLA_OP_MAXCHILD && n->child[i]; i++)
        inc_refctr (n->child[i]);
}

#if 0
static bool
binding (PFsql_t * n)
{
  assert (n);

  if (n->kind == sql_bind)
    return true;
  else
    {
      for (unsigned int i = 0; i < PFSQL_OP_MAXCHILD && n->child[i]; i++)
	{
	  return binding (n->child[i]);
	}
    }
  return false;
}

static PFsql_t *gen_roots_statement (PFla_op_t * p, PFla_op_t * frag,
				     sql_correlation_name_t * eloc_crrl,
				     sql_correlation_name_t * t1loc_crrl);
static PFsql_t *gen_ctx_statement (PFla_op_t * p, PFla_op_t * frag,
				   sql_correlation_name_t * eloc_crrl,
				   sql_correlation_name_t * t2loc_crrl,
				   sql_correlation_name_t * t3loc_crrl);

#endif 

static PFsql_t* gen_content (PFla_op_t *p, PFla_op_t *frag,
                                sql_correlation_name_t *doc1,
                                sql_correlation_name_t *doc2);

static PFsql_t* gen_toplevel_content (PFla_op_t *p, PFla_op_t *frag,
                                sql_correlation_name_t *doc1);

static PFsql_t* gen_roots (PFla_op_t *p, PFla_op_t *c);


/**
 * Reduce function. This is the core of this source file, containing
 * the actions that should be executed whenever a burg-pattern matches.
 */
static void
reduce (PFla_op_t * p, int goalnt)
{
    int rule;			/* rule number that matches this node */
    short *nts;
    static bool twig_sort = false;
    /* target non-terminals for the leaf node
       of the current rule */
    PFsql_t *sql_stmt;
    /* SQL statment we construct in this
       function */
    PFla_op_t *kids[MAX_KIDS];	/* leaf node of this rule */
    bool topdown;

    PFrecursion_fence();

    sql_stmt = NULL;

    if (p->sql_ann)
    {
        return;
    }

    /* determine rule that matches for this non-terminal */
    rule = PFlalg2sql_rule (STATE_LABEL (p), goalnt);

    /* error if a rule with value zero is determined */
    assert (rule);

    /* initializing the kids vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
    {
        kids[i] = NULL;
    }

    /* get information for dag-traversal */
    nts = PFlalg2sql_nts[rule];
    PFlalg2sql_kids (p, rule, kids);

    switch (rule) {
        /* Query:  serialize (Frag, Rel) */
        case 1:
        /* Rel:    string_join (Rel, Rel) */
        case 43:
        /* Rel:    cond_err (Rel, Rel) */
        case 80:
        /* Constra: element (Rel, fcns (nil, nil)) */
        case 221: 
        /* Constra: element (Rel, List) */
        case 216:
        /* Constr: twig (Constr) */
        case 218:
            topdown = true;
            break;
        /* Rel:    semijoin(Rel, Rel) */
        case 7:
            if (PFprop_set (p->prop))
              topdown = false;
            else
              topdown = true;
            break;
        default:
            topdown = false;
            break;
    }

    /* make a top down traversal */
    if (!topdown)
    {
        for (unsigned short i = 0; i < PFLA_OP_MAXCHILD && nts[i]; i++)
            reduce (kids[i], nts[i]);
    }

    /* check if the sql annotations just exists in the algebra
     * node
     */ 
    if (p->sql_ann && rule != 52)
    {
        return;
    }

    /* initialize SQL annotations */
    if (rule != 52)
        p->sql_ann = sql_alg_ann_new ();

    if (L (p))
        substitute (L (p));

    switch (rule) {
        /* Query:  serialize (Frag, Rel)
        * We conflate the schema information needed by the 
        * externalized serializer with the final query,
        * that computes the result of the XQuery-Statement
        */
        case 1:
        {
            /* For the SQL generation the only purpose of
             * the serialize operator is to bind the
             * underlying nodes to a table name and
             * construct some default tables for
             * the externalized serializer. */
            for (unsigned short i = 0; i < PFLA_OP_MAXCHILD && nts[i]; i++) {
                /* make subsequent nodes of serialize dirty to force
                 * a binding */
                kids[i]->dirty = true;
                reduce (kids[i], nts[i]);
            }

            /* construct schema information for serializer */
            PFsql_t *schm_inf = NULL;

            schm_inf =
                schema_information
                (
                 schm_inf,
                 schema_comment ("END SCHEMA INFORMATION ** "
                                 "DO NOT EDIT THESE LINES")
                );

            PFsql_t *clmnlist = NULL;

            /* adding information about the result relation */

            /* we guarantee that the schema has a
             * pos_nat and and an item_* attribute
             * The item's type depends on the return
             * type of the query. It can be either 
             * nodes (type pre) or atomic types
             * such as integers or strings.
             * The serializer takes care of such types.
             */
            schm_inf = 
                schema_information
                (
                 schm_inf,
                 schema_expression
                 (
                  schema_result (),
                  COLUMN_NAME (att_pos, aat_nat)
                 ),
                 schema_expression
                 (
                  schema_result (),
                  COLUMN_NAME (att_item, type_of ( R (p), p->sem.serialize.item))
                 )
                );

            /* we even guarantee our both return values in the
             * result relation are the item and the pos attribute
             */
            clmnlist = 
                column_list
                (
                 clmnlist,
                 COLUMN_NAME (att_pos, aat_nat),
                 COLUMN_NAME (att_item, type_of (R (p), p->sem.serialize.item))
                );

            /* create a special result relation */
            PFsql_t *result = result (clmnlist);

            /* the result relation is the same query as in the right underlying node.
             * We only get rid of the attributes that are different to those 
             * referenced by the serialize semantics.
             * All what we have to do is to copy everything from the right child.
             */
            PFsql_t *result_query = 
                                select
                                (
                                 select_list
                                 (
                                  column_assign
                                  (
                                   sql_expression
                                   (
                                    COLMAP (R (p)),
                                    p->sem.serialize.pos,
                                    type_of (R (p), p->sem.serialize.pos)
                                   ),
                                   COLUMN_NAME (att_pos, aat_nat)
                                  ),
                                  column_assign
                                  (
                                   sql_expression
                                   (
                                    COLMAP (R (p)),
                                    p->sem.serialize.item,
                                    type_of (R (p), p->sem.serialize.item)
                                   ),
                                   COLUMN_NAME (att_item, aat_pre)
                                  )
                                 ),
                                 FROM (R (p)),
                                 WHERE (R (p)),
                                 GROUP (R (p))
                                );
    
            schm_inf = 
                schema_information
                (
                    schm_inf,
                    schema_expression (
                        schema_result (),
                        result)
                );

            /* adding information about the document relation */
            schm_inf = schema_information 
                (
                 schm_inf,
                 schema_expression
                 (
                  schema_doc (),
                  COLUMN_SPEC (sql_col_tag)
                 ),
                 schema_expression
                 (
                  schema_doc (),
                  COLUMN_SPEC (sql_col_name)
                 ),
                 schema_expression
                 (
                  schema_doc (),
                  COLUMN_SPEC (sql_col_value)
                 ),
                 schema_expression
                 (
                  schema_doc (),
                  COLUMN_SPEC (sql_col_kind)
                 ),
                 schema_expression
                 (
                  schema_doc (),
                  COLUMN_SPEC (sql_col_level)
                 ),
                 schema_expression
                 (
                  schema_doc (),
                  COLUMN_SPEC (sql_col_size)
                 ),
                 schema_expression
                 (
                  schema_doc (),
                  COLUMN_SPEC (sql_col_pre)
                 ),
                 schema_expression
                 (
                  schema_doc (),
                  document (NULL)
                 ),
                 schema_comment
                 (
                  "START SCHEMA INFORMATION "
                  "** DO NOT EDIT THESE LINES"
                 )
                );

            execute (comment ("===================="),
                     comment ("= RESULT RELATIONS ="),
                     comment ("===================="),
                     bind (result, result_query));

            sql_correlation_name_t *coll_crrl = sql_correlation_name_new ();

            /* the reason why we need those special relations
             * - document and
             * - result
             * is that the externalized serializer expects those special relation names
             * to construct a query
             */
            execute (
                    bind
                    (
                     document /* create a special document relation */
                     (
                      column_list
                      (
                       COLUMN_SPEC (sql_col_name),
                       COLUMN_SPEC (sql_col_tag),
                       COLUMN_SPEC (sql_col_value),
                       COLUMN_SPEC (sql_col_kind),
                       COLUMN_SPEC (sql_col_level),
                       COLUMN_SPEC (sql_col_size),
                       COLUMN_SPEC (sql_col_pre)
                      )
                     ),
                     select
                     (
                      select_list
                      (
                       /* in our approach we actually don't use
                        * the tagname. We will use it later
                        * to handle queries on multiple
                        * documents.
                        */
                       COLUMN_SPEC (sql_col_name),
                       COLUMN_SPEC (sql_col_name),
                       COLUMN_SPEC (sql_col_value),
                       COLUMN_SPEC (sql_col_kind),
                       COLUMN_SPEC (sql_col_level),
                       COLUMN_SPEC (sql_col_size),
                       COLUMN_SPEC (sql_col_pre)
                      ),
                      from_list
                      (
                       alias
                       (
                        collect (L (p)), /* collect all fragments */
                        correlation_name (coll_crrl->name)
                       )
                      ), 
                      NULL,
                      NULL
                     )
                     ));
            /* the final query consists of the schema information needed by the serializer
             * and the with clause conflating all queries translated to this point.
             */
            sql_stmts = seq (schm_inf, with (sql_stmts));
        } break;
        /* Query:  serialize (Frag, empty_tbl) */
        case 2:
            assert (!"missing");
            break;
        /* Rel:    lit_tbl */
        case 3:
        {
            /* declare a new correlation name
             * used for this expression */
            sql_correlation_name_t *crrl = sql_correlation_name_new ();

            for (unsigned int row = 0; row < p->sem.lit_tbl.count; row++) {
                for (unsigned int col = 0; col < p->schema.count; col++) {
                    for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                        if (t & TYPE_MASK (p->schema.items[col].type)) {
                            sql_column_env_add (
                                COLMAP (p),
                                p->schema.items[col].name,
                                t,
                                crrl_deco (
                                    (t == p->sem.lit_tbl.tuples[row].atoms[col].type)?
                                        literal (p->sem.lit_tbl.tuples[row].atoms[col]):
                                        cast (null (), type (t)),
                                    crrl->name));
                        }
                    }
                }
            }

            /* FIXME there has to be an union to support tables with
             * more than one row. */
            sql_stmt = 
                    select
                    (
                     NULL,	/* no selectlist provided */
                     from_list
                     (
                      alias
                      (
                       /* IBM provides a dummy relation in SYSIBM.sysdummy1
                        * that is useful to create tables with constant
                        * values. */
                       tab_name (schema (SYSIBM), sysdummy1 ()),
                       correlation_name (crrl->name)
                      )
                     ),
                     NULL, /* no wherelist */
                     NULL  /* no grouping */
                    );
        } break;
        /* Rel:    attach (Rel) */
        case 4:
        {
            /* copy all existing expressions */
            for (unsigned int i = 0;
                i < PFarray_last (COLMAP (L (p))); i++) {
                sql_column_env_t entry =
                    sql_column_env_at (COLMAP (L (p)), i);
                sql_column_env_add (COLMAP (p), entry.att, entry.type,
                                    entry.expression);
            }

            /* copy the existing wheremap */
            where_env_copy (WHEREMAP(L (p)), WHEREMAP (p));

            /* add expression for attach to the column environment */
            sql_column_env_add (COLMAP (p),
                                p->sem.attach.res, p->sem.attach.value.type,
                                literal (p->sem.attach.value));

            assert (FROM (L (p)));

            sql_stmt = select
                       (
                        NULL,     /* no selectlist provided */
                        /* take the fromlist of the left child */
                        from_list
                        (
                            FROM (L (p)),
                        ),
                        NULL,    /* late construction of wherelist */ 
                        NULL     /* no grouping */
                       );
        } break;
        /* Rel:    cross (Rel, Rel) */
        case 5:
        {
            /* copy all existing expressions from left child */
            for (unsigned int i = 0;
                i < PFarray_last (COLMAP (L (p))); i++) {
                sql_column_env_t entry =
                    sql_column_env_at (COLMAP (L (p)), i);
                sql_column_env_add (COLMAP (p), entry.att, entry.type,
                                    entry.expression);
            }

            /* copy all existing expression from right child */
            for (unsigned int i = 0;
                i < PFarray_last (COLMAP (R (p))); i++) {
                sql_column_env_t entry =
                    sql_column_env_at (COLMAP (R (p)), i);

                /* if the att/type value is just in the environment
                 * throw an error, because the schema of the left and
                 * right child should be disjoint.
                 */
                if (!sql_expression_unsafe (
                        COLMAP (p),
                        entry.att,
                        entry.type)) {
                    sql_column_env_add (COLMAP (p),
                                entry.att, entry.type, entry.expression);
                }
                else {
                    PFoops (OOPS_FATAL,
                                "SQLgen: The join tables contains equal"
                                " attribute/type mappings");
                }
            }

            /* merge the wherelist of the left and right child */
            where_env_copy (WHEREMAP(L (p)), WHEREMAP(p));

            where_env_copy (WHEREMAP(R (p)), WHEREMAP(p));

            sql_stmt = select
                       (
                        NULL,
                        from_list
                        (
                         FROM (L (p)),
                         FROM (R (p))
                        ),
                        NULL,
                        NULL
                       );
        } break;
        /* Rel:    thetajoin(Rel, Rel) */
        case 115:
        {
            /* copy all existing expressions from left child */
            for (unsigned int i = 0;
                    i < PFarray_last (COLMAP (L (p))); i++) {
                sql_column_env_t entry =
                    sql_column_env_at (COLMAP (L (p)), i);
                sql_column_env_add (COLMAP (p), entry.att, entry.type,
                                    entry.expression);
            }

            /* copy all existing expressions from right child */
            for (unsigned int i = 0;
                    i < PFarray_last (COLMAP (R (p))); i++) {
                sql_column_env_t entry =
                            sql_column_env_at (COLMAP (R (p)), i);
                /* if the att/type value is just in the environment
                * throw an error, because the schema of the left and
                * right child should be disjoint.
                */
                if (!sql_expression_unsafe (
                        COLMAP (p),
                        entry.att,
                        entry.type)) {
                    sql_column_env_add (COLMAP (p),
                            entry.att, entry.type, entry.expression);
                }
                else {
                    PFoops (OOPS_FATAL,
                                "SQLgen: The join tables contains equal "
                            "attribute/type mappings");
                }
            }

            /* merge the wherelist of the left and right child */
            where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

            where_env_copy (WHEREMAP (R (p)), WHEREMAP (p));

            for (unsigned int i = 0; i < p->sem.thetajoin.count; i++) {
                switch (p->sem.thetajoin.pred[i].comp) {
                    case alg_comp_eq:
                        sql_where_env_add (
                                        WHEREMAP (p),
                                        eq
                                        (
                                         sql_expression (
                                          COLMAP (L (p)),
                                          p->sem.thetajoin.pred[i].left,
                                          type_of (
                                           L (p),
                                           p->sem.thetajoin.pred[i].left)),
                                         sql_expression (
                                          COLMAP (R (p)),
                                          p->sem.thetajoin.  pred[i].right,
                                          type_of (
                                           R (p),
                                           p->sem.thetajoin.pred[i].right))
                                        ));
                        break;
                    case alg_comp_gt:
                        sql_where_env_add (
                                        WHEREMAP (p),
                                        gt
                                        (
                                         sql_expression (
                                          COLMAP (L (p)),
                                          p->sem.thetajoin.pred[i].left,
                                          type_of (
                                           L (p),
                                           p->sem.thetajoin.pred[i].left)),
                                         sql_expression (
                                          COLMAP (R (p)),
                                          p->sem.thetajoin.pred[i].right,
                                          type_of (
                                           R (p),
                                           p->sem.thetajoin.pred[i].right))
                                        ));
                        break;
                    case alg_comp_ge:
                        sql_where_env_add (
                                        WHEREMAP (p),
                                        gteq
                                        (
                                         sql_expression (
                                          COLMAP (L (p)),
                                          p->sem.thetajoin.pred[i].left,
                                          type_of (
                                           L (p),
                                           p->sem.thetajoin.pred[i].left)),
                                         sql_expression (
                                          COLMAP (R (p)),
                                          p->sem.thetajoin.pred[i].right,
                                          type_of (
                                           R (p),
                                           p->sem.thetajoin.pred[i].right))
                                        ));
                    break;
                    case alg_comp_lt:
                        sql_where_env_add (
                                        WHEREMAP (p),
                                        gt
                                        (
                                         sql_expression (
                                          COLMAP (R (p)),
                                          p->sem.thetajoin.pred[i].right,
                                          type_of (
                                           R (p),
                                           p->sem.thetajoin.pred[i].right)),
                                         sql_expression (
                                          COLMAP (L (p)),
                                          p->sem.thetajoin.pred[i].left,
                                          type_of (
                                           L (p),
                                           p->sem.thetajoin.pred[i].left))
                                        ));
                        break;
                    case alg_comp_le:
                        sql_where_env_add (
                                        WHEREMAP (p),
                                        gteq
                                        (
                                         sql_expression (
                                          COLMAP (R (p)),
                                          p->sem.thetajoin.pred[i].right,
                                          type_of (
                                           R (p),
                                           p->sem.thetajoin.pred[i].right)),
                                         sql_expression (
                                          COLMAP (L (p)),
                                          p->sem.thetajoin.pred[i].left,
                                          type_of (
                                           L (p),
                                           p->sem.thetajoin.pred[i].left))
                                        ));
                      
                        break;
                    case alg_comp_ne:
                        sql_where_env_add (
                                        WHEREMAP (p),
                                        not_
                                        (
                                         eq
                                         (
                                          sql_expression (
                                           COLMAP (L (p)),
                                           p->sem.thetajoin.pred[i].left,
                                           type_of (
                                            L (p),
                                            p->sem.thetajoin.pred[i].left)),
                                          sql_expression (
                                           COLMAP (R (p)),
                                           p->sem.thetajoin.pred[i].right,
                                           type_of (
                                            R (p),
                                            p->sem.thetajoin.pred[i].right))
                                          )
                                        ));
                          break;
                    default:
                        PFoops (OOPS_FATAL,
                                  "SQLgen: Cannot determine which comparison operator to use");
                        break;
                }
            }
            sql_stmt = select
                       (
                        NULL, /* no select list provided */
                        /* merge fromlists of the two children */
                        from_list
                        (
                         FROM (L (p)),
                         FROM (R (p))
                        ),
                        NULL, /* late wherelist construction */
                        NULL  /* no group by list */
                       );
        } break;
        /* Rel:    eqjoin (Rel, Rel) */
        case 6:
        {
            /* copy all existing expressions of the left child */
            for (unsigned int i = 0;
                    i < PFarray_last (COLMAP (L (p))); i++) {
                sql_column_env_t entry =
                    sql_column_env_at (COLMAP (L (p)), i);
                sql_column_env_add (COLMAP (p), entry.att, entry.type,
                                    entry.expression);
            }


            for (unsigned int i = 0;
                    i < PFarray_last (COLMAP (R (p))); i++) {
                sql_column_env_t entry =
                    sql_column_env_at (COLMAP (R (p)), i);

                /* if the att/type value is just in the environment
                 * throw an error, because the schema of the left and
                 * right child should be disjoint.
                 */
                if (!sql_expression_unsafe (
                        COLMAP (p), entry.att, entry.type)) {
                    sql_column_env_add (COLMAP (p),
                                        entry.att, entry.type,
                                        entry.expression);
                }
                else {
                    PFoops (OOPS_FATAL,
                        "SQLgen: The join tables contains equal"
                        " attribute/type mappings");
                }
            }

            /* merge the wherelist of the left and right child */
            where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

            where_env_copy (WHEREMAP (R (p)), WHEREMAP (p));

            /* add the constraint that comes from the equijoin semantics */
            sql_where_env_add (WHEREMAP (p),
                                eq
                                (
                                 sql_expression (
                                  COLMAP (L (p)),
                                  p->sem.eqjoin.att1,
                                  type_of (
                                   L (p),
                                   p->sem.eqjoin.att1)),
                                 sql_expression (
                                  COLMAP (R (p)),
                                  p->sem.eqjoin.att2,
                                  type_of (
                                   R (p),
                                   p->sem.eqjoin.att2))
                                ));

            sql_stmt = select
                       (
                        NULL,
                        from_list
                        (
                         FROM (L (p)),
                         FROM (R (p))
                        ),
                        NULL,
                        NULL
                       );
        } break;
        /* Rel:    semijoin(Rel, Rel) */
        case 7:
        {
            /* if we handle this operator like a set 
             * we don't have to reduce the underlying
             * nodes first */
            if (!PFprop_set (p->prop)) {
                reduce (kids[0], nts[0]);
                /* dump the right child */
                kids[1]->dirty = true;
                /* eliminate tuples in the right child */
                kids[1]->distinct = true;

                reduce (kids[1], nts[1]);
            }

            /* copy all existing expressions from left relation */
            /* for the semijoin we only need the attributes of
             * the left relation */
            for (unsigned int i = 0;
                    i < PFarray_last (COLMAP (L (p))); i++) {
                sql_column_env_t entry =
                    sql_column_env_at (COLMAP (L (p)), i);
                sql_column_env_add (COLMAP (p), entry.att, entry.type,
                                    entry.expression);
            }

            /* merge wherelists */ 
            where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));
            where_env_copy (WHEREMAP (R (p)), WHEREMAP (p));

            /* add the constraint coming from semijoin */
            sql_where_env_add (WHEREMAP (p),
                               eq
                               (
                                sql_expression (
                                 COLMAP (L (p)),
                                 p->sem.eqjoin.att1,
                                 type_of (
                                  L (p),
                                  p->sem.eqjoin.att1)),
                                sql_expression (
                                 COLMAP (R (p)),
                                 p->sem.eqjoin.att2,
                                 type_of (
                                  R (p),
                                  p->sem.eqjoin.att2))
                               ));

            sql_stmt = select
                       (
                        NULL, /* no selectlist provided */
                        /* merge fromlists */
                        from_list
                        (
                         FROM (L (p)),
                         FROM (R (p))
                        ),
                        NULL, /* late wherelist construction */
                        NULL  /* no grouping */
                       );
        } break;
        /* Rel:    project (Rel) */
        case 8:
        {
            for (unsigned int i = 0; i < p->sem.proj.count; i++) {
                PFsql_t *sqlnode = sql_expression (
                                    COLMAP (L (p)),
                                    p->sem.proj.items[i].old,
                                    type_of (
                                     L (p),
                                     p->sem.proj.items[i].old));
                sql_column_env_add (COLMAP (p),
                                p->sem.proj.items[i].new,
                                type_of (
                                 p,
                                 p->sem.proj.items[i].new),
                                sqlnode);
            }

            /* copy wherelist */
            where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));
            assert (L (p)->sql_ann->sfw);

            sql_stmt = 
                    select 
                    (
                     NULL,	/* no selectlist provided */
                     FROM (L (p)), 
                     NULL,  /* no wherelist */
                     NULL   /* no grouping */
                    );
        } break;
        /* Rel:    select_ (Rel) */
        case 9:
        {
            /* copy all existing expressions */
            for (unsigned int i = 0;
                    i < PFarray_last (COLMAP (L (p))); i++) {
                sql_column_env_t entry =
                            sql_column_env_at (COLMAP (L (p)), i);
                if (entry.att == p->sem.select.att)
                    continue;
                sql_column_env_add (COLMAP (p),
                                    entry.att, entry.type,
                                    entry.expression);
            }

            /* copy existing wheremap */
            where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

            PFsql_t *sqlnode = sql_expression (
                                        COLMAP (L (p)),
                                        p->sem.select.att,
                                        type_of (
                                         p,
                                         p->sem.select.att));

            if (sqlnode->kind != sql_clmn_name) {
                sql_where_env_add (WHEREMAP (p), sqlnode);
            }
            else {
                sql_where_env_add (
                                WHEREMAP (p),
                                eq
                                (
                                 sqlnode,
                                 lit_int (1)
                                ));
            }
            assert (L (p)->sql_ann->sfw);

            sql_stmt = select
            (
             NULL,
             FROM (L (p)),
             NULL,
             NULL
            );
        } break;
        /* Rel:    disjunion (Rel, Rel) */
        case 10:
        {
            sql_stmt = bin_rel (
                            PFsql_union, /* union */
                            p,
                            L (p),       /* left child */
                            R (p));      /* right child */
        } break;
        /* Rel:    intersect (Rel, Rel) */
        case 11:
            assert (!"missing");
            break;
        /* Rel:    difference (Rel, Rel) */
        case 12:
        {
            sql_stmt =
                bin_rel (
                    PFsql_difference,
                    p,
                    L (p),
                    R (p));
        } break;

      /* Rel:    distinct (Rel) */
      case 13:
          {
              /* copy all existing expressions */
              for (unsigned int i = 0;
                      i < PFarray_last (COLMAP (L (p))); i++)
              {
                  sql_column_env_t entry =
                      sql_column_env_at (COLMAP (L (p)), i);
                  sql_column_env_add (COLMAP (p), entry.att, entry.type,
                          entry.expression);
              }

              /* copy existing wheremap */
              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              sql_stmt = select_distinct
                  (NULL, FROM (L (p)), NULL, NULL);

              p->dirty = true;
          } break;

          /* Rel:    fun_1to1 (Rel) */
      case 20:
          {
              assert (L (p)->sql_ann->sfw);
              switch (p->sem.fun_1to1.kind)
              {
                  case alg_fun_num_add:
                      sql_stmt = bin_arith (PFsql_add, p);
                      break;
                  case alg_fun_num_subtract:
                      sql_stmt = bin_arith (PFsql_sub, p);
                      break;
                  case alg_fun_num_multiply:
                      sql_stmt = bin_arith (PFsql_mul, p);
                      break;
                  case alg_fun_num_divide:
                      sql_stmt = bin_arith (PFsql_div, p);
                      break;
                  case alg_fun_fn_contains:
                      sql_stmt = bin_arith (PFsql_like, p);
                      break;

                      /**< arithmetic modulo operator */
                  case alg_fun_num_modulo:
                      /**< fn:abs */
                  case alg_fun_fn_abs:
                      /**< fn:ceiling */
                  case alg_fun_fn_ceiling:
                      /**< fn:floor */
                  case alg_fun_fn_floor:
                      /**< fn:round */
                  case alg_fun_fn_round:
                      /**< fn:concat */
                  case alg_fun_fn_concat:
                      /**< fn:number */
                  case alg_fun_fn_number:
                      assert (!"missing");
                      PFoops (OOPS_FATAL,
                              "SQLgen: Pathfinder doesn't support " "this function");
                      break;
              }
          }
          break;

          /* Rel:    num_gt (Rel) */
      case 21:
          {
              assert (L (p)->sql_ann->sfw);
              sql_stmt = bin_comp (PFsql_gt, p);
          }
          break;

          /* Rel:    num_eq (Rel) */
      case 22:
          {
              assert (L (p)->sql_ann->sfw);
              sql_stmt = bin_comp (PFsql_eq, p);
          }
          break;

          /* Rel:    bool_and (Rel) */
      case 23:
          assert (!"missing");
          break;

          /* Rel:    bool_or (Rel) */
      case 24:
          assert (!"missing");
          break;

          /* Rel:    bool_not (Rel) */
      case 25:
          {
              /* copy all existing expressions */
              for (unsigned int i = 0;
                      i < PFarray_last (COLMAP (L (p))); i++)
              {
                  sql_column_env_t entry =
                      sql_column_env_at (COLMAP (L (p)), i);
                  sql_column_env_add (COLMAP (p), entry.att, entry.type,
                          entry.expression);
              }

              PFsql_t *sqlnode = sql_expression (COLMAP (L (p)),
                      p->sem.unary.att,
                      type_of (L (p), p->sem.unary.att));

              sql_column_env_add (COLMAP (p),
                      p->sem.unary.res, type_of (p, p->sem.unary.res),
                      not_
                      ((sqlnode->kind != sql_clmn_name) ?
                       sqlnode : eq (sqlnode, lit_int (1))));

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              sql_stmt = select
                  (NULL, from_list (FROM (L (p))), NULL, NULL);
          } break;

          /* Rel:    type (Rel) */
      case 26:
          assert (!"missing");
          break;

          /* Rel:    type_assert (Rel) */
      case 27:
          assert (!"missing");
          break;
          /* Rel:    cast (Rel) */
      case 28:
          {
              for (unsigned int i = 0; i < p->schema.count; i++)
              {
                  for (PFalg_simple_type_t t = 1; t; t <<= 1)
                  {
                      if (t & TYPE_MASK (p->schema.items[i].type))
                      {
                          if (p->schema.items[i].name == p->sem.type.res)
                          {
                              /* if we cast a numeric type to varchar we have to do
                               * it over the char bridge
                               */
                              if (NUM_TYPE (type_of (L (p), p->sem.type.att))
                                      && CHAR_TYPE (p->sem.type.ty))
                              {
                                  sql_column_env_add (COLMAP (p),
                                          p->sem.type.res, t,
                                          cast
                                          (cast
                                           (sql_expression
                                            (COLMAP (L (p)),
                                             p->sem.type.att,
                                             type_of (L (p),
                                                 p->sem.type.att)),
                                            type (aat_charseq)),
                                           type (p->sem.type.ty)));
                              }
                              /* if we want to cast a string to a not so expressive type
                               * like numeric, we have to do it over the the DECIMAL bridge
                               */
                              else if (CHAR_TYPE (type_of (L (p), p->sem.type.att))
                                      && NUM_NOTEXPR (p->sem.type.ty))
                              {
                                  sql_column_env_add (COLMAP (p),
                                          p->sem.type.res, t,
                                          cast
                                          (cast
                                           (sql_expression
                                            (COLMAP (L (p)),
                                             p->sem.type.att,
                                             type_of (L (p),
                                                 p->sem.type.att)),
                                            type (aat_dbl)),
                                           type (p->sem.type.ty)));
                              }
                              else
                              {
                                  sql_column_env_add (COLMAP (p),
                                          p->sem.type.res, t,
                                          cast
                                          (sql_expression
                                           (COLMAP (L (p)),
                                            p->sem.type.att,
                                            type_of (L (p),
                                                p->sem.type.att)),
                                           type (p->sem.type.ty)));
                              }
                          }
                          else
                              sql_column_env_add (COLMAP (p),
                                      p->schema.items[i].name, t,
                                      sql_expression (COLMAP (L (p)),
                                          p->schema.items[i].
                                          name, t));
                      }
                  }
              }

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              sql_stmt = select (NULL, FROM (L (p)), NULL, NULL);
          }
          break;
          /* Rel:    avg (Rel) */
      case 35:
          {
              sql_column_env_add (COLMAP (p),
                      p->sem.aggr.res, type_of (p, p->sem.aggr.res),
                      avg
                      (sql_expression (COLMAP (L (p)),
                                       p->sem.aggr.att, type_of (L (p),
                                           p->sem.
                                           aggr.
                                           att))));
              if (p->sem.aggr.part)
              {
                  sql_column_env_add (COLMAP (p),
                          p->sem.aggr.part, type_of (p,
                              p->sem.aggr.part),
                          sql_expression (COLMAP (L (p)),
                              p->sem.aggr.part, type_of (p,
                                  p->
                                  sem.
                                  aggr.
                                  part)));
              }

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              sql_stmt = select
                  (NULL,
                   FROM (L (p)),
                   NULL,
                   (p->sem.aggr.part) ?
                   column_list (sql_expression (COLMAP (L (p)),
                           p->sem.aggr.part, type_of (p,
                               p->sem.
                               aggr.
                               part))) :
                   NULL);

              p->dirty = true;
          }
          break;
          /* Rel:    max_ (Rel) */
      case 36:
          {
              sql_column_env_add (COLMAP (p),
                      p->sem.aggr.res, type_of (p, p->sem.aggr.res),
                      max
                      (sql_expression (COLMAP (L (p)),
                                       p->sem.aggr.att, type_of (L (p),
                                           p->sem.
                                           aggr.
                                           att))));
              if (p->sem.aggr.part)
              {
                  sql_column_env_add (COLMAP (p),
                          p->sem.aggr.part, type_of (p,
                              p->sem.aggr.part),
                          sql_expression (COLMAP (L (p)),
                              p->sem.aggr.part, type_of (p,
                                  p->
                                  sem.
                                  aggr.
                                  part)));
              }

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              sql_stmt = select
                  (NULL,
                   FROM (L (p)),
                   NULL,
                   (p->sem.aggr.part) ?
                   column_list (sql_expression (COLMAP (L (p)),
                           p->sem.aggr.part, type_of (p,
                               p->sem.
                               aggr.
                               part))) :
                   NULL);

              p->dirty = true;
          }
          break;
          /* Rel:   min_ (Rel) */
      case 37:
          {
              sql_column_env_add (COLMAP (p),
                      p->sem.aggr.res, type_of (p, p->sem.aggr.res),
                      min
                      (sql_expression (COLMAP (L (p)),
                                       p->sem.aggr.att, type_of (L (p),
                                           p->sem.
                                           aggr.
                                           att))));
              if (p->sem.aggr.part)
              {
                  sql_column_env_add (COLMAP (p),
                          p->sem.aggr.part, type_of (p,
                              p->sem.aggr.part),
                          sql_expression (COLMAP (L (p)),
                              p->sem.aggr.part, type_of (p,
                                  p->
                                  sem.
                                  aggr.
                                  part)));
              }

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              sql_stmt = select
                  (NULL,
                   FROM (L (p)),
                   NULL,
                   (p->sem.aggr.part) ?
                   column_list (sql_expression (COLMAP (L (p)),
                           p->sem.aggr.part, type_of (p,
                               p->sem.
                               aggr.
                               part))) :
                   NULL);

              p->dirty = true;
          }
          break;
          /* Rel:    sum (Rel) */
      case 38:
          {
              sql_column_env_add (COLMAP (p),
                      p->sem.aggr.res, type_of (p, p->sem.aggr.res),
                      sum
                      (sql_expression (COLMAP (L (p)),
                                       p->sem.aggr.att, type_of (L (p),
                                           p->sem.
                                           aggr.
                                           att))));
              if (p->sem.aggr.part)
              {
                  sql_column_env_add (COLMAP (p),
                          p->sem.aggr.part, type_of (p,
                              p->sem.aggr.part),
                          sql_expression (COLMAP (L (p)),
                              p->sem.aggr.part, type_of (p,
                                  p->
                                  sem.
                                  aggr.
                                  part)));
              }

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              sql_stmt = select
                  (NULL,
                   FROM (L (p)),
                   NULL,
                   (p->sem.aggr.part) ?
                   column_list (sql_expression (COLMAP (L (p)),
                           p->sem.aggr.part, type_of (p,
                               p->sem.
                               aggr.
                               part))) :
                   NULL);

              p->dirty = true;
          }
          break;
          /* Rel:    count (Rel) */
      case 39:
          {
              sql_column_env_add (COLMAP (p),
                      p->sem.aggr.res, type_of (p, p->sem.aggr.res),
                      count (false, star ()));
              if (p->sem.aggr.part) {
                  sql_column_env_add (COLMAP (p),
                          p->sem.aggr.part, type_of (p,
                              p->sem.aggr.part),
                          sql_expression (COLMAP (L (p)),
                              p->sem.aggr.part, type_of (p,
                                  p->
                                  sem.
                                  aggr.
                                  part)));
              }

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              sql_stmt = select
                  (NULL,
                   FROM (L (p)),
                   NULL,
                   (p->sem.aggr.part) ?
                   column_list (sql_expression (COLMAP (L (p)),
                           p->sem.aggr.part, type_of (p,
                               p->sem.
                               aggr.
                               part))) :
                   NULL);

              p->dirty = true;
          }
          break;

          /* Rel:    seqty1 (Rel) */
      case 41:
          assert (!"missing");
          break;

          /* Rel:    all (Rel) */
      case 42:
          assert (!"missing");
          break;

          /* Rel:    string_join (Rel, Rel) */
      case 43:
          {
              reduce (kids[0], nts[0]);
              /* even string_join is implemented as identity operator,
               * so it will handle most of the queries */
              sql_column_env_add (COLMAP (p),
                      p->sem.string_join.iter_res,
                      type_of (p, p->sem.string_join.iter_res),
                      sql_expression (COLMAP (L (p)),
                          p->sem.string_join.iter,
                          type_of (L (p),
                              p->sem.string_join.
                              iter)));

              sql_column_env_add (COLMAP (p),
                      p->sem.string_join.item_res,
                      type_of (p, p->sem.string_join.item_res),
                      sql_expression (COLMAP (L (p)),
                          p->sem.string_join.item,
                          type_of (L (p),
                              p->sem.string_join.
                              item)));

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              sql_stmt = select
                  (NULL, from_list (FROM (L (p))), NULL, NULL);
          }
          break;
      /* Rel:    rank (Rel) */
      case 223:
      {
        /* copy all existing expressions */
        for (unsigned int i = 0; 
            i < PFarray_last (COLMAP (L (p))); i++) {
            sql_column_env_t entry =
                sql_column_env_at (COLMAP (L (p)), i);
            sql_column_env_add (COLMAP (p), entry.att, entry.type,
                                    entry.expression);
        }

        where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

        /* construct the sortby list used by the rank operator */
        PFsql_t *srtbylist = NULL;
        for (int j = PFord_count (p->sem.rank.sortby)-1; j >= 0;
                    j--) {
            srtbylist = sortkey_expressions
                        (
                         srtbylist,
                         order
                         (
                          sql_expression (COLMAP (L (p)),
                           PFord_order_col_at (p->sem.rank.sortby, j),
                           type_of (L (p), PFord_order_col_at (
                                p->sem.rank.sortby, j))),
                          (PFord_order_dir_at (p->sem.rank.sortby, j))?
                            desc():asc()
                         )
                        );
        }

        sql_column_env_add (COLMAP (p),
                    p->sem.rank.res,
                    type_of (p, p->sem.rank.res),
                    over
                    (
                     rownumber (),
                     window_clause
                     (
                      NULL,
                      order_by (srtbylist)
                     )
                    ));

         assert (L (p)->sql_ann->sfw);

         sql_stmt = select (NULL, FROM (L (p)), NULL, NULL);

         p->dirty = true;
      } break;
      /* Rel:    rownum (Rel) */
      case 50:
          {
              /* copy all existing expressions */
              for (unsigned int i = 0;
                      i < PFarray_last (COLMAP (L (p))); i++)
              {
                  sql_column_env_t entry =
                      sql_column_env_at (COLMAP (L (p)), i);
                  sql_column_env_add (COLMAP (p), entry.att, entry.type,
                          entry.expression);
              }

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              /* construct the sortby list used by the rownumber operator */
              PFsql_t *srtbylist = NULL;
              for (int j = PFord_count (p->sem.rownum.sortby) - 1;
                        j >= 0; j--)
              {
                  srtbylist =
                      sortkey_expressions
                      (srtbylist,
                       order (sql_expression (COLMAP (L (p)),
                               PFord_order_col_at (p->sem.rownum.
                                   sortby, j),
                               type_of (L (p),
                                   PFord_order_col_at (p->sem.
                                       rownum.
                                       sortby,
                                       j))),
                           (PFord_order_dir_at (p->sem.rownum.sortby, j)) ? desc ()
                           : asc ()));
              }

              sql_column_env_add (COLMAP (p),
                      p->sem.rownum.res,
                      type_of (p, p->sem.rownum.res),
                      over
                      (rownumber (),
                       window_clause
                       ((p->sem.rownum.part == 0) ?
                        NULL :
                        partition
                        (part_expressions
                         (sql_expression (COLMAP (L (p)),
                                          p->sem.rownum.part,
                                          type_of (L (p),
                                              p->sem.rownum.
                                              part)))),
                        order_by (srtbylist))));

              assert (L (p)->sql_ann->sfw);

              sql_stmt = select (NULL, FROM (L (p)), NULL, NULL);

              p->dirty = true;
          } break;

          /* Rel:    number (Rel) */
      case 51:
          {
              /* copy all existing expressions */
              for (unsigned int i = 0; i < PFarray_last (COLMAP (L (p)));
                      i++)
              {
                  sql_column_env_t entry =
                      sql_column_env_at (COLMAP (L (p)), i);
                  sql_column_env_add (COLMAP (p), entry.att, entry.type,
                          entry.expression);
              }

              sql_column_env_add (COLMAP (p),
                      p->sem.number.res,
                      type_of (p, p->sem.number.res),
                      over
                      (rownumber (),
                       window_clause (NULL, NULL))); 

              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              assert (L (p)->sql_ann->sfw);
              sql_stmt = select (NULL, FROM (L (p)), NULL, NULL);

              p->dirty = true;
          } break;

          /* Rel:    StRel */
      case 52:
          {
              sql_stmt = select
                  (NULL, FROM (p), NULL, NULL);
              if (p->sql_ann->sfw->kind == sql_select && !PFprop_set (p->prop))
                  sql_stmt->sem.select.distinct = true;

              /* if set property is not set dump the query */
              if (!PFprop_set (p->prop))
                  p->dirty = true;
          }
          break;

    /* StRel: step (Frag, Rel) */
    case 53:
    {
        p->sql_ann = llscj (LR (p), p);

        for (PFla_op_t * loop = LL (p); loop->kind != la_empty_frag;
                loop = L (loop))
        {
            *(p->sql_ann) = (PFsql_alg_ann_t)
            {
                .sfw = disjunion
                    (llscj (R (loop), p)->sfw,
                     p->sql_ann->sfw)};
        }

        sql_stmt = (p->sql_ann->sfw->kind == sql_select) ?
            select
            (NULL, FROM (p), NULL, NULL) : p->sql_ann->sfw;
        if (p->sql_ann->sfw->kind == sql_select && !PFprop_set (p->prop))
            sql_stmt->sem.select.distinct = true;
    }
    break;
    /* Rel: step_join (Frag, Rel) */
    case 224:
    {
        /* Fill the annotation with values to
         * fulfill the step */ 
        p->sql_ann = dup_step (LR (p), p);
        
        /* run over the fragments */
        for (PFla_op_t *loop = LL (p); loop->kind != la_empty_frag;
                loop = L (loop)) {
            *(p->sql_ann) =
                (PFsql_alg_ann_t)
                {
                    .sfw = disjunion (dup_step (R (loop), p)->sfw,
                                                p->sql_ann->sfw)
                };
        }

        sql_stmt = (p->sql_ann->sfw->kind == sql_select)?
                    select
                    (
                     NULL,
                     FROM (p),
                     NULL,
                     NULL
                    ):
                    p->sql_ann->sfw;
    } break;
          /* StRel: step (Frag, StRel) */
      case 54:
          {
              /* combine more than one staircase join steps */
              p->sql_ann = llscj (LR (p), p);

              for (PFla_op_t * loop = LL (p); loop->kind != la_empty_frag;
                      loop = L (loop))
              {
                  *(p->sql_ann) = (PFsql_alg_ann_t)
                  {
                      .sfw = disjunion
                          (llscj (R (loop), p)->sfw,
                           p->sql_ann->sfw)};
              }

              sql_stmt = (p->sql_ann->sfw->kind == sql_select) ?
                  select
                  (NULL, FROM (p), NULL, NULL) : p->sql_ann->sfw;
              if (p->sql_ann->sfw->kind == sql_select && !PFprop_set (p->prop))
                  sql_stmt->sem.select.distinct = true;
          }
          break;

          /* Rel: guide_step (Frag, Rel) */
      case 225:
          {
              p->sql_ann = guide_llscj (LR (p), p);

              for (PFla_op_t * loop = LL (p); loop->kind != la_empty_frag;
                      loop = L (loop)) {
                  *(p->sql_ann) = (PFsql_alg_ann_t) {
                      .sfw = disjunion
                          (guide_llscj (R (loop), p)->sfw,
                           p->sql_ann->sfw)};
              }

              sql_stmt = (p->sql_ann->sfw->kind == sql_select) ?
                  select
                  (NULL, p->sql_ann->sfw->child[1], NULL, NULL) : p->sql_ann->sfw;
              if (p->sql_ann->sfw->kind == sql_select && !PFprop_set (p->prop))
                  sql_stmt->sem.select.distinct = true;
                /* if set property is not set dump the query */
              if (!PFprop_set (p->prop))
                  p->dirty = true;

          }
          break;

          /* Rel:    doc_access (Frag, Rel) */
      case 55:
          {
              p->sql_ann = doc_access (LR (p), p);

              for (PFla_op_t * loop = LL (p); loop->kind != la_empty_frag;
                      loop = L (loop))
              {
                  *(p->sql_ann) = (PFsql_alg_ann_t)
                  {
                      .sfw = disjunion
                          (doc_access (R (loop), p)->sfw, p->sql_ann->sfw)};
              }

              sql_stmt = (p->sql_ann->sfw->kind == sql_select) ?
                  select_distinct
                  (NULL, FROM (p), NULL, NULL) : p->sql_ann->sfw;
              //p->dirty = true;
          }
          break;

          /* Rel:    roots_ (Constr) */
      case 60:
          {
              /* copy environment */
              for (unsigned int i = 0;
                      i < PFarray_last (COLMAP (L (p))); i++)
              {
                  sql_column_env_t entry =
                      sql_column_env_at (COLMAP (L (p)), i);
                  sql_column_env_add (COLMAP (p),
                          entry.att, entry.type, entry.expression);
              }

              /* copy where environment */
              where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

              assert (L (p)->sql_ann->sfw);

              sql_stmt = select (NULL, FROM (L (p)), NULL, NULL);
          } break;

          /* Frag:   fragment ( Constr ) */
      case 61:
          {
              p->sql_ann->fragment = L (p)->sql_ann->fragment;
          }
          break;

          /* Frag:   frag_union (Frag, Frag) */
      case 62:
          {
              /* frag_union turns out to be an absolutely noop,
                 the magic is implemented in those operations
                 accessing this kind of node, to use the advantage
                 of indexes */
          }
          break;

          /* Frag:   frag_union (empty_frag, Frag) */
      case 63:
          {
              /* each frag_union turns out to be a absolutely
               * noop */
              p->sql_ann->fragment = R (p)->sql_ann->fragment;
          }
          break;

          /* Frag:   empty_frag */
      case 64:
          {
              /* empty frag is a no-op */
          }
          break;
          /* Constr: doc_tbl (Rel) */
      case 70:
          {
              sql_correlation_name_t *crrl1 = sql_correlation_name_new ();

              /* add iter to the column environment */
              sql_column_env_add (COLMAP (p),
                      p->sem.doc_tbl.iter,
                      type_of (p, p->sem.doc_tbl.iter),
                      crrl_deco (sql_expression (COLMAP (L (p)),
                              p->sem.doc_tbl.iter,
                              type_of (L (p),
                                  p->sem.
                                  doc_tbl.
                                  iter)),
                          crrl1->name));

              /* add column to store the document nodes to
               * the environment */
              sql_column_env_add (COLMAP (p),
                      p->sem.doc_tbl.item_res,
                      TYPE_MASK (type_of (p, p->sem.doc_tbl.item_res)),
                      crrl_deco (
                          COLUMN_SPEC (sql_col_pre),
                          crrl1->name));

              sql_where_env_add (WHEREMAP (p),
                      eq
                      (crrl_deco (
                       COLUMN_SPEC (sql_col_kind),
                        crrl1->name), lit_int (DOC)));

              sql_where_env_add (WHEREMAP (p),
                      eq
                      (crrl_deco
                       (COLUMN_SPEC (sql_col_value),
                        crrl1->name),
                       sql_expression (COLMAP (L (p)),
                           p->sem.doc_tbl.item,
                           type_of (L (p),
                               p->sem.doc_tbl.item))));

              /* set the fragment relation */
              p->sql_ann->fragment = fragrelation ();

              /* preparing fromlist */
              PFsql_t *fromlist = FROM (L (p));
              PFsql_t *fr = table_deco (alias (fragrelation (),
                              correlation_name (crrl1->name)),
                              true);
              fromlist = from_list_add (fromlist, fr);

              sql_stmt = select (NULL, fromlist, NULL, NULL);
          }
          break;

          /* List:   fcns (Constr, List) */
          case 219:
          {
          } break;
          /* List:   nil */
      case 220:
          {
          } break;

    /* Rel:    disjunion (count(Rel), attach(difference(Rel, project(count(Rel))))) */ 
    /*           union             */                             
    /*           /   \             */   
    /*          /     \            */ 
    /*         /     attach        */
    /*        /        |           */
    /*       /       diff          */
    /*      /        /  \          */
    /*      \      Rel   \         */
    /*       \         project     */       
    /*        \          /         */
    /*         \        /          */ 
    /*          \      /           */
    /*           \    /            */    
    /*            count            */
    case 222:
    {

        assert (RLRL (p)->sem.aggr.part);
        PFsql_t *fromlist = NULL;

        sql_column_env_add (COLMAP (p),
              RLRL (p)->sem.aggr.res, type_of (RLRL (p),
                  RLRL (p)->sem.aggr.res),
              coalesce
              (
               count
               (
                false,
                sql_expression (COLMAP (RLRLL (p)),
                     RLRL (p)->sem.aggr.part, type_of (RLRL (p),
                         RLRL (p)->sem.aggr.part))
               ),
               literal (R (p)->sem.attach.value)
              ));

        sql_column_env_add (COLMAP (p),
              RLRL (p)->sem.aggr.part, type_of (RLRL (p),
                  RLRL (p)->sem.aggr.part),
              sql_expression (COLMAP (RLL (p)),
                         RLRL (p)->sem.aggr.part, type_of(RLRL (p),
                             RLRL (p)->sem.aggr.part)));
        
        fromlist = 
            from_list (
               on
               (
                right_outer_join
                (
                  FROM (RLRLL (p)),
                  FROM (RLL (p))
                ),
                eq
                (
                 sql_expression (COLMAP (RLRLL (p)),
                     RLRL (p)->sem.aggr.part, type_of(RLRL (p),
                         RLRL (p)->sem.aggr.part)),
                 sql_expression (COLMAP (RLL (p)),
                     RLRL (p)->sem.aggr.part, type_of (RLRL (p),
                         RLRL (p)->sem.aggr.part))
                )
               )
            );


        where_env_copy (WHEREMAP (RLRLL (p)), WHEREMAP (p));
        where_env_copy (WHEREMAP (RLL (p)), WHEREMAP (p));

        sql_stmt = select
            (NULL,
             fromlist,
             NULL,
             column_list (
                 sql_expression (COLMAP (RLRLL (p)),
                     RLRL (p)->sem.aggr.part, type_of (RLRL (p),
                         RLRL (p)->sem.aggr.part)),
                 sql_expression (COLMAP (RLL (p)),
                     RLRL (p)->sem.aggr.part, type_of (RLRL (p),
                         RLRL (p)->sem.aggr.part))));

        p->dirty = true;

    } break;
    /* Constra: element (Rel, fcns (nil, nil)) */
    case 221:
    {
        /* reduce the first child */
        kids[0]->dirty = true;
        reduce (kids[0], nts[0]);

        PFsql_t *selectlist = NULL;
        PFsql_t *fromlist = NULL;

        /* this element doesn't have content */
        selectlist = 
              select_list
              (
               column_assign ( /* name */
                  sql_expression ( COLMAP (L (p)),
                      p->sem.iter_item.item,
                      type_of (L (p), p->sem.iter_item.item)),
                   COLUMN_SPEC (sql_col_name)
                  ),
               column_assign ( /* value */
                   lit_str(""),
                   COLUMN_SPEC (sql_col_value)
                   ),
               column_assign ( /* kind */
                  lit_int (ELEM),
                  COLUMN_SPEC (sql_col_kind)
                  ),
               column_assign ( /* level */
                  lit_int (p->delta_level), 
                  COLUMN_SPEC (sql_col_level)
                  ),
               column_assign ( /* size */
                  lit_int (0),
                  COLUMN_SPEC (sql_col_size)
                  ),
               column_assign ( /* delta_pre */
                   lit_int (p->delta_pre),
                   COLUMN_SPEC (sql_col_dpre)
                   ),
               column_assign ( /* pre */
                  lit_int (-1),
                  COLUMN_SPEC (sql_col_pre)
                  ),
              column_assign ( /* pos */
                   lit_int (-1),
                   COLUMN_NAME (att_pos, aat_nat)
                   ),
               column_assign ( /* iter */
                   sql_expression ( COLMAP (L(p)),
                       p->sem.iter_item.iter,
                       type_of (L (p), p->sem.iter_item.iter)),
                   COLUMN_NAME (p->sem.iter_item.iter,
                       type_of (L (p), p->sem.iter_item.iter))
                   )
              );
        fromlist = from_list (FROM (L (p)));      

        PFsql_t *new_roots = 
            select
            (
             selectlist,
             fromlist,
             NULL,
             NULL
            );

        sql_table_name_t *newroots_tbl = sql_table_name_new ();

	execute (comment ("======================="),
		 comment ("= ELEMENT CONSTRUCTOR ="),
		 comment ("======================="),
		 bind
		 (table_name
		  (newroots_tbl->name,
		   column_list
		   (
            COLUMN_SPEC (sql_col_name),
            COLUMN_SPEC (sql_col_value),
            COLUMN_SPEC (sql_col_kind),
            COLUMN_SPEC (sql_col_level),
            COLUMN_SPEC (sql_col_size),
            COLUMN_SPEC (sql_col_dpre),
            COLUMN_SPEC (sql_col_pre),
            COLUMN_NAME (att_pos,  aat_nat),
            COLUMN_NAME (att_iter, 
                        type_of (L (p), p->sem.iter_item.iter))
           )
          ),
          new_roots));

        p->sql_ann->tabname = table_name_default (newroots_tbl->name);
    } break;
    /* Constra: element (Rel, List) */ 
    case 216:
    {
        /* reduce the first child */
        kids[0]->dirty = true;
        reduce (kids[0], nts[0]);
        for (unsigned short i = 1; nts[i]; i++) {
	        /* make subsequent nodes of cross dirty to force
	           a binding */
            reduce (kids[i], nts[i]);
        }

        PFsql_t *roots = NULL;
        PFsql_t *selectlist = NULL;
        PFsql_t *fromlist = NULL;

        sql_correlation_name_t *root_crrl = sql_correlation_name_new ();

        /* run through the fcns list collecting the contents */
        for (PFla_op_t *fcns = R (p); fcns->kind != la_nil; fcns = R (fcns))
        {
            roots = (roots == NULL)?
                gen_roots (p, L (fcns)):
                disjunion (roots, gen_roots (p, L (fcns))); 
        }

        int ccontent = count_content ( R(p));
        twig_sort = (ccontent != -1);
        selectlist = 
            select_list
            (
             column_assign ( /* name */
                sql_expression ( COLMAP (L (p)),
                    p->sem.iter_item.item,
                    type_of (L (p), p->sem.iter_item.item)),
                COLUMN_SPEC (sql_col_name)
                ),
             column_assign ( /* value */
                 lit_str(""),
                 COLUMN_SPEC (sql_col_value)
                 ),
             column_assign ( /* kind */
                lit_int (ELEM),
                COLUMN_SPEC (sql_col_kind)
                ),
             column_assign ( /* level */
                lit_int (p->delta_level),
                COLUMN_SPEC (sql_col_level)
                ),
             column_assign ( /* size */
                (ccontent != -1)?
                lit_int (ccontent):
                coalesce
                (
                 sum
                 (
                  add
                  (
                   crrl_deco (
                       COLUMN_SPEC (sql_col_size),
                       root_crrl->name),
                       lit_int (1)
                  )
                 ),
                 lit_int (0)
                ),
                COLUMN_SPEC (sql_col_size)
                ),
             column_assign ( /* delta_pre */
                 lit_int (p->delta_pre),
                 COLUMN_SPEC (sql_col_dpre)
                 ),
             column_assign ( /* pre */
                lit_int (-1),
                COLUMN_SPEC (sql_col_pre)
                ),
            column_assign ( /* pos */
                 lit_int (-1),
                 COLUMN_NAME (att_pos, aat_nat)
                 ),
             column_assign ( /* iter */
                 sql_expression ( COLMAP (L(p)),
                     p->sem.iter_item.iter,
                     type_of (L (p), p->sem.iter_item.iter)),
                 COLUMN_NAME (att_iter, aat_nat)
                 )
            );

        fromlist =
            from_list
            (
             (ccontent != -1)?
             FROM (L (p)):      
             on
             (
              right_outer_join
              (
                alias
                (
                 roots,
                 correlation_name (root_crrl->name)
                ),
                FROM (L (p))
              ),
              eq
              (
               sql_expression (
                   COLMAP (L(p)),
                   p->sem.iter_item.iter,
                   type_of (L(p), p->sem.iter_item.iter)
                   ),
               crrl_deco (
                   COLUMN_NAME (att_iter, 
                                type_of (
                                 L (p),
                                 p->sem.iter_item.iter)),
                   root_crrl->name
                   )
              )
             )
            );

      PFsql_t *new_roots = 
          select
          (
           selectlist,
           fromlist,
           NULL,
           (ccontent != -1)?
           NULL:
           column_list (
               sql_expression ( COLMAP (L (p)),
                     p->sem.iter_item.iter,
                     type_of (L (p), p->sem.iter_item.iter)),
                sql_expression ( COLMAP (L (p)),
                    p->sem.iter_item.item,
                    type_of (L (p), p->sem.iter_item.item))
               )
          );

      sql_table_name_t *newroots_tbl = sql_table_name_new ();

	execute (comment ("======================="),
	   comment ("= ELEMENT CONSTRUCTOR ="),
	   comment ("======================="),
	   bind
	   (table_name
	    (newroots_tbl->name,
	     column_list
	     (
          COLUMN_SPEC (sql_col_name),
          COLUMN_SPEC (sql_col_value),
          COLUMN_SPEC (sql_col_kind),
          COLUMN_SPEC (sql_col_level),
          COLUMN_SPEC (sql_col_size),
          COLUMN_SPEC (sql_col_dpre),
          COLUMN_SPEC (sql_col_pre),
          COLUMN_NAME (att_pos, aat_nat),
          COLUMN_NAME (att_iter, type_of (L (p), p->sem.iter_item.iter))
         )
        ),
        new_roots
       )
      );

      p->sql_ann->tabname = table_name_default (newroots_tbl->name);
    } break;
    /* Constr: twig (Constr) */
    case 218:
      {
        PFsql_t *selectlist = NULL;
        PFsql_t *fromlist = NULL;
        /* assign the delta_prev value to the constructor nodes */


        assign_delta_pre (p);
        PFla_dag_reset (p);

        reduce (kids[0], nts[0]);

        sql_table_name_t *twig_tbl = sql_table_name_new ();
        sql_correlation_name_t *subel_crrl = sql_correlation_name_new ();
        sql_correlation_name_t *max_crrl = sql_correlation_name_new ();

        /* after reducing the child nodes
         * collect the contents */
        selectlist = 
              select_list
              (
               column_assign ( /* name */
                   crrl_deco (
                       COLUMN_SPEC (sql_col_name),
                       subel_crrl->name
                       ),
                    COLUMN_SPEC (sql_col_name)
                   ),
               column_assign ( /* value */
                   crrl_deco (
                       COLUMN_SPEC (sql_col_value),
                       subel_crrl->name
                       ),
                   COLUMN_SPEC (sql_col_value)
                   ),
               column_assign ( /* kind */
                   crrl_deco (
                       COLUMN_SPEC (sql_col_kind),
                       subel_crrl->name
                       ),
                   COLUMN_SPEC (sql_col_kind)
                   ),
               column_assign ( /* level */
                   crrl_deco (
                       COLUMN_SPEC (sql_col_level),
                       subel_crrl->name),
                   COLUMN_SPEC (sql_col_level)
                   ),
               column_assign ( /* size */
                   crrl_deco (
                       COLUMN_SPEC (sql_col_size),
                       subel_crrl->name),
                      COLUMN_SPEC (sql_col_size)
                   ),
               column_assign ( /* pre */
                 add
                 (
                  crrl_deco
                  (
                   COLUMN_SPEC (sql_col_pre),
                   max_crrl->name
                  ),
                  over
                  (
                   rownumber (),
                   window_clause (
                    NULL,
                    order_by
                    (
                     (!twig_sort)?
                     sortkey_expressions
                     (
                      crrl_deco (
                            COLUMN_SPEC (sql_col_pre),
                        subel_crrl->name),
                      crrl_deco (
                        COLUMN_NAME (att_pos, aat_nat),
                         subel_crrl->name),
                      crrl_deco (
                            COLUMN_SPEC (sql_col_dpre),
                        subel_crrl->name),
                      crrl_deco (
		       COLUMN_NAME (att_iter,
                        type_of (p, p->sem.iter_item.iter)),
                       subel_crrl->name)
                      ):
                      sortkey_expressions
                      (
                       crrl_deco (
                             COLUMN_SPEC (sql_col_dpre),
                         subel_crrl->name),
                       crrl_deco (
		        COLUMN_NAME (att_iter, 
                        type_of (p, p->sem.iter_item.iter)),
                        subel_crrl->name)
                      )
                     )
                    )
                  )
                  ),
                    COLUMN_SPEC (sql_col_pre)
                  ),
               column_assign ( /* iter */
                   crrl_deco (
                    COLUMN_NAME (att_iter, 
                        type_of (p, p->sem.iter_item.iter)),
                    subel_crrl->name),
                   COLUMN_NAME ( p->sem.iter_item.iter, type_of (p, p->sem.iter_item.iter))
                   )
              );

        twig_sort = false;

	p->sql_ann->fragment = select
	  (select_list
	   (COLUMN_SPEC (sql_col_name),
	    COLUMN_SPEC (sql_col_value),
	    COLUMN_SPEC (sql_col_kind),
	    COLUMN_SPEC (sql_col_level),
	    COLUMN_SPEC (sql_col_size),
	    COLUMN_SPEC (sql_col_pre)),
	   from_list
           (
            alias
            (
             table_name_default (twig_tbl->name),
             correlation_name (sql_correlation_name_new ()->name)
            )
           ),
	   NULL,
           
           NULL);


        sql_correlation_name_t *max_pre_crrl = sql_correlation_name_new ();

        PFsql_t *max_pre = select
                    (select_list (column_assign (max
                                                 (COLUMN_SPEC (sql_col_pre)),
                                                  COLUMN_SPEC (sql_col_pre))),
                     from_list (alias (max_pre_frag,
                                       correlation_name (max_pre_crrl->name))),
                     NULL,
                     NULL);

          fromlist =
              from_list
              (
               alias (get_twig_constr (p, p),
                   correlation_name (subel_crrl->name)),
               /* L(p)->sql_ann->tabname, */
               alias (max_pre,
                   correlation_name (max_crrl->name))
              );

        /* reset the SEEN bit */
        PFla_dag_reset (p);

        PFsql_t *twig = 
              select
              (
               selectlist,
               fromlist,
               NULL,
               NULL
              );

        execute (comment ("===================="),
		 comment ("= TWIG CONSTRUCTOR ="),
		 comment ("===================="),
		 bind
		 (table_name
		  (twig_tbl->name,
		   column_list
		   (
                    COLUMN_SPEC (sql_col_name),
                    COLUMN_SPEC (sql_col_value),
                    COLUMN_SPEC (sql_col_kind),
                    COLUMN_SPEC (sql_col_level),
                    COLUMN_SPEC (sql_col_size),
                    COLUMN_SPEC (sql_col_pre),
                    COLUMN_NAME (p->sem.iter_item.iter,
                                 type_of (p, p->sem.iter_item.iter))
            )
           ),
           twig
          ));


        sql_table_name_t *twig_crrl = sql_table_name_new ();

        sql_column_env_add ( COLMAP (p),
                p->sem.iter_item.iter,
                type_of (p, p->sem.iter_item.iter),
                crrl_deco (
                    COLUMN_NAME (p->sem.iter_item.iter,
                        type_of (p, p->sem.iter_item.iter)),
                    twig_crrl->name));

        sql_column_env_add ( COLMAP (p),
                p->sem.iter_item.item,
                type_of (p, p->sem.iter_item.item),
                crrl_deco (
                    COLUMN_SPEC ( sql_col_pre),
                    twig_crrl->name));

	sql_where_env_add (WHEREMAP (p),
			   eq (crrl_deco
			       (COLUMN_SPEC (sql_col_level),
				twig_crrl->name), lit_int (0)));


        /* the new maximum pre value is here */
	max_pre_frag = table_name_default (twig_tbl->name);

        sql_stmt = 
            select
            (
             NULL,
             from_list (
                 alias (
                     table_name_default (twig_tbl->name),
                     correlation_name (twig_crrl->name)
                 )),
             NULL,
             NULL
            );
      } break;
    /* Constr: content (Frag, Rel) */
    case 217:
      {
        sql_correlation_name_t *doc1 = sql_correlation_name_new (); 
        sql_correlation_name_t *doc2 = sql_correlation_name_new ();

        PFsql_t   *content = NULL;
        PFsql_t   *toplevel_content = NULL;
        PFla_op_t *frag = L(p);

        for (; frag->kind != la_empty_frag; frag = L (frag))
        {
            /* traverse the union-tree until you find a
	     * a node you you can use */
	    if (RL (frag)->kind == la_merge_adjacent)
	      continue;

            toplevel_content = gen_toplevel_content (p, frag, doc1);

            content = gen_content (p, frag, doc1, doc2);

            break;
        }

        for (frag = L (frag); frag->kind != la_empty_frag; frag = L (frag))
        {
            if (RL (frag)->kind == la_merge_adjacent)
                continue;

            toplevel_content = disjunion
                (
                 content,
                 gen_toplevel_content (p, frag, doc1)
                );

            content = 
                disjunion
                (
                 content,
                 gen_content(p, frag, doc1, doc2)
                );
        }

        sql_table_name_t *toplevel_tbl = sql_table_name_new ();

        execute (comment ("===================="),
                 comment ("= TOPLEVEL CONTENT ="),
                 comment ("===================="),
                 bind
                 (table_name
                  (toplevel_tbl->name,
                   column_list
                   (
                    COLUMN_SPEC (sql_col_size),
                    COLUMN_NAME (att_iter, type_of (R (p), p->sem.iter_pos_item.iter))
                   )),toplevel_content));

        sql_table_name_t *content_tbl = sql_table_name_new ();

	execute (comment ("==================="),
		 comment ("= ELEMENT CONTENT ="),
		 comment ("==================="),
		 bind
		 (table_name
		  (content_tbl->name,
		   column_list
		   (
                    COLUMN_SPEC (sql_col_name),
                    COLUMN_SPEC (sql_col_value),
                    COLUMN_SPEC (sql_col_kind),
                    COLUMN_SPEC (sql_col_level),
                    COLUMN_SPEC (sql_col_size),
                    COLUMN_SPEC (sql_col_dpre),
                    COLUMN_SPEC (sql_col_pre),
                    COLUMN_NAME (att_pos, aat_nat),
                    COLUMN_NAME (att_iter,
                                type_of ( R (p), p->sem.iter_pos_item.iter))
                   )),content));

        p->sql_ann->tabname = table_name_default (content_tbl->name);
        p->sql_ann->toplevel = table_name_default (toplevel_tbl->name);

      } break;
      /* Constr: element (Frag, element_tag (Rel, empty_tbl)) */
    case 72:
      assert (!"missing");
      break;



      /* Constr: attribute (Rel) */
    case 73:
      {

        PFsql_t *selectlist = 
            select_list
            (
            column_assign ( /* value */
                 sql_expression (COLMAP (L (p)),
                     p->sem.iter_item1_item2.item1,
                     type_of (L (p), p->sem.iter_item1_item2.item1)
                     ),
                 COLUMN_SPEC (sql_col_name)
                 ),
            column_assign ( /* name */
                 sql_expression (COLMAP (L (p)),
                     p->sem.iter_item1_item2.item2,
                     type_of (L (p), p->sem.iter_item1_item2.item2)
                     ),
                 COLUMN_SPEC (sql_col_value)
                 ),
             column_assign ( /* kind */
                 lit_int (ATTR),
                     COLUMN_SPEC (sql_col_kind)
                 ),
             column_assign ( /* level */
                 lit_int (p->delta_level),
                     COLUMN_SPEC (sql_col_level)
                 ),
             column_assign ( /* size */
                 lit_int (0),
                     COLUMN_SPEC (sql_col_size)
                 ),
             column_assign ( /* delta pre */
                 lit_int (p->delta_pre),
                     COLUMN_SPEC (sql_col_dpre)
                 ),
             column_assign ( /* pre */
                 lit_int (-1),
                     COLUMN_SPEC (sql_col_pre)
                 ),
             column_assign ( /* pos */ 
                 lit_int (-1),
                 COLUMN_NAME (att_pos, aat_nat)
                 ),
             column_assign ( /* iter */
                 sql_expression (COLMAP (L (p)),
                     p->sem.iter_item1_item2.iter,
                     type_of (L (p), p->sem.iter_item1_item2.iter)),
                 COLUMN_NAME (att_iter,
                     type_of (L (p), p->sem.iter_item1_item2.iter))
                 )
            );

        PFsql_t* fromlist = 
            from_list (
                    FROM (L (p))
                    );

        PFsql_t *wherelist = NULL;
        for (unsigned int i = 0;
	     i < PFarray_last (WHEREMAP (L (p))); i++)
	  {
	    sql_where_env_t entry =
	      sql_where_env_at (WHEREMAP (L (p)), i);
	    wherelist = where_list (wherelist, entry.expression);
	  }


        PFsql_t *new_attributes=
            select 
            (
             selectlist,
             fromlist,
             wherelist,
             NULL
            );

        sql_table_name_t *attribute_tbl= sql_table_name_new ();

	execute (comment ("========================"),
		 comment ("= ATTRIBUTE CONSTRUCTOR ="),
		 comment ("========================"),
		 bind
		 (table_name
		  (attribute_tbl->name,
		   column_list
		   (
                    COLUMN_SPEC (sql_col_name),
                    COLUMN_SPEC (sql_col_value),
                    COLUMN_SPEC (sql_col_kind),
                    COLUMN_SPEC (sql_col_level),
                    COLUMN_SPEC (sql_col_size),
                    COLUMN_SPEC (sql_col_dpre),
                    COLUMN_SPEC (sql_col_pre),
                    COLUMN_NAME (att_pos, aat_nat),
                    COLUMN_NAME (att_iter,
                                 type_of (L(p), p->sem.iter_item1_item2.iter))
                   )),new_attributes));

        p->sql_ann->tabname = table_name_default (attribute_tbl->name);

      } break;
      /* Constr: textnode (Rel) */
    case 74:
      {
        PFsql_t *selectlist = 
            select_list
            (
             column_assign ( /* name */
                 lit_str (""),
                 COLUMN_SPEC (sql_col_name)
                 ),
             column_assign ( /* value */
                 sql_expression (COLMAP (L (p)),
                     p->sem.iter_item.item,
                     type_of (L (p), p->sem.iter_item.item)
                     ),
                 COLUMN_SPEC (sql_col_value)
                 ),
             column_assign ( /* kind */
                 lit_int (PF_TEXT),
                 COLUMN_SPEC (sql_col_kind)
                 ),
             column_assign ( /* level */
                 lit_int (p->delta_level),
                 COLUMN_SPEC (sql_col_level)
                 ),
             column_assign ( /* size */
                 lit_int (0),
                 COLUMN_SPEC (sql_col_size)
                 ),
            column_assign ( /* delta pre */
                 lit_int (p->delta_pre),
                 COLUMN_SPEC (sql_col_dpre)
                 ),
             column_assign ( /* pre */
                 lit_int (-1),
                     COLUMN_SPEC (sql_col_pre)
                 ),
            column_assign ( /* pos */ 
                 lit_int (-1),
                 COLUMN_NAME (att_pos, aat_nat)
                 ),
             column_assign ( /* iter */
                 sql_expression (COLMAP (L (p)),
                     p->sem.iter_item.iter,
                     type_of (L (p), p->sem.iter_item.iter)),
                 COLUMN_NAME (p->sem.iter_item.iter,
                             type_of (L (p), p->sem.iter_item.iter))
                 )
            );

        PFsql_t *wherelist = NULL;
        for (unsigned int i = 0;
	     i < PFarray_last (WHEREMAP (L (p))); i++)
	  {
	    sql_where_env_t entry =
	      sql_where_env_at (WHEREMAP (L (p)), i);
	    wherelist = where_list (wherelist, entry.expression);
	  }


        PFsql_t* fromlist = 
            from_list (
                    FROM (L (p))
                    );

        PFsql_t *new_textnodes =
            select 
            (
             selectlist,
             fromlist,
             wherelist,
             NULL
            );

        sql_table_name_t *textnode_tbl = sql_table_name_new ();

	execute (comment ("========================"),
		 comment ("= TEXTNODE CONSTRUCTOR ="),
		 comment ("========================"),
		 bind
		 (table_name
		  (textnode_tbl->name,
		   column_list
		   (
            COLUMN_SPEC (sql_col_name),
            COLUMN_SPEC (sql_col_value),
            COLUMN_SPEC (sql_col_kind),
            COLUMN_SPEC (sql_col_level),
            COLUMN_SPEC (sql_col_size),
            COLUMN_SPEC (sql_col_dpre),
            COLUMN_SPEC (sql_col_pre),
            COLUMN_NAME (att_pos, aat_nat),
            COLUMN_NAME (att_iter,
                         type_of (L(p), p->sem.iter_item.iter))
           )
          ),
          new_textnodes));

        p->sql_ann->tabname = table_name_default (textnode_tbl->name);

      } break;

    /* Constr: docnode (Frag, Rel) */
    case 75:
      assert (!"missing");
      break;

    /* Constr: comment (Rel) */
    case 76:
      assert (!"missing");
      break;

    /* Constr: processi (Rel) */
    case 77:
      assert (!"missing");
      break;

    /* Constr: merge_adjacent (Frag, Rel) */
    case 78:
      {
	/* implement this rule as identity operator */
	for (unsigned int col = 0; col < p->schema.count; col++)
	  {
	    for (PFalg_simple_type_t t = 1; t; t <<= 1)
	      {
		if (t & TYPE_MASK (p->schema.items[col].type))
		  {
		    PFsql_t *sqlnode =
		      sql_expression_unsafe (COLMAP (R (p)),
					     p->schema.items[col].name, t);
		    if (!sqlnode)
		      {
			sqlnode = sql_expression (COLMAP (L (p)),
						  p->schema.items[col].name,
						  t);
		      }
		    sql_column_env_add (COLMAP (p),
					p->schema.items[col].name, t,
					sqlnode);
		  }
	      }
	  }

	p->sql_ann->fragment = collect (L (p));

	sql_stmt = select (NULL, FROM (R (p)), NULL, NULL);
      }
      break;

    /* Rel:    cond_err (Rel, Rel) */
    case 80:
      {
	reduce (kids[0], nts[0]);

	for (unsigned int i = 0; i < PFarray_last (COLMAP (L (p)));
	     i++)
	  {
	    sql_column_env_t entry =
	      sql_column_env_at (COLMAP (L (p)), i);
	    sql_column_env_add (COLMAP (p), entry.att, entry.type,
				entry.expression);
	  }

	sql_stmt = select
	  (NULL, from_list (FROM (L (p))), NULL, NULL);
      } break;

      /* Rel:    trace (Rel, Msg) */
    case 100:
      /* Msg:    trace_msg (Rel, Map) */
    case 101:
      /* Map:    trace_map (Rel, Map) */
    case 102:
      /* Map:    nil */
    case 103:
      /* Rel:    rec_fix (Rec, Rel) */
    case 105:
      /* Rel:    rec_base */
    case 106:
      /* Rec:    rec_param (Arg, Rec) */
    case 107:
      /* Rec:    nil */
    case 108:
      /* Arg:    rec_arg (Rel, Rel) */
    case 109:
      {
	    /** add OOPS here to indicate an unimplemented rule */
	PFoops (OOPS_FATAL,
		"SQLgen: Logical algebra rule (%u) not supported", rule);
      }
      break;

      /* Rel:    dummy (Rel) */
    case 110:
      /* Rel:    proxy (Rel) */
    case 111:
      /* Rel:    proxy_base (Rel) */
    case 112:
      /* Rel:    eqjoin_unq (Rel, Rel) */
    case 113:
      /* Rel:    cross_mvd (Rel, Rel) */
    case 114:
      PFoops (OOPS_FATAL,
	      "SQLgen: Logical algebra operator is not allowed here");
      break;
    }

  /* override sfw only when is not dirty */
  if (sql_stmt)
    {
      p->sql_ann->sfw = sql_stmt;
      p->sql_ann->sfw = (DIRTY (p) && rule != 70) ? NULL : sql_stmt;
    }

  /* BINDING */
  /* execute the statement at the end if the node is dirty,
     and bind it to a new SQL variable */
  /* The strategy behind this late binding is to merge
   * as many operators as possible into one SQL statement.
   */
  if (sql_stmt && DIRTY (p) && rule != 70)
    {
#ifndef NDEBUG
      execute (comment ("%s", PFlalg2sql_string[rule]),
	       comment ("Binding due to: %s%s%s%s%s",
			(p->refctr > 1)
			? "refctr > 1" : "",
			(p->refctr > 1 &&
			 sql_stmt->kind != sql_select)
			? " and " : "",
			(sql_stmt->kind != sql_select)
			? "kind != sql_select" : "",
			((p->refctr > 1 ||
			  sql_stmt->kind != sql_select) &&
			 p->dirty)
			? " and " : "", (p->dirty) ? "dirty node" : ""));
#endif
      /* create a new table name for binding */
      sql_table_name_t *newvar = sql_table_name_new ();
      /* bind the new variable to the sql annotation */
      p->sql_ann->tabname = table_name_default (newvar->name);

      /* first selectlist for select statement in p */
      PFsql_t *selectlist1 = NULL;
      PFsql_t *selectlist2 = NULL;
      PFsql_t *columnlist = NULL;
      PFsql_t *wherelist = NULL;

      /* correlation name for bounded table */
      sql_correlation_name_t *crrl = sql_correlation_name_new ();

      for (unsigned int i = 0; i < PFarray_last (WHEREMAP (p)); i++)
	{
	  sql_where_env_t entry = sql_where_env_at (WHEREMAP (p), i);
	  wherelist = where_list (wherelist, entry.expression);
	}

      for (unsigned int i = 0; i < p->schema.count; i++)
	{
	  for (PFalg_simple_type_t t = 1; t; t <<= 1)
	    {
	      if (t & TYPE_MASK (p->schema.items[i].type))
		{
		  /* get the sql operation bound to
		   * att/type tuple */
		  PFsql_t *sqlnode = sql_expression (COLMAP (p),
						     p->schema.items[i].name,
						     t);
		  sql_column_name_t *colname =
		    ((sqlnode->kind == sql_clmn_name)
		     && (eq_type (p->schema.items[i].name, t,
				  sqlnode->sem.column.
				  ident))) ? NULL : sql_column_name_new (p->
									 schema.
									 items
									 [i].
									 name,
									 t);

		  /* add the sql operation to the select list */

		  /* we have a different strategy when our
		     when our item is boolean */
		  if (p->schema.items[i].type != aat_bln)
		    {
		      selectlist1 = select_list (selectlist1,
						 ((sqlnode->kind ==
						   sql_clmn_name)
						  &&
						  (eq_type
						   (p->schema.items[i].name,
						    t,
						    sqlnode->sem.column.
						    ident))) ?
						 /* the column name get not affected
						    by the new correlation name */
						 crrl_deco (column_name
							    (sqlnode->sem.
							     column.ident),
							    sqlnode->
							    crrlname) :
						 column_assign (sqlnode,
								column_name
								(colname->
								 ident)));
		    }
		  else
		    {
		      /* our item is boolean, we work around this problem
		         with a case statement */
		      selectlist1 = select_list (selectlist1,
						 ((sqlnode->kind ==
						   sql_clmn_name)
						  &&
						  (eq_type
						   (p->schema.items[i].name,
						    t,
						    sqlnode->sem.column.
						    ident))) ?
						 crrl_deco (column_name
							    (sqlnode->sem.
							     column.ident),
							    sqlnode->
							    crrlname) :
						 column_assign (case_
								(else_
								 (lit_int
								  (0)),
								 when
								 (sqlnode,
								  lit_int
								  (1))),
								column_name
								(colname->
								 ident)));
		    }

		  /* create a column list for the variable
		     and for the select automatic generated
		     sfw statement in annotations. */
		  selectlist2 = select_list (selectlist2,
					     crrl_deco (((sqlnode->kind ==
							  sql_clmn_name)
							 &&
							 (eq_type
							  (p->schema.items[i].
							   name, t,
							   sqlnode->sem.
							   column.
							   ident))) ?
							column_name (IS_PRE
								     (sqlnode->
								      sem.
								      column.
								      ident) ?
								     sql_column_name_new
								     (p->
								      schema.
								      items
								      [i].
								      name,
								      t)->
								     ident :
								     sqlnode->
								     sem.
								     column.
								     ident) :
							column_name (IS_PRE
								     (colname->
								      ident) ?
								     sql_column_name_new
								     (p->
								      schema.
								      items
								      [i].
								      name,
								      t)->
								     ident :
								     colname->
								     ident),
							crrl->name));

		  /* create columnlist for the table name */
		  columnlist = column_list (columnlist,
					    ((sqlnode->kind == sql_clmn_name)
					     &&
					     (eq_type
					      (p->schema.items[i].name, t,
					       sqlnode->sem.column.ident))) ?
					    /* regarding the correlation
					       names both columns are unbounded */
					    column_name (IS_PRE
							 (sqlnode->sem.column.
							  ident) ?
							 sql_column_name_new
							 (p->schema.items[i].
							  name,
							  t)->
							 ident : sqlnode->sem.
							 column.
							 ident) :
					    column_name (IS_PRE
							 (colname->
							  ident) ?
							 sql_column_name_new
							 (p->schema.items[i].
							  name,
							  t)->
							 ident : colname->
							 ident));

		  /* override expression with columnname */
		  sql_override_expr (COLMAP (p),
				     p->schema.items[i].name, t,
				     ((sqlnode->kind == sql_clmn_name) &&
				      (eq_type (p->schema.items[i].name, t,
						sqlnode->sem.column.ident))) ?
				     IS_PRE (sqlnode->sem.column.ident) ?
				     sql_column_name_new (p->schema.items[i].
							  name,
							  t)->
				     ident : sqlnode->sem.column.
				     ident : IS_PRE (colname->
						     ident) ?
				     sql_column_name_new (p->schema.items[i].
							  name,
							  t)->
				     ident : colname->ident, crrl->name);
		}
	    }
	}

      WHEREMAP (p) = sql_where_env_new ();

      if (sql_stmt->kind == sql_select)
	{
	  sql_stmt->child[0] = selectlist1;
	  sql_stmt->child[2] = (!wherelist) ? NULL : wherelist;
	}

      if (p->distinct)
	sql_stmt->sem.select.distinct = true;

      execute (bind (table_name (newvar->name, columnlist), sql_stmt));

	/** override sfw node with a valid select node */
      p->sql_ann->sfw =
	select
	(selectlist2,
	 from_list
	 (alias (p->sql_ann->tabname,
		 correlation_name (crrl->name))), NULL, NULL);
    }

}

static PFsql_t*
gen_roots (PFla_op_t *p, PFla_op_t *c)
{
    sql_correlation_name_t *roots = sql_correlation_name_new (); 

    PFsql_t *selectlist = 
        select_list 
        (
         column_assign (  /* size */
             crrl_deco
             (
              COLUMN_SPEC (sql_col_size),
              roots->name
             ),
             COLUMN_SPEC (sql_col_size)
             ),
         column_assign (  /* iter */
             crrl_deco
             (
              COLUMN_NAME (p->sem.iter_item.iter,
                          type_of (L (p),p->sem.iter_item.iter)),
              roots->name
             ),
             COLUMN_NAME (p->sem.iter_item.iter,
                          type_of (L (p),p->sem.iter_item.iter)))
        );

    PFsql_t *fromlist =
        from_list
        (
         alias
         (
          (c->kind == la_content)?c->sql_ann->toplevel:c->sql_ann->tabname,
          correlation_name (roots->name)
         )
        );

    return select
        (
         selectlist,
         fromlist,
         NULL,
         NULL
        );
}

static PFsql_t*
gen_content (PFla_op_t *p, PFla_op_t *frag,
        sql_correlation_name_t *doc1,
        sql_correlation_name_t *doc2)
{
    /* the select clause remains the same for all contents */
    PFsql_t *selectlist =
        select_list
        (
        column_assign (
             crrl_deco (
                 COLUMN_SPEC (sql_col_name),
                 doc2->name),
             COLUMN_SPEC (sql_col_name)
             ),
         column_assign (
             crrl_deco (
                 COLUMN_SPEC (sql_col_value),
                 doc2->name),
             COLUMN_SPEC (sql_col_value)
             ),
         column_assign (
             crrl_deco (
                 COLUMN_SPEC (sql_col_kind),
                 doc2->name),
             COLUMN_SPEC (sql_col_kind)
             ),
         column_assign (
             add
             (
              sub
              (
               crrl_deco (
                   COLUMN_SPEC (sql_col_level),
                   doc2->name),
               crrl_deco (
                   COLUMN_SPEC (sql_col_level),
                   doc1->name)
              ),
              lit_int (p->delta_level)
             ),
              COLUMN_SPEC (sql_col_level)
             ),
         column_assign (
             crrl_deco (
                 COLUMN_SPEC (sql_col_size),
                 doc2->name),
                 COLUMN_SPEC (sql_col_size)
             ),
         column_assign (
             lit_int (p->delta_pre), 
             COLUMN_SPEC (sql_col_dpre)
             ),
         column_assign (
             crrl_deco (
                COLUMN_SPEC (sql_col_pre),
                 doc2->name),
                COLUMN_SPEC (sql_col_pre)
             ),
         column_assign (
             sql_expression (COLMAP (R (p)),
                 p->sem.iter_pos_item.pos,
                 type_of (R (p), p->sem.iter_pos_item.pos)),
             COLUMN_NAME (att_pos, aat_nat)
             ),
         column_assign (
             sql_expression (COLMAP (R (p)), 
                 p->sem.iter_pos_item.iter,
                 type_of (R (p), p->sem.iter_pos_item.iter)),
             COLUMN_NAME (p->sem.iter_pos_item.iter, type_of ( R (p), p->sem.iter_pos_item.iter))
             )
        );

        PFsql_t *wherelist = NULL;
        for (unsigned int i = 0;
	     i < PFarray_last (WHEREMAP (R (p))); i++)
	  {
	    sql_where_env_t entry =
	      sql_where_env_at (WHEREMAP (R (p)), i);
	    wherelist = where_list (wherelist, entry.expression);
	  }

        wherelist = where_list (wherelist, and_
             (
              eq
              (
                crrl_deco (
                    COLUMN_SPEC (sql_col_pre),
                    doc1->name),
                sql_expression (COLMAP (R (p)),
                    p->sem.iter_pos_item.item,
                    type_of (R (p), p->sem.iter_pos_item.item))
              ),
              and_
              (
               gteq
               (
                crrl_deco (
                    COLUMN_SPEC (sql_col_pre),
                    doc2->name),
                crrl_deco (
                    COLUMN_SPEC (sql_col_pre),
                    doc1->name)
               ),
               gteq
               (
                add
                (
                 crrl_deco (
                     COLUMN_SPEC (sql_col_pre),
                     doc1->name),
                 crrl_deco (
                     COLUMN_SPEC (sql_col_size),
                     doc1->name)
                ),
                crrl_deco (
                    COLUMN_SPEC (sql_col_pre),
                    doc2->name)
               )
              )
             ));
    
        return 
            select 
            (
             selectlist,
             from_list
             (
              FROM (R (p)),
              alias
              (
               R (frag)->sql_ann->fragment,
               correlation_name (doc1->name)
              ),
              alias
              (
               R (frag)->sql_ann->fragment,
               correlation_name (doc2->name)
              )
             ),
             wherelist,
             NULL
            );
}

static PFsql_t*
gen_toplevel_content (PFla_op_t *p, PFla_op_t *frag,
        sql_correlation_name_t *doc1)
{
    /* the select clause remains the same for all contents */
    PFsql_t *selectlist =
        select_list
        (
         column_assign (
             crrl_deco (
                 COLUMN_SPEC (sql_col_size),
                 doc1->name),
                 COLUMN_SPEC (sql_col_size)
             ),
         column_assign (
             sql_expression (COLMAP (R (p)), 
                 p->sem.iter_pos_item.iter,
                 type_of (R (p), p->sem.iter_pos_item.iter)),
             COLUMN_NAME (p->sem.iter_pos_item.iter, type_of ( R (p), p->sem.iter_pos_item.iter))
             )
        );

        PFsql_t *wherelist = NULL;
        for (unsigned int i = 0;
	     i < PFarray_last (WHEREMAP (R (p))); i++)
        {
            sql_where_env_t entry =
              sql_where_env_at (WHEREMAP (R (p)), i);
            wherelist = where_list (wherelist, entry.expression);
        }

        wherelist = where_list (wherelist,
              eq
              (
                crrl_deco (
                    COLUMN_SPEC (sql_col_pre),
                    doc1->name),
                sql_expression (COLMAP (R (p)),
                    p->sem.iter_pos_item.item,
                    type_of (R (p), p->sem.iter_pos_item.item))
              ),
             );
    
        return 
            select 
            (
             selectlist,
             from_list
             (
              FROM (R (p)),
              alias
              (
               R (frag)->sql_ann->fragment,
               correlation_name (doc1->name)
              ),
             ),
             wherelist,
             NULL
            );
}

#if 0

static PFsql_t *
gen_ctx_cstr (PFla_op_kind_t kind, PFla_op_t * p, sql_correlation_name_t
	      * eloc_crrl, sql_correlation_name_t * t2loc_crrl,
	      sql_correlation_name_t * t3loc_crrl)
{
  return
    and_
    (eq
     (crrl_deco (column_name (sql_special_name_new (sql_col_pre)->ident),
		 t2loc_crrl->name),
      crrl_deco (column_name (sql_expression (RR (p)->sql_ann->colmap,
					      p->sem.elem.item_val,
					      ((kind == la_textnode) ||
					       (kind == la_element)) ?
					      aat_pre : aat_attr)->sem.column.
			      ident), eloc_crrl->name)),
     and_ (gteq
	   (crrl_deco
	    (column_name (sql_special_name_new (sql_col_pre)->ident),
	     t3loc_crrl->name),
	    crrl_deco (column_name
		       (sql_special_name_new (sql_col_pre)->ident),
		       t2loc_crrl->name)),
	   gteq (add
		 (crrl_deco
		  (column_name (sql_special_name_new (sql_col_pre)->ident),
		   t2loc_crrl->name),
		  crrl_deco (column_name
			     (sql_special_name_new (sql_col_size)->ident),
			     t2loc_crrl->name)),
		 crrl_deco (column_name
			    (sql_special_name_new (sql_col_pre)->ident),
			    t3loc_crrl->name))));
}

static PFsql_t *
gen_ctx_statement (PFla_op_t * p, PFla_op_t * frag, sql_correlation_name_t
		   * eloc_crrl, sql_correlation_name_t * t2loc_crrl,
		   sql_correlation_name_t * t3loc_crrl)
{

  PFsql_t *selectlist =
    select_list
    (column_assign
     (crrl_deco (column_name (sql_special_name_new (sql_col_name)->ident),
		 t3loc_crrl->name),
      column_name (sql_special_name_new (sql_col_name)->ident)),
     column_assign
     (crrl_deco (column_name (sql_special_name_new (sql_col_value)->ident),
		 t3loc_crrl->name),
      column_name (sql_special_name_new (sql_col_value)->ident)),
     column_assign
     (crrl_deco (column_name (sql_special_name_new (sql_col_kind)->ident),
		 t3loc_crrl->name),
      column_name (sql_special_name_new (sql_col_kind)->ident)),
     column_assign
     (add
      (sub
       (crrl_deco (column_name (sql_special_name_new (sql_col_level)->ident),
		   t3loc_crrl->name),
	crrl_deco (column_name (sql_special_name_new (sql_col_level)->ident),
		   t2loc_crrl->name)),
       lit_int (1)),
      column_name (sql_special_name_new (sql_col_level)->ident)),
     column_assign
     (crrl_deco (column_name (sql_special_name_new (sql_col_size)->ident),
		 t3loc_crrl->name),
      column_name (sql_special_name_new (sql_col_size)->ident)),
     column_assign
     (crrl_deco (column_name (sql_special_name_new (sql_col_pre)->ident),
		 t3loc_crrl->name),
      column_name (sql_special_name_new (sql_col_pre)->ident)),
     column_assign
     (crrl_deco (column_name (sql_expression (RR (p)->sql_ann->colmap,
					      p->sem.elem.pos_val,
					      type_of (RR (p),
						       p->sem.elem.pos_val))->
			      sem.column.ident),
		 eloc_crrl->name),
      column_name (sql_column_name_new (att_pos, aat_nat)->ident)),
     column_assign
     (crrl_deco (column_name (sql_expression (RR (p)->sql_ann->colmap,
					      p->sem.elem.iter_val,
					      type_of (RR (p),
						       p->sem.elem.
						       iter_val))->sem.column.
			      ident),
		 eloc_crrl->name),
      column_name (sql_column_name_new (att_iter, aat_nat)->ident)));

  /* if the constructor is listed in the macro
   * constr then we need only one constraint 
   */
  if (constr (RL (frag)))
    {
      return
	select
	(selectlist,
	 from_list
	 (alias
	  (RR (p)->sql_ann->tabname,
	   correlation_name (eloc_crrl->name)),
	  alias
	  (R (frag)->sql_ann->fragment,
	   correlation_name (t2loc_crrl->name)),
	  alias
	  (R (frag)->sql_ann->fragment,
	   correlation_name (t3loc_crrl->name))),
	 gen_ctx_cstr (RL (frag)->kind, p, eloc_crrl, t2loc_crrl, t3loc_crrl),
	 NULL);
    }
  else
    {
      if (type_of (p, p->sem.elem.item_val) & aat_attr)
	{
	  return
	    disjunion
	    (select
	     (selectlist,
	      from_list
	      (alias
	       (RR (p)->sql_ann->tabname,
		correlation_name (eloc_crrl->name)),
	       alias
	       (R (frag)->sql_ann->fragment,
		correlation_name (t2loc_crrl->name)),
	       alias
	       (R (frag)->sql_ann->fragment,
		correlation_name (t3loc_crrl->name))),
	      gen_ctx_cstr (la_element, p, eloc_crrl, t2loc_crrl, t3loc_crrl),
	      NULL),
	     select
	     (selectlist,
	      from_list
	      (alias
	       (RR (p)->sql_ann->tabname,
		correlation_name (eloc_crrl->name)),
	       alias
	       (R (frag)->sql_ann->fragment,
		correlation_name (t2loc_crrl->name)),
	       alias
	       (R (frag)->sql_ann->fragment,
		correlation_name (t3loc_crrl->name))),
	      gen_ctx_cstr (la_attribute, p, eloc_crrl, t2loc_crrl,
			    t3loc_crrl), NULL));
	}
      else
	{
	  return
	    select
	    (selectlist,
	     from_list
	     (alias
	      (RR (p)->sql_ann->tabname,
	       correlation_name (eloc_crrl->name)),
	      alias
	      (R (frag)->sql_ann->fragment,
	       correlation_name (t2loc_crrl->name)),
	      alias
	      (R (frag)->sql_ann->fragment,
	       correlation_name (t3loc_crrl->name))),
	     gen_ctx_cstr (la_element, p, eloc_crrl, t2loc_crrl, t3loc_crrl),
	     NULL);
	}
    }
}



static PFsql_t *
gen_root_cstr (PFla_op_kind_t kind, PFla_op_t * p,
	       sql_correlation_name_t * eloc_crrl,
	       sql_correlation_name_t * t1loc_crrl)
{
  return
    eq
    (crrl_deco (column_name (sql_expression (COLMAP (RR (p)),
					     p->sem.elem.item_val,
					     (kind == la_element ||
					      kind == la_textnode)
					     ? aat_pre : aat_attr)->sem.
			     column.ident), eloc_crrl->name),
     crrl_deco (COLUMN_SPEC (sql_col_pre),
		t1loc_crrl->name));
}

static PFsql_t *
gen_roots_statement (PFla_op_t * p, PFla_op_t * frag,
		     sql_correlation_name_t * eloc_crrl,
		     sql_correlation_name_t * t1loc_crrl)
{
  PFsql_t *selectlist =
    select_list
    (crrl_deco (COLUMN_SPEC (sql_col_name),
		t1loc_crrl->name),
     crrl_deco (COLUMN_SPEC (sql_col_value),
		t1loc_crrl->name),
     crrl_deco (COLUMN_SPEC (sql_col_level),
		t1loc_crrl->name),
     crrl_deco (COLUMN_SPEC (sql_col_size),
		t1loc_crrl->name),
     crrl_deco (COLUMN_SPEC (sql_col_pre),
		t1loc_crrl->name),
     crrl_deco (column_name (sql_expression (COLMAP (RL (p)),
					     p->sem.elem.iter_qn,
					     type_of (RL (p),
						      p->sem.elem.iter_qn))->
			     sem.column.ident),
		eloc_crrl->name));

  /* if the constructor is listed in the macro
   * constr then we need only one constraint 
   */
  if (constr (RL (frag)))
    {
      return
	select
	(selectlist,
	 from_list
	 (on
	  (inner_join
	   (alias
	    (RR (p)->sql_ann->tabname,
	     correlation_name (eloc_crrl->name)),
	    alias
	    (R (frag)->sql_ann->fragment,
	     correlation_name (t1loc_crrl->name))),
	   gen_root_cstr (RL (frag)->kind, p, eloc_crrl, t1loc_crrl))),
	 NULL, NULL);
    }
  else
    {
      if (type_of (p, p->sem.elem.item_val) & aat_attr)
	{
	  return
	    disjunion
	    (select
	     (selectlist,
	      from_list
	      (on
	       (inner_join
		(alias
		 (RR (p)->sql_ann->tabname,
		  correlation_name (eloc_crrl->name)),
		 alias
		 (R (frag)->sql_ann->fragment,
		  correlation_name (t1loc_crrl->name))),
		gen_root_cstr (la_element, p, eloc_crrl, t1loc_crrl))),
	      NULL,
	      NULL),
	     select
	     (select_list (star ()),
	      from_list
	      (on
	       (inner_join
		(alias
		 (RR (p)->sql_ann->tabname,
		  correlation_name (eloc_crrl->name)),
		 alias
		 (R (frag)->sql_ann->fragment,
		  correlation_name (t1loc_crrl->name))),
		gen_root_cstr (la_attribute, p, eloc_crrl, t1loc_crrl))),
	      NULL, NULL));

	}
      else
	{
	  return
	    select
	    (selectlist,
	     from_list
	     (on
	      (inner_join
	       (alias
		(RR (p)->sql_ann->tabname,
		 correlation_name (eloc_crrl->name)),
		alias
		(R (frag)->sql_ann->fragment,
		 correlation_name (t1loc_crrl->name))),
	       gen_root_cstr (la_element, p, eloc_crrl, t1loc_crrl))),
	     NULL, NULL);

	}
    }
}
#endif


/**
 * Generate a SQL statement from current annotation.
 */
static PFsql_t *
gen_select (const PFla_op_t * p, PFsql_alg_ann_t * ann)
{
  /* first selectlist for select statement in p */
  PFsql_t *selectlist1 = NULL;
  PFsql_t *wherelist = NULL;

  for (unsigned int i = 0; i < PFarray_last (ann->wheremap); i++)
    {
      sql_where_env_t entry = sql_where_env_at (ann->wheremap, i);
      wherelist = where_list (wherelist, entry.expression);
    }

  for (unsigned int i = 0; i < p->schema.count; i++)
    {
      for (PFalg_simple_type_t t = 1; t; t <<= 1) {
	  if (t & TYPE_MASK (p->schema.items[i].type)) {

	      /* get the sql operation bound to
	       * att/type tuple */
	      PFsql_t *sqlnode = sql_expression (ann->colmap,
						 p->schema.items[i].name, t);

	      sql_column_name_t *colname =
		((sqlnode->kind == sql_clmn_name) &&
		 (eq_type (p->schema.items[i].name, t,
			   sqlnode->sem.column.ident))) ?
		NULL : sql_column_name_new (p->schema.items[i].name, t);

	      /* add the sql operation to the select list */
	      selectlist1 = select_list (selectlist1,
					 ((sqlnode->kind == sql_clmn_name) &&
					  (eq_type
					   (p->schema.items[i].name, t,
					    sqlnode->sem.column.ident))) ?
					 /* the column name get not affected
					    by the new correlation name */
					 crrl_deco (column_name
						    (sqlnode->sem.column.
						     ident),
						    sqlnode->
						    crrlname) :
					 column_assign (sqlnode,
							/* column is unbounded because */
							column_name (colname->
								     ident)));
	    }
	}
  }

  return select (selectlist1, NULL, wherelist, NULL);

}

/**
 * Construct a literal from a given algebra atom.
 */
static PFsql_t *
literal (PFalg_atom_t atom)
{
  switch (atom.type)
    {
    case aat_nat:
      return lit_int (atom.val.nat_);
    case aat_int:
      return lit_int (atom.val.int_);
    case aat_str:
      return lit_str (atom.val.str);
    case aat_bln:
      return lit_bln (atom.val.bln);
    case aat_dbl:
      return lit_dec (atom.val.dbl);
    case aat_dec:
      return lit_dec (atom.val.dec_);
    case aat_qname:
      return lit_str (PFqname_loc (atom.val.int_));
    default:
      break;
    }

  PFoops (OOPS_FATAL,
	  "SQLgen: a relational algebra type (0x%X) has not "
	  "been implemented", atom.type);

  return NULL;			/* satisfy picky compilers */
}

/**
 * Returns the type of an attribute.
 */
static PFalg_simple_type_t
type_of (const PFla_op_t * n, PFalg_att_t att)
{
  assert (n);

  for (unsigned int i = 0; i < n->schema.count; i++)
    {
      if (n->schema.items[i].name == att)
	{
	  return TYPE_MASK (n->schema.items[i].type);
	}
    }

  PFoops (OOPS_FATAL,
	  "SQLgen: cannot determine implementation type of "
	  "algebra expression");

  return aat_nat;		/* satisfy picky compilers */
}


/**
 * Constructs annotations for a generic, binary comparison operator.
 */
static PFsql_t *
bin_cmp (PFsql_t * (*op) (const PFsql_t *, const PFsql_t *),
	 PFla_op_t * p, PFalg_simple_type_t arg_ty)
{
  for (unsigned int i = 0; i < PFarray_last (COLMAP (L (p))); i++)
    {
      sql_column_env_t entry = sql_column_env_at (COLMAP (L (p)), i);
      sql_column_env_add (COLMAP (p),
			  entry.att, entry.type, entry.expression);
    }

  sql_column_env_add (COLMAP (p),
		      p->sem.binary.res, type_of (p, p->sem.binary.res),
		      op
		      (sql_expression (COLMAP (p),
				       p->sem.binary.att1,
				       arg_ty),
		       sql_expression (COLMAP (p),
				       p->sem.binary.att2, arg_ty)));

  where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

  return select (NULL,		/* no selectlist provided */
		 FROM (L (p)), NULL, NULL);
}

/**
 * Generic handling of binary operators.
 * Constructs annotations for a generic, binary operator.
 */
static PFsql_t *
bin_op (PFsql_t * (*op) (const PFsql_t *, const PFsql_t *),
	PFla_op_t * p, PFalg_simple_type_t arg_ty, PFalg_simple_type_t res_ty)
{
  for (unsigned int i = 0; i < PFarray_last (COLMAP (L (p))); i++)
    {
      sql_column_env_t entry = sql_column_env_at (COLMAP (L (p)), i);

      sql_column_env_add (COLMAP (p),
			  entry.att, entry.type, entry.expression);
    }

  where_env_copy (WHEREMAP (L (p)), WHEREMAP (p));

  for (unsigned int col = 0; col < p->schema.count; col++)
    {
      for (PFalg_simple_type_t t = 1; t; t <<= 1)
	{
	  if (t & TYPE_MASK (p->schema.items[col].type))
	    {
	      sql_column_env_add (COLMAP (p),
				  p->schema.items[col].name,
				  t,
				  op
				  (sql_expression (COLMAP (p),
						   p->sem.fun_1to1.refs.
						   atts[0], arg_ty),
				   sql_expression (COLMAP (p),
						   p->sem.fun_1to1.refs.
						   atts[1], arg_ty)));
	    }
	}
    }

  res_ty = res_ty;

  return select (NULL,		/* no selectlist provided */
		 from_list (FROM (L (p))), NULL, NULL);
}


static PFsql_t *
bin_rel (PFsql_t * (*op) (const PFsql_t *, const PFsql_t *),
	 PFla_op_t * p, PFla_op_t * l, PFla_op_t * r)
{
  PFsql_t *selectlist1 = NULL;
  PFsql_t *selectlist2 = NULL;

  for (unsigned int i = 0; i < p->schema.count; i++)
    {
      for (PFalg_simple_type_t t = 1; t; t <<= 1)
	{
	  if (t & TYPE_MASK (p->schema.items[i].type))
	    {
	      /*
	       * Type t is in the result relation.
	       * See if it is also in the left
	       * operand.
	       */
	      if (!(t & type_of (l, p->schema.items[i].name)))
		{
		  /* add null to the colmap */
		  sql_column_env_add (COLMAP (L (p)),
				      p->schema.items[i].name,
				      t, cast (null (), type (t)));
		}

	      PFsql_t *sqlnode = sql_expression (COLMAP (l),
						 p->schema.items[i].name, t);

	      selectlist1 = select_list (selectlist1,
					 ((sqlnode->kind == sql_clmn_name) &&
					  (eq_type
					   (p->schema.items[i].name, t,
					    sqlnode->sem.column.
					    ident))) ?
					 crrl_deco (column_name
						    (sqlnode->sem.column.
						     ident),
						    sqlnode->
						    crrlname) :
					 column_assign (sqlnode,
							COLUMN_NAME (p->schema.items[i].  name, t)));

	      /*
	       * Type t is in the result relation.
	       * See if it is also in the left
	       * operand.
	       */
	      if (!(t & type_of (R (p), p->schema.items[i].name)))
		{
		  /* add null to the colmap */
		  sql_column_env_add (COLMAP (r),
				      p->schema.items[i].name,
				      t, cast (null (), type (t)));
		}

	      sqlnode =
		sql_expression (COLMAP (r),
				p->schema.items[i].name, t);

	      selectlist2 = select_list (selectlist2,
					 ((sqlnode->kind == sql_clmn_name) &&
					  (eq_type
					   (p->schema.items[i].name, t,
					    sqlnode->sem.column.
					    ident))) ?
					 crrl_deco (column_name
						    (sqlnode->sem.column.
						     ident),
						    sqlnode->
						    crrlname) :
					 column_assign (sqlnode,
							COLUMN_NAME (p->schema.items[i].name, t)));

	      sql_column_env_add (COLMAP (p),
				  p->schema.items[i].name,
				  t,
				  COLUMN_NAME (p->schema.items[i].name, t));
	    }
	}
    }

  PFsql_t *wherelist1 = NULL;
  PFsql_t *wherelist2 = NULL;

  for (unsigned int i = 0; i < PFarray_last (WHEREMAP (l)); i++)
    {
      sql_where_env_t entry = sql_where_env_at (WHEREMAP (l), i);
      wherelist1 = where_list (wherelist1, entry.expression);
    }

  for (unsigned int i = 0; i < PFarray_last (WHEREMAP (r)); i++)
    {
      sql_where_env_t entry = sql_where_env_at (WHEREMAP (r), i);
      wherelist2 = where_list (wherelist2, entry.expression);
    }

  /* create an union from two selects */
  if (L (p)->sql_ann->sfw && R (p)->sql_ann->sfw)
    return op
      (select
       (selectlist1,
	FROM (l),
	wherelist1,
	NULL),
       select (selectlist2, FROM (r), wherelist2, NULL));
  else
    return NULL;
}


/**
 * Generic binary arithmetic operator. In addition to bin_op()
 * does addition type checks.
 */
static PFsql_t *
bin_arith (PFsql_t * (*op) (const PFsql_t *, const PFsql_t *), PFla_op_t * p)
{
  PFalg_simple_type_t ty = type_of (L (p), p->sem.fun_1to1.refs.atts[0]);

  /* second operand must have the same type as the first */
  assert (ty == type_of (L (p), p->sem.fun_1to1.refs.atts[0]));
  assert (ty == aat_int || ty == aat_dec || ty == aat_dbl || ty == aat_str);

  return bin_op (op, p, ty, ty);
}


/**
 * Generic binary comparison operator. In addition to bin_op() does
 * additional type checks.
 */
static PFsql_t *
bin_comp (PFsql_t * (*op) (const PFsql_t *, const PFsql_t *), PFla_op_t * p)
{
  PFalg_simple_type_t ty = type_of (L (p), p->sem.binary.att1);

  /* second operand must have the same type as the first */
  assert (ty == type_of (L (p), p->sem.binary.att1));
  assert (ty == aat_int || ty == aat_dec ||
	  ty == aat_dbl || ty == aat_str ||
	  ty == aat_bln || ty == aat_nat || ty == aat_qname || aat_pre);
  return bin_cmp (op, p, ty);
}

/**
 * Clone a given wherelist.
 */
static void
where_env_copy (PFarray_t * srcwheremap, PFarray_t * destwheremap)
{
  for (unsigned int i = 0; i < PFarray_last (srcwheremap); i++)
    {
      sql_where_env_t entry = sql_where_env_at (srcwheremap, i);
      sql_where_env_add (destwheremap, entry.expression);
    }
}

static void
llscj_attr_axis (PFsql_correlation_name_t c1,
		 PFsql_correlation_name_t c2, struct PFsql_alg_ann_t *ann)
{
  sql_where_env_add (ann->wheremap,
		     gt
		     (crrl_deco
		      (COLUMN_SPEC (sql_col_pre), c1),
		      crrl_deco (
				 COLUMN_SPEC (sql_col_pre),
				 c2)));

  sql_where_env_add (ann->wheremap,
		     gteq
		     (add
		      (crrl_deco
		       (COLUMN_SPEC (sql_col_pre), c2),
		       crrl_deco (COLUMN_SPEC (sql_col_size), c2)),
		      crrl_deco (
              COLUMN_SPEC (sql_col_pre),
				 c1)));

  sql_where_env_add (ann->wheremap,
		     eq
		     (crrl_deco
		      (COLUMN_SPEC (sql_col_level), c1),
		      add (crrl_deco
			   (COLUMN_SPEC (sql_col_level),
			    c2), lit_int (1))));
}

static void
llscj_axis (const PFla_op_t *p, PFsql_correlation_name_t c1,
	    PFsql_correlation_name_t c2,
	    PFsql_t ** fromlist, const PFla_op_t * frag,
	    struct PFsql_alg_ann_t *ann)
{

  /* we use the static information level if it is
   * available */
  if (LEVEL_SET (p))
      sql_where_env_add (ann->wheremap,
                    eq
                    (
                     crrl_deco
                     (
                      COLUMN_SPEC (sql_col_level)
                      ,
                      c1
                     ),
                     lit_int (p->sem.step.level)
                    ));

  assert (frag->sql_ann->fragment);
  switch (p->sem.step.axis)
    {
      /* ancestor axis */
    case alg_anc:
      {
    if (!LEVEL_SET (p))
        sql_where_env_add (ann->wheremap,
                   gt
                   (crrl_deco
                    (COLUMN_SPEC (sql_col_level),
                     c2),
                    crrl_deco (COLUMN_SPEC (sql_col_level), c1)));

	sql_where_env_add (ann->wheremap,
			   gteq (add
				 (crrl_deco
				  (COLUMN_SPEC (sql_col_pre), c2),
				  crrl_deco (COLUMN_SPEC (sql_col_size), c2)),
				 crrl_deco (COLUMN_SPEC (sql_col_pre), c1)));
	sql_where_env_add (ann->wheremap,
			   gteq (crrl_deco
				 (COLUMN_SPEC (sql_col_pre),
				  c2),
				 add (crrl_deco
				      (COLUMN_SPEC (sql_col_pre), c1),
				      crrl_deco (COLUMN_SPEC (sql_col_size),
						 c1))));
      }
      break;
      /* ancestor-or-self axis */
    case alg_anc_s:
      {
      if (!LEVEL_SET (p))
            sql_where_env_add (ann->wheremap,
                       gt
                       (crrl_deco
                        (COLUMN_SPEC (sql_col_level),
                         c2),
                        crrl_deco (COLUMN_SPEC (sql_col_level), c1)));
	sql_where_env_add (ann->wheremap,
			   gteq (add
				 (crrl_deco
				  (COLUMN_SPEC (sql_col_pre), c2),
				  crrl_deco (COLUMN_SPEC (sql_col_size), c2)),
				 crrl_deco (COLUMN_SPEC (sql_col_pre), c1)));
	sql_where_env_add (ann->wheremap,
			   gteq (crrl_deco
				 (COLUMN_SPEC (sql_col_pre),
				  c2),
				 add (crrl_deco
				      (COLUMN_SPEC (sql_col_pre), c1),
				      crrl_deco (COLUMN_SPEC (sql_col_size),
						 c1))));

      }
      break;
      /* child axis */
    case alg_chld:
      {
	sql_where_env_add (ann->wheremap,
			   gt
			   (crrl_deco
			    (COLUMN_SPEC (sql_col_pre), c1),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c2)));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (add
			    (crrl_deco
			     (COLUMN_SPEC (sql_col_pre),
			      c2),
			     crrl_deco (COLUMN_SPEC (sql_col_size), c2)),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c1)));

        if (!LEVEL_SET (p))
            sql_where_env_add (ann->wheremap,
                       eq
                       (crrl_deco
                        (COLUMN_SPEC (sql_col_level),
                         c1),
                        add (crrl_deco
                         (COLUMN_SPEC (sql_col_level), c2), lit_int (1))));
      }
      break;
      /* descendant axis */
    case alg_desc:
      {
	sql_where_env_add (ann->wheremap,
			   gt
			   (crrl_deco
			    (COLUMN_SPEC (sql_col_pre), c1),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c2)));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (add
			    (crrl_deco
			     (COLUMN_SPEC (sql_col_pre),
			      c2),
			     crrl_deco (COLUMN_SPEC (sql_col_size), c2)),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c1)));
      }
      break;
      /* descendant-or-self axis */
    case alg_desc_s:
      {
	sql_where_env_add (ann->wheremap,
			   gteq
			   (crrl_deco
                (COLUMN_SPEC (sql_col_pre), c1),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c2)
			    /*sql_expression(R(p)->sql_ann->colmap,
			       p->sem.step.item, aat_pre) */
			   ));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (add
			    (crrl_deco
			     (COLUMN_SPEC (sql_col_pre),
			      c2),
			     crrl_deco (COLUMN_SPEC (sql_col_size), c2)),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c1)));
      }
      break;
      /* following-sibling axis */
    case alg_fol_s:
      {
      if (!LEVEL_SET (p))
        sql_where_env_add (ann->wheremap,
                   eq
                   (crrl_deco
                    (COLUMN_SPEC (sql_col_level),
                     c1),
                    crrl_deco (COLUMN_SPEC (sql_col_level), c2)));
      }				/* continue with follwing */
      /* following axis */
    case alg_fol:
      {
	sql_where_env_add (ann->wheremap,
			   gt
			   (crrl_deco
			    (COLUMN_SPEC (sql_col_pre), c1),
			    add (crrl_deco
				 (COLUMN_SPEC (sql_col_pre),
				  c2),
				 crrl_deco (COLUMN_SPEC (sql_col_size), c2))));

	sql_correlation_name_t *crrl = sql_correlation_name_new ();

	*fromlist = from_list_add (*fromlist,
				   alias (frag->sql_ann->fragment,
					  correlation_name (crrl->name)));

	/* get parent of context node */
	sql_where_env_add (ann->wheremap,
			   eq
			   (crrl_deco
			    (COLUMN_SPEC (sql_col_level),
			     crrl->name),
			    sub (crrl_deco
				 (COLUMN_SPEC (sql_col_level), c2), lit_int (1))));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (add
			    (crrl_deco
			     (COLUMN_SPEC (sql_col_pre),
			      crrl->name),
			     crrl_deco (COLUMN_SPEC (sql_col_size), crrl->name)),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c2)));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (add
			    (crrl_deco
			     (COLUMN_SPEC (sql_col_pre),
			      c2),
			     crrl_deco (
                 COLUMN_SPEC (sql_col_size), c2)),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), crrl->name)));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (add
			    (crrl_deco
			     (COLUMN_SPEC (sql_col_pre),
			      crrl->name),
			     crrl_deco (COLUMN_SPEC (sql_col_size), crrl->name)),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c1)));

      }
      break;
      /* parent axis */
    case alg_par:
      {
      if (!LEVEL_SET (p))
            sql_where_env_add (ann->wheremap,
                       eq
                       (crrl_deco
                        (COLUMN_SPEC (sql_col_level),
                         c1),
                        sub (crrl_deco
                         (COLUMN_SPEC (sql_col_level), c2), lit_int (1))));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (
                add
			    (
                 crrl_deco
			     (
                  COLUMN_SPEC (sql_col_pre),
			      c1
                 ),
                 crrl_deco 
                 (
			      COLUMN_SPEC (sql_col_size),
                  c1
                 )
                ),
			    crrl_deco
                (
                 COLUMN_SPEC (sql_col_pre),
                 c2
                )));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (add
			    (crrl_deco
			     (COLUMN_SPEC (sql_col_pre),
			      c2),
			     crrl_deco (COLUMN_SPEC (sql_col_size), c2)),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c1)));
      }
      break;
      /* preceding-sibling axis */
    case alg_prec_s:
      {
      if (!LEVEL_SET (p))
        sql_where_env_add (ann->wheremap,
                   eq
                   (crrl_deco
                    (COLUMN_SPEC (sql_col_level),
                     c1),
                    crrl_deco (
                    COLUMN_SPEC (sql_col_level), c2)));

	sql_correlation_name_t *crrl = sql_correlation_name_new ();

	*fromlist = from_list_add (*fromlist,
				   alias (frag->sql_ann->fragment,
					  correlation_name (crrl->name)));

	/* get parent of context node */
	sql_where_env_add (ann->wheremap,
			   eq
			   (crrl_deco
			    (
                COLUMN_SPEC (sql_col_level),
			     crrl->name),
			    sub (crrl_deco
				 (COLUMN_SPEC (sql_col_level), c2), lit_int (1))));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (add
			    (crrl_deco
			     (COLUMN_SPEC (sql_col_pre),
			      crrl->name),
			     crrl_deco (COLUMN_SPEC (sql_col_size), crrl->name)),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c2)));

	sql_where_env_add (ann->wheremap,
			   gteq
			   (add
			    (crrl_deco
			     (COLUMN_SPEC (sql_col_pre),
			      c2),
			     crrl_deco (COLUMN_SPEC (sql_col_size), c2)),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), crrl->name)));

	sql_where_env_add (ann->wheremap,
			   gt
			   (crrl_deco
			    (COLUMN_SPEC (sql_col_pre), c1),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), crrl->name)));

      }				/* continue with preceding axis */
      /* preceding axis */
    case alg_prec:
      {
	sql_where_env_add (ann->wheremap,
			   gt
			   (crrl_deco
			    (COLUMN_SPEC (sql_col_pre), c2),
			    add (crrl_deco
				 (COLUMN_SPEC (sql_col_pre),
				  c1),
				 crrl_deco (COLUMN_SPEC (sql_col_size), c1))));
      }
      break;
      /* self axis */
    case alg_self:
      {
	sql_where_env_add (ann->wheremap,
			   eq
			   (crrl_deco
			    (COLUMN_SPEC (sql_col_pre), c1),
			    crrl_deco (COLUMN_SPEC (sql_col_pre), c2)));
      }
      break;
    default:
      PFoops (OOPS_FATAL, "SQLgen: axis not supported");
    }
}


static void
llscj_elem (const PFla_op_t *p, PFsql_correlation_name_t c1,
	    PFsql_correlation_name_t c2, const PFla_op_t * frag,
	    PFsql_t ** fromlist, struct PFsql_alg_ann_t *ann)
{
  assert (frag->sql_ann->fragment);

  sql_where_env_add (ann->wheremap,
		     eq
		     (crrl_deco
		      (COLUMN_SPEC (sql_col_kind), c1),
		      lit_int (ELEM)));

  llscj_axis (p, c1, c2, fromlist, frag, ann);
}

static void
llscj_attr (PFsql_correlation_name_t c1,
	    PFsql_correlation_name_t c2, struct PFsql_alg_ann_t *ann)
{
  sql_where_env_add (ann->wheremap,
		     eq
		     (crrl_deco
		      (COLUMN_SPEC (sql_col_kind), c1),
		      lit_int (ATTR)));

  llscj_attr_axis (c1, c2, ann);
}


static void
llscj_text (const PFla_op_t *p, PFsql_correlation_name_t c1,
	    PFsql_correlation_name_t c2, const PFla_op_t * frag,
	    PFsql_t ** fromlist, struct PFsql_alg_ann_t *ann)
{
  assert (frag->sql_ann->fragment);
  sql_where_env_add (ann->wheremap,
		     eq
		     (crrl_deco
		      (COLUMN_SPEC (sql_col_kind), c1),
		      lit_int (PF_TEXT)));

  llscj_axis (p, c1, c2, fromlist, frag, ann);
}


static void
llscj_comm (const PFla_op_t *p, PFsql_correlation_name_t c1,
	    PFsql_correlation_name_t c2, const PFla_op_t * frag,
	    PFsql_t ** fromlist, struct PFsql_alg_ann_t *ann)
{
  assert (frag->sql_ann->fragment);

  sql_where_env_add (ann->wheremap,
		     eq
		     (crrl_deco
		      (COLUMN_SPEC (sql_col_kind), c1),
		      lit_int (COMM)));

  llscj_axis (p, c1, c2, fromlist, frag, ann);
}


#define llscj_elem_nsloc(ax, ns, loc, c1, c2, frag, fr, ann) \
    llscj_elem_loc(ax, loc, c1, c2, frag, fr, ann)
static void
llscj_elem_loc (const PFla_op_t *p, PFsql_t * loc, PFsql_correlation_name_t c1,
		PFsql_correlation_name_t c2, const PFla_op_t * frag,
		PFsql_t ** fromlist, struct PFsql_alg_ann_t *ann)
{
  assert (frag->sql_ann->fragment);

  sql_where_env_add (ann->wheremap,
		     eq
		     (crrl_deco
		      (COLUMN_SPEC (sql_col_name), c1),
		      loc));

  llscj_elem (p, c1, c2, frag, fromlist, ann);
}

#define llscj_attr_nsloc(ns, loc, c1, c2, ann) \
    llscj_attr_loc(loc, c1, c2, ann)
static void
llscj_attr_loc (PFsql_t * loc, PFsql_correlation_name_t c1,
		PFsql_correlation_name_t c2, struct PFsql_alg_ann_t *ann)
{
  sql_where_env_add (ann->wheremap,
		     eq
		     (crrl_deco
		      (COLUMN_SPEC (sql_col_name), c1),
		      loc));

  llscj_attr (c1, c2, ann);
}


static struct PFsql_alg_ann_t *
llscj (const PFla_op_t * frag, const PFla_op_t * p)
{
  assert (frag->sql_ann->fragment);

  /* initialize the environment to fill */
  PFsql_alg_ann_t *ret = sql_alg_ann_new ();

  /* abbreviations for input expressions */
  PFty_t ty = p->sem.step.ty;
  PFsql_t *iter;
  PFsql_t *item;

  /* get attribute names of scj */
  PFalg_att_t pa_iter = p->sem.step.iter;
  PFalg_att_t pa_item = p->sem.step.item;

  /*
   * Determine generic input arguments.
   */
  assert (p);
  assert (R (p));
  assert (COLMAP (R (p)));

  iter = sql_expression (COLMAP (R (p)), pa_iter, type_of (R (p), pa_iter));
  assert (iter);

  item = sql_expression (COLMAP (R (p)), pa_item, type_of (R (p), pa_item));
  assert (item);


  /* get the correlation name of item */
  sql_correlation_name_t item_crrl;
  item_crrl.name = item->crrlname;

  /* get new correlation name for frag expression */
  sql_correlation_name_t *leg_crrl =
    (sql_correlation_name_t *) PFmalloc (sizeof (sql_correlation_name_t));

  /* check if the alias expression with item_crrl as correlation name
     is marked with frag */
  leg_crrl->name = sql_search_frag (FROM (R (p)), item_crrl);
  sql_correlation_name_t *crrl1 = sql_correlation_name_new ();

  sql_correlation_name_t *crrl2 =
    (leg_crrl->name > 0) ? leg_crrl : sql_correlation_name_new ();

  PFsql_t *fromlist = FROM (R (p));

  /* this new relation we need to get the attributes beside the pre
     value */
  if (leg_crrl->name == 0)
  {
    PFsql_t *fr2 = table_deco (alias (frag->sql_ann->fragment,
  				correlation_name (crrl2->name)),
  			 true);
    fromlist = from_list_add (fromlist, fr2);
  }

  /* this relation we need to get the new elements we want to find
     with the axis steps */
  PFsql_t *fr1 =
    table_deco (alias
		(frag->sql_ann->fragment, correlation_name (crrl1->name)),
		true);
  fromlist = from_list_add (fromlist, fr1);

  /* copy iter and item expression to current environment */
  sql_column_env_add (
              ret->colmap,
              pa_iter,
              type_of (p, pa_iter),
              iter);
  sql_column_env_add (
              ret->colmap,
		      p->sem.step.item_res,
              PFty_subtype (ty,
					     PFty_xs_anyAttribute ())?
		      aat_attr : aat_pre,
		      crrl_deco (COLUMN_SPEC (sql_col_pre),
				 crrl1->name));

  /* copy existing wheremap */
  for (unsigned int i = 0; i < PFarray_last (R (p)->sql_ann->wheremap); i++)
    {
      sql_where_env_t entry = sql_where_env_at (R (p)->sql_ann->wheremap, i);
      sql_where_env_add (ret->wheremap, entry.expression);
    }

  if (leg_crrl->name == 0)
    sql_where_env_add (ret->wheremap,
		       eq
		       (crrl_deco
			(COLUMN_SPEC (sql_col_pre),
			 crrl2->name), item));

  if (PFty_subtype (ty, PFty_xs_anyElement ()))
    {
      /* This is a test for element nodes */



      /* This is just a generic element kind test */
      if (PFty_subtype (PFty_xs_anyElement (), ty))
	{
	  llscj_elem (p, crrl1->name, crrl2->name, frag, &fromlist, ret);
	}
      /* test on element kind and local name only */
      else if (PFty_subtype (PFty_elem (PFqname (PFns_wild,
						 PFqname_loc (PFty_name
							      (PFty_defn
							       (ty)))),
					PFty_xs_anyType ()), ty))
	{
	  llscj_elem_loc (p,
			  lit_str (PFqname_loc (PFty_name (PFty_defn (ty)))),
			  crrl1->name, crrl2->name, frag, &fromlist, ret);
	}
      /* test on element kind and namespace only */
      else
	if (PFty_subtype
	    (PFty_elem
	     (PFqname (PFqname_ns (PFty_name (PFty_defn (ty))), NULL),
	      PFty_xs_anyType ()), ty))
	{
	  PFoops (OOPS_FATAL, "SQLgen: namespace tests only not supported");
	}
      /* test on element and full QName */
      else if (PFty_subtype (PFty_elem (PFty_name (PFty_defn (ty)),
					PFty_xs_anyType ()), ty))
	{
	  /* we simply ignore the namespace here */
	  llscj_elem_nsloc (p,
			    lit_str (""),
			    lit_str (PFqname_loc
				     (PFty_name (PFty_defn (ty)))),
			    crrl1->name, crrl2->name, frag, &fromlist, ret);
	}
      /*
       * We couldn't figure out what element test we got, give up.
       */
      else
	{
	  PFoops (OOPS_FATAL,
		  "SQLgen: problem with an XPath step: cannot evaluate "
		  "node test `%s'", PFty_str (ty));
	}
    }
  /* If the node wasn't some element test, maybe it is a text() test? */
  else if (PFty_subtype (ty, PFty_text ()))
    {
      llscj_text (p, crrl1->name, crrl2->name, frag, &fromlist, ret);
    }
  /* or a comment test ? */
  else if (PFty_subtype (ty, PFty_comm ()))
    {
      llscj_comm (p, crrl1->name, crrl2->name, frag, &fromlist, ret);
    }
  /* some test for processing instructions TODO */
  else if (PFty_subtype (ty, PFty_pi (NULL)))
    {
      assert (!"missing processing instruction test");
    }
  else if (PFty_subtype (PFty_xs_anyNode (), ty))
    {
      assert (!"missing anynode test");
    }
  else if (PFty_subtype (ty, PFty_xs_anyAttribute ()))
    {

      /* It is just a generic attribute kind test?
         (e.g. .../attribute) */
      if (PFty_subtype (PFty_xs_anyAttribute (), ty))
	;

      /* Is it a test on attribute kind and local name only? */
      else if (PFty_subtype (PFty_attr (PFqname (PFns_wild,
						 PFqname_loc (PFty_name
							      (PFty_defn
							       (ty)))),
					PFty_xs_anySimpleType ()), ty))
	{
	  assert (!"Is it a test on attribute kind and local name only?");
	}
      /* Or maybe a test on attribute kind and namespace only? */
      else
	if (PFty_subtype
	    (PFty_attr
	     (PFqname (PFqname_ns (PFty_name (PFty_defn (ty))), NULL),
	      PFty_xs_anySimpleType ()), ty))
	{
	  assert (!"Or maybe a test on attribute kind and namespace only?");
	}
      /* A test on attribute kind and full QName? */
      else if (PFty_subtype (PFty_attr (PFty_name (PFty_defn (ty)),
					PFty_xs_anySimpleType ()), ty))
	{
	  /* we simply ignore namespace here */
	  llscj_attr_nsloc (lit_str (""),
			    lit_str (PFqname_loc
				     (PFty_name (PFty_defn (ty)))),
			    crrl1->name, crrl2->name, ret);
	}
      /*
       * If we couldn't figure out what attribute test we got,
       * give up.
       *
       * NOTE: The surface language actually allows such tests. We
       *       just cannot implement them (yet):
       *
       *    doc("foo")/attribute::attribute(shoeSize, xs:integer)
       */
      else
	PFoops (OOPS_FATAL,
		"SQLgen: Problem with an XPath step: cannot evaluate "
		"node test `%s'", PFty_str (ty));
    }
  else
    {
      PFoops (OOPS_FATAL,
	      "SQLgen: we couldn't figure out what we test "
	      "in staircase join");
    }

  ret->sfw = gen_select (p, ret);
  ret->sfw->child[1] = fromlist;

  return ret;
}

static struct PFsql_alg_ann_t *
guide_llscj (const PFla_op_t * frag, const PFla_op_t * p)
{
  assert (frag->sql_ann->fragment);

  /* initialize the environment to fill */
  PFsql_alg_ann_t *ret = sql_alg_ann_new ();

  /* abbreviations for input expressions */
  PFty_t ty = p->sem.step.ty;
  PFsql_t *iter;
  PFsql_t *item;

  /* get attribute names of scj */
  PFalg_att_t pa_iter = p->sem.step.iter;
  PFalg_att_t pa_item = p->sem.step.item;

  /*
   * Determine generic input arguments.
   */
  assert (p);
  assert (R (p));
  assert (COLMAP (R (p)));

  iter = sql_expression (COLMAP (R (p)), pa_iter, type_of (R (p), pa_iter));
  assert (iter);

  item = sql_expression (COLMAP (R (p)), pa_item, type_of (R (p), pa_item));
  assert (item);

  /* get the correlation name of item */
  sql_correlation_name_t item_crrl;
  item_crrl.name = item->crrlname;

  /* get new correlation name for frag expression */
  sql_correlation_name_t *leg_crrl =
    (sql_correlation_name_t *) PFmalloc (sizeof (sql_correlation_name_t));

  /* check if the alias expression with item_crrl as correlation name
     is marked with frag */
  leg_crrl->name = sql_search_frag (FROM (R (p)), item_crrl);
  sql_correlation_name_t *crrl1 = sql_correlation_name_new ();

  sql_correlation_name_t *crrl2 =
    (leg_crrl->name > 0) ? leg_crrl : sql_correlation_name_new ();

  PFsql_t *fromlist = FROM (R (p));

  /* this new relation we need to get the attributes beside the pre
     value */
  if (leg_crrl->name == 0)
  {
    PFsql_t *fr2 = table_deco (alias (frag->sql_ann->fragment,
  				correlation_name (crrl2->name)),
  			 true);
    fromlist = from_list_add (fromlist, fr2);
  }

  /* this relation we need to get the new elements we want to find
     with the axis steps */
  PFsql_t *fr1 =
    table_deco (alias
		(frag->sql_ann->fragment, correlation_name (crrl1->name)),
		true);
  fromlist = from_list_add (fromlist, fr1);

  /* copy iter and item expression to current environment */
  sql_column_env_add (
              ret->colmap,
              pa_iter,
              type_of (p, pa_iter),
              iter);
  sql_column_env_add (
              ret->colmap,
		      p->sem.step.item_res,
              PFty_subtype (ty,
					     PFty_xs_anyAttribute ())?
		      aat_attr : aat_pre,
		      crrl_deco (COLUMN_SPEC (sql_col_pre),
				 crrl1->name));

  /* copy existing wheremap */
  for (unsigned int i = 0; i < PFarray_last (R (p)->sql_ann->wheremap); i++)
    {
      sql_where_env_t entry = sql_where_env_at (R (p)->sql_ann->wheremap, i);
      sql_where_env_add (ret->wheremap, entry.expression);
    }

  if (leg_crrl->name == 0)
    sql_where_env_add (ret->wheremap,
		       eq
		       (crrl_deco
			(COLUMN_SPEC (sql_col_pre),
			 crrl2->name), item));

  if (PFty_subtype (ty, PFty_xs_anyElement ()))
    {
      /* This is a test for element nodes */



      /* This is just a generic element kind test */
      if (PFty_subtype (PFty_xs_anyElement (), ty))
	{
	  llscj_elem (p, crrl1->name, crrl2->name, frag, &fromlist, ret);
	}
      /* test on element kind and local name only */
      else if (PFty_subtype (PFty_elem (PFqname (PFns_wild,
						 PFqname_loc (PFty_name
							      (PFty_defn
							       (ty)))),
					PFty_xs_anyType ()), ty))
	{
	  llscj_elem_loc (p,
			  lit_str (PFqname_loc (PFty_name (PFty_defn (ty)))),
			  crrl1->name, crrl2->name, frag, &fromlist, ret);
	}
      /* test on element kind and namespace only */
      else
	if (PFty_subtype
	    (PFty_elem
	     (PFqname (PFqname_ns (PFty_name (PFty_defn (ty))), NULL),
	      PFty_xs_anyType ()), ty))
	{
	  PFoops (OOPS_FATAL, "SQLgen: namespace tests only not supported");
	}
      /* test on element and full QName */
      else if (PFty_subtype (PFty_elem (PFty_name (PFty_defn (ty)),
					PFty_xs_anyType ()), ty))
	{
	  /* we simply ignore the namespace here */
	  llscj_elem_nsloc (p,
			    lit_str (""),
			    lit_str (PFqname_loc
				     (PFty_name (PFty_defn (ty)))),
			    crrl1->name, crrl2->name, frag, &fromlist, ret);
	}
      /*
       * We couldn't figure out what element test we got, give up.
       */
      else
	{
	  PFoops (OOPS_FATAL,
		  "SQLgen: problem with an XPath step: cannot evaluate "
		  "node test `%s'", PFty_str (ty));
	}
    }
  /* If the node wasn't some element test, maybe it is a text() test? */
  else if (PFty_subtype (ty, PFty_text ()))
    {
      llscj_text (p, crrl1->name, crrl2->name, frag, &fromlist, ret);
    }
  /* or a comment test ? */
  else if (PFty_subtype (ty, PFty_comm ()))
    {
      llscj_comm (p, crrl1->name, crrl2->name, frag, &fromlist, ret);
    }
  /* some test for processing instructions TODO */
  else if (PFty_subtype (ty, PFty_pi (NULL)))
    {
      assert (!"missing processing instruction test");
    }
  else if (PFty_subtype (PFty_xs_anyNode (), ty))
    {
      assert (!"missing anynode test");
    }
  else if (PFty_subtype (ty, PFty_xs_anyAttribute ()))
    {

      /* It is just a generic attribute kind test?
         (e.g. .../attribute) */
      if (PFty_subtype (PFty_xs_anyAttribute (), ty))
	;

      /* Is it a test on attribute kind and local name only? */
      else if (PFty_subtype (PFty_attr (PFqname (PFns_wild,
						 PFqname_loc (PFty_name
							      (PFty_defn
							       (ty)))),
					PFty_xs_anySimpleType ()), ty))
	{
	  assert (!"Is it a test on attribute kind and local name only?");
	}
      /* Or maybe a test on attribute kind and namespace only? */
      else
	if (PFty_subtype
	    (PFty_attr
	     (PFqname (PFqname_ns (PFty_name (PFty_defn (ty))), NULL),
	      PFty_xs_anySimpleType ()), ty))
	{
	  assert (!"Or maybe a test on attribute kind and namespace only?");
	}
      /* A test on attribute kind and full QName? */
      else if (PFty_subtype (PFty_attr (PFty_name (PFty_defn (ty)),
					PFty_xs_anySimpleType ()), ty))
	{
	  /* we simply ignore namespace here */
	  llscj_attr_nsloc (lit_str (""),
			    lit_str (PFqname_loc
				     (PFty_name (PFty_defn (ty)))),
			    crrl1->name, crrl2->name, ret);
	}
      /*
       * If we couldn't figure out what attribute test we got,
       * give up.
       *
       * NOTE: The surface language actually allows such tests. We
       *       just cannot implement them (yet):
       *
       *    doc("foo")/attribute::attribute(shoeSize, xs:integer)
       */
      else
	PFoops (OOPS_FATAL,
		"SQLgen: Problem with an XPath step: cannot evaluate "
		"node test `%s'", PFty_str (ty));
    }
  else
    {
      PFoops (OOPS_FATAL,
	      "SQLgen: we couldn't figure out what we test "
	      "in staircase join");
    }

  /* create the in operator of guide information */
    unsigned int guide_node_count = p->sem.step.guide_count; 
    /* literal list with statistical information */
    PFsql_t **list = (PFsql_t**)
            PFmalloc (
                guide_node_count*sizeof(PFsql_t*));

    /* guide nodes, with the statistical information */
    PFguide_tree_t ** guide_elements = p->sem.step.guides;

    /* create literals from guide nodes */
    for (unsigned int i = 0; i < guide_node_count; i++) {
        list[i] = lit_int(guide_elements[i]->guide);
    }
  
    PFsql_t *literal = PFsql_lit_list_
                       (
                        guide_node_count,
                        (const PFsql_t**)list
                       );
  
    PFsql_t *guide = in
                     (
                       crrl_deco (
                       COLUMN_SPEC(sql_col_guide),
                       crrl1->name),
                       literal
                     );
  
    sql_where_env_add (ret->wheremap, guide);        

    ret->sfw = gen_select (p, ret);
    ret->sfw->child[1] = fromlist;

  
    return ret;
}
    
static struct PFsql_alg_ann_t *
dup_step (const PFla_op_t * frag, const PFla_op_t * p)
{





      assert (frag->sql_ann->fragment);
    
      /* initialize the environment to fill */
    PFsql_alg_ann_t *ret = sql_alg_ann_new ();
  
    /* copy all existing expressions */
    for (unsigned int i = 0;
            i < PFarray_last (COLMAP (R (p))); i++) {
        sql_column_env_t entry =
            sql_column_env_at (COLMAP (R (p)), i);
        sql_column_env_add (ret->colmap, entry.att, entry.type,
                            entry.expression);
    }
  
    /* abbreviations for input expressions */
    PFty_t ty = p->sem.step.ty;
    PFsql_t *item;
  
    /* get attribute names of scj */
    PFalg_att_t pa_item = p->sem.step.item;
  
    /*
     * Determine generic input arguments.
     */
    assert (p);
    assert (R (p));
    assert (COLMAP (R (p)));
    item = sql_expression (COLMAP (R (p)), pa_item, aat_pre);
    assert (item);
  
    /* get the correlation name of item */
    sql_correlation_name_t item_crrl;
    item_crrl.name = item->crrlname;
  
    /* get new correlation name for frag expression */
    sql_correlation_name_t *leg_crrl =
      (sql_correlation_name_t *) PFmalloc (sizeof (sql_correlation_name_t));
  
    /* check if the alias expression with item_crrl as correlation name
       is marked with frag */
    leg_crrl->name = sql_search_frag (FROM (R (p)), item_crrl);
    sql_correlation_name_t *crrl1 = sql_correlation_name_new ();
  
    sql_correlation_name_t *crrl2 =
      (leg_crrl->name > 0) ? leg_crrl : sql_correlation_name_new ();
  
    PFsql_t *fromlist = FROM (R (p));
  
    /* this new relation we need to get the attributes beside the pre
       value */
    if (leg_crrl->name == 0)
    {
      PFsql_t *fr2 = table_deco (alias (frag->sql_ann->fragment,
    				correlation_name (crrl2->name)),
    			 true);
      fromlist = from_list_add (fromlist, fr2);
    }
  
    /* this relation we need to get the new elements we want to find
       with the axis steps */
    PFsql_t *fr1 =
      table_deco (alias
  		(frag->sql_ann->fragment, correlation_name (crrl1->name)),
  		true);
    fromlist = from_list_add (fromlist, fr1);
  
    /* copy iter and item expression to current environment */
    sql_column_env_add (ret->colmap,
  		      p->sem.step.item_res, PFty_subtype (ty,
  					     PFty_xs_anyAttribute ())?
  		      aat_attr : aat_pre,
  		      crrl_deco (COLUMN_SPEC (sql_col_pre),
  				 crrl1->name));
  
    /* copy existing wheremap */
    for (unsigned int i = 0;
        i < PFarray_last (R (p)->sql_ann->wheremap); i++) {
        sql_where_env_t entry = sql_where_env_at (R (p)->sql_ann->wheremap, i);
        sql_where_env_add (ret->wheremap, entry.expression);
    }
  
    if (leg_crrl->name == 0)
      sql_where_env_add (ret->wheremap,
  		       eq
  		       (crrl_deco
  			(COLUMN_SPEC (sql_col_pre),
  			 crrl2->name), item));
  
    if (PFty_subtype (ty, PFty_xs_anyElement ()))
      {
        /* This is a test for element nodes */
  
  
  
        /* This is just a generic element kind test */
      if (PFty_subtype (PFty_xs_anyElement (), ty))
  	{
  	  llscj_elem (p, crrl1->name, crrl2->name, frag, &fromlist, ret);
  	}
        /* test on element kind and local name only */
        else if (PFty_subtype (PFty_elem (PFqname (PFns_wild,
  						 PFqname_loc (PFty_name
  							      (PFty_defn
  							       (ty)))),
  					PFty_xs_anyType ()), ty))
  	{
  	  llscj_elem_loc (p,
  			  lit_str (PFqname_loc (PFty_name (PFty_defn (ty)))),
  			  crrl1->name, crrl2->name, frag, &fromlist, ret);
  	}
        /* test on element kind and namespace only */
        else
  	if (PFty_subtype
  	    (PFty_elem
  	     (PFqname (PFqname_ns (PFty_name (PFty_defn (ty))), NULL),
  	      PFty_xs_anyType ()), ty))
  	{
  	  PFoops (OOPS_FATAL, "SQLgen: namespace tests only not supported");
  	}
        /* test on element and full QName */
        else if (PFty_subtype (PFty_elem (PFty_name (PFty_defn (ty)),
  					PFty_xs_anyType ()), ty))
  	{
  	  /* we simply ignore the namespace here */
  	  llscj_elem_nsloc (p,
  			    lit_str (""),
  			    lit_str (PFqname_loc
  				     (PFty_name (PFty_defn (ty)))),
  			    crrl1->name, crrl2->name, frag, &fromlist, ret);
  	}
        /*
         * We couldn't figure out what element test we got, give up.
         */
        else
  	{
  	  PFoops (OOPS_FATAL,
  		  "SQLgen: problem with an XPath step: cannot evaluate "
  		  "node test `%s'", PFty_str (ty));
  	}
      }
    /* If the node wasn't some element test, maybe it is a text() test? */
    else if (PFty_subtype (ty, PFty_text ()))
      {
        llscj_text (p, crrl1->name, crrl2->name, frag, &fromlist, ret);
      }
    /* or a comment test ? */
    else if (PFty_subtype (ty, PFty_comm ()))
      {
        llscj_comm (p, crrl1->name, crrl2->name, frag, &fromlist, ret);
      }
    /* some test for processing instructions TODO */
    else if (PFty_subtype (ty, PFty_pi (NULL)))
      {
        assert (!"missing processing instruction test");
      }
    else if (PFty_subtype (PFty_xs_anyNode (), ty))
      {
        assert (!"missing anynode test");
      }
    else if (PFty_subtype (ty, PFty_xs_anyAttribute ()))
      {
  
        /* It is just a generic attribute kind test?
           (e.g. .../attribute) */
        if (PFty_subtype (PFty_xs_anyAttribute (), ty))
  	;
  
        /* Is it a test on attribute kind and local name only? */
        else if (PFty_subtype (PFty_attr (PFqname (PFns_wild,
  						 PFqname_loc (PFty_name
  							      (PFty_defn
  							       (ty)))),
  					PFty_xs_anySimpleType ()), ty))
  	{
  	  assert (!"Is it a test on attribute kind and local name only?");
  	}
        /* Or maybe a test on attribute kind and namespace only? */
        else
  	if (PFty_subtype
  	    (PFty_attr
  	     (PFqname (PFqname_ns (PFty_name (PFty_defn (ty))), NULL),
  	      PFty_xs_anySimpleType ()), ty))
  	{
  	  assert (!"Or maybe a test on attribute kind and namespace only?");
  	}
        /* A test on attribute kind and full QName? */
        else if (PFty_subtype (PFty_attr (PFty_name (PFty_defn (ty)),
  					PFty_xs_anySimpleType ()), ty))
  	{
  	  /* we simply ignore namespace here */
  	  llscj_attr_nsloc (lit_str (""),
  			    lit_str (PFqname_loc
  				     (PFty_name (PFty_defn (ty)))),
  			    crrl1->name, crrl2->name, ret);
  	}
        /*
       * If we couldn't figure out what attribute test we got,
       * give up.
       *
       * NOTE: The surface language actually allows such tests. We
       *       just cannot implement them (yet):
       *
       *    doc("foo")/attribute::attribute(shoeSize, xs:integer)
       */
      else
	PFoops (OOPS_FATAL,
		"SQLgen: Problem with an XPath step: cannot evaluate "
		"node test `%s'", PFty_str (ty));
    }
    else
      {
        PFoops (OOPS_FATAL,
  	      "SQLgen: we couldn't figure out what we test "
  	      "in staircase join");
    }

    ret->sfw = gen_select (p, ret);
    ret->sfw->child[1] = fromlist;

    return ret;
}

static PFsql_alg_ann_t *
doc_access (PFla_op_t * frag, PFla_op_t * p)
{
  PFsql_t *item;

  /* get attribute names of scj */
  PFalg_att_t pa_item = p->sem.doc_access.att;

  /*
   * Determine generic input arguments.
   */
  item = sql_expression (COLMAP (R (p)), pa_item, type_of (p, p->sem.doc_access.att));
  assert (item);

  /* get the correlation name of item */
  sql_correlation_name_t item_crrl;
  item_crrl.name = item->crrlname;

  /* get new correlation name for frag expression */
  sql_correlation_name_t *leg_crrl =
    (sql_correlation_name_t *) PFmalloc (sizeof (sql_correlation_name_t));

  /* check if the alias expression with item_crrl as correlation name
     is marked with frag */
  leg_crrl->name = sql_search_frag (FROM (R (p)), item_crrl);

  sql_correlation_name_t *crrl =
    (leg_crrl->name > 0) ? leg_crrl : sql_correlation_name_new ();

  PFsql_t *fromlist = FROM (R (p));

  /* this new relation we need to get the attributes beside the pre
     value */
  if (leg_crrl->name == 0)
    {
      PFsql_t *fr2 = table_deco (alias (frag->sql_ann->fragment,
					correlation_name (crrl->name)),
				 true);
      fromlist = from_list_add (fromlist, fr2);
    }

  assert (frag->sql_ann->fragment);
  PFsql_alg_ann_t *ret = sql_alg_ann_new ();

  /* copying environment */
  for (unsigned int i = 0; i < PFarray_last (COLMAP (R (p))); i++)
    {
      sql_column_env_t entry = sql_column_env_at (COLMAP (R (p)), i);
      sql_column_env_add (ret->colmap,
			  entry.att, entry.type, entry.expression);
    }
  /* get new correlation name */
//  sql_correlation_name_t *crrl = sql_correlation_name_new ();

  /* adding prop column containing the property we
     are connecting */
  sql_column_env_add (ret->colmap,
                      p->sem.doc_access.res, type_of (p,
                                                      p->sem.doc_access.res),
                      crrl_deco (COLUMN_SPEC (sql_col_value), crrl->name));

  /* copy wheremaps */
  for (unsigned int i = 0; i < PFarray_last (R (p)->sql_ann->wheremap); i++)
    {
      sql_where_env_t entry = sql_where_env_at (R (p)->sql_ann->wheremap, i);
      sql_where_env_add (ret->wheremap, entry.expression);
    }

  /* add constraint to get only the rows we are interested in */
  if (leg_crrl->name == 0)
      sql_where_env_add (ret->wheremap,
                         eq
                         (sql_expression (COLMAP (R (p)),
                                          p->sem.doc_access.att,
                                          type_of (p, p->sem.doc_access.att)),
                          crrl_deco (COLUMN_SPEC (sql_col_pre),
                                     crrl->name)));

  switch (p->sem.doc_access.doc_col)
    {
    case doc_text:
      /* add constraints to get text nodes */
      sql_where_env_add (ret->wheremap,
			 eq
			 (crrl_deco
			  (COLUMN_SPEC (sql_col_kind),
			   crrl->name), lit_int (PF_TEXT)));
      break;
    case doc_atext:
      /* add a constraint to get only the content of attribute nodes */
      sql_where_env_add (ret->wheremap,
			 eq
			 (crrl_deco
			  (COLUMN_SPEC (sql_col_kind),
			   crrl->name), lit_int (ATTR)));
      break;
    default:
      PFoops (OOPS_FATAL,
	      "SQLgen: this kind (%u) is not supported by doc access",
	      p->sem.doc_access.doc_col);
      break;
    }

//  fromlist = from_list_add
//    (fromlist,
//     alias (frag->sql_ann->fragment, correlation_name (crrl->name)));

  ret->sfw = gen_select (p, ret);
  ret->sfw->child[1] = fromlist;

  return ret;
}

static PFsql_t *
collect (PFla_op_t * p)
{
  assert (p);
  if (p->kind == la_empty_frag)
    return select
      (select_list
       (COLUMN_SPEC (sql_col_name),
    	COLUMN_SPEC (sql_col_value),
    	COLUMN_SPEC (sql_col_kind),
    	COLUMN_SPEC (sql_col_level),
    	COLUMN_SPEC (sql_col_size),
    	COLUMN_SPEC (sql_col_pre),),
       fragrelation (), NULL, NULL);

  PFsql_t *ret = NULL;
  if (RL (p)->kind == la_merge_adjacent)
    ret = collect (L (p));
  else if (L (p)->kind == la_empty_frag)
    ret = R (p)->sql_ann->fragment;
  else
    ret = disjunion (collect (L (p)), R (p)->sql_ann->fragment);

  assert (ret);
  return ret;
}




static void
parse (PFla_op_t * n)
{
  /* label the algebra tree to determine optimal code generation */
  /* PFlalg2sql_label (n); */
  /* traverse algebra tree */
  reduce (n, 1);
}

/* Attach node labels in a DAG walk bottom-up */
static void
label (PFla_op_t *p)
{
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFlalg2sql_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        if (!SEEN(L(p))) label (L(p));
        STATE_LABEL(p) = PFlalg2sql_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
    }
    else if (!L(p) && R(p)) {
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFlalg2sql_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    else {
        if (!SEEN(L(p))) label (L(p));
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFlalg2sql_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    SEEN(p) = true;

    assert (STATE_LABEL (p));
}


PFsql_t *
PFlalg2sql (PFla_op_t * n)
{
  sql_stmts = NULL;

  assert (n);

  /* set reference counters in algebra tree nodes */
  inc_refctr (n);
  PFla_dag_reset (n);

  max_pre_frag = fragrelation ();

  label (n);
  PFla_dag_reset (n);

  parse (n);

  return sql_stmts;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
