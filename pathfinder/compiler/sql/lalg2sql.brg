%{

/**
 * @file
 *
 * Transforms the logical algebra tree into a tree that represents
 * SQL statements.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2007 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 * $Id$
 */

/* always include pathfinder first */
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "lalg2sql.h"
#include "alg_dag.h"
#include "mem.h"
#include "oops.h"             /* PFoops() */
#include "subtyping.h"

/**
 * Accessors for the burg pattern matcher
 */
typedef struct PFla_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)     ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)   ((p)->child[0])
#define RIGHT_CHILD(p)  ((p)->child[1])

/* the state, burg determines during the bottom up graph
 * traversal
 */
#define STATE_LABEL(p) ((p)->state_label)

/* the state of the children determined during
   bottom-up labeling is backed up here */
#define CHILD_STATE_LABEL(p,i) ((p)->child_state_label[i])

/* if an error occurs, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start with non-terminal */
%start Query

%term serialize       =  1 /**< serialize algebra expression
                                (Placed on the very top of the tree.) */
%term lit_tbl         =  2 /**< literal table */
%term empty_tbl       =  3 /**< empty literal table */
%term attach          =  4 /**< attach constant column */
%term cross           =  5 /**< cross product (Cartesian product) */
%term eqjoin          =  6 /**< equi-join */
%term semijoin        =  7 /**< semi-join */
%term thetajoin       =  8 /**< theta-join (with possibly multiple
                                predicates) */
%term project         =  9 /**< algebra projection and renaming operator */
%term select_         = 10 /**< selection of rows where column value != 0 */
%term disjunion       = 11 /**< union two relations with same schema */
%term intersect       = 12 /**< intersect two relations with same schema */
%term difference      = 13 /**< difference of two relations w/ same schema */
%term distinct        = 14 /**< duplicate elimination operator */
%term fun_1to1        = 20 /**< generic operator that extends the schema with
                                a new column where each value is determined
                                by the values of a single row (cardinality
                                stays the same) */
%term num_eq          = 25 /**< numeric equal operator */
%term num_gt          = 26 /**< numeric greater-than operator */
%term bool_and        = 28 /**< boolean AND operator */
%term bool_or         = 29 /**< boolean OR operator */
%term bool_not        = 30 /**< boolean NOT operator */
%term to              = 31 /**< op:to operator */
%term avg             = 32 /**< operator for (partitioned) avg of a column */
%term max_            = 33 /**< operator for (partitioned) max of a column */
%term min_            = 34 /**< operator for (partitioned) min of a column */
%term sum             = 35 /**< operator for (partitioned) sum of a column */
%term count           = 36 /**< (partitioned) row counting operator */
%term rownum          = 37 /**< consecutive number generation */
%term rank            = 38 /**< arbitrary but ordered number generation */
%term number          = 39 /**< arbitrary, unordered number generation */
%term type            = 40 /**< selection of rows where a column is of a
                                certain type */
%term type_assert     = 41 /**< restricts the type of a relation */
%term cast            = 42 /**< type cast of an attribute */
%term seqty1          = 43 /**< test for exactly one type occurrence in one
                                iteration (Pathfinder extension) */
%term all             = 44 /**< test if all items in an iteration are true */
%term step            = 49 /**< XPath location step */
%term step_join       = 50 /**< duplicate generating path step */
%term guide_step      = 51 /**< XPath location step
                                (with guide information) */
%term guide_step_join = 52 /**< duplicate generating path step
                                (with guide information) */
%term id              = 53 /**< Operator representing a fn:id node lookup */
%term idref           = 54 /**< Operator representing a fn:idref node
                                lookup */
%term doc_tbl         = 55 /**< document relation (is also a fragment) */
%term doc_access      = 56 /**< document access necessary
                                for pf:string-value */
%term twig            = 60 /**< twig root operator */
%term fcns            = 61 /**< twig constructor sequence */
%term docnode         = 62 /**< document node-constructing operator */
%term element         = 63 /**< element-constructing operator */
%term attribute       = 64 /**< attribute-constructing operator */
%term textnode        = 65 /**< text node-constructing operator */
%term comment         = 66 /**< comment-constructing operator */
%term processi        = 67 /**< processing instruction-constr. operator */
%term content         = 68 /**< constructor content operator (elem|doc) */
%term merge_adjacent  = 69 /**< operator for pf:merge-adjacent-text-nodes
                                builtin function */
%term roots_          = 70 /**< algebraic repres. of the roots of newly
                                created xml nodes (e.g. element());
                                schema: iter | pos | item */
/* all operators below represent xml node fragments with no schema */
%term fragment        = 71 /**< representation of a node fragment */
%term frag_union      = 72 /**< special node type used to form an algebraic
                                union of fragments */
%term empty_frag      = 73 /**< representation of an empty fragment */

%term cond_err        = 80 /**< facility to trigger runtime errors */
%term nil             = 81 /**< end of the list of parameters */
%term trace           = 82 /**< debug operator */
%term trace_msg       = 83 /**< debug operator */
%term trace_map       = 84 /**< debug relation map operator */
%term rec_fix         = 85 /**< operator representing a tail recursion */
%term rec_param       = 86 /**< list of parameters of the recursion */
%term rec_arg         = 87 /**< reference to the arguments of a parameter
                                in the recursion */
%term rec_base        = 88 /**< base of the DAG describing the recursion */

%term proxy           = 96 /**< proxy operator that represents a group
                                of operators */
%term proxy_base      = 97 /**< completes the content of the proxy
                                (a virtual base table) */
%term cross_mvd       = 98 /**< clone column aware cross product */
%term eqjoin_unq      = 99 /**< clone column aware equi-join */
/* builtin support for XQuery functions */
%term string_join     =102 /**< fn:string-join */

%term dummy           =120 /**< dummy operator that does nothing */

%%

Query:  serialize (Frag, Rel)                        =   1 (10);
Query:  serialize (Frag, empty_tbl)                  =   2 (10);

Rel:    lit_tbl                                      =   3 (10);
Rel:    attach (Rel)                                 =   4 (10);

Rel:    cross (Rel, Rel)                             =   5 (10);
Rel:    eqjoin (Rel, Rel)                            =   6 (10);
Rel:    semijoin (Rel, Rel)                          =   7 (10);
Rel:    thetajoin (Rel, Rel)                         =   8 (10);
Rel:    project (Rel)                                =   9 (10);
Rel:    select_ (Rel)                                =  10 (10);

Rel:    disjunion (Rel, Rel)                         =  15 (10);
Rel:    intersect (Rel, Rel)                         =  16 (10);
Rel:    difference (Rel, Rel)                        =  17 (10);
Rel:    distinct (Rel)                               =  18 (10);

Rel:    fun_1to1 (Rel)                               =  20 (10);
Rel:    num_eq (Rel)                                 =  21 (10);
Rel:    num_gt (Rel)                                 =  22 (10);
Rel:    bool_and (Rel)                               =  23 (10);
Rel:    bool_or (Rel)                                =  24 (10);
Rel:    bool_not (Rel)                               =  25 (10);
Rel:    type (Rel)                                   =  26 (10);
Rel:    type_assert (Rel)                            =  27 (10);
Rel:    cast (Rel)                                   =  28 (10);

Rel:    avg (Rel)                                    =  35 (10);
Rel:    max_ (Rel)                                   =  36 (10);
Rel:    min_ (Rel)                                   =  37 (10);
Rel:    sum (Rel)                                    =  38 (10);
Rel:    count (Rel)                                  =  39 (10);
Rel:    disjunion (
            count (Rel),
            attach (difference (
                        Rel,
                        project (count (Rel)))))     =  40  (5);

Rel:    seqty1 (Rel)                                 =  41 (10);
Rel:    all (Rel)                                    =  42 (10);

Rel:    string_join (Rel, Rel)                       =  43 (10);

Rel:    rownum (Rel)                                 =  50 (10);
Rel:    number (Rel)                                 =  51 (10);
Rel:    rank (Rel)                                   =  52 (10);

Rel:    step (Frag, Rel)                             =  55 (10);
Rel:    guide_step (Frag, Rel)                       =  56 (10);
Rel:    step_join (Frag, Rel)                        =  57 (10);
Rel:    guide_step_join (Frag, Rel)                  =  58 (10);

Rel:    doc_access (Frag, Rel)                       =  59 (10);

Rel:    roots_ (Constr)                              =  60 (10);
Frag:   fragment (Constr)                            =  61 (10);
Frag:   frag_union (Frag, Frag)                      =  62 (10);
Frag:   frag_union (empty_frag, Frag)                =  63 (10);
Frag:   empty_frag                                   =  64 (10);

Constr: doc_tbl (Rel)                                =  70 (10);
Constr: twig (Twig)                                  =  71 (10);
Constr: twig (docnode (Rel, fcns (nil, nil)))        =  72 (10);
Constr: twig (element (Rel, fcns (nil, nil)))        =  73 (10);
Constr: twig (attribute (Rel))                       =  74 (10);
Constr: twig (textnode (Rel))                        =  75 (10);
Constr: twig (comment (Rel))                         =  76 (10);
Constr: twig (processi (Rel))                        =  77 (10);
List:   fcns (Twig, List)                            =  78 (10);
List:   fcns (Twig, nil)                             =  79 (10);

Twig:   docnode (Rel, List)                          =  80 (10);
Twig:   docnode (Rel, fcns (nil, nil))               =  81 (10);
Twig:   element (Rel, List)                          =  82 (10);
Twig:   element (Rel, fcns (nil, nil))               =  83 (10);
Twig:   attribute (Rel)                              =  84 (10);
Twig:   textnode (Rel)                               =  85 (10);
Twig:   comment (Rel)                                =  86 (10);
Twig:   processi (Rel)                               =  87 (10);
Twig:   content (Frag, Rel)                          =  88 (10);

Constr: merge_adjacent (Frag, Rel)                   =  89 (10);

Rel:    cond_err (Rel, Rel)                          =  99 (10);

Rel:    trace (Rel, Msg)                             = 100 (10);
Msg:    trace_msg (Rel, Map)                         = 101 (10);
Map:    trace_map (Rel, Map)                         = 102 (10);
Map:    nil                                          = 103 (10);

Rel:    rec_fix (Rec, Rel)                           = 105 (10);
Rel:    rec_base                                     = 106 (10);
Rec:    rec_param (Arg, Rec)                         = 107 (10);
Rec:    nil                                          = 108 (10);
Arg:    rec_arg (Rel, Rel)                           = 109 (10);

Rel:    dummy (Rel)                                  = 110 (10);
Rel:    proxy (Rel)                                  = 111 (10);
Rel:    proxy_base (Rel)                             = 112 (10);
Rel:    eqjoin_unq (Rel, Rel)                        = 113 (10);
Rel:    cross_mvd (Rel, Rel)                         = 114 (10);

%%

#include "sql_mnemonic.h"
#include "properties.h"

#define MAX_KIDS 5

/*
 * Easily access subtree parts.
 */
/* starting from p, make a left step */
#define L(p)      (LEFT_CHILD(p))
/* starting from p, make a right step */
#define R(p)      (RIGHT_CHILD(p))
/* ... and so on */
#define LL(p)     L(L(p))
#define LR(p)     R(L(p))
#define RL(p)     L(R(p))
#define RR(p)     R(R(p))
#define RLR(p)    R(L(R(p)))
#define RLL(p)    L(L(R(p)))
#define RLRL(p)   L(R(L(R(p))))

/** Macro determining if a node was already visited */
#define SEEN(p)   ((p)->bit_dag)

/**
 * We collect the SQL statements during compilation here.
 */
static PFsql_t *sql_stmts = NULL;

/* The execute is used to construct the sequence
 * of `common table expressions'.
 */
#define execute(...) sql_stmts = (sql_stmts == NULL)? \
    common_table_expr( __VA_ARGS__ ):\
    common_table_expr(sql_stmts, __VA_ARGS__)

/**
 * We define the fragment with the maximum pre value here.
 */
static PFsql_t *max_pre_frag = NULL;

/* we "mask out" the flags regarding the generation of attributes,
 * up to now we don't support attributes */
#define TYPE_MASK(t) ((t) & ~(aat_afrag | aat_pfrag))

#define BOUND(p)     ((p)->sql_ann->bound)
#define COLMAP(p)    ((p)->sql_ann->colmap)
#define FROMLIST(p)  ((p)->sql_ann->frommap)
#define WHERELIST(p) ((p)->sql_ann->wheremap)
#define FRAG(p)      ((p)->sql_ann->fragment)
#define CSIZE(p)     ((p)->sql_ann->content_size)
#define TPRE(p)      ((p)->sql_ann->twig_pre)
#define TSIZE(p)     ((p)->sql_ann->twig_size)
#define TLEVEL(p)    ((p)->sql_ann->twig_level)

/* .......... Generic Helper Functions .......... */

/**
 * Returns the type of an attribute.
 */
static PFalg_simple_type_t
type_of_ (const PFla_op_t * n, PFalg_att_t att)
{
    assert (n);

    for (unsigned int i = 0; i < n->schema.count; i++)
        if (n->schema.items[i].name == att)
            return TYPE_MASK (n->schema.items[i].type);

#ifndef NDEBUG
    return 0;
#else
    PFoops (OOPS_FATAL,
            "SQLgen: cannot determine implementation type of "
            "column %s.",
            PFatt_str (att));

    return aat_nat; /* satisfy picky compilers */
#endif
}
#ifndef NDEBUG
#define type_of(node,att) (assert (type_of_((node), (att))), \
                           type_of_((node), (att)))
#else
#define type_of(node,att) type_of_((node), (att))
#endif

/**
 * Construct a literal from a given algebra atom.
 */
static PFsql_t *
literal (PFalg_atom_t atom)
{
    switch (atom.type) {
        case aat_nat:   return lit_int (atom.val.nat_);
        case aat_int:   return lit_int (atom.val.int_);
        case aat_str:   return lit_str (atom.val.str);
        case aat_bln:   return eq (lit_int (atom.val.bln?1:0), lit_int (1));
        case aat_dbl:   return lit_dec (atom.val.dbl);
        case aat_dec:   return lit_dec (atom.val.dec_);
        case aat_qname: return lit_str (PFqname_loc (atom.val.int_));
        default: break;
    }

    PFoops (OOPS_FATAL,
            "SQLgen: a relational algebra type (0x%X) has not "
            "been implemented yet.",
            atom.type);

    return NULL; /* satisfy picky compilers */
}

/**
 * Returns a new table name.
 */
static PFsql_tident_t
new_table_name ()
{
    /* static variable that holds the actual variable-number */
    static unsigned int varno = PF_SQL_RES_TABLE_COUNT;
    return varno++;
}

/**
 * Returns a new alias.
 */
static PFsql_aident_t
new_alias (void)
{
    static unsigned int varno = PF_SQL_RES_ALIAS_COUNT;
    return varno++;
}

/**
 * Returns a special column name
 * (like pre or size, following our encoding scheme).
 */
static PFsql_col_t *
special_col (PFsql_special_t spc)
{
    PFsql_col_t *ret = (PFsql_col_t *) PFmalloc (sizeof (PFsql_col_t));
    ret->spec = spc;
    ret->id   = PF_SQL_COLUMN_SPECIAL;
    return ret;
}

/* creates a special column like the attributes in the XML-document relation */
#define PRE_        column_name (special_col (sql_col_pre))
#define SIZE_       column_name (special_col (sql_col_size))
#define LEVEL_      column_name (special_col (sql_col_level))
#define KIND_       column_name (special_col (sql_col_kind))
#define NAME_       column_name (special_col (sql_col_name))
#define GUIDE_      column_name (special_col (sql_col_guide))
#define VALUE_      column_name (special_col (sql_col_value))
#define TWIG_PRE_   column_name (special_col (sql_col_twig_pre))
#define ITER_       column_name (special_col (sql_col_iter))
#define POS_        column_name (special_col (sql_col_pos))
#define TAG_        column_name (special_col (sql_col_tag))
#define MAX_        column_name (special_col (sql_col_max))

#define PRE(n)      ext_column_name (n, special_col (sql_col_pre))
#define SIZE(n)     ext_column_name (n, special_col (sql_col_size))
#define LEVEL(n)    ext_column_name (n, special_col (sql_col_level))
#define KIND(n)     ext_column_name (n, special_col (sql_col_kind))
#define NAME(n)     ext_column_name (n, special_col (sql_col_name))
#define GUIDE(n)    ext_column_name (n, special_col (sql_col_guide))
#define VALUE(n)    ext_column_name (n, special_col (sql_col_value))
#define TWIG_PRE(n) ext_column_name (n, special_col (sql_col_twig_pre))
#define ITER(n)     ext_column_name (n, special_col (sql_col_iter))
#define POS(n)      ext_column_name (n, special_col (sql_col_pos))
#define MAX(n)      ext_column_name (n, special_col (sql_col_max))

/**
 * Returns a new column name
 * (also storing its logical algebra name and its type).
 */
static PFsql_col_t *
new_col (PFalg_att_t att, PFalg_simple_type_t ty)
{
    static unsigned int varno = PF_SQL_RES_COLUMN_COUNT;
    PFsql_col_t *ret = (PFsql_col_t *) PFmalloc (sizeof (PFsql_col_t));
    ret->att = att;
    ret->ty  = ty;
    ret->id  = varno++;
    return ret;
}

/** creates a column (determining his type from the given att/ty pair) */
#define COLUMN_NAME(att,ty)           (column_name (new_col ((att),(ty))))
#define EXT_COLUMN_NAME(alias,att,ty) (ext_column_name ( \
                                           (alias), new_col ((att),(ty))))



/* .......... Column Environment Helper Functions .......... */

struct sql_column_env_t
{
    PFalg_simple_type_t type;
    PFalg_att_t att;
    PFsql_t *expression;
    PFsql_aident_t step_alias;
};
typedef struct sql_column_env_t sql_column_env_t;

/**
 * Returns a new column environment.
 */
#define col_env_new() (PFarray (sizeof (sql_column_env_t)))

/**
 * Adds a (attribute/type -> expression)
 * mapping to the column-environment.
 */
static void
col_env_add_full (PFarray_t * env, PFalg_att_t att,
                  PFalg_simple_type_t ty, PFsql_t * expr,
                  PFsql_aident_t step_alias)
{
    ty = TYPE_MASK (ty);

    /* we can add only the types specified here */
    assert (ty == aat_nat || ty == aat_int ||
            ty == aat_dbl || ty == aat_dec ||
            ty == aat_str || ty == aat_uA ||
            ty == aat_qname || ty == aat_bln ||
            ty == aat_pre || ty == aat_attr);

    *(sql_column_env_t *) PFarray_add (env) =
        (sql_column_env_t) { .type = ty,
                             .att = att,
                             .expression = expr,
                             .step_alias = step_alias };
}
#define col_env_add(e,a,t,s) col_env_add_full(e,a,t,s,PF_SQL_ALIAS_UNBOUND)

/**
 * Returns an environment item at a specific position
 */
#define col_env_at(env,i) (*(sql_column_env_t *) PFarray_at (env, i))

/**
 * Add a given fromlist @a src to another fromlist @a dest.
 */
static void
col_env_copy (PFarray_t * dest, PFarray_t * src)
{
    /* copy all existing expressions */
    for (unsigned int i = 0; i < PFarray_last (src); i++) {
        sql_column_env_t entry = col_env_at (src, i);
        col_env_add_full (dest,
                          entry.att,
                          entry.type,
                          entry.expression,
                          entry.step_alias);
    }
}

/**
 * Returns the expression associated with a given attribute/type
 * pair. If there doesn't exist an expression, simply return NULL.
 */
static PFsql_t *
col_env_lookup_unsafe (const PFarray_t * env, PFalg_att_t att,
                       PFalg_simple_type_t ty)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        sql_column_env_t entry =
            *(sql_column_env_t *) PFarray_at ((PFarray_t *) env, i);

        if (entry.att == att && TYPE_MASK (entry.type) == TYPE_MASK (ty))
            return entry.expression;
    }
    return NULL;
}

/**
 * Returns the expression associated with a given attribute/type
 * pair. Abort the codegeneration and produce an error message,
 * when there is no expression, for the att/type pair.
 */
static PFsql_t *
col_env_lookup_ (const PFarray_t * env, PFalg_att_t att,
                 PFalg_simple_type_t ty)
{
    ty = TYPE_MASK (ty);
    PFsql_t *expr = col_env_lookup_unsafe (env, att, ty);

    if (expr)
        return expr;

#ifndef NDEBUG
    fprintf (stderr, "looking for att: %s, ty: 0x%X\n", PFatt_str (att), ty);
    fprintf (stderr, "environment looks like:\n");
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        sql_column_env_t entry =
            *(sql_column_env_t *) PFarray_at ((PFarray_t *) env, i);

        fprintf (stderr, "  att: %s, type: 0x%X, sql-op kind: %u\n",
                 PFatt_str (entry.att), entry.type,
                 entry.expression->kind);
    }
#else
    PFoops (OOPS_FATAL,
            "SQLgen: attribute '%s' with type '0x%X' "
            "not found in environment", PFatt_str (att), ty);
#endif
    return NULL; /* satisfy picky compilers */
}
#ifndef NDEBUG
#define col_env_lookup(env,att,ty) (assert (col_env_lookup_(env,att,ty)), \
                                    col_env_lookup_(env,att,ty))
#else
#define col_env_lookup(env,att,ty) col_env_lookup_(env,att,ty)
#endif

static PFsql_aident_t
col_env_lookup_step (const PFarray_t * env, PFalg_att_t att,
                     PFalg_simple_type_t ty)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        sql_column_env_t entry =
            *(sql_column_env_t *) PFarray_at ((PFarray_t *) env, i);

        if (entry.att == att && TYPE_MASK (entry.type) == TYPE_MASK (ty))
            return entry.step_alias;
    }
    return PF_SQL_ALIAS_UNBOUND;
}

/**
 * Transforms an expression into a selectlist statement.
 */
static PFsql_t *
transform_expression (PFsql_t *n, PFsql_t *col)
{
    assert (col->kind == sql_column_name &&
            col->sem.column.name->id != PF_SQL_COLUMN_SPECIAL);

    /* we have a different strategy when our item is boolean */
    if (col->sem.column.name->ty == aat_bln)
        n = case_ (when (n, lit_int (1)), else_ (lit_int (0)));

    if (n->kind == sql_column_name)
        return n;
    else
        return column_assign (n, col);
}

/**
 * Transform a column environment in a column-list
 */
static PFsql_t *
transform_columnlist (PFarray_t *col_env)
{
    PFsql_t * collist = NULL;
    for (unsigned int i = 0; i < PFarray_last (col_env); i++) {
        sql_column_env_t colitem = col_env_at (col_env, i);
        collist = column_list (collist, 
                           column_name (new_col (colitem.att, colitem.type))); 
    }
    return collist;
}

/**
 * Transform a column environment in a select-list
 */
static PFsql_t *
transform_selectlist (PFarray_t *col_env)
{
    PFsql_t * sellist = NULL;
    for (unsigned int i = 0; i < PFarray_last (col_env); i++) {
        sql_column_env_t colitem = col_env_at (col_env, i);
        sellist = select_list (sellist,
                       transform_expression (colitem.expression,
                          column_name (new_col (colitem.att, colitem.type))));
    }
    return sellist;
}

/**
 * Bind every column in the environment list to 
 * a new alias @a ident.
 */
static void
transform_colenv (PFarray_t *col_env, PFsql_aident_t ident)
{
    for (unsigned int i = 0; i < PFarray_last (col_env); i++) {
        sql_column_env_t * colitem =
            (sql_column_env_t *) PFarray_at (col_env, i);
        if (colitem->expression->kind == sql_column_name)
            colitem->expression =
                       ext_column_name (
                              ident,
                              colitem->expression->sem.column.name
                              );
    }
}

/* .......... FROM List Helper Functions .......... */

struct sql_from_list_t
{
    PFsql_t       *table;
    PFsql_aident_t alias;
};
typedef struct sql_from_list_t sql_from_list_t;

/**
 * Returns a new fromlist.
 */
#define from_list_new() (PFarray (sizeof (sql_from_list_t)))

/**
 * Add a (table, alias) pair to the fromlist.
 */
#define from_list_add(fl,t,a) *(sql_from_list_t *) PFarray_add (fl) = \
                                    (sql_from_list_t) { .table = t, .alias = a }

/**
 * Returns a (table, alias) pair at a specific position.
 */
#define from_list_at(fl,i) (*(sql_from_list_t *) PFarray_at (fl, i))

/**
 * Add a given fromlist @a src to another fromlist @a dest.
 */
static void
from_list_copy (PFarray_t *dest, PFarray_t *src)
{
    for (unsigned int i = 0; i < PFarray_last (src); i++) {
        sql_from_list_t from_clause = from_list_at (src, i);
        from_list_add (dest, from_clause.table, from_clause.alias);
    }
}

/**
 * Transform a fromlist into a list of SQL from clauses.
 *
 * (Use this extended variant if you want to patch holes 
 *  (NULL values) with the SQL tree in @a tbl.)
 */
static PFsql_t *
transform_frommap_ext (PFla_op_t *p, PFsql_t *tbl)
{
    PFsql_t *fromlist = NULL;
    sql_from_list_t from_clause;

    assert (PFarray_last (FROMLIST(p)));

    for (int i = PFarray_last (FROMLIST(p)) - 1; i >= 0; i--) {
        from_clause = *(sql_from_list_t *) PFarray_at (FROMLIST(p), i);
        fromlist = from_list (fromlist,
                              alias_bind (
                                  /* check for a NULL value */
                                  from_clause.table
                                  ? from_clause.table : tbl,
                                  alias (from_clause.alias)));
    }

    return fromlist;
}
#define transform_frommap(p) transform_frommap_ext(p,NULL)



/* .......... WHERE List Helper Functions .......... */

/**
 * Returns a new wherelist.
 */
#define where_list_new() (PFarray (sizeof (PFsql_t *)))



/**
 * Add a predicate to the wherelist.
 */
#define where_list_add(wl,e) *(PFsql_t **) PFarray_add (wl) = e

/**
 * Returns a predicate at a specific position.
 */
#define where_list_at(wl,i) (*(PFsql_t **) PFarray_at (wl, i))

/**
 * Add a given fromlist @a src to another fromlist @a dest.
 */
static void
where_list_copy (PFarray_t *dest, PFarray_t *src)
{
    for (unsigned int i = 0; i < PFarray_last (src); i++) {
        PFsql_t *where_clause = where_list_at (src, i);
        where_list_add (dest, where_clause);
    }
}

/**
 * Transform a wherelist into a list of SQL predicates.
 */
static PFsql_t *
transform_wheremap (PFla_op_t *p)
{
    PFsql_t *wherelist = NULL, *where_clause = NULL;

    for (int i = PFarray_last (WHERELIST(p)) - 1; i >= 0; i--) {
        where_clause = *(PFsql_t **) PFarray_at (WHERELIST(p), i);
        wherelist = where_list (wherelist, where_clause);
    }

    return wherelist;
}



/*............ Annotations ...........*/

/**
 * Return a new algebra annotation.
 * @note
 *     Each node of the algebra contains annotations regarding the
 *     SQL-Codegeneration.
 */
static PFsql_alg_ann_t *
sql_alg_ann_new (void)
{
    PFsql_alg_ann_t *ret =
        (PFsql_alg_ann_t *) PFmalloc (sizeof (PFsql_alg_ann_t));

    ret->bound        = false;
    ret->colmap       = col_env_new ();
    ret->frommap      = from_list_new ();
    ret->wheremap     = where_list_new ();
    ret->fragment     = NULL;
    ret->content_size = NULL;

    return ret;
}



/* .......... Alias Substitution Helper Functions .......... */

struct sql_alias_map_t
{
    PFsql_aident_t new;
    PFsql_aident_t old;
};
typedef struct sql_alias_map_t sql_alias_map_t;

/**
 * helper for substitute_aliases.
 * It recursively replaces all old aliases by the new ones.
 */
static void
substitute_aliases_helper (PFsql_t *sqlnode,
                           sql_alias_map_t map[],
                           unsigned int map_count)
{
    for (unsigned int i = 0; i < PFSQL_OP_MAXCHILD && sqlnode->child[i]; i++)
        substitute_aliases_helper (sqlnode->child[i], map, map_count);

    if (sqlnode->kind == sql_column_name &&
        sqlnode->sem.column.alias != PF_SQL_ALIAS_UNBOUND)
        for (unsigned int i = 0; i < map_count; i++)
            if (map[i].old == sqlnode->sem.column.alias) {
                sqlnode->sem.column.alias = map[i].new;
                break;
            }
}

/**
 * substitute_aliases iterates over the from list and creates
 * an alias mapping (old<->new). Then it iterates over colmap,
 * frommap and wheremap and recursively replace all old aliases
 * by the new ones.
 */
static void
substitute_aliases (PFla_op_t * p)
{
    unsigned int count = PFarray_last (FROMLIST(p));
    sql_alias_map_t map[count];
    sql_column_env_t entry;

    /* prepare an alias map with new aliases and
       replace the old aliases in the from list */
    for (unsigned int i = 0; i < count; i++) {
        map[i].new = new_alias ();
        map[i].old = (from_list_at (FROMLIST(p), i)).alias;
        (from_list_at (FROMLIST(p), i)).alias = map[i].new;

        /* Copy the expressions in the fromlist */
        (from_list_at (FROMLIST(p), i)).table
            = duplicate ((from_list_at (FROMLIST(p), i)).table);
    }

    for (unsigned int i = 0; i < PFarray_last (COLMAP(p)); i++) {
        entry = col_env_at (COLMAP(p), i);
        /* Copy the expressions in the column map, ... */
        entry.expression = duplicate (entry.expression);
        /* ... replace all aliases, ... */
        substitute_aliases_helper (entry.expression, map, count);

        /* ... make sure that we replace also the step aliases, ... */
        if (entry.step_alias != PF_SQL_ALIAS_UNBOUND)
            for (unsigned int j = 0; j < count; j++)
                if (map[j].old == entry.step_alias) {
                    entry.step_alias = map[j].new;
                    break;
                }
        /* ... and then replace the binding. */
        *(sql_column_env_t *) PFarray_at ((PFarray_t *) COLMAP(p), i) = entry;
    }

    for (unsigned int i = 0; i < PFarray_last (WHERELIST(p)); i++) {
        /* Copy the wherelist, ... */
        PFsql_t *expr = duplicate (where_list_at (WHERELIST(p), i));
        /* ... replace all aliases, ... */
        substitute_aliases_helper (expr, map, count);
        /* ... and then replace the binding. */
        *(PFsql_t **) PFarray_at ((PFarray_t *) WHERELIST(p), i) = expr;
    }
}



/* .......... Path Step Helper Functions .......... */

static void
step_sibling (PFla_op_t *p, PFsql_aident_t ctx, PFsql_aident_t step,
              PFsql_t *fragment)
{
    PFsql_aident_t par  = new_alias ();
    from_list_add (FROMLIST(p), fragment, par);

    /* parent step */
    /* ctx.pre > par.pre and par.pre + par.size >= ctx.pre */
    where_list_add (WHERELIST(p),
                    between (PRE(ctx), add (PRE(par), lit_int (1)),
                             add(PRE(par), SIZE(par))));
    where_list_add (WHERELIST(p),
                    eq (add (LEVEL(par), lit_int (1)), LEVEL(ctx)));
    /* child step */
    where_list_add (WHERELIST(p),
                    between (PRE(step), add (PRE(par), lit_int (1)),
                             add (PRE(par), SIZE(par))));
    where_list_add (WHERELIST(p),
                    eq (LEVEL(ctx), LEVEL(step)));
}

static void
step_axis (PFla_op_t *p, PFsql_aident_t ctx, PFsql_aident_t step,
           PFalg_axis_t axis, PFsql_t *fragment)
{
    switch (axis) {
        /* ancestor axis */
        case alg_anc:
        /* parent axis */
        case alg_par:
            where_list_add (WHERELIST(p),
                            between (PRE(ctx), add (PRE(step), lit_int (1)),
                                     add (PRE(step), SIZE(step))));
            break;

        /* ancestor-or-self axis */
        case alg_anc_s:
            where_list_add (WHERELIST(p),
                            between (PRE(ctx), PRE(step),
                                     add (PRE(step), SIZE(step))));
            break;

        /* descendant axis */
        case alg_desc:
        /* child axis */
        case alg_chld:
        /* attribute axis */
        case alg_attr:
            where_list_add (WHERELIST(p),
                            between (PRE(step), add (PRE(ctx), lit_int (1)),
                                     add (PRE(ctx), SIZE(ctx))));
            break;

        /* descendant-or-self axis */
        case alg_desc_s:
            where_list_add (WHERELIST(p),
                            between (PRE(step), PRE(ctx),
                                     add (PRE(ctx), SIZE(ctx))));
            break;

        /* following-sibling axis */
        case alg_fol_s:
            step_sibling (p, ctx, step, fragment);
            /* continue with the following axis */

        /* following axis */
        case alg_fol:
            where_list_add (WHERELIST(p),
                            gt (PRE(step), add (PRE(ctx), SIZE(ctx))));
            break;

        /* preceding-sibling axis */
        case alg_prec_s:
            step_sibling (p, ctx, step, fragment);
            /* continue with the preceding axis */

        /* preceding axis */
        case alg_prec:
            where_list_add (WHERELIST(p),
                            gt (PRE(ctx), add (PRE(step), SIZE(step))));
            break;

        /* self axis */
        case alg_self:
            where_list_add (WHERELIST(p),
                            eq (PRE(step), PRE(ctx)));
            break;
    }
}

static void
step_level (PFla_op_t *p, PFsql_aident_t ctx, PFsql_aident_t step,
            PFalg_axis_t axis, int level)
{
    if (level >= 0)
        where_list_add (WHERELIST(p), eq (LEVEL(step), lit_int (level)));
    else
        switch (axis) {
            /* parent axis */
            case alg_par:
                where_list_add (WHERELIST(p),
                                eq (add (LEVEL(step), lit_int (1)),
                                    LEVEL(ctx)));
                break;

            /* attribute axis */
            case alg_attr:
            /* child axis */
            case alg_chld:
                where_list_add (WHERELIST(p),
                                eq (add (LEVEL(ctx), lit_int (1)),
                                    LEVEL(step)));
                break;

            default:
                break;
        }
}

/* encoding for the different node types in out XML scheme */
#define ELEM    1    /* element node */
#define ATTR    2    /* attribute */
#define PF_TEXT 3    /* text */
#define COMM    4    /* comment */
#define PI      5    /* processing instruction */
#define DOC     6    /* document root node */

static void
step_kind (PFla_op_t *p, PFsql_aident_t step, PFty_t ty)
{
    int kind = 0;

    if (PFty_subtype (ty, PFty_doc (PFty_xs_anyNode ())))
        kind = DOC;
    else if (PFty_subtype (ty, PFty_xs_anyElement ()))
        kind = ELEM;
    else if (PFty_subtype (ty, PFty_text ()))
        kind = PF_TEXT;
    else if (PFty_subtype (ty, PFty_comm ()))
        kind = COMM;
    else if (PFty_subtype (ty, PFty_pi (NULL)))
        kind = PI;
    else if (PFty_subtype (ty, PFty_xs_anyAttribute ()))
        kind = ATTR;

    if (kind)
        where_list_add (WHERELIST(p),
                        eq (KIND(step), lit_int (kind)));
}

static void
step_name (PFla_op_t *p, PFsql_aident_t step, PFty_t ty)
{
    PFsql_t *name = NULL;

    if (!PFty_subtype (ty, PFty_xs_anyElement ()) &&
        !PFty_subtype (ty, PFty_xs_anyAttribute ()))
        return;

        /* This is a test for element nodes */

        /* This is just a generic kind test */
        if (PFty_subtype (PFty_xs_anyElement (), ty) ||
            PFty_subtype (PFty_xs_anyAttribute (), ty))
            return;
        /* test on local name only */
        else if (PFty_subtype (
                     PFty_elem (
                         PFqname (
                             PFns_wild,
                             PFqname_loc (PFty_name (PFty_defn (ty)))),
                         PFty_xs_anyType ()),
                     ty) ||
                 PFty_subtype (
                     PFty_attr (
                         PFqname (
                             PFns_wild,
                             PFqname_loc (PFty_name (PFty_defn (ty)))),
                         PFty_xs_anySimpleType ()),
                     ty))
            name = lit_str (PFqname_loc (PFty_name (PFty_defn (ty))));
        /* test on namespace only */
        else if (PFty_subtype (
                     PFty_elem (
                         PFqname (
                             PFqname_ns (PFty_name (PFty_defn (ty))),
                             NULL),
                         PFty_xs_anyType ()),
                     ty) ||
                 PFty_subtype (
                     PFty_attr (
                         PFqname (
                             PFqname_ns (PFty_name (PFty_defn (ty))),
                             NULL),
                         PFty_xs_anySimpleType ()),
                     ty))
            PFoops (OOPS_FATAL, "SQLgen: namespace tests only not supported");
        /* test on full QName */
        else if (PFty_subtype (
                     PFty_elem (
                         PFty_name (PFty_defn (ty)),
                         PFty_xs_anyType ()),
                     ty) ||
                 PFty_subtype (
                     PFty_attr (
                         PFty_name (PFty_defn (ty)),
                         PFty_xs_anySimpleType ()),
                     ty))
            /* we simply ignore the namespace here */
            name = lit_str (PFqname_loc (PFty_name (PFty_defn (ty))));
        else
        /*
         * If we couldn't figure out what name test we got,
         * give up.
         *
         * NOTE: The surface language actually allows such tests. We
         *       just cannot implement them (yet):
         *
         *    doc("foo")/attribute::attribute(shoeSize, xs:integer)
         */
             PFoops (OOPS_FATAL,
                     "SQLgen: Problem with an XPath step: cannot evaluate "
                     "node test `%s'", PFty_str (ty));

    if (name)
        where_list_add (WHERELIST(p), eq (NAME(step), name));
}

static void
step_guide (PFla_op_t *p, PFsql_aident_t step,
            unsigned int count, PFguide_tree_t **guides)
{
    PFsql_t **list = PFmalloc (count * sizeof (PFsql_t *));

    for (unsigned int i = 0; i < count; i++)
        list[i] = lit_int (guides[i]->guide);

    where_list_add (WHERELIST(p),
                    in (GUIDE(step),
                        PFsql_stmt_list_ (count, (const PFsql_t **) list)));
}

static void 
step_guide_join (PFla_op_t *p, PFsql_aident_t step,
                unsigned int count, PFguide_tree_t **guides)
{
    assert (p);

    PFsql_tident_t newtable = new_table_name ();
    PFsql_aident_t newalias = new_alias ();

    PFsql_t **list = PFmalloc (count * sizeof (PFsql_t *));

    for (unsigned int i = 0; i < count; i++)
        list[i] = stmt_list (lit_int (guides[i]->guide));

    /* prepare table to dump */
    execute (comment (""),
             bind (table_def (
                       newtable,
                       column_list (GUIDE_)),
                   values (PFsql_list_list_ (count, (const PFsql_t **) list))));

    /* prepare step node */
    from_list_add (FROMLIST(p), table_name (newtable),
                   newalias);
                   

    where_list_add (WHERELIST(p),
                    eq
                    (
                      GUIDE(step),
                      GUIDE(newalias)
                    ));
}



/* .......... Twig Constructor Helper Functions .......... */

#define construct_simple_twig(p,iter,kind,value,name) \
            construct_twig_generic (p, new_alias(), new_alias(), true, \
                                    NULL, iter, kind, value, name)
#define construct_twig(p,content,new_root,sortkey_list) \
            construct_twig_generic (p, content, new_root, false,       \
                                    sortkey_list, att_iter, 0, NULL, NULL)
/**
 * Construct a twig binding.
 *
 * This function is used in two flavors:
 * - a 'simple' variant that constructs a single node (order does not matter)
 * - a 'normal' variant that uses the collected list of node constructors
 *   and orders them by the order specified in @a sortkey_list
 */
static void
construct_twig_generic (PFla_op_t *p,
                        PFsql_aident_t content,
                        PFsql_aident_t new_root,
                        bool simple,
                        PFsql_t *sortkey_list,
                        PFalg_att_t citer, int kind,
                        PFsql_t *value, PFsql_t *name)
{
    PFsql_tident_t      twig_tbl = new_table_name ();
    PFsql_aident_t      max      = new_alias ();
    PFalg_att_t         iter;
    PFalg_simple_type_t iter_ty;
    PFsql_col_t        *iter_col;
    PFsql_t            *twig;

    assert (p->kind == la_twig);

    iter     = p->sem.iter_item.iter;
    iter_ty  = type_of (p, iter);
    iter_col = new_col (iter, iter_ty);

    if (simple)
        twig = select (select_list (
                           column_assign (
                               col_env_lookup (COLMAP(LL(p)),
                                               citer, type_of (LL(p), citer)),
                               column_name (iter_col)),
                           column_assign (
                               add (MAX(max),
                                    over (rownumber (),
                                          window_clause (NULL, NULL))),
                               PRE_),
                           column_assign (lit_int (0), SIZE_),
                           column_assign (lit_int (0), LEVEL_),
                           column_assign (lit_int (kind), KIND_),
                           column_assign (value, VALUE_),
                           column_assign (name, NAME_)),
                       from_list (
                           alias_bind (select (
                                           column_assign (max (PRE_), MAX_),
                                           from_list (max_pre_frag),
                                           NULL,
                                           NULL),
                                       alias (max)),
                           transform_frommap (LL(p))),
                       transform_wheremap (LL(p)),
                       NULL);
    else
        twig = select (select_list (
                           column_assign (
                               ITER(content),
                               column_name (iter_col)),
                           column_assign (
                               add (MAX(max),
                                    over (rownumber (),
                                          window_clause (
                                              NULL,
                                              order_by (sortkey_list)))),
                               PRE_),
                           SIZE(content),
                           LEVEL(content),
                           KIND(content),
                           VALUE(content),
                           NAME(content)),
                       from_list (
                           alias_bind (select (
                                           column_assign (max (PRE_), MAX_),
                                           from_list (max_pre_frag),
                                           NULL,
                                           NULL),
                                       alias (max)),
                           alias_bind (FRAG(L(p)), alias (content))),
                       NULL,
                       NULL);

    execute (comment ("===================="),
             comment ("= TWIG CONSTRUCTOR ="),
             comment ("===================="),
             bind (table_def (
                       twig_tbl,
                       column_list (
                           column_name (iter_col),
                           PRE_,
                           SIZE_,
                           LEVEL_,
                           KIND_,
                           VALUE_,
                           NAME_)),
                   twig));

    FRAG(p) = table_name (twig_tbl);

    /* store the new maximum pre value */
    max_pre_frag = table_name (twig_tbl);

    /* prepare the result */
    col_env_add (COLMAP(p),
                 iter,
                 iter_ty,
                 EXT_COLUMN_NAME (new_root, iter, iter_ty));

    col_env_add (COLMAP(p),
                 p->sem.iter_item.item,
                 type_of (p, p->sem.iter_item.item),
                 PRE(new_root));

    from_list_add (FROMLIST(p),
                   table_name (twig_tbl),
                   new_root);

    /* mark node p as bound */
    BOUND(p) = true;
}

/**
 * Construct a single node.
 *
 * Depending on the node kind (@a kind) the names (@a name)
 * and values (@a value) differ.
 */
static void
construct_node (PFla_op_t *p, PFalg_att_t iter, int kind,
                PFsql_t *value, PFsql_t *name)
{
    PFalg_simple_type_t iter_ty = type_of (L(p), iter);

    FRAG (p) = select (
                   select_list (
                       column_assign (
                           col_env_lookup (COLMAP(L(p)), iter, iter_ty),
                           ITER_),
                       column_assign (lit_int (TPRE(p)), TWIG_PRE_),
                       column_assign (lit_int (-1), POS_),
                       column_assign (lit_int (-1), PRE_),
                       column_assign (lit_int (TSIZE(p)), SIZE_),
                       column_assign (lit_int (TLEVEL(p)), LEVEL_),
                       column_assign (lit_int (kind), KIND_),
                       column_assign (value, VALUE_),
                       column_assign (name, NAME_)),
                   transform_frommap (L(p)),
                   transform_wheremap (L(p)),
                   NULL);
}



/* .......... Remaining Helper Functions .......... */

/**
 * copy_cols_from_where copies all select, from, and where
 * information from a child operator @a c to a parent
 * operator @a p.
 */
static void
copy_cols_from_where (PFla_op_t *p, PFla_op_t *c)
{
    /* copy the existing environment */
    col_env_copy (COLMAP(p), COLMAP(c)); 
    /* copy the existing frommap */
    from_list_copy (FROMLIST(p), FROMLIST(c));
    /* copy the existing wheremap */
    where_list_copy (WHERELIST(p), WHERELIST(c));
}

/**
 * bind_operator creates a selec-from-where binding
 * for a given operator @a p. The additional boolean
 * flag distinct triggers the generation of the SQL
 * DISTINCT keyword.
 */
static void
bind_operator (PFla_op_t *p, bool distinct)
{
    PFsql_t *selectlist = NULL;
    PFsql_t *columnlist = NULL;
    sql_column_env_t entry;
    PFsql_col_t *colname;

    /* only bind the operator if it is not already bound */
    if (BOUND(p)) return;

    /* create a new table name for binding */
    PFsql_tident_t newtable = new_table_name ();
    /* new correlation name for bounded table */
    PFsql_aident_t newalias = new_alias ();

    /* prepare the selection lists, the column list, and fill in
       the new bindings for the column environment */
    for (unsigned int i = 0; i < PFarray_last (COLMAP(p)); i++) {
        entry = col_env_at (COLMAP(p), i);
        colname = new_col (entry.att, entry.type);

        /* create columnlist for the table name */
        columnlist = column_list (columnlist, column_name (colname));

        /* add the sql operation to the select list */
        selectlist = select_list (
                         selectlist,
                         transform_expression (
                             entry.expression,
                             column_name (colname)));

        /* override expression with columnname */
        entry.expression = ext_column_name (newalias, colname);
        /* reset step alias (as we got rid of the table schema) */
        entry.step_alias = PF_SQL_ALIAS_UNBOUND;

        /* override column map entry */
        *(sql_column_env_t *) PFarray_at (COLMAP(p), i) = entry;
    }

    /* dump the operator binding */
    execute (bind (table_def (newtable, columnlist),
                   PFsql_select (distinct,
                                 selectlist,
                                 transform_frommap (p),
                                 transform_wheremap (p),
                                 NULL)));

    /* clear the from and the where list */
    PFarray_last (FROMLIST(p)) = 0;
    PFarray_last (WHERELIST(p)) = 0;

    /* add the new binding to the from list */
    from_list_add (FROMLIST(p),
                   table_name (newtable),
                   newalias);

    /* mark node p as bound */
    BOUND(p) = true;
}

/**
 * Collect a union of all referenced fragments.
 *
 * worker for collect_fragments.
 */
static void
collect_frag_worker (PFla_op_t * p, PFarray_t *frags)
{
    assert (p);
 
    if (p->kind == la_frag_union) {
        collect_frag_worker (L(p), frags);
        collect_frag_worker (R(p), frags);
    }
    else if (p->kind == la_fragment) {
        PFsql_tident_t name;
        unsigned int   i;
        PFsql_t       *frag;
        assert (FRAG(p) && FRAG(p)->kind == sql_tbl_name);
        
        name = FRAG(p)->sem.tbl.name;
        /* add fragment if we haven't collected it so far */
        for (i = 0; i < PFarray_last (frags); i++) {
            frag = *(PFsql_t **) PFarray_at (frags, 0);
            if (frag->sem.tbl.name == name)
                break;
        }
        if (i == PFarray_last (frags))
            *(PFsql_t **) PFarray_add (frags) = FRAG(p);
    }
}

#define frag_select(f) select (                                             \
                           select_list (PRE_, SIZE_, LEVEL_, KIND_, VALUE_, \
                                        NAME_, NAME_),                      \
                           f, NULL, NULL)

static PFsql_t *
collect_fragments (PFla_op_t * p)
{
    PFarray_t *frags = PFarray (sizeof (PFsql_t *));
    
    collect_frag_worker (p, frags);

    if (PFarray_last (frags)) {
        PFsql_t *res = frag_select (*(PFsql_t **) PFarray_at (frags, 0));
        
        for (unsigned int i = 1; i < PFarray_last (frags); i++)
            res = union_ (res, *(PFsql_t **) PFarray_at (frags, i));
        
        return res;
    }
    else
        return frag_select (table_name (PF_SQL_TABLE_FRAG));
}

static PFsql_t *
cast_ (PFsql_t * expr, PFalg_simple_type_t ty, PFalg_simple_type_t res_ty)
{
    if (ty == res_ty) return expr;
    #define NUM_TYPE(t)    ((t == aat_nat) || \
                            (t == aat_int) || \
                            (t == aat_dec) || \
                            (t == aat_dbl))
    #define CHAR_TYPE(t)   ((t == aat_str) || \
                            (t == aat_uA))
    #define NUM_NOTEXPR(t) ((t == aat_int))

    /* if we cast a numeric type to varchar we have to
       first cast it to CHAR and then to varchar */
    if (NUM_TYPE (ty) && CHAR_TYPE (res_ty))
        expr = cast (expr, type (aat_charseq));
    /* if we cast a string to a less expressive type
       like numeric, we have to first cast it to DECIMAL
       and then to the less expressive type */
    else if (CHAR_TYPE (ty) && NUM_NOTEXPR (res_ty))
        expr = cast (expr, type (aat_dbl));

    return cast (expr, type (res_ty)); 
}



/**
 * Reduce function. This is the core of this source file, containing
 * the actions that should be executed whenever a burg-pattern matches.
 */
static void
reduce (PFla_op_t * p, int goalnt)
{
    int        rule;            /* rule number that matches this node */
    short     *nts;
    PFla_op_t *kids[MAX_KIDS];  /* leaf node of this rule */
    bool       bind     = false;
    bool       distinct = false;

    /* guard against too deep recursion */
    PFrecursion_fence ();

    if (SEEN(p)) {
        substitute_aliases (p);
        return;
    } else
        SEEN(p) = true;

    /* determine rule that matches for this non-terminal */
    rule = PFlalg2sql_rule (STATE_LABEL(p), goalnt);

    /* error if a rule with value zero is determined */
    assert (rule);

    /* initializing the kids vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /* get information for dag-traversal */
    nts = PFlalg2sql_nts[rule];
    PFlalg2sql_kids (p, rule, kids);

    switch (rule) {
        /* Rel:    string_join (Rel, Rel) */
        case 43:
        /* Rel:    cond_err (Rel, Rel) */
        case 99:
            /* top-down translation */
            break;

        default:
            /* bottom-up translation */
            for (unsigned short i = 0; i < PFLA_OP_MAXCHILD && nts[i]; i++)
                reduce (kids[i], nts[i]);
            break;
    }

    switch (rule) {
        /* Query:  serialize (Frag, Rel) */
        case 1:
        {
            PFsql_t *colname;

            /* We conflate the schema information needed by the
             * externalized serializer with the final query,
             * that computes the result of the XQuery-Statement
             */
            PFsql_t *clmnlist = NULL, *selectlist = NULL;

            /* construct schema information for serializer */
            PFsql_t *ser_info =
                ser_info_item (
                    ser_comment (
                        "END SCHEMA INFORMATION ** DO NOT EDIT THESE LINES"),
                    nil ());

            assert (PFarray_last (COLMAP(R(p))));

            /* fill in the SQL code for the serialization info,
               the column name and the select list */

            /* first collect the position information ... */
            colname = COLUMN_NAME (att_pos, aat_nat);
            assert (monomorphic (type_of (p, p->sem.serialize.pos)));

            ser_info = ser_info_item (
                           ser_map (ser_res (), colname),
                           ser_info);

            /* align column name and selection list */
            clmnlist = column_list (clmnlist, colname);

            /* add the sql operation to the select list */
            selectlist = select_list (
                             selectlist,
                             transform_expression (
                                 col_env_lookup (
                                     COLMAP(R(p)),
                                     p->sem.serialize.pos,
                                     type_of (p, p->sem.serialize.pos)),
                                 colname));

            /* ... and then the item information */
            for (unsigned int i = 0; i < PFarray_last (COLMAP(R(p))); i++) {
                sql_column_env_t entry = col_env_at (COLMAP(R(p)), i);
                if (entry.att == p->sem.serialize.item) {
                    colname = COLUMN_NAME (att_item, entry.type);

                    ser_info = ser_info_item (
                                   ser_map (ser_res (), colname),
                                   ser_info);

                    /* align column name and selection list */
                    clmnlist = column_list (clmnlist, colname);

                    /* add the sql operation to the select list */
                    selectlist = select_list (
                                     selectlist,
                                     transform_expression (
                                         entry.expression,
                                         colname));
                }
            }

            /* create a special result relation */
            PFsql_t *result = table_def (PF_SQL_TABLE_RESULT, clmnlist);

            /* construct schema information for serialization */
            ser_info =
                ser_info_item (
                    ser_comment (
                        "START SCHEMA INFORMATION ** DO NOT EDIT THESE LINES"),
                ser_info_item (
                    ser_map (ser_doc (), table_name (PF_SQL_TABLE_DOC)),
                ser_info_item (
                    ser_map (ser_doc (), PRE_),
                ser_info_item (
                    ser_map (ser_doc (), SIZE_),
                ser_info_item (
                    ser_map (ser_doc (), LEVEL_),
                ser_info_item (
                    ser_map (ser_doc (), KIND_),
                ser_info_item (
                    ser_map (ser_doc (), VALUE_),
                ser_info_item (
                    ser_map (ser_doc (), NAME_),
                ser_info_item (
                    ser_map (ser_doc (), TAG_),
                ser_info_item (
                    ser_map (ser_res (), result),
                    ser_info))))))))));

            /* the result relation is the same query as in the right underlying node.
             * We only get rid of the attributes that are different to those
             * referenced by the serialize semantics.
             * All what we have to do is to copy everything from the right child.
             */
            execute (comment ("===================="),
                     comment ("= RESULT RELATIONS ="),
                     comment ("===================="),
                     bind (result,
                           select (selectlist,
                                   transform_frommap (R(p)),
                                   transform_wheremap (R(p)),
                                   NULL)));

            /* the reason why we need those special relations 'document' and
             * 'result' is that the externalized serializer expects those
             * special relation names to construct a query
             */
            execute (bind (table_def (PF_SQL_TABLE_DOC,
                                      column_list (
                                          PRE_,
                                          SIZE_,
                                          LEVEL_,
                                          KIND_,
                                          VALUE_,
                                          TAG_,
                                          NAME_)),
                           collect_fragments (L(p))));

            /* the final query consists of the schema information needed
             * by the serializer and the with clause conflating all queries
             * translated to this point.
             */
            sql_stmts = root (ser_info, with (sql_stmts));
        }   break;

        /* Query:  serialize (Frag, empty_tbl) */
        case 2:
            /* FIXME: implementation is missting */
            assert (!"missing");
            break;

        /* Rel:    lit_tbl */
        case 3:
            if (p->sem.lit_tbl.count == 1) {
                for (unsigned int col = 0; col < p->schema.count; col++)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & TYPE_MASK (p->schema.items[col].type)) {
                            col_env_add (
                                COLMAP(p),
                                p->schema.items[col].name,
                                t,
                                (t == p->sem.lit_tbl
                                            .tuples[0]
                                            .atoms[col].type)
                                ? literal (p->sem.lit_tbl.tuples[0]
                                                         .atoms[col])
                                : cast (null (), type (t)));
                        }

                from_list_add (FROMLIST(p),
                               schema_table_name (
                                   "sysibm",
                                   table_name (PF_SQL_TABLE_SYSDUMMY1)),
                               new_alias ());
            } else {
                /* literal table has more than one row */
                PFsql_tident_t      newtable = new_table_name ();
                PFsql_aident_t      newalias = new_alias ();

                PFsql_t *valuesquery = NULL;
                PFsql_t **list = NULL;
                PFsql_t **l_list = NULL;
                PFsql_t *columnlist = NULL;

                unsigned int ccount = 0,
                             rcount = p->sem.lit_tbl.count;
                unsigned int colcount = 0;
                unsigned int col = 0;

                /* calculate the size of the list and additionally
                 * prepare the column list and even the column
                 * environment. */
                for (unsigned int col = 0; col < p->schema.count; col++)
                     for (PFalg_simple_type_t t = 1; t; t <<= 1)
                          if (t & TYPE_MASK (p->schema.items[col].type)) {
                               /* found another literal */
                               ccount ++;
                               columnlist = column_list (columnlist,
                                                column_name (new_col (
                                                     p->schema.items[col]
                                                              .name, t)));
                               col_env_add (COLMAP (p),
                                            p->schema.items[col].name,
                                            t,
                                            ext_column_name (newalias,
                                                new_col (p->schema.items[col]
                                                            .name, t)));
                          }

                /* prepare the fromlist */
                from_list_add (FROMLIST(p),
                               table_name (newtable),
                               newalias);

                /* initialize the list */
                list  = PFmalloc (ccount * sizeof (PFsql_t *));
                l_list = PFmalloc (rcount * sizeof (PFsql_t *));

                /* run over all columns */
                for (unsigned int row = 0; row < p->sem.lit_tbl.count; row++) {
                    colcount = 0;
                    for (col = 0; col < p->schema.count; col++)
                        for (PFalg_simple_type_t t = 1; t; t <<= 1)
                            if (t & TYPE_MASK (p->schema.items[col].type)) {
                                /* found another literal */
                                list[colcount] = (t == p->sem.lit_tbl.tuples[row]
                                                      .atoms[col].type) ?
                                          literal (p->sem.lit_tbl.tuples[row]
                                                                 .atoms[col])
                                          : cast (null (), type (t));

                                /* increment the countvariable */
                                colcount++;
                            }

                    /* generate the list and add it to our list of lists */
                    l_list[row] = PFsql_stmt_list_ (ccount, (const PFsql_t **) list); 
                }

                valuesquery = values (PFsql_list_list_(rcount, 
                                             (const PFsql_t **) l_list)); 

                execute (comment ("Binding due to multi value literal table"),
                         bind (table_def (
                                   newtable,
                                   columnlist),
                                   valuesquery));

                BOUND(p) = true;
            }
                   
            break;

        /* Rel:    attach (Rel) */
        case 4:
            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));

            /* add expression for attach to the column environment */
            col_env_add (COLMAP(p),
                         p->sem.attach.res,
                         p->sem.attach.value.type,
                         literal (p->sem.attach.value));
            break;

        /* Rel:    cross (Rel, Rel) */
        case 5:
        /* Rel:    eqjoin (Rel, Rel) */
        case 6:
        /* Rel:    thetajoin (Rel, Rel) */
        case 8:
            /* copy all existing column, from, and where lists
               of the left child */
            copy_cols_from_where (p, L(p));

            /* copy all existing expression from right child */
            for (unsigned int i = 0; i < PFarray_last (COLMAP(R(p))); i++) {
                sql_column_env_t entry = col_env_at (COLMAP(R(p)), i);

                /* if the att/type value is just in the environment
                 * throw an error, because the schema of the left and
                 * right child should be disjoint.
                 */
                if (!col_env_lookup_unsafe (COLMAP(p), entry.att, entry.type))
                    col_env_add_full (COLMAP(p),
                                      entry.att,
                                      entry.type,
                                      entry.expression,
                                      entry.step_alias);
                else
                    PFoops (OOPS_FATAL,
                            "SQLgen: The join tables contains equal"
                            " attribute/type mappings");
            }

            /* do not copy singleton relation */
            {
                PFsql_t *tbl = from_list_at (FROMLIST(R(p)), 0).table;
                if (!(PFarray_last (FROMLIST(R(p))) == 1 &&
                      tbl->kind == sql_schema_tbl_name &&
                      L(tbl)->kind == sql_tbl_name &&
                      !strcmp (tbl->sem.schema.str, "sysibm") &&
                      L(tbl)->sem.tbl.name == PF_SQL_TABLE_SYSDUMMY1))
                    /* merge the fromlist of the left and right child */
                    from_list_copy (FROMLIST(p), FROMLIST(R(p)));
            }

            /* merge the wherelist of the left and right child */
            where_list_copy (WHERELIST(p), WHERELIST(R(p)));

            /* join predicate for the equi-join operator */
            if (p->kind == la_eqjoin) {
                PFalg_simple_type_t l_ty, r_ty;

                l_ty = type_of (L(p), p->sem.eqjoin.att1);
                r_ty = type_of (R(p), p->sem.eqjoin.att2);

                assert (l_ty == r_ty && monomorphic (l_ty));

                /* add the constraint that comes from the equijoin semantics */
                where_list_add (WHERELIST(p),
                                eq (col_env_lookup (
                                        COLMAP(L(p)),
                                        p->sem.eqjoin.att1,
                                        l_ty),
                                    col_env_lookup (
                                        COLMAP(R(p)),
                                        p->sem.eqjoin.att2,
                                        r_ty)));
            }
            /* join predicates for the theta-join operator */
            else if (p->kind == la_thetajoin) {
                PFalg_att_t left, right;
                PFalg_simple_type_t l_ty, r_ty;
                PFsql_t *l_expr, *r_expr;
                PFsql_t *cond;

                /* iterate over all predicates and add them to the wherelist */
                for (unsigned int i = 0; i < p->sem.thetajoin.count; i++) {
                    left   = p->sem.thetajoin.pred[i].left;
                    right  = p->sem.thetajoin.pred[i].right;
                    l_ty   = type_of (L(p), left);
                    r_ty   = type_of (R(p), right);

                    assert (l_ty == r_ty && monomorphic (l_ty));

                    l_expr = col_env_lookup (COLMAP(L(p)), left, l_ty);
                    r_expr = col_env_lookup (COLMAP(R(p)), right, r_ty);

                    switch (p->sem.thetajoin.pred[i].comp) {
                        case alg_comp_eq: cond = eq (l_expr, r_expr); break;
                        case alg_comp_gt: cond = gt (l_expr, r_expr); break;
                        case alg_comp_ge: cond = gteq (l_expr, r_expr); break;
                        case alg_comp_lt: cond = gt (r_expr, l_expr); break;
                        case alg_comp_le: cond = gteq (r_expr, l_expr); break;
                        case alg_comp_ne:
                            cond = not_ (eq (l_expr, r_expr));
                            break;

                        default:
                            PFoops (OOPS_FATAL,
                                    "SQLgen: Cannot determine which "
                                    "comparison operator to use");
                            break;
                    }

                    where_list_add (WHERELIST(p), cond);
                }
            }
            break;

        /* Rel:    semijoin (Rel, Rel) */
        case 7:
        {
            PFalg_att_t         att1 = p->sem.eqjoin.att1,
                                att2 = p->sem.eqjoin.att2;
            PFalg_simple_type_t ty   = type_of (L(p), att1);
            PFsql_alg_ann_t    *right;

            assert (type_of (R(p), att2) == ty);

            /* for the semijoin we only need the attributes of
             * the left relation */
            /* copy all existing column, from, and where lists
               of the left child */
            copy_cols_from_where (p, L(p));

            /* If we need to ensure the correct cardinality
               we first need to bind the right argument. */
            if (!PFprop_set (p->prop) &&
                !(PFprop_key_left (p->prop, att1) &&
                  PFprop_key_right (p->prop, att2))) {
                PFsql_t            *expr     = col_env_lookup (
                                                   COLMAP(R(p)), att2, ty);
                PFsql_col_t        *colname  = new_col (att2, ty);
                PFsql_tident_t      newtable = new_table_name ();
                PFsql_aident_t      newalias = new_alias ();

                assert (monomorphic(ty));

                /* bind the right side and ensure the distinct
                   is evaluated on the join attribute only */
                execute (comment ("binding due to semijoin"),
                         bind (table_def (
                                   newtable,
                                   column_list (
                                       column_name (colname))),
                               select_distinct (
                                   select_list (
                                       column_assign (
                                           expr,
                                           column_name (colname))),
                                   transform_frommap (R(p)),
                                   transform_wheremap (R(p)), 
                                   NULL)));

                /* prepare a new sql annotation
                   for the rest of the translation */
                right = sql_alg_ann_new ();

                from_list_add (right->frommap,
                               table_name (newtable),
                               newalias);

                col_env_add (right->colmap,
                             att2,
                             ty,
                             ext_column_name (newalias, colname));
            }
            else
                right = R(p)->sql_ann;

            /* merge the fromlist of the left and right child */
            from_list_copy (FROMLIST(p), right->frommap);
            /* merge the wherelist of the left and right child */
            where_list_copy (WHERELIST(p), right->wheremap);

            /* add the constraint coming from semijoin */
            where_list_add (WHERELIST(p),
                            eq (col_env_lookup (COLMAP(L(p)), att1, ty),
                                col_env_lookup (right->colmap, att2, ty)));
        }   break;

        /* Rel:    project (Rel) */
        case 9:
        {
            sql_column_env_t entry;

            /* copy the column map and update the column names
               for all columns in the projection list */
            for (unsigned int i = 0; i < p->sem.proj.count; i++)
                for (unsigned int j = 0; j < PFarray_last (COLMAP(L(p))); j++) {
                    entry = col_env_at (COLMAP(L(p)), j);
                    if (p->sem.proj.items[i].old == entry.att)
                        col_env_add_full (COLMAP(p),
                                          p->sem.proj.items[i].new,
                                          entry.type,
                                          entry.expression,
                                          entry.step_alias);
                }

            /* copy fromlist */
            from_list_copy (FROMLIST(p), FROMLIST(L(p)));
            /* copy wherelist */

            where_list_copy (WHERELIST(p), WHERELIST(L(p)));
        }   break;

        /* Rel:    select_ (Rel) */
        case 10:
        {
            PFsql_t *sqlnode;

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));

            assert (type_of (p, p->sem.select.att) == aat_bln);

            sqlnode = col_env_lookup (COLMAP(L(p)),
                                      p->sem.select.att,
                                      aat_bln);

            if (sqlnode->kind == sql_column_name)
                /* we introduced a case expression before that produces
                   1 for all true values ... */
                where_list_add (WHERELIST(p), eq (sqlnode, lit_int (1)));
            else
                /* otherwise we already have a comparison in our hands
                   and use it */
                where_list_add (WHERELIST(p), sqlnode);

        }   break;

        /* Rel:    disjunion (Rel, Rel) */
        case 15:
        /* Rel:    difference (Rel, Rel) */
        case 17:
        {
            PFsql_t * (*op) (const PFsql_t *, const PFsql_t *);
            PFsql_t *selectlist1 = NULL;
            PFsql_t *selectlist2 = NULL;
            PFsql_t *columnlist  = NULL;
            PFalg_att_t att;
            PFalg_simple_type_t ty, t;
            PFsql_col_t *colname;

            /* create a new table name for binding */
            PFsql_tident_t newtable = new_table_name ();
            /* new correlation name for bounded table */
            PFsql_aident_t newalias = new_alias ();

            /* start a new from list as @a newtable will be bound */
            from_list_add (FROMLIST(p),
                           table_name (newtable),
                           newalias);

            /* prepare the selection lists, the column list, and fill in
               the new bindings for the column environment */
            for (unsigned int i = 0; i < p->schema.count; i++) {
                att = p->schema.items[i].name;
                ty  = p->schema.items[i].type;
                for (t = 1; t; t <<= 1)
                    if (t & TYPE_MASK (ty)) {
                        colname = new_col (att, t);

                        /* create columnlist for the table name */
                        columnlist = column_list (columnlist,
                                                  column_name (colname));

                        col_env_add (COLMAP(p),
                                     att,
                                     t,
                                     ext_column_name (newalias, colname));

                        /* Type t is in the result relation.
                           See if it is also in the left operand.  */
                        if (!(t & type_of (L(p), att)))
                            selectlist1 = select_list (
                                              selectlist1,
                                              column_assign (
                                                  cast (null (), type (t)),
                                                  column_name (colname)));
                        else
                            selectlist1 = select_list (
                                              selectlist1,
                                              transform_expression (
                                                  col_env_lookup (
                                                      COLMAP(L(p)), att, t),
                                                  column_name (colname)));

                        /* Type t is in the result relation.
                           See if it is also in the left operand. */
                        if (!(t & type_of (R(p), att)))
                            selectlist2 = select_list (
                                              selectlist2,
                                              column_assign (
                                                  cast (null (), type (t)),
                                                  column_name (colname)));
                        else
                            selectlist2 = select_list (
                                              selectlist2,
                                              transform_expression (
                                                  col_env_lookup (
                                                      COLMAP(R(p)), att, t),
                                                  column_name (colname)));
                    }
            }

            if (p->kind == la_disjunion)
                op = PFsql_union;
            else
                op = PFsql_difference;

            /* dump the operator binding */
            execute (comment ("binding due to set operation"),
                     bind (table_def (newtable, columnlist),
                           op (select (selectlist1,
                                       transform_frommap (L(p)),
                                       transform_wheremap (L(p)),
                                       NULL),
                               select (selectlist2,
                                       transform_frommap (R(p)),
                                       transform_wheremap (R(p)),
                                       NULL))));

            /* mark node p as bound */
            BOUND(p) = true;
        }   break;

        /* Rel:    intersect (Rel, Rel) */
        case 16:
            /* FIXME: implementation is missing */
            assert (!"missing");
            break;

        /* Rel:    distinct (Rel) */
        case 18:
            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));

            distinct = true;
            bind = true;
            execute (comment ("binding due to duplicate elimination"));
            break;

        /* Rel:    fun_1to1 (Rel) */
        case 20:
        {
            unsigned int count = p->sem.fun_1to1.refs.count;
            PFalg_att_t att[count];
            PFalg_simple_type_t ty[count];
            PFsql_t *expr[count];
            PFalg_att_t res_att = p->sem.fun_1to1.res;
            PFalg_simple_type_t res_ty = type_of (p, res_att);
            PFsql_t *res_expr = NULL;

            for (unsigned int i = 0; i < count; i++) {
                att[i]  = p->sem.fun_1to1.refs.atts[i];
                ty[i]   = type_of (p, att[i]);
                expr[i] = col_env_lookup (COLMAP(L(p)), att[i], ty[i]);
            }

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));

            switch (p->sem.fun_1to1.kind) {
                case alg_fun_num_add:
                    res_expr = add (expr[0], expr[1]); break;
                case alg_fun_num_subtract:
                    res_expr = sub (expr[0], expr[1]); break;
                case alg_fun_num_multiply:
                    res_expr = mul (expr[0], expr[1]); break;
                case alg_fun_num_divide:
                    res_expr = div (expr[0], expr[1]); break;
                case alg_fun_fn_contains:
                    /* FIXME: this only works with constant expr[1] */
                    res_expr = like (expr[0], expr[1]); break;
                /**< fn:ceiling */
                case alg_fun_fn_ceiling:
                    res_expr = ceil (expr[0]); break;
                /**< fn:floor */
                case alg_fun_fn_floor:
                    res_expr = floor (expr[0]); break;
                /**< arithmetic modulo operator */
                case alg_fun_num_modulo:
                    res_expr = modulo (expr[0], expr[1]); break;
                /**< fn:abs */
                case alg_fun_fn_abs:
                    res_expr = abs (expr[0]); break;
                /**< fn:concat */
                case alg_fun_fn_concat:
                    /* the algebra ensures that the expressions are strings */
                    res_expr = concat (expr[0], expr[1]); break;    
                /**< fn:number */
                case alg_fun_fn_number:
                    res_expr = cast_ (expr[0], ty[0], aat_dbl); break;
                /**< fn:round */
                case alg_fun_fn_round:
                    /* FIXME: implementation is missing */

                    assert (!"missing");
                    break;
            }
            col_env_add (COLMAP(p), res_att, res_ty, res_expr);

        }   break;
        /* Rel:    num_eq (Rel) */
        case 21:
        /* Rel:    num_gt (Rel) */
        case 22:
        {
            PFsql_t * (*op) (const PFsql_t *, const PFsql_t *);

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));

            if (p->kind == la_num_eq)
                op = PFsql_eq;
            else
                op = PFsql_gt;

            /* add the new column to the environment */
            col_env_add (COLMAP(p),
                         p->sem.binary.res,
                         type_of (p, p->sem.binary.res),
                         op (col_env_lookup (COLMAP(p),
                                             p->sem.binary.att1,
                                             type_of (p, p->sem.binary.att1)),
                             col_env_lookup (COLMAP(p),
                                             p->sem.binary.att2,
                                             type_of (p, p->sem.binary.att2))));
        }   break;

        /* Rel:    bool_and (Rel) */
        case 23:
            /* FIXME: implementation is missing */
            assert (!"missing");
            break;

        /* Rel:    bool_or (Rel) */
        case 24:
            /* FIXME: implementation is missing */
            assert (!"missing");
            break;

        /* Rel:    bool_not (Rel) */
        case 25:
        {
            PFsql_t *sqlnode;

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));

            sqlnode = col_env_lookup (COLMAP(p), p->sem.unary.att, aat_bln);

            if (sqlnode->kind == sql_column_name)
                sqlnode = eq (sqlnode, lit_int (1));

            /* add the new column to the environment */
            col_env_add (COLMAP(p),
                         p->sem.unary.res,
                         aat_bln,
                         not_ (sqlnode));
        }   break;

        /* Rel:    type (Rel) */
        case 26:
            /* FIXME: implementation is missing */
            assert (!"missing");
            break;

        /* Rel:    type_assert (Rel) */
        case 27:
            /* FIXME: implementation is missing */
            assert (!"missing");
            break;

        /* Rel:    cast (Rel) */
        case 28:
        {
            PFalg_att_t att = p->sem.type.att;
            PFalg_simple_type_t ty = TYPE_MASK (type_of (p, att));
            PFalg_att_t res_att = p->sem.type.res;
            PFalg_simple_type_t res_ty = p->sem.type.ty;
            PFsql_t *expr;


            /* copy all existing column, from, and where lists */
            if (monomorphic (ty)) {
                copy_cols_from_where (p, L(p));

                expr = col_env_lookup (COLMAP(L(p)), att, ty);

                col_env_add (COLMAP(p), res_att, res_ty,
                             cast_ (expr, ty, res_ty));
            }
            else {
                /* if the type is polymorphic we have to dump
                 * the query immediatly */
                PFsql_t * selectlist,
                        * columnlist;

                /* create a new table name for binding */
                PFsql_tident_t newtable = new_table_name ();
                /* new correlation name for bounded table */
                PFsql_aident_t newalias = new_alias ();

                PFsql_col_t *res_col = new_col (res_att, res_ty);

                PFsql_t * query = NULL;

                /* prepare columnlist and selectlist,
                 * be careful that both are aligned */
                columnlist = transform_columnlist (COLMAP(L(p)));
                selectlist = transform_selectlist (COLMAP(L(p)));

                /* we can add the resulting attribute already
                 * here  to columnlist and environment. */
                columnlist = column_list (columnlist,
                                      column_name (res_col));

                col_env_copy (COLMAP(p), COLMAP(L(p)));
                /* bind every column to a new alias */
                transform_colenv (COLMAP(p), newalias);
                col_env_add (COLMAP(p), res_att, res_ty,
                             ext_column_name (newalias, res_col));

                /* prepare fromlist */
                from_list_add (FROMLIST(p), table_name(newtable), newalias);
                
                /* run over the possible types */
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & ty) {
                         expr = col_env_lookup (COLMAP(L(p)), att, t);

                         /* prepare statement */
                         PFsql_t * temp = 
                            select (
                                select_list (selectlist,
                                    transform_expression (cast_ (expr, t, res_ty),
                                      column_name (res_col))),
                                transform_frommap (L(p)),
                                where_list (transform_wheremap (L(p)),
                                             is_not (expr, null ())),
                                NULL);

                         query = (query)?union_(query,temp):temp; 
                    }

                execute (comment ("bind due to polymorphic cast"),
                         bind (table_def (newtable, columnlist),
                               query));

                BOUND(p) = true;
            }
        }   break;

        /* Rel:    avg (Rel) */
        case 35:
        /* Rel:    max_ (Rel) */
        case 36:
        /* Rel:    min_ (Rel) */
        case 37:
        /* Rel:    sum (Rel) */
        case 38:
        /* Rel:    count (Rel) */
        case 39:
        {
            PFalg_att_t att = p->sem.aggr.att,
                        part = p->sem.aggr.part,
                        res_att = p->sem.aggr.res;
            PFalg_simple_type_t ty,
                                part_ty,
                                res_ty = type_of (p, res_att);
            PFsql_t *expr = NULL,
                    *part_expr;
            PFsql_col_t *part_col,
                        *res_col = new_col (res_att, res_ty);

            PFsql_t *selectlist = NULL;
            PFsql_t *columnlist = NULL;
            PFsql_t *groupbylist = NULL;
            /* create a new table name for binding */
            PFsql_tident_t newtable = new_table_name ();
            /* new correlation name for bounded table */
            PFsql_aident_t newalias = new_alias ();

            /* start a new from list as @a newtable will be bound */
            from_list_add (FROMLIST(p),
                           table_name (newtable),
                           newalias);

            if (att) /* cope with missing att column in case of count */ {
                ty = type_of (p, att);
                expr = col_env_lookup (COLMAP(L(p)), att, ty);
            }

            /* add the partition criterion to all lists and environments */
            if (part) {
                part_ty = type_of (p, part);
                part_col = new_col (part, part_ty);
                part_expr = col_env_lookup (COLMAP(L(p)), part, part_ty);

                col_env_add (COLMAP(p), part, part_ty,
                             ext_column_name (newalias, part_col));

                /* create columnlist for the table name */
                columnlist = column_list (columnlist,
                                          column_name (part_col));

                /* create selectlist for the table name */
                selectlist = select_list (selectlist,
                                          transform_expression (
                                              part_expr,
                                              column_name (part_col)));

                groupbylist = column_list (groupbylist, part_expr);
            }

            /* generate the aggregation */
            switch (p->kind) {
                case la_avg:   expr = avg (expr); break;
                case la_max:   expr = max (expr); break;
                case la_min:   expr = min (expr); break;
                case la_sum:   expr = sum (expr); break;
                case la_count: expr = count (star ()); break;
                default: assert (0); break;
            }

            col_env_add (COLMAP(p), res_att, res_ty,
                         ext_column_name (newalias, res_col));

            columnlist = column_list (columnlist, column_name (res_col));

            /* add the aggregation to the selection list */
            selectlist = select_list (selectlist,
                                      transform_expression (
                                          expr,
                                          column_name (res_col)));

            /* dump the operator binding */
            execute (comment ("binding due to aggregate"),
                     bind (table_def (newtable, columnlist),
                           select (selectlist,
                                   transform_frommap (L(p)),
                                   transform_wheremap (L(p)),
                                   groupbylist)));

            /* mark node p as bound */
            BOUND(p) = true;
        }   break;

        /* Rel:    disjunion (
                       count (Rel),
                       attach (difference (
                                   Rel,
                                   project (count (Rel))))) */
        case 40:
            /**
             * ensure the following pattern:
             *
             *     union
             *     /   \
             *    /     \
             *   |     attach
             *   |       |
             *   |     diff
             *   |     /  \
             *   |   Rel   \
             *   |       project
             *   |         /
             *   |        /
             *    \      /
             *     \    /
             *      count
             */
            if (!(L(p) == RLRL(p) &&
                  R(p)->sem.attach.res == L(p)->sem.aggr.res &&
                  R(p)->sem.attach.value.type == aat_int &&
                  R(p)->sem.attach.value.val.int_ == 0 &&
                  RLL(p)->schema.count == 1 &&
                  RLR(p)->schema.count == 1 &&
                  L(p)->sem.aggr.part != att_NULL &&
                  L(p)->sem.aggr.part == RLR(p)->schema.items[0].name))
                PFoops (OOPS_FATAL, "error in count translation");

        {
            PFalg_att_t part, res_att;
            PFalg_simple_type_t part_ty, res_ty;
            PFsql_col_t *part_col, *res_col;
            PFsql_t *loop, *part_expr, *loop_from, *part_from;
            sql_from_list_t from;

            PFsql_t *selectlist = NULL;
            PFsql_t *columnlist = NULL;
            PFsql_t *groupbylist = NULL;
            PFsql_tident_t newtable;
            PFsql_aident_t newalias;

            part      = L(p)->sem.aggr.part;
            res_att   = L(p)->sem.aggr.res;
            part_ty   = type_of (p, part);
            res_ty    = type_of (p, res_att);

            /* Bind the inner relation if it contains more
               than one input relation (as right outer join
               only works on exactly two relations). */
            if (PFarray_last (FROMLIST(LL(p))) != 1) {
#ifndef NDEBUG
                if (!BOUND(LL(p)))
                    execute (comment ("bind as a single relation "
                                      "is needed in the following outerjoin"));
#endif
                bind_operator (LL(p), false);
            }

            /* bind the outer relation if it contains more
               than one input relation (as right outer join
               only works on exactly two relations) or if the
               loop column is computed. */
            if (PFarray_last (FROMLIST(RLL(p))) != 1 ||
                col_env_lookup (COLMAP(RLL(p)),
                                part,
                                part_ty)->kind != sql_column_name) {
#ifndef NDEBUG
                if (!BOUND(RLL(p)))
                    execute (comment ("bind as a single relation "
                                      "is needed in the following outerjoin"));
#endif
                bind_operator (RLL(p), false);
            }

            part_col  = new_col (part, part_ty);
            res_col   = new_col (res_att, res_ty);
            loop      = col_env_lookup (COLMAP(RLL(p)), part, part_ty);
            part_expr = col_env_lookup (COLMAP(LL(p)), part, part_ty);
            from      = from_list_at (FROMLIST(RLL(p)), 0);
            loop_from = alias_bind (from.table, alias (from.alias));
            from      = from_list_at (FROMLIST(LL(p)), 0);
            part_from = alias_bind (from.table, alias (from.alias));

            /* create a new table name for binding */
            newtable = new_table_name ();
            /* new correlation name for bounded table */
            newalias = new_alias ();
            /* start a new from list as @a newtable will be bound */
            from_list_add (FROMLIST(p),
                           table_name (newtable),
                           newalias);

            /* PREPARE EVERYTHING FOR THE RESULT ATTRIBUTE */
            col_env_add (COLMAP(p), res_att, res_ty,
                         ext_column_name (newalias, res_col));

            columnlist = column_list (columnlist, column_name (res_col));

            /* add the aggregation to the selection list */
            selectlist = select_list (selectlist,
                                      column_assign (
                                          coalesce (
                                              count (part_expr),
                                              literal (
                                                  R(p)->sem.attach.value)),
                                          column_name (res_col)));

            /* PREPARE EVERYTHING FOR THE PARTITION ATTRIBUTE */
            col_env_add (COLMAP(p), part, part_ty,
                         ext_column_name (newalias, part_col));

            /* create columnlist for the table name */
            columnlist = column_list (columnlist,
                                      column_name (part_col));

            /* create selectlist for the table name */
            selectlist = select_list (selectlist, loop);

            groupbylist = column_list (groupbylist, loop);

            /* DUMP THE OPERATOR BINDING */
            execute (comment ("binding due to count aggregate"),
                     bind (table_def (newtable, columnlist),
                           select (selectlist,
                                   from_list (
                                       on (outer_join (part_from, loop_from),
                                           eq (part_expr, loop))),
                                   transform_wheremap (LL(p)),
                                   groupbylist)));

            /* mark node p as bound */
            BOUND(p) = true;
        }   break;

        /* Rel:    seqty1 (Rel) */
        case 41:
            /* FIXME: implementation is missing */
            assert (!"missing");
            break;

        /* Rel:    all (Rel) */
        case 42:
            /* FIXME: implementation is missing */
            assert (!"missing");
            break;

        /* Rel:    string_join (Rel, Rel) */
        case 43:
        {
            PFalg_att_t iter = p->sem.string_join.iter_res,
                        item = p->sem.string_join.item_res;
            PFalg_simple_type_t iter_ty = type_of (p, iter),
                                item_ty = type_of (p, item);

            /* FIXME: string_join is implemented as identity operator,
               so it will handle most of the queries */
            reduce (kids[0], nts[0]);

            col_env_add_full (COLMAP(p), iter, iter_ty,
                              col_env_lookup (COLMAP(L(p)), iter, iter_ty),
                              col_env_lookup_step (
                                  COLMAP(L(p)), iter, iter_ty));
            col_env_add (COLMAP(p), item, item_ty,
                         col_env_lookup (COLMAP(L(p)), item, item_ty));

            /* copy fromlist */
            from_list_copy (FROMLIST(p), FROMLIST(L(p)));
            /* copy wherelist */
            where_list_copy (WHERELIST(p), WHERELIST(L(p)));
        }   break;

        /* Rel:    rownum (Rel) */
        case 50:
        {
            PFsql_t *srtbylist = nil ();
            PFsql_t *partlist = NULL;
            PFalg_att_t ord;
            bool asc;

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));

            /* collect all sorting criteria */
            for (int i = PFord_count (p->sem.rownum.sortby) - 1; i >= 0; i--) {
                ord = PFord_order_col_at (p->sem.rownum.sortby, i);
                asc = PFord_order_dir_at (p->sem.rownum.sortby, i) == DIR_ASC;
                srtbylist = sortkey (
                                col_env_lookup (
                                    COLMAP(L(p)),
                                    ord,
                                    type_of (L(p), ord)),
                                asc,
                                srtbylist);
            }

            /* creat partition criterion if present */
            if (p->sem.rownum.part)
                partlist = partition (
                               column_list (
                                   col_env_lookup (
                                       COLMAP(L(p)),
                                       p->sem.rownum.part,
                                       type_of (L(p), p->sem.rownum.part))));

            col_env_add (COLMAP(p),
                         p->sem.rownum.res,
                         aat_nat,
                         over (rownumber (),
                               window_clause (
                                   partlist,
                                   order_by (srtbylist))));

            bind = true;
            execute (comment ("binding due to rownumber operator"));
        }   break;

        /* Rel:    number (Rel) */
        case 51:
            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));

            col_env_add (COLMAP(p),
                         p->sem.number.res,
                         aat_nat,
                         over (rownumber (),
                               window_clause (NULL, NULL)));

            bind = true;
            execute (comment ("binding due to number operator"));
            break;

        /* Rel:    rank (Rel) */
        case 52:
        {
            PFsql_t *srtbylist = nil ();
            PFalg_att_t ord;
            bool asc;

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));

            /* collect all sorting criteria */
            for (int i = PFord_count (p->sem.rank.sortby) - 1; i >= 0; i--) {
                ord = PFord_order_col_at (p->sem.rank.sortby, i);
                asc = PFord_order_dir_at (p->sem.rank.sortby, i) == DIR_ASC;
                srtbylist = sortkey (
                                col_env_lookup (
                                    COLMAP(L(p)),
                                    ord,
                                    type_of (L(p), ord)),
                                asc,
                                srtbylist);
            }

            col_env_add (COLMAP(p),
                         p->sem.rank.res,
                         aat_nat,
                         over (rownumber (),
                               window_clause (NULL, order_by (srtbylist))));

            bind = true;
            execute (comment ("binding due to rank operator"));
        }   break;

        /* Rel:    step (Frag, Rel) */
        case 55:
        /* Rel:    guide_step (Frag, Rel) */
        case 56:
        /* Rel:    step_join (Frag, Rel) */
        case 57:
        /* Rel:    guide_step_join (Frag, Rel) */
        case 58:
        {
            PFarray_t *colmap = col_env_new ();
            PFalg_att_t item = p->sem.step.item,
                        item_res = p->sem.step.item_res;
            PFalg_simple_type_t item_ty = type_of (R(p), item),
                                item_res_ty = type_of (p, item_res);
            PFsql_aident_t ctxalias, stepalias;

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, R(p));

            /* make sure to get the full table schema for the context nodes */
            ctxalias = col_env_lookup_step (COLMAP(p), item, item_ty);
            if (ctxalias == PF_SQL_ALIAS_UNBOUND) {
                ctxalias = new_alias ();
                from_list_add (FROMLIST(p), FRAG(L(p)), ctxalias);
                where_list_add (WHERELIST(p),
                                eq (col_env_lookup (COLMAP(p), item, item_ty),
                                    PRE(ctxalias)));
            }

            /* add the binding for the new document relation */
            stepalias = new_alias ();
            from_list_add (FROMLIST(p),
                           FRAG(L(p)),
                           stepalias);

            /* add the axis conditions */
            step_axis (p,
                       ctxalias,
                       stepalias,
                       p->sem.step.axis,
                       FRAG(L(p)));

            if (p->kind == la_step || p->kind == la_step_join) {
                step_name (p, stepalias, p->sem.step.ty);
                step_kind (p, stepalias, p->sem.step.ty);
                step_level (p, ctxalias, stepalias,
                            p->sem.step.axis, p->sem.step.level);
            } else {
                assert (p->kind == la_guide_step ||
                        p->kind == la_guide_step_join);

                #define GUIDE_BARRIER 1 

                if (p->sem.step.guide_count > GUIDE_BARRIER) {
                    step_guide_join (p,
                                     stepalias,
                                     p->sem.step.guide_count,
                                     p->sem.step.guides);
                }
                else {
                    step_guide (p,
                                stepalias,
                                p->sem.step.guide_count,
                                p->sem.step.guides);
                }
            }

            if (p->kind == la_step || p->kind == la_guide_step) {
                PFalg_att_t iter = p->sem.step.iter;
                PFalg_simple_type_t iter_ty = type_of (p, iter);

                /* prune the selection list */
                col_env_add_full (colmap, iter, iter_ty,
                                  col_env_lookup (COLMAP(p), iter, iter_ty),
                                  col_env_lookup_step (
                                      COLMAP(p), iter, iter_ty));
                COLMAP(p) = colmap;

                /* dump the relation if a distinct is required */
                if (!PFprop_set (p->prop)) {
                    distinct = true;
                    bind = true;
                    execute (comment ("binding due to %sstep operator",
                                      p->kind == la_step ? "" : "guide "));
                }
            }
            col_env_add_full (COLMAP(p), item_res, item_res_ty,
                              PRE(stepalias), stepalias);
        }   break;

        /* Rel:    doc_access (Frag, Rel) */
        case 59:
        {
            PFalg_att_t item = p->sem.doc_access.att,
                        item_res = p->sem.doc_access.res;
            PFalg_simple_type_t item_ty = type_of (p, item),
                                item_res_ty = type_of (p, item_res);
            PFsql_aident_t ctxalias;

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, R(p));

            /* make sure to get the full table schema for the context nodes */
            ctxalias = col_env_lookup_step (COLMAP(p), item, item_ty);
            if (ctxalias == PF_SQL_ALIAS_UNBOUND) {
                ctxalias = new_alias ();
                from_list_add (FROMLIST(p), FRAG(L(p)), ctxalias);
                where_list_add (WHERELIST(p),
                                eq (PRE(ctxalias),
                                    col_env_lookup (COLMAP(p), item, item_ty)));
            }

            /* add the new column to the column map */
            col_env_add (COLMAP(p), item_res, item_res_ty, VALUE(ctxalias));
        }   break;

        /* Rel:    roots_ (Constr) */
        case 60:
            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));
            break;

        /* Frag:   fragment (Constr) */
        case 61:
            FRAG(p) = FRAG(L(p));
            break;

        /* Frag:   frag_union (Frag, Frag) */
        case 62:
            /* Try to keep simple references (and thus merge
               equal document references into a single one). */
            if (FRAG(L(p))->kind == sql_tbl_name &&
                FRAG(R(p))->kind == sql_tbl_name &&
                FRAG(L(p))->sem.tbl.name == FRAG(R(p))->sem.tbl.name)
                FRAG(p) = FRAG(L(p));
            else
                /* Otherwise build a SFW that represents
                   the union of all referenced documents */
                FRAG(p) = collect_fragments (p);
            break;

        /* Frag:   frag_union (empty_frag, Frag) */
        case 63:
            FRAG(p) = FRAG(R(p));
            break;

        /* Frag:   empty_frag */
        case 64:
            FRAG(p) = table_name (PF_SQL_TABLE_FRAG);
            break;

        /* Constr: doc_tbl (Rel) */
        case 70:
        {
            PFalg_att_t iter = p->sem.doc_tbl.iter,
                        item = p->sem.doc_tbl.item,
                        item_res = p->sem.doc_tbl.item_res;
            PFalg_simple_type_t iter_ty = type_of (p, iter),
                                item_ty = type_of (L(p), item),
                                item_res_ty = type_of (p, item_res);
            PFsql_t *item_expr = col_env_lookup (COLMAP(L(p)), item, item_ty);
            PFsql_aident_t doc_tbl;

            /* copy the existing frommap */
            from_list_copy (FROMLIST(p), FROMLIST(L(p)));
            /* copy the existing wheremap */
            where_list_copy (WHERELIST(p), WHERELIST(L(p)));

            /* throw away singleton relation */
            if (PFarray_last (FROMLIST(p)) == 1) {
                PFsql_t *tbl = from_list_at (FROMLIST(p), 0).table;
                if (tbl->kind == sql_schema_tbl_name &&
                    L(tbl)->kind == sql_tbl_name &&
                    !strcmp (tbl->sem.schema.str, "sysibm") &&
                    L(tbl)->sem.tbl.name == PF_SQL_TABLE_SYSDUMMY1)
                    PFarray_del (FROMLIST(p));
            }

            /* introduce a new alias... */
            doc_tbl = new_alias ();
            /* ... and use it to refer to a fresh document relation */
            from_list_add (FROMLIST(p),
                           table_name (PF_SQL_TABLE_FRAG),
                           doc_tbl);

            /* add the output columns to the column map */
            col_env_add_full (COLMAP(p), iter, iter_ty,
                              col_env_lookup (COLMAP(L(p)), iter, iter_ty),
                              col_env_lookup_step (
                                  COLMAP(L(p)), iter, iter_ty));
            col_env_add_full (COLMAP(p), item_res, item_res_ty,
                              PRE(doc_tbl), doc_tbl);

            /* add the two checks to lookup the correct document */
            where_list_add (WHERELIST(p), eq (KIND(doc_tbl), lit_int (DOC)));
            where_list_add (WHERELIST(p), eq (VALUE(doc_tbl), item_expr));

            /* set the fragment relation */
            FRAG(p) = table_name (PF_SQL_TABLE_FRAG);
        }   break;

        /* Constr: twig (Twig) */
        case 71:
        {
            PFsql_aident_t      content      = new_alias ();
            PFsql_aident_t      new_root     = new_alias ();
            PFsql_t            *sortkey_list = nil ();

            /* We only need to sort by <pos, pre> if we have a variable
               part (content operator) in the twig constructor. */
            if (CSIZE(L(p)))
                sortkey_list = sortkey (POS(content),
                                        true,
                                        sortkey (PRE(content),
                                                 true,
                                                 sortkey_list));

            /* Always sort first by <iter, twig_pre>. */
            sortkey_list = sortkey (ITER(content),
                                    true,
                                    sortkey (TWIG_PRE(content),
                                             true,
                                             sortkey_list));

            /* call a helper function that does the 'real' job */
            construct_twig (p, content, new_root, sortkey_list);

            where_list_add (WHERELIST(p),
                            eq (LEVEL(new_root), lit_int (0)));
        }   break;

        /* Constr: twig (docnode (Rel, fcns (nil, nil))) */
        case 72:
            construct_simple_twig (p, L(p)->sem.docnode.iter, DOC,
                                   lit_str (""), lit_str (""));
            break;

        /* Constr: twig (element (Rel, fcns (nil, nil))) */
        case 73:
        {
            PFalg_att_t item = L(p)->sem.iter_item.item;

            construct_simple_twig (
                p, L(p)->sem.iter_item.iter, ELEM,
                lit_str (""),
                col_env_lookup (COLMAP(LL(p)), item, type_of (LL(p), item)));
        }   break;
        
        /* Constr: twig (attribute (Rel)) */
        case 74:
        /* Constr: twig (processi (Rel)) */
        case 77:
        {
            PFalg_att_t item1 = L(p)->sem.iter_item1_item2.item1;
            PFalg_att_t item2 = L(p)->sem.iter_item1_item2.item2;

            construct_simple_twig (
                p, L(p)->sem.iter_item1_item2.iter,
                L(p)->kind == la_attribute ? ATTR : PI,
                col_env_lookup (COLMAP(LL(p)), item2, type_of (LL(p), item2)),
                col_env_lookup (COLMAP(LL(p)), item1, type_of (LL(p), item1)));
        }   break;

        /* Constr: twig (textnode (Rel)) */
        case 75:
        /* Constr: twig (comment (Rel)) */
        case 76:
        {
            PFalg_att_t item = L(p)->sem.iter_item.item;

            construct_simple_twig (
                p, L(p)->sem.iter_item.iter,
                L(p)->kind == la_textnode ? PF_TEXT : COMM,
                col_env_lookup (COLMAP(LL(p)), item, type_of (LL(p), item)),
                lit_str (""));
        }   break;
        
        /* List:   fcns (Twig, List) */
        case 78:
            FRAG(p) = union_ (FRAG(L(p)), FRAG(R(p)));

            if (CSIZE(L(p)) && CSIZE(R(p))) {
                /* For the content sizes we try to maintain
                   simple table names as long as possible. Here
                   this is not possible anymore and we have to
                   turn the reference into a union on subselects. */
                PFsql_t *l_csize = CSIZE(L(p)),
                        *r_csize = CSIZE(R(p));

                if (l_csize->kind != sql_union) {
                    assert (l_csize->kind == sql_tbl_name);
                    l_csize = select (select_list (ITER_, SIZE_),
                                      l_csize, NULL, NULL);
                }
                if (r_csize->kind != sql_union) {
                    assert (r_csize->kind == sql_tbl_name);
                    r_csize = select (select_list (ITER_, SIZE_),
                                      r_csize, NULL, NULL);
                }

                CSIZE(p) = union_ (l_csize, r_csize);
            }
            else if (CSIZE(L(p)))
                CSIZE(p) = CSIZE(L(p));
            else if (CSIZE(R(p)))
                CSIZE(p) = CSIZE(R(p));
            break;

        /* List:   fcns (Twig, nil) */
        case 79:
            FRAG(p) = FRAG(L(p));
            CSIZE(p) = CSIZE(L(p));
            break;

        /* Twig:   docnode (Rel, List) */
        case 80:
            if (CSIZE(R(p))) {
                PFalg_att_t     iter = p->sem.docnode.iter;
                sql_from_list_t name_from;
                PFsql_aident_t  csize_alias;
                PFsql_t        *iter_col;

                CSIZE(p) = CSIZE(R(p));
                csize_alias = new_alias ();

                if (PFarray_last (FROMLIST(L(p))) != 1 ||
                    col_env_lookup (
                        COLMAP(L(p)),
                        iter,
                        type_of (L(p), iter))->kind != sql_column_name) {
#ifndef NDEBUG
                    if (!BOUND(L(p)))
                        execute (comment ("bind loop relation as a single "
                                          "relation is needed in the "
                                          "following outerjoin"));
#endif
                    bind_operator (L(p), false);
                }

                name_from   = from_list_at (FROMLIST(L(p)), 0);
                iter_col    = col_env_lookup (
                                  COLMAP(L(p)),
                                  iter,
                                  type_of (L(p), iter));

                FRAG (p) = select (
                               select_list (
                                   column_assign (iter_col, ITER_),
                                   column_assign (lit_int (TPRE(p)), TWIG_PRE_),
                                   column_assign (lit_int (-1), POS_),
                                   column_assign (lit_int (-1), PRE_),
                                   column_assign (
                                       add (lit_int (TSIZE(p)),
                                            coalesce (
                                                sum (SIZE(csize_alias)),
                                                lit_int (0))),
                                       SIZE_),
                                   column_assign (lit_int (TLEVEL(p)), LEVEL_),
                                   column_assign (lit_int (DOC), KIND_),
                                   column_assign (lit_str (""), VALUE_),
                                   column_assign (lit_str (""), NAME_)),
                               from_list (
                                   on (outer_join (
                                           alias_bind (
                                               CSIZE(R(p)),
                                               alias (csize_alias)),
                                           alias_bind (
                                               name_from.table,
                                               alias (name_from.alias))),
                                       eq (ITER(csize_alias),
                                           iter_col))),
                               NULL,
                               column_list (iter_col));

                FRAG(p) = union_ (FRAG(p), FRAG(R(p)));
            } else {
                construct_node (p, p->sem.docnode.iter, DOC,
                                lit_str (""), lit_str (""));

                FRAG(p) = union_ (FRAG(p), FRAG(R(p)));
            }
            break;

        /* Twig:   docnode (Rel, fcns (nil, nil)) */
        case 81:
            construct_node (p, p->sem.docnode.iter, DOC,
                            lit_str (""), lit_str (""));
            break;

        /* Twig:   element (Rel, List) */
        case 82:
            if (CSIZE(R(p))) {
                PFalg_att_t     iter = p->sem.iter_item.iter,
                                item = p->sem.iter_item.item;
                sql_from_list_t name_from;
                PFsql_aident_t  csize_alias;
                PFsql_t        *iter_col, *item_col, *grpbylist;
                bool            item_const = PFprop_const (L(p)->prop, item);

                CSIZE(p) = CSIZE(R(p));
                csize_alias = new_alias ();

                /* bind the element names if we cannot avoid it */
                if (!item_const ||
                    PFarray_last (FROMLIST(L(p))) != 1 ||
                    col_env_lookup (
                        COLMAP(L(p)),
                        iter,
                        type_of (L(p), iter))->kind != sql_column_name) {
#ifndef NDEBUG
                    if (!BOUND(L(p)))
                        execute (comment ("bind element name as a single "
                                          "relation is needed in the "
                                          "following outerjoin"));
#endif
                    bind_operator (L(p), false);
                }

                name_from   = from_list_at (FROMLIST(L(p)), 0);
                iter_col    = col_env_lookup (
                                  COLMAP(L(p)),
                                  iter,
                                  type_of (L(p), iter));
                
                /* If we have a constant QName we directly use it. */
                if (item_const) {
                    item_col  = literal (PFprop_const_val (L(p)->prop, item));
                    grpbylist = column_list (iter_col);
                }
                /* Otherwise we need to put the item column
                   also into the list of groupby criteria. */
                else {
                    item_col = EXT_COLUMN_NAME (
                                   name_from.alias,
                                   item,
                                   type_of (L(p), item));
                    grpbylist = column_list (iter_col, item_col);
                }

                FRAG (p) = select (
                               select_list (
                                   column_assign (iter_col, ITER_),
                                   column_assign (lit_int (TPRE(p)), TWIG_PRE_),
                                   column_assign (lit_int (-1), POS_),
                                   column_assign (lit_int (-1), PRE_),
                                   column_assign (
                                       add (lit_int (TSIZE(p)),
                                            coalesce (
                                                sum (SIZE(csize_alias)),
                                                lit_int (0))),
                                       SIZE_),
                                   column_assign (lit_int (TLEVEL(p)), LEVEL_),
                                   column_assign (lit_int (ELEM), KIND_),
                                   column_assign (lit_str (""), VALUE_),
                                   column_assign (item_col, NAME_)),
                               from_list (
                                   on (outer_join (
                                           alias_bind (
                                               CSIZE(R(p)),
                                               alias (csize_alias)),
                                           alias_bind (
                                               name_from.table,
                                               alias (name_from.alias))),
                                       eq (ITER(csize_alias),
                                           iter_col))),
                               NULL,
                               grpbylist);

                FRAG(p) = union_ (FRAG(p), FRAG(R(p)));
            } else {
                /* simple translation (as we already have all size values) */
                PFalg_att_t item = p->sem.iter_item.item;

                construct_node (
                    p, p->sem.iter_item.iter, ELEM,
                    lit_str (""),
                    col_env_lookup (COLMAP(L(p)), item, type_of (L(p), item)));

                FRAG(p) = union_ (FRAG(p), FRAG(R(p)));
            }
            break;

        /* Twig:   element (Rel, fcns (nil, nil)) */
        case 83:
        {
            PFalg_att_t item = p->sem.iter_item.item;

            construct_node (
                p, p->sem.iter_item.iter, ELEM,
                lit_str (""),
                col_env_lookup (COLMAP(L(p)), item, type_of (L(p), item)));
        }   break;

        /* Twig:   attribute (Rel) */
        case 84:
        /* Twig:   processi (Rel) */
        case 87:
        {
            PFalg_att_t item1 = p->sem.iter_item1_item2.item1;
            PFalg_att_t item2 = p->sem.iter_item1_item2.item2;

            construct_node (
                p, p->sem.iter_item1_item2.iter,
                p->kind == la_attribute ? ATTR : PI,
                col_env_lookup (COLMAP(L(p)), item2, type_of (L(p), item2)),
                col_env_lookup (COLMAP(L(p)), item1, type_of (L(p), item1)));
        }   break;

        /* Twig:   textnode (Rel) */
        case 85:
        /* Twig:   comment (Rel) */
        case 86:
        {
            PFalg_att_t item = p->sem.iter_item.item;

            construct_node (
                p, p->sem.iter_item.iter,
                p->kind == la_textnode ? PF_TEXT : COMM,
                col_env_lookup (COLMAP(L(p)), item, type_of (L(p), item)),
                lit_str (""));
        }   break;

        /* Twig:   content (Frag, Rel) */
        case 88:
        {
            PFalg_att_t         iter          = p->sem.iter_pos_item.iter,
                                pos           = p->sem.iter_pos_item.pos,
                                item          = p->sem.iter_pos_item.item;
            PFalg_simple_type_t iter_ty       = type_of (R(p), iter),
                                pos_ty        = type_of (R(p), pos),
                                item_ty       = type_of (R(p), item);

            PFsql_aident_t ctx, step;
            PFsql_tident_t iter_size_tbl, content_tbl;
            PFsql_t *iter_expr, *pos_expr, *item_expr,
                    *iter_size = NULL, *content = NULL,
                    *frag, *sel, *selectlist;

            PFarray_t *frags = PFarray (sizeof (PFsql_t *));
            /* collect the duplicate free list of fragment references */
            collect_frag_worker (L(p), frags);
            assert (PFarray_last (frags));
            
#ifndef NDEBUG
            if (!BOUND(R(p)))
                execute (comment ("bind input as it will be referenced "
                                  "at least twice."));
#endif
            bind_operator (R(p), false);

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, R(p));

            iter_expr = col_env_lookup (COLMAP(p), iter, iter_ty);
            pos_expr  = col_env_lookup (COLMAP(p), pos, pos_ty);
            item_expr = col_env_lookup (COLMAP(p), item, item_ty);

            /* add the document relation */
            ctx = new_alias ();
            from_list_add (FROMLIST(p), NULL, ctx);
            where_list_add (WHERELIST(p), eq (item_expr, PRE(ctx)));
            
            for (unsigned int i = 0; i < PFarray_last (frags); i++) {
                frag = *(PFsql_t **) PFarray_at (frags, i);
                
                sel = select (select_list (
                                  column_assign (iter_expr, ITER_),
                                  column_assign (
                                      add (SIZE(ctx), lit_int (1)),
                                      SIZE_)),
                              transform_frommap_ext (p, frag),
                              transform_wheremap (p),
                              NULL);
                iter_size = (i == 0) ? sel : union_ (iter_size, sel);
            }
            
            iter_size_tbl = new_table_name (), 
            execute (comment ("====================="),
                     comment ("= CONSTRUCTOR SIZES ="),
                     comment ("====================="),
                     bind (table_def (iter_size_tbl,
                                      column_list (ITER_, SIZE_)),
                           iter_size));

            CSIZE(p) = table_name (iter_size_tbl);
            
            /* ................................................... */
            
            /* add the binding for the new document relation */
            step = new_alias ();
            from_list_add (FROMLIST(p), NULL, step);
            /* add the axis conditions */
            step_axis (p, ctx, step, alg_desc_s, NULL);
            
            selectlist = select_list (
                             column_assign (iter_expr, ITER_),
                             column_assign (lit_int (TPRE(p)), TWIG_PRE_),
                             column_assign (pos_expr, POS_),
                             column_assign (PRE(step), PRE_),
                             column_assign (SIZE(step), SIZE_),
                             column_assign (
                                 add (sub (LEVEL(step), LEVEL(ctx)),
                                      lit_int (TLEVEL(p))),
                                 LEVEL_),
                             column_assign (KIND(step), KIND_),
                             column_assign (VALUE(step), VALUE_),
                             column_assign (NAME(step), NAME_));

            for (unsigned int i = 0; i < PFarray_last (frags); i++) {
                frag = *(PFsql_t **) PFarray_at (frags, i);
                
                sel = select (selectlist,
                              transform_frommap_ext (p, frag),
                              transform_wheremap (p),
                              NULL);
                content = (i == 0) ? sel : union_ (content, sel);
            }

            content_tbl = new_table_name (); 
            execute (comment ("======================="),
                     comment ("= CONSTRUCTOR CONTENT ="),
                     comment ("======================="),
                     bind (table_def (
                               content_tbl,
                               column_list (
                                   ITER_, TWIG_PRE_, POS_, PRE_,
                                   SIZE_, LEVEL_, KIND_, VALUE_, NAME_)),
                           content));
            
            FRAG(p) = select (select_list (
                                  ITER_, TWIG_PRE_, POS_, PRE_,
                                  SIZE_, LEVEL_, KIND_, VALUE_, NAME_),
                              table_name (content_tbl),
                              NULL, NULL);
        }   break;

        /* Constr: merge_adjacent (Frag, Rel) */
        case 89:
            /* FIXME: this rule is implemented as identity operator */

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, R(p));

            FRAG(p) = FRAG(L(p));
            break;

        /* Rel:    cond_err (Rel, Rel) */
        case 99:
            reduce (kids[0], nts[0]);

            /* copy all existing column, from, and where lists */
            copy_cols_from_where (p, L(p));
            break;

        /* Rel:    trace (Rel, Msg) */
        case 100:
        /* Msg:    trace_msg (Rel, Map) */
        case 101:
        /* Map:    trace_map (Rel, Map) */
        case 102:
        /* Map:    nil */
        case 103:
        /* Rel:    rec_fix (Rec, Rel) */
        case 105:
        /* Rel:    rec_base */
        case 106:
        /* Rec:    rec_param (Arg, Rec) */
        case 107:
        /* Rec:    nil */
        case 108:
        /* Arg:    rec_arg (Rel, Rel) */
        case 109:
            /* FIXME: implementation is missing */
            PFoops (OOPS_FATAL,
                    "SQLgen: Translation for the logical "
                    "algebra pattern (%s) is still missing.",
                    PFlalg2sql_string[rule]);
            break;

        /* Rel:    dummy (Rel) */
        case 110:
        /* Rel:    proxy (Rel) */
        case 111:
        /* Rel:    proxy_base (Rel) */
        case 112:
        /* Rel:    eqjoin_unq (Rel, Rel) */
        case 113:
        /* Rel:    cross_mvd (Rel, Rel) */
        case 114:
        default:
            PFoops (OOPS_FATAL,
                    "SQLgen: Logical algebra operator "
                    "(%s) is not allowed here.",
                    PFlalg2sql_string[rule]);
            break;
    }

#define FRAG_OP(p) (/* fragment related operators */ \
                    (p)->kind == la_frag_union    || \
                    (p)->kind == la_empty_frag    || \
                    (p)->kind == la_fragment      || \
                    /* and operators that are     */ \
                    /* referenced by 'roots' and  */ \
                    /* 'fragment' only            */ \
                    (p)->kind == la_doc_tbl       || \
                    (p)->kind == la_twig          || \
                    (p)->kind == la_merge_adjacent)

    /* BINDING: execute the statement at the end
       if the node is dirty, and bind it to a new SQL variable.
       The strategy behind this late binding is to merge
       as many operators as possible into one SQL statement.  */
    if (bind)
        bind_operator (p, distinct);
    else if (p->refctr > 1 && !FRAG_OP(p)) {
        execute (comment ("binding due to multiple references"));
        bind_operator (p, distinct);
    }
}

/* Attach node labels in a DAG walk bottom-up */
static void
label (PFla_op_t *p)
{
    /* label the nodes */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFlalg2sql_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        if (!SEEN(L(p))) label (L(p));
        STATE_LABEL(p) = PFlalg2sql_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
    }
    else if (!L(p) && R(p)) {
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFlalg2sql_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
        /* update also control reference */
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    else {
        if (!SEEN(L(p))) label (L(p));
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFlalg2sql_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
        /* update also control reference */
        CHILD_STATE_LABEL(p, 0) = STATE_LABEL(L(p));
        CHILD_STATE_LABEL(p, 1) = STATE_LABEL(R(p));
    }
    SEEN(p) = true;

    /* and add annotations to them */
    p->sql_ann = sql_alg_ann_new ();

    assert (STATE_LABEL(p));
}

/**
 * Assign each constructor in a twig pattern a delta value in pre-order,
 * a level value, and a size value. */
static unsigned int
assign_twig_info (PFla_op_t *n, unsigned int twig_pre, unsigned int level)
{
    assert (n);

    /* only descend once */
    if (SEEN (n))
        return twig_pre;
    else
        SEEN (n) = true;

    if (n->kind == la_twig) {
        assign_twig_info (L(n), 0, 0);
        return twig_pre;
    } else if (n->kind == la_fcns) {
        /* this is the only place we need to ensure the order */
        twig_pre = assign_twig_info (L(n), twig_pre, level);
        twig_pre = assign_twig_info (R(n), twig_pre, level);

        if (L(n)->kind == la_nil && R(n)->kind == la_nil)
            TSIZE(n) = 0;
        else if (R(n)->kind == la_nil)
            TSIZE(n) = TSIZE(L(n)) + 1;
        else
            TSIZE(n) = (TSIZE(L(n)) + 1) + TSIZE(R(n));

        return twig_pre;
    } else if (n->kind == la_docnode ||
               n->kind == la_element) {
        TPRE(n)   = twig_pre++;
        TLEVEL(n) = level++;

        /* assign pre, size, and level information for the children */
        twig_pre = assign_twig_info (L(n), twig_pre, level);
        twig_pre = assign_twig_info (R(n), twig_pre, level);

        TSIZE(n) = TSIZE(R(n));
        return twig_pre;
    } else if (n->kind == la_attribute ||
               n->kind == la_textnode ||
               n->kind == la_comment ||
               n->kind == la_processi ||
               n->kind == la_content) {
        TPRE(n)   = twig_pre++;
        TSIZE(n)  = n->kind == la_content ? -1 : 0;
        TLEVEL(n) = level;
    }

    /* traverse the children */
    for (unsigned int i = 0; i < PFLA_OP_MAXCHILD && n->child[i]; i++)
        twig_pre = assign_twig_info (n->child[i], twig_pre, level);

    return twig_pre;
}

PFsql_t *
PFlalg2sql (PFla_op_t * n)
{
  sql_stmts = NULL;

  assert (n);

  /* Set reference counters in algebra tree nodes. */
  PFprop_infer_refctr (n);

  /* Set the initial fragment. */
  max_pre_frag = table_name (PF_SQL_TABLE_FRAG);

  /* Label and annotate the complete DAG. */
  label (n);
  PFla_dag_reset (n);

  /* Assign the delta-pre, level, and size value for node constructors */
  assign_twig_info (n, 0, 0);
  PFla_dag_reset (n);

  /* Traverse the tree and collect as a side effect
     the SQL code in the global variable @a sql_stmts. */
  reduce (n, 1);

  return sql_stmts;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */

