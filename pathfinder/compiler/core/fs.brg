%{

/**
 * @file
 *
 * Compile parse tree into XQuery Core. This file implements
 * (more or less) the W3C XQuery Formal Semantics Working Draft.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2005 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */ 


#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "abssyn.h"
#include "qname.h"
#include "mem.h"

/* PFcnode_t */
#include "core.h"

/*
 * We need subtyping stuff for semantics of function application.
 */
#include "subtyping.h"

/* PFvar_t */
#include "variable.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFpnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/abssyn.h!
 */
%term    and            =   1
%term    apply          =   2
%term    args           =   3
%term    atom_ty        =   4
%term    attr           =   5
%term    base_uri       =   6
%term    bind           =   7
%term    binds          =   8
%term    case_          =   9
%term    cases          =  10
%term    cast           =  11
%term    castable       =  12
%term    coll_decl      =  13
%term    comment        =  14
%term    constr_decl    =  15
%term    contseq        =  16
%term    decl_imps      =  17
%term    def_order      =  18
%term    default_       =  19
%term    div            =  20
%term    doc            =  21
%term    dot            =  22
%term    elem           =  23
%term    empty_seq      =  24
%term    empty_ty       =  25
%term    ens_decl       =  26
%term    eq             =  27
%term    every          =  28
%term    except         =  29
%term    exprseq        =  30
%term    external       =  31
%term    flwr           =  32
%term    fns_decl       =  33
%term    fun            =  34
/* %term fun_decl       =  35  eliminated by function checking */
/* %term fun_ref        =  36  eliminated by function checking */
%term    fun_sig        =  37
%term    ge             =  38
%term    gt             =  39
%term    gtgt           =  40
%term    idiv           =  41
%term    if_            =  42
%term    inherit_ns     =  43
%term    instof         =  44
%term    intersect      =  45
%term    is             =  46
%term    item_ty        =  47
%term    le             =  48
%term    let            =  49
%term    lib_mod        =  50
%term    lit_dbl        =  51
%term    lit_dec        =  52
%term    lit_int        =  53
%term    lit_str        =  54
%term    locpath        =  55
%term    lt             =  56
%term    ltlt           =  57
%term    main_mod       =  58
%term    minus          =  59
%term    mod            =  60
%term    mod_imp        =  61
%term    mod_ns         =  62
%term    mult           =  63
%term    named_ty       =  64
%term    ne             =  65
%term    nil            =  66
%term    nis            =  67
%term    node_ty        =  68
%term    ns_decl        =  69
%term    or             =  70
%term    ord_ret        =  71
%term    orderby        =  72
%term    ordered        =  73
%term    ordering_mode  =  74
%term    orderspecs     =  75
%term    param          =  76
%term    params         =  77
%term    pi             =  78
%term    plus           =  79
%term    pred           =  80
%term    range          =  81
%term    req_name       =  82
%term    req_ty         =  83
%term    root_          =  84
%term    schm_ats       =  85
%term    schm_attr      =  86
%term    schm_elem      =  87
%term    schm_imp       =  88
%term    seq_ty         =  89
%term    some           =  90
%term    step           =  91
%term    tag            =  92
%term    text           =  93
%term    then_else      =  94
%term    treat          =  95
%term    typeswitch     =  96
%term    uminus         =  97
%term    union_         =  98
%term    unordered      =  99
%term    uplus          = 100
%term    val_eq         = 101
%term    val_ge         = 102
%term    val_gt         = 103
%term    val_le         = 104
%term    val_lt         = 105
%term    val_ne         = 106
%term    validate       = 107
%term    var            = 108
%term    var_decl       = 109
%term    var_type       = 110
/* %term varref         = 111  eliminated by function checking */
%term    vars           = 112
%term    where          = 113
%term    xmls_decl      = 114

%%

Query:                  MainModule                                  =   1 (10);
Query:                  lib_mod (ModuleDecl, Prolog)                =   2 (10);

MainModule:             main_mod (Prolog, QueryBody)                =   3 (10);
LibraryModule:          lib_mod (ModuleDecl, Prolog)                =   4 (10);

ModuleDecl:             mod_ns (lit_str)                            =   5 (10);
Prolog:                 DeclsImports                                =   6 (10);

DeclsImports:           decl_imps (DeclImport, DeclsImports)        =   7 (10);
DeclsImports:           nil                                         =   8 (10);

/* Expand function declarations here to allow for appropriate
 * top-down processing.
 */
DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                 SequenceType),
                                        Expr),
                                   DeclsImports)                    =   9 (10);
DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                 SequenceType),
                                        external),
                                   DeclsImports)                    =  10 (10);


DeclImport:             DefaultNamespaceDecl                        =  11 (10);
DeclImport:             XMLSpaceDecl                                =  12 (10);
DeclImport:             DefaultCollationDecl                        =  13 (10);
DeclImport:             BaseURIDecl                                 =  14 (10);
DeclImport:             ConstructionDecl                            =  15 (10);
DeclImport:             OrderingModeDecl                            =  16 (10);
DeclImport:             EmptyOrderingDecl                           =  17 (10);
DeclImport:             InheritNamespacesDecl                       =  18 (10);
DeclImport:             NamespaceDecl                               =  19 (10);
DeclImport:             SchemaImport                                =  20 (10);
DeclImport:             ModuleImport                                =  21 (10);
DeclImport:             VariableDeclaration                         =  22 (10);
DeclImport:             LibraryModule                               =  23 (10);

DefaultNamespaceDecl:   ens_decl (lit_str)                          =  24 (10);
DefaultNamespaceDecl:   fns_decl (lit_str)                          =  25 (10);

XMLSpaceDecl:           xmls_decl                                   =  26 (10);

DefaultCollationDecl:   coll_decl (lit_str)                         =  27 (10);

BaseURIDecl:            base_uri (lit_str)                          =  28 (10);

ConstructionDecl:       constr_decl                                 =  29 (10);

OrderingModeDecl:       ordering_mode                               =  30 (10);

EmptyOrderingDecl:      def_order                                   =  31 (10);

InheritNamespacesDecl:  inherit_ns                                  =  32 (10);

NamespaceDecl:          ns_decl (lit_str)                           =  33 (10);

SchemaImport:           schm_imp (lit_str, OptImportLoc_)           =  34 (10);

ModuleImport:           mod_imp (lit_str, OptImportLoc_)            =  35 (10);

OptImportLoc_:          nil                                         =  36 (10);
OptImportLoc_:          schm_ats (lit_str, OptImportLoc_)           =  37 (10);

OptParamList_:          nil                                         =  38 (10);
OptParamList_:          ParamList_                                  =  39 (10);

ParamList_:             nil                                         =  40 (10);
ParamList_:             params (Param, ParamList_)                  =  41 (10);

Param:                  param (SequenceType, Var)                   =  42 (10);

OptSequenceType_:       nil                                         =  43 (10);
OptSequenceType_:       SequenceType                                =  44 (10);

VariableDeclaration:    var_decl (var_type (Var,
                                            nil),
                                  OptExpr)                          =  45 (10);
VariableDeclaration:    var_decl (var_type (Var,
                                            SequenceType),
                                  OptExpr)                          =  46 (10);
VariableDeclaration:    var_decl (var_type (Var,
                                            OptSequenceType_),
                                  external)                         =  47 (10);

QueryBody:              OptExpr                                     =  48 (10);

OptExpr:                empty_seq                                   =  49 (10);
OptExpr:                Expr                                        =  50 (10);

Expr:                   exprseq (OptExpr, OptExpr)                  =  51 (10);
Expr:                   ExprSingle                                  =  52 (10);

ExprSingle:             FLWORExpr                                   =  53 (10);
ExprSingle:             QuantifiedExpr                              =  54 (10);
ExprSingle:             TypeswitchExpr                              =  55 (10);
ExprSingle:             IfExpr                                      =  56 (10);
ExprSingle:             OrExpr                                      =  57 (10);

FLWORExpr:              flwr (binds (let (var_type (Var,
                                                    nil),
                                          OptExpr),
                                     nil),
                              where (OptWhereClause_,
                                     OrderByReturn))                =  58 (10);

FLWORExpr:              flwr (binds (let (var_type (Var,
                                                    TypeDeclaration),
                                          OptExpr),
                                     nil),
                              where (OptWhereClause_,
                                     OrderByReturn))                =  59 (10);

FLWORExpr:              flwr (binds (bind (vars (var_type (Var,
                                                           nil),
                                                 OptPosVar),
                                           OptExpr),
                                     nil),
                              where (OptWhereClause_,
                                     OrderByReturn))                =  60 (10);

FLWORExpr:              flwr (binds (bind (vars (var_type (Var,
                                                           TypeDeclaration),
                                                 OptPosVar),
                                           OptExpr),
                                     nil),
                              where (OptWhereClause_,
                                     OrderByReturn))                =  61 (10);

OrderByReturn:          ord_ret (nil, OptExpr)                      =  62 (10);
OrderByReturn:          ord_ret (OrderByClause, OptExpr)            =  63 (10);

OptPosVar:              nil                                         =  64 (10);
OptPosVar:              Var                                         =  65 (10);

TypeDeclaration:        SequenceType                                =  66 (10);

OptWhereClause_:        nil                                         =  67 (10);
OptWhereClause_:        OptExpr                                     =  68 (10);

OrderByClause:          orderby (OrderSpecList)                     =  69 (10);

OrderSpecList:          nil                                         =  70 (10);
OrderSpecList:          orderspecs (OptExpr, OrderSpecList)         =  71 (10);

QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                           nil),
                                                 nil),
                                           OptExpr),
                                     nil),
                              OptExpr)                              =  72 (10);
QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                           TypeDeclaration),
                                                 nil),
                                           OptExpr),
                                     nil),
                              OptExpr)                              =  73 (10);
QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                            nil),
                                                  nil),
                                            OptExpr),
                                      nil),
                               OptExpr)                             =  74 (10);
QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                            TypeDeclaration),
                                                  nil),
                                            OptExpr),
                                      nil),
                               OptExpr)                             =  75 (10);

TypeswitchExpr:         typeswitch (
                            OptExpr,
                            cases (case_ (var_type (OptCaseVar,
                                                    SequenceType),
                                          OptExpr),
                                   cases (default_ (OptCaseVar,
                                                    OptExpr),
                                          nil)))                    =  76 (10);

OptCaseVar:             nil                                         =  77 (10);
OptCaseVar:             Var                                         =  78 (10);

SequenceType:           seq_ty (ItemType)                           =  79 (10);

SingleType:             seq_ty (AtomType)                           =  80 (10);

ItemType:               empty_ty                                    =  81 (10);
ItemType:               NodeTest                                    =  82 (10);
ItemType:               item_ty (nil)                               =  83 (10);
ItemType:               atom_ty (nil)                               =  84 (10);
ItemType:               schm_elem                                   =  85 (10);
ItemType:               schm_attr                                   =  86 (10);

AtomType:               atom_ty (nil)                               =  87 (10);

NodeTest:               node_ty (nil)                               =  88 (10);
NodeTest:               node_ty (ElemOrAttrType)                    =  89 (10);
NodeTest:               node_ty (node_ty (nil))                     =  90 (10);
NodeTest:               node_ty (node_ty (ElemOrAttrType))          =  91 (10);
NodeTest:               node_ty (lit_str)                           =  92 (10);

ElemOrAttrType:         req_ty (nil, nil)                           =  93 (10);
ElemOrAttrType:         req_ty (nil, SchemaType)                    =  94 (10);
ElemOrAttrType:         req_ty (req_name, nil)                      =  95 (10);
ElemOrAttrType:         req_ty (req_name, SchemaType)               =  96 (10);

SchemaType:             named_ty                                    =  97 (10);

IfExpr:                 if_ (OptExpr,
                             then_else (OptExpr, OptExpr))          =  98 (10);

OrExpr:                 AndExpr                                     =  99 (10);
OrExpr:                 or (AndExpr, OrExpr)                        = 100 (10);

AndExpr:                ComparisonExpr                              = 101 (10);
AndExpr:                and (ComparisonExpr, AndExpr)               = 102 (10);

ComparisonExpr:         RangeExpr                                   = 103 (10);
ComparisonExpr:         eq (RangeExpr, RangeExpr)                   = 104 (10);
ComparisonExpr:         ne (RangeExpr, RangeExpr)                   = 105 (10);
ComparisonExpr:         lt (RangeExpr, RangeExpr)                   = 106 (10);
ComparisonExpr:         le (RangeExpr, RangeExpr)                   = 107 (10);
ComparisonExpr:         gt (RangeExpr, RangeExpr)                   = 108 (10);
ComparisonExpr:         ge (RangeExpr, RangeExpr)                   = 109 (10);
ComparisonExpr:         val_eq (RangeExpr, RangeExpr)               = 110 (10);
ComparisonExpr:         val_ne (RangeExpr, RangeExpr)               = 111 (10);
ComparisonExpr:         val_lt (RangeExpr, RangeExpr)               = 112 (10);
ComparisonExpr:         val_le (RangeExpr, RangeExpr)               = 113 (10);
ComparisonExpr:         val_gt (RangeExpr, RangeExpr)               = 114 (10);
ComparisonExpr:         val_ge (RangeExpr, RangeExpr)               = 115 (10);
ComparisonExpr:         is (RangeExpr, RangeExpr)                   = 116 (10);
ComparisonExpr:         nis (RangeExpr, RangeExpr)                  = 117 (10);
ComparisonExpr:         ltlt (RangeExpr, RangeExpr)                 = 118 (10);
ComparisonExpr:         gtgt (RangeExpr, RangeExpr)                 = 119 (10);

RangeExpr:              AdditiveExpr                                = 120 (10);
RangeExpr:              range (RangeExpr, RangeExpr)                = 121 (10);

AdditiveExpr:           MultiplicativeExpr                          = 122 (10);
AdditiveExpr:           plus (AdditiveExpr, MultiplicativeExpr)     = 123 (10);
AdditiveExpr:           minus (AdditiveExpr, MultiplicativeExpr)    = 124 (10);

MultiplicativeExpr:     UnionExpr                                   = 125 (10);
MultiplicativeExpr:     mult (UnionExpr, MultiplicativeExpr)        = 126 (10);
MultiplicativeExpr:     div (UnionExpr, MultiplicativeExpr)         = 127 (10);
MultiplicativeExpr:     idiv (UnionExpr, MultiplicativeExpr)        = 128 (10);
MultiplicativeExpr:     mod (UnionExpr, MultiplicativeExpr)         = 129 (10);

UnionExpr:              IntersectExceptExpr                         = 130 (10);
UnionExpr:              union_ (IntersectExceptExpr, UnionExpr)     = 131 (10);

IntersectExceptExpr:    InstanceofExpr                              = 132 (10);
IntersectExceptExpr:    intersect (InstanceofExpr,
                                   IntersectExceptExpr)             = 133 (10);
IntersectExceptExpr:    except (InstanceofExpr,
                                IntersectExceptExpr)                = 134 (10);

InstanceofExpr:         TreatExpr                                   = 135 (10);
InstanceofExpr:         instof (TreatExpr, SequenceType)            = 136 (10);

TreatExpr:              CastableExpr                                = 137 (10);
TreatExpr:              treat (CastableExpr, SequenceType)          = 138 (10);

CastableExpr:           CastExpr                                    = 139 (10);
CastableExpr:           castable (CastExpr, SingleType)             = 140 (10);

CastExpr:               UnaryExpr                                   = 141 (10);
CastExpr:               cast (UnaryExpr, SingleType)                = 142 (10);

UnaryExpr:              ValueExpr                                   = 143 (10);
UnaryExpr:              uminus (ValueExpr)                          = 144 (10);
UnaryExpr:              uplus (ValueExpr)                           = 145 (10);

ValueExpr:              ValidateExpr                                = 146 (10);
ValueExpr:              PathExpr                                    = 147 (10);

ValidateExpr:           validate (OptExpr)                          = 148 (10);

PathExpr:               StepExpr                                    = 149 (10);
PathExpr:               LocationPath                                = 150 (10);

LocationPath:           root_                                       = 151 (10);
LocationPath:           locpath (StepExpr, StepExpr)                = 152 (10);
LocationPath:           locpath (LocationStep, StepExpr)            = 153 (10);

/*
 * NOTE: Did not exaclty use the normalize.brg rules here.
 *
PathExpr:               root_                                       = 149 (10);
PathExpr:               RelativePathExpr                            = 150 (10);

RelativePathExpr:       StepExpr                                    = 151 (10);
RelativePathExpr:       locpath (RelativePathExpr, StepExpr)        = 152 (10);
 */

StepExpr:               LocationStep                                = 154 (10);
StepExpr:               FilterExpr                                  = 155 (10);

FilterExpr:             PrimaryExpr                                 = 156 (10);
FilterExpr:             pred (StepExpr, OptExpr)                    = 157 (10);

LocationStep:           step (NodeTest)                             = 158 (10);

PrimaryExpr:            Literal                                     = 159 (10);
PrimaryExpr:            Var                                         = 160 (10);
PrimaryExpr:            ParenthesizedExpr                           = 161 (10);
PrimaryExpr:            ContextItemExpr                             = 162 (10);
PrimaryExpr:            FunctionCall                                = 163 (10);
PrimaryExpr:            Constructor                                 = 164 (10);
PrimaryExpr:            OrderedExpr                                 = 165 (10);
PrimaryExpr:            UnorderedExpr                               = 166 (10);

Literal:                NumericLiteral                              = 167 (10);
Literal:                StringLiteral                               = 168 (10);

NumericLiteral:         IntegerLiteral                              = 169 (10);
NumericLiteral:         DecimalLiteral                              = 170 (10);
NumericLiteral:         DoubleLiteral                               = 171 (10);

IntegerLiteral:         lit_int                                     = 172 (10);
DecimalLiteral:         lit_dec                                     = 173 (10);
DoubleLiteral:          lit_dbl                                     = 174 (10);

StringLiteral:          lit_str                                     = 175 (10);

Var:                    var                                         = 176 (10);

ParenthesizedExpr:      OptExpr                                     = 177 (10);

ContextItemExpr:        dot                                         = 178 (10);

FunctionCall:           apply (nil)                                 = 179 (10);
FunctionCall:           apply (FuncArgList)                         = 180 (10);

FuncArgList:            nil                                         = 181 (10);
FuncArgList:            args (OptExpr, FuncArgList)                 = 182 (10);

OrderedExpr:            ordered (OptExpr)                           = 183 (10);
UnorderedExpr:          unordered (OptExpr)                         = 184 (10);

Constructor:            ElementConstructor                          = 185 (10);
Constructor:            AttributeConstructor                        = 186 (10);
Constructor:            TextConstructor                             = 187 (10);
Constructor:            CommentConstructor                          = 188 (10);
Constructor:            PIConstructor                               = 189 (10);
Constructor:            DocumentConstructor                         = 190 (10);

ElementConstructor:     elem (TagName, OptContentExpr)              = 191 (10);

AttributeConstructor:   attr (TagName, AttributeValue)              = 192 (10);

TextConstructor:        text (OptExpr)                              = 193 (10);

CommentConstructor:     comment (OptExpr)                           = 194 (10);

PIConstructor:          pi (OptExpr, OptContentExpr)                = 195 (10);

DocumentConstructor:    doc (OptExpr)                               = 196 (10);

TagName:                tag                                         = 197 (10);
TagName:                OptExpr                                     = 198 (10);

OptContentExpr:         Expr                                        = 199 (10);
OptContentExpr:         empty_seq                                   = 200 (10);
OptContentExpr:         contseq (OptContentExpr, OptContentExpr)    = 201 (10);

AttributeValue:         Expr                                        = 202 (10);
AttributeValue:         empty_seq                                   = 203 (10);
AttributeValue:         contseq (AttributeValue, AttributeValue)    = 204 (10);


%%

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))
#define LLR(p) R(L(L(p)))
#define RRR(p) R(R(R(p)))
#define LLL(p) L(L(L(p)))
#define LLLL(p) L(L(L(L(p))))
#define LLLLL(p) L(L(L(L(L(p)))))
#define LLLLR(p) R(L(L(L(L(p)))))
#define LLLR(p) R(L(L(L(p))))
#define RLLR(p) R(L(L(R(p))))
#define RLLL(p) L(L(L(R(p))))
#define RLR(p) R(L(R(p)))
#define RRLL(p) L(L(R(R(p))))
#define RRLR(p) R(L(R(R(p))))

/** Access the Core representation of any node */
#define C(p) ((p)->core)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

/** mnemonic XQuery Core constructors */
#include "core_mnemonic.h"

/**
 * The current context items $fs:dot, $fs:position, and $fs:last
 * (see W3C XQuery Formal Semantics 3.1.2)
 */
static PFvar_t *fs_dot;
static PFvar_t *fs_position;
static PFvar_t *fs_last;

/**
 * The top of this stack holds a reference to the current function
 * (whose argument list is currently compiled).
 */
static PFarray_t *funs;
/**
 * The top of this stack holds a representation of the 
 * argument list to be passed to the currently compiled function application:
 *
 *               arg (e1, arg (e2, ..., arg (en, nil)...))
 */
static PFarray_t *args;
/**
 * The top of this stack holds the function argument number
 * that is currently compiled.
 */
static PFarray_t *arg_num;

/**
 * Collect function signatures here. The will be available as the
 * left child of the root node of the resulting Core tree.
 */
static PFcnode_t *fun_sigs;

/**
 * Collect variable declarations from the query prolog in this
 * root/hole pair. (see rule for VariableDeclaration)
 */
static struct {
    PFcnode_t *root;
    PFcnode_t *hole;
} var_decls;

/* element/attribute constructor and content */
static PFty_t (*elem_attr) (PFqname_t, PFty_t);
static PFty_t any;

static PFty_t *parameter_types (PFpnode_t *paramlist);

static PFcnode_t *function_conversion (const PFcnode_t *e, PFty_t expected);

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFpnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */
    PFcnode_t    *c;              /* temporary helper variable */

    /* determine rule that matches for this non-terminal */
    rule = PFfs_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFfs_nts[rule];
    PFfs_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    switch (rule) {
        /* DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                            SequenceType),
                                                   Expr),
                                              DeclsImports) */
        case 9:
        /* DeclsImports:           decls_imps (fun (fun_sig (OptParamList_,
                                                             SequenceType),
                                                    external),
                                               DeclsImports) */
        case 10:
        /* NodeTest:               node_ty (ElemOrAttrType) */
        case 89:
        /* NodeTest:               node_ty (node_ty (ElemOrAttrType)) */
        case 91:
        /* LocationPath:           locpath (StepExpr, StepExpr) */
        case 152:
        /* FilterExpr:             pred (StepExpr, Expr) */
        case 157:
        /* FunctionCall:           apply (nil) */
        case 179:
        /* FunctionCall:           apply (OptFuncArgList_) */
        case 180:
        /* FuncArgList:            args (Expr, FuncArgList) */
        case 182:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    if (!topdown)
        for (unsigned short i = 0; nts[i]; i++)
            reduce (kids[i], nts[i]);

    switch (rule) {

        /* Query:                  MainModule */
        case 1:
            break;

        /* Query:                  lib_mod (ModuleDecl, Prolog) */
        case 2:
            /*
             * Catch the case where we got an XQuery module
             * directly as the input.
             *
             * Don't know what the best is to do here. For now,
             * we pick Peter's approach and just "simulate" a
             * query that returns just the empty sequence.
             */

            /*
             * We may have collected variable bindings from the
             * prolog. Put them on top of the query.
             */
            if (var_decls.root) {
                var_decls.hole->child[1] = empty ();
                c = var_decls.root;
            }
            else
                c = empty ();

            /*
             * Make a `main' node the root of the resulting tree.
             * Left child lists all the function signatures. Right
             * child is the query itself.
             */
            C(p) = PFcore_main (fun_sigs, c);

            break;

        /* MainModule:             main_mod (Prolog, QueryBody) */
        case 3:
            /*
             * We may have collected variable bindings from the
             * prolog. Put them on top of the query.
             */
            if (var_decls.root) {
                var_decls.hole->child[1] = C(R(p));
                c = var_decls.root;
            }
            else
                c = C(R(p));

            /*
             * Make a `main' node the root of the resulting tree.
             * Left child lists all the function signatures. Right
             * child is the query itself.
             */
            C(p) = PFcore_main (fun_sigs, c);

            break;

        /* LibraryModule:          lib_mod (ModuleDecl, Prolog) */
        case 4:
            break;

        /* ModuleDecl:             mod_ns (lit_str) */
        case 5:
            break;

        /* Prolog:                 DeclsImports */
        case 6:
            break;

        /* DeclsImports:           decl_imps (DeclImport, DeclsImports) */
        case 7:
            break;

        /* DeclsImports:           nil */
        case 8:
            break;

        /* DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                            SequenceType),
                                                   Expr),
                                              DeclsImports) */
        case 9:
        {   /* TOPDOWN */

            /*
             * User-defined functions:
             *
             * (1) Create a unique PFfun_t data structure, containing
             *     type information, number of arguments, and an argument
             *     list (PFvar_t pointers).
             *     This has already happened during function checking.
             *
             * (2) Set function signature (particularly the type information).
             * 
             * (3) Process other function declarations.
             *     (We require this to have function signatures available
             *     if functions call each other. We will thus top-down
             *     process this rule.)
             *
             * (4) Translate function body.
             *
             * (5) Store the Core equivalent of the function body in
             *     the PFfun_t data structure. Parameter variables will
             *     appear free in this Core expression.
             *     Step (3) is what we do here.
             *
             * [(6) Before executing the Core code for this function,
             *      the back-end (e.g., algebra translation) needs to
             *      fill the variable environment with bindings for all
             *      the function parameters.
             *      This has to be done in the back-end.]
             *
             * Parse tree situation for function declarations:
             *
             *                   decls_imps
             *                  /          \
             *               fun        (other decls)
             *              /   \
             *        fun_sig    BODY
             *        /     \
             *  ParamList  ReturnType
             */

            PFvar_t *v = new_var (NULL);

            /* compile function signature */
            reduce (kids[0], nts[0]);
            reduce (kids[1], nts[1]);

            L(p)->sem.fun->par_ty = parameter_types (LLL(p));
            L(p)->sem.fun->ret_ty = C(LLR(p))->sem.type;

            /* Compile other functions (means we will compile all
             * function signatures before we compile any function body. */
            reduce (kids[3], nts[3]);

            /* compile function body */
            reduce (kids[2], nts[2]);

            /*
             * Apply function conversion to the function result
             * (see W3C XQuery 3.1.5 or function_conversion()
             */

            C(LR(p)) = let (letbind (var (v), C(LR(p))),
                            function_conversion (var (v), C(LLR(p))->sem.type));
            L(p)->sem.fun->core = C(LR(p));

            fun_sigs = fun_decls (fun_decl (L(p)->sem.fun, C(LLL(p)), C(LR(p))),
                                  fun_sigs);

        } break;


        /* DeclsImports:           decls_imps (fun (fun_sig (OptParamList_,
                                                             SequenceType),
                                                    external),
                                               DeclsImports) */
        case 10:
        {   /* TOPDOWN */

            /*
             * External functions:
             *
             * (1) Create a unique PFfun_t data structure, containing
             *     type information, number of arguments, and an argument
             *     list (PFvar_t pointers).
             *     This has already happened during function checking.
             *
             * (2) Set function signature (particularly the type information).
             * 
             * (3) Process other function declarations.
             *     (We require this to have function signatures available
             *     if functions call each other. We will thus top-down
             *     process this rule.)
             *
             * Parse tree situation for function declarations:
             *
             *                   decls_imps
             *                  /          \
             *               fun        (other decls)
             *              /   \
             *        fun_sig    external
             *        /     \
             *  ParamList  ReturnType
             */

            /* compile function signature */
            reduce (kids[0], nts[0]);
            reduce (kids[1], nts[1]);

            L(p)->sem.fun->par_ty = parameter_types (LLL(p));
            L(p)->sem.fun->ret_ty = C(LLR(p))->sem.type;

            /* Compile other functions (means we will compile all
             * function signatures before we compile any function body. */
            reduce (kids[2], nts[2]);

        } break;

        /* DeclImport:             DefaultNamespaceDecl */
        case 11:
            break;

        /* DeclImport:             XMLSpaceDecl */
        case 12:
            break;

        /* DeclImport:             DefaultCollationDecl */
        case 13:
            break;

        /* DeclImport:             BaseURIDecl */
        case 14:
            break;

        /* DeclImport:             ConstructionDecl */
        case 15:
            break;

        /* DeclImport:             OrderingModeDecl */
        case 16:
            break;

        /* DeclImport:             EmptyOrderingDecl */
        case 17:
            break;

        /* DeclImport:             InheritNamespacesDecl */
        case 18:
            break;

        /* DeclImport:             NamespaceDecl */
        case 19:
            break;

        /* DeclImport:             SchemaImport */
        case 20:
            break;

        /* DeclImport:             ModuleImport */
        case 21:
            break;

        /* DeclImport:             VariableDeclaration */
        case 22:
            break;

        /* DeclImport:             ModuleDecl */
        case 23:
            break;

        /* DefaultNamespaceDecl:   ens_decl (lit_str) */
        case 24:
            break;

        /* DefaultNamespaceDecl:   fns_decl (lit_str) */
        case 25:
            break;

        /* XMLSpaceDecl:           xmls_decl */
        case 26:
            break;

        /* DefaultCollationDecl:   coll_decl (lit_str) */
        case 27:
            PFinfo_loc (OOPS_WARN_NOTSUPPORTED, p->loc,
                        "default collation declaration will be ignored");
            break;

        /* BaseURIDecl:            base_uri (lit_str) */
        case 28:
            PFinfo_loc (OOPS_WARN_NOTSUPPORTED, p->loc,
                        "base-uri declaration will be ignored");
            break;

        /* ConstructionDecl:       constr_decl */
        case 29:
            PFinfo_loc (OOPS_WARN_NOTSUPPORTED, p->loc,
                        "construction mode declaration will be ignored");
            break;

        /* OrderingModeDecl:       ordering_mode */
        case 30:
            PFquery.ordering = p->sem.tru;
            break;

        /* EmptyOrderingDecl:      def_order */
        case 31:
            PFquery.empty_order = p->sem.mode.empty;
            break;

        /* InheritNamespacesDecl:  inherit_ns */
        case 32:
            PFquery.inherit_ns = p->sem.tru;
            break;

        /* NamespaceDecl:          ns_decl (lit_str) */
        case 33:
            break;

        /* SchemaImport:           schm_imp (lit_str, OptImportLoc_) */
        case 34:
            break;

        /* ModuleImport:           mod_imp (lit_str, OptImportLoc_) */
        case 35:
            /*
             * module imports have already been handled by the parser
             */
            break;

        /* OptImportLoc_:          nil */
        case 36:
            break;

        /* OptImportLoc_:          schm_ats (lit_str, OptImportLoc_) */
        case 37:
            break;

        /* OptParamList_:          nil */
        case 38:
            C(p) = nil ();
            break;

        /* OptParamList_:          ParamList_ */
        case 39:
            break;

        /* ParamList_:             nil */
        case 40:
            C(p) = nil ();
            break;

        /* ParamList_:             params (Param, ParamList_) */
        case 41:
            C(p) = params (C(L(p)), C(R(p)));
            break;

        /* Param:                  param (SequenceType, Var) */
        case 42:
            C(p) = param (C(L(p)), C(R(p)));
            break;

        /* OptSequenceType_:       nil */
        case 43:
            break;

        /* OptSequenceType_:       SequenceType */
        case 44:
            break;

        /* VariableDeclaration:    var_decl (var_type (Var,
                                                       nil),
                                             OptExpr) */
        case 45:
            /*
             * We translate
             *
             *  declare variable $a := ea ;
             *  declare variable $b := eb ;
             *  e0
             *
             * as
             *
             *  let $a := ea return
             *    let $b := eb return
             *      e0  .
             *
             * So while traversing the Query Prolog (this is what we're
             * currently doing), we build up a chain of nested let clauses,
             * with the return part as a hole.
             */
            c = let (letbind (C(LL(p)), C(R(p))), nil ());

	    /* set global information */
	    LL(c)->sem.var->global = true;

            if (var_decls.root)
                var_decls.hole = var_decls.hole->child[1] = c;
            else
                var_decls.root = var_decls.hole = c;

            break;

        /* VariableDeclaration:    var_decl (var_type (Var,
                                                       SequenceType),
                                             OptExpr) */
        case 46:
        {
            /*
             * We translate
             *
             *  declare variable $a as t1 := ea ;
             *  declare variable $b as t2 := eb ;
             *  e0
             *
             * as
             *
             *  let $a as t1 := ea return
             *    let $b as t2 := eb return
             *      e0  .
             *
             * So while traversing the Query Prolog (this is what we're
             * currently doing), we build up a chain of nested let clauses,
             * with the return part as a hole.
             */
            PFvar_t *v1 = new_var (NULL);

            c = let (letbind (var (v1), C(R(p))),
                     let (letbind (C(LL(p)),
                                   proof (subty (var (v1), C(LR(p))),
                                          seqcast (C(LR(p)), var (v1)))),
                          NULL));

	    /* set global information */
	    LL(R(c))->sem.var->global = true;

            if (var_decls.root)
                var_decls.hole->child[1] = c;
            else
                var_decls.root = c;

            var_decls.hole = c->child[1];

        } break;

        /* VariableDeclaration:    var_decl (var_type (Var,
                                                       OptSequenceType_),
                                             external) */
        case 47:
            /* FIXME: What to do here? */
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "external variables not yet implemented");
            break;

        /* QueryBody:              OptExpr */
        case 48:
            assert (C(p));
            break;

        /* OptExpr:                empty_seq */
        case 49:
            C(p) = empty ();
            break;

        /* OptExpr:                Expr */
        case 50:
            assert (C(p));
            break;

        /* Expr:                   exprseq (OptExpr, OptExpr) */
        case 51:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
        
            C(p) = let (letbind (var (v1), C(L(p))),
                        let (letbind (var (v2), C(R(p))),
                             seq (var (v1), var (v2))));
        } break;

        /* Expr:                   ExprSingle */
        case 52:
            assert (C(p));
            break;

        /* ExprSingle:             FLWORExpr */
        case 53:
            break;

        /* ExprSingle:             QuantifiedExpr */
        case 54:
            break;

        /* ExprSingle:             TypeswitchExpr */
        case 55:
            break;

        /* ExprSingle:             IfExpr */
        case 56:
            break;

        /* ExprSingle:             OrExpr */
        case 57:
            break;

        /* FLWORExpr:              flwr (binds (let (var_type (Var,
                                                               nil),
                                                     OptExpr),
                                                nil),
                                         where (OptWhereClause_,
                                                OrderByReturn)) */
        case 58:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = let (letbind (C(LLLL(p)), C(LLR(p))),
                        let (letbind (var (v), C(RL(p))),
                             if_ (var (v),
                                  then_else (C(RR(p)), empty ()))));

        } break;

        /* FLWORExpr:              flwr (binds (let (var_type (Var,
                                                               TypeDeclaration),
                                                     OptExpr),
                                                nil),
                                         where (OptWhereClause_,
                                                OrderByReturn)) */
        case 59:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);

            C(p) = let (letbind (var (v1), C(LLR(p))),
                        let (letbind (C(LLLL(p)),
                                      proof (subty (var (v1), C(LLLR(p))),
                                             seqcast (C(LLLR(p)), var (v1)))),
                             let (letbind (var (v2), C(RL(p))),
                                  if_ (var (v2),
                                       then_else (C(RR(p)), empty ())))));
                        
        } break;

        /* FLWORExpr:              flwr (binds (bind (vars (var_type (Var,
                                                                      nil),
                                                            OptPosVar),
                                                      OptExpr),
                                                nil),
                                         where (OptWhereClause_,
                                                OrderByReturn)) */
        case 60:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);

            C(p) = let (letbind (var (v1), C(LLR(p))),
                        for_ (forbind (forvars (C(LLLLL(p)), C(LLLR(p))),
                                       var (v1)),
                              let (letbind (var (v2), C(RL(p))),
                                   if_ (var (v2),
                                        then_else (C(RR(p)), empty ())))));
        } break;

        /* FLWORExpr:              flwr (binds (bind (vars (var_type (Var,
                                                                      TypeDecl),
                                                            OptPosVar),
                                                      OptExpr),
                                                nil),
                                         where (OptWhereClause_,
                                                OrderByReturn)) */
        case 61:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);

            C(p) = let (letbind (var (v1), C(LLR(p))),
                        for_ (forbind (forvars (var (v2), C(LLLR(p))),
                                       var (v1)),
                              let (letbind (C(LLLLL(p)),
                                            proof (subty (var (v2),
                                                          C(LLLLR(p))),
                                                   seqcast (C(LLLLR(p)),
                                                            var (v2)))),
                                   let (letbind (var (v3), C(RL(p))),
                                        if_ (var (v3),
                                             then_else (C(RR(p)), empty()))))));
        } break;

        /* OrderByReturn:          ord_ret (nil, OptExpr) */
        case 62:
            C(p) = C(R(p));
            break;

        /* OrderByReturn:          ord_ret (OrderByClause, OptExpr) */
        case 63:
            C(p) = orderby (C(L(p)), C(R(p)));
            break;

        /* OptPosVar:              nil */
        case 64:
            C(p) = nil ();
            break;

        /* OptPosVar:              Var */
        case 65:
            break;

        /* TypeDeclaration:        SequenceType */
        case 66:
            break;

        /* OptWhereClause_:        nil */
        case 67:
            C(p) = true_ ();
            break;

        /* OptWhereClause_:        OptExpr */
        case 68:
            C(p) = ebv (C(p));
            break;

        /* OrderByClause:          orderby (OrderSpecList) */
        case 69:
            C(p) = C(L(p));
            break;

        /* OrderSpecList:          nil */
        case 70:
            C(p) = nil ();
            break;

        /* OrderSpecList:          orderspecs (OptExpr, OrderSpecList) */
        case 71:
            C(p) = orderspecs (p->sem.mode, fn_data (C(L(p))), C(R(p)));
            break;

        /* QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                                      nil),
                                                            nil),
                                                      OptExpr),
                                                nil),
                                         OptExpr) */
        case 72:
            C(p) = some (C(LLLLL(p)), C(LLR(p)), C(R(p)));
            break;

        /* QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                                      TypeDecl),
                                                            nil),
                                                      OptExpr),
                                                nil),
                                         OptExpr) */
        case 73:
        {
            PFvar_t *v1 = new_var (NULL);

            C(p) = some (var (v1), C(LLR(p)),
                         let (
                             letbind (
                                 C(LLLLL(p)),
                                 proof (subty (var (v1), C(LLLLR(p))),
                                        seqcast (C(LLLLR(p)), var (v1)))),
                             C(R(p))));

        } break;


        /* QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                                       nil),
                                                             nil),
                                                       OptExpr),
                                                 nil),
                                          OptExpr) */
        case 74:
        {
            /* every $a in e1 satisfies e2
             *  ==
             * not (some $a in e1 satisfies not (e2))
             *  ==
             * let $v1 := some $a in e1 satisfies
             *              let $v2 := e2 return not ($v2) return
             *   not ($v1)
             */
            PFvar_t *v1     = new_var (NULL);
            PFvar_t *v2     = new_var (NULL);
            PFfun_t *fn_not = function (PFqname (PFns_fn, "not"));

            C(p) = let (
                    letbind (
                        var (v1), 
                        some (
                            C(LLLLL(p)),
                            C(LLR(p)),
                            let (letbind (var (v2), C(R(p))),
                                 APPLY (fn_not, (var (v2)))))),
                    APPLY (fn_not, (var (v1))));

        } break;

        /* QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                                       TypeDec),
                                                             nil),
                                                       OptExpr),
                                                 nil),
                                          OptExpr) */
        case 75:
        {
            /* every $a as t in e1 satisfies e2
             *  ==
             * not (some $a as t in e1 satisfies not (e2))
             *  ==
             * let $v1 := some $a as t in e1 satisfies
             *              let $v2 := e2 return not ($v2) return
             *   not ($v1)
             *  ==
             * let $v1 :=
             *   some $v3 in e1 satisfies
             *     let $a := proof ($v3, t, seqcast (t, $v3)) return
             *       let $v2 := e2 return not ($v2) return
             *   not ($v1)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);
            PFfun_t *fn_not   = function (PFqname (PFns_fn, "not"));

            C(p) = let (
                    letbind (
                        var (v1), 
                        some (
                            var (v3),
                            C(LLR(p)),
                            let (
                                letbind (
                                    C(LLLLL(p)),
                                    proof (subty (var (v3), C(LLLLR(p))),
                                           seqcast (C(LLLLR(p)), var (v3)))),
                                let (letbind (var (v2), C(R(p))),
                                     APPLY (fn_not, var (v2)))))),
                    APPLY (fn_not, (var (v1))));

        } break;

        /* TypeswitchExpr:         typeswitch (
                                       Expr,
                                       cases (case_ (var_type (OptCaseVar,
                                                               SequenceType),
                                                     OptExpr),
                                              cases (default_ (OptCaseVar,
                                                               OptExpr),
                                                     nil))) */
        case 76:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = let (letbind (var (v), C(L(p))),
                        typeswitch (
                            var (v),
                            cases (
                                case_ (
                                    C(RLLR(p)),
                                    let (letbind (C(RLLL(p)), var (v)),
                                         C(RLR(p)))),
                                default_ (
                                    let (letbind (C(RRLL(p)), var (v)),
                                         C(RRLR(p)))))));
        } break;

        /* OptCaseVar:             nil */
        case 77:
            /*
             * Generate new variable in case no variable has been
             * specified for case/default branch of typeswitch.
             */
            C(p) = var (new_var ("tsw"));
            break;

        /* OptCaseVar:             Var */
        case 78:
            assert (C(p));
            break;

        /* SequenceType:           seq_ty (ItemType) */
        case 79:
            /* fall through */

        /* SingleType:             seq_ty (AtomType) */
        case 80:
            switch (p->sem.oci) {
                case p_one:
                    C(p) = C(L(p));
                    break;
                case p_zero_or_one:
                    C(p) = seqtype (PFty_opt (C(L(p))->sem.type));
                    break;
                case p_zero_or_more:
                    C(p) = seqtype (PFty_star (C(L(p))->sem.type));
                    break;
                case p_one_or_more:
                    C(p) = seqtype (PFty_plus (C(L(p))->sem.type));
                    break;
                default:
                    PFoops_loc (OOPS_FATAL, p->loc,
                                "illegal occurrence indicator (%d) in "
                                "sequence type", p->sem.oci);
                    break;
            } break;
            
        /* ItemType:               empty_ty */
        case 81:
            C(p) = seqtype (PFty_empty ());
            break;

        /* ItemType:               NodeTest */
        case 82:
            assert (C(p));
            break;

        /* ItemType:               item_ty (nil) */
        case 83:
            C(p) = seqtype (PFty_xs_anyItem ());
            break;

        /* ItemType:               atom_ty (nil) */
        case 84:
            /* is the referenced type a known schema type? */
            if (! PFty_schema (PFty_named (p->sem.qname)))
                PFoops_loc (OOPS_TYPENOTDEF, p->loc,
                        "``%s''",
                        PFqname_str (p->sem.qname));

            C(p) = seqtype (PFty_named (p->sem.qname));
            break;

        /* ItemType:               schm_elem */
        case 85:
            /* FIXME: This probably requires work in the type system */
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "schema-element types are not supported");
            break;

        /* ItemType:               schm_attr */
        case 86:
            /* FIXME: This probably requires work in the type system */
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "schema-attribute types are not supported");
            break;

        /* AtomType:               atom_ty (nil) */
        case 87:
            /* is the referenced type a known schema type? */
            if (! PFty_schema (PFty_named (p->sem.qname)))
                PFoops_loc (OOPS_TYPENOTDEF, p->loc,
                        "``%s''",
                        PFqname_str (p->sem.qname));

            C(p) = seqtype (PFty_named (p->sem.qname));
            break;

        /* NodeTest:               node_ty (nil) */
        case 88:
            switch (p->sem.kind) {
                case p_kind_node:
                    /* node */
                    C(p) = seqtype (PFty_xs_anyNode ());
                    break;
                case p_kind_comment:
                    /* comment */
                    C(p) = seqtype (PFty_comm ());
                    break;
                case p_kind_text:
                    /* text */
                    C(p) = seqtype (PFty_text ());
                    break;
                case p_kind_pi:
                    /* processing-instruction */
                    C(p) = seqtype (PFty_pi (NULL));
                    break;
                case p_kind_doc:
                    /* document */
                    C(p) = seqtype (PFty_doc (PFty_xs_anyType ()));
                    break;
                case p_kind_elem:
                    /* element */
                    C(p) = seqtype (PFty_elem (PFqname (PFns_wild, NULL),
                                PFty_xs_anyType ()));
                    break;
                case p_kind_attr:
                    /* attribute */
                    C(p) = seqtype (PFty_attr (PFqname (PFns_wild, NULL),
                                               PFty_star (PFty_atomic ())));
                    break;
                default:
                    PFoops_loc (OOPS_FATAL, p->loc,
                                "illegal node kind in node type");
            }
            break;

        /* NodeTest:               node_ty (ElemOrAttrType) */
        case 89:
            /* TOPDOWN */

            switch (p->sem.kind) {
                case p_kind_elem:
                    elem_attr = PFty_elem;
                    any = PFty_xs_anyType ();
                    break;
                case p_kind_attr:
                    elem_attr = PFty_attr;
                    any = PFty_star (PFty_atomic ());
                    break;
                default:
                    PFoops_loc (OOPS_FATAL, p->loc,
                                "illegal node kind in NodeTest");
            }

            reduce (kids[0], nts[0]);

            C(p) = C(L(p));
            break;

        /* NodeTest:               node_ty (node_ty (nil)) */
        case 90:
            assert (p->sem.kind == p_kind_doc);
            assert (L(p)->sem.kind == p_kind_elem);

            C(p) = seqtype (PFty_doc (PFty_xs_anyElement ()));
            break;

        /* NodeTest:               node_ty (node_ty (ElemOrAttrType)) */
        case 91:
            /* TOPDOWN */

            assert (p->sem.kind == p_kind_doc);
            assert (L(p)->sem.kind == p_kind_elem);

            elem_attr = PFty_elem;
            any = PFty_xs_anyType ();

            reduce (kids[0], nts[0]);

            C(p) = seqtype (PFty_doc (C(LL(p))->sem.type));
            break;

        /* NodeTest:               node_ty (lit_str) */
        case 92:
            /*
             * processing-instruction tests may have a string
             * argument (restricting the pi target)
             */
            assert (p->sem.kind == p_kind_pi);
            C(p) = seqtype (PFty_pi (L(p)->sem.str));
            break;

        /* ElemOrAttrType:         req_ty (nil, nil) */
        case 93:
            /* element/attribute: any name, any type */
            C(p) = seqtype (elem_attr (PFqname (PFns_wild, NULL), any));
            break;
     
        /* ElemOrAttrType:         req_ty (nil, SchemaType) */
        case 94:
            /* element/attribute: any name, given type */
            C(p) = seqtype (elem_attr (PFqname (PFns_wild, NULL),
                                       C(R(p))->sem.type));
            break;

        /* ElemOrAttrType:         req_ty (req_name, nil) */
        case 95:
            /* element/attribute: given name, any type */
            C(p) = seqtype (elem_attr (L(p)->sem.qname, any));
            break;


        /* ElemOrAttrType:         req_ty (req_name, SchemaType) */
        case 96:
            /* element/attribute: given name, given type */
            C(p) = seqtype (elem_attr (L(p)->sem.qname, C(R(p))->sem.type));
            break;

        /* SchemaType:             named_ty */
        case 97:
            /* is the referenced type a known schema type definition? */
            if (! PFty_schema (PFty_named (p->sem.qname)))
                PFoops_loc (OOPS_TYPENOTDEF, p->loc,
                            "``%s''",
                            PFqname_str (p->sem.qname));

            C(p) = seqtype (PFty_named (p->sem.qname));
            break;

        /* IfExpr:                 if_ (Expr,
                                        then_else (OptExpr, OptExpr)) */
        case 98:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = let (letbind (var (v), ebv (C(L(p)))),
                        if_ (var (v),
                             then_else (C(RL(p)), C(RR(p)))));
        } break;

        /* OrExpr:                 AndExpr */
        case 99:
            break;

        /* OrExpr:                 or (AndExpr, OrExpr) */
        case 100:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_or = function (PFqname (PFns_op, "or"));

            C(p) = let (letbind (var (v1), ebv (C(L(p)))),
                    let (letbind (var (v2), ebv (C(R(p)))),
                        APPLY (op_or, var (v1), var (v2))));
        } break;

        /* AndExpr:                ComparisonExpr */
        case 101:
            break;

        /* AndExpr:                and (ComparisonExpr, AndExpr) */
        case 102:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_and = function (PFqname (PFns_op, "and"));

            C(p) = let (letbind (var (v1), ebv (C(L(p)))),
                    let (letbind (var (v2), ebv (C(R(p)))),
                        APPLY (op_and, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         RangeExpr */
        case 103:
            break;

        /* ComparisonExpr:         eq (RangeExpr, RangeExpr) */
        case 104:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *u1 = new_var (NULL);
            PFvar_t *u2 = new_var (NULL);
            PFfun_t *op_eq = function (PFqname (PFns_op, "eq"));

            C(p) = some (var (v1), fn_data (C(L(p))),
                    some (
                        var (v2), fn_data (C(R(p))),
                        let (
                            letbind (
                                var (u1),
                                fs_convert_op_by_type (
                                    fs_convert_op_by_expr (var (v1), var (v2)),
                                    PFty_xs_string ())),
                            let (
                                letbind (
                                    var (u2),
                                    fs_convert_op_by_type (
                                        fs_convert_op_by_expr (var (v2),
                                                               var (v1)),
                                        PFty_xs_string ())),
                                APPLY (op_eq, var (u1), var (u2))))));
        } break;

        /* ComparisonExpr:         ne (RangeExpr, RangeExpr) */
        case 105:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *u1 = new_var (NULL);
            PFvar_t *u2 = new_var (NULL);
            PFfun_t *op_ne = function (PFqname (PFns_op, "ne"));

            C(p) = some (var (v1), fn_data (C(L(p))),
                    some (
                        var (v2), fn_data (C(R(p))),
                        let (
                            letbind (
                                var (u1),
                                fs_convert_op_by_type (
                                    fs_convert_op_by_expr (var (v1), var (v2)),
                                    PFty_xs_string ())),
                            let (
                                letbind (
                                    var (u2),
                                    fs_convert_op_by_type (
                                        fs_convert_op_by_expr (var (v2),
                                                               var (v1)),
                                        PFty_xs_string ())),
                                APPLY (op_ne, var (u1), var (u2))))));
        } break;

        /* ComparisonExpr:         lt (RangeExpr, RangeExpr) */
        case 106:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *u1 = new_var (NULL);
            PFvar_t *u2 = new_var (NULL);
            PFfun_t *op_lt = function (PFqname (PFns_op, "lt"));

            C(p) = some (var (v1), fn_data (C(L(p))),
                    some (
                        var (v2), fn_data (C(R(p))),
                        let (
                            letbind (
                                var (u1),
                                fs_convert_op_by_type (
                                    fs_convert_op_by_expr (var (v1), var (v2)),
                                    PFty_xs_string ())),
                            let (
                                letbind (
                                    var (u2),
                                    fs_convert_op_by_type (
                                        fs_convert_op_by_expr (var (v2),
                                                               var (v1)),
                                        PFty_xs_string ())),
                                APPLY (op_lt, var (u1), var (u2))))));
        } break;

        /* ComparisonExpr:         le (RangeExpr, RangeExpr) */
        case 107:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *u1 = new_var (NULL);
            PFvar_t *u2 = new_var (NULL);
            PFfun_t *op_le = function (PFqname (PFns_op, "le"));

            C(p) = some (var (v1), fn_data (C(L(p))),
                    some (
                        var (v2), fn_data (C(R(p))),
                        let (
                            letbind (
                                var (u1),
                                fs_convert_op_by_type (
                                    fs_convert_op_by_expr (var (v1), var (v2)),
                                    PFty_xs_string ())),
                            let (
                                letbind (
                                    var (u2),
                                    fs_convert_op_by_type (
                                        fs_convert_op_by_expr (var (v2),
                                                               var (v1)),
                                        PFty_xs_string ())),
                                APPLY (op_le, var (u1), var (u2))))));
        } break;

        /* ComparisonExpr:         gt (RangeExpr, RangeExpr) */
        case 108:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *u1 = new_var (NULL);
            PFvar_t *u2 = new_var (NULL);
            PFfun_t *op_gt = function (PFqname (PFns_op, "gt"));

            C(p) = some (var (v1), fn_data (C(L(p))),
                    some (
                        var (v2), fn_data (C(R(p))),
                        let (
                            letbind (
                                var (u1),
                                fs_convert_op_by_type (
                                    fs_convert_op_by_expr (var (v1), var (v2)),
                                    PFty_xs_string ())),
                            let (
                                letbind (
                                    var (u2),
                                    fs_convert_op_by_type (
                                        fs_convert_op_by_expr (var (v2),
                                                               var (v1)),
                                        PFty_xs_string ())),
                                APPLY (op_gt, var (u1), var (u2))))));
        } break;

        /* ComparisonExpr:         ge (RangeExpr, RangeExpr) */
        case 109:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *u1 = new_var (NULL);
            PFvar_t *u2 = new_var (NULL);
            PFfun_t *op_ge = function (PFqname (PFns_op, "ge"));

            C(p) = some (var (v1), fn_data (C(L(p))),
                    some (
                        var (v2), fn_data (C(R(p))),
                        let (
                            letbind (
                                var (u1),
                                fs_convert_op_by_type (
                                    fs_convert_op_by_expr (var (v1), var (v2)),
                                    PFty_xs_string ())),
                            let (
                                letbind (
                                    var (u2),
                                    fs_convert_op_by_type (
                                        fs_convert_op_by_expr (var (v2),
                                                               var (v1)),
                                        PFty_xs_string ())),
                                APPLY (op_ge, var (u1), var (u2))))));
        } break;

        /* ComparisonExpr:         val_eq (RangeExpr, RangeExpr) */
        case 110:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_eq = function (PFqname (PFns_op, "eq"));

            C(p) = let (
                     letbind (
                         var (v1),
                         fs_convert_op_by_type (fn_data (C(L(p))),
                                                PFty_xs_string ())),
                     let (
                         letbind (
                             var (v2),
                             fs_convert_op_by_type (fn_data (C(R(p))),
                                                    PFty_xs_string ())),
                         APPLY (op_eq, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         val_ne (RangeExpr, RangeExpr) */
        case 111:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_ne = function (PFqname (PFns_op, "ne"));

            C(p) = let (
                     letbind (
                         var (v1),
                         fs_convert_op_by_type (fn_data (C(L(p))),
                                                PFty_xs_string ())),
                     let (
                         letbind (
                             var (v2),
                             fs_convert_op_by_type (fn_data (C(R(p))),
                                                    PFty_xs_string ())),
                         APPLY (op_ne, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         val_lt (RangeExpr, RangeExpr) */
        case 112:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_lt = function (PFqname (PFns_op, "lt"));

            C(p) = let (
                     letbind (
                         var (v1),
                         fs_convert_op_by_type (fn_data (C(L(p))),
                                                PFty_xs_string ())),
                     let (
                         letbind (
                             var (v2),
                             fs_convert_op_by_type (fn_data (C(R(p))),
                                                    PFty_xs_string ())),
                         APPLY (op_lt, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         val_le (RangeExpr, RangeExpr) */
        case 113:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_le = function (PFqname (PFns_op, "le"));

            C(p) = let (
                     letbind (
                         var (v1),
                         fs_convert_op_by_type (fn_data (C(L(p))),
                                                PFty_xs_string ())),
                     let (
                         letbind (
                             var (v2),
                             fs_convert_op_by_type (fn_data (C(R(p))),
                                                    PFty_xs_string ())),
                         APPLY (op_le, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         val_gt (RangeExpr, RangeExpr) */
        case 114:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_gt = function (PFqname (PFns_op, "gt"));

            C(p) = let (
                     letbind (
                         var (v1),
                         fs_convert_op_by_type (fn_data (C(L(p))),
                                                PFty_xs_string ())),
                     let (
                         letbind (
                             var (v2),
                             fs_convert_op_by_type (fn_data (C(R(p))),
                                                    PFty_xs_string ())),
                         APPLY (op_gt, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         val_ge (RangeExpr, RangeExpr) */
        case 115:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_ge = function (PFqname (PFns_op, "ge"));

            C(p) = let (
                     letbind (
                         var (v1),
                         fs_convert_op_by_type (fn_data (C(L(p))),
                                                PFty_xs_string ())),
                     let (
                         letbind (
                             var (v2),
                             fs_convert_op_by_type (fn_data (C(R(p))),
                                                    PFty_xs_string ())),
                         APPLY (op_ge, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         is (RangeExpr, RangeExpr) */
        case 116:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_is = function (PFqname (PFns_op, "is-same-node"));

            C(p) = let (letbind (var (v1), C(L(p))),
                    let (letbind (var (v2), C(R(p))),
                        APPLY (op_is, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         nis (RangeExpr, RangeExpr) */
        case 117:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);
            PFvar_t *v4 = new_var (NULL);
            PFvar_t *v5 = new_var (NULL);
            PFfun_t *op_is = function (PFqname (PFns_op, "is-same-node"));
            PFfun_t *fn_not = function (PFqname (PFns_fn, "not"));

            C(p) = let (letbind (var (v1), C(L(p))),
                    let (letbind (var (v2), C(R(p))),
                        let (letbind (var (v3),
                                      APPLY (op_is, var (v1), var (v2))),
                             let (letbind (var (v4),
                                           APPLY (fn_not, PFcore_var (v3))),
                                  PFcore_var (v5)))));
        } break;

        /* ComparisonExpr:         ltlt (RangeExpr, RangeExpr) */
        case 118:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_ltlt = function (PFqname (PFns_op, "node-before"));

            C(p) = let (letbind (var (v1), C(L(p))),
                    let (letbind (var (v2), C(R(p))),
                        APPLY (op_ltlt, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         gtgt (RangeExpr, RangeExpr) */
        case 119:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_gtgt = function (PFqname (PFns_op, "node-after"));

            C(p) = let (letbind (var (v1), C(L(p))),
                    let (letbind (var (v2), C(R(p))),
                        APPLY (op_gtgt, var (v1), var (v2))));
        } break;

        /* RangeExpr:              AdditiveExpr */
        case 120:
            break;

        /* RangeExpr:              range (RangeExpr, RangeExpr) */
        case 121:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_to = function (PFqname (PFns_op, "to"));

            C(p) = let (letbind (var (v1), C(L(p))),
                    let (letbind (var (v2), C(R(p))),
                        APPLY (op_to, var (v1), var (v2))));
        } break;

        /* AdditiveExpr:           MultiplicativeExpr */
        case 122:
            break;

        /* AdditiveExpr:           plus (AdditiveExpr, MultiplicativeExpr) */
        case 123:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_plus = function (PFqname (PFns_op, "plus"));

            C(p) = let (
                    letbind (
                        var (v1),
                        fs_convert_op_by_type (fn_data (C(L(p))),
                                               PFty_xs_double ())),
                    let (
                        letbind (
                            var (v2),
                            fs_convert_op_by_type (fn_data (C(R(p))),
                                                   PFty_xs_double ())),
                        APPLY (op_plus, var (v1), var (v2))));
        } break;

        /* AdditiveExpr:           minus (AdditiveExpr, MultiplicativeExpr) */
        case 124:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_minus = function (PFqname (PFns_op, "minus"));

            C(p) = let (
                    letbind (
                        var (v1),
                        fs_convert_op_by_type (fn_data (C(L(p))),
                                               PFty_xs_double ())),
                    let (
                        letbind (
                            var (v2),
                            fs_convert_op_by_type (fn_data (C(R(p))),
                                                   PFty_xs_double ())),
                        APPLY (op_minus, var (v1), var (v2))));
        } break;

        /* MultiplicativeExpr:     UnionExpr */
        case 125:
            break;

        /* MultiplicativeExpr:     mult (UnionExpr, MultiplicativeExpr) */
        case 126:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_times = function (PFqname (PFns_op, "times"));

            C(p) = let (
                    letbind (
                        var (v1),
                        fs_convert_op_by_type (fn_data (C(L(p))),
                                               PFty_xs_double ())),
                    let (
                        letbind (
                            var (v2),
                            fs_convert_op_by_type (fn_data (C(R(p))),
                                                   PFty_xs_double ())),
                        APPLY (op_times, var (v1), var (v2))));
        } break;

        /* MultiplicativeExpr:     div (UnionExpr, MultiplicativeExpr) */
        case 127:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_div = function (PFqname (PFns_op, "div"));

            C(p) = let (
                    letbind (
                        var (v1),
                        fs_convert_op_by_type (fn_data (C(L(p))),
                                               PFty_xs_double ())),
                    let (
                        letbind (
                            var (v2),
                            fs_convert_op_by_type (fn_data (C(R(p))),
                                                   PFty_xs_double ())),
                        APPLY (op_div, var (v1), var (v2))));
        } break;

        /* MultiplicativeExpr:     idiv (UnionExpr, MultiplicativeExpr) */
        case 128:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_idiv = function (PFqname (PFns_op, "idiv"));

            C(p) = let (
                    letbind (
                        var (v1),
                        fs_convert_op_by_type (fn_data (C(L(p))),
                                               PFty_xs_double ())),
                    let (
                        letbind (
                            var (v2),
                            fs_convert_op_by_type (fn_data (C(R(p))),
                                                   PFty_xs_double ())),
                        APPLY (op_idiv, var (v1), var (v2))));
        } break;

        /* MultiplicativeExpr:     mod (UnionExpr, MultiplicativeExpr) */
        case 129:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_mod = function (PFqname (PFns_op, "mod"));

            C(p) = let (
                    letbind (
                        var (v1),
                        fs_convert_op_by_type (fn_data (C(L(p))),
                                               PFty_xs_double ())),
                    let (
                        letbind (
                            var (v2),
                            fs_convert_op_by_type (fn_data (C(R(p))),
                                                   PFty_xs_double ())),
                        APPLY (op_mod, var (v1), var (v2))));
        } break;

        /* UnionExpr:              IntersectExceptExpr */
        case 130:
            break;

        /* UnionExpr:              union_ (IntersectExceptExpr, UnionExpr) */
        case 131:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_union = function (PFqname (PFns_op, "union"));

            C(p) = let (letbind (var (v1), C(L(p))),
                    let (letbind (var (v2), C(R(p))),
                        APPLY (op_union, var (v1), var (v2))));
        } break;

        /* IntersectExceptExpr:    InstanceofExpr */
        case 132:
            break;

        /* IntersectExceptExpr:    intersect (InstanceofExpr,
                                              IntersectExceptExpr) */
        case 133:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_intersect = function (PFqname (PFns_op, "intersect"));

            C(p) = let (letbind (var (v1), C(L(p))),
                    let (letbind (var (v2), C(R(p))),
                        APPLY (op_intersect, var (v1), var (v2))));
        } break;

        /* IntersectExceptExpr:    except (InstanceofExpr,
                                           IntersectExceptExpr) */
        case 134:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_except = function (PFqname (PFns_op, "except"));

            C(p) = let (letbind (var (v1), C(L(p))),
                    let (letbind (var (v2), C(R(p))),
                        APPLY (op_except, var (v1), var (v2))));
        } break;

        /* InstanceofExpr:         TreatExpr */
        case 135:
            break;

        /* InstanceofExpr:         instof (TreatExpr, SequenceType) */
        case 136:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = let (letbind (var (v), C(L(p))),
                        typeswitch (
                            var (v),
                            cases (
                                case_ (C(R(p)), true_ ()),
                                default_ (false_ ()))));
        } break;

        /* TreatExpr:              CastableExpr */
        case 137:
            break;

        /* TreatExpr:              treat (CastableExpr, SequenceType) */
        case 138:
        {
            PFvar_t *v1 = new_var (NULL);
            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));

            C(p) = let (letbind (var (v1), C(L(p))),
                        typeswitch (
                            var (v1),
                            cases (case_ (C(R(p)), var (v1)),
                                   default_ (APPLY (fn_error, str("err:XP0050"))))));
        } break;

        /* CastableExpr:           CastExpr */
        case 139:
            break;

        /* CastableExpr:           castable (CastExpr, SingleType) */
        case 140:
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "`castable' keyword is not supported");
            break;

        /* CastExpr:               UnaryExpr */
        case 141:
            break;

        /* CastExpr:               cast (UnaryExpr, SingleType) */
        case 142:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);

            C(p) = let (letbind (var (v1), C(L(p))),
                        let (letbind (var (v2), fn_data (var (v1))),
                             cast (C(R(p)), var (v2))));
        } break;

        /* UnaryExpr:              ValueExpr */
        case 143:
            break;

        /* UnaryExpr:              uminus (ValueExpr) */
        case 144:
        {
            PFvar_t *v = new_var (NULL);
            PFfun_t *op_minus = function (PFqname (PFns_op, "minus"));

            C(p) = let (
                    letbind (
                        var (v),
                        fs_convert_op_by_type (fn_data (C(L(p))),
                                               PFty_xs_double ())),
                    APPLY (op_minus, num (0), var (v)));
        } break;

        /* UnaryExpr:              uplus (ValueExpr) */
        case 145:
        {
            PFvar_t *v = new_var (NULL);
            PFfun_t *op_plus = function (PFqname (PFns_op, "plus"));

            C(p) = let (
                    letbind (
                        var (v),
                        fs_convert_op_by_type (fn_data (C(L(p))),
                                               PFty_xs_double ())),
                    APPLY (op_plus, num (0), var (v)));
        } break;

        /* ValueExpr:              ValidateExpr */
        case 146:
            break;

        /* ValueExpr:              PathExpr */
        case 147:
            break;

        /* ValidateExpr:           validate (Expr) */
        case 148:
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc, "validation not supported");
            break;

        /* PathExpr:               StepExpr */
        case 149:
            assert (C(p));
            break;

        /* PathExpr:               LocationPath */
        case 150:
            assert (C(p));
            break;

        /* LocationPath:           root_ */
        case 151:
        {
            PFfun_t *_root = function (PFqname (PFns_fn, "root"));

            if (fs_dot)     
                C(p) = APPLY (_root, var (fs_dot));
            else
                PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");
        } break;

        /* LocationPath:           locpath (StepExpr, StepExpr) */
        case 152:
        {
            /* TOPDOWN */

            /*
             * A path expression E1/E2 is to be evaluated as follows:
             * (see XQuery Oct 2004 WD, Section 3.2)
             *
             * (1) Expression E1 is evaluated, and if the result is not
             *     a (possibly empty) sequence of nodes, a type error
             *     is raised.
             *
             * (2) Each node resulting from the evaluation of E1 then
             *     serves in turn to provide an inner focus for an
             *     evaluation of E2.
             *
             * (3) The sequences resulting from all the evaluations of
             *     E2 are combined as follows:
             *
             *     -- If every evaluation of E2 returns a (possibly empty)
             *        sequence of nodes, these sequences are combined,
             *        and duplicate nodes are eliminated. If ordering mode
             *        is ordered, the resulting node sequence is returned
             *        in document order.
             *     -- If every evaluation of E2 returns a (possibly empty)
             *        sequence of atomic values, these sequences are
             *        concatenated, in order, and returned.
             *     -- Otherwise (that is, if the multiple evaluations of
             *        E2 return at least one node and at least one atomic
             *        value), a type error is raised.
             *
             * In XQuery Core:
             *
             * let $v1 := E1 return
             *   typeswitch ($v1)
             *     case node* return
             *       let $v2 := let $fs:last := fn:count ($v1) return
             *                    for $fs:dot at $fs:position in $v1 return E2
             *         return
             *         typeswitch ($v2)
             *           case $v3 as node* return fs:distinct-doc-order ($v3)
             *           default typeswitch ($v2)
             *                     case atomic* return $v2
             *                     default error (err:XP0018)
             *     default error (err:XP0019)
             */

            PFvar_t *dot;
            PFvar_t *position;
            PFvar_t *last;
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);

            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));
            PFfun_t *count = function (PFqname (PFns_fn, "count"));
            PFfun_t *ddo = function (PFqname (PFns_pf, "distinct-doc-order"));

            /* compile context first */
            reduce (kids[1], nts[1]);

            /*
             * save context items $fs:dot, $fs:position, $fs:last
             * and establish new context item
             */
            dot = fs_dot;
            fs_dot = new_var ("dot");
            position = fs_position;
            fs_position = new_var ("pos");
            last = fs_last;
            fs_last = new_var ("lst");

            /* compile step in this new context */
            reduce (kids[0], nts[0]);

            C(p) =
                let (
                  letbind (var (v1), C(R(p))),
                  typeswitch (
                    var (v1),
                    cases (
                      case_ (
                        seqtype (PFty_star (PFty_xs_anyNode ())),
                        let (
                          letbind (
                            var (v2),
                            let (
                              letbind (var (fs_last), APPLY (count, var (v1))),
                              for_ (
                                forbind (forvars (var (fs_dot),
                                                  var (fs_position)),
                                         var (v1)),
                                C(L(p))))),
                          typeswitch (
                            var (v2),
                            cases (
                              case_ (
                                seqtype (PFty_star (PFty_xs_anyNode ())),
                                let (
                                    letbind (
                                        var (v3),
                                        seqcast (seqtype (
                                                   PFty_star (
                                                     PFty_xs_anyNode ())),
                                                 var (v2))),
                                     APPLY (ddo, var (v3)))),
                              default_ (
                                typeswitch (
                                  var (v2),
                                  cases (
                                    case_ (
                                      seqtype (
                                          PFty_star (PFty_atomic ())),
                                      var (v2)),
                                    default_ (
                                      APPLY (fn_error, str ("err:XP0018")))
                                    ))))))),
                      default_ (
                        APPLY (fn_error,
                               str ("err:XP0019: Argument to location step "
                                    "must be a node sequence."))))));

            /* restore context items */
            fs_dot = dot;
            fs_position = position;
            fs_last = last;

        } break;

        /* LocationPath:           locpath (LocationStep, StepExpr) */
        case 153:
        {   /*
             * For regular location steps, we don't actually need the
             * complicated stuff in the above rule.
             *
             * let $v1 := StepExpr return
             *   typeswitch ($v1)
             *     case node* return
             *                  let $v2 := $v1/LocationStep return
             *                    fs:distinct-doc-order ($v2)
             *     default error (err:XP0019)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *ddo = function (PFqname (PFns_pf, "distinct-doc-order"));
            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));

            C(p) = let (letbind (var (v1), C(R(p))),
                        typeswitch (
                          var (v1),
                          cases (
                            case_ (seqtype (PFty_star (PFty_xs_anyNode ())),
                              let (letbind (var (v2), locsteps (C(L(p)),
                                                                var (v1))),
                                   APPLY (ddo, var (v2)))),
                            default_ (
                              APPLY (fn_error,
                                     str ("err:XP0019: Argument to location "
                                          "step must be a node sequence."))))));
        } break;

        /* StepExpr:               LocationStep */
        case 154:
            break;

        /* StepExpr:               FilterExpr */
        case 155:
            break;

        /* FilterExpr:             PrimaryExpr */
        case 156:
            break;

        /* FilterExpr:             pred (StepExpr, Expr) */
        case 157:
        {   /* TOPDOWN */

            /*
             * Predicate evaluation:
             *
             * e1[e2]
             *  ==
             * let $v1 := e1 return
             *   let $fs:last := fn:count ($v1) return
             *     for $fs:dot at $fs:position in $v1 return
             *       let $v2 := e2 return
             *         let $v3 :=
             *           typeswitch ($v2)
             *             case numeric return
             *               typeswitch ($v2)
             *                 case $v4 as xs:integer
             *                   return fn:eq ($v4, $fs:position)
             *                 case $v5 as xs:decimal
             *                   return fn:eq ($v5, $fs:position)
             *                 case $v6 as xs:double
             *                   return fn:eq ($v6, $fs:position)
             *                 default return   (: should actually not happen :)
             *                   let $v7 := $v2 cast as xs:double return
             *                     fn:eq ($v7, $fs:position)
             *             default return ebv ($v2)
             *           return
             *             if ($v3) then $fs:dot else ()
             *
             * Note:
             *   We explicitly line up the variants of type `numeric' here.
             *   (a simple `case $v4 as numeric return fn:eq ($v4, $fs:pos)'
             *   instead of the inner typeswitch would loose important
             *   static type information: $v4 would get static type numeric,
             *   and we would loose the (possibly more specific) type we
             *   inferred so far.)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);
            PFvar_t *v4 = new_var (NULL);
            PFvar_t *v5 = new_var (NULL);
            PFvar_t *v6 = new_var (NULL);
            PFvar_t *v7 = new_var (NULL);
            PFvar_t *dot;
            PFvar_t *position;
            PFvar_t *last;
            PFfun_t *count = function (PFqname (PFns_fn, "count"));
            PFfun_t *op_eq = function (PFqname (PFns_op, "eq"));

            /* compile e1 */
            reduce (kids[0], nts[0]);

            /*
             * save context items $fs:dot, $fs:position, $fs:last
             * and establish new context item
             */
            dot = fs_dot;
            fs_dot = new_var ("dot");
            position = fs_position;
            fs_position = new_var ("pos");
            last = fs_last;
            fs_last = new_var ("lst");

            /* compile predicate expression in this new context */
            reduce (kids[1], nts[1]);

            C(p) = let (
                    letbind (var (v1), C(L(p))),
                    let (
                      letbind (var (fs_last), APPLY (count, var (v1))),
                      for_ (
                        forbind (
                          forvars (var (fs_dot), var (fs_position)),
                          var (v1)),
                        let (
                          letbind (var (v2), C(R(p))),
                          let (
                            letbind (
                              var (v3),
                              typeswitch (
                                var (v2),
                                cases (
                                  case_ (
                                    seqtype (PFty_numeric ()),
                                    typeswitch (
                                      var (v2),
                                      cases (
                                        case_ (
                                          seqtype (PFty_xs_integer ()),
                                          let (
                                            letbind (var (v4),
                                                     seqcast (
                                                       seqtype (
                                                           PFty_xs_integer()),
                                                       var (v2))),
                                            APPLY (op_eq, var (v4),
                                                   var (fs_position)))),
                                        default_ (
                                          typeswitch (
                                            var (v2),
                                            cases (
                                              case_ (
                                                seqtype (PFty_xs_decimal ()),
                                                let (
                                                  letbind (
                                                    var (v5),
                                                    seqcast (
                                                      seqtype (
                                                            PFty_xs_decimal ()),
                                                      var (v2))),
                                                  APPLY (op_eq, var (v5),
                                                         var (fs_position)))),
                                              default_ (
                                                typeswitch (
                                                  var (v2),
                                                  cases (
                                                    case_ (
                                                      seqtype (
                                                        PFty_xs_double ()),
                                                      let (
                                                        letbind (
                                                          var (v6),
                                                          seqcast (
                                                            seqtype (
                                                              PFty_xs_double()),
                                                            var (v2))),
                                                        APPLY (op_eq, var (v6),
                                                               var (fs_position)
                                                               ))),
                                                    default_ (
                                                      let (
                                                        letbind (
                                                          var (v7),
                                                          cast (
                                                            seqtype (
                                                              PFty_xs_double()),
                                                            var (v2))),
                                                        APPLY (op_eq,
                                                               var (v7),
                                                               var (fs_position)
                                                            )))))))))))),
                                  default_ (ebv (var (v2)))))),
                            if_ (
                              var (v3),
                              then_else (var (fs_dot), empty ())))))));

            /* restore context items */
            fs_dot = dot;
            fs_position = position;
            fs_last = last;
        } break;

        /* LocationStep:           step (NodeTest) */
        case 158:
            assert (C(L(p)));
            C(p) = step (p->sem.axis, C(L(p)));
            break;

        /* PrimaryExpr:            Literal */
        case 159:
            break;

        /* PrimaryExpr:            Var */
        case 160:
            break;

        /* PrimaryExpr:            ParenthesizedExpr */
        case 161:
            break;

        /* PrimaryExpr:            ContextItemExpr */
        case 162:
            break;

        /* PrimaryExpr:            FunctionCall */
        case 163:
            break;

        /* PrimaryExpr:            Constructor */
        case 164:
            break;

        /* PrimaryExpr:            OrderedExpr */
        case 165:
            break;

        /* PrimaryExpr:            UnorderedExpr */
        case 166:
            break;
            
        /* Literal:                NumericLiteral */
        case 167:
            break;

        /* Literal:                StringLiteral */
        case 168:
            break;

        /* NumericLiteral:         IntegerLiteral */
        case 169:
            break;

        /* NumericLiteral:         DecimalLiteral */
        case 170:
            break;

        /* NumericLiteral:         DoubleLiteral */
        case 171:
            break;

        /* IntegerLiteral:         lit_int */
        case 172:
            C(p) = num (p->sem.num);
            break;

        /* DecimalLiteral:         lit_dec */
        case 173:
            C(p) = dec (p->sem.dec);
            break;

        /* DoubleLiteral:          lit_dbl */
        case 174:
            C(p) = dbl (p->sem.dbl);
            break;

        /* StringLiteral:          lit_str */
        case 175:
            C(p) = str (p->sem.str);
            break;

        /* Var:                    var */
        case 176:
            C(p) = var (p->sem.var);
            break;

        /* ParenthesizedExpr:      Expr */
        case 177:
            assert (C(p));
            break;

        /* ContextItemExpr:        dot */
        case 178:
            if (fs_dot)
                C(p) = var (fs_dot);
            else
                PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");
            break;

        /* FunctionCall:           apply (nil) */
        case 179:
            /*
             * There are some built-in functions with special
             * implicit semantics.
             */

            /*
             * Functions `fn:string', `fn:name', `fn:local-name', 
             * `fn:namespace-uri', `fn:root' with no arguments
             * implicitly get the current
             * context node `.' as their argument.
             */
            if ( (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "string")))
                || (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "name")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "local-name")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "namespace-uri")))
                || (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "root")))
               ) {
                if (fs_dot)
                    C(p) = APPLY (p->sem.fun, var (fs_dot));
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");

                break;
            }

            /*
             * Functions `fn:string-length', `fn:normalize-space',
             * `fn:number'
             * implicitly get the string-value of the current context
             * node `.' as their argument if called without any
             * arguments.
             */
            if ((!PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "string-length")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "normalize-space")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "number")))
               ) {
                if (fs_dot) {
                    PFvar_t *v = new_var (NULL);
                    C(p) = let (
                            letbind (
                                var (v),
                                APPLY (function (PFqname (PFns_fn, "string")),
                                       var (fs_dot))),
                            APPLY (p->sem.fun, var (v)));
                }
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");

                break;
            }

            /*
             * `fn:position' is available as variable $fs:position.
             */
            if (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "position"))){
                if (fs_position)
                    C(p) = var (fs_position);
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc,
                                "position information not available");
                break;
            }

            /*
             * `fn:last' is available as variable $fs:last.
             */
            if (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "last"))) {
                if (fs_last)
                    C(p) = var (fs_last);
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc,
                                "position information not available");
                break;
            }

            /*
             * In all other cases just call the respective function
             */
            C(p) = apply (p->sem.fun, nil ());
            break;

        /* FunctionCall:           apply (FuncArgList) */
        case 180:
            /* TOPDOWN */

            assert (PFqname_eq (p->sem.fun->qname,
                                PFqname (PFns_fn, "position")));

            *(PFfun_t **) PFarray_add (funs) = p->sem.fun;
            *(PFcnode_t **) PFarray_add (args) = nil ();
            *(unsigned short *) PFarray_add (arg_num) = 0;

            /*
             * Functions `fn:id', `fn:idref' with one argument
             * implicitly get the current context node `.' as
             * their second/last argument.
             */
            if (p->sem.fun->arity == 1 &&
                ((!PFqname_eq (p->sem.fun->qname,
                               PFqname (PFns_fn, "id")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "idref")))
                )
               ) {
                if (fs_dot)
                    *(PFcnode_t **) PFarray_top (args)
                        = arg (var (fs_dot), *(PFcnode_t **) PFarray_top (args));
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");
            }

            reduce (kids[0], nts[0]);

            PFarray_del (funs);
            PFarray_del (args);
            PFarray_del (arg_num);

            C(p) = C(L(p));

            break;

        /* FuncArgList:            nil */
        case 181:
        {
            PFfun_t *fun = *(PFfun_t **) PFarray_top (funs);

            C(p) = apply (fun, *(PFcnode_t **) PFarray_top (args));

        } break;

        /* FuncArgList:            args (Expr, FuncArgList) */
        case 182:
        {   /* TOPDOWN */
            
            /*
             * Apply ``function conversion rules'' (W3C XQuery 3.1.5).
             * See also helper function function_conversion().
             */
            PFvar_t      *v        = new_var (NULL);
            PFfun_t      *fun;
            PFty_t        expected;
            unsigned int  param_num;
            PFfun_t      *implicit = NULL;

            /* translate function argument */
            reduce (kids[0], nts[0]);

            /* build up argument list */
            *(PFcnode_t **) PFarray_top (args)
                = arg (var (v), *(PFcnode_t **) PFarray_top (args));

            /* translate other arguments */
            reduce (kids[1], nts[1]);

            /* count arguments (parse tree is in reverse order
               - therefore increase argument after other arguments) */
            param_num = (*(unsigned short *) PFarray_top (arg_num))++;


            /* What function are we actually talking about? */
            fun = *(PFfun_t **) PFarray_top (funs);

            /*
             * There's exactly one function that allows an arbitrary
             * number of arguments: fn:concat(). Looking at the
             * parameter types here doesn't really make sense, we
             * use atomic? instead.
             */
            if (PFqname_eq (fun->qname,
                            PFqname (PFns_fn, "concat")) == 0)
                expected = PFty_opt (PFty_atomic ());
            else
                /* look up expected argument type */
                expected = fun->par_ty[param_num];

            /*
             * There's implicit semantics for some functions.
             */
            /* Implicitly call fn:boolean() before fn:not(). */
            if (! PFqname_eq (fun->qname, PFqname (PFns_fn, "not")))
                implicit = function (PFqname (PFns_fn, "boolean"));

            /* Implicitly call fn:string() before fn:concat(). */
            if (! PFqname_eq (fun->qname, PFqname (PFns_fn, "concat")))
                implicit = function (PFqname (PFns_fn, "string"));

            if (implicit) {
                PFvar_t *v1 = new_var (NULL);

                C(p) = let (letbind (var (v1),
                                     function_conversion (C(L(p)), expected)),
                            let (letbind (var (v),
                                          APPLY (implicit, var (v1))),
                                 C(R(p))));
            }
            else {
                /* construct return value */
                C(p) = let (letbind (var (v),
                                     function_conversion (C(L(p)), expected)),
                            C(R(p)));
            }

        } break;

        /* OrderedExpr:            ordered (Expr) */
        case 183:
            /* FIXME: Better treatment of `ordered' information?
             *         - Make this rule TOPDOWN
             *         - Keep a state variable during compilation
             */
            C(p) = ordered (C(L(p)));
            break;

        /* UnorderedExpr:          unordered (Expr) */
        case 184:
            C(p) = unordered (C(L(p)));
            break;

        /* Constructor:            ElementConstructor */
        case 185:
            break;

        /* Constructor:            AttributeConstructor */
        case 186:
            break;

        /* Constructor:            TextConstructor */
        case 187:
            break;

        /* Constructor:            CommentConstructor */
        case 188:
            break;

        /* Constructor:            PIConstructor */
        case 189:
            break;

        /* Constructor:            DocumentConstructor */
        case 190:
            break;

        /* ElementConstructor:     elem (TagName, OptContentExpr) */
        case 191:
        {
            PFfun_t *pf_matn
                = function (PFqname (PFns_pf, "merge-adjacent-text-nodes"));

            C(p) = constr_elem (C(L(p)), APPLY (pf_matn, C(R(p))));

        } break;

        /* AttributeConstructor:   attr (TagName, AttributeValue) */
        case 192:
            /*
             * The translation rules rooted at AttributeValue compile
             * the attribute value into a single string.
             */
            C(p) = constr_attr (C(L(p)), C(R(p)));
            break;

        /* TextConstructor:        text (Expr) */
        case 193:
        {
            PFfun_t *is2uA =
                function (PFqname (PFns_pf, "item-sequence-to-untypedAtomic"));

            C(p) = constr (p->kind, APPLY (is2uA, C(L(p))));

        } break;

        /* CommentConstructor:     comment (Expr) */
        case 194:
        {
            PFfun_t *is2uA =
                function (PFqname (PFns_pf, "item-sequence-to-untypedAtomic"));

            C(p) = constr (p->kind, APPLY (is2uA, C(L(p))));

        } break;

        /* PIConstructor:          pi (OptExpr, OptContentExpr) */
        case 195:
        {
            PFvar_t *target  = new_var (NULL);
            PFvar_t *content = new_var (NULL);
            PFvar_t *v       = new_var (NULL);

            PFfun_t *is2uA =
                function (PFqname (PFns_pf, "item-sequence-to-untypedAtomic"));

            C(p) = let (
                    letbind (var (target), C(L(p))),
                    let (
                        letbind (var (v), C(R(p))),
                        let (letbind (var (content), APPLY (is2uA, var (v))),
                             constr_pi (var (target), var (content)))));
        } break;

        /* DocumentConstructor:    doc (Expr) */
        case 196:
        {
            PFfun_t *is2ns =
                function (PFqname (PFns_pf, "item-sequence-to-node-sequence"));

            C(p) = constr (p->kind, APPLY (is2ns, C(L(p))));
        } break;

        /* TagName:                tag */
        case 197:
            C(p) = constr_tag (p->sem.qname);
            break;

        /* TagName:                Expr */
        case 198:
            /* in theory this should be translated into
               'fn:resolve-QName' but we don't know the
               element argument - therefore internally
               the string is translated into a qname */
            C(p) = fs_convert_op_by_type (fn_data (C(p)), PFty_string ());
            break;

        /* OptContentExpr:         OptExpr */
        case 199:
        {
            PFvar_t *v = new_var (NULL);
            PFfun_t *is2ns =
                function (PFqname (PFns_pf, "item-sequence-to-node-sequence"));

            C(p) = let (letbind (var (v), C(p)), APPLY (is2ns, var (v)));

        } break;

        /* OptContentExpr:         empty_seq */
        case 200:
            C(p) = empty ();
            break;

        /* OptContentExpr:         contseq (OptContentExpr, OptContentExpr) */
        case 201:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);

            C(p) = let (letbind (var (v1), C(L(p))),
                        let (letbind (var (v2), C(R(p))),
                             seq (var (v1), var (v2))));

        } break;

        /* AttributeValue:         Expr */
        case 202:
        {
            /*
             * Convert enclosed expression in attribute values as described in
             * [XQ, Section 3.7.1.1]:
             *
             *  a. Apply atomization (fn:data) to the enclosed expression.
             *  b. Cast each atomic value in the resulting sequence to a string
             *  c. Merge all the resulting strings with a space character
             *     inbetween.
             *
             * let $v1 := [[ $1$ ]] return
             *    let $v2 := for $v3 in $v1 return fn:string($v3)
             *       return
             *       fn:string-join( $v2, " " )
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);
            PFfun_t *string = function (PFqname (PFns_fn, "string"));
            PFfun_t *string_join = function (PFqname (PFns_fn, "string-join"));

            C(p) =
                let (letbind (var (v1), C(p)),
                     let (
                         letbind (
                             var (v2),
                             for_ (forbind (forvars (var (v3), nil ()),
                                            var (v1)),
                                   APPLY (string, var (v3)))),
                         APPLY (string_join, var (v2), str (" "))));
        } break;

        /* AttributeValue:         empty_seq */
        case 203:
            /*
             * An empty attribute value shall result in an empty string.
             */
            C(p) = str ("");
            break;

        /* AttributeValue:         contseq (AttributeValue, AttributeValue) */
        case 204:
        {
            /*
             * Both arguments have type xs:string after they had been
             * converted in the rule AttrEnclosedExpr. All that is left
             * to do is to concatenate them.
             *
             * let $v1 := [[ e1 ]] return
             *   let $v2 := [[ e2 ]] return
             *     fn:concat ($v1, $v2)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *concat = function (PFqname (PFns_fn, "concat"));

            C(p) = let (letbind (var (v1), C(L(p))),
                        let (letbind (var (v2), C(R(p))),
                             APPLY (concat, var (v1), var (v2))));

        } break;


        default:
            PFoops_loc (OOPS_FATAL, p->loc, "untranslated expression");
            break;
    }
}

/**
 * Extract sequence types from function parameter list and
 * put them into a single array, suitable for insertion into
 * PFfun_t.
 *                fun
 *               /   \
 *         fun_sig    Body
 *        /       \
 *    params      ReturnType
 *   /     \
 *  ty      params
 *         /      \
 *        ty      ...
 *                  \
 *                  nil
 *
 * Call with the topmost `param' node.
 */
static PFty_t *
parameter_types (PFpnode_t *paramlist)
{
    PFarray_t *par_ty = PFarray (sizeof (PFty_t));
    PFpnode_t *n = paramlist;

    assert (paramlist);

    while (n->kind != p_nil) {
        assert (n->kind == p_params);
        assert (L(n) && L(n)->kind == p_param);
        assert (LL(n) && C(LL(n)) && C(LL(n))->kind == c_seqtype);

        *((PFty_t *) PFarray_add (par_ty)) = C(LL(n))->sem.type;

        n = R(n);
        assert (n);
    }

    return par_ty->base;
}

/**
 * Convert function argument or return value according to
 * to the function conversion rules in W3C XQuery 3.1.5.
 *
 * -- If the expected type is an atomic type,
 * 
 *    (1) Apply atomization (i.e., fn:data)
 *    (2) Cast each xdt:untypedAtomic item to the expected
 *        atomic type. For built-in functions with expected
 *        type `numeric', cast them to xs:double.
 *    (3) Apply numeric type promotion, if possible.
 *
 * -- Leave other arguments as they are. (FIXME: correct?)
 *
 * We use fn:data() for Step 1, fs:convert-operand() for Step 2.
 * FIXME: Step 3?
 *
 * In XQuery Core:
 *
 * -- The expected type t is an atomic type:
 *
 *    let $v1 := arg return
 *      for $v2 in $v1 return
 *        let $v3 := fn:data ($v2) return
 *          convert-operand ($v3, prime(expected))
 *
 */
static PFcnode_t *
function_conversion (const PFcnode_t *e, PFty_t expected)
{
    PFty_t exp_prime;

    PFcnode_t *ret;
    PFvar_t   *v1 = new_var (NULL);
    PFvar_t   *v2 = new_var (NULL);
    PFvar_t   *v3 = new_var (NULL);

    assert (e);

    exp_prime = PFty_prime (PFty_defn (expected));

    if (PFty_subtype (exp_prime, PFty_atomic ())) {

        /*
         * Built-in functions allow the expected type to be `numeric'.
         * In that case, we shall convert to xs:double.
         */
        if (PFty_eq (exp_prime, PFty_numeric ()))
            exp_prime = PFty_double ();

        /* Steps 1 and 2:
         *
         * let $v1 := e return
         *   let $v2 := fn:data ($v1) return
         *     for $v3 in $v2 return
         *       convert-op ($v3, exp_prime)
         */
        ret = let (
                letbind (var (v1), e),
                let (
		  letbind (var (v2), fn_data (var (v1))),
                  for_ (
                    forbind (forvars (var (v3), nil ()), var (v2)),
                      fs_convert_op_by_type (var (v3), exp_prime))));

    }
    else
        /* do nothing if expected is not atomic */
        ret = (PFcnode_t *) e;

    return ret;
}


/**
 * Compile parse tree into XQuery Core tree.
 *
 * @param r root of the abstract syntax tree
 * @return the Core equivalent of @a r
 */
PFcnode_t *
PFfs (PFpnode_t *r)
{
    assert (r);

    core_vars = 0;

    /* initially, there is no function on the current function stack */
    funs = PFarray (sizeof (PFfun_t *));

    /* initially, there is no argument list on the current arguments stack */
    args = PFarray (sizeof (PFcnode_t *));

    /* initially, there nothing on the current argument number stack */
    arg_num = PFarray (sizeof (unsigned short));

    /* initially, the context item is undefined */
    fs_dot = NULL;
    fs_position = NULL;
    fs_last = NULL;

    /* We collect function signatures in the query prolog here. */
    fun_sigs = nil ();

    /* We collect variable declarations in the query prolog
     * in a root/hole pair. */
    var_decls.root = var_decls.hole = NULL;

    /* label the parse tree bottom up */
    PFfs_label (r);

    /* invoke compilation */
    reduce (r, 1);

    /* sanity: current function/argument list stacks need to be empty */
    assert (PFarray_empty (funs));
    assert (PFarray_empty (args));

    return r->core;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
