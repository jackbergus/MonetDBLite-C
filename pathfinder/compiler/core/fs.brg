%{

/**
 * @file
 *
 * Compile parse tree into XQuery Core. This file implements
 * (more or less) the W3C XQuery Formal Semantics Working Draft.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2008 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 *
 * $Id$
 */ 


#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "abssyn.h"
#include "qname.h"
#include "mem.h"

/* PFcnode_t */
#include "core.h"

/*
 * We need subtyping stuff for semantics of function application.
 */
#include "subtyping.h"

/* PFvar_t */
#include "variable.h"

/* Easily access subtree-parts */
#include "child_mnemonic.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFpnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/abssyn.h!
 */
%term    and            =   1
%term    apply          =   2
%term    args           =   3
%term    atom_ty        =   4
%term    attr           =   5
%term    base_uri       =   6
%term    bind           =   7
%term    binds          =   8
%term    case_          =   9
%term    cases          =  10
%term    cast           =  11
%term    castable       =  12
%term    coll_decl      =  13
%term    comment        =  14
%term    constr_decl    =  15
%term    contseq        =  16
%term    decl_imps      =  17
%term    def_order      =  18
%term    default_       =  19
%term    div            =  20
%term    doc            =  21
%term    dot            =  22
%term    elem           =  23
%term    empty_seq      =  24
%term    empty_ty       =  25
%term    ens_decl       =  26
%term    eq             =  27
%term    every          =  28
%term    except         =  29
%term    exprseq        =  30
%term    external       =  31
%term    ext_expr       =  32
%term    flwr           =  33
%term    fns_decl       =  34
%term    fun            =  35
/* %term fun_decl       =  36  eliminated by function checking */
/* %term fun_ref        =  37  eliminated by function checking */
%term    fun_sig        =  38
%term    ge             =  39
%term    gt             =  40
%term    gtgt           =  41
%term    idiv           =  42
%term    if_            =  43
%term    copy_ns        =  44
%term    instof         =  45
%term    intersect      =  46
%term    is             =  47
%term    item_ty        =  48
%term    le             =  49
%term    let            =  50
%term    lib_mod        =  51
%term    lit_dbl        =  52
%term    lit_dec        =  53
%term    lit_int        =  54
%term    lit_str        =  55
%term    locpath        =  56
%term    lt             =  57
%term    ltlt           =  58
%term    main_mod       =  59
%term    minus          =  60
%term    mod            =  61
%term    mod_imp        =  62
%term    mod_ns         =  63
%term    mult           =  64
%term    named_ty       =  65
%term    ne             =  66
%term    nil            =  67
%term    node_ty        =  68
%term    ns_decl        =  69
%term    option         =  70
%term    or             =  71
%term    ord_ret        =  72
%term    orderby        =  73
%term    ordered        =  74
%term    ordering_mode  =  75
%term    orderspecs     =  76
%term    param          =  77
%term    params         =  78
%term    pi             =  79
%term    plus           =  80
%term    pragma         =  81
%term    pragmas        =  82
%term    pred           =  83
%term    range          =  84
%term    req_name       =  85
%term    req_ty         =  86
%term    root_          =  87
%term    schm_ats       =  88
%term    schm_attr      =  89
%term    schm_elem      =  90
%term    schm_imp       =  91
%term    seq_ty         =  92
%term    some           =  93
%term    step           =  94
%term    tag            =  95
%term    text           =  96
%term    then_else      =  97
%term    treat          =  98
%term    typeswitch     =  99
%term    uminus         = 100
%term    union_         = 101
%term    unordered      = 102
%term    uplus          = 103
%term    val_eq         = 104
%term    val_ge         = 105
%term    val_gt         = 106
%term    val_le         = 107
%term    val_lt         = 108
%term    val_ne         = 109
%term    validate       = 110
%term    var            = 111
%term    var_decl       = 112
%term    var_type       = 113
/* %term varref         = 114  eliminated by function checking */
%term    vars           = 115
%term    where          = 116
%term    boundspc_decl  = 117
%term    revalid        = 118
%term    insert         = 119
%term    delete         = 120
%term    replace        = 121
%term    rename         = 122
%term    transform      = 123
%term    modify         = 124
%term    transbinds     = 125
%term    stmt_ty        = 126
%term    recursion      = 127
%term    seed           = 128
%term    xrpc           = 129
%term    docmgmt_ty     = 130

%%

Query:                  MainModule                                  =   1 (10);
Query:                  lib_mod (ModuleDecl, Prolog)                =   2 (10);

MainModule:             main_mod (Prolog, QueryBody)                =   3 (10);
LibraryModule:          lib_mod (ModuleDecl, Prolog)                =   4 (10);

ModuleDecl:             mod_ns (lit_str)                            =   5 (10);
Prolog:                 DeclsImports                                =   6 (10);

DeclsImports:           decl_imps (DeclImport, DeclsImports)        =   7 (10);
DeclsImports:           nil                                         =   8 (10);

/* Expand function declarations here to allow for appropriate
 * top-down processing.
 */
DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                 SequenceType),
                                        Expr),
                                   DeclsImports)                    =   9 (10);
DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                 SequenceType),
                                        external),
                                   DeclsImports)                    =  10 (10);


DeclImport:             DefaultNamespaceDecl                        =  11 (10);
DeclImport:             BoundarySpaceDecl                           =  12 (10);
DeclImport:             DefaultCollationDecl                        =  13 (10);
DeclImport:             BaseURIDecl                                 =  14 (10);
DeclImport:             ConstructionDecl                            =  15 (10);
DeclImport:             OrderingModeDecl                            =  16 (10);
DeclImport:             EmptyOrderingDecl                           =  17 (10);
DeclImport:             CopyNamespacesDecl                          =  18 (10);
DeclImport:             NamespaceDecl                               =  19 (10);
DeclImport:             OptionDecl                                  =  20 (10);
DeclImport:             SchemaImport                                =  21 (10);
DeclImport:             ModuleImport                                =  22 (10);
DeclImport:             VariableDeclaration                         =  23 (10);
DeclImport:             LibraryModule                               =  24 (10);

DefaultNamespaceDecl:   ens_decl (lit_str)                          =  25 (10);
DefaultNamespaceDecl:   fns_decl (lit_str)                          =  26 (10);

BoundarySpaceDecl:      boundspc_decl                               =  27 (10);

DefaultCollationDecl:   coll_decl (lit_str)                         =  28 (10);

BaseURIDecl:            base_uri (lit_str)                          =  29 (10);

ConstructionDecl:       constr_decl                                 =  30 (10);

OptionDecl:             option (lit_str)                            =  31 (10);

OrderingModeDecl:       ordering_mode                               =  32 (10);

EmptyOrderingDecl:      def_order                                   =  33 (10);

CopyNamespacesDecl:     copy_ns                                     =  34 (10);

NamespaceDecl:          ns_decl (lit_str)                           =  35 (10);

SchemaImport:           schm_imp (lit_str, OptImportLoc_)           =  36 (10);

ModuleImport:           mod_imp (lit_str, OptImportLoc_)            =  37 (10);

OptImportLoc_:          nil                                         =  38 (10);
OptImportLoc_:          schm_ats (lit_str, OptImportLoc_)           =  39 (10);

OptParamList_:          nil                                         =  40 (10);
OptParamList_:          ParamList_                                  =  41 (10);

ParamList_:             nil                                         =  42 (10);
ParamList_:             params (Param, ParamList_)                  =  43 (10);

Param:                  param (SequenceType, Var)                   =  44 (10);

OptSequenceType_:       nil                                         =  45 (10);
OptSequenceType_:       SequenceType                                =  46 (10);

VariableDeclaration:    var_decl (var_type (Var,
                                            nil),
                                  OptExpr)                          =  47 (10);
VariableDeclaration:    var_decl (var_type (Var,
                                            SequenceType),
                                  OptExpr)                          =  48 (10);
VariableDeclaration:    var_decl (var_type (Var,
                                            OptSequenceType_),
                                  external)                         =  49 (10);

QueryBody:              OptExpr                                     =  50 (10);

OptExpr:                empty_seq                                   =  51 (10);
OptExpr:                Expr                                        =  52 (10);

Expr:                   exprseq (OptExpr, OptExpr)                  =  53 (10);
Expr:                   ExprSingle                                  =  54 (10);

ExprSingle:             FLWORExpr                                   =  55 (10);
ExprSingle:             QuantifiedExpr                              =  56 (10);
ExprSingle:             TypeswitchExpr                              =  57 (10);
ExprSingle:             IfExpr                                      =  58 (10);
ExprSingle:             OrExpr                                      =  59 (10);

FLWORExpr:              flwr (OptBindExpr,
                              where (OptWhereClause_,
                                     ord_ret (nil, OptExpr)))       =  60 (10);

FLWORExpr:              flwr (OptBindExpr,
                              where (OptWhereClause_,
                                     ord_ret (orderby (
                                                 OrderSpecList),
                                              OptExpr)))            =  61 (10);

OptBindExpr:            nil                                         =  62 (10);
OptBindExpr:            binds (let (var_type (Var,
                                              nil),
                                    OptExpr),
                               OptBindExpr)                         =  63 (10);
OptBindExpr:            binds (let (var_type (Var,
                                              TypeDeclaration),
                                    OptExpr),
                               OptBindExpr)                         =  64 (10);
OptBindExpr:            binds (bind (vars (var_type (Var,
                                                     nil),
                                           OptPosVar),
                                     OptExpr),
                               OptBindExpr)                         =  65 (10);
OptBindExpr:            binds (bind (vars (var_type (Var,
                                                     TypeDeclaration),
                                           OptPosVar),
                                     OptExpr),
                               OptBindExpr)                         =  66 (10);

OptPosVar:              nil                                         =  68 (10);
OptPosVar:              Var                                         =  69 (10);

TypeDeclaration:        SequenceType                                =  70 (10);

OptWhereClause_:        nil                                         =  71 (10);
OptWhereClause_:        OptExpr                                     =  72 (10);

OrderSpecList:          nil                                         =  73 (10);
OrderSpecList:          orderspecs (OptExpr, OrderSpecList)         =  74 (10);

QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                           nil),
                                                 nil),
                                           OptExpr),
                                     nil),
                              OptExpr)                              =  75 (10);
QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                           TypeDeclaration),
                                                 nil),
                                           OptExpr),
                                     nil),
                              OptExpr)                              =  76 (10);
QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                            nil),
                                                  nil),
                                            OptExpr),
                                      nil),
                               OptExpr)                             =  77 (10);
QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                            TypeDeclaration),
                                                  nil),
                                            OptExpr),
                                      nil),
                               OptExpr)                             =  78 (10);

TypeswitchExpr:         typeswitch (
                            OptExpr,
                            cases (case_ (var_type (OptCaseVar,
                                                    SequenceType),
                                          OptExpr),
                                   cases (default_ (OptCaseVar,
                                                    OptExpr),
                                          nil)))                    =  79 (10);

OptCaseVar:             nil                                         =  80 (10);
OptCaseVar:             Var                                         =  81 (10);

SequenceType:           seq_ty (ItemType)                           =  82 (10);

SingleType:             seq_ty (AtomType)                           =  83 (10);

ItemType:               empty_ty                                    =  84 (10);
ItemType:               NodeTest                                    =  85 (10);
ItemType:               item_ty (nil)                               =  86 (10);
ItemType:               atom_ty (nil)                               =  87 (10);
ItemType:               schm_elem                                   =  88 (10);
ItemType:               schm_attr                                   =  89 (10);

AtomType:               atom_ty (nil)                               =  90 (10);

NodeTest:               node_ty (nil)                               =  91 (10);
NodeTest:               node_ty (ElemOrAttrType)                    =  92 (10);
NodeTest:               node_ty (node_ty (nil))                     =  93 (10);
NodeTest:               node_ty (node_ty (ElemOrAttrType))          =  94 (10);
NodeTest:               node_ty (lit_str)                           =  95 (10);

ElemOrAttrType:         req_ty (nil, nil)                           =  96 (10);
ElemOrAttrType:         req_ty (nil, SchemaType)                    =  97 (10);
ElemOrAttrType:         req_ty (req_name, nil)                      =  98 (10);
ElemOrAttrType:         req_ty (req_name, SchemaType)               =  99 (10);

SchemaType:             named_ty                                    = 100 (10);

IfExpr:                 if_ (OptExpr,
                             then_else (OptExpr, OptExpr))          = 101 (10);

OrExpr:                 AndExpr                                     = 102 (10);
OrExpr:                 or (AndExpr, OrExpr)                        = 103 (10);

AndExpr:                ComparisonExpr                              = 104 (10);
AndExpr:                and (ComparisonExpr, AndExpr)               = 105 (10);

ComparisonExpr:         RangeExpr                                   = 106 (10);
ComparisonExpr:         eq (RangeExpr, RangeExpr)                   = 107 (10);
ComparisonExpr:         ne (RangeExpr, RangeExpr)                   = 108 (10);
ComparisonExpr:         lt (RangeExpr, RangeExpr)                   = 109 (10);
ComparisonExpr:         le (RangeExpr, RangeExpr)                   = 110 (10);
ComparisonExpr:         gt (RangeExpr, RangeExpr)                   = 111 (10);
ComparisonExpr:         ge (RangeExpr, RangeExpr)                   = 112 (10);
ComparisonExpr:         val_eq (RangeExpr, RangeExpr)               = 113 (10);
ComparisonExpr:         val_ne (RangeExpr, RangeExpr)               = 114 (10);
ComparisonExpr:         val_lt (RangeExpr, RangeExpr)               = 115 (10);
ComparisonExpr:         val_le (RangeExpr, RangeExpr)               = 116 (10);
ComparisonExpr:         val_gt (RangeExpr, RangeExpr)               = 117 (10);
ComparisonExpr:         val_ge (RangeExpr, RangeExpr)               = 118 (10);
ComparisonExpr:         is (RangeExpr, RangeExpr)                   = 119 (10);
ComparisonExpr:         ltlt (RangeExpr, RangeExpr)                 = 121 (10);
ComparisonExpr:         gtgt (RangeExpr, RangeExpr)                 = 122 (10);

RangeExpr:              AdditiveExpr                                = 123 (10);
RangeExpr:              range (RangeExpr, RangeExpr)                = 124 (10);

AdditiveExpr:           MultiplicativeExpr                          = 125 (10);
AdditiveExpr:           plus (AdditiveExpr, MultiplicativeExpr)     = 126 (10);
AdditiveExpr:           minus (AdditiveExpr, MultiplicativeExpr)    = 127 (10);

MultiplicativeExpr:     UnionExpr                                   = 128 (10);
MultiplicativeExpr:     mult (UnionExpr, MultiplicativeExpr)        = 129 (10);
MultiplicativeExpr:     div (UnionExpr, MultiplicativeExpr)         = 130 (10);
MultiplicativeExpr:     idiv (UnionExpr, MultiplicativeExpr)        = 131 (10);
MultiplicativeExpr:     mod (UnionExpr, MultiplicativeExpr)         = 132 (10);

UnionExpr:              IntersectExceptExpr                         = 133 (10);
UnionExpr:              union_ (IntersectExceptExpr, UnionExpr)     = 134 (10);

IntersectExceptExpr:    InstanceofExpr                              = 135 (10);
IntersectExceptExpr:    intersect (InstanceofExpr,
                                   IntersectExceptExpr)             = 136 (10);
IntersectExceptExpr:    except (InstanceofExpr,
                                IntersectExceptExpr)                = 137 (10);

InstanceofExpr:         TreatExpr                                   = 138 (10);
InstanceofExpr:         instof (TreatExpr, SequenceType)            = 139 (10);

TreatExpr:              CastableExpr                                = 140 (10);
TreatExpr:              treat (CastableExpr, SequenceType)          = 141 (10);

CastableExpr:           CastExpr                                    = 142 (10);
CastableExpr:           castable (CastExpr, SingleType)             = 143 (10);

CastExpr:               UnaryExpr                                   = 144 (10);
CastExpr:               cast (UnaryExpr, SingleType)                = 145 (10);

UnaryExpr:              ValueExpr                                   = 146 (10);
UnaryExpr:              uminus (ValueExpr)                          = 147 (10);
UnaryExpr:              uplus (ValueExpr)                           = 148 (10);

ValueExpr:              ValidateExpr                                = 149 (10);
ValueExpr:              PathExpr                                    = 150 (10);
ValueExpr:              ExtensionExpr                               = 151 (10);

ValidateExpr:           validate (OptExpr)                          = 152 (10);

PathExpr:               FilterExpr                                  = 153 (10);
PathExpr:               LocationPath                                = 154 (10);

LocationPath:           root_                                       = 155 (10);
LocationPath:           locpath (PathExpr, PathExpr)                = 156 (10);
LocationPath:           locpath (step (NodeTest), PathExpr)         = 157 (10);
LocationPath:           pred (LocationPath, OptExpr)                = 158 (10);

FilterExpr:             PrimaryExpr                                 = 160 (10);
FilterExpr:             pred (PathExpr, OptExpr)                    = 161 (10);

PrimaryExpr:            Literal                                     = 163 (10);
PrimaryExpr:            Var                                         = 164 (10);
PrimaryExpr:            ParenthesizedExpr                           = 165 (10);
PrimaryExpr:            ContextItemExpr                             = 166 (10);
PrimaryExpr:            FunctionCall                                = 167 (10);
PrimaryExpr:            Constructor                                 = 168 (10);
PrimaryExpr:            OrderedExpr                                 = 169 (10);
PrimaryExpr:            UnorderedExpr                               = 170 (10);
PrimaryExpr:            XRPCCall                                    = 171 (10);

Literal:                NumericLiteral                              = 172 (10);
Literal:                StringLiteral                               = 173 (10);

NumericLiteral:         IntegerLiteral                              = 174 (10);
NumericLiteral:         DecimalLiteral                              = 175 (10);
NumericLiteral:         DoubleLiteral                               = 176 (10);

IntegerLiteral:         lit_int                                     = 177 (10);
DecimalLiteral:         lit_dec                                     = 178 (10);
DoubleLiteral:          lit_dbl                                     = 179 (10);

StringLiteral:          lit_str                                     = 180 (10);

Var:                    var                                         = 181 (10);

ParenthesizedExpr:      OptExpr                                     = 182 (10);

ContextItemExpr:        dot                                         = 183 (10);

FunctionCall:           apply (nil)                                 = 184 (10);
FunctionCall:           apply (FuncArgList)                         = 185 (10);

FuncArgList:            nil                                         = 186 (10);
FuncArgList:            args (OptExpr, FuncArgList)                 = 187 (10);

OrderedExpr:            ordered (OptExpr)                           = 188 (10);
UnorderedExpr:          unordered (OptExpr)                         = 189 (10);

Constructor:            ElementConstructor                          = 190 (10);
Constructor:            AttributeConstructor                        = 191 (10);
Constructor:            TextConstructor                             = 192 (10);
Constructor:            CommentConstructor                          = 193 (10);
Constructor:            PIConstructor                               = 194 (10);
Constructor:            DocumentConstructor                         = 195 (10);

ElementConstructor:     elem (TagName, OptContentExpr)              = 196 (10);

AttributeConstructor:   attr (TagName, AttributeValue)              = 197 (10);

TextConstructor:        text (OptExpr)                              = 198 (10);

CommentConstructor:     comment (OptExpr)                           = 199 (10);

PIConstructor:          pi (OptExpr, OptContentExpr)                = 200 (10);

DocumentConstructor:    doc (OptExpr)                               = 201 (10);

TagName:                tag                                         = 202 (10);
TagName:                OptExpr                                     = 203 (10);

OptContentExpr:         Expr                                        = 204 (10);
OptContentExpr:         empty_seq                                   = 205 (10);
OptContentExpr:         contseq (OptContentExpr, OptContentExpr)    = 206 (10);

AttributeValue:         Expr                                        = 207 (10);
AttributeValue:         empty_seq                                   = 208 (10);
AttributeValue:         contseq (AttributeValue, AttributeValue)    = 209 (10);

ExtensionExpr:          ext_expr (Pragmas, nil)                     = 210 (10);
ExtensionExpr:          ext_expr (Pragmas, Expr)                    = 211 (10);

Pragmas:                nil                                         = 212 (10);
Pragmas:                pragmas (pragma, Pragmas)                   = 213 (10);

/* --- XQuery Update Facility below --- */
DeclImport:             RevalidationDecl                            = 214 (10);

RevalidationDecl:       revalid                                     = 215 (10);

ExprSingle:             InsertExpr                                  = 216 (10);
ExprSingle:             DeleteExpr                                  = 217 (10);
ExprSingle:             RenameExpr                                  = 218 (10);
ExprSingle:             ReplaceExpr                                 = 219 (10);
ExprSingle:             TransformExpr                               = 220 (10);

InsertExpr:             insert (SourceExpr, TargetExpr)             = 221 (10);
DeleteExpr:             delete (SourceExpr)                         = 222 (10);
ReplaceExpr:            replace (TargetExpr, ExprSingle)            = 223 (10);
RenameExpr:             rename (SourceExpr, NewNameExpr)            = 224 (10);

TransformExpr:          transform (TransformBindings,
                                   modify (ExprSingle, ExprSingle)) = 225 (10);

TransformBindings:      nil                                         = 226 (10);
TransformBindings:      transbinds (TransformBinding,
                                    TransformBindings)              = 227 (10);

TransformBinding:       let (var_type (Var, nil), OptExpr)          = 228 (10);

SourceExpr:             ExprSingle                                  = 229 (10);
TargetExpr:             ExprSingle                                  = 230 (10);
NewNameExpr:            ExprSingle                                  = 231 (10);

/* statement type for updating functions */
SequenceType:           seq_ty (stmt_ty (nil))                      = 232 (10);

/* Pathfinder extension: recursion */
ExprSingle:             RecursiveExpr                               = 233 (10);

RecursiveExpr:          recursion (
                            var_type (Var, OptTypeDeclForRec),
                            seed (ExprSingle, ExprSingle))          = 234 (10);

OptTypeDeclForRec:      nil                                         = 235 (10);
OptTypeDeclForRec:      SequenceType                                = 236 (10);
/* end of recursion extension */

/* Pathfinder extension: XRPC */
XRPCCall:               xrpc (Expr, FunctionCall)                   = 237 (10);

/* Pathfinder extension: statement type for document management functions */
SequenceType:           seq_ty (docmgmt_ty (nil))                   = 238 (10);

%%

/** Access the Core representation of any node */
#define C(p) ((p)->core)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

/** mnemonic XQuery Core constructors */
#include "core_mnemonic.h"

/** global query information */
static PFquery_t *PFquery;

/**
 * The current context items $fs:dot, $fs:position, and $fs:last
 * (see W3C XQuery Formal Semantics 3.1.2)
 */
static PFvar_t *fs_dot;
static PFvar_t *fs_position;
static PFvar_t *fs_last;

/**
 * The top of this stack holds a reference to the current function
 * (whose argument list is currently compiled).
 */
static PFarray_t *funs;
/**
 * The top of this stack holds a representation of the 
 * argument list to be passed to the currently compiled function application:
 *
 *               arg (e1, arg (e2, ..., arg (en, nil)...))
 */
static PFarray_t *args;
/**
 * The top of this stack holds the function argument number
 * that is currently compiled.
 */
static PFarray_t *arg_num;

/**
 * Collect function signatures here. The will be available as the
 * left child of the root node of the resulting Core tree.
 */
static PFcnode_t *fun_sigs;

/**
 * Collect variable declarations from the query prolog in this
 * root/hole pair. (see rule for VariableDeclaration)
 */
static struct {
    PFcnode_t *root;
    PFcnode_t *hole;
} var_decls;

/* element/attribute constructor and content */
static PFty_t (*elem_attr) (PFqname_t, PFty_t);
static PFty_t any;

static PFty_t *parameter_types (PFpnode_t *paramlist);

static PFcnode_t *function_conversion (const PFcnode_t *e, PFty_t expected);
static void comparison_worker (PFpnode_t *p, PFfun_t *fun);
static void val_comparison_worker (PFpnode_t *p, PFfun_t *fun);
static void calculation_worker (PFpnode_t *p, PFfun_t *fun);
static void two_arg_fun_worker (PFpnode_t *p, PFfun_t *fun);

static void reduce (PFpnode_t * p, int goalnt);

/**
 * Watch out for function declarations in the abstract syntax tree
 * and call reduce() for them.
 *
 * Compilation of expressions into Core requires the full signatures
 * of all functions to be readily available.  Function checking
 * (functions.c) has only set the number of function arguments, but
 * not their types (and neither the function return type).
 *
 * reduce() contains logic to derive #PFty_t types from abstract
 * syntax tree fragments.  We thus call reduce() for the function
 * signature whenever we find a function declaration.  Otherwise
 * we follow all those children that might contain further function
 * declarations.  (Note that we only handle the function signature
 * here, not its body.)
 */
static void
process_fun_sigs (PFpnode_t *p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */

    /* determine rule that matches for this non-terminal */
    rule = PFfs_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert (rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFfs_nts[rule];
    PFfs_kids (p, rule, kids);

    switch (rule) {

        /* Query:                  lib_mod (ModuleDecl, Prolog) */
        case 2:
        /* LibraryModule:          lib_mod (ModuleDecl, Prolog) */
        case 4:

            /* we are heading for function signatures in the prolog only */
            process_fun_sigs (kids[1], nts[1]);
            break;

        /* MainModule:             main_mod (Prolog, QueryBody) */
        case 3:

            /* we are heading for function signatures in the prolog only */
            process_fun_sigs (kids[0], nts[0]);
            break;

        /* DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                            SequenceType),
                                                   Expr),
                                              DeclsImports) */
        case 9:
            /* fall through */

        /* DeclsImports:           decls_imps (fun (fun_sig (OptParamList_,
                                                             SequenceType),
                                                    external),
                                               DeclsImports) */
        case 10:
            /*
             * Parse tree situation for function declarations:
             *
             *                   decls_imps
             *                  /          \
             *               fun        (other decls)
             *              /   \
             *        fun_sig    BODY
             *        /     \
             *  ParamList  ReturnType
             */

            /* debugging only
            PFinfo (OOPS_NOTICE, "processing `%s'",
                    PFqname_str (L(p)->sem.fun->qname));
            */

            /*
             * This is the situation that process_fun_sigs() actually
             * looks out for.  We call reduce() for function signatures.
             * reduce() contains code to build up the Core equivalent
             * of the function signature and---most importantly---code
             * to derive #PFty_t types from parse tree fragments.  We
             * use the latter to fill in the missing parts into the
             * #PFfun_t struct.
             */
            reduce (kids[0], nts[0]);
            reduce (kids[1], nts[1]);

            L(p)->sem.fun->sig_count = 1;
            L(p)->sem.fun->sigs =  
                (PFfun_sig_t *) PFmalloc (sizeof (PFfun_sig_t));
	    
            L(p)->sem.fun->sigs[0].par_ty = parameter_types (LLL(p));
            L(p)->sem.fun->sigs[0].ret_ty = C(LLR(p))->sem.type;

            /* Look out for more function declarations */
            process_fun_sigs (kids[3], nts[3]);

            break;


        /* Query:                  MainModule */
        case 1:

        /* Prolog:                 DeclsImports */
        case 6:

        /* DeclsImports:           decl_imps (DeclImport, DeclsImports) */
        case 7:

        /* DeclImport:             LibraryModule */
        case 24:

            /* These are the interesting paths to follow */
            for (unsigned short i = 0; nts[i]; i++)
                process_fun_sigs (kids[i], nts[i]);
            break;

        default:
            break;
    }
}

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void reduce_rest (PFpnode_t * p, int rule, short * nts, PFpnode_t *kids[MAX_KIDS]);
static void
reduce (PFpnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */

    /* guard against too dep recursion */
    PFrecursion_fence();

    /* determine rule that matches for this non-terminal */
    rule = PFfs_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert (rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFfs_nts[rule];
    PFfs_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    switch (rule) {
        /* DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                            SequenceType),
                                                   Expr),
                                              DeclsImports) */
        case 9:
        /* DeclsImports:           decls_imps (fun (fun_sig (OptParamList_,
                                                             SequenceType),
                                                    external),
                                               DeclsImports) */
        case 10:
        /* NodeTest:               node_ty (ElemOrAttrType) */
        case 92:
        /* NodeTest:               node_ty (node_ty (ElemOrAttrType)) */
        case 94:
        /* LocationPath:           locpath (PathExpr, PathExpr) */
        case 156:
        /* LocationPath:           pred (LocationPath, OptExpr) */
        case 158:
        /* FilterExpr:             pred (PathExpr, Expr) */
        case 161:
        /* FunctionCall:           apply (nil) */
        case 184:
        /* FunctionCall:           apply (FuncArgList) */
        case 185:
        /* FuncArgList:            args (Expr, FuncArgList) */
        case 187:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    if (!topdown)
        for (unsigned short i = 0; nts[i]; i++)
            reduce (kids[i], nts[i]);

    reduce_rest(p, rule, nts, kids);
}

static void
reduce_rest (PFpnode_t * p, int rule, short * nts, PFpnode_t *kids[MAX_KIDS])
{
    PFcnode_t    *c;              /* temporary helper variable */

    /*
    PFinfo (OOPS_NOTICE, "processing rule %i", rule);
    */

    switch (rule) {

        /* Query:                  MainModule */
        case 1:
            break;

        /* Query:                  lib_mod (ModuleDecl, Prolog) */
        case 2:
            /*
             * Catch the case where we got an XQuery module
             * directly as the input.
             *
             * Don't know what the best is to do here. For now,
             * we pick Peter's approach and just "simulate" a
             * query that returns just the empty sequence.
             */

            /*
             * We may have collected variable bindings from the
             * prolog. Put them on top of the query.
             */
            if (var_decls.root) {
                var_decls.hole->child[1] = nil ();
                c = flwr (var_decls.root, empty ());
            }
            else
                c = empty ();

            /*
             * Make a `main' node the root of the resulting tree.
             * Left child lists all the function signatures. Right
             * child is the query itself.
             */
            C(p) = PFcore_main (fun_sigs, c);

            break;

        /* MainModule:             main_mod (Prolog, QueryBody) */
        case 3:
            /*
             * We may have collected variable bindings from the
             * prolog. Put them on top of the query.
             */
            if (var_decls.root) {
                var_decls.hole->child[1] = nil ();
                c = flwr (var_decls.root, C(R(p)));
            }
            else
                c = C(R(p));

            /*
             * Make a `main' node the root of the resulting tree.
             * Left child lists all the function signatures. Right
             * child is the query itself.
             */
            C(p) = PFcore_main (fun_sigs, c);

            break;

        /* LibraryModule:          lib_mod (ModuleDecl, Prolog) */
        case 4:
            break;

        /* ModuleDecl:             mod_ns (lit_str) */
        case 5:
            break;

        /* Prolog:                 DeclsImports */
        case 6:
            break;

        /* DeclsImports:           decl_imps (DeclImport, DeclsImports) */
        case 7:
            break;

        /* DeclsImports:           nil */
        case 8:
            break;

        /* DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                            SequenceType),
                                                   Expr),
                                              DeclsImports) */
        case 9:
        {   /* TOPDOWN */

            /*
             * User-defined functions:
             *
             * (1) Create a unique PFfun_t data structure, containing
             *     type information, number of arguments, and an argument
             *     list (PFvar_t pointers).
             *     This has already happened during function checking.
             *
             * (2) Set function signatures
             *     This has been done already during process_fun_sigs().
             * 
             * (3) Translate function body.
             *
             * (4) Store the Core equivalent of the function body in
             *     the PFfun_t data structure. Parameter variables will
             *     appear free in this Core expression.
             *     Step (3) is what we do here.
             *
             * [(5) Before executing the Core code for this function,
             *      the back-end (e.g., algebra translation) needs to
             *      fill the variable environment with bindings for all
             *      the function parameters.
             *      This has to be done in the back-end.]
             *
             * Parse tree situation for function declarations:
             *
             *                   decls_imps
             *                  /          \
             *               fun        (other decls)
             *              /   \
             *        fun_sig    BODY
             *        /     \
             *  ParamList  ReturnType
             */

            /*
             * No need to compile function signature.  This has been
             * done already in process_fun_sigs().
             */

            /* recurse */
            reduce (kids[2], nts[2]);
            reduce (kids[3], nts[3]);

            /*
             * Apply function conversion to the function result
             * (see W3C XQuery 3.1.5 or function_conversion()
             */

            C(LR(p)) = function_conversion (C(LR(p)),
                                            C(LLR(p))->sem.type);
            L(p)->sem.fun->core = C(LR(p));

            fun_sigs = fun_decls (fun_decl (L(p)->sem.fun, C(LLL(p)), C(LR(p))),
                                  fun_sigs);

        } break;


        /* DeclsImports:           decls_imps (fun (fun_sig (OptParamList_,
                                                             SequenceType),
                                                    external),
                                               DeclsImports) */
        case 10:
        {   /* TOPDOWN */

            /*
             * Parse tree situation for function declarations:
             *
             *                   decls_imps
             *                  /          \
             *               fun        (other decls)
             *              /   \
             *        fun_sig    external
             *        /     \
             *  ParamList  ReturnType
             */

            /*
             * We have already handled the function signature, so
             * nothing left to do for external functions.
             *
             * just recurse and handle other declarations
             */
            reduce (kids[2], nts[2]);

        } break;

        /* DeclImport:             DefaultNamespaceDecl */
        case 11:
            break;

        /* DeclImport:             XMLSpaceDecl */
        case 12:
            break;

        /* DeclImport:             DefaultCollationDecl */
        case 13:
            break;

        /* DeclImport:             BaseURIDecl */
        case 14:
            break;

        /* DeclImport:             ConstructionDecl */
        case 15:
            break;

        /* DeclImport:             OrderingModeDecl */
        case 16:
            break;

        /* DeclImport:             EmptyOrderingDecl */
        case 17:
            break;

        /* DeclImport:             InheritNamespacesDecl */
        case 18:
            break;

        /* DeclImport:             NamespaceDecl */
        case 19:
            break;

        /* DeclImport:             OptionDecl */
        case 20:
            break;

        /* DeclImport:             SchemaImport */
        case 21:
            break;

        /* DeclImport:             ModuleImport */
        case 22:
            break;

        /* DeclImport:             VariableDeclaration */
        case 23:
            break;

        /* DeclImport:             LibraryModule */
        case 24:
            break;

        /* DefaultNamespaceDecl:   ens_decl (lit_str) */
        case 25:
            break;

        /* DefaultNamespaceDecl:   fns_decl (lit_str) */
        case 26:
            break;

        /* XMLSpaceDecl:           xmls_decl */
        case 27:
            break;

        /* DefaultCollationDecl:   coll_decl (lit_str) */
        case 28:
            PFinfo_loc (OOPS_WARN_NOTSUPPORTED, p->loc,
                        "default collation declaration will be ignored");
            break;

        /* BaseURIDecl:            base_uri (lit_str) */
        case 29:
            PFinfo_loc (OOPS_WARN_NOTSUPPORTED, p->loc,
                        "base-uri declaration will be ignored");
            break;

        /* ConstructionDecl:       constr_decl */
        case 30:
            PFinfo_loc (OOPS_WARN_NOTSUPPORTED, p->loc,
                        "construction mode declaration will be ignored");
            break;

        /* OptionDecl:             option (lit_str) */
        case 31:
            /*
             * Options have already been extracted and entered into
             * PFoptions.  No need to do anything special here.
             */
            break;

        /* OrderingModeDecl:       ordering_mode */
        case 32:
            PFquery->ordering = p->sem.tru;
            break;

        /* EmptyOrderingDecl:      def_order */
        case 33:
            PFquery->empty_order = p->sem.mode.empty==p_greatest?greatest:least;
            break;

        /* InheritNamespacesDecl:  inherit_ns */
        case 34:
            PFquery->inherit_ns = p->sem.tru;
            break;

        /* NamespaceDecl:          ns_decl (lit_str) */
        case 35:
            break;

        /* SchemaImport:           schm_imp (lit_str, OptImportLoc_) */
        case 36:
            break;

        /* ModuleImport:           mod_imp (lit_str, OptImportLoc_) */
        case 37:
            /*
             * module imports have already been handled by the parser
             */
            break;

        /* OptImportLoc_:          nil */
        case 38:
            break;

        /* OptImportLoc_:          schm_ats (lit_str, OptImportLoc_) */
        case 39:
            break;

        /* OptParamList_:          nil */
        case 40:
            C(p) = nil ();
            break;

        /* OptParamList_:          ParamList_ */
        case 41:
            break;

        /* ParamList_:             nil */
        case 42:
            C(p) = nil ();
            break;

        /* ParamList_:             params (Param, ParamList_) */
        case 43:
            C(p) = params (C(L(p)), C(R(p)));
            break;

        /* Param:                  param (SequenceType, Var) */
        case 44:
            C(p) = param (C(L(p)), C(R(p)));
            break;

        /* OptSequenceType_:       nil */
        case 45:
            break;

        /* OptSequenceType_:       SequenceType */
        case 46:
            break;

        /* VariableDeclaration:    var_decl (var_type (Var,
                                                       nil),
                                             OptExpr) */
        case 47:
            /*
             * We translate
             *
             *  declare variable $a := ea ;
             *  declare variable $b := eb ;
             *  e0
             *
             * as
             *
             *  let $a := ea return
             *    let $b := eb return
             *      e0  .
             *
             * So while traversing the Query Prolog (this is what we're
             * currently doing), we build up a chain of nested let clauses,
             * with the return part as a hole.
             */
            c = let (letbind (C(LL(p)), C(R(p))), nil ());

	    /* set global information */
	    LL(c)->sem.var->global = true;

            if (var_decls.root)
                var_decls.hole = var_decls.hole->child[1] = c;
            else
                var_decls.root = var_decls.hole = c;

            break;

        /* VariableDeclaration:    var_decl (var_type (Var,
                                                       SequenceType),
                                             OptExpr) */
        case 48:
        {
            /*
             * We translate
             *
             *  declare variable $a as t1 := ea ;
             *  declare variable $b as t2 := eb ;
             *  e0
             *
             * as
             *
             *  let $a as t1 := ea return
             *    let $b as t2 := eb return
             *      e0  .
             *
             * So while traversing the Query Prolog (this is what we're
             * currently doing), we build up a chain of nested let clauses,
             * with the return part as a hole.
             */
            PFvar_t *v1 = new_var (NULL);

            c = let (letbind (var (v1), C(R(p))),
                     let (letbind (C(LL(p)),
                                   proof (subty (var (v1), C(LR(p))),
                                          seqcast (C(LR(p)), var (v1)))),
                          nil ()));

	    /* set global information */
	    LL(R(c))->sem.var->global = true;

            if (var_decls.root)
                var_decls.hole->child[1] = c;
            else
                var_decls.root = c;

            var_decls.hole = c->child[1];

        } break;

        /* VariableDeclaration:    var_decl (var_type (Var,
                                                       OptSequenceType_),
                                             external) */
        case 49:
            /* FIXME: What to do here? */
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "external variables not yet implemented");
            break;

        /* QueryBody:              OptExpr */
        case 50:
            assert (C(p));
            break;

        /* OptExpr:                empty_seq */
        case 51:
            C(p) = empty ();
            break;

        /* OptExpr:                Expr */
        case 52:
            assert (C(p));
            break;

        /* Expr:                   exprseq (OptExpr, OptExpr) */
        case 53:
            C(p) = seq (C(L(p)), C(R(p)));
            break;

        /* Expr:                   ExprSingle */
        case 54:
            assert (C(p));
            break;

        /* ExprSingle:             FLWORExpr */
        case 55:
            break;

        /* ExprSingle:             QuantifiedExpr */
        case 56:
            break;

        /* ExprSingle:             TypeswitchExpr */
        case 57:
            break;

        /* ExprSingle:             IfExpr */
        case 58:
            break;

        /* ExprSingle:             OrExpr */
        case 59:
            break;

        /* FLWORExpr:              flwr (OptBindExpr,
                                         where (OptWhereClause_,
                                                ord_ret (nil, OptExpr))) */
        case 60:
            C(p) = flwr (C(L(p)),
                         if_ (C(RL(p)), then_else (C(RRR(p)), empty ())));
            break;

        /* FLWORExpr:              flwr (OptBindExpr,
                                         where (OptWhereClause_,
                                                ord_ret (orderby (
                                                            OrderSpecList),
                                                    OptExpr))) */
        case 61:
            C(p) = flwr (C(L(p)),
                         orderby (RRL(p)->sem.tru,    /* stable or not? */
                                  C(RRLL(p)),
                                  if_ (C(RL(p)),
                                       then_else (C(RRR(p)), 
                                                  empty ()))));
            break;

        /* OptBindExpr:            nil */
        case 62:
            C(p) = nil ();
            break;

        /* OptBindExpr:            binds (let (var_type (Var,
                                                         nil),
                                               OptExpr),
                                          OptBindExpr) */
        case 63:
        {
            C(p) = let (letbind (C(LLL(p)), C(LR(p))), C(R(p)));

        } break;

        /* OptBindExpr:            binds (let (var_type (Var,
                                                         TypeDeclaration),
                                               OptExpr),
                                          OptBindExpr) */
        case 64:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = let (letbind (var (v), C(LR(p))),
                        let (letbind (C(LLL(p)),
                                      proof (subty (var (v), C(LLR(p))),
                                             seqcast (C(LLR(p)), 
                                                      var (v)))),
                             C(R(p))));
                        
        } break;

        /* OptBindExpr:            binds (bind (vars (var_type (Var,
                                                                nil),
                                                      OptPosVar),
                                                OptExpr),
                                          OptBindExpr) */
        case 65:
            C(p) = for_ (forbind (forvars (C(LLLL(p)), C(LLR(p))),
                                  C(LR(p))),
                         C(R(p)));
            break;

        /* OptBindExpr:            binds (bind (vars (var_type (
                                                          Var,
                                                          TypeDeclaration),
                                                      OptPosVar),
                                                OptExpr),
                                          OptBindExpr) */
        case 66:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = for_ (forbind (forvars (var (v), C(LLR(p))),
                                  C(LR(p))),
                         let (letbind (C(LLLL(p)),
                                       proof (subty (var (v),
                                                     C(LLLR(p))),
                                              seqcast (C(LLLR(p)),
                                                       var (v)))),
                              C(R(p))));
        } break;

        /* OptPosVar:              nil */
        case 68:
            C(p) = nil ();
            break;

        /* OptPosVar:              Var */
        case 69:
            break;

        /* TypeDeclaration:        SequenceType */
        case 70:
            break;

        /* OptWhereClause_:        nil */
        case 71:
            C(p) = true_ ();
            break;

        /* OptWhereClause_:        OptExpr */
        case 72:
            C(p) = ebv (C(p));
            break;

        /* OrderSpecList:          nil */
        case 73:
            C(p) = nil ();
            break;

        /* OrderSpecList:          orderspecs (OptExpr, OrderSpecList) */
        case 74:
            C(p) = orderspecs (p->sem.mode, 
                               fs_convert_op_by_type (fn_data (C(L(p))), 
                                                      PFty_xs_string ()),
                               C(R(p)));
            break;

        /* QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                                      nil),
                                                            nil),
                                                      OptExpr),
                                                nil),
                                         OptExpr) */
        case 75:
            C(p) = some (C(LLLLL(p)), C(LLR(p)), C(R(p)));
            break;

        /* QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                                      TypeDecl),
                                                            nil),
                                                      OptExpr),
                                                nil),
                                         OptExpr) */
        case 76:
        {
            PFvar_t *v1 = new_var (NULL);

            C(p) = some (var (v1), C(LLR(p)),
                         flwr (let (letbind (C(LLLLL(p)),
                                             proof (subty (var (v1),
                                                           C(LLLLR(p))),
                                                    seqcast (C(LLLLR(p)), 
                                                             var (v1)))),
                                    nil ()),
                               C(R(p))));

        } break;


        /* QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                                       nil),
                                                             nil),
                                                       OptExpr),
                                                 nil),
                                          OptExpr) */
        case 77:
        {
            /* every $a in e1 satisfies e2
             *  ==
             * not (some $a in e1 satisfies not (e2))
             *  ==
             * not (boolean (some $a in e1 satisfies not (boolean (e2))))
             *
             * (As not() uses boolean() to ensure that all items are
             *  present and we only want to support the more specific
             *  variant of not() we introduce additional calls 
             *  to boolean().)
             */
            PFfun_t *fn_not  = function (PFqname (PFns_fn, "not"));
            PFfun_t *fn_bool = function (PFqname (PFns_fn, "boolean"));

            C(p) = APPLY (fn_not, 
                          APPLY (fn_bool,
                                 some (
                                     C(LLLLL(p)),
                                     C(LLR(p)),
                                     APPLY (fn_not, 
                                            APPLY (fn_bool, C(R(p)))))));
        } break;

        /* QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                                       TypeDec),
                                                             nil),
                                                       OptExpr),
                                                 nil),
                                          OptExpr) */
        case 78:
        {
            /* every $a as t in e1 satisfies e2
             *  ==
             * not (some $a as t in e1 satisfies not (e2))
             *  ==
             * not (boolean (some $a as t in e1 satisfies not (boolean (e2))))
             *  ==
             * not (boolean (
             *   some $v in e1 satisfies
             *     let $a := proof ($v, t, seqcast (t, $v))
             *     return not (boolean (e2))))
             *
             * (As not() uses boolean() to ensure that all items are
             *  present and we only want to support the more specific
             *  variant of not() we introduce additional calls 
             *  to boolean().)
             */
            PFvar_t *v = new_var (NULL);
            PFfun_t *fn_not  = function (PFqname (PFns_fn, "not"));
            PFfun_t *fn_bool = function (PFqname (PFns_fn, "boolean"));

            C(p) = APPLY (fn_not,
                          APPLY (fn_bool, 
                                 some (
                                     var (v),
                                     C(LLR(p)),
                                     flwr (let (
                                               letbind (
                                                   C(LLLLL(p)),
                                                   proof (subty (var (v),
                                                                 C(LLLLR(p))),
                                                          seqcast (C(LLLLR(p)),
                                                                   var (v)))),
                                               nil ()),
                                           APPLY (fn_not,
                                                  APPLY (fn_bool,
                                                         C(R(p))))))));
        } break;

        /* TypeswitchExpr:         typeswitch (
                                       Expr,
                                       cases (case_ (var_type (OptCaseVar,
                                                               SequenceType),
                                                     OptExpr),
                                              cases (default_ (OptCaseVar,
                                                               OptExpr),
                                                     nil))) */
        case 79:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = flwr (let (letbind (var (v), C(L(p))),
                              nil ()),
                         typeswitch (
                             var (v),
                             cases (
                                 case_ (
                                     C(RLLR(p)),
                                     flwr (let (letbind (C(RLLL(p)),
                                                         seqcast (C(RLLR(p)),
                                                                  var (v))),
                                                nil ()),
                                           C(RLR(p)))),
                                 default_ (
                                     flwr (let (letbind (C(RRLL(p)), var (v)),
                                                nil ()),
                                           C(RRLR(p)))))));
        } break;

        /* OptCaseVar:             nil */
        case 80:
            /*
             * Generate new variable in case no variable has been
             * specified for case/default branch of typeswitch.
             */
            C(p) = var (new_var ("tsw"));
            break;

        /* OptCaseVar:             Var */
        case 81:
            assert (C(p));
            break;

        /* SequenceType:           seq_ty (ItemType) */
        case 82:
            /* fall through */

        /* SingleType:             seq_ty (AtomType) */
        case 83:
            switch (p->sem.oci) {
                case p_one:
                    C(p) = C(L(p));
                    break;
                case p_zero_or_one:
                    C(p) = seqtype (PFty_opt (C(L(p))->sem.type));
                    break;
                case p_zero_or_more:
                    C(p) = seqtype (PFty_star (C(L(p))->sem.type));
                    break;
                case p_one_or_more:
                    C(p) = seqtype (PFty_plus (C(L(p))->sem.type));
                    break;
                default:
                    PFoops_loc (OOPS_FATAL, p->loc,
                                "illegal occurrence indicator (%d) in "
                                "sequence type", p->sem.oci);
                    break;
            } break;
            
        /* ItemType:               empty_ty */
        case 84:
            C(p) = seqtype (PFty_empty ());
            break;

        /* ItemType:               NodeTest */
        case 85:
            assert (C(p));
            break;

        /* ItemType:               item_ty (nil) */
        case 86:
            C(p) = seqtype (PFty_xs_anyItem ());
            break;

        /* ItemType:               atom_ty (nil) */
        case 87:
            /* is the referenced type a known schema type? */
            if (! PFty_schema (PFty_named (p->sem.qname)))
                PFoops_loc (OOPS_TYPENOTDEF, p->loc,
                        "``%s''",
                        PFqname_str (p->sem.qname));

            C(p) = seqtype (PFty_named (p->sem.qname));
            break;

        /* ItemType:               schm_elem */
        case 88:
            /* FIXME: This probably requires work in the type system */
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "schema-element types are not supported");
            break;

        /* ItemType:               schm_attr */
        case 89:
            /* FIXME: This probably requires work in the type system */
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "schema-attribute types are not supported");
            break;

        /* AtomType:               atom_ty (nil) */
        case 90:
            /* is the referenced type a known schema type? */
            if (! PFty_schema (PFty_named (p->sem.qname)))
                PFoops_loc (OOPS_TYPENOTDEF, p->loc,
                        "``%s''",
                        PFqname_str (p->sem.qname));

            C(p) = seqtype (PFty_named (p->sem.qname));
            break;

        /* NodeTest:               node_ty (nil) */
        case 91:
            switch (p->sem.kind) {
                case p_kind_node:
                    /* node */
                    C(p) = seqtype (PFty_xs_anyNode ());
                    break;
                case p_kind_comment:
                    /* comment */
                    C(p) = seqtype (PFty_comm ());
                    break;
                case p_kind_text:
                    /* text */
                    C(p) = seqtype (PFty_text ());
                    break;
                case p_kind_pi:
                    /* processing-instruction */
                    C(p) = seqtype (PFty_pi (NULL));
                    break;
                case p_kind_doc:
                    /* document */
                    C(p) = seqtype (PFty_doc (PFty_xs_anyType ()));
                    break;
                case p_kind_elem:
                    /* element */
                    C(p) = seqtype (PFty_elem (PFqname (PFns_wild, NULL),
                                PFty_xs_anyType ()));
                    break;
                case p_kind_attr:
                    /* attribute */
                    C(p) = seqtype (PFty_attr (PFqname (PFns_wild, NULL),
                                               PFty_star (PFty_atomic ())));
                    break;
                default:
                    PFoops_loc (OOPS_FATAL, p->loc,
                                "illegal node kind in node type");
            }
            break;

        /* NodeTest:               node_ty (ElemOrAttrType) */
        case 92:
            /* TOPDOWN */

            switch (p->sem.kind) {
                case p_kind_elem:
                    elem_attr = PFty_elem;
                    any = PFty_xs_anyType ();
                    break;
                case p_kind_attr:
                    elem_attr = PFty_attr;
                    any = PFty_star (PFty_atomic ());
                    break;
                default:
                    PFoops_loc (OOPS_FATAL, p->loc,
                                "illegal node kind in NodeTest");
            }

            reduce (kids[0], nts[0]);

            C(p) = C(L(p));
            break;

        /* NodeTest:               node_ty (node_ty (nil)) */
        case 93:
            assert (p->sem.kind == p_kind_doc);
            assert (L(p)->sem.kind == p_kind_elem);

            C(p) = seqtype (PFty_doc (PFty_xs_anyElement ()));
            break;

        /* NodeTest:               node_ty (node_ty (ElemOrAttrType)) */
        case 94:
            /* TOPDOWN */

            assert (p->sem.kind == p_kind_doc);
            assert (L(p)->sem.kind == p_kind_elem);

            elem_attr = PFty_elem;
            any = PFty_xs_anyType ();

            reduce (kids[0], nts[0]);

            C(p) = seqtype (PFty_doc (C(LL(p))->sem.type));
            break;

        /* NodeTest:               node_ty (lit_str) */
        case 95:
            /*
             * processing-instruction tests may have a string
             * argument (restricting the pi target)
             */
            assert (p->sem.kind == p_kind_pi);
            C(p) = seqtype (PFty_pi (L(p)->sem.str));
            break;

        /* ElemOrAttrType:         req_ty (nil, nil) */
        case 96:
            /* element/attribute: any name, any type */
            C(p) = seqtype (elem_attr (PFqname (PFns_wild, NULL), any));
            break;
     
        /* ElemOrAttrType:         req_ty (nil, SchemaType) */
        case 97:
            /* element/attribute: any name, given type */
            C(p) = seqtype (elem_attr (PFqname (PFns_wild, NULL),
                                       C(R(p))->sem.type));
            break;

        /* ElemOrAttrType:         req_ty (req_name, nil) */
        case 98:
            /* element/attribute: given name, any type */
            C(p) = seqtype (elem_attr (L(p)->sem.qname, any));
            break;


        /* ElemOrAttrType:         req_ty (req_name, SchemaType) */
        case 99:
            /* element/attribute: given name, given type */
            C(p) = seqtype (elem_attr (L(p)->sem.qname, C(R(p))->sem.type));
            break;

        /* SchemaType:             named_ty */
        case 100:
            /* is the referenced type a known schema type definition? */
            if (! PFty_schema (PFty_named (p->sem.qname)))
                PFoops_loc (OOPS_TYPENOTDEF, p->loc,
                            "``%s''",
                            PFqname_str (p->sem.qname));

            C(p) = seqtype (PFty_named (p->sem.qname));
            break;

        /* IfExpr:                 if_ (Expr,
                                        then_else (OptExpr, OptExpr)) */
        case 101:
            C(p) = if_ (ebv (C(L(p))), then_else (C(RL(p)), C(RR(p))));
            break;

        /* OrExpr:                 AndExpr */
        case 102:
            break;

        /* OrExpr:                 or (AndExpr, OrExpr) */
        case 103:
        {
            PFfun_t *op_or = function (PFqname (PFns_op, "or"));

            C(p) = APPLY (op_or, ebv (C(L(p))), ebv (C(R(p))));
        } break;

        /* AndExpr:                ComparisonExpr */
        case 104:
            break;

        /* AndExpr:                and (ComparisonExpr, AndExpr) */
        case 105:
        {
            PFfun_t *op_and = function (PFqname (PFns_op, "and"));

            C(p) = APPLY (op_and, ebv (C(L(p))), ebv (C(R(p))));
        } break;

        /* ComparisonExpr:         RangeExpr */
        case 106:
            break;

        /* ComparisonExpr:         eq (RangeExpr, RangeExpr) */
        case 107:
        {
            PFfun_t *op_eq = function (PFqname (PFns_op, "eq"));
            comparison_worker (p, op_eq);
            
        } break;

        /* ComparisonExpr:         ne (RangeExpr, RangeExpr) */
        case 108:
        {
            PFfun_t *op_ne = function (PFqname (PFns_op, "ne"));
            comparison_worker (p, op_ne);

        } break;

        /* ComparisonExpr:         lt (RangeExpr, RangeExpr) */
        case 109:
        {
            PFfun_t *op_lt = function (PFqname (PFns_op, "lt"));
            comparison_worker (p, op_lt);

        } break;

        /* ComparisonExpr:         le (RangeExpr, RangeExpr) */
        case 110:
        {
            PFfun_t *op_le = function (PFqname (PFns_op, "le"));
            comparison_worker (p, op_le);

        } break;

        /* ComparisonExpr:         gt (RangeExpr, RangeExpr) */
        case 111:
        {
            PFfun_t *op_gt = function (PFqname (PFns_op, "gt"));
            comparison_worker (p, op_gt);

        } break;

        /* ComparisonExpr:         ge (RangeExpr, RangeExpr) */
        case 112:
        {
            PFfun_t *op_ge = function (PFqname (PFns_op, "ge"));
            comparison_worker (p, op_ge);

        } break;

        /* ComparisonExpr:         val_eq (RangeExpr, RangeExpr) */
        case 113:
        {
            PFfun_t *op_eq = function (PFqname (PFns_op, "eq"));
            val_comparison_worker (p, op_eq);

        } break;

        /* ComparisonExpr:         val_ne (RangeExpr, RangeExpr) */
        case 114:
        {
            PFfun_t *op_ne = function (PFqname (PFns_op, "ne"));
            val_comparison_worker (p, op_ne);

        } break;

        /* ComparisonExpr:         val_lt (RangeExpr, RangeExpr) */
        case 115:
        {
            PFfun_t *op_lt = function (PFqname (PFns_op, "lt"));
            val_comparison_worker (p, op_lt);

        } break;

        /* ComparisonExpr:         val_le (RangeExpr, RangeExpr) */
        case 116:
        {
            PFfun_t *op_le = function (PFqname (PFns_op, "le"));
            val_comparison_worker (p, op_le);

        } break;

        /* ComparisonExpr:         val_gt (RangeExpr, RangeExpr) */
        case 117:
        {
            PFfun_t *op_gt = function (PFqname (PFns_op, "gt"));
            val_comparison_worker (p, op_gt);

        } break;

        /* ComparisonExpr:         val_ge (RangeExpr, RangeExpr) */
        case 118:
        {
            PFfun_t *op_ge = function (PFqname (PFns_op, "ge"));
            val_comparison_worker (p, op_ge);

        } break;

        /* ComparisonExpr:         is (RangeExpr, RangeExpr) */
        case 119:
        {
            PFfun_t *op_is = function (PFqname (PFns_op, "is-same-node"));
            two_arg_fun_worker (p, op_is);

        } break;

        /* ComparisonExpr:         ltlt (RangeExpr, RangeExpr) */
        case 121:
        {
            PFfun_t *op_ltlt = function (PFqname (PFns_op, "node-before"));
            two_arg_fun_worker (p, op_ltlt);

        } break;

        /* ComparisonExpr:         gtgt (RangeExpr, RangeExpr) */
        case 122:
        {
            PFfun_t *op_gtgt = function (PFqname (PFns_op, "node-after"));
            two_arg_fun_worker (p, op_gtgt);

        } break;

        /* RangeExpr:              AdditiveExpr */
        case 123:
            break;

        /* RangeExpr:              range (RangeExpr, RangeExpr) */
        case 124:
        {
            PFfun_t *op_to = function (PFqname (PFns_op, "to"));
            two_arg_fun_worker (p, op_to);

        } break;

        /* AdditiveExpr:           MultiplicativeExpr */
        case 125:
            break;

        /* AdditiveExpr:           plus (AdditiveExpr, MultiplicativeExpr) */
        case 126:
        {
            PFfun_t *op_plus = function (PFqname (PFns_op, "plus"));
            calculation_worker (p, op_plus);

        } break;

        /* AdditiveExpr:           minus (AdditiveExpr, MultiplicativeExpr) */
        case 127:
        {
            PFfun_t *op_minus = function (PFqname (PFns_op, "minus"));
            calculation_worker (p, op_minus);

        } break;

        /* MultiplicativeExpr:     UnionExpr */
        case 128:
            break;

        /* MultiplicativeExpr:     mult (UnionExpr, MultiplicativeExpr) */
        case 129:
        {
            PFfun_t *op_times = function (PFqname (PFns_op, "times"));
            calculation_worker (p, op_times);

        } break;

        /* MultiplicativeExpr:     div (UnionExpr, MultiplicativeExpr) */
        case 130:
        {
            PFfun_t *op_div = function (PFqname (PFns_op, "div"));
            calculation_worker (p, op_div);

        } break;

        /* MultiplicativeExpr:     idiv (UnionExpr, MultiplicativeExpr) */
        case 131:
        {
            PFfun_t *op_idiv = function (PFqname (PFns_op, "idiv"));

            C(p) =  APPLY (op_idiv, 
                           fs_convert_op_by_type (fn_data (C(L(p))),
                                                  PFty_xs_integer ()),
                           fs_convert_op_by_type (fn_data (C(R(p))),
                                                  PFty_xs_integer ()));
        } break;

        /* MultiplicativeExpr:     mod (UnionExpr, MultiplicativeExpr) */
        case 132:
        {
            PFfun_t *op_mod = function (PFqname (PFns_op, "mod"));
            calculation_worker (p, op_mod);

        } break;

        /* UnionExpr:              IntersectExceptExpr */
        case 133:
            break;

        /* UnionExpr:              union_ (IntersectExceptExpr, UnionExpr) */
        case 134:
        {
            PFfun_t *op_union = function (PFqname (PFns_op, "union"));
            two_arg_fun_worker (p, op_union);

        } break;

        /* IntersectExceptExpr:    InstanceofExpr */
        case 135:
            break;

        /* IntersectExceptExpr:    intersect (InstanceofExpr,
                                              IntersectExceptExpr) */
        case 136:
        {
            PFfun_t *op_intersect = function (PFqname (PFns_op, "intersect"));
            two_arg_fun_worker (p, op_intersect);

        } break;

        /* IntersectExceptExpr:    except (InstanceofExpr,
                                           IntersectExceptExpr) */
        case 137:
        {
            PFfun_t *op_except = function (PFqname (PFns_op, "except"));
            two_arg_fun_worker (p, op_except);

        } break;

        /* InstanceofExpr:         TreatExpr */
        case 138:
            break;

        /* InstanceofExpr:         instof (TreatExpr, SequenceType) */
        case 139:
            C(p) = typeswitch (
                       C(L(p)),
                       cases (
                           case_ (C(R(p)), true_ ()),
                           default_ (false_ ())));
            break;

        /* TreatExpr:              CastableExpr */
        case 140:
            break;

        /* TreatExpr:              treat (CastableExpr, SequenceType) */
        case 141:
        {
            PFvar_t *v1 = new_var (NULL);
            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));

            C(p) = flwr (let (letbind (var (v1), C(L(p))), nil ()),
                         typeswitch (
                             var (v1),
                             cases (case_ (C(R(p)), var (v1)),
                                    default_ (APPLY (fn_error,
                                                     str("err:XP0050"))))));
        } break;

        /* CastableExpr:           CastExpr */
        case 142:
            break;

        /* CastableExpr:           castable (CastExpr, SingleType) */
        case 143:
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "`castable' keyword is not supported");
            break;

        /* CastExpr:               UnaryExpr */
        case 144:
            break;

        /* CastExpr:               cast (UnaryExpr, SingleType) */
        case 145:
            C(p) = cast (C(R(p)), fn_data (C(L(p))));
            break;

        /* UnaryExpr:              ValueExpr */
        case 146:
            break;

        /* UnaryExpr:              uminus (ValueExpr) */
        case 147:
        {
            PFfun_t *op_minus = function (PFqname (PFns_op, "minus"));

            C(p) = APPLY (op_minus,
                          num (0), 
                          fs_convert_op_by_type (
                              fn_data (C(L(p))),
                              PFty_xs_double ()));
        } break;

        /* UnaryExpr:              uplus (ValueExpr) */
        case 148:
        {
            PFfun_t *op_plus = function (PFqname (PFns_op, "plus"));

            C(p) = APPLY (op_plus,
                          num (0), 
                          fs_convert_op_by_type (
                              fn_data (C(L(p))),
                              PFty_xs_double ()));
        } break;

        /* ValueExpr:              ValidateExpr */
        case 149:
            break;

        /* ValueExpr:              PathExpr */
        case 150:
            break;

        /* ValueExpr:              ExtensionExpr */
        case 151:
            break;

        /* ValidateExpr:           validate (Expr) */
        case 152:
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc, "validation not supported");
            break;

        /* PathExpr:               PathExpr */
        case 153:
            assert (C(p));
            break;

        /* PathExpr:               LocationPath */
        case 154:
        {   /* guarantee document order (even for reverse axis steps) */
            assert (C(p));

            PFfun_t *ddo_as   = function (
                                    PFqname (
                                        PFns_pf, 
                                        "distinct-doc-order-or-atomic-sequence"
                                            ));
                
            C(p) = APPLY (ddo_as, C(p));
        } break;

        /* LocationPath:           root_ */
        case 155:
        {
            PFfun_t *_root = function (PFqname (PFns_fn, "root"));

            if (fs_dot)
                C(p) = APPLY (_root, var (fs_dot));
            else
                PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");

#if 0
    FIXME:
        The code below is actually closer to the standard that
        demands to not only translate the '/' operator into a
        call to fn:root(.), but into

          fn:root(.) treat as document .

        However, milprint_summer cannot evaluate the typeswitch
        involved, making '/' fail in any case.  We do not want to
        break too much, but rather be slightly off the standard
        for the time being.
                                                 Jens (26.10.05)

            PFvar_t *v1 = new_var (NULL);
            PFfun_t *_root = function (PFqname (PFns_fn, "root"));
            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));

            if (fs_dot)
                C(p) = flwr (let (letbind (var (v1), APPLY (_root, 
                                                            var (fs_dot))),
                                  nil ()),
                             typeswitch (
                                 var (v1),
                                 cases (
                                     case_ (
                                         seqtype (PFty_doc (
                                             PFty_plus (PFty_xs_anyNode ()))),
                                         var (v1)),
                                     default_ (
                                         APPLY (fn_error,
                                                str("err:XP0050"))))));
            else
                PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");
#endif
        } break;

        /* LocationPath:           locpath (PathExpr, PathExpr) */
        case 156:
        {
            /* TOPDOWN */

            /*
             * A path expression E1/E2 is to be evaluated as follows:
             * (see XQuery Oct 2004 WD, Section 3.2)
             *
             * (1) Expression E1 is evaluated, and if the result is not
             *     a (possibly empty) sequence of nodes, a type error
             *     is raised.
             *
             * (2) Each node resulting from the evaluation of E1 then
             *     serves in turn to provide an inner focus for an
             *     evaluation of E2.
             *
             * (3) The sequences resulting from all the evaluations of
             *     E2 are combined as follows:
             *
             *     -- If every evaluation of E2 returns a (possibly empty)
             *        sequence of nodes, these sequences are combined,
             *        and duplicate nodes are eliminated. If ordering mode
             *        is ordered, the resulting node sequence is returned
             *        in document order.
             *     -- If every evaluation of E2 returns a (possibly empty)
             *        sequence of atomic values, these sequences are
             *        concatenated, in order, and returned.
             *     -- Otherwise (that is, if the multiple evaluations of
             *        E2 return at least one node and at least one atomic
             *        value), a type error is raised.
             *
             * In XQuery Core:
             *
             * let $v := E1 return
             *   typeswitch ($v)
             *     case node* return
             *       fs:distinct-doc-order-or-atomic-sequence (
             *           let $fs:last := fn:count ($v) returni
             *               for $fs:dot at $fs:position in $v return E2)
             *     default error (err:XP0019)
             */

            PFvar_t *dot;
            PFvar_t *position;
            PFvar_t *last;
            PFvar_t *v = new_var (NULL);

            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));
            PFfun_t *count    = function (PFqname (PFns_fn, "count"));
            PFfun_t *ddo_as   = function (
                                    PFqname (
                                        PFns_pf, 
                                        "distinct-doc-order-or-atomic-sequence"
                                            ));

            /* compile context first */
            reduce (kids[1], nts[1]);

            /*
             * save context items $fs:dot, $fs:position, $fs:last
             * and establish new context item
             */
            dot = fs_dot;
            fs_dot = new_var ("dot");
            position = fs_position;
            fs_position = new_var ("pos");
            last = fs_last;
            fs_last = new_var ("lst");

            /* compile step in this new context */
            reduce (kids[0], nts[0]);

            C(p) =
                flwr (let (letbind (var (v), C(R(p))), nil ()),
                  typeswitch (
                    var (v),
                    cases (
                      case_ (
                        seqtype (PFty_star (PFty_xs_anyNode ())),
                        APPLY (ddo_as,
                               flwr (
                                 let (
                                   letbind (var (fs_last), 
                                            APPLY (count, var (v))),
                                   nil ()),
                                 flwr (for_ (
                                     forbind (forvars (var (fs_dot),
                                                       var (fs_position)),
                                              var (v)),
                                     nil ()),
                                 C(L(p)))))),
                      default_ (
                        APPLY (fn_error,
                               str ("err:XP0019: Argument to location step "
                                    "must be a node sequence."))))));

            /* restore context items */
            fs_dot = dot;
            fs_position = position;
            fs_last = last;

        } break;

        /* LocationPath:           locpath (step (NodeTest), PathExpr) */
        case 157:
        {   /*
             * For regular location steps, we don't actually need the
             * complicated stuff in the above rule.
             *
             * let $v := PathExpr return
             *   typeswitch ($v)
             *     case node* return
             *         fs:distinct-doc-order ($v/LocationStep)
             *     default error (err:XP0019)
             */
            PFvar_t *v = new_var (NULL);
            PFfun_t *ddo = function (PFqname (PFns_pf, "distinct-doc-order"));
            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));

            assert (C(LL(p)));
            
            C(L(p)) = step (L(p)->sem.axis, C(LL(p)));
            C(p) = flwr (let (letbind (var (v), C(R(p))),
                              nil ()),
                         typeswitch (
                           var (v),
                           cases (
                             case_ (seqtype (PFty_star (PFty_xs_anyNode ())),
                               APPLY (ddo, locsteps (C(L(p)),var (v)))),
                             default_ (
                               APPLY (fn_error,
                                      str ("err:XP0019: Argument to location "
                                           "step must be a node sequence."))))));

            /* Return the result of the path step in reverse document order
               if the axis is a reverse axis. This enables predicates to lookup
               the values at the correct position. */
            if (L(p)->sem.axis == p_ancestor ||
                L(p)->sem.axis == p_ancestor_or_self ||
                L(p)->sem.axis == p_parent ||
                L(p)->sem.axis == p_preceding ||
                L(p)->sem.axis == p_preceding_sibling) {
                
                PFvar_t *v = new_var (NULL);
                PFfun_t *fn_rev = function (PFqname (PFns_fn, "reverse"));
                
                C(p) = flwr (let (letbind (var (v), C(p)),
                                  nil ()),
                             APPLY (fn_rev, var (v)));
            }
        } break;

        /* LocationPath:           pred (LocationPath, OptExpr) */
        case 158:
        /* FilterExpr:             pred (PathExpr, Expr) */
        case 161:
        {   /* TOPDOWN */

            /*
             * Predicate evaluation:
             *
             * e1[e2]
             *  ==
             * let $v1 := e1 return
             *   let $fs:last := fn:count ($v1) return
             *     for $fs:dot at $fs:position in $v1 return
             *       let $v2 := e2 return
             *         let $v3 :=
             *           typeswitch ($v2)
             *             case $v8 as numeric return
             *               typeswitch ($v2)
             *                 case $v4 as xs:integer
             *                   return fn:eq ($v4, $fs:position)
             *                 case $v5 as xs:decimal
             *                   return fn:eq ($v5, $fs:position)
             *                 case $v6 as xs:double
             *                   return fn:eq ($v6, $fs:position)
             *                 default return   (: should actually not happen :)
             *                   let $v7 := $v8 cast as xs:double return
             *                     fn:eq ($v7, $fs:position)
             *             default return ebv ($v2)
             *           return
             *             if ($v3) then $fs:dot else ()
             *
             * Note:
             *   We explicitly line up the variants of type `numeric' here.
             *   (a simple `case $v4 as numeric return fn:eq ($v4, $fs:pos)'
             *   instead of the inner typeswitch would loose important
             *   static type information: $v4 would get static type numeric,
             *   and we would loose the (possibly more specific) type we
             *   inferred so far.)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);
            PFvar_t *v4 = new_var (NULL);
            PFvar_t *v5 = new_var (NULL);
            PFvar_t *v6 = new_var (NULL);
            PFvar_t *v7 = new_var (NULL);
            PFvar_t *v8 = new_var (NULL);
            PFvar_t *dot;
            PFvar_t *position;
            PFvar_t *last;
            PFfun_t *count = function (PFqname (PFns_fn, "count"));
            PFfun_t *op_eq = function (PFqname (PFns_op, "eq"));

            /* compile e1 */
            reduce (kids[0], nts[0]);

            /*
             * save context items $fs:dot, $fs:position, $fs:last
             * and establish new context item
             */
            dot = fs_dot;
            fs_dot = new_var ("dot");
            position = fs_position;
            fs_position = new_var ("pos");
            last = fs_last;
            fs_last = new_var ("lst");

            /* compile predicate expression in this new context */
            reduce (kids[1], nts[1]);

            C(p) = flwr (
                     let (letbind (var (v1), C(L(p))), nil ()),
                     flwr (
                       let (letbind (var (fs_last), 
                                     APPLY (count, var (v1))), nil ()),
                       flwr (
                         for_ (forbind (forvars (var (fs_dot),
                                                 var (fs_position)),
                                        var (v1)), nil ()),
                         flwr (
                           let (letbind (var (v2), C(R(p))), nil ()),
                           flwr (
                             let (
                               letbind (
                                 var (v3),
                                 typeswitch (
                                   var (v2),
                                   cases (
                                     case_ (
                                       seqtype (PFty_numeric ()),
                                       flwr (
                                         let (letbind (var (v8),
                                                       seqcast (
                                                         seqtype (
                                                           PFty_numeric ()),
                                                       var (v2))), nil ()),
                                         typeswitch (
                                           var (v2),
                                           cases (
                                             case_ (
                                               seqtype (PFty_xs_integer ()),
                                               flwr (
                                                 let (
                                                   letbind (
                                                     var (v4),
                                                     seqcast (
                                                       seqtype (
                                                         PFty_xs_integer()),
                                                       var (v2))), nil ()),
                                                 APPLY (op_eq, var (v4),
                                                        var (fs_position)))),
                                             default_ (
                                         /* <------ */
                                         typeswitch (
                                           var (v2),
                                           cases (
                                             case_ (
                                               seqtype (PFty_xs_decimal ()),
                                               flwr (
                                                 let (
                                                   letbind (
                                                     var (v5),
                                                     seqcast (
                                                       seqtype (
                                                         PFty_xs_decimal ()),
                                                       var (v2))), nil ()),
                                                 APPLY (op_eq, var (v5),
                                                        var (fs_position)))),
                                             default_ (
                                         /* <------ */
                                         typeswitch (
                                           var (v2),
                                           cases (
                                             case_ (
                                               seqtype (PFty_xs_double ()),
                                               flwr (
                                                 let (
                                                   letbind (
                                                     var (v6),
                                                     seqcast (
                                                       seqtype (
                                                         PFty_xs_double()),
                                                       var (v2))), nil ()),
                                                 APPLY (op_eq, var (v6),
                                                        var (fs_position)))),
                                             default_ (
                                         /* <------ */
                                         flwr (
                                           let (
                                             letbind (
                                               var (v7),
                                               cast (seqtype (PFty_xs_double()),
                                                     var (v8))), nil ()),
                                           APPLY (op_eq,
                                                  var (v7),
                                                  var (fs_position)))
                                         /* ------> */
                                                      )))
                                         /* ------> */
                                                      )))
                                         /* ------> */
                                                      )))
                                       )
                                     ),
                                   default_ (ebv (var (v2)))))), nil ()),
                             if_ (var (v3),
                              then_else (var (fs_dot), empty ())))))));

            /* restore context items */
            fs_dot = dot;
            fs_position = position;
            fs_last = last;
        } break;

        /* FilterExpr:             PrimaryExpr */
        case 160:
            assert (C(p));
            break;

        /* PrimaryExpr:            Literal */
        case 163:
            assert (C(p));
            break;

        /* PrimaryExpr:            Var */
        case 164:
            assert (C(p));
            break;

        /* PrimaryExpr:            ParenthesizedExpr */
        case 165:
            assert (C(p));
            break;

        /* PrimaryExpr:            ContextItemExpr */
        case 166:
            assert (C(p));
            break;

        /* PrimaryExpr:            FunctionCall */
        case 167:
            assert (C(p));
            break;

        /* PrimaryExpr:            Constructor */
        case 168:
            assert (C(p));
            break;

        /* PrimaryExpr:            OrderedExpr */
        case 169:
            assert (C(p));
            break;

        /* PrimaryExpr:            UnorderedExpr */
        case 170:
            assert (C(p));
            break;
            
        /* PrimaryExpr:            XRPCCall */
        case 171:
            assert (C(p));
            break;

        /* Literal:                NumericLiteral */
        case 172:
            break;

        /* Literal:                StringLiteral */
        case 173:
            break;

        /* NumericLiteral:         IntegerLiteral */
        case 174:
            break;

        /* NumericLiteral:         DecimalLiteral */
        case 175:
            break;

        /* NumericLiteral:         DoubleLiteral */
        case 176:
            break;

        /* IntegerLiteral:         lit_int */
        case 177:
            C(p) = num (p->sem.num);
            break;

        /* DecimalLiteral:         lit_dec */
        case 178:
            C(p) = dec (p->sem.dec);
            break;

        /* DoubleLiteral:          lit_dbl */
        case 179:
            C(p) = dbl (p->sem.dbl);
            break;

        /* StringLiteral:          lit_str */
        case 180:
            C(p) = str (p->sem.str);
            break;

        /* Var:                    var */
        case 181:
            C(p) = var (p->sem.var);
            break;

        /* ParenthesizedExpr:      Expr */
        case 182:
            assert (C(p));
            break;

        /* ContextItemExpr:        dot */
        case 183:
            if (fs_dot)
                C(p) = var (fs_dot);
            else
                PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");
            break;

        /* FunctionCall:           apply (nil) */
        case 184:
            /*
             * There are some built-in functions with special
             * implicit semantics.
             */

            /*
             * Functions `fn:string', `fn:name', `fn:local-name', 
             * `fn:namespace-uri', `fn:root' with no arguments
             * implicitly get the current
             * context node `.' as their argument.
             */
            if ( (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "string")))
                || (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "name")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "local-name")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "namespace-uri")))
                || (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "root")))
               ) {
                if (fs_dot)
                    C(p) = APPLY (p->sem.fun, var (fs_dot));
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");

                break;
            }

            /*
             * Functions `fn:string-length', `fn:normalize-space',
             * `fn:number'
             * implicitly get the string-value of the current context
             * node `.' as their argument if called without any
             * arguments.
             */
            if ((!PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "string-length")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "normalize-space")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "number")))
               ) {
                if (fs_dot) {
                    C(p) = APPLY (p->sem.fun, 
                                  APPLY (function (PFqname (PFns_fn, "string")),
                                         var (fs_dot)));
                }
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");

                break;
            }

            /*
             * `fn:position' is available as variable $fs:position.
             */
            if (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "position"))){
                if (fs_position)
                    C(p) = var (fs_position);
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc,
                                "position information not available");
                break;
            }

            /*
             * `fn:last' is available as variable $fs:last.
             */
            if (!PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "last"))) {
                if (fs_last)
                    C(p) = var (fs_last);
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc,
                                "position information not available");
                break;
            }

            /*
             * In all other cases just call the respective function
             */
            C(p) = apply (p->sem.fun, nil ());
            break;

        /* FunctionCall:           apply (FuncArgList) */
        case 185:
            /* TOPDOWN */

            assert (PFqname_eq (p->sem.fun->qname,
                                PFqname (PFns_fn, "position")));

            *(PFfun_t **) PFarray_add (funs) = p->sem.fun;
            *(PFcnode_t **) PFarray_add (args) = nil ();

            *(short *) PFarray_add (arg_num) = 0;

            /*
             * Functions `fn:id', `fn:idref' with one argument
             * implicitly get the current context node `.' as
             * their second/last argument.
             */
            if (p->sem.fun->arity == 1 &&
                ((!PFqname_eq (p->sem.fun->qname,
                               PFqname (PFns_fn, "id")))
                || (!PFqname_eq (p->sem.fun->qname,
                                 PFqname (PFns_fn, "idref")))
                )
               ) {
                if (fs_dot)
                    *(PFcnode_t **) PFarray_top (args)
                        = arg (var (fs_dot), *(PFcnode_t **) PFarray_top (args));
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");
            }

            reduce (kids[0], nts[0]);

            PFarray_del (funs);
            PFarray_del (args);
            PFarray_del (arg_num);

            C(p) = C(L(p));

            break;

        /* FuncArgList:            nil */
        case 186:
        {
            PFfun_t *fun = *(PFfun_t **) PFarray_top (funs);

            C(p) = apply (fun, *(PFcnode_t **) PFarray_top (args));

        } break;

        /* FuncArgList:            args (Expr, FuncArgList) */
        case 187:
        {   /* TOPDOWN */
            
            /*
             * Apply ``function conversion rules'' (W3C XQuery 3.1.5).
             * See also helper function function_conversion().
             */
            PFcnode_t    *dummy = nil ();
            PFfun_t      *fun;
            PFty_t        expected;
            int  param_num;
            PFfun_t      *implicit = NULL;
            PFcnode_t    *converted = NULL;

            /* translate function argument */
            reduce (kids[0], nts[0]);

            /* build up argument list -- fill in a dummy placeholder
               which will be replaced at the end by the real content */
            *(PFcnode_t **) PFarray_top (args)
                = arg (dummy, *(PFcnode_t **) PFarray_top (args));

            /* translate other arguments */
            reduce (kids[1], nts[1]);

            /* count arguments (parse tree is in reverse order
               - therefore increase argument after other arguments) */
            param_num = (*(short*) PFarray_top (arg_num))++;


            /* What function are we actually talking about? */
            fun = *(PFfun_t **) PFarray_top (funs);

            /* no dynamic overloading here */
            assert (fun->sig_count == 1);

            /*
             * There's exactly one function that allows an arbitrary
             * number of arguments: fn:concat(). Looking at the
             * parameter types here doesn't really make sense, we
             * use atomic? instead.
             */
            if (PFqname_eq (fun->qname,
                            PFqname (PFns_fn, "concat")) == 0) {
                expected = PFty_opt (PFty_atomic ());
            } else if (param_num == -1) {
                /* this is the magic leading URL string parameter of an
                 * XRPC function call, its expected type is string. */
                expected = PFty_opt (PFty_xs_string ());
            } else {
                /* look up expected argument type */
                expected = fun->sigs[0].par_ty[param_num];
            }

            /*
             * Apply function conversion rules (XQuery 3.1.5.)
             * to this function argument, but leave the *literal*
             * empty sequence alone.
             *
             * (Account for specific issues around the empty sequence
             * here.  In particular, function conversion would try to
             * iterate over the empty sequence, which resulted in an
             * undefined type for the iteration variable.)
             */
            if (C(L(p))->kind == c_empty)
                converted = C(L(p));
            else
                converted = function_conversion (C(L(p)), expected);

            /*
             * There's implicit semantics for some functions.
             */
            
            /* Implicitly call fn:round() and cast the result to integer
               for the second and third argument of fn:subsequence(). */
            if (! PFqname_eq (fun->qname, PFqname (PFns_fn, "subsequence")) &&
                param_num > 0) {
                converted = APPLY (function (PFqname (PFns_fn, "round")),
                                   converted);
		converted = cast (seqtype (PFty_xs_integer ()),
                                  converted);
            }
            
            /* Implicitly call fn:boolean() before fn:not(). */
            if (! PFqname_eq (fun->qname, PFqname (PFns_fn, "not")))
                implicit = function (PFqname (PFns_fn, "boolean"));

            /* Implicitly call fn:string() before fn:concat(). */
            if (! PFqname_eq (fun->qname, PFqname (PFns_fn, "concat")))
                implicit = function (PFqname (PFns_fn, "string"));

            /* replace the dummy placeholder in the list of function
               arguments by the real input */
            if (implicit)
                *dummy = *(APPLY (implicit, converted));
            else
                *dummy = *(converted); 

            /* propagate the complete function call */
            C(p) = C(R(p));
        } break;

        /* OrderedExpr:            ordered (Expr) */
        case 188:
            /* FIXME: Better treatment of `ordered' information?
             *         - Make this rule TOPDOWN
             *         - Keep a state variable during compilation
             */
            C(p) = ordered (C(L(p)));
            break;

        /* UnorderedExpr:          unordered (Expr) */
        case 189:
            C(p) = unordered (C(L(p)));
            break;

        /* Constructor:            ElementConstructor */
        case 190:
            break;

        /* Constructor:            AttributeConstructor */
        case 191:
            break;

        /* Constructor:            TextConstructor */
        case 192:
            break;

        /* Constructor:            CommentConstructor */
        case 193:
            break;

        /* Constructor:            PIConstructor */
        case 194:
            break;

        /* Constructor:            DocumentConstructor */
        case 195:
            break;

        /* ElementConstructor:     elem (TagName, OptContentExpr) */
        case 196:
        {
            PFfun_t *pf_matn
                = function (PFqname (PFns_pf, "merge-adjacent-text-nodes"));

            C(p) = constr_elem (C(L(p)), APPLY (pf_matn, C(R(p))));

        } break;

        /* AttributeConstructor:   attr (TagName, AttributeValue) */
        case 197:
            /*
             * The translation rules rooted at AttributeValue compile
             * the attribute value into a single string.
             */
            C(p) = constr_attr (C(L(p)), C(R(p)));
            break;

        /* TextConstructor:        text (Expr) */
        case 198:
        {
            /*
             * FIXME:
             *   Since June 2005 the W3C specs describe different variants
             *   for fs:item-sequence-to-untypedAtomic() for each node
             *   kind. fs:item-sequence-to-untypedAtomic-text() handles
             *   the empty sequence differently. For now, we leave everything
             *   as it is and wait until the W3C guys know what they want.
             */
            PFfun_t *is2uA =
	      function (PFqname (PFns_pf, "item-sequence-to-untypedAtomic"));

	    /* 
	     * Text node construction:
	     *
	     * text { e }
	     *  ==
	     * text { pf:item-sequence-to-untypedAtomic (fn:data (e))
                      cast as xs:string? }
	     */
	    C(p) = constr (p->kind, 
                           cast (seqtype (PFty_opt (PFty_xs_string ())),
                                 APPLY (is2uA, fn_data (C(L(p))))));
        } break;

        /* CommentConstructor:     comment (Expr) */
        case 199:
        {
            PFfun_t *is2uA =
                function (PFqname (PFns_pf, "item-sequence-to-untypedAtomic"));

            C(p) = constr (p->kind, APPLY (is2uA, C(L(p))));

        } break;

        /* PIConstructor:          pi (OptExpr, OptContentExpr) */
        case 200:
        {
            PFfun_t *is2uA =
                function (PFqname (PFns_pf, "item-sequence-to-untypedAtomic"));

            C(p) = constr_pi (C(L(p)), APPLY (is2uA, C(R(p))));
        } break;

        /* DocumentConstructor:    doc (Expr) */
        case 201:
        {
            PFfun_t *is2ns =
                function (PFqname (PFns_pf, "item-sequence-to-node-sequence"));

            C(p) = constr (p->kind, APPLY (is2ns, C(L(p))));
        } break;

        /* TagName:                tag */
        case 202:
            C(p) = constr_tag (p->sem.qname);
            break;

        /* TagName:                Expr */
        case 203:
        {
            /*
             * FIXME:
             *   The specs are a bit odd in this case.  The conversion
             *   of a string argument to a computed element constructor
             *   is not formally described.
             *
             *   fn:resolve-QName is not actually a solution:
             *
             *    (1) fn:resolve-QName() requires a second argument that
             *        describes the "in-scope namespaces" to resolve the
             *        prefix in the string argument.  Unfortunately we
             *        cannot provide one here.
             *
             *    (2) "in-scope namespaces" are not actually what we need
             *        here anyway.  Tag names for computed element
             *        constructors are based on "statically-known
             *        namespaces".
             *
             *   Hence, we introduce our own fn:resolve-QName (xs:string?)
             *   here and let the back-end try to give its best.  In
             *   milprint_summer.c, fn:resolve-QName will simply be the
             *   identity, as element construction will fiddle with strings
             *   there anyway.
             */
            PFfun_t *resolve_qname
                = function (PFqname (PFns_fn, "resolve-QName"));

            C(p) = APPLY (resolve_qname,
                          fs_convert_op_by_type (fn_data (C(p)),
                                                 PFty_xs_string ()));
        } break;

        /* OptContentExpr:         OptExpr */
        case 204:
        {
            PFfun_t *is2ns =
                function (PFqname (PFns_pf, "item-sequence-to-node-sequence"));

            C(p) = APPLY (is2ns, C(p));

        } break;

        /* OptContentExpr:         empty_seq */
        case 205:
            C(p) = empty ();
            break;

        /* OptContentExpr:         contseq (OptContentExpr, OptContentExpr) */
        case 206:
            C(p) = seq (C(L(p)), C(R(p)));
            break;

        /* AttributeValue:         Expr */
        case 207:
        {
            /*
             * Convert enclosed expression in attribute values as described in
             * [XQ, Section 3.7.1.1]:
             *
             *  a. Apply atomization (fn:data) to the enclosed expression.
             *  b. Cast each atomic value in the resulting sequence to a string
             *  c. Merge all the resulting strings with a space character
             *     inbetween.
             */
            PFvar_t *v = new_var (NULL);
            PFfun_t *string = function (PFqname (PFns_fn, "string"));
            PFfun_t *string_join = function (PFqname (PFns_fn, "string-join"));

            C(p) = APPLY (string_join,
                          flwr (for_ (forbind (forvars (var (v),
                                                        nil ()),
                                               C(p)),
                                      nil()),
                                APPLY (string, var (v))),
                          str (" "));
        } break;

        /* AttributeValue:         empty_seq */
        case 208:
            /*
             * An empty attribute value shall result in an empty string.
             */
            C(p) = str ("");
            break;

        /* AttributeValue:         contseq (AttributeValue, AttributeValue) */
        case 209:
        {
            /*
             * Both arguments have type xs:string after they had been
             * converted in the rule AttrEnclosedExpr. All that is left
             * to do is to concatenate them.
             *
             * fn:concat ([[ e1 ]], [[ e2 ]])
             */
            PFfun_t *concat = function (PFqname (PFns_fn, "concat"));

            C(p) = APPLY (concat, C(L(p)), C(R(p)));
        } break;

        /* ExtensionExpr:          ext_expr (Pragmas, nil) */
        case 210:
            /*
             * If an extension expression has an empty body we shall
             * raise a static error (W3C XQuery 3.14) if we don't
             * understand the pragma.
             */
            PFoops (OOPS_NOTSUPPORTED,
                    "err:XQST0079: pragma(s) not understood and pragma "
                    "expression body is absent");
            break;

        /* ExtensionExpr:          ext_expr (Pragmas, Expr) */
        case 211:
            /* Just ignore the pragma.  We don't understand it anyway. */
            C(p) = C(R(p));
            break;

        /* Pragmas:                nil */
        case 212:
            /* We don't understand pragmas anyway */
            break;

        /* Pragmas:                pragmas (pragma, Pragmas) */
        case 213:
            /* We don't understand pragmas anyway */
            break;

        /* DeclImport:             RevalidationDecl */
        case 214:
            break;

        /* RevalidationDecl:       revalid */
        case 215:
            break;

        /* ExprSingle:             InsertExpr */
        case 216:
            assert (C(p));
            break;

        /* ExprSingle:             DeleteExpr */
        case 217:
            assert (C(p));
            break;

        /* ExprSingle:             RenameExpr */
        case 218:
            assert (C(p));
            break;

        /* ExprSingle:             ReplaceExpr */
        case 219:
            assert (C(p));
            break;

        /* ExprSingle:             TransformExpr */
        case 220:
            assert (C(p));
            break;

        /* InsertExpr:             insert (SourceExpr, TargetExpr) */
        case 221:
        {
            PFvar_t *target = new_var (NULL);
            PFvar_t *v1     = new_var (NULL);
            PFvar_t *v2     = new_var (NULL);
            PFvar_t *v3     = new_var (NULL);
            PFvar_t *v4     = new_var (NULL);
            PFvar_t *ins    = new_var (NULL);

            PFfun_t *exactly_one
                = function (PFqname (PFns_fn, "exactly-one"));
            PFfun_t *is2ns
                = function (PFqname (PFns_pf, "item-sequence-to-node-sequence"));
            PFfun_t *matn
                = function (PFqname (PFns_pf, "merge-adjacent-text-nodes"));
            PFfun_t *insert = NULL;

            switch (p->sem.insert) {

                case p_first_into:
                    if (!insert)
                        insert
                            = function (PFqname (PFns_upd,"insertIntoAsFirst"));
                    /* fall through */

                case p_last_into:
                case p_into:
                    /*
                     * With "into", the position is implementation defined.
                     * we use it as a synonym for "into as last"
                     */
                    if (!insert)
                        insert
                            = function (PFqname (PFns_upd, "insertIntoAsLast"));
                    /* fall through */

                case p_after:
                    if (!insert)
                        insert
                            = function (PFqname (PFns_upd, "insertAfter"));
                    /* fall through */

                case p_before:
                    if (!insert)
                        insert
                            = function (PFqname (PFns_upd, "insertBefore"));

                    /*
                     *  1. Compile <SourceExpr> as if it were the content
                     *     of an element constructor.
                     *
                     *  2. If the insertion expression contains a document
                     *     node, replace it in the insertion sequence by
                     *     its children.
                     *
                     *  3. Invoke the respective update operation.
                     *
                     * NOTE: We do not guarantee here that (in case of
                     *   "before" or "after") that parent property of the
                     *   target expression is not empty.
                     *
                     * let $target := [[ <TargetExpr> ]]
                     * let $v1 := [[ <SourceExpr> ]]
                     * let $v2 := pf:item-sequence-to-node-sequence ($v1)
                     * let $v3 := pf:merge-adjacent-text-nodes ($v2)
                     * let $ins := for $v4 in $v3 return
                     *               typeswitch ($v4)
                     *                 case document-node() return $v4/node()
                     *                 default return $v4
                     * return
                     *   upd:insertXXX ($target, $ins)
                     */
                    C(p)
                        = flwr (
                            let (letbind (var (target), APPLY(exactly_one, C(R(p)))),
                            let (letbind (var (v1), C(L(p))),
                            let (letbind (var (v2), APPLY (is2ns, var (v1))),
                            let (letbind (var (v3), APPLY (matn, var (v2))),
                            let (
                                letbind (
                                    var (ins),
                                    flwr (
                                        for_ (
                                            forbind (
                                                forvars (var (v4), nil ()),
                                                var (v3)),
                                            nil ()),
                                        typeswitch (
                                            var (v4),
                                            cases (
                                                case_ (
                                                    seqtype (
                                                        PFty_doc (
                                                            PFty_xs_anyType())),
                                                    locsteps (
                                                        step (
                                                            p_child,
                                                            seqtype (
                                                                PFty_node())),
                                                        var (v4))),
                                                default_ (var (v4)))))),
                                nil ()))))),
                            APPLY (insert, var (target), var (ins)));
                    break;
            }

        } break;

        /* DeleteExpr:             delete (SourceExpr) */
        case 222:
        {   /*
             * [[ do delete <TargetExpr> ]]
             *  ==
             * let $v1 := [[ <TargetExpr> ]] return
             *   for $v2 in $v1 return
             *     upd:delete ($v2)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *delete = function (PFqname (PFns_upd, "delete"));

            C(p) = flwr (let (letbind (var (v1), C(L(p))), nil ()),
                         flwr (for_ (forbind (forvars (var (v2), nil ()),
                                              var (v1)),
                                     nil ()),
                               APPLY (delete, var (v2))));
        } break;


        /* ReplaceExpr:            replace (TargetExpr, ExprSingle) */
        case 223:
            if (p->sem.tru) {  
                /*
                 * The semantics of the expression
                 *
                 *   do replace value of <TargetExpr> with <ExprSingle>
                 *
                 * is described in the XQuery Update Facility:
                 *
                 * 1. <ExprSingle> is evaluated as if it were the content
                 *    expression of a text node constructor.
                 *
                 * 2. The <TargetExpr> must evaluate to a single node.
                 *
                 * 3. If <TargetExpr> evaluates to an element node,
                 *    generate the update primitive upd:relaceElementContent()
                 *
                 * 4. If <TargetExpr> evaluates to an attribute, text, or
                 *    processing-instruction node, replace their content
                 *    with the string obtained in Step 1.
                 *
                 * 5. If <TargetExpr> evaluates to a document node, raise
                 *    an error.
                 *
                 * [[ do replace value of <TargetExpr> with <ExprSingle> ]]
                 *  ==
                 * let $expr := [[ <ExprSingle> ]]
                 * let $string := fn:data ($expr)
                 * let $step1 := pf:item-sequence-to-untypedAtomic($string)
                 * let $target := [[ <TargetExpr> ]] return
                 *   typeswitch ($target)
                 *     case $e as xs:anyElement return
                 *       let $textnode := text { $step1 }
                 *       return upd:replaceElementContent ($e, $textnode)
                 *     case $a as xs:anyAttribute return
                 *       upd:replaceValue ($a, $step1)
                 *     case $t as text() return
                 *       upd:replaceValue ($t, $step1)
                 *     case $p as processing-instruction() return
                 *       upd:replaceValue ($p, $step1)
                 *     case $c as comment() return
                 *       upd:replaceValue ($c, $step1)
                 *     default return
                 *       error ("illegal expression in `do replace' clause")
                 */
                PFvar_t *expr     = new_var (NULL);
                PFvar_t *string   = new_var (NULL);
                PFvar_t *step1    = new_var (NULL);
                PFvar_t *target   = new_var (NULL);
                PFvar_t *e        = new_var (NULL);
                PFvar_t *textnode = new_var (NULL);
                PFvar_t *a        = new_var (NULL);
                PFvar_t *t        = new_var (NULL);
                PFvar_t *pi       = new_var (NULL);
                PFvar_t *c        = new_var (NULL);

                PFfun_t *exactly_one
                    = function (PFqname (PFns_fn, "exactly-one"));
                PFfun_t *is2uA
                    = function (PFqname (PFns_pf,
                                         "item-sequence-to-untypedAtomic"));
                PFfun_t *replCont
                    = function (PFqname (PFns_upd, "replaceElementContent"));
                PFfun_t *replace
                    = function (PFqname (PFns_upd, "replaceValue"));
                PFfun_t *error   = function (PFqname (PFns_fn, "error"));

                C(p)
                  = flwr (
                        let (letbind (var (expr), C(R(p))),
                            let (letbind (var (string), fn_data (var (expr))),
                                let (letbind (var (step1),
                                              APPLY (is2uA, var (string))),
                                    let (letbind (var (target), APPLY(exactly_one, C(L(p)))),
                                         nil())))),
                        typeswitch (
                            var (target),
                            cases (
                                case_ (
                                    seqtype (PFty_xs_anyElement ()),
                                    flwr (
                                        let (letbind (var (e),
                                                seqcast (
                                                    seqtype (
                                                        PFty_xs_anyElement ()),
                                                    var (target))),
                                        let (letbind (var (textnode),
                                                      constr (p_text,
                                                              var (step1))),
                                        nil ())),
                                        APPLY (replCont, var (e),
                                               var (textnode)))),
                            default_ (typeswitch (var (target), cases (
                                case_ (
                                    seqtype (PFty_xs_anyAttribute ()),
                                    flwr (
                                        let (letbind (var (a),
                                            seqcast (
                                                seqtype (
                                                    PFty_xs_anyAttribute ()),
                                                var (target))), nil ()),
                                        APPLY (replace, var (a), var (step1)))),
                            default_ (typeswitch (var (target), cases (
                                case_ (
                                    seqtype (PFty_text ()),
                                    flwr (
                                        let (letbind (var (t),
                                                      seqcast (
                                                          seqtype (
                                                              PFty_text ()),
                                                          var (target))),
                                             nil ()),
                                        APPLY (replace, var (t), var (step1)))),
                            default_ (typeswitch (var (target), cases (
                                case_ (
                                    seqtype (PFty_pi (NULL)),
                                    flwr (
                                        let (letbind (var (pi),
                                                      seqcast (
                                                          seqtype (
                                                              PFty_pi (NULL)),
                                                          var (target))),
                                             nil ()),
                                        APPLY (replace,
                                               var (pi), var (step1)))),
                            default_ (typeswitch (var (target), cases (
                                case_ (
                                    seqtype (PFty_comm ()),
                                    flwr (
                                        let (letbind (var (c),
                                                      seqcast (
                                                          seqtype (
                                                              PFty_comm ()),
                                                          var (target))),
                                             nil ()),
                                        APPLY (replace, var (c), var (step1)))),
                            default_ (
                                APPLY (error,
                                      str ("illegal expression in `do replace' "
                                           "clause"))
                                ))))))))))))))));

            }
            else {
                /*
                 * Evaluate the clause
                 *
                 *   do replace <TargetExpr> with <ExprSingle>
                 *
                 * as follows:
                 *
                 *  1. evaluate <ExprSingle> as if it were enclosed in
                 *     an element constructor, yielding the "replacement
                 *     sequence".
                 *
                 *  2. If the replacement sequence contains a document
                 *     node, replace it by its children.
                 *
                 * (3. Raise an error if the replacement sequence contains
                 *     an attribute node that does follow a node that is
                 *     not an attribute.)
                 *
                 *  4. <TargetExpr> must not have an empty parent property.
                 *
                 *  5. If <TargetExpr> is an element, text, comment, or
                 *     processing instruction node, generate the update
                 *     operation
                 *
                 *       upd:replaceNode ($target, $clist)
                 *
                 *  6. If <TargetExpr> is an attribute node, generate the
                 *     operations
                 *
                 *       upd:insertIntoAsLast ($parent, $clist)
                 *       upd:delete ($target).
                 *
                 * [[ do replace <TargetExpr> with <ExprSingle> ]]
                 *  ==
                 * let $target := [[ <TargetExpr> ]]
                 * let $v1 := [[ <ExprSingle> ]]
                 * let $v2 := fs:item-sequence-to-node-sequence ($v1)
                 * let $v3 := fs:merge-adjacent-text-nodes ($v2)
                 * let $repl := for $v4 in $v3 return
                 *                typeswitch ($v4)
                 *                  case document-node() return $v4/node()
                 *                  default return $v4
                 * let $parent := $target/parent::node()
                 * return
                 *   typeswitch ($parent)
                 *     case empty() return error ("parent of `replace' empty")
                 *     default return
                 *       typeswitch ($target)
                 *         case xs:anyAttribute return
                 *           let $v4 := upd:insertIntoAsLast ($parent, $repl)
                 *           let $v5 := upd:delete ($target)
                 *           return
                 *             ($v4, $v5)
                 *         case node() return
                 *           let $v6 := upd:insertBefore ($target, $repl)
                 *           let $v7 := upd:delete ($target)
                 *           return
                 *             ($v6, $v7)
                 *         default
                 *           error ("illegal expression in `do replace' expr")
                 */
                PFvar_t *target = new_var (NULL);
                PFvar_t *v1     = new_var (NULL);
                PFvar_t *v2     = new_var (NULL);
                PFvar_t *v3     = new_var (NULL);
                PFvar_t *v4     = new_var (NULL);
                PFvar_t *v5     = new_var (NULL);
                PFvar_t *v6     = new_var (NULL);
                PFvar_t *repl   = new_var (NULL);
                PFvar_t *parent = new_var (NULL);

                PFfun_t *exactly_one
                    = function (PFqname (PFns_fn, "exactly-one"));
                PFfun_t *is2ns
                    = function (PFqname (PFns_pf,
                                         "item-sequence-to-node-sequence"));
                PFfun_t *matn
                    = function (PFqname (PFns_pf,
                                         "merge-adjacent-text-nodes"));
                PFfun_t *insertlast
                    = function (PFqname (PFns_upd, "insertIntoAsLast"));
                PFfun_t *delete  = function (PFqname (PFns_upd, "delete"));
                PFfun_t *replaceNode
                    = function (PFqname (PFns_upd, "replaceNode"));
                PFfun_t *error   = function (PFqname (PFns_fn, "error"));

                C(p)
                  = flwr (
                      let (letbind (var (target), APPLY(exactly_one, C(L(p)))),
                      let (letbind (var (v1), C(R(p))),
                      let (letbind (var (v2), APPLY (is2ns, var (v1))),
                      let (letbind (var (v3), APPLY (matn, var (v2))),
                      let (letbind (
                          var (repl),
                          flwr (
                              for_ (
                                  forbind (
                                      forvars (var (v4), nil ()),
                                      var (v3)),
                                  nil ()),
                              typeswitch (
                                  var (v4),
                                  cases (
                                      case_ (
                                          seqtype (
                                              PFty_doc(PFty_plus(PFty_node()))),
                                          locsteps (step (p_child,
                                                          seqtype(PFty_node())),
                                                    var (v4))),
                                      default_ (var (v4)))))),
                      let (letbind (var (parent),
                                    locsteps (step (p_parent,
                                                    seqtype (PFty_node ())),
                                              var (target))),
                      nil ())))))),
                      typeswitch (
                          var (parent),
                          cases (
                            case_ (seqtype (PFty_empty ()),
                                   APPLY (error,
                                          str("parent of `do replace' empty"))),
                            default_ (
                                typeswitch (
                                    var (target),
                                    cases (
                                        case_ (
                                            seqtype (PFty_xs_anyAttribute ()),
                                            flwr (
                                                let (
                                                    letbind (
                                                        var (v4),
                                                        APPLY (insertlast,
                                                               var (parent),
                                                               var (repl))),
                                                let (
                                                    letbind (
                                                        var (v5),
                                                        APPLY (delete,
                                                               var (target))),
                                                nil ())),
                                                seq (var (v4), var (v5)))),
                                        default_ (
                                            typeswitch (var (target), cases (
                                        case_ (
                                            seqtype (PFty_node ()),
                                            flwr (
                                                let (
                                                    letbind (
                                                        var (v6),
                                                        APPLY (replaceNode,
                                                               var (target),
                                                               var (repl))),
                                                nil ()),
                                                var (v6))),
                                        default_ (
                                            APPLY (
                                                error,
                                                str ("illegal expression in "
                                                     "`do replace expression"))
                                            ))))))))));
            }
            
            break;

        /* RenameExpr:             rename (SourceExpr, NewNameExpr) */
        case 224:
        {
            /*
             * [[ do rename <TargetExpr> into <NewNameExpr> ]]
             *  ==
             * let $target := [[ <TargetExpr> ]] return
             *   let $newName := [[ <NewNameExpr ]] return
             *     upd:rename ($target, $newName)
             */
            PFvar_t *target  = new_var (NULL);
            PFvar_t *newName = new_var (NULL);
            PFfun_t *rename  = function (PFqname (PFns_upd, "rename"));
            PFfun_t *exactly_one = function (PFqname (PFns_fn, "exactly-one"));

            C(p) = flwr (let (letbind (var (target), APPLY(exactly_one, C(L(p)))),
                              nil ()),
                         flwr (let (letbind (var (newName), C(R(p))),
                                    nil ()),
                               APPLY (rename, var (target), var (newName))));
        } break;

        /* TransformExpr:          transform (TransformBindings,
                                             modify (ExprSingle, ExprSingle)) */
        case 225:
            PFoops (OOPS_NOTSUPPORTED,
                    "`transform' expressions are not supported in Pathfinder");
            break;


        /* TransformBindings:      nil */
        case 226:
            /* we do not support transform expressions anyway */
            break;

        /* TransformBindings:      transbinds (TransformBinding,
                                    TransformBindings) */
        case 227:
            /* we do not support transform expressions anyway */
            break;


        /* TransformBinding:       let (var_type (Var, nil), OptExpr) */
        case 228:
            /* we do not support transform expressions anyway */
            break;


        /* SourceExpr:             ExprSingle */
        case 229:
            assert (C(p));
            break;

        /* TargetExpr:             ExprSingle */
        case 230:
            assert (C(p));
            break;

        /* NewNameExpr:            ExprSingle */
        case 231:
        {
            /*
             * XQuery Update Facility (May 8, 2006, Sect. 2.3.4):
             * ``NewNameExpr'' is evaluated as though it were the name
             * expression of a computed element constructor.''
             *
             * (see also Rule TagName: OptExpr)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *resolve_qname
                = function (PFqname (PFns_fn, "resolve-QName"));

            C(p) = flwr (let (letbind (var (v1), fn_data (C(p))), nil ()),
                         flwr (let (letbind (
                                     var (v2),
                                     fs_convert_op_by_type (var (v1),
                                                            PFty_xs_string ())),
                                    nil ()),
                               APPLY (resolve_qname, var (v2))));
        } break;

        /* SequenceType:           seq_ty (stmt_ty (nil)) */
        case 232:
            /*
             * statement type for updating user-defined functions.
             */
            C(p) = seqtype (PFty_star (PFty_stmt ()));
            break;

        /* ExprSingle:             RecursiveExpr */
        case 233:
            break;

        /* RecursiveExpr:          recursion (
                                       var_type (Var, OptTypeDeclForRec),
                                       seed (ExprSingle, ExprSingle)) */
        case 234:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);

            /*
             * with $var [as type1] seeded by expr1 recurse expr2
             *
             * Both expressions must evaluate to a subtype of type1
             * (we allow empty sequences for expr2, though).  If
             * absent, type1 defaults to `node*'.  The static type
             * of the overall expression is type1.
             */
            C(p) = flwr (let (letbind (var (v1), C(RL(p))),
                         let (letbind (var (v2),
                                       proof (subty (var (v1), C(LR(p))),
                                              seqcast (C(LR(p)), var (v1)))),
                              nil ())),
                         recursion (C(LL(p)),
                                    seed (var (v2),
                                          proof (
                                              subty (
                                                  C(RR(p)),
                                                  seqtype (
                                                      PFty_opt (
                                                          C(LR(p))->sem.type))),
                                                 C(RR(p))))));
        } break;

        /* OptTypeDeclForRec:      nil */
        case 235:
            /*
             * If no type is given in an
             *
             *   with $x [as type] seeded by e1 return e2
             *
             * expression, we default to node*
             */
            C(p) = seqtype (PFty_star (PFty_node ()));
            break;

        /* OptTypeDeclForRec:      SequenceType */
        case 236:
            break;

        /* XRPCCall:               xrpc (Expr, FunctionCall) */
        case 237:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);

            C(p) = flwr (let (letbind (var (v1), C(L(p))),
                         let (letbind (var (v2), fn_data (var (v1))),
                         let (letbind (var (v3),
                                       cast (seqtype (PFty_xs_string ()),
                                             var (v2))),
                              nil ()))),
                         xrpc (var (v3), C(R(p))));
        } break;

        /* SequenceType:           seq_ty (docmgmt_ty (nil)) */
        case 238:
            /*
             * statement type for document managemtn user-defined functions.
             */
            C(p) = seqtype (PFty_star (PFty_docmgmt ()));
            break;

        default:
            PFoops_loc (OOPS_FATAL, p->loc, "untranslated expression");
            break;
    }
}

static void
comparison_worker (PFpnode_t *p, PFfun_t *fun)
{
    PFvar_t *v1 = new_var (NULL);
    PFvar_t *v2 = new_var (NULL);

    C(p) = some (
               var (v1), fn_data (C(L(p))),
               some (
                   var (v2), fn_data (C(R(p))),
                   APPLY (
                       fun,
                       fs_convert_op_by_type (
                           fs_convert_op_by_expr (var (v1), var (v2)),
                           PFty_xs_string ()),
                       fs_convert_op_by_type (
                           fs_convert_op_by_expr (var (v2), var (v1)),
                           PFty_xs_string ()))));
}

static void
val_comparison_worker (PFpnode_t *p, PFfun_t *fun)
{
    C(p) = APPLY (fun, 
                  fs_convert_op_by_type (fn_data (C(L(p))),
                                         PFty_xs_string ()),
                  fs_convert_op_by_type (fn_data (C(R(p))),
                                         PFty_xs_string ()));
}

static void
calculation_worker (PFpnode_t *p, PFfun_t *fun)
{
    C(p) = APPLY (fun,
                  fs_convert_op_by_type (fn_data (C(L(p))),
                                         PFty_xs_double ()),
                  fs_convert_op_by_type (fn_data (C(R(p))),
                                         PFty_xs_double ()));
}

static void
two_arg_fun_worker (PFpnode_t *p, PFfun_t *fun)
{
    C(p) = APPLY (fun, C(L(p)), C(R(p)));
}

/**
 * Extract sequence types from function parameter list and
 * put them into a single array, suitable for insertion into
 * PFfun_t.
 *                fun
 *               /   \
 *         fun_sig    Body
 *        /       \
 *    params      ReturnType
 *   /     \
 *  ty      params
 *         /      \
 *        ty      ...
 *                  \
 *                  nil
 *
 * Call with the topmost `param' node.
 */
static PFty_t *
parameter_types (PFpnode_t *paramlist)
{
    /* we assume functions to have less than 15 parameters */
    PFarray_t *par_ty = PFarray (sizeof (PFty_t), 15);
    PFpnode_t *n = paramlist;

    assert (paramlist);

    while (n->kind != p_nil) {
        assert (n->kind == p_params);
        assert (L(n) && L(n)->kind == p_param);
        assert (LL(n) && C(LL(n)) && C(LL(n))->kind == c_seqtype);

        *((PFty_t *) PFarray_add (par_ty)) = C(LL(n))->sem.type;

        n = R(n);
        assert (n);
    }

    return par_ty->base;
}

/**
 * Convert function argument or return value according to
 * to the function conversion rules in W3C XQuery 3.1.5.
 *
 * -- If the expected type is an atomic type,
 * 
 *    (1) Apply atomization (i.e., fn:data)
 *    (2) Cast each xdt:untypedAtomic item to the expected
 *        atomic type. For built-in functions with expected
 *        type `numeric', cast them to xs:double.
 *    (3) Apply numeric type promotion, if possible.
 *
 * -- Leave other arguments as they are. (FIXME: correct?)
 *
 * We use fn:data() for Step 1, fs:convert-operand() for Step 2.
 * FIXME: Step 3?
 *
 * In XQuery Core:
 *
 * -- The expected type t is an atomic type:
 *
 *    let $v1 := arg return
 *      for $v2 in $v1 return
 *        let $v3 := fn:data ($v2) return
 *          convert-operand ($v3, prime(expected))
 *
 */
static PFcnode_t *
function_conversion (const PFcnode_t *e, PFty_t expected)
{
    PFty_t exp_prime;

    PFcnode_t *ret;
    PFvar_t   *v = new_var (NULL);

    assert (e);

    exp_prime = PFty_prime (PFty_defn (expected));

    if (PFty_subtype (exp_prime, PFty_atomic ())) {

        /*
         * Built-in functions allow the expected type to be `numeric'.
         * In that case, we shall convert to xs:double.
         */
        if (PFty_eq (exp_prime, PFty_numeric ()))
            exp_prime = PFty_xs_double ();

        /* if type exp_prime is atomic untypedAtomic 
           does not need to be casted to atomic 
           -- we therefore can skip the convert-op */
        if (PFty_eq (exp_prime, PFty_atomic ()))
            ret = fn_data (e);
        else 
            /* Steps 1 and 2:
             *
             * for $v in fn:data (e) return
             *   convert-op ($v, exp_prime)
             */
            ret = flwr (for_ (forbind (forvars (var (v), nil ()),
                                       fn_data (e)), nil ()),
                        fs_convert_op_by_type (var (v), exp_prime));

    }
    else
        /* do nothing if expected is not atomic */
        ret = (PFcnode_t *) e;

    return ret;
}


/**
 * Compile parse tree into XQuery Core tree.
 *
 * @param r root of the abstract syntax tree
 * @return the Core equivalent of @a r
 */
PFcnode_t *
PFfs (PFpnode_t *r, PFquery_t *query)
{
    assert (r);

    PFquery = query;
    core_vars = 0;

    /* initially, there is no function on the current function stack */
    funs = PFarray (sizeof (PFfun_t *), 20);

    /* initially, there is no argument list on the current arguments stack */
    args = PFarray (sizeof (PFcnode_t *), 20);

    /* initially, there nothing on the current argument number stack */
    arg_num = PFarray (sizeof (short), 20);

    /* initially, the context item is undefined */
    fs_dot = NULL;
    fs_position = NULL;
    fs_last = NULL;

    /* We collect function signatures in the query prolog here. */
    fun_sigs = nil ();

    /* We collect variable declarations in the query prolog
     * in a root/hole pair. */
    var_decls.root = var_decls.hole = NULL;

    /* label the parse tree bottom up */
    PFfs_label (r);

    /* invoke compilation */
    process_fun_sigs (r, 1);    /* compile function signatures first */
    reduce (r, 1);              /* then all the rest */

    /* sanity: current function/argument list stacks need to be empty */
    assert (PFarray_empty (funs));
    assert (PFarray_empty (args));

    return r->core;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
