%{

/**
 * @file
 *
 * Compile parse tree into XQuery Core. This file implements
 * (more or less) the W3C XQuery Formal Semantics Working Draft.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2006 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */ 


#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "abssyn.h"
#include "qname.h"
#include "mem.h"

/* PFcnode_t */
#include "core.h"

/*
 * We need subtyping stuff for semantics of function application.
 */
#include "subtyping.h"

/* PFvar_t */
#include "variable.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFpnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/abssyn.h!
 */
%term    and            =   1
%term    apply          =   2
%term    args           =   3
%term    atom_ty        =   4
%term    attr           =   5
%term    base_uri       =   6
%term    bind           =   7
%term    binds          =   8
%term    case_          =   9
%term    cases          =  10
%term    cast           =  11
%term    castable       =  12
%term    coll_decl      =  13
%term    comment        =  14
%term    constr_decl    =  15
%term    contseq        =  16
%term    decl_imps      =  17
%term    def_order      =  18
%term    default_       =  19
%term    div            =  20
%term    doc            =  21
%term    dot            =  22
%term    elem           =  23
%term    empty_seq      =  24
%term    empty_ty       =  25
%term    ens_decl       =  26
%term    eq             =  27
%term    every          =  28
%term    except         =  29
%term    exprseq        =  30
%term    external       =  31
%term    flwr           =  32
%term    fns_decl       =  33
%term    fun            =  34
/* %term fun_decl       =  35  eliminated by function checking */
/* %term fun_ref        =  36  eliminated by function checking */
%term    fun_sig        =  37
%term    ge             =  38
%term    gt             =  39
%term    gtgt           =  40
%term    idiv           =  41
%term    if_            =  42
%term    inherit_ns     =  43
%term    instof         =  44
%term    intersect      =  45
%term    is             =  46
%term    item_ty        =  47
%term    le             =  48
%term    let            =  49
%term    lib_mod        =  50
%term    lit_dbl        =  51
%term    lit_dec        =  52
%term    lit_int        =  53
%term    lit_str        =  54
%term    locpath        =  55
%term    lt             =  56
%term    ltlt           =  57
%term    main_mod       =  58
%term    minus          =  59
%term    mod            =  60
%term    mod_imp        =  61
%term    mod_ns         =  62
%term    mult           =  63
%term    named_ty       =  64
%term    ne             =  65
%term    nil            =  66
%term    node_ty        =  67
%term    ns_decl        =  68
%term    or             =  69
%term    ord_ret        =  70
%term    orderby        =  71
%term    ordered        =  72
%term    ordering_mode  =  73
%term    orderspecs     =  74
%term    param          =  75
%term    params         =  76
%term    pi             =  77
%term    plus           =  78
%term    pred           =  79
%term    range          =  80
%term    req_name       =  81
%term    req_ty         =  82
%term    root_          =  83
%term    schm_ats       =  84
%term    schm_attr      =  85
%term    schm_elem      =  86
%term    schm_imp       =  87
%term    seq_ty         =  88
%term    some           =  89
%term    step           =  90
%term    tag            =  91
%term    text           =  92
%term    then_else      =  93
%term    treat          =  94
%term    typeswitch     =  95
%term    uminus         =  96
%term    union_         =  97
%term    unordered      =  98
%term    uplus          =  99
%term    val_eq         = 100
%term    val_ge         = 101
%term    val_gt         = 102
%term    val_le         = 103
%term    val_lt         = 104
%term    val_ne         = 105
%term    validate       = 106
%term    var            = 107
%term    var_decl       = 108
%term    var_type       = 109
/* %term varref         = 110  eliminated by function checking */
%term    vars           = 111
%term    where          = 112
%term    xmls_decl      = 113

%%

Query:                  MainModule                                  =   1 (10);
Query:                  lib_mod (ModuleDecl, Prolog)                =   2 (10);

MainModule:             main_mod (Prolog, QueryBody)                =   3 (10);
LibraryModule:          lib_mod (ModuleDecl, Prolog)                =   4 (10);

ModuleDecl:             mod_ns (lit_str)                            =   5 (10);
Prolog:                 DeclsImports                                =   6 (10);

DeclsImports:           decl_imps (DeclImport, DeclsImports)        =   7 (10);
DeclsImports:           nil                                         =   8 (10);

/* Expand function declarations here to allow for appropriate
 * top-down processing.
 */
DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                 SequenceType),
                                        Expr),
                                   DeclsImports)                    =   9 (10);
DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                 SequenceType),
                                        external),
                                   DeclsImports)                    =  10 (10);


DeclImport:             DefaultNamespaceDecl                        =  11 (10);
DeclImport:             XMLSpaceDecl                                =  12 (10);
DeclImport:             DefaultCollationDecl                        =  13 (10);
DeclImport:             BaseURIDecl                                 =  14 (10);
DeclImport:             ConstructionDecl                            =  15 (10);
DeclImport:             OrderingModeDecl                            =  16 (10);
DeclImport:             EmptyOrderingDecl                           =  17 (10);
DeclImport:             InheritNamespacesDecl                       =  18 (10);
DeclImport:             NamespaceDecl                               =  19 (10);
DeclImport:             SchemaImport                                =  20 (10);
DeclImport:             ModuleImport                                =  21 (10);
DeclImport:             VariableDeclaration                         =  22 (10);
DeclImport:             LibraryModule                               =  23 (10);

DefaultNamespaceDecl:   ens_decl (lit_str)                          =  24 (10);
DefaultNamespaceDecl:   fns_decl (lit_str)                          =  25 (10);

XMLSpaceDecl:           xmls_decl                                   =  26 (10);

DefaultCollationDecl:   coll_decl (lit_str)                         =  27 (10);

BaseURIDecl:            base_uri (lit_str)                          =  28 (10);

ConstructionDecl:       constr_decl                                 =  29 (10);

OrderingModeDecl:       ordering_mode                               =  30 (10);

EmptyOrderingDecl:      def_order                                   =  31 (10);

InheritNamespacesDecl:  inherit_ns                                  =  32 (10);

NamespaceDecl:          ns_decl (lit_str)                           =  33 (10);

SchemaImport:           schm_imp (lit_str, OptImportLoc_)           =  34 (10);

ModuleImport:           mod_imp (lit_str, OptImportLoc_)            =  35 (10);

OptImportLoc_:          nil                                         =  36 (10);
OptImportLoc_:          schm_ats (lit_str, OptImportLoc_)           =  37 (10);

OptParamList_:          nil                                         =  38 (10);
OptParamList_:          ParamList_                                  =  39 (10);

ParamList_:             nil                                         =  40 (10);
ParamList_:             params (Param, ParamList_)                  =  41 (10);

Param:                  param (SequenceType, Var)                   =  42 (10);

OptSequenceType_:       nil                                         =  43 (10);
OptSequenceType_:       SequenceType                                =  44 (10);

VariableDeclaration:    var_decl (var_type (Var,
                                            nil),
                                  OptExpr)                          =  45 (10);
VariableDeclaration:    var_decl (var_type (Var,
                                            SequenceType),
                                  OptExpr)                          =  46 (10);
VariableDeclaration:    var_decl (var_type (Var,
                                            OptSequenceType_),
                                  external)                         =  47 (10);

QueryBody:              OptExpr                                     =  48 (10);

OptExpr:                empty_seq                                   =  49 (10);
OptExpr:                Expr                                        =  50 (10);

Expr:                   exprseq (OptExpr, OptExpr)                  =  51 (10);
Expr:                   ExprSingle                                  =  52 (10);

ExprSingle:             FLWORExpr                                   =  53 (10);
ExprSingle:             QuantifiedExpr                              =  54 (10);
ExprSingle:             TypeswitchExpr                              =  55 (10);
ExprSingle:             IfExpr                                      =  56 (10);
ExprSingle:             OrExpr                                      =  57 (10);

FLWORExpr:              flwr (OptBindExpr,
                              where (OptWhereClause_,
                                     ord_ret (nil, OptExpr)))       =  58 (10);

FLWORExpr:              flwr (OptBindExpr,
                              where (OptWhereClause_,
                                     ord_ret (OrderByClause,
                                              OptExpr)))            =  59 (10);

OptBindExpr:            nil                                         =  60 (10);
OptBindExpr:            binds (let (var_type (Var,
                                              nil),
                                    OptExpr),
                               OptBindExpr)                         =  61 (10);
OptBindExpr:            binds (let (var_type (Var,
                                              TypeDeclaration),
                                    OptExpr),
                               OptBindExpr)                         =  62 (10);
OptBindExpr:            binds (bind (vars (var_type (Var,
                                                     nil),
                                           OptPosVar),
                                     OptExpr),
                               OptBindExpr)                         =  63 (10);
OptBindExpr:            binds (bind (vars (var_type (Var,
                                                     TypeDeclaration),
                                           OptPosVar),
                                     OptExpr),
                               OptBindExpr)                         =  64 (10);

OptPosVar:              nil                                         =  66 (10);
OptPosVar:              Var                                         =  67 (10);

TypeDeclaration:        SequenceType                                =  68 (10);

OptWhereClause_:        nil                                         =  69 (10);
OptWhereClause_:        OptExpr                                     =  70 (10);

OrderByClause:          orderby (OrderSpecList)                     =  71 (10);

OrderSpecList:          nil                                         =  72 (10);
OrderSpecList:          orderspecs (OptExpr, OrderSpecList)         =  73 (10);

QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                           nil),
                                                 nil),
                                           OptExpr),
                                     nil),
                              OptExpr)                              =  74 (10);
QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                           TypeDeclaration),
                                                 nil),
                                           OptExpr),
                                     nil),
                              OptExpr)                              =  75 (10);
QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                            nil),
                                                  nil),
                                            OptExpr),
                                      nil),
                               OptExpr)                             =  76 (10);
QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                            TypeDeclaration),
                                                  nil),
                                            OptExpr),
                                      nil),
                               OptExpr)                             =  77 (10);

TypeswitchExpr:         typeswitch (
                            OptExpr,
                            cases (case_ (var_type (OptCaseVar,
                                                    SequenceType),
                                          OptExpr),
                                   cases (default_ (OptCaseVar,
                                                    OptExpr),
                                          nil)))                    =  78 (10);

OptCaseVar:             nil                                         =  79 (10);
OptCaseVar:             Var                                         =  80 (10);

SequenceType:           seq_ty (ItemType)                           =  81 (10);

SingleType:             seq_ty (AtomType)                           =  82 (10);

ItemType:               empty_ty                                    =  83 (10);
ItemType:               NodeTest                                    =  84 (10);
ItemType:               item_ty (nil)                               =  85 (10);
ItemType:               atom_ty (nil)                               =  86 (10);
ItemType:               schm_elem                                   =  87 (10);
ItemType:               schm_attr                                   =  88 (10);

AtomType:               atom_ty (nil)                               =  89 (10);

NodeTest:               node_ty (nil)                               =  90 (10);
NodeTest:               node_ty (ElemOrAttrType)                    =  91 (10);
NodeTest:               node_ty (node_ty (nil))                     =  92 (10);
NodeTest:               node_ty (node_ty (ElemOrAttrType))          =  93 (10);
NodeTest:               node_ty (lit_str)                           =  94 (10);

ElemOrAttrType:         req_ty (nil, nil)                           =  95 (10);
ElemOrAttrType:         req_ty (nil, SchemaType)                    =  96 (10);
ElemOrAttrType:         req_ty (req_name, nil)                      =  97 (10);
ElemOrAttrType:         req_ty (req_name, SchemaType)               =  98 (10);

SchemaType:             named_ty                                    =  99 (10);

IfExpr:                 if_ (OptExpr,
                             then_else (OptExpr, OptExpr))          = 100 (10);

OrExpr:                 AndExpr                                     = 101 (10);
OrExpr:                 or (AndExpr, OrExpr)                        = 102 (10);

AndExpr:                ComparisonExpr                              = 103 (10);
AndExpr:                and (ComparisonExpr, AndExpr)               = 104 (10);

ComparisonExpr:         RangeExpr                                   = 105 (10);
ComparisonExpr:         eq (RangeExpr, RangeExpr)                   = 106 (10);
ComparisonExpr:         ne (RangeExpr, RangeExpr)                   = 107 (10);
ComparisonExpr:         lt (RangeExpr, RangeExpr)                   = 108 (10);
ComparisonExpr:         le (RangeExpr, RangeExpr)                   = 109 (10);
ComparisonExpr:         gt (RangeExpr, RangeExpr)                   = 110 (10);
ComparisonExpr:         ge (RangeExpr, RangeExpr)                   = 111 (10);
ComparisonExpr:         val_eq (RangeExpr, RangeExpr)               = 112 (10);
ComparisonExpr:         val_ne (RangeExpr, RangeExpr)               = 113 (10);
ComparisonExpr:         val_lt (RangeExpr, RangeExpr)               = 114 (10);
ComparisonExpr:         val_le (RangeExpr, RangeExpr)               = 115 (10);
ComparisonExpr:         val_gt (RangeExpr, RangeExpr)               = 116 (10);
ComparisonExpr:         val_ge (RangeExpr, RangeExpr)               = 117 (10);
ComparisonExpr:         is (RangeExpr, RangeExpr)                   = 118 (10);
ComparisonExpr:         ltlt (RangeExpr, RangeExpr)                 = 120 (10);
ComparisonExpr:         gtgt (RangeExpr, RangeExpr)                 = 121 (10);

RangeExpr:              AdditiveExpr                                = 122 (10);
RangeExpr:              range (RangeExpr, RangeExpr)                = 123 (10);

AdditiveExpr:           MultiplicativeExpr                          = 124 (10);
AdditiveExpr:           plus (AdditiveExpr, MultiplicativeExpr)     = 125 (10);
AdditiveExpr:           minus (AdditiveExpr, MultiplicativeExpr)    = 126 (10);

MultiplicativeExpr:     UnionExpr                                   = 127 (10);
MultiplicativeExpr:     mult (UnionExpr, MultiplicativeExpr)        = 128 (10);
MultiplicativeExpr:     div (UnionExpr, MultiplicativeExpr)         = 129 (10);
MultiplicativeExpr:     idiv (UnionExpr, MultiplicativeExpr)        = 130 (10);
MultiplicativeExpr:     mod (UnionExpr, MultiplicativeExpr)         = 131 (10);

UnionExpr:              IntersectExceptExpr                         = 132 (10);
UnionExpr:              union_ (IntersectExceptExpr, UnionExpr)     = 133 (10);

IntersectExceptExpr:    InstanceofExpr                              = 134 (10);
IntersectExceptExpr:    intersect (InstanceofExpr,
                                   IntersectExceptExpr)             = 135 (10);
IntersectExceptExpr:    except (InstanceofExpr,
                                IntersectExceptExpr)                = 136 (10);

InstanceofExpr:         TreatExpr                                   = 137 (10);
InstanceofExpr:         instof (TreatExpr, SequenceType)            = 138 (10);

TreatExpr:              CastableExpr                                = 139 (10);
TreatExpr:              treat (CastableExpr, SequenceType)          = 140 (10);

CastableExpr:           CastExpr                                    = 141 (10);
CastableExpr:           castable (CastExpr, SingleType)             = 142 (10);

CastExpr:               UnaryExpr                                   = 143 (10);
CastExpr:               cast (UnaryExpr, SingleType)                = 144 (10);

UnaryExpr:              ValueExpr                                   = 145 (10);
UnaryExpr:              uminus (ValueExpr)                          = 146 (10);
UnaryExpr:              uplus (ValueExpr)                           = 147 (10);

ValueExpr:              ValidateExpr                                = 148 (10);
ValueExpr:              PathExpr                                    = 149 (10);

ValidateExpr:           validate (OptExpr)                          = 150 (10);

PathExpr:               StepExpr                                    = 151 (10);
PathExpr:               LocationPath                                = 152 (10);

LocationPath:           root_                                       = 153 (10);
LocationPath:           locpath (StepExpr, StepExpr)                = 154 (10);
LocationPath:           locpath (LocationStep, StepExpr)            = 155 (10);

/*
 * NOTE: Did not exaclty use the normalize.brg rules here.
 *
PathExpr:               root_                                       = 151 (10);
PathExpr:               RelativePathExpr                            = 152 (10);

RelativePathExpr:       StepExpr                                    = 153 (10);
RelativePathExpr:       locpath (RelativePathExpr, StepExpr)        = 154 (10);
 */

StepExpr:               LocationStep                                = 156 (10);
StepExpr:               FilterExpr                                  = 157 (10);

FilterExpr:             PrimaryExpr                                 = 158 (10);
FilterExpr:             pred (StepExpr, OptExpr)                    = 159 (10);

LocationStep:           step (NodeTest)                             = 160 (10);

PrimaryExpr:            Literal                                     = 161 (10);
PrimaryExpr:            Var                                         = 162 (10);
PrimaryExpr:            ParenthesizedExpr                           = 163 (10);
PrimaryExpr:            ContextItemExpr                             = 164 (10);
PrimaryExpr:            FunctionCall                                = 165 (10);
PrimaryExpr:            Constructor                                 = 166 (10);
PrimaryExpr:            OrderedExpr                                 = 167 (10);
PrimaryExpr:            UnorderedExpr                               = 168 (10);

Literal:                NumericLiteral                              = 169 (10);
Literal:                StringLiteral                               = 170 (10);

NumericLiteral:         IntegerLiteral                              = 171 (10);
NumericLiteral:         DecimalLiteral                              = 172 (10);
NumericLiteral:         DoubleLiteral                               = 173 (10);

IntegerLiteral:         lit_int                                     = 174 (10);
DecimalLiteral:         lit_dec                                     = 175 (10);
DoubleLiteral:          lit_dbl                                     = 176 (10);

StringLiteral:          lit_str                                     = 177 (10);

Var:                    var                                         = 178 (10);

ParenthesizedExpr:      OptExpr                                     = 179 (10);

ContextItemExpr:        dot                                         = 180 (10);

FunctionCall:           apply (nil)                                 = 181 (10);
FunctionCall:           apply (FuncArgList)                         = 182 (10);

FuncArgList:            nil                                         = 183 (10);
FuncArgList:            args (OptExpr, FuncArgList)                 = 184 (10);

OrderedExpr:            ordered (OptExpr)                           = 185 (10);
UnorderedExpr:          unordered (OptExpr)                         = 186 (10);

Constructor:            ElementConstructor                          = 187 (10);
Constructor:            AttributeConstructor                        = 188 (10);
Constructor:            TextConstructor                             = 189 (10);
Constructor:            CommentConstructor                          = 190 (10);
Constructor:            PIConstructor                               = 191 (10);
Constructor:            DocumentConstructor                         = 192 (10);

ElementConstructor:     elem (TagName, OptContentExpr)              = 193 (10);

AttributeConstructor:   attr (TagName, AttributeValue)              = 194 (10);

TextConstructor:        text (OptExpr)                              = 195 (10);

CommentConstructor:     comment (OptExpr)                           = 196 (10);

PIConstructor:          pi (OptExpr, OptContentExpr)                = 197 (10);

DocumentConstructor:    doc (OptExpr)                               = 198 (10);

TagName:                tag                                         = 199 (10);
TagName:                OptExpr                                     = 200 (10);

OptContentExpr:         Expr                                        = 201 (10);
OptContentExpr:         empty_seq                                   = 202 (10);
OptContentExpr:         contseq (OptContentExpr, OptContentExpr)    = 203 (10);

AttributeValue:         Expr                                        = 204 (10);
AttributeValue:         empty_seq                                   = 205 (10);
AttributeValue:         contseq (AttributeValue, AttributeValue)    = 206 (10);


%%

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))
#define LLR(p) R(L(L(p)))
#define RRR(p) R(R(R(p)))
#define LLL(p) L(L(L(p)))
#define LLLL(p) L(L(L(L(p))))
#define LLLLL(p) L(L(L(L(L(p)))))
#define LLLLR(p) R(L(L(L(L(p)))))
#define LLLR(p) R(L(L(L(p))))
#define RLLR(p) R(L(L(R(p))))
#define RLLL(p) L(L(L(R(p))))
#define RLR(p) R(L(R(p)))
#define RRLL(p) L(L(R(R(p))))
#define RRLR(p) R(L(R(R(p))))

/** Access the Core representation of any node */
#define C(p) ((p)->core)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

/** mnemonic XQuery Core constructors */
#include "core_mnemonic.h"

/**
 * The current context items $fs:dot, $fs:position, and $fs:last
 * (see W3C XQuery Formal Semantics 3.1.2)
 */
static PFvar_t *fs_dot;
static PFvar_t *fs_position;
static PFvar_t *fs_last;

/**
 * The top of this stack holds a reference to the current function
 * (whose argument list is currently compiled).
 */
static PFarray_t *funs;
/**
 * The top of this stack holds a representation of the 
 * argument list to be passed to the currently compiled function application:
 *
 *               arg (e1, arg (e2, ..., arg (en, nil)...))
 */
static PFarray_t *args;
/**
 * The top of this stack holds the function argument number
 * that is currently compiled.
 */
static PFarray_t *arg_num;

/**
 * Collect function signatures here. The will be available as the
 * left child of the root node of the resulting Core tree.
 */
static PFcnode_t *fun_sigs;

/**
 * Collect variable declarations from the query prolog in this
 * root/hole pair. (see rule for VariableDeclaration)
 */
static struct {
    PFcnode_t *root;
    PFcnode_t *hole;
} var_decls;

/* element/attribute constructor and content */
static PFty_t (*elem_attr) (PFqname_t, PFty_t);
static PFty_t any;

static PFty_t *parameter_types (PFpnode_t *paramlist);

static PFcnode_t *function_conversion (const PFcnode_t *e, PFty_t expected);
static void comparison_worker (PFpnode_t *p, PFfun_t *fun);
static void val_comparison_worker (PFpnode_t *p, PFfun_t *fun);
static void calculation_worker (PFpnode_t *p, PFfun_t *fun);
static void two_arg_fun_worker (PFpnode_t *p, PFfun_t *fun);

static void reduce (PFpnode_t * p, int goalnt);

/**
 * Watch out for function declarations in the abstract syntax tree
 * and call reduce() for them.
 *
 * Compilation of expressions into Core requires the full signatures
 * of all functions to be readily available.  Function checking
 * (functions.c) has only set the number of function arguments, but
 * not their types (and neither the function return type).
 *
 * reduce() contains logic to derive #PFty_t types from abstract
 * syntax tree fragments.  We thus call reduce() for the function
 * signature whenever we find a function declaration.  Otherwise
 * we follow all those children that might contain further function
 * declarations.  (Note that we only handle the function signature
 * here, not its body.)
 */
static void
process_fun_sigs (PFpnode_t *p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */

    /* determine rule that matches for this non-terminal */
    rule = PFfs_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert (rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFfs_nts[rule];
    PFfs_kids (p, rule, kids);

    switch (rule) {

        /* Query:                  lib_mod (ModuleDecl, Prolog) */
        case 2:
        /* LibraryModule:          lib_mod (ModuleDecl, Prolog) */
        case 4:

            /* we are heading for function signatures in the prolog only */
            process_fun_sigs (kids[1], nts[1]);
            break;

        /* MainModule:             main_mod (Prolog, QueryBody) */
        case 3:

            /* we are heading for function signatures in the prolog only */
            process_fun_sigs (kids[0], nts[0]);
            break;

        /* DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                            SequenceType),
                                                   Expr),
                                              DeclsImports) */
        case 9:
            /* fall through */

        /* DeclsImports:           decls_imps (fun (fun_sig (OptParamList_,
                                                             SequenceType),
                                                    external),
                                               DeclsImports) */
        case 10:
            /*
             * Parse tree situation for function declarations:
             *
             *                   decls_imps
             *                  /          \
             *               fun        (other decls)
             *              /   \
             *        fun_sig    BODY
             *        /     \
             *  ParamList  ReturnType
             */

            /* debugging only
            PFinfo (OOPS_NOTICE, "processing `%s'",
                    PFqname_str (L(p)->sem.apply.fun->qname));
            */

            /*
             * This is the situation that process_fun_sigs() actually
             * looks out for.  We call reduce() for function signatures.
             * reduce() contains code to build up the Core equivalent
             * of the function signature and---most importantly---code
             * to derive #PFty_t types from parse tree fragments.  We
             * use the latter to fill in the missing parts into the
             * #PFfun_t struct.
             */
            reduce (kids[0], nts[0]);
            reduce (kids[1], nts[1]);

            L(p)->sem.apply.fun->par_ty = parameter_types (LLL(p));
            L(p)->sem.apply.fun->ret_ty = C(LLR(p))->sem.type;

            /* Look out for more function declarations */
            process_fun_sigs (kids[3], nts[3]);

            break;


        /* Query:                  MainModule */
        case 1:

        /* Prolog:                 DeclsImports */
        case 6:

        /* DeclsImports:           decl_imps (DeclImport, DeclsImports) */
        case 7:

        /* DeclImport:             LibraryModule */
        case 23:

            /* These are the interesting paths to follow */
            for (unsigned short i = 0; nts[i]; i++)
                process_fun_sigs (kids[i], nts[i]);
            break;

        default:
            break;
    }
}

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFpnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */
    PFcnode_t    *c;              /* temporary helper variable */

    /* determine rule that matches for this non-terminal */
    rule = PFfs_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert (rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFfs_nts[rule];
    PFfs_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    switch (rule) {
        /* DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                            SequenceType),
                                                   Expr),
                                              DeclsImports) */
        case 9:
        /* DeclsImports:           decls_imps (fun (fun_sig (OptParamList_,
                                                             SequenceType),
                                                    external),
                                               DeclsImports) */
        case 10:
        /* NodeTest:               node_ty (ElemOrAttrType) */
        case 91:
        /* NodeTest:               node_ty (node_ty (ElemOrAttrType)) */
        case 93:
        /* LocationPath:           locpath (StepExpr, StepExpr) */
        case 154:
        /* FilterExpr:             pred (StepExpr, Expr) */
        case 159:
        /* FunctionCall:           apply (nil) */
        case 181:
        /* FunctionCall:           apply (FuncArgList) */
        case 182:
        /* FuncArgList:            args (Expr, FuncArgList) */
        case 184:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    if (!topdown)
        for (unsigned short i = 0; nts[i]; i++)
            reduce (kids[i], nts[i]);

    switch (rule) {

        /* Query:                  MainModule */
        case 1:
            break;

        /* Query:                  lib_mod (ModuleDecl, Prolog) */
        case 2:
            /*
             * Catch the case where we got an XQuery module
             * directly as the input.
             *
             * Don't know what the best is to do here. For now,
             * we pick Peter's approach and just "simulate" a
             * query that returns just the empty sequence.
             */

            /*
             * We may have collected variable bindings from the
             * prolog. Put them on top of the query.
             */
            if (var_decls.root) {
                var_decls.hole->child[1] = nil ();
                c = flwr (var_decls.root, empty ());
            }
            else
                c = empty ();

            /*
             * Make a `main' node the root of the resulting tree.
             * Left child lists all the function signatures. Right
             * child is the query itself.
             */
            C(p) = PFcore_main (fun_sigs, c);

            break;

        /* MainModule:             main_mod (Prolog, QueryBody) */
        case 3:
            /*
             * We may have collected variable bindings from the
             * prolog. Put them on top of the query.
             */
            if (var_decls.root) {
                var_decls.hole->child[1] = nil ();
                c = flwr (var_decls.root, C(R(p)));
            }
            else
                c = C(R(p));

            /*
             * Make a `main' node the root of the resulting tree.
             * Left child lists all the function signatures. Right
             * child is the query itself.
             */
            C(p) = PFcore_main (fun_sigs, c);

            break;

        /* LibraryModule:          lib_mod (ModuleDecl, Prolog) */
        case 4:
            break;

        /* ModuleDecl:             mod_ns (lit_str) */
        case 5:
            break;

        /* Prolog:                 DeclsImports */
        case 6:
            break;

        /* DeclsImports:           decl_imps (DeclImport, DeclsImports) */
        case 7:
            break;

        /* DeclsImports:           nil */
        case 8:
            break;

        /* DeclsImports:           decl_imps (fun (fun_sig (OptParamList_,
                                                            SequenceType),
                                                   Expr),
                                              DeclsImports) */
        case 9:
        {   /* TOPDOWN */

            /*
             * User-defined functions:
             *
             * (1) Create a unique PFfun_t data structure, containing
             *     type information, number of arguments, and an argument
             *     list (PFvar_t pointers).
             *     This has already happened during function checking.
             *
             * (2) Set function signatures
             *     This has been done already during process_fun_sigs().
             * 
             * (3) Translate function body.
             *
             * (4) Store the Core equivalent of the function body in
             *     the PFfun_t data structure. Parameter variables will
             *     appear free in this Core expression.
             *     Step (3) is what we do here.
             *
             * [(5) Before executing the Core code for this function,
             *      the back-end (e.g., algebra translation) needs to
             *      fill the variable environment with bindings for all
             *      the function parameters.
             *      This has to be done in the back-end.]
             *
             * Parse tree situation for function declarations:
             *
             *                   decls_imps
             *                  /          \
             *               fun        (other decls)
             *              /   \
             *        fun_sig    BODY
             *        /     \
             *  ParamList  ReturnType
             */

            PFvar_t *v = new_var (NULL);

            /*
             * No need to compile function signature.  This has been
             * done already in process_fun_sigs().
             */

            /* recurse */
            reduce (kids[2], nts[2]);
            reduce (kids[3], nts[3]);

            /*
             * Apply function conversion to the function result
             * (see W3C XQuery 3.1.5 or function_conversion()
             */

            C(LR(p)) = flwr (let (letbind (var (v), C(LR(p))), nil ()),
                             function_conversion (var (v), 
                                                  C(LLR(p))->sem.type));
            L(p)->sem.apply.fun->core = C(LR(p));

            fun_sigs = fun_decls (fun_decl (L(p)->sem.apply.fun, C(LLL(p)), C(LR(p))),
                                  fun_sigs);

        } break;


        /* DeclsImports:           decls_imps (fun (fun_sig (OptParamList_,
                                                             SequenceType),
                                                    external),
                                               DeclsImports) */
        case 10:
        {   /* TOPDOWN */

            /*
             * Parse tree situation for function declarations:
             *
             *                   decls_imps
             *                  /          \
             *               fun        (other decls)
             *              /   \
             *        fun_sig    external
             *        /     \
             *  ParamList  ReturnType
             */

            /*
             * We have already handled the function signature, so
             * nothing left to do for external functions.
             *
             * just recurse and handle other declarations
             */
            reduce (kids[2], nts[2]);

        } break;

        /* DeclImport:             DefaultNamespaceDecl */
        case 11:
            break;

        /* DeclImport:             XMLSpaceDecl */
        case 12:
            break;

        /* DeclImport:             DefaultCollationDecl */
        case 13:
            break;

        /* DeclImport:             BaseURIDecl */
        case 14:
            break;

        /* DeclImport:             ConstructionDecl */
        case 15:
            break;

        /* DeclImport:             OrderingModeDecl */
        case 16:
            break;

        /* DeclImport:             EmptyOrderingDecl */
        case 17:
            break;

        /* DeclImport:             InheritNamespacesDecl */
        case 18:
            break;

        /* DeclImport:             NamespaceDecl */
        case 19:
            break;

        /* DeclImport:             SchemaImport */
        case 20:
            break;

        /* DeclImport:             ModuleImport */
        case 21:
            break;

        /* DeclImport:             VariableDeclaration */
        case 22:
            break;

        /* DeclImport:             LibraryModule */
        case 23:
            break;

        /* DefaultNamespaceDecl:   ens_decl (lit_str) */
        case 24:
            break;

        /* DefaultNamespaceDecl:   fns_decl (lit_str) */
        case 25:
            break;

        /* XMLSpaceDecl:           xmls_decl */
        case 26:
            break;

        /* DefaultCollationDecl:   coll_decl (lit_str) */
        case 27:
            PFinfo_loc (OOPS_WARN_NOTSUPPORTED, p->loc,
                        "default collation declaration will be ignored");
            break;

        /* BaseURIDecl:            base_uri (lit_str) */
        case 28:
            PFinfo_loc (OOPS_WARN_NOTSUPPORTED, p->loc,
                        "base-uri declaration will be ignored");
            break;

        /* ConstructionDecl:       constr_decl */
        case 29:
            PFinfo_loc (OOPS_WARN_NOTSUPPORTED, p->loc,
                        "construction mode declaration will be ignored");
            break;

        /* OrderingModeDecl:       ordering_mode */
        case 30:
            PFquery.ordering = p->sem.tru;
            break;

        /* EmptyOrderingDecl:      def_order */
        case 31:
            PFquery.empty_order = p->sem.mode.empty;
            break;

        /* InheritNamespacesDecl:  inherit_ns */
        case 32:
            PFquery.inherit_ns = p->sem.tru;
            break;

        /* NamespaceDecl:          ns_decl (lit_str) */
        case 33:
            break;

        /* SchemaImport:           schm_imp (lit_str, OptImportLoc_) */
        case 34:
            break;

        /* ModuleImport:           mod_imp (lit_str, OptImportLoc_) */
        case 35:
            /*
             * module imports have already been handled by the parser
             */
            break;

        /* OptImportLoc_:          nil */
        case 36:
            break;

        /* OptImportLoc_:          schm_ats (lit_str, OptImportLoc_) */
        case 37:
            break;

        /* OptParamList_:          nil */
        case 38:
            C(p) = nil ();
            break;

        /* OptParamList_:          ParamList_ */
        case 39:
            break;

        /* ParamList_:             nil */
        case 40:
            C(p) = nil ();
            break;

        /* ParamList_:             params (Param, ParamList_) */
        case 41:
            C(p) = params (C(L(p)), C(R(p)));
            break;

        /* Param:                  param (SequenceType, Var) */
        case 42:
            C(p) = param (C(L(p)), C(R(p)));
            break;

        /* OptSequenceType_:       nil */
        case 43:
            break;

        /* OptSequenceType_:       SequenceType */
        case 44:
            break;

        /* VariableDeclaration:    var_decl (var_type (Var,
                                                       nil),
                                             OptExpr) */
        case 45:
            /*
             * We translate
             *
             *  declare variable $a := ea ;
             *  declare variable $b := eb ;
             *  e0
             *
             * as
             *
             *  let $a := ea return
             *    let $b := eb return
             *      e0  .
             *
             * So while traversing the Query Prolog (this is what we're
             * currently doing), we build up a chain of nested let clauses,
             * with the return part as a hole.
             */
            c = let (letbind (C(LL(p)), C(R(p))), nil ());

	    /* set global information */
	    LL(c)->sem.var->global = true;

            if (var_decls.root)
                var_decls.hole = var_decls.hole->child[1] = c;
            else
                var_decls.root = var_decls.hole = c;

            break;

        /* VariableDeclaration:    var_decl (var_type (Var,
                                                       SequenceType),
                                             OptExpr) */
        case 46:
        {
            /*
             * We translate
             *
             *  declare variable $a as t1 := ea ;
             *  declare variable $b as t2 := eb ;
             *  e0
             *
             * as
             *
             *  let $a as t1 := ea return
             *    let $b as t2 := eb return
             *      e0  .
             *
             * So while traversing the Query Prolog (this is what we're
             * currently doing), we build up a chain of nested let clauses,
             * with the return part as a hole.
             */
            PFvar_t *v1 = new_var (NULL);

            c = let (letbind (var (v1), C(R(p))),
                     let (letbind (C(LL(p)),
                                   proof (subty (var (v1), C(LR(p))),
                                          seqcast (C(LR(p)), var (v1)))),
                          NULL));

	    /* set global information */
	    LL(R(c))->sem.var->global = true;

            if (var_decls.root)
                var_decls.hole->child[1] = c;
            else
                var_decls.root = c;

            var_decls.hole = c->child[1];

        } break;

        /* VariableDeclaration:    var_decl (var_type (Var,
                                                       OptSequenceType_),
                                             external) */
        case 47:
            /* FIXME: What to do here? */
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "external variables not yet implemented");
            break;

        /* QueryBody:              OptExpr */
        case 48:
            assert (C(p));
            break;

        /* OptExpr:                empty_seq */
        case 49:
            C(p) = empty ();
            break;

        /* OptExpr:                Expr */
        case 50:
            assert (C(p));
            break;

        /* Expr:                   exprseq (OptExpr, OptExpr) */
        case 51:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
        
            C(p) = flwr (let (letbind (var (v1), C(L(p))), nil ()),
                         flwr (let (letbind (var (v2), C(R(p))), nil ()),
                               seq (var (v1), var (v2))));
        } break;

        /* Expr:                   ExprSingle */
        case 52:
            assert (C(p));
            break;

        /* ExprSingle:             FLWORExpr */
        case 53:
            break;

        /* ExprSingle:             QuantifiedExpr */
        case 54:
            break;

        /* ExprSingle:             TypeswitchExpr */
        case 55:
            break;

        /* ExprSingle:             IfExpr */
        case 56:
            break;

        /* ExprSingle:             OrExpr */
        case 57:
            break;

        /* FLWORExpr:              flwr (OptBindExpr,
                                         where (OptWhereClause_,
                                                ord_ret (nil, OptExpr))) */
        case 58:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = flwr (C(L(p)),
                         flwr (let (letbind (var (v), C(RL(p))), nil ()),
                               if_ (var (v),
                                    then_else (C(RRR(p)), empty ()))));
        } break;

        /* FLWORExpr:              flwr (OptBindExpr,
                                         where (OptWhereClause_,
                                                ord_ret (OrderByClause,
                                                         OptExpr))) */
        case 59:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = flwr (C(L(p)),
                         orderby (C(RRL(p)),
                                  flwr (let (letbind (var (v),
                                                      C(RL(p))),
                                             nil ()),
                                        if_ (var (v),
                                             then_else (C(RRR(p)), 
                                                        empty ())))));
        } break;

        /* OptBindExpr:            nil */
        case 60:
            C(p) = nil ();
            break;

        /* OptBindExpr:            binds (let (var_type (Var,
                                                         nil),
                                               OptExpr),
                                          OptBindExpr) */
        case 61:
        {
            C(p) = let (letbind (C(LLL(p)), C(LR(p))), C(R(p)));

        } break;

        /* OptBindExpr:            binds (let (var_type (Var,
                                                         TypeDeclaration),
                                               OptExpr),
                                          OptBindExpr) */
        case 62:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = let (letbind (var (v), C(LR(p))),
                        let (letbind (C(LLL(p)),
                                      proof (subty (var (v), C(LLR(p))),
                                             seqcast (C(LLR(p)), 
                                                      var (v)))),
                             C(R(p))));
                        
        } break;

        /* OptBindExpr:            binds (bind (vars (var_type (Var,
                                                                nil),
                                                      OptPosVar),
                                                OptExpr),
                                          OptBindExpr) */
        case 63:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = let (letbind (var (v), C(LR(p))),
                        for_ (forbind (forvars (C(LLLL(p)), C(LLR(p))),
                                              var (v)),
                              C(R(p))));
        } break;

        /* OptBindExpr:            binds (bind (vars (var_type (
                                                          Var,
                                                          TypeDeclaration),
                                                      OptPosVar),
                                                OptExpr),
                                          OptBindExpr) */
        case 64:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);

            C(p) = let (letbind (var (v1), C(LR(p))),
                        for_ (forbind (forvars (var (v2), C(LLR(p))),
                                              var (v1)),
                              let (letbind (C(LLLL(p)),
                                            proof (subty (var (v2),
                                                          C(LLLR(p))),
                                                   seqcast (C(LLLR(p)),
                                                            var (v2)))),
                                   C(R(p)))));
        } break;

        /* OptPosVar:              nil */
        case 66:
            C(p) = nil ();
            break;

        /* OptPosVar:              Var */
        case 67:
            break;

        /* TypeDeclaration:        SequenceType */
        case 68:
            break;

        /* OptWhereClause_:        nil */
        case 69:
            C(p) = true_ ();
            break;

        /* OptWhereClause_:        OptExpr */
        case 70:
            C(p) = ebv (C(p));
            break;

        /* OrderByClause:          orderby (OrderSpecList) */
        case 71:
            C(p) = C(L(p));
            break;

        /* OrderSpecList:          nil */
        case 72:
            C(p) = nil ();
            break;

        /* OrderSpecList:          orderspecs (OptExpr, OrderSpecList) */
        case 73:
            C(p) = orderspecs (p->sem.mode, 
                               fs_convert_op_by_type (fn_data (C(L(p))), 
                                                      PFty_string ()),
                               C(R(p)));
            break;

        /* QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                                      nil),
                                                            nil),
                                                      OptExpr),
                                                nil),
                                         OptExpr) */
        case 74:
            C(p) = some (C(LLLLL(p)), C(LLR(p)), C(R(p)));
            break;

        /* QuantifiedExpr:         some (binds (bind (vars (var_type (Var,
                                                                      TypeDecl),
                                                            nil),
                                                      OptExpr),
                                                nil),
                                         OptExpr) */
        case 75:
        {
            PFvar_t *v1 = new_var (NULL);

            C(p) = some (var (v1), C(LLR(p)),
                         flwr (let (letbind (C(LLLLL(p)),
                                             proof (subty (var (v1),
                                                           C(LLLLR(p))),
                                                    seqcast (C(LLLLR(p)), 
                                                             var (v1)))),
                                    nil ()),
                               C(R(p))));

        } break;


        /* QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                                       nil),
                                                             nil),
                                                       OptExpr),
                                                 nil),
                                          OptExpr) */
        case 76:
        {
            /* every $a in e1 satisfies e2
             *  ==
             * not (some $a in e1 satisfies not (e2))
             *  ==
             * let $v1 := some $a in e1 satisfies
             *              let $v2 := e2 return not ($v2) return
             *   not ($v1)
             */
            PFvar_t *v1     = new_var (NULL);
            PFvar_t *v2     = new_var (NULL);
            PFfun_t *fn_not = function (PFqname (PFns_fn, "not"));

            C(p) = flwr (let (
                             letbind (var (v1), 
                                      some (
                                          C(LLLLL(p)),
                                          C(LLR(p)),
                                          flwr (let (letbind (var (v2),
                                                              C(R(p))),
                                                     nil ()),
                                                APPLY (fn_not, 
                                                       (var (v2)))))),
                             nil ()),
                         APPLY (fn_not, (var (v1))));

        } break;

        /* QuantifiedExpr:         every (binds (bind (vars (var_type (Var,
                                                                       TypeDec),
                                                             nil),
                                                       OptExpr),
                                                 nil),
                                          OptExpr) */
        case 77:
        {
            /* every $a as t in e1 satisfies e2
             *  ==
             * not (some $a as t in e1 satisfies not (e2))
             *  ==
             * let $v1 := some $a as t in e1 satisfies
             *              let $v2 := e2 return not ($v2) return
             *   not ($v1)
             *  ==
             * let $v1 :=
             *   some $v3 in e1 satisfies
             *     let $a := proof ($v3, t, seqcast (t, $v3)) return
             *       let $v2 := e2 return not ($v2) return
             *   not ($v1)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);
            PFfun_t *fn_not   = function (PFqname (PFns_fn, "not"));

            C(p) = flwr (let (letbind (
                                  var (v1), 
                                  some (
                                      var (v3),
                                      C(LLR(p)),
                                      flwr (let (
                                                letbind (
                                                    C(LLLLL(p)),
                                                    proof (subty (var (v3),
                                                                  C(LLLLR(p))),
                                                           seqcast (C(LLLLR(p)),
                                                                    var (v3)))),
                                                nil ()),
                                            flwr (let (letbind (var (v2), 
                                                                C(R(p))),
                                                       nil ()),
                                                  APPLY (fn_not, var (v2)))))),
                              nil ()),
                          APPLY (fn_not, (var (v1))));

        } break;

        /* TypeswitchExpr:         typeswitch (
                                       Expr,
                                       cases (case_ (var_type (OptCaseVar,
                                                               SequenceType),
                                                     OptExpr),
                                              cases (default_ (OptCaseVar,
                                                               OptExpr),
                                                     nil))) */
        case 78:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = flwr (let (letbind (var (v), C(L(p))),
                              nil ()),
                         typeswitch (
                             var (v),
                             cases (
                                 case_ (
                                     C(RLLR(p)),
                                     flwr (let (letbind (C(RLLL(p)), var (v)),
                                                nil ()),
                                           C(RLR(p)))),
                                 default_ (
                                     flwr (let (letbind (C(RRLL(p)), var (v)),
                                                nil ()),
                                           C(RRLR(p)))))));
        } break;

        /* OptCaseVar:             nil */
        case 79:
            /*
             * Generate new variable in case no variable has been
             * specified for case/default branch of typeswitch.
             */
            C(p) = var (new_var ("tsw"));
            break;

        /* OptCaseVar:             Var */
        case 80:
            assert (C(p));
            break;

        /* SequenceType:           seq_ty (ItemType) */
        case 81:
            /* fall through */

        /* SingleType:             seq_ty (AtomType) */
        case 82:
            switch (p->sem.oci) {
                case p_one:
                    C(p) = C(L(p));
                    break;
                case p_zero_or_one:
                    C(p) = seqtype (PFty_opt (C(L(p))->sem.type));
                    break;
                case p_zero_or_more:
                    C(p) = seqtype (PFty_star (C(L(p))->sem.type));
                    break;
                case p_one_or_more:
                    C(p) = seqtype (PFty_plus (C(L(p))->sem.type));
                    break;
                default:
                    PFoops_loc (OOPS_FATAL, p->loc,
                                "illegal occurrence indicator (%d) in "
                                "sequence type", p->sem.oci);
                    break;
            } break;
            
        /* ItemType:               empty_ty */
        case 83:
            C(p) = seqtype (PFty_empty ());
            break;

        /* ItemType:               NodeTest */
        case 84:
            assert (C(p));
            break;

        /* ItemType:               item_ty (nil) */
        case 85:
            C(p) = seqtype (PFty_xs_anyItem ());
            break;

        /* ItemType:               atom_ty (nil) */
        case 86:
            /* is the referenced type a known schema type? */
            if (! PFty_schema (PFty_named (p->sem.qname)))
                PFoops_loc (OOPS_TYPENOTDEF, p->loc,
                        "``%s''",
                        PFqname_str (p->sem.qname));

            C(p) = seqtype (PFty_named (p->sem.qname));
            break;

        /* ItemType:               schm_elem */
        case 87:
            /* FIXME: This probably requires work in the type system */
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "schema-element types are not supported");
            break;

        /* ItemType:               schm_attr */
        case 88:
            /* FIXME: This probably requires work in the type system */
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "schema-attribute types are not supported");
            break;

        /* AtomType:               atom_ty (nil) */
        case 89:
            /* is the referenced type a known schema type? */
            if (! PFty_schema (PFty_named (p->sem.qname)))
                PFoops_loc (OOPS_TYPENOTDEF, p->loc,
                        "``%s''",
                        PFqname_str (p->sem.qname));

            C(p) = seqtype (PFty_named (p->sem.qname));
            break;

        /* NodeTest:               node_ty (nil) */
        case 90:
            switch (p->sem.kind) {
                case p_kind_node:
                    /* node */
                    C(p) = seqtype (PFty_xs_anyNode ());
                    break;
                case p_kind_comment:
                    /* comment */
                    C(p) = seqtype (PFty_comm ());
                    break;
                case p_kind_text:
                    /* text */
                    C(p) = seqtype (PFty_text ());
                    break;
                case p_kind_pi:
                    /* processing-instruction */
                    C(p) = seqtype (PFty_pi (NULL));
                    break;
                case p_kind_doc:
                    /* document */
                    C(p) = seqtype (PFty_doc (PFty_xs_anyType ()));
                    break;
                case p_kind_elem:
                    /* element */
                    C(p) = seqtype (PFty_elem (PFqname (PFns_wild, NULL),
                                PFty_xs_anyType ()));
                    break;
                case p_kind_attr:
                    /* attribute */
                    C(p) = seqtype (PFty_attr (PFqname (PFns_wild, NULL),
                                               PFty_star (PFty_atomic ())));
                    break;
                default:
                    PFoops_loc (OOPS_FATAL, p->loc,
                                "illegal node kind in node type");
            }
            break;

        /* NodeTest:               node_ty (ElemOrAttrType) */
        case 91:
            /* TOPDOWN */

            switch (p->sem.kind) {
                case p_kind_elem:
                    elem_attr = PFty_elem;
                    any = PFty_xs_anyType ();
                    break;
                case p_kind_attr:
                    elem_attr = PFty_attr;
                    any = PFty_star (PFty_atomic ());
                    break;
                default:
                    PFoops_loc (OOPS_FATAL, p->loc,
                                "illegal node kind in NodeTest");
            }

            reduce (kids[0], nts[0]);

            C(p) = C(L(p));
            break;

        /* NodeTest:               node_ty (node_ty (nil)) */
        case 92:
            assert (p->sem.kind == p_kind_doc);
            assert (L(p)->sem.kind == p_kind_elem);

            C(p) = seqtype (PFty_doc (PFty_xs_anyElement ()));
            break;

        /* NodeTest:               node_ty (node_ty (ElemOrAttrType)) */
        case 93:
            /* TOPDOWN */

            assert (p->sem.kind == p_kind_doc);
            assert (L(p)->sem.kind == p_kind_elem);

            elem_attr = PFty_elem;
            any = PFty_xs_anyType ();

            reduce (kids[0], nts[0]);

            C(p) = seqtype (PFty_doc (C(LL(p))->sem.type));
            break;

        /* NodeTest:               node_ty (lit_str) */
        case 94:
            /*
             * processing-instruction tests may have a string
             * argument (restricting the pi target)
             */
            assert (p->sem.kind == p_kind_pi);
            C(p) = seqtype (PFty_pi (L(p)->sem.str));
            break;

        /* ElemOrAttrType:         req_ty (nil, nil) */
        case 95:
            /* element/attribute: any name, any type */
            C(p) = seqtype (elem_attr (PFqname (PFns_wild, NULL), any));
            break;
     
        /* ElemOrAttrType:         req_ty (nil, SchemaType) */
        case 96:
            /* element/attribute: any name, given type */
            C(p) = seqtype (elem_attr (PFqname (PFns_wild, NULL),
                                       C(R(p))->sem.type));
            break;

        /* ElemOrAttrType:         req_ty (req_name, nil) */
        case 97:
            /* element/attribute: given name, any type */
            C(p) = seqtype (elem_attr (L(p)->sem.qname, any));
            break;


        /* ElemOrAttrType:         req_ty (req_name, SchemaType) */
        case 98:
            /* element/attribute: given name, given type */
            C(p) = seqtype (elem_attr (L(p)->sem.qname, C(R(p))->sem.type));
            break;

        /* SchemaType:             named_ty */
        case 99:
            /* is the referenced type a known schema type definition? */
            if (! PFty_schema (PFty_named (p->sem.qname)))
                PFoops_loc (OOPS_TYPENOTDEF, p->loc,
                            "``%s''",
                            PFqname_str (p->sem.qname));

            C(p) = seqtype (PFty_named (p->sem.qname));
            break;

        /* IfExpr:                 if_ (Expr,
                                        then_else (OptExpr, OptExpr)) */
        case 100:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = flwr (let (letbind (var (v), ebv (C(L(p)))), nil ()),
                         if_ (var (v),
                              then_else (C(RL(p)), C(RR(p)))));
        } break;

        /* OrExpr:                 AndExpr */
        case 101:
            break;

        /* OrExpr:                 or (AndExpr, OrExpr) */
        case 102:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_or = function (PFqname (PFns_op, "or"));

            C(p) = flwr (let (letbind (var (v1), ebv (C(L(p)))), nil ()),
                         flwr (let (letbind (var (v2), ebv (C(R(p)))), nil ()),
                               APPLY (op_or, var (v1), var (v2))));
        } break;

        /* AndExpr:                ComparisonExpr */
        case 103:
            break;

        /* AndExpr:                and (ComparisonExpr, AndExpr) */
        case 104:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *op_and = function (PFqname (PFns_op, "and"));

            C(p) = flwr (let (letbind (var (v1), ebv (C(L(p)))), nil ()),
                         flwr (let (letbind (var (v2), ebv (C(R(p)))), nil ()),
                               APPLY (op_and, var (v1), var (v2))));
        } break;

        /* ComparisonExpr:         RangeExpr */
        case 105:
            break;

        /* ComparisonExpr:         eq (RangeExpr, RangeExpr) */
        case 106:
        {
            PFfun_t *op_eq = function (PFqname (PFns_op, "eq"));
            comparison_worker (p, op_eq);
            
        } break;

        /* ComparisonExpr:         ne (RangeExpr, RangeExpr) */
        case 107:
        {
            PFfun_t *op_ne = function (PFqname (PFns_op, "ne"));
            comparison_worker (p, op_ne);

        } break;

        /* ComparisonExpr:         lt (RangeExpr, RangeExpr) */
        case 108:
        {
            PFfun_t *op_lt = function (PFqname (PFns_op, "lt"));
            comparison_worker (p, op_lt);

        } break;

        /* ComparisonExpr:         le (RangeExpr, RangeExpr) */
        case 109:
        {
            PFfun_t *op_le = function (PFqname (PFns_op, "le"));
            comparison_worker (p, op_le);

        } break;

        /* ComparisonExpr:         gt (RangeExpr, RangeExpr) */
        case 110:
        {
            PFfun_t *op_gt = function (PFqname (PFns_op, "gt"));
            comparison_worker (p, op_gt);

        } break;

        /* ComparisonExpr:         ge (RangeExpr, RangeExpr) */
        case 111:
        {
            PFfun_t *op_ge = function (PFqname (PFns_op, "ge"));
            comparison_worker (p, op_ge);

        } break;

        /* ComparisonExpr:         val_eq (RangeExpr, RangeExpr) */
        case 112:
        {
            PFfun_t *op_eq = function (PFqname (PFns_op, "eq"));
            val_comparison_worker (p, op_eq);

        } break;

        /* ComparisonExpr:         val_ne (RangeExpr, RangeExpr) */
        case 113:
        {
            PFfun_t *op_ne = function (PFqname (PFns_op, "ne"));
            val_comparison_worker (p, op_ne);

        } break;

        /* ComparisonExpr:         val_lt (RangeExpr, RangeExpr) */
        case 114:
        {
            PFfun_t *op_lt = function (PFqname (PFns_op, "lt"));
            val_comparison_worker (p, op_lt);

        } break;

        /* ComparisonExpr:         val_le (RangeExpr, RangeExpr) */
        case 115:
        {
            PFfun_t *op_le = function (PFqname (PFns_op, "le"));
            val_comparison_worker (p, op_le);

        } break;

        /* ComparisonExpr:         val_gt (RangeExpr, RangeExpr) */
        case 116:
        {
            PFfun_t *op_gt = function (PFqname (PFns_op, "gt"));
            val_comparison_worker (p, op_gt);

        } break;

        /* ComparisonExpr:         val_ge (RangeExpr, RangeExpr) */
        case 117:
        {
            PFfun_t *op_ge = function (PFqname (PFns_op, "ge"));
            val_comparison_worker (p, op_ge);

        } break;

        /* ComparisonExpr:         is (RangeExpr, RangeExpr) */
        case 118:
        {
            PFfun_t *op_is = function (PFqname (PFns_op, "is-same-node"));
            two_arg_fun_worker (p, op_is);

        } break;

        /* ComparisonExpr:         ltlt (RangeExpr, RangeExpr) */
        case 120:
        {
            PFfun_t *op_ltlt = function (PFqname (PFns_op, "node-before"));
            two_arg_fun_worker (p, op_ltlt);

        } break;

        /* ComparisonExpr:         gtgt (RangeExpr, RangeExpr) */
        case 121:
        {
            PFfun_t *op_gtgt = function (PFqname (PFns_op, "node-after"));
            two_arg_fun_worker (p, op_gtgt);

        } break;

        /* RangeExpr:              AdditiveExpr */
        case 122:
            break;

        /* RangeExpr:              range (RangeExpr, RangeExpr) */
        case 123:
        {
            PFfun_t *op_to = function (PFqname (PFns_op, "to"));
            two_arg_fun_worker (p, op_to);

        } break;

        /* AdditiveExpr:           MultiplicativeExpr */
        case 124:
            break;

        /* AdditiveExpr:           plus (AdditiveExpr, MultiplicativeExpr) */
        case 125:
        {
            PFfun_t *op_plus = function (PFqname (PFns_op, "plus"));
            calculation_worker (p, op_plus);

        } break;

        /* AdditiveExpr:           minus (AdditiveExpr, MultiplicativeExpr) */
        case 126:
        {
            PFfun_t *op_minus = function (PFqname (PFns_op, "minus"));
            calculation_worker (p, op_minus);

        } break;

        /* MultiplicativeExpr:     UnionExpr */
        case 127:
            break;

        /* MultiplicativeExpr:     mult (UnionExpr, MultiplicativeExpr) */
        case 128:
        {
            PFfun_t *op_times = function (PFqname (PFns_op, "times"));
            calculation_worker (p, op_times);

        } break;

        /* MultiplicativeExpr:     div (UnionExpr, MultiplicativeExpr) */
        case 129:
        {
            PFfun_t *op_div = function (PFqname (PFns_op, "div"));
            calculation_worker (p, op_div);

        } break;

        /* MultiplicativeExpr:     idiv (UnionExpr, MultiplicativeExpr) */
        case 130:
        {
            PFfun_t *op_idiv = function (PFqname (PFns_op, "idiv"));
            calculation_worker (p, op_idiv);

        } break;

        /* MultiplicativeExpr:     mod (UnionExpr, MultiplicativeExpr) */
        case 131:
        {
            PFfun_t *op_mod = function (PFqname (PFns_op, "mod"));
            calculation_worker (p, op_mod);

        } break;

        /* UnionExpr:              IntersectExceptExpr */
        case 132:
            break;

        /* UnionExpr:              union_ (IntersectExceptExpr, UnionExpr) */
        case 133:
        {
            PFfun_t *op_union = function (PFqname (PFns_op, "union"));
            two_arg_fun_worker (p, op_union);

        } break;

        /* IntersectExceptExpr:    InstanceofExpr */
        case 134:
            break;

        /* IntersectExceptExpr:    intersect (InstanceofExpr,
                                              IntersectExceptExpr) */
        case 135:
        {
            PFfun_t *op_intersect = function (PFqname (PFns_op, "intersect"));
            two_arg_fun_worker (p, op_intersect);

        } break;

        /* IntersectExceptExpr:    except (InstanceofExpr,
                                           IntersectExceptExpr) */
        case 136:
        {
            PFfun_t *op_except = function (PFqname (PFns_op, "except"));
            two_arg_fun_worker (p, op_except);

        } break;

        /* InstanceofExpr:         TreatExpr */
        case 137:
            break;

        /* InstanceofExpr:         instof (TreatExpr, SequenceType) */
        case 138:
        {
            PFvar_t *v = new_var (NULL);

            C(p) = flwr (let (letbind (var (v), C(L(p))), nil ()),
                         typeswitch (
                             var (v),
                             cases (
                                 case_ (C(R(p)), true_ ()),
                                 default_ (false_ ()))));
        } break;

        /* TreatExpr:              CastableExpr */
        case 139:
            break;

        /* TreatExpr:              treat (CastableExpr, SequenceType) */
        case 140:
        {
            PFvar_t *v1 = new_var (NULL);
            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));

            C(p) = flwr (let (letbind (var (v1), C(L(p))), nil ()),
                         typeswitch (
                             var (v1),
                             cases (case_ (C(R(p)), var (v1)),
                                    default_ (APPLY (fn_error,
                                                     str("err:XP0050"))))));
        } break;

        /* CastableExpr:           CastExpr */
        case 141:
            break;

        /* CastableExpr:           castable (CastExpr, SingleType) */
        case 142:
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc,
                        "`castable' keyword is not supported");
            break;

        /* CastExpr:               UnaryExpr */
        case 143:
            break;

        /* CastExpr:               cast (UnaryExpr, SingleType) */
        case 144:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);

            C(p) = flwr (let (letbind (var (v1), C(L(p))), nil ()),
                         flwr (let (letbind (var (v2), fn_data (var (v1))),
                                    nil ()),
                               cast (C(R(p)), var (v2))));
        } break;

        /* UnaryExpr:              ValueExpr */
        case 145:
            break;

        /* UnaryExpr:              uminus (ValueExpr) */
        case 146:
        {
            PFvar_t *v = new_var (NULL);
            PFfun_t *op_minus = function (PFqname (PFns_op, "minus"));

            C(p) = flwr (let (letbind (var (v),
                                       fs_convert_op_by_type (
                                           fn_data (C(L(p))),
                                           PFty_xs_double ())),
                              nil ()),
                         APPLY (op_minus, num (0), var (v)));
        } break;

        /* UnaryExpr:              uplus (ValueExpr) */
        case 147:
        {
            PFvar_t *v = new_var (NULL);
            PFfun_t *op_plus = function (PFqname (PFns_op, "plus"));

            C(p) = flwr (let (letbind (var (v),
                                       fs_convert_op_by_type (
                                           fn_data (C(L(p))),
                                           PFty_xs_double ())),
                              nil ()),
                    APPLY (op_plus, num (0), var (v)));
        } break;

        /* ValueExpr:              ValidateExpr */
        case 148:
            break;

        /* ValueExpr:              PathExpr */
        case 149:
            break;

        /* ValidateExpr:           validate (Expr) */
        case 150:
            PFoops_loc (OOPS_NOTSUPPORTED, p->loc, "validation not supported");
            break;

        /* PathExpr:               StepExpr */
        case 151:
            assert (C(p));
            break;

        /* PathExpr:               LocationPath */
        case 152:
            assert (C(p));
            break;

        /* LocationPath:           root_ */
        case 153:
        {
            PFfun_t *_root = function (PFqname (PFns_fn, "root"));

            if (fs_dot)
                C(p) = APPLY (_root, var (fs_dot));
            else
                PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");

#if 0
    FIXME:
        The code below is actually closer to the standard that
        demands to not only translate the '/' operator into a
        call to fn:root(.), but into

          fn:root(.) treat as document .

        However, milprint_summer cannot evaluate the typeswitch
        involved, making '/' fail in any case.  We do not want to
        break too much, but rather be slightly off the standard
        for the time being.
                                                 Jens (26.10.05)

            PFvar_t *v1 = new_var (NULL);
            PFfun_t *_root = function (PFqname (PFns_fn, "root"));
            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));

            if (fs_dot)
                C(p) = flwr (let (letbind (var (v1), APPLY (_root, 
                                                            var (fs_dot))),
                                  nil ()),
                             typeswitch (
                                 var (v1),
                                 cases (
                                     case_ (
                                         seqtype (PFty_doc (
                                             PFty_plus (PFty_xs_anyNode ()))),
                                         var (v1)),
                                     default_ (
                                         APPLY (fn_error,
                                                str("err:XP0050"))))));
            else
                PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");
#endif
        } break;

        /* LocationPath:           locpath (StepExpr, StepExpr) */
        case 154:
        {
            /* TOPDOWN */

            /*
             * A path expression E1/E2 is to be evaluated as follows:
             * (see XQuery Oct 2004 WD, Section 3.2)
             *
             * (1) Expression E1 is evaluated, and if the result is not
             *     a (possibly empty) sequence of nodes, a type error
             *     is raised.
             *
             * (2) Each node resulting from the evaluation of E1 then
             *     serves in turn to provide an inner focus for an
             *     evaluation of E2.
             *
             * (3) The sequences resulting from all the evaluations of
             *     E2 are combined as follows:
             *
             *     -- If every evaluation of E2 returns a (possibly empty)
             *        sequence of nodes, these sequences are combined,
             *        and duplicate nodes are eliminated. If ordering mode
             *        is ordered, the resulting node sequence is returned
             *        in document order.
             *     -- If every evaluation of E2 returns a (possibly empty)
             *        sequence of atomic values, these sequences are
             *        concatenated, in order, and returned.
             *     -- Otherwise (that is, if the multiple evaluations of
             *        E2 return at least one node and at least one atomic
             *        value), a type error is raised.
             *
             * In XQuery Core:
             *
             * let $v1 := E1 return
             *   typeswitch ($v1)
             *     case node* return
             *       let $v2 := let $fs:last := fn:count ($v1) return
             *                    for $fs:dot at $fs:position in $v1 return E2
             *         return
             *         typeswitch ($v2)
             *           case $v3 as node* return fs:distinct-doc-order ($v3)
             *           default typeswitch ($v2)
             *                     case atomic* return $v2
             *                     default error (err:XP0018)
             *     default error (err:XP0019)
             */

            PFvar_t *dot;
            PFvar_t *position;
            PFvar_t *last;
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);

            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));
            PFfun_t *count = function (PFqname (PFns_fn, "count"));
            PFfun_t *ddo = function (PFqname (PFns_pf, "distinct-doc-order"));

            /* compile context first */
            reduce (kids[1], nts[1]);

            /*
             * save context items $fs:dot, $fs:position, $fs:last
             * and establish new context item
             */
            dot = fs_dot;
            fs_dot = new_var ("dot");
            position = fs_position;
            fs_position = new_var ("pos");
            last = fs_last;
            fs_last = new_var ("lst");

            /* compile step in this new context */
            reduce (kids[0], nts[0]);

            C(p) =
                flwr (let (letbind (var (v1), C(R(p))), nil ()),
                  typeswitch (
                    var (v1),
                    cases (
                      case_ (
                        seqtype (PFty_star (PFty_xs_anyNode ())),
                        flwr (
                          let (
                            letbind (
                              var (v2),
                              flwr (
                                let (
                                  letbind (var (fs_last), 
                                           APPLY (count, var (v1))),
                                  nil ()),
                                flwr (for_ (
                                    forbind (forvars (var (fs_dot),
                                                      var (fs_position)),
                                             var (v1)),
                                    nil ()),
                                C(L(p))))),
                            nil ()),
                          typeswitch (
                            var (v2),
                            cases (
                              case_ (
                                seqtype (PFty_star (PFty_xs_anyNode ())),
                                flwr (let (
                                          letbind (
                                              var (v3),
                                              seqcast (seqtype (
                                                         PFty_star (
                                                           PFty_xs_anyNode ())),
                                                       var (v2))),
                                          nil ()),
                                      APPLY (ddo, var (v3)))),
                              default_ (
                                typeswitch (
                                  var (v2),
                                  cases (
                                    case_ (
                                      seqtype (
                                          PFty_star (PFty_atomic ())),
                                      var (v2)),
                                    default_ (
                                      APPLY (fn_error, str ("err:XP0018")))
                                    ))))))),
                      default_ (
                        APPLY (fn_error,
                               str ("err:XP0019: Argument to location step "
                                    "must be a node sequence."))))));

            /* restore context items */
            fs_dot = dot;
            fs_position = position;
            fs_last = last;

        } break;

        /* LocationPath:           locpath (LocationStep, StepExpr) */
        case 155:
        {   /*
             * For regular location steps, we don't actually need the
             * complicated stuff in the above rule.
             *
             * let $v1 := StepExpr return
             *   typeswitch ($v1)
             *     case node* return
             *                  let $v2 := $v1/LocationStep return
             *                    fs:distinct-doc-order ($v2)
             *     default error (err:XP0019)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *ddo = function (PFqname (PFns_pf, "distinct-doc-order"));
            PFfun_t *fn_error = function (PFqname (PFns_fn, "error"));

            C(p) = flwr (let (letbind (var (v1), C(R(p))),
                              nil ()),
                         typeswitch (
                           var (v1),
                           cases (
                             case_ (seqtype (PFty_star (PFty_xs_anyNode ())),
                               flwr (let (letbind (var (v2), 
                                                   locsteps (C(L(p)),
                                                             var (v1))),
                                          nil ()),
                                     APPLY (ddo, var (v2)))),
                             default_ (
                               APPLY (fn_error,
                                      str ("err:XP0019: Argument to location "
                                           "step must be a node sequence."))))));
        } break;

        /* StepExpr:               LocationStep */
        case 156:
            break;

        /* StepExpr:               FilterExpr */
        case 157:
            break;

        /* FilterExpr:             PrimaryExpr */
        case 158:
            break;

        /* FilterExpr:             pred (StepExpr, Expr) */
        case 159:
        {   /* TOPDOWN */

            /*
             * Predicate evaluation:
             *
             * e1[e2]
             *  ==
             * let $v1 := e1 return
             *   let $fs:last := fn:count ($v1) return
             *     for $fs:dot at $fs:position in $v1 return
             *       let $v2 := e2 return
             *         let $v3 :=
             *           typeswitch ($v2)
             *             case numeric return
             *               typeswitch ($v2)
             *                 case $v4 as xs:integer
             *                   return fn:eq ($v4, $fs:position)
             *                 case $v5 as xs:decimal
             *                   return fn:eq ($v5, $fs:position)
             *                 case $v6 as xs:double
             *                   return fn:eq ($v6, $fs:position)
             *                 default return   (: should actually not happen :)
             *                   let $v7 := $v2 cast as xs:double return
             *                     fn:eq ($v7, $fs:position)
             *             default return ebv ($v2)
             *           return
             *             if ($v3) then $fs:dot else ()
             *
             * Note:
             *   We explicitly line up the variants of type `numeric' here.
             *   (a simple `case $v4 as numeric return fn:eq ($v4, $fs:pos)'
             *   instead of the inner typeswitch would loose important
             *   static type information: $v4 would get static type numeric,
             *   and we would loose the (possibly more specific) type we
             *   inferred so far.)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);
            PFvar_t *v4 = new_var (NULL);
            PFvar_t *v5 = new_var (NULL);
            PFvar_t *v6 = new_var (NULL);
            PFvar_t *v7 = new_var (NULL);
            PFvar_t *dot;
            PFvar_t *position;
            PFvar_t *last;
            PFfun_t *count = function (PFqname (PFns_fn, "count"));
            PFfun_t *op_eq = function (PFqname (PFns_op, "eq"));

            /* compile e1 */
            reduce (kids[0], nts[0]);

            /*
             * save context items $fs:dot, $fs:position, $fs:last
             * and establish new context item
             */
            dot = fs_dot;
            fs_dot = new_var ("dot");
            position = fs_position;
            fs_position = new_var ("pos");
            last = fs_last;
            fs_last = new_var ("lst");

            /* compile predicate expression in this new context */
            reduce (kids[1], nts[1]);

            C(p) = flwr (let (letbind (var (v1), C(L(p))), nil ()),
                    flwr (let (letbind (var (fs_last), 
                                       APPLY (count, var (v1))), nil ()),
                      flwr (for_ (forbind (forvars (var (fs_dot),
                                                    var (fs_position)),
                                           var (v1)), nil ()),
                        flwr (let (letbind (var (v2), C(R(p))), nil ()),
                          flwr (let (
                            letbind (
                              var (v3),
                              typeswitch (
                                var (v2),
                                cases (
                                  case_ (
                                    seqtype (PFty_numeric ()),
                                    typeswitch (
                                      var (v2),
                                      cases (
                                        case_ (
                                          seqtype (PFty_xs_integer ()),
                                          flwr (let (
                                            letbind (var (v4),
                                                     seqcast (
                                                       seqtype (
                                                           PFty_xs_integer()),
                                                       var (v2))), nil ()),
                                            APPLY (op_eq, var (v4),
                                                   var (fs_position)))),
                                        default_ (
                                          typeswitch (
                                            var (v2),
                                            cases (
                                              case_ (
                                                seqtype (PFty_xs_decimal ()),
                                                flwr (let (
                                                  letbind (
                                                    var (v5),
                                                    seqcast (
                                                      seqtype (
                                                            PFty_xs_decimal ()),
                                                      var (v2))), nil ()),
                                                  APPLY (op_eq, var (v5),
                                                         var (fs_position)))),
                                              default_ (
                                                typeswitch (
                                                  var (v2),
                                                  cases (
                                                    case_ (
                                                      seqtype (
                                                        PFty_xs_double ()),
                                                      flwr (let (
                                                        letbind (
                                                          var (v6),
                                                          seqcast (
                                                            seqtype (
                                                              PFty_xs_double()),
                                                            var (v2))), nil ()),
                                                        APPLY (op_eq, var (v6),
                                                               var (fs_position)
                                                               ))),
                                                    default_ (
                                                      flwr (let (
                                                        letbind (
                                                          var (v7),
                                                          cast (
                                                            seqtype (
                                                              PFty_xs_double()),
                                                            var (v2))), nil ()),
                                                        APPLY (op_eq,
                                                               var (v7),
                                                               var (fs_position)
                                                            )))))))))))),
                                  default_ (ebv (var (v2)))))), nil ()),
                            if_ (
                              var (v3),
                              then_else (var (fs_dot), empty ())))))));

            /* restore context items */
            fs_dot = dot;
            fs_position = position;
            fs_last = last;
        } break;

        /* LocationStep:           step (NodeTest) */
        case 160:
            assert (C(L(p)));
            C(p) = step (p->sem.axis, C(L(p)));
            break;

        /* PrimaryExpr:            Literal */
        case 161:
            break;

        /* PrimaryExpr:            Var */
        case 162:
            break;

        /* PrimaryExpr:            ParenthesizedExpr */
        case 163:
            break;

        /* PrimaryExpr:            ContextItemExpr */
        case 164:
            break;

        /* PrimaryExpr:            FunctionCall */
        case 165:
            break;

        /* PrimaryExpr:            Constructor */
        case 166:
            break;

        /* PrimaryExpr:            OrderedExpr */
        case 167:
            break;

        /* PrimaryExpr:            UnorderedExpr */
        case 168:
            break;
            
        /* Literal:                NumericLiteral */
        case 169:
            break;

        /* Literal:                StringLiteral */
        case 170:
            break;

        /* NumericLiteral:         IntegerLiteral */
        case 171:
            break;

        /* NumericLiteral:         DecimalLiteral */
        case 172:
            break;

        /* NumericLiteral:         DoubleLiteral */
        case 173:
            break;

        /* IntegerLiteral:         lit_int */
        case 174:
            C(p) = num (p->sem.num);
            break;

        /* DecimalLiteral:         lit_dec */
        case 175:
            C(p) = dec (p->sem.dec);
            break;

        /* DoubleLiteral:          lit_dbl */
        case 176:
            C(p) = dbl (p->sem.dbl);
            break;

        /* StringLiteral:          lit_str */
        case 177:
            C(p) = str (p->sem.str);
            break;

        /* Var:                    var */
        case 178:
            C(p) = var (p->sem.var);
            break;

        /* ParenthesizedExpr:      Expr */
        case 179:
            assert (C(p));
            break;

        /* ContextItemExpr:        dot */
        case 180:
            if (fs_dot)
                C(p) = var (fs_dot);
            else
                PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");
            break;

        /* FunctionCall:           apply (nil) */
        case 181:
            /*
             * There are some built-in functions with special
             * implicit semantics.
             */

            /*
             * Functions `fn:string', `fn:name', `fn:local-name', 
             * `fn:namespace-uri', `fn:root' with no arguments
             * implicitly get the current
             * context node `.' as their argument.
             */
            if ( (!PFqname_eq (p->sem.apply.fun->qname, PFqname (PFns_fn, "string")))
                || (!PFqname_eq (p->sem.apply.fun->qname, PFqname (PFns_fn, "name")))
                || (!PFqname_eq (p->sem.apply.fun->qname,
                                 PFqname (PFns_fn, "local-name")))
                || (!PFqname_eq (p->sem.apply.fun->qname,
                                 PFqname (PFns_fn, "namespace-uri")))
                || (!PFqname_eq (p->sem.apply.fun->qname, PFqname (PFns_fn, "root")))
               ) {
                if (fs_dot)
                    C(p) = APPLY (p->sem.apply.fun, var (fs_dot));
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");

                break;
            }

            /*
             * Functions `fn:string-length', `fn:normalize-space',
             * `fn:number'
             * implicitly get the string-value of the current context
             * node `.' as their argument if called without any
             * arguments.
             */
            if ((!PFqname_eq (p->sem.apply.fun->qname,
                              PFqname (PFns_fn, "string-length")))
                || (!PFqname_eq (p->sem.apply.fun->qname,
                                 PFqname (PFns_fn, "normalize-space")))
                || (!PFqname_eq (p->sem.apply.fun->qname,
                                 PFqname (PFns_fn, "number")))
               ) {
                if (fs_dot) {
                    PFvar_t *v = new_var (NULL);
                    C(p) = flwr (let (letbind (var (v),
                                              APPLY (
                                                  function (
                                                      PFqname (PFns_fn,
                                                               "string")),
                                       var (fs_dot))), nil ()),
                                 APPLY (p->sem.apply.fun, var (v)));
                }
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");

                break;
            }

            /*
             * `fn:position' is available as variable $fs:position.
             */
            if (!PFqname_eq (p->sem.apply.fun->qname, PFqname (PFns_fn, "position"))){
                if (fs_position)
                    C(p) = var (fs_position);
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc,
                                "position information not available");
                break;
            }

            /*
             * `fn:last' is available as variable $fs:last.
             */
            if (!PFqname_eq (p->sem.apply.fun->qname, PFqname (PFns_fn, "last"))) {
                if (fs_last)
                    C(p) = var (fs_last);
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc,
                                "position information not available");
                break;
            }

            /*
             * In all other cases just call the respective function
             */
            C(p) = apply (&p->sem.apply, nil ());
            break;

        /* FunctionCall:           apply (FuncArgList) */
        case 182:
            /* TOPDOWN */

            assert (PFqname_eq (p->sem.apply.fun->qname,
                                PFqname (PFns_fn, "position")));

            *(PFapply_t **) PFarray_add (funs) = &p->sem.apply;
            *(PFcnode_t **) PFarray_add (args) = nil ();
            *(unsigned short *) PFarray_add (arg_num) = 0;

            /*
             * Functions `fn:id', `fn:idref' with one argument
             * implicitly get the current context node `.' as
             * their second/last argument.
             */
            if (p->sem.apply.fun->arity == 1 &&
                ((!PFqname_eq (p->sem.apply.fun->qname,
                               PFqname (PFns_fn, "id")))
                || (!PFqname_eq (p->sem.apply.fun->qname,
                                 PFqname (PFns_fn, "idref")))
                )
               ) {
                if (fs_dot)
                    *(PFcnode_t **) PFarray_top (args)
                        = arg (var (fs_dot), *(PFcnode_t **) PFarray_top (args));
                else
                    PFoops_loc (OOPS_NOCONTEXT, p->loc, "``.'' is unbound");
            }

            reduce (kids[0], nts[0]);

            PFarray_del (funs);
            PFarray_del (args);
            PFarray_del (arg_num);

            C(p) = C(L(p));

            break;

        /* FuncArgList:            nil */
        case 183:
        {
            PFapply_t *fun = *(PFapply_t **) PFarray_top (funs);

            C(p) = apply (fun, *(PFcnode_t **) PFarray_top (args));

        } break;

        /* FuncArgList:            args (Expr, FuncArgList) */
        case 184:
        {   /* TOPDOWN */
            
            /*
             * Apply ``function conversion rules'' (W3C XQuery 3.1.5).
             * See also helper function function_conversion().
             */
            PFvar_t      *v        = new_var (NULL);
            PFfun_t      *fun;
            PFty_t        expected;
            unsigned int  param_num;
            PFfun_t      *implicit = NULL;

            /* translate function argument */
            reduce (kids[0], nts[0]);

            /* build up argument list */
            *(PFcnode_t **) PFarray_top (args)
                = arg (var (v), *(PFcnode_t **) PFarray_top (args));

            /* translate other arguments */
            reduce (kids[1], nts[1]);

            /* count arguments (parse tree is in reverse order
               - therefore increase argument after other arguments) */
            param_num = (*(unsigned short *) PFarray_top (arg_num))++;


            /* What function are we actually talking about? */
            fun = (*(PFapply_t **) PFarray_top (funs))->fun;

            /*
             * There's exactly one function that allows an arbitrary
             * number of arguments: fn:concat(). Looking at the
             * parameter types here doesn't really make sense, we
             * use atomic? instead.
             */
            if (PFqname_eq (fun->qname,
                            PFqname (PFns_fn, "concat")) == 0)
                expected = PFty_opt (PFty_atomic ());
            else
                /* look up expected argument type */
                expected = fun->par_ty[param_num];

            /*
             * There's implicit semantics for some functions.
             */
            /* Implicitly call fn:boolean() before fn:not(). */
            if (! PFqname_eq (fun->qname, PFqname (PFns_fn, "not")))
                implicit = function (PFqname (PFns_fn, "boolean"));

            /* Implicitly call fn:string() before fn:concat(). */
            if (! PFqname_eq (fun->qname, PFqname (PFns_fn, "concat")))
                implicit = function (PFqname (PFns_fn, "string"));

            if (implicit) {
                PFvar_t *v1 = new_var (NULL);

                C(p) = flwr (let (letbind (var (v1),
                                           function_conversion (C(L(p)),
                                                                expected)),
                                  nil ()),
                             flwr (let (letbind (var (v),
                                                 APPLY (implicit, var (v1))),
                                        nil ()),
                                   C(R(p))));
            }
            else {
                /* construct return value */
                C(p) = flwr (let (letbind (var (v),
                                           function_conversion (C(L(p)),
                                                                expected)),
                                  nil ()),
                             C(R(p)));
            }

        } break;

        /* OrderedExpr:            ordered (Expr) */
        case 185:
            /* FIXME: Better treatment of `ordered' information?
             *         - Make this rule TOPDOWN
             *         - Keep a state variable during compilation
             */
            C(p) = ordered (C(L(p)));
            break;

        /* UnorderedExpr:          unordered (Expr) */
        case 186:
            C(p) = unordered (C(L(p)));
            break;

        /* Constructor:            ElementConstructor */
        case 187:
            break;

        /* Constructor:            AttributeConstructor */
        case 188:
            break;

        /* Constructor:            TextConstructor */
        case 189:
            break;

        /* Constructor:            CommentConstructor */
        case 190:
            break;

        /* Constructor:            PIConstructor */
        case 191:
            break;

        /* Constructor:            DocumentConstructor */
        case 192:
            break;

        /* ElementConstructor:     elem (TagName, OptContentExpr) */
        case 193:
        {
            PFfun_t *pf_matn
                = function (PFqname (PFns_pf, "merge-adjacent-text-nodes"));

            C(p) = constr_elem (C(L(p)), APPLY (pf_matn, C(R(p))));

        } break;

        /* AttributeConstructor:   attr (TagName, AttributeValue) */
        case 194:
            /*
             * The translation rules rooted at AttributeValue compile
             * the attribute value into a single string.
             */
            C(p) = constr_attr (C(L(p)), C(R(p)));
            break;

        /* TextConstructor:        text (Expr) */
        case 195:
        {
            /*
             * FIXME:
             *   Since June 2005 the W3C specs describe different variants
             *   for fs:item-sequence-to-untypedAtomic() for each node
             *   kind. fs:item-sequence-to-untypedAtomic-text() handles
             *   the empty sequence differently. For now, we leave everything
             *   as it is and wait until the W3C guys know what they want.
             */
            PFfun_t *is2uA =
                function (PFqname (PFns_pf, "item-sequence-to-untypedAtomic"));

            C(p) = constr (p->kind, APPLY (is2uA, C(L(p))));

        } break;

        /* CommentConstructor:     comment (Expr) */
        case 196:
        {
            PFfun_t *is2uA =
                function (PFqname (PFns_pf, "item-sequence-to-untypedAtomic"));

            C(p) = constr (p->kind, APPLY (is2uA, C(L(p))));

        } break;

        /* PIConstructor:          pi (OptExpr, OptContentExpr) */
        case 197:
        {
            PFvar_t *target  = new_var (NULL);
            PFvar_t *content = new_var (NULL);
            PFvar_t *v       = new_var (NULL);

            PFfun_t *is2uA =
                function (PFqname (PFns_pf, "item-sequence-to-untypedAtomic"));

            C(p) = flwr (let (letbind (var (target), C(L(p))), nil ()),
                         flwr (let (letbind (var (v), C(R(p))), nil ()),
                               flwr (let (letbind (var (content), 
                                                   APPLY (is2uA, var (v))),
                                          nil ()),
                                     constr_pi (var (target), 
                                                var (content)))));
        } break;

        /* DocumentConstructor:    doc (Expr) */
        case 198:
        {
            PFfun_t *is2ns =
                function (PFqname (PFns_pf, "item-sequence-to-node-sequence"));

            C(p) = constr (p->kind, APPLY (is2ns, C(L(p))));
        } break;

        /* TagName:                tag */
        case 199:
            C(p) = constr_tag (p->sem.qname);
            break;

        /* TagName:                Expr */
        case 200:
            /* in theory this should be translated into
               'fn:resolve-QName' but we don't know the
               element argument - therefore internally
               the string is translated into a qname */
            C(p) = fs_convert_op_by_type (fn_data (C(p)), PFty_string ());
            break;

        /* OptContentExpr:         OptExpr */
        case 201:
        {
            PFvar_t *v = new_var (NULL);
            PFfun_t *is2ns =
                function (PFqname (PFns_pf, "item-sequence-to-node-sequence"));

            C(p) = flwr (let (letbind (var (v), C(p)), nil ()),
                         APPLY (is2ns, var (v)));

        } break;

        /* OptContentExpr:         empty_seq */
        case 202:
            C(p) = empty ();
            break;

        /* OptContentExpr:         contseq (OptContentExpr, OptContentExpr) */
        case 203:
        {
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);

            C(p) = flwr (let (letbind (var (v1), C(L(p))), nil ()),
                         flwr (let (letbind (var (v2), C(R(p))), nil ()),
                               seq (var (v1), var (v2))));

        } break;

        /* AttributeValue:         Expr */
        case 204:
        {
            /*
             * Convert enclosed expression in attribute values as described in
             * [XQ, Section 3.7.1.1]:
             *
             *  a. Apply atomization (fn:data) to the enclosed expression.
             *  b. Cast each atomic value in the resulting sequence to a string
             *  c. Merge all the resulting strings with a space character
             *     inbetween.
             *
             * let $v1 := [[ $1$ ]] return
             *    let $v2 := for $v3 in $v1 return fn:string($v3)
             *       return
             *       fn:string-join( $v2, " " )
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFvar_t *v3 = new_var (NULL);
            PFfun_t *string = function (PFqname (PFns_fn, "string"));
            PFfun_t *string_join = function (PFqname (PFns_fn, "string-join"));

            C(p) =
                flwr (let (letbind (var (v1), C(p)), nil ()),
                      flwr (let (letbind (
                                     var (v2),
                                     flwr (for_ (forbind (forvars (var (v3),
                                                                   nil ()),
                                                 var (v1)), nil ()),
                                           APPLY (string, var (v3)))),
                                 nil ()),
                            APPLY (string_join, var (v2), str (" "))));
        } break;

        /* AttributeValue:         empty_seq */
        case 205:
            /*
             * An empty attribute value shall result in an empty string.
             */
            C(p) = str ("");
            break;

        /* AttributeValue:         contseq (AttributeValue, AttributeValue) */
        case 206:
        {
            /*
             * Both arguments have type xs:string after they had been
             * converted in the rule AttrEnclosedExpr. All that is left
             * to do is to concatenate them.
             *
             * let $v1 := [[ e1 ]] return
             *   let $v2 := [[ e2 ]] return
             *     fn:concat ($v1, $v2)
             */
            PFvar_t *v1 = new_var (NULL);
            PFvar_t *v2 = new_var (NULL);
            PFfun_t *concat = function (PFqname (PFns_fn, "concat"));

            C(p) = flwr (let (letbind (var (v1), C(L(p))), nil ()),
                         flwr (let (letbind (var (v2), C(R(p))), nil ()),
                               APPLY (concat, var (v1), var (v2))));

        } break;


        default:
            PFoops_loc (OOPS_FATAL, p->loc, "untranslated expression");
            break;
    }
}

static void
comparison_worker (PFpnode_t *p, PFfun_t *fun)
{
    PFvar_t *v1 = new_var (NULL);
    PFvar_t *v2 = new_var (NULL);
    PFvar_t *u1 = new_var (NULL);
    PFvar_t *u2 = new_var (NULL);

    C(p) = some (var (v1), fn_data (C(L(p))),
            some (
                var (v2), fn_data (C(R(p))),
                flwr (let (letbind (var (u1),
                                    fs_convert_op_by_type (
                                        fs_convert_op_by_expr (var (v1),
                                                               var (v2)),
                                        PFty_xs_string ())), nil ()),
                      flwr (let (letbind (var (u2),
                                          fs_convert_op_by_type (
                                              fs_convert_op_by_expr (var (v2),
                                                                     var (v1)),
                                              PFty_xs_string ())), nil ()),
                            APPLY (fun, var (u1), var (u2))))));
}

static void
val_comparison_worker (PFpnode_t *p, PFfun_t *fun)
{
    PFvar_t *v1 = new_var (NULL);
    PFvar_t *v2 = new_var (NULL);

    C(p) = flwr (let (letbind (
                          var (v1),
                          fs_convert_op_by_type (fn_data (C(L(p))),
                                                 PFty_xs_string ())), nil ()),
                 flwr (let (letbind (
                                var (v2),
                                fs_convert_op_by_type (fn_data (C(R(p))),
                                                       PFty_xs_string ())),
                            nil ()),
                       APPLY (fun, var (v1), var (v2))));
}

static void
calculation_worker (PFpnode_t *p, PFfun_t *fun)
{
    PFvar_t *v1 = new_var (NULL);
    PFvar_t *v2 = new_var (NULL);

    C(p) = flwr (let (letbind (
                          var (v1),
                          fs_convert_op_by_type (fn_data (C(L(p))),
                                                 PFty_xs_double ())), nil ()),
                 flwr (let (letbind (
                                var (v2),
                                fs_convert_op_by_type (fn_data (C(R(p))),
                                                       PFty_xs_double ())),
                            nil ()),
                       APPLY (fun, var (v1), var (v2))));
}

static void
two_arg_fun_worker (PFpnode_t *p, PFfun_t *fun)
{
    PFvar_t *v1 = new_var (NULL);
    PFvar_t *v2 = new_var (NULL);

    C(p) = flwr (let (letbind (var (v1), C(L(p))), nil ()),
                 flwr (let (letbind (var (v2), C(R(p))), nil ()),
                       APPLY (fun, var (v1), var (v2))));
}

/**
 * Extract sequence types from function parameter list and
 * put them into a single array, suitable for insertion into
 * PFfun_t.
 *                fun
 *               /   \
 *         fun_sig    Body
 *        /       \
 *    params      ReturnType
 *   /     \
 *  ty      params
 *         /      \
 *        ty      ...
 *                  \
 *                  nil
 *
 * Call with the topmost `param' node.
 */
static PFty_t *
parameter_types (PFpnode_t *paramlist)
{
    PFarray_t *par_ty = PFarray (sizeof (PFty_t));
    PFpnode_t *n = paramlist;

    assert (paramlist);

    while (n->kind != p_nil) {
        assert (n->kind == p_params);
        assert (L(n) && L(n)->kind == p_param);
        assert (LL(n) && C(LL(n)) && C(LL(n))->kind == c_seqtype);

        *((PFty_t *) PFarray_add (par_ty)) = C(LL(n))->sem.type;

        n = R(n);
        assert (n);
    }

    return par_ty->base;
}

/**
 * Convert function argument or return value according to
 * to the function conversion rules in W3C XQuery 3.1.5.
 *
 * -- If the expected type is an atomic type,
 * 
 *    (1) Apply atomization (i.e., fn:data)
 *    (2) Cast each xdt:untypedAtomic item to the expected
 *        atomic type. For built-in functions with expected
 *        type `numeric', cast them to xs:double.
 *    (3) Apply numeric type promotion, if possible.
 *
 * -- Leave other arguments as they are. (FIXME: correct?)
 *
 * We use fn:data() for Step 1, fs:convert-operand() for Step 2.
 * FIXME: Step 3?
 *
 * In XQuery Core:
 *
 * -- The expected type t is an atomic type:
 *
 *    let $v1 := arg return
 *      for $v2 in $v1 return
 *        let $v3 := fn:data ($v2) return
 *          convert-operand ($v3, prime(expected))
 *
 */
static PFcnode_t *
function_conversion (const PFcnode_t *e, PFty_t expected)
{
    PFty_t exp_prime;

    PFcnode_t *ret;
    PFvar_t   *v1 = new_var (NULL);
    PFvar_t   *v2 = new_var (NULL);
    PFvar_t   *v3 = new_var (NULL);

    assert (e);

    exp_prime = PFty_prime (PFty_defn (expected));

    if (PFty_subtype (exp_prime, PFty_atomic ())) {

        /*
         * Built-in functions allow the expected type to be `numeric'.
         * In that case, we shall convert to xs:double.
         */
        if (PFty_eq (exp_prime, PFty_numeric ()))
            exp_prime = PFty_double ();

        /* if type exp_prime is atomic untypedAtomic 
           does not need to be casted to atomic 
           -- we therefore can skip the convert-op */
        if (PFty_eq (exp_prime, PFty_atomic ()))
            ret = flwr (let (letbind (var (v1), e), nil ()),
                        fn_data (var (v1)));
        else 
            /* Steps 1 and 2:
             *
             * let $v1 := e return
             *   let $v2 := fn:data ($v1) return
             *     for $v3 in $v2 return
             *       convert-op ($v3, exp_prime)
             */
            ret = flwr (let (letbind (var (v1), e), nil ()),
                        flwr (let (letbind (var (v2), fn_data (var (v1))), 
                                   nil ()),
                              flwr (for_ (forbind (forvars (var (v3), nil ()),
                                                   var (v2)), nil ()),
                                    fs_convert_op_by_type (var (v3),
                                                           exp_prime))));

    }
    else
        /* do nothing if expected is not atomic */
        ret = (PFcnode_t *) e;

    return ret;
}


/**
 * Compile parse tree into XQuery Core tree.
 *
 * @param r root of the abstract syntax tree
 * @return the Core equivalent of @a r
 */
PFcnode_t *
PFfs (PFpnode_t *r)
{
    assert (r);

    core_vars = 0;

    /* initially, there is no function on the current function stack */
    funs = PFarray (sizeof (PFapply_t *));

    /* initially, there is no argument list on the current arguments stack */
    args = PFarray (sizeof (PFcnode_t *));

    /* initially, there nothing on the current argument number stack */
    arg_num = PFarray (sizeof (unsigned short));

    /* initially, the context item is undefined */
    fs_dot = NULL;
    fs_position = NULL;
    fs_last = NULL;

    /* We collect function signatures in the query prolog here. */
    fun_sigs = nil ();

    /* We collect variable declarations in the query prolog
     * in a root/hole pair. */
    var_decls.root = var_decls.hole = NULL;

    /* label the parse tree bottom up */
    PFfs_label (r);

    /* invoke compilation */
    process_fun_sigs (r, 1);    /* compile function signatures first */
    reduce (r, 1);              /* then all the rest */

    /* sanity: current function/argument list stacks need to be empty */
    assert (PFarray_empty (funs));
    assert (PFarray_empty (args));

    return r->core;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
