%{

/**
 * @file
 *
 * Optimize XQuery Core tree (with static type information available).
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2005 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */ 


#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "oops.h"
#include "core.h"
#include "qname.h"
#include "mem.h"
#include "subtyping.h"
#include "typecheck.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFcnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/core.h!
 */
%term var                =  1 /**< variable */
%term lit_str            =  2 /**< string literal */
%term lit_int            =  3 /**< integer literal */
%term lit_dec            =  4 /**< decimal literal */
%term lit_dbl            =  5 /**< double literal */
%term nil                =  6 /**< end-of-sequence marker */

%term seq                =  7 /**< sequence construction */
%term ordered            =  8
%term unordered          =  9

%term let                = 10 /**< let expression */
%term letbind            = 11 /**< binding part of a let expression */
%term for_               = 12 /**< for expression */
%term forbind            = 13 /**< binding part of a for expression */
%term forvars            = 14 /**< variable pair (var + pos. var) of a for */

%term orderby            = 15 /**< orderby clause */
%term orderspecs         = 16 /**< list of order specs */

%term apply              = 17 /**< function application */
%term arg                = 18 /**< function argument (list) */

%term typesw             = 19 /**< typeswitch clause */
%term cases              = 20 /**< case concatenation for typeswitch */
%term case_              = 21 /**< single case for typeswitch */
%term default_           = 22 /**< default branch in typeswitch */
%term seqtype            = 23 /**< a SequenceType */
%term seqcast            = 24 /**< cast along <: */
%term proof              = 25 /**< typechecker only: prove <: relationship */
%term subty              = 26 /**< subtype condition for proof() */
%term stattype           = 27 /**< static type of expression. Required for
                                   fs:convert-operand. Will be removed during
                                   typechecking and replaced by seqtype, as
                                   soon as types are known. */

%term if_                = 28 /**< if-then-else conditional */
%term then_else          = 29 /**< then- and else-branches of an
                                   if-then-else conditional */

%term locsteps           = 30 /**< path of location steps only */
%term ancestor           = 31 /**< the parent, the parent's parent,... */
%term ancestor_or_self   = 32 /**< the parent, the parent's parent,... + self */
%term attribute          = 33 /**< attributes of the context node */
%term child              = 34 /**< children of the context node */
%term descendant         = 35 /**< children, children's children,... + self */
%term descendant_or_self = 36 /**< children, children's children,... */
%term following          = 37 /**< nodes after current node (document order) */
%term following_sibling  = 38 /**< all following nodes with same parent */
%term parent             = 39 /**< parent node (exactly one or none) */
%term preceding          = 40 /**< nodes before context node (document order) */
%term preceding_sibling  = 41 /**< all preceding nodes with same parent */
%term self               = 42 /**< the context node itself */

%term elem               = 43 /**< the element constructor */
%term attr               = 44 /**< the attribute constructor */
%term text               = 45 /**< the text constructor */
%term doc                = 46 /**< the document constructor */
%term comment            = 47 /**< the comment constructor */
%term pi                 = 48 /**< the processing-instruction constructor */
%term tag                = 49 /**< the tagname for elem. and attr. constr. */

%term true_              = 50 /**< built-in function `fn:true ()' */
%term false_             = 51 /**< built-in function `fn:false ()' */
%term empty              = 52 /**< built-in function `empty' */
%term main               = 53 /**< tree root
                                   Separates function declarations from
                                   the query body. */
%term fun_decls          = 54 /**< list of function declarations */
%term fun_decl           = 55 /**< function declaration */
%term params             = 56 /**< function declaration parameter list */
%term param              = 57 /**< function declaration parameter */
%term cast               = 58 /**< XQuery `cast as' operation */

%%

Query:              main (FunctionDecls, CoreExpr)              =   1 (10);

CoreExpr:           Atom                                        =   2 (10);
CoreExpr:           SequenceTypeCast                            =   3 (10);

CoreExpr:           for_ (forbind (forvars (var, OptVar),
                                   Atom),
                          CoreExpr)                             =   4 (10);

OptVar:             nil                                         =   5 (10);
OptVar:             var                                         =   6 (10);

CoreExpr:           let (letbind (var, Atom), CoreExpr)         =   7 (10);
CoreExpr:           let (letbind (var, CoreExpr), CoreExpr)     =   8 (10);
CoreExpr:           let (letbind (var,
                                  let (letbind (var, CoreExpr),
                                       CoreExpr)),
                         CoreExpr)                              =   9 (10);

CoreExpr:           typesw (Atom,
                            cases (case_ (SequenceType,
                                          CoreExpr),
                                   default_ (CoreExpr)))        =  10 (10);

SequenceType:       seqtype                                     =  11 (10);
SequenceType:       stattype (CoreExpr)                         =  12 (10);

SequenceTypeCast:   seqcast (SequenceType, CoreExpr)            =  13 (10);

CoreExpr:           proof (subty (CoreExpr, SequenceType),
                           CoreExpr)                            =  14 (10);

CoreExpr:           if_ (Atom, then_else (CoreExpr, CoreExpr))  =  15 (10);

Var:                var                                         =  18 (10);

CoreExpr:           seq (Atom, Atom)                            =  19 (10);
CoreExpr:           seq (empty, Atom)                           =  20 (10);
CoreExpr:           seq (Atom, empty)                           =  21 (10);

CoreExpr:           LocationSteps                               =  22 (10);
CoreExpr:           LocationStep                                =  23 (10);

LocationStep:       ancestor (SequenceType)                     =  24 (10);
LocationStep:       ancestor_or_self (SequenceType)             =  25 (10);
LocationStep:       attribute (SequenceType)                    =  26 (10);
LocationStep:       child (SequenceType)                        =  27 (10);
LocationStep:       descendant (SequenceType)                   =  28 (10);
LocationStep:       descendant_or_self (SequenceType)           =  29 (10);
LocationStep:       following (SequenceType)                    =  30 (10);
LocationStep:       following_sibling (SequenceType)            =  31 (10);
LocationStep:       parent (SequenceType)                       =  32 (10);
LocationStep:       preceding (SequenceType)                    =  33 (10);
LocationStep:       preceding_sibling (SequenceType)            =  34 (10);
LocationStep:       self (SequenceType)                         =  35 (10);

LocationSteps:      locsteps (LocationStep, LocationSteps)      =  36 (10);
LocationSteps:      locsteps (LocationStep, Atom)               =  37 (10);

CoreExpr:           elem (TagName, CoreExpr)                    =  38 (10);
CoreExpr:           attr (TagName, CoreExpr)                    =  39 (10);
CoreExpr:           text (CoreExpr)                             =  40 (10);
CoreExpr:           doc (CoreExpr)                              =  41 (10);
CoreExpr:           comment (CoreExpr)                          =  42 (10);
CoreExpr:           pi (CoreExpr)                               =  43 (10);

TagName:            tag                                         =  44 (10);
TagName:            CoreExpr                                    =  45 (10);

CoreExpr:           apply (FunctionArgs)                        =  46 (10);
CoreExpr:           apply (arg (Atom, nil))                     =  47 (10);
CoreExpr:           apply (arg (Atom, arg (Atom, nil)))         =  48 (10);

FunctionArgs:       arg (Atom, FunctionArgs)                    =  49 (10);
FunctionArgs:       arg (SequenceTypeCast, FunctionArgs)        =  50 (10);
FunctionArgs:       nil                                         =  51 (10);

CoreExpr:           ordered (CoreExpr)                          =  52 (10);
CoreExpr:           unordered (CoreExpr)                        =  53 (10);

CoreExpr:           orderby (OrderSpecs, CoreExpr)              =  54 (10);

OrderSpecs:         orderspecs (CoreExpr, nil)                  =  55 (10);
OrderSpecs:         orderspecs (CoreExpr, OrderSpecs)           =  56 (10);

CoreExpr:           cast (SequenceType, CoreExpr)               =  57 (10);

Atom:               var                                         =  58 (10);
Atom:               empty                                       =  59 (10);
Atom:               LiteralValue                                =  60 (10);

LiteralValue:       lit_str                                     =  61 (10);
LiteralValue:       lit_int                                     =  62 (10);
LiteralValue:       lit_dec                                     =  63 (10);
LiteralValue:       lit_dbl                                     =  64 (10);
LiteralValue:       true_                                       =  65 (10);
LiteralValue:       false_                                      =  66 (10);

FunctionDecls:      nil                                         =  67 (10);
FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls)     =  68 (10);

FunctionDecl:       fun_decl (ParamList, FunctionBody)          =  69 (10);

ParamList:          nil                                         =  70 (10);
ParamList:          params (FunParam, ParamList)                =  71 (10);

FunctionBody:       CoreExpr                                    =  72 (10);

FunParam:           param (SequenceType, var)                   =  73 (10);

%%

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define LRL(p) L(R(L(p)))
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))
#define LLL(p) L(L(L(p)))
#define LLR(p) R(L(L(p)))
#define LRR(p) R(R(L(p)))
#define LRLL(p) L(L(R(L(p))))
#define LRLR(p) R(L(R(L(p))))
#define RLR(p) R(L(R(p)))
#define RLL(p) L(L(R(p)))

/** Type of a core tree node */
#define TY(p) ((p)->type)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

static void relabel (PFcnode_t *p,  PFcnode_t **kids);
static bool replace_var (PFvar_t *v, PFcnode_t *a, PFcnode_t *e);

/**
 * Global XQuery `declare variable' statements have been translated
 * into `let' clauses during Core compilation.  Rewriting such `let'
 * clauses (i.e., replacing their variable), may affect user-defined
 * functions.
 *
 * When rewriting `let's, we thus also do the variable replacement
 * in the function declarations, which are available through this
 * pointer.  If we rewrote anything in the function declarations
 * part, we set fun_decls_modified, to trigger another run of the
 * optimizer.
 */
static PFcnode_t *fun_decls = NULL;
static bool fun_decls_modified = false;

#include "core_mnemonic.h"

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFcnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFcnode_t *   kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          rewritten;
    short         old_state_label;

    do {
        /* determine rule that matches for this non-terminal */
        rule = PFcoreopt_rule (STATE_LABEL (p), goalnt);

        assert (rule);

        /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFcoreopt_nts[rule];
        PFcoreopt_kids (p, rule, kids);

        /*
         * Recursively invoke compilation.  This means bottom-up compilation.
         */
        unsigned short i;
        rewritten = false;
        for (i = 0; nts[i]; i++)
            if ((rewritten = reduce (kids[i], nts[i])))
                break;  /* abort if a subtree was rewritten */

        if (rewritten) {
            /*
             * If a subtree has been rewritten, we have to
             *  - re-label that part of the tree, and
             *  - possibly propagate the `rewritten' information upwards.
             */

            /* remember our old state_label (so we know if it has changed) */
            old_state_label = STATE_LABEL(p);

            /*
             * Re-label current tree pattern.
             * (at most down to the pattern leaves, as they should already be
             * correctly labeled by the above reduce() call)
             */
            relabel (p, kids);

            /* If our own state_label has changed, notify our caller. */
            if (old_state_label != STATE_LABEL(p))
                return true;
        }
    } while (rewritten);

    rewritten = false;

    switch (rule) {

        /* CoreExpr:           for_ (forbind (forvars (var, OptVar),
                                              Atom),
                                     CoreExpr) */
        case 4:
            /*
             * for $v [ at $p ] in e return $v   -->   e
             */
            if (R(p)->kind == c_var
                && R(p)->sem.var == LLL(p)->sem.var) {
                *p = *LR(p);
                rewritten = true;
                break;
            }

            /*
             * If we iterate over a sequence that we know (from static
             * typing) to always have length 1, replace the `for' by
             * a corresponding `let'.
             */
            if (PFty_subtype (TY(LR(p)), PFty_xs_anyItem ())) {

                PFcnode_t *c = R(p);

                if (LLR(p)->kind != c_nil) {
                    c = let (letbind (LLR(p), num (1)), c);

                    /* fix types */
                    TY(c) = TY(R(p));
                    TY(LR(c)) = PFty_xs_integer ();
                }

                *p = *let (letbind (LLL(p), LR(p)), c);

                TY(p) = TY(c);

                relabel (p, kids);
                rewritten = true;

                /*
                 * Re-label entire subtree. Type-checking may have
                 * modified all the state labels in the subtree, so
                 * we have to restore them.
                 */
                PFcoreopt_label (p);
                break;
            }

            /*
             * If we know (from static typing) that we are iterating
             * over the empty sequence, replace the whole thing by
             * the empty sequence.
             */
            if (PFty_subtype (TY(LR(p)), PFty_empty ())) {
                *p = *empty ();
                relabel (p, kids);
                rewritten = true;
                break;
            }

            break;

        /* CoreExpr:           let (letbind (var, Atom), CoreExpr) */
        case 7:
            /*
             * Unfold atoms (a is an atom)
             *
             *     let $v := a return e
             *  -->
             *     e[a/$v]
             */
            replace_var (LL(p)->sem.var, LR(p), R(p));

            /*
             * Also replace variables in the function declarations
             * prolog. If anything has been replaced, set a flag to
             * trigger another run of the optimizer (to optimize
             * function bodies).
             */
            fun_decls_modified
                |= replace_var (LL(p)->sem.var, LR(p), fun_decls);

            /*
             * If we replaced a global variable by another variable,
             * mark this new variable as global.
             */
            if (fun_decls_modified && 
                LR(p)->kind == c_var &&
                LL(p)->sem.var->global)
                LR(p)->sem.var->global = true;

            *p = *R(p);
            /* Variable replacement can have effects on patterns deep
             * down below the current pattern. We thus re-label the
             * entire subtree.
             */
            PFcoreopt_label (p);
            rewritten = true;
            break;

        /* CoreExpr:           let (letbind (var,
                                             let (letbind (var, CoreExpr),
                                                  CoreExpr)),
                                    CoreExpr) */
        case 9:
            /*
             * Remove a nested let block:
             * 
             *     let $v1 := let $v2 := e return e' return e''
             *  -->
             *     let $v2 := e return
             *       let $v1 := e' return
             *         e''
             */
            *p = *let (letbind (LRLL(p), LRLR(p)),  /* let $v2 := e return    */
                     let (letbind (LL(p), LRR(p)),  /*   let $v1 := e' return */
                         R(p)));                    /*     e''                */
            relabel (p, kids);
            rewritten = true;
            break;

        /* CoreExpr:           typesw (Atom,
                                       cases (case_ (SequenceType,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 10:
            /*
             * If we statically know that the type of an expression matches
             * a typeswitch case, we can remove the typeswitch.
             */
            if (PFty_subtype (L(p)->type, RLL(p)->type)) {
                *p = *RLR(p);
                rewritten = true;
            }
            /*
             * If we statically know that the type of an expression
             * can never match a typeswitch case, we can remove the
             * typeswitch.
             */
            else if (PFty_disjoint (L(p)->type, RLL(p)->type)) {
                *p = *RRL(p);
                rewritten = true;
            }

            break;

        /* CoreExpr:           seq (empty, Atom) */
        case 20:
            *p = *R(p);
            rewritten = true;
            break;

        /* CoreExpr:           seq (Atom, empty) */
        case 21:
            *p = *L(p);
            rewritten = true;
            break;

        /* CoreExpr:           apply (arg (Atom, nil)) */
        case 47:
            if (! PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "data"))) {
                /*
                 * If the argument is a subtype of atomic*, fn:data()
                 * returns the argument itself.
                 */
                if (PFty_subtype (TY(LL(p)), PFty_star (PFty_atomic ()))) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
                /*
                 * If the argument is a subtype of
                 * (comment | processing-instruction)*,
                 * fn:data() returns the string-value
                 * of the argument.
                 */
                if (PFty_subtype (TY(LL(p)),
                                  PFty_star (PFty_choice (PFty_comm (),
                                                          PFty_pi (NULL))))) {
                    p->sem.fun = function (PFqname (PFns_pf, "string-value"));
                    /* type-check what we just created */
                    PFty_check (p);

                    rewritten = true;

                    /*
                     * Re-label entire subtree. Type-checking may have
                     * modified all the state labels in the subtree, so
                     * we have to restore them.
                     */
                    PFcoreopt_label (p);
                    break;
                }
                /*
                 * If the argument is a subtype of
                 * (element | attribute | text | document)*,
                 * fn:data() returns the typed-value
                 * of the argument.
                 */
                if (PFty_subtype (TY(LL(p)),
                                  PFty_star (
                                      PFty_choice (
                                          PFty_xs_anyElement (),
                                          PFty_choice (
                                              PFty_xs_anyAttribute (),
                                              PFty_choice (
                                                  PFty_text (),
                                                  PFty_doc (PFty_xs_anyType ()))
                                              ))))) {
                    /*
                     *   fn:data(e)
                     * -->
                     *   for $v in e return
                     *     fn:typed-value ($v)
                     */
                    PFvar_t *v = new_var (NULL);
                    PFfun_t *fn_tv
                        = function (PFqname (PFns_pf, "typed-value"));

                    *p = *for_ (forbind (forvars (var (v), nil ()), LL(p)),
                                apply (fn_tv, arg (var (v), nil ())));

                    /* type-check what we just created */
                    PFty_check (p);

                    rewritten = true;

                    /*
                     * Re-label entire subtree. Type-checking may have
                     * modified all the state labels in the subtree, so
                     * we have to restore them.
                     */
                    PFcoreopt_label (p);
                    break;
                }
            }

            /*
             * On non-validated nodes, typed-value() always returns
             * the string-value of the node as xs:untypedAtomic.
             * (see also Data Model, 6.2.3)
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf, "typed-value"))
                && PFty_subtype (TY(p), PFty_untypedAtomic ())) {

                PFcnode_t *c = PFmalloc (sizeof (PFcnode_t));
                PFvar_t   *v = new_var (NULL);

                /* apply string-value(), not typed-value() */
                *c = *p;
                c->sem.fun = function (PFqname (PFns_pf, "string-value"));

                *p = *let (letbind (var (v), c),
                           seqcast (seqtype (PFty_untypedAtomic ()), var (v)));

                /* type-check what we just created */
                PFty_check (p);

                rewritten = true;

                /*
                 * Re-label entire subtree. Type-checking may have
                 * modified all the state labels in the subtree, so
                 * we have to restore them.
                 */
                PFcoreopt_label (p);

                break;
            }

            /*
             * fn:zero-or-one() applied to something that is of
             * type empty returns the argument itself.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "zero-or-one"))) {
                if (PFty_subtype (TY(LL(p)), PFty_empty ())) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }
            
            /*
             * fn:exactly-one() applied to something that is of
             * type empty returns an error.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "exactly-one"))) {
                if (PFty_subtype (TY(LL(p)), PFty_empty ()))
                    PFoops (OOPS_FATAL,
                            "err:FORG0005, fn:exactly-one called with "
                            "a sequence containing zero or more than one item.");
                break;
            }
            
            /*
             * fn:boolean() applied to something that is already of
             * type xs:boolean returns the argument itself.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "boolean"))) {
                if (PFty_subtype (TY(LL(p)), PFty_boolean ())) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }

            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "string"))) {
                /*
                 * If the argument is a subtype of xs:string,
                 * fn:string returns the argument itself.
                 */
                if (PFty_subtype (TY(LL(p)), PFty_string ())) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
                /*
                 * If the argument is a subtype of atomic, fn:string()
                 * is just a cast.
                 */
                else if (PFty_subtype (TY(LL(p)), PFty_atomic ())) {
                    PFcnode_t *c = PFmalloc (sizeof (PFcnode_t));
                    PFvar_t   *v = new_var (NULL);
                    
                    c = let (letbind (var (v), LL(p)),
                             cast (seqtype (PFty_string ()), var (v)));

                    *p = *c;
                    
                    /* type-check what we just created */
                    PFty_check (p);
                    
                    rewritten = true;
                    /*
                     * Re-label entire subtree. Type-checking may have
                     * modified all the state labels in the subtree, so
                     * we have to restore them.
                     */
                    PFcoreopt_label (p);
                    break;
                }
                /*
                 * If the argument is a subtype of node,
                 * fn:string() returns the string-value
                 * of the argument.
                 */
                else if (PFty_subtype (TY(LL(p)), PFty_xs_anyNode ())) {
                    p->sem.fun = function (PFqname (PFns_pf, "string-value"));
                    /* type-check what we just created */
                    PFty_check (p);

                    rewritten = true;

                    /*
                     * Re-label entire subtree. Type-checking may have
                     * modified all the state labels in the subtree, so
                     * we have to restore them.
                     */
                    PFcoreopt_label (p);
                    break;
                }
            }

            /*
             * pf:item-sequence-to-untypedAtomic () is translated into
             * fn:string for each node followed by a fn:string-join ()
             * with the seperator " "
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf,
                                       "item-sequence-to-untypedAtomic"))) {
                
                PFvar_t   *v1 = new_var (NULL);
                PFvar_t   *v2 = new_var (NULL);
                PFfun_t   *fn_string
                    = function (PFqname (PFns_fn, "string"));
                PFfun_t   *fn_string_join
                    = function (PFqname (PFns_fn, "string-join"));

                *p = *let (letbind (var (v1),
                                    for_ (forbind (forvars (var (v2), nil ()),
                                                   LL(p)),
                                          apply (fn_string, arg (var (v2), nil ())))),
                            apply (fn_string_join, 
                                   arg (var (v1),
                                        arg (str (" "),
                                             nil ()))));
                PFty_check (p);

                rewritten = true;

                /*
                 * Re-label entire subtree. Type-checking may have
                 * modified all the state labels in the subtree, so
                 * we have to restore them.
                 */
                PFcoreopt_label (p);

                break;
            }

            /*
             * The application of pf:item-sequence-to-node-sequence ()
             * to something that contains only nodes can be discarded.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf,
                                       "item-sequence-to-node-sequence"))) {
                if (PFty_subtype (TY(LL(p)),
                                  PFty_star (PFty_xs_anyNode ()))) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }

            /*
             * The application of pf:merge-adjacent-text-nodes () 
             * to something that contains at most one text node
             * can be discarded.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf, "merge-adjacent-text-nodes"))) {
                    /* is empty */
                if (LL(p)->kind == c_empty ||
                    /* contains exactly one text node */
                    PFty_subtype (TY(LL(p)), PFty_text()) ||
                    /* contains exactly one text node and some attributes*/
                    PFty_subtype (TY(LL(p)), PFty_seq (
                                                 PFty_star (
                                                     PFty_xs_anyAttribute ()),
                                                 PFty_text())) ||
                    /* contains no text nodes */
                    PFty_subtype (TY(LL(p)),
                                  PFty_star (
                                      PFty_choice (
                                          PFty_xs_anyElement (),
                                          PFty_choice (
                                              PFty_xs_anyAttribute (),
                                              PFty_choice (
                                                  PFty_doc (PFty_xs_anyType ()),
                                                  PFty_choice (
                                                      PFty_comm (),
                                                      PFty_pi (NULL)))))))) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }
            break;

        /* CoreExpr:           apply (arg (Atom, arg (Atom, nil))) */
        case 48:
            /*
             * fn:concat does not need to append an empty string
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "concat"))) {
                if (!strcmp (LRL(p)->sem.str,"")) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }

            /*
             * fn:string-join() applied to an empty sequence
             * returns an empty string and applied to a singleton
             * sequence returns the singleton
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "string-join"))) {
                if (PFty_subtype (TY(LL(p)), PFty_empty ())) {
                    *p = *str ("");
                    PFty_check (p);

                    rewritten = true;

                    /*
                     * Re-label entire subtree. Type-checking may have
                     * modified all the state labels in the subtree, so
                     * we have to restore them.
                     */
                    PFcoreopt_label (p);
                    break;
                }
                else if (PFty_subtype (TY(LL(p)), PFty_string ())) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }
            break;

        default:
            break;
    }

    return rewritten;
}

/*
 * Re-label a match pattern.
 *
 * Start with node @a p and relabel the subtree below. However, stop
 * if @a p is one of the pattern leaves, passed as the argument @a kids.
 */
static void 
relabel (PFcnode_t *p,  PFcnode_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFcoreopt_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        relabel (L(p), kids);
        STATE_LABEL(p) = PFcoreopt_state (OP_LABEL(p),
                                          STATE_LABEL(L(p)),
                                          0);
    }
    else if (!L(p) && R(p)) {
        relabel (R(p), kids);
        STATE_LABEL(p) = PFcoreopt_state (OP_LABEL(p),
                                          STATE_LABEL(R(p)),
                                          0);
    }
    else {
        relabel (L(p), kids);
        relabel (R(p), kids);
        STATE_LABEL(p) = PFcoreopt_state (OP_LABEL(p),
                                          STATE_LABEL(L(p)),
                                          STATE_LABEL(R(p)));
    }

}

/**
 * Walk core tree @a e and replace occurrences of variable @a v
 * by core tree @a a (i.e., compute e[a/v]).
 *  
 * @param v variable to replace
 * @param a core tree to insert for @a v
 * @param e core tree to walk over
 * @return modified core tree
 */
static bool
replace_var (PFvar_t *v, PFcnode_t *a, PFcnode_t *e)
{
  unsigned short int  i;
  bool                did_replace = false;

  assert (v && a && e);
    
  if (e->kind == c_var && e->sem.var == v) {
      *e = *a;
      did_replace = true;
  }
  else                            
      for (i = 0; (i < PFCNODE_MAXCHILD) && e->child[i]; i++)
          did_replace |= replace_var (v, a, e->child[i]);

  return did_replace;
}


/**
 * Optimize Core tree, with static type information available.
 *
 * @param r root of the XQuery Core tree
 * @return the optimized XQuery Core tree
 */
PFcnode_t *
PFcoreopt (PFcnode_t *r)
{
    assert (r);

    /* make function declaration prolog accessible to (body) rewrite rules */
    fun_decls = L(r);

    do {
        fun_decls_modified = false;

        /* label the Core tree bottom up */
        PFcoreopt_label (r);

        /* invoke rewriting */
        while (reduce (r, 1))
            /* rewrite as long as there is something to do. */;

    } while (fun_decls_modified);

    return r;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
