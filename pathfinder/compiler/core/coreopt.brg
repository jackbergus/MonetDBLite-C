%{

/**
 * @file
 *
 * Optimize XQuery Core tree (with static type information available).
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2007 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 *
 * $Id$
 */ 


#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "oops.h"
#include "core.h"
#include "qname.h"
#include "mem.h"
#include "subtyping.h"
#include "typecheck.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFcnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

/** We hash variable replacement bindings into 8 buckets */
#define HASH_BUCKETS 8
/** hash function for the variable replacement environment */
#define hash(v) ((unsigned int) ((v) - (PFvar_t *) NULL) % HASH_BUCKETS)

/** a binding in the variable replacement environment */
typedef struct {
    PFvar_t    *var;
    PFcnode_t  *atom;
    char        child;
} bind_t;

/**
 * Variable replacement environment.
 *
 * In order to unfold let-bound variables which are bound to some
 * other atom, we proceed as follows:
 *
 * First, we process the binding sequence (the atom).  If it is
 * a variable itself, there may be a replacement for it, so we do
 * that first.  Then, add an entry to the environment var_env
 * (a hash table with HASH_BUCKETS buckets) and process the return
 * part (which will replace every occurrence of the variable).
 * When we're back, we replace the let clause by its return part.
 *
 * Whenever we process the usage of a variable, look into the
 * environment if there is a replacement for it.  In that case,
 * do the replacement.
 *
 * Note that we do *not* remove the binding from the environment
 * when we're back from the return part.  The Core expression
 * tree may contain "global" variables (i.e., ones that were
 * bound in the query prolog).  Such variables may be used in
 * functions as well.  Therefore, we process the query first
 * (the start rule for our grammar is top-down) in order to have
 * globals be added to the environment.  As we leave all the
 * variables in the environment, they will be available when we
 * process the function bodies.  Hence, they will be replaced
 * there as well.
 */
static PFarray_t *var_env[HASH_BUCKETS];

/**
 * Variable environment that collects the usage of variable bindings.
 */
static PFarray_t *unused_var_env;
/**
 * Variable environment that collects the variable references.
 */
static PFarray_t *used_var_env;

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/core.h!
 */
%term var                =  1 /**< variable */
%term lit_str            =  2 /**< string literal */
%term lit_int            =  3 /**< integer literal */
%term lit_dec            =  4 /**< decimal literal */
%term lit_dbl            =  5 /**< double literal */
%term nil                =  6 /**< end-of-sequence marker */

%term seq                =  7 /**< sequence construction */
%term twig_seq           =  8 /**< sequence construction within twigs */
%term ordered            =  9
%term unordered          = 10

%term flwr               = 14 /**< flwr expression */
%term let                = 15 /**< let expression */
%term letbind            = 16 /**< binding part of a let expression */
%term for_               = 17 /**< for expression */
%term forbind            = 18 /**< binding part of a for expression */
%term forvars            = 19 /**< variable pair (var + pos. var) of a for */

%term orderby            = 20 /**< orderby clause */
%term orderspecs         = 21 /**< list of order specs */

%term apply              = 22 /**< function application */
%term arg                = 23 /**< function argument (list) */

%term typesw             = 25 /**< typeswitch clause */
%term cases              = 26 /**< case concatenation for typeswitch */
%term case_              = 27 /**< single case for typeswitch */
%term default_           = 28 /**< default branch in typeswitch */
%term seqtype            = 29 /**< a SequenceType */
%term seqcast            = 30 /**< cast along <: */
%term proof              = 31 /**< typechecker only: prove <: relationship */
%term subty              = 32 /**< subtype condition for proof() */
%term stattype           = 33 /**< static type of expression. Required for
                                fs:convert-operand. Will be removed during
                                typechecking and replaced by seqtype, as
                                soon as types are known. */

%term if_                = 34 /**< if-then-else conditional */
%term then_else          = 35 /**< then- and else-branches of an
                                if-then-else conditional */

%term locsteps           = 40 /**< path of location steps only */

  /* XPath axes */
%term ancestor           = 41 /**< the parent, the parent's parent,... */
%term ancestor_or_self   = 42 /**< the parent, the parent's parent,... + self */
%term attribute          = 43 /**< attributes of the context node */
%term child              = 44 /**< children of the context node */
%term descendant         = 45 /**< children, children's children,... + self */
%term descendant_or_self = 46 /**< children, children's children,... */
%term following          = 47 /**< nodes after current node (document order) */
%term following_sibling  = 48 /**< all following nodes with same parent */
%term parent             = 49 /**< parent node (exactly one or none) */
%term preceding          = 50 /**< nodes before context node (document order) */
%term preceding_sibling  = 51 /**< all preceding nodes with same parent */
%term self               = 52 /**< the context node itself */
/* [STANDOFF] */
%term select_narrow      = 100 /**< regions contained in a context-node */
%term select_wide        = 101 /**< regions overlapping a context-node */
%term reject_narrow      = 102 /**< all regions except the contained regions */
%term reject_wide        = 103 /**< all regions except the overlapping regions */
/* [/STANDOFF] */

  /* Constructor Nodes */
%term elem               = 55 /**< the element constructor */
%term attr               = 56 /**< the attribute constructor */
%term text               = 57 /**< the text constructor */
%term doc                = 58 /**< the document constructor */
%term comment            = 59 /**< the comment constructor */
%term pi                 = 60 /**< the processing-instruction constructor */
%term tag                = 61 /**< the tagname for elem. and attr. constr. */

%term true_              = 65 /**< built-in function `fn:true ()' */
%term false_             = 66 /**< built-in function `fn:false ()' */
%term empty              = 67 /**< built-in function `empty' */

%term main               = 68 /**< tree root.
                                   Separates function declarations from
                                   the query body. */
%term fun_decls          = 69 /**< list of function declarations */
%term fun_decl           = 70 /**< function declaration */
%term params             = 71 /**< function declaration parameter list */
%term param              = 72 /**< function declaration parameter */
%term cast               = 73 /**< function declaration parameter */

  /* Pathfinder extension: recursion */
%term recursion          = 74 /**< "with $v seeded by..." expression */
%term seed               = 75

  /* Pathfinder extension: XRPC */
%term xrpc               = 76 /**< XRPC calls: "execute at" */

%%

/* all rules starting from rule 40 are never used
   for optimization (-- see also different formatting) */ 

Query:              main (FunctionDecls, CoreExpr)              =   1 (10);
                                                                     
CoreExpr:           Atom                                        =   40(10);
CoreExpr:           SequenceTypeCast                            =   41(10);
                                                                     
CoreExpr:           flwr (OptBindExpr, CoreExpr)                =   2 (10);

CoreExpr:           flwr (for_ (forbind (forvars (var, nil),
                                         CoreExpr),
                                nil), var)                      =   3 (10);

CoreExpr:           flwr (let (letbind (var, CoreExpr),       
                               nil), var)                       =   4 (10);

OptBindExpr:        for_ (forbind (forvars (var, OptVar),            
                                   CoreExpr),                        
                          OptBindExpr)                          =   5 (10);
                                                                     
OptVar:             nil                                         =   42(10);
OptVar:             var                                         =   43(10);
                                                                     
OptBindExpr:        let (letbind (var, Atom), OptBindExpr)      =  10 (10);
OptBindExpr:        let (letbind (var,                               
                                  flwr (let (letbind (var,           
                                                      CoreExpr),     
                                             nil),                   
                                        CoreExpr)),                  
                         OptBindExpr)                           =  11 (10);
OptBindExpr:        let (letbind (var,                               
                                  flwr (let (letbind (var,           
                                                      CoreExpr),     
                                             OptBindExpr),           
                                        CoreExpr)),                  
                         OptBindExpr)                           =  12 (10);
OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr)  =   44(10);
OptBindExpr:        nil                                         =   45(10);
                                                                     
CoreExpr:           typesw (CoreExpr,                                
                            cases (case_ (SequenceType,              
                                          CoreExpr),                 
                                   default_ (CoreExpr)))        =  13 (10);
                                                                     
SequenceType:       seqtype                                     =   46(10);
SequenceType:       stattype (CoreExpr)                         =   47(10);
                                                                     
SequenceTypeCast:   seqcast (SequenceType, CoreExpr)            =  24 (10);
                                                                     
CoreExpr:           proof (subty (CoreExpr, SequenceType),           
                           CoreExpr)                            =   48(10);
                                                                     
CoreExpr:           if_ (CoreExpr,
                         then_else (CoreExpr, CoreExpr))        =   49(10);
                                                                     
CoreExpr:           seq (seq (CoreExpr, CoreExpr), CoreExpr)    =  15 (10);
CoreExpr:           seq (CoreExpr, CoreExpr)                    =   50(10);
CoreExpr:           seq (empty, CoreExpr)                       =  16 (10);
CoreExpr:           seq (CoreExpr, empty)                       =  17 (10);
                                                                     
CoreExpr:           twig_seq (CoreExpr, seq (CoreExpr,
                                             CoreExpr))         =  18 (10);
CoreExpr:           twig_seq (seq (CoreExpr, CoreExpr), 
                              CoreExpr)                         =  19 (10);
CoreExpr:           twig_seq (CoreExpr, CoreExpr)               =   51(10);
CoreExpr:           twig_seq (empty, CoreExpr)                  =  20 (10);
CoreExpr:           twig_seq (CoreExpr, empty)                  =  21 (10);

CoreExpr:           LocationSteps                               =  29 (10);
CoreExpr:           LocationStep                                =   56(10);
                                                                     
LocationStep:       ancestor (SequenceType)                     =   57(10);
LocationStep:       ancestor_or_self (SequenceType)             =   58(10);
LocationStep:       attribute (SequenceType)                    =   59(10);
LocationStep:       child (SequenceType)                        =   60(10);
LocationStep:       descendant (SequenceType)                   =   61(10);
LocationStep:       descendant_or_self (SequenceType)           =   62(10);
LocationStep:       following (SequenceType)                    =   63(10);
LocationStep:       following_sibling (SequenceType)            =   64(10);
LocationStep:       parent (SequenceType)                       =   65(10);
LocationStep:       preceding (SequenceType)                    =   66(10);
LocationStep:       preceding_sibling (SequenceType)            =   67(10);
LocationStep:       self (SequenceType)                         =   68(10);
/* [STANDOFF] */
LocationStep:       select_narrow (SequenceType)                =   69(10);
LocationStep:       select_wide (SequenceType)                  =   70(10);
LocationStep:       reject_narrow (SequenceType)                =   71(10);
LocationStep:       reject_wide (SequenceType)                  =   72(10);
/* [/STANDOFF] */
                                                                     
LocationSteps:      locsteps (LocationStep, LocationSteps)      =   75(10);
LocationSteps:      locsteps (LocationStep, CoreExpr)           =   76(10);
                                                                     
CoreExpr:           elem (TagName, CoreExpr)                    =   77(10);
CoreExpr:           elem (TagName, seq (CoreExpr, CoreExpr))    =  22 (10);
CoreExpr:           attr (TagName, CoreExpr)                    =   78(10);
CoreExpr:           text (CoreExpr)                             =   79(10);
CoreExpr:           doc (CoreExpr)                              =   80(10);
CoreExpr:           doc (seq (CoreExpr, CoreExpr))              =  23 (10);
CoreExpr:           comment (CoreExpr)                          =   81(10);
CoreExpr:           pi (CoreExpr, CoreExpr)                     =   82(10);
                                                                     
TagName:            tag                                         =   83(10);
TagName:            CoreExpr                                    =   84(10);
                                                                     
CoreExpr:           apply (FunctionArgs)                        =   85(10);
CoreExpr:           apply (arg (CoreExpr, nil))                 =  25 (10);
CoreExpr:           apply (arg (CoreExpr, arg (CoreExpr, nil))) =  26 (10);

FunctionArgs:       arg (CoreExpr, FunctionArgs)                =   86(10);
FunctionArgs:       arg (SequenceTypeCast, FunctionArgs)        =   87(10);
FunctionArgs:       nil                                         =   88(10);
                                                                     
CoreExpr:           ordered (CoreExpr)                          =   90(10);
CoreExpr:           unordered (CoreExpr)                        =   91(10);
                                                                     
CoreExpr:           orderby (OrderSpecs, CoreExpr)              =   92(10);
                                                                     
OrderSpecs:         orderspecs (CoreExpr, nil)                  =   93(10);
OrderSpecs:         orderspecs (CoreExpr, OrderSpecs)           =   94(10);
                                                                     
CoreExpr:           cast (SequenceType, CoreExpr)               =  27 (10);
                                                                     
Atom:               var                                         =  28 (10);
Atom:               empty                                       =   95(10);
Atom:               LiteralValue                                =   96(10);
                                                                     
LiteralValue:       lit_str                                     =  100(10);
LiteralValue:       lit_int                                     =  101(10);
LiteralValue:       lit_dec                                     =  102(10);
LiteralValue:       lit_dbl                                     =  103(10);
LiteralValue:       true_                                       =  104(10);
LiteralValue:       false_                                      =  105(10);
                                                                     
FunctionDecls:      nil                                         =  106(10);
FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls)     =  107(10);
                                                                     
FunctionDecl:       fun_decl (ParamList, FunctionBody)          =  110(10);
                                                                     
ParamList:          nil                                         =  111(10);
ParamList:          params (FunParam, ParamList)                =  112(10);
                                                                     
FunctionBody:       CoreExpr                                    =  113(10);
                                                                     
FunParam:           param (SequenceType, var)                   =  114(10);

/* Pathfinder extension: recursion */
CoreExpr:           recursion (var, seed (CoreExpr, CoreExpr))  =  115(10);

/* Pathfinder extension: XRPC */
CoreExpr:           xrpc (CoreExpr, CoreExpr)                   =  116(10);

%%

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define LRL(p) L(R(L(p)))
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))
#define LLL(p) L(L(L(p)))
#define LLR(p) R(L(L(p)))
#define LRR(p) R(R(L(p)))
#define LLLL(p) L(L(L(L(p))))
#define LRLL(p) L(L(R(L(p))))
#define LLRL(p) L(R(L(L(p))))
#define LRLR(p) R(L(R(L(p))))
#define LLRR(p) R(R(L(L(p))))
#define RLR(p) R(L(R(p)))
#define RLL(p) L(L(R(p)))

/** Type of a core tree node */
#define TY(p) ((p)->type)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

static void relabel (PFcnode_t *p,  PFcnode_t **kids);

#include "core_mnemonic.h"

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static bool
reduce (PFcnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFcnode_t *   kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          rewritten;
    short         old_state_label;

    /* guard against too dep recursion */
    PFrecursion_fence();

    do {
        /* determine rule that matches for this non-terminal */
        rule = PFcoreopt_rule (STATE_LABEL (p), goalnt);

        assert (rule);

        /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */

        /* initialize the kids[] vector */
        for (unsigned short i = 0; i < MAX_KIDS; i++)
            kids[i] = NULL;

        /*
         * prepare recursive traversal: get information on leaf nodes of
         * this rule
         */
        nts = PFcoreopt_nts[rule];
        PFcoreopt_kids (p, rule, kids);

        rewritten = false;
        /* evaluate top-down in a number of cases */
        switch (rule) {
            /* Query:              main (FunctionDecls, CoreExpr) */
            case 1:
                /*
                 * Look at query body first, then at function declarations.
                 * This way we make sure that the expansion of let statements
                 * also considers function declarations.
                 */
                rewritten |= reduce (kids[1], nts[1]);
                rewritten |= reduce (kids[0], nts[0]);

                break;

            /* CoreExpr:           flwr (OptBindExpr,
                                         CoreExpr) */
            case 2:
                /* Make sure to collect all variables first ... */
                rewritten |= reduce (kids[0], nts[0]);
                /* ... and then fill in the replacements. */
                rewritten |= reduce (kids[1], nts[1]);

                /* remove uncessary flwr expressions */
                if (L(p)->kind == c_nil)
                {
                    /* also remove orderby node if present
                       (static typing ensures that we don't
                        prune erroneous order arguments) */
                    if (R(p)->kind == c_orderby)
                        *p = *(RR(p));
                    else
                        *p = *(R(p));

                    rewritten = true;
                }
                break;

            /* OptBindExpr:        let (letbind (var, CoreExpr), OptBindExpr) */
            case 10:
                /*
                 * Unfold atoms (a is an atom)
                 *
                 *     let $v := a return e
                 *  -->
                 *     e[a/$v]
                 *
                 * See the comment in the declaration of var_env to
                 * understand what's going on here.
                 */

                /*
                 * Handle CoreExpr first.  In case it is a variable, this
                 * will make sure that we do transitive cases of variable
                 * replacement correctly.
                 */
                reduce (kids[0], nts[0]);

                /* add mapping for this variable to the environment */
                *((bind_t *) PFarray_add (var_env[hash(LL(p)->sem.var)]))
                    = (bind_t) { .var = LL(p)->sem.var,
                                 .atom = LR(p),
                                 .child = -1 };

                if (LL(p)->sem.var->global && LR(p)->kind == c_var)
                    LR(p)->sem.var->global = true;

                /*
                 * Reduce the return part.
                 */
                reduce (kids[1], nts[1]);

                /*
                 * Do NOT remove the variable from the environment.
                 */

                /*
                 * We have now replaced every occurrence of the variable
                 * in the return part with its binding atom.  The return
                 * part now becomes the expression itself.
                 */
                *p = *R(p);

                rewritten = true;
                break;

            default:
                /*
                 * Recursively invoke compilation.
                 * This means bottom-up compilation.
                 */
                for (unsigned short i = 0; nts[i]; i++)
                    if ((rewritten = reduce (kids[i], nts[i])))
                        break;  /* abort if a subtree was rewritten */
        }

        if (rewritten) {
            /*
             * If a subtree has been rewritten, we have to
             *  - re-label that part of the tree, and
             *  - possibly propagate the `rewritten' information upwards.
             */

            /* remember our old state_label (so we know if it has changed) */
            old_state_label = STATE_LABEL(p);

            /*
             * Re-label current tree pattern.
             * (at most down to the pattern leaves, as they should already be
             * correctly labeled by the above reduce() call)
             */
            relabel (p, kids);

            /* If our own state_label has changed, notify our caller. */
            if (old_state_label != STATE_LABEL(p))
                return true;
        }
    } while (rewritten);

    rewritten = false;

    switch (rule) {
        /* CoreExpr:           flwr (for_ (forbind (forvars (var, nil),
                                                    CoreExpr),
                                           nil), var) */
        case 3:
            /* replace for loops of the form
               'for $a in ... return $a' by its input '...' */
            if (LLLL(p)->sem.var == R(p)->sem.var) {
                *p = *LLR(p);
                relabel (p, kids);
                rewritten = true;
            }
            break;
            
        /* CoreExpr:           flwr (let (letbind (var, CoreExpr),       
                                          nil), var) */
        case 4:
            /* replace unnecessary let binding 
               'let $a := ... return $a' by its input '...' */
            if (LLL(p)->sem.var == R(p)->sem.var &&
                !R(p)->sem.var->global) {
                *p = *LLR(p);
                relabel (p, kids);
                rewritten = true;
            }
            break;
            
        /* OptBindExpr:        for_ (forbind (forvars (var, OptVar),
                                              CoreExpr),
                                     OptBindExpr) */
        case 5:
            /*
             * If we iterate over a sequence that we know (from static
             * typing) to always have length 1, replace the `for' by
             * a corresponding `let'.
             */
            if (PFty_subtype (TY(LR(p)), PFty_xs_anyItem ())) {

                PFcnode_t *c = R(p);

                if (LLR(p)->kind != c_nil) {
                    c = let (letbind (LLR(p), num (1)), c);

                    /* fix types */
                    TY(LR(c)) = PFty_xs_integer ();
                    c->sem.flwr.quantifier = PFty_one;
                }

                *p = *let (letbind (LLL(p), LR(p)), c);
                /* type let binding */
                p->sem.flwr.quantifier = PFty_one;

                relabel (p, kids);
                rewritten = true;

                break;
            }

            break;

        /* OptBindExpr:        let (letbind (var,
                                             flwr (let (letbind (var, 
                                                                 CoreExpr),
                                                        nil),
                                                   CoreExpr)),
                                    OptBindExpr) */
        case 11:
            /*
             * Remove a nested let block:
             * 
             *     let $v1 := let $v2 := e return e' return e''
             *  -->
             *     let $v2 := e return
             *       let $v1 := e' return
             *         e''
             */
            *p = *let (letbind (LL(LRL(p)), LR(LRL(p))), /* let $v2 := e ret */
                       let (letbind (LL(p), LRR(p)),     /*   let $v1 := e'  */
                            R(p)));                      /*     ret e''      */

            /* remove unncessary order by expression 
               bound to flwr expression (here e') */
            if (RLR(p)->kind == c_orderby)
                RLR(p) = R(RLR(p));
    
            /* type let binding */
            p->sem.flwr.quantifier    = 
            R(p)->sem.flwr.quantifier = RR(p)->sem.flwr.quantifier;

            relabel (p, kids);
            rewritten = true;
            break;


        /* OptBindExpr:        let (letbind (var,
                                             flwr (let (letbind (var, 
                                                                 CoreExpr),
                                                        OptBindExpr)),
                                                   CoreExpr),
                                    OptBindExpr) */
        case 12:
            /*
             * Remove a nested let block:
             * 
             *     let $v1 := let $v2 := e return e' return e''
             *  -->
             *     let $v2 := e return
             *       let $v1 := e' return
             *         e''
             */
            *p = *let (letbind (LL(LRL(p)), LR(LRL(p))), /* let $v2 := e ret */
                     let (letbind (LL(p),                /*   let $v1 := e'  */
                                   flwr (R(LRL(p)),
                                         LRR(p))),
                          R(p)));                        /*     ret e''      */

            /* type let binding */
            p->sem.flwr.quantifier    = 
            R(p)->sem.flwr.quantifier = RR(p)->sem.flwr.quantifier;

            relabel (p, kids);
            rewritten = true;
            break;

        /* CoreExpr:           typesw (CoreExpr,
                                       cases (case_ (SequenceType,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 13:
            /*
             * If we statically know that the type of an expression matches
             * a typeswitch case, we can remove the typeswitch.
             */
            if (PFty_subtype (TY(L(p)), TY(RLL(p)))) {
                *p = *RLR(p);
                rewritten = true;
            }
            /*
             * If we statically know that the type of an expression
             * can never match a typeswitch case, we can remove the
             * typeswitch.
             */
            else if (PFty_disjoint (TY(L(p)), TY(RLL(p)))) {
                *p = *RRL(p);
                rewritten = true;
            }

            /*
             * If the opt occurrence indicator is the only part
             * in the typeswitch we cannot decide statically
             * we can replace the typeswitch by a call to fn:exists ().
             */
            else if (L(p)->kind == c_var &&
                R(p)->kind == c_cases &&
                RL(p)->kind == c_case &&
                PFty_subtype (TY(RLL(p)), PFty_item ()) &&
                PFty_subtype (TY(L(p)), PFty_opt(TY(RLL(p))))) {
                PFvar_t *v = PFcore_new_var (NULL);
                PFfun_t *fn_exists
                    = PFcore_function (PFqname (PFns_fn, "exists"));

                /* if the input is not empty choose the case branch
                   else choose the default branch */
                *p = *flwr (let (letbind (
                                     var (v),
                                     apply (fn_exists, arg (L(p), nil ()))),
                                 nil ()),
                            if_ (var (v), then_else (RLR(p), RRL(p))));

                /* type-check what we just created */
                PFty_check (p);

                rewritten = true;

                /*
                 * Re-label entire subtree. Type-checking may have
                 * modified all the state labels in the subtree, so
                 * we have to restore them.
                 */
                PFcoreopt_label (p);
                break;
            }

            break;

        /* CoreExpr:           seq (seq (CoreExpr, CoreExpr), CoreExpr) */
        case 15:
        /* CoreExpr:           twig_seq (seq (CoreExpr, CoreExpr), CoreExpr) */
        case 19:
            *p = *seq (LL(p), seq (LR(p), R(p)));
            
            /* type-check what we just created */
            PFty_check (p);

            rewritten = true;

            /*
             * Re-label entire subtree. Type-checking may have
             * modified all the state labels in the subtree, so
             * we have to restore them.
             */
            PFcoreopt_label (p);
            break;
                
        /* CoreExpr:           seq (empty, CoreExpr) */
        case 16:
        /* CoreExpr:           twig_seq (empty, CoreExpr) */
        case 20:
            *p = *R(p);
            rewritten = true;
            break;

        /* CoreExpr:           seq (CoreExpr, empty) */
        case 17:
        /* CoreExpr:           twig_seq (CoreExpr, empty) */
        case 21:
            *p = *L(p);
            rewritten = true;
            break;

        /* CoreExpr:           twig_seq (CoreExpr, seq (CoreExpr, CoreExpr)) */
        case 18:
        /* CoreExpr:           elem (TagName, seq (CoreExpr, CoreExpr)) */
        case 22:
        {
            PFty_t ty_r = TY(R(p));
            R(p) = twig_seq (RL(p), RR(p));
            TY(R(p)) = ty_r;

            relabel (p, kids);
            rewritten = true;
        }   break;

        /* CoreExpr:           doc (seq (CoreExpr, CoreExpr)) */
        case 23:
        {
            PFty_t ty_l = TY(L(p));
            L(p) = twig_seq (LL(p), LR(p));
            TY(L(p)) = ty_l;

            relabel (p, kids);
            rewritten = true;
        }   break;

        /* CoreExpr:           apply (arg (CoreExpr, nil)) */
        case 25:
            if (! PFqname_eq (p->sem.fun->qname, PFqname (PFns_fn, "data"))) {
                /*
                 * If the argument is a subtype of atomic*, fn:data()
                 * returns the argument itself.
                 */
                if (PFty_subtype (TY(LL(p)), PFty_star (PFty_atomic ()))) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }

                /*
                 * If the argument is a subtype of node*,
                 * fn:data() returns the typed-value of the argument.
                 */
                if (PFty_subtype (TY(LL(p)),
                                  PFty_star (PFty_node ()))) {
                    /*
                     *   fn:data(e)
                     * -->
                     *   for $v in e return
                     *     fn:typed-value ($v)
                     */
                    PFvar_t *v = new_var (NULL);
                    PFfun_t *fn_tv
                        = function (PFqname (PFns_pf, "typed-value"));

                    *p = *flwr (for_ (forbind (forvars (var (v), nil ()), 
                                               LL(p)), nil ()),
                                apply (fn_tv, arg (var (v), nil ())));

                    /* type-check what we just created */
                    PFty_check (p);

                    rewritten = true;

                    /*
                     * Re-label entire subtree. Type-checking may have
                     * modified all the state labels in the subtree, so
                     * we have to restore them.
                     */
                    PFcoreopt_label (p);
                    break;
                }
            }

            /*
             * If the argument is a subtype of
             * (comment | processing-instruction),
             * fn:typed-value() returns the string-value
             * of the argument.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf, "typed-value"))
                && PFty_subtype (TY(LL(p)),
                                 PFty_choice (PFty_comm (), PFty_pi (NULL)))) {
                p->sem.fun = function (PFqname (PFns_pf, "string-value"));
                rewritten = true;
                break;
            }

            /*
             * On non-validated nodes (for non-validated nodes,
             * the return type of typed-value() has been inferred
             * as untypedAtomic (via the judgement data_on)),
             * typed-value() always returns the string-value of
             * the node as xs:untypedAtomic.
             * (see also Data Model, 6.2.3)
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf, "typed-value"))
                && PFty_subtype (TY(p), PFty_untypedAtomic ())) {

                PFcnode_t *c = PFmalloc (sizeof (PFcnode_t));
                PFvar_t   *v = new_var (NULL);

                /* apply string-value(), not typed-value() */
                *c = *p;
                c->sem.fun = function (PFqname (PFns_pf, "string-value"));

                *p = *flwr (let (letbind (var (v), c), nil ()),
                            cast (seqtype (PFty_untypedAtomic ()), 
                                  var (v)));

                /* type-check what we just created */
                PFty_check (p);

                rewritten = true;

                /*
                 * Re-label entire subtree. Type-checking may have
                 * modified all the state labels in the subtree, so
                 * we have to restore them.
                 */
                PFcoreopt_label (p);

                break;
            }

            /*
             * #pf:distinct-doc-order-or-atomic-sequence() can be replaced
             * by the function #pf:distinct-doc-order if the type is node*
             * and by the identity otherwise (type atomic*).
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (
                                  PFns_pf, 
                                  "distinct-doc-order-or-atomic-sequence"))) {
                if (PFty_subtype (TY(p), PFty_star (PFty_node ()))) {
                    p->sem.fun = 
                        function (
                            PFqname (
                                PFns_pf,
                                "distinct-doc-order"));
                    rewritten = true;
                    break;
                }
                else if (PFty_subtype (TY(p), PFty_star (PFty_atomic ()))) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
                else
                    PFoops (OOPS_FATAL,
                            "typechecking is incomplete for function "
                            "#pf:distinct-doc-order-or-atomic-sequence.");
            }
            
            /*
             * #pf:distinct-doc-order() or fn:reverse() underneath a call
             * of the function #pf:distinct-doc-order can be removed.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf, "distinct-doc-order"))) {
                if (LL(p)->kind == c_apply &&
                    (! PFqname_eq (LL(p)->sem.fun->qname,
                                   PFqname (PFns_pf, "distinct-doc-order")) ||
                     ! PFqname_eq (LL(p)->sem.fun->qname,
                                   PFqname (PFns_fn, "reverse")))) {
                    assert (LLL(p)->kind == c_arg);

                    LL(p) = LL(LL(p));
                     
                    /* replace kids vector by the real kid... */
                    kids[0] = LL(p);
                    /* ... and relabel the pattern */
                    relabel (p, kids);
                        
                    rewritten = true;
                    break;
                }
                if (LL(p)->kind == c_locsteps &&
                    LLR(p)->kind == c_apply &&
                    ! PFqname_eq (LLR(p)->sem.fun->qname,
                                  PFqname (PFns_pf, "distinct-doc-order"))) {
                    LLR(p) = LL(LLR(p));
                     
                    /* replace kids vector by the real kid... */
                    kids[0] = LLR(p);
                    /* ... and relabel the pattern */
                    relabel (p, kids);
                        
                    rewritten = true;
                    break;
                }
            }

            /*
             * fn:zero-or-one() applied to something that is of
             * type item? returns the argument itself.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "zero-or-one"))) {
                if (PFty_subtype (TY(LL(p)), PFty_opt (PFty_item ()))) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }
            
            /*
             * fn:exactly-one() applied to something that is of
             * type empty returns an error.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "exactly-one"))) {
                if (PFty_subtype (TY(LL(p)), PFty_empty ()))
                    PFoops (OOPS_FATAL,
                            "err:FORG0005, fn:exactly-one called with a "
                            "sequence containing zero or more than one item.");
                break;
            }
            
            /*
             * fn:boolean() applied to something that is already of
             * type xs:boolean returns the argument itself.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "boolean"))) {
                if (PFty_subtype (TY(LL(p)), PFty_xs_boolean ())) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }

            /*
             * fn:ceiling(), fn:floor(), and fn:round() applied 
             * to something that is of type integer returns
             * the argument itself.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "ceiling")) ||
                ! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "floor")) ||
                ! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "round"))) {
                if (PFty_subtype (TY(LL(p)), PFty_xs_integer ())) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }

            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "string"))) {
                /*
                 * If the argument is a subtype of xs:string,
                 * fn:string returns the argument itself.
                 */
                if (PFty_subtype (TY(LL(p)), PFty_xs_string ())) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
                /*
                 * If the argument is a subtype of atomic, fn:string()
                 * is just a cast.
                 */
                else if (PFty_subtype (TY(LL(p)), PFty_atomic ())) {
                    PFcnode_t *c = PFmalloc (sizeof (PFcnode_t));
                    PFvar_t   *v = new_var (NULL);
                    
                    c = flwr (let (letbind (var (v), LL(p)), nil ()),
                              cast (seqtype (PFty_xs_string ()), var (v)));

                    *p = *c;
                    
                    /* type-check what we just created */
                    PFty_check (p);
                    
                    rewritten = true;
                    /*
                     * Re-label entire subtree. Type-checking may have
                     * modified all the state labels in the subtree, so
                     * we have to restore them.
                     */
                    PFcoreopt_label (p);
                    break;
                }
                /*
                 * If the argument is a subtype of node,
                 * fn:string() returns the string-value
                 * of the argument.
                 */
                else if (PFty_subtype (TY(LL(p)), PFty_xs_anyNode ())) {
                    p->sem.fun
                        = function (PFqname (PFns_pf, "string-value"));
                    /* type-check what we just created */
                    PFty_check (p);

                    rewritten = true;

                    /*
                     * Re-label entire subtree. Type-checking may have
                     * modified all the state labels in the subtree, so
                     * we have to restore them.
                     */
                    PFcoreopt_label (p);
                    break;
                }
            }

            /*
             * pf:item-sequence-to-untypedAtomic () is translated into
             * fn:string for each node followed by a fn:string-join ()
             * with the seperator " "
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf,
                                       "item-sequence-to-untypedAtomic"))) {
                
                /* cope with empty sequences */
                if (PFty_subtype (TY(LL(p)), PFty_empty ())) {
                    *p = *cast (seqtype (PFty_untypedAtomic ()),
                                str (""));
                }
                else {
                    PFvar_t   *v = new_var (NULL);
                    PFfun_t   *fn_string
                        = function (PFqname (PFns_fn, "string"));
                    PFfun_t   *fn_string_join
                        = function (PFqname (PFns_fn, "string-join"));

                    *p = *cast (seqtype (PFty_untypedAtomic ()),
                                APPLY (fn_string_join,
                                       flwr (for_ (forbind (forvars (var (v),
                                                                     nil ()),
                                                            LL(p)), nil ()),
                                             APPLY (fn_string, var (v))),
                                       str (" ")));
                }

                PFty_check (p);

                rewritten = true;

                /*
                 * Re-label entire subtree. Type-checking may have
                 * modified all the state labels in the subtree, so
                 * we have to restore them.
                 */
                PFcoreopt_label (p);

                break;
            }

            /*
             * The application of pf:item-sequence-to-node-sequence ()
             * to something that contains only nodes can be discarded.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf,
                                       "item-sequence-to-node-sequence"))) {
                if (PFty_subtype (TY(LL(p)),
                                  PFty_star (PFty_xs_anyNode ()))) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
                else if (PFty_subtype (TY(LL(p)), PFty_atomic ())) {
                    PFfun_t   *fn_string
                        = function (PFqname (PFns_fn, "string"));
                    *p = *constr(p_text, apply (fn_string,
                                                arg (LL(p), nil ())));
                    PFty_check (p);

                    rewritten = true;

                    /*
                     * Re-label entire subtree. Type-checking may have
                     * modified all the state labels in the subtree, so
                     * we have to restore them.
                     */
                    PFcoreopt_label (p);
                    break;
                }
            }

            /*
             * The application of pf:merge-adjacent-text-nodes () 
             * to something that contains at most one text node
             * can be discarded.
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_pf, "merge-adjacent-text-nodes"))) {
                    /* is empty */
                if (LL(p)->kind == c_empty ||
                    /* contains at most one text node */
                    PFty_subtype (TY(LL(p)), PFty_opt (PFty_text())) ||
                    /* contains at most one text node and some attributes*/
                    PFty_subtype (TY(LL(p)), PFty_seq (
                                                 PFty_star (
                                                     PFty_xs_anyAttribute ()),
                                                 PFty_opt (PFty_text()))) ||
                    /* contains no text nodes */
                    PFty_subtype (TY(LL(p)),
                                  PFty_star (
                                      PFty_choice (
                                          PFty_xs_anyElement (),
                                          PFty_choice (
                                              PFty_xs_anyAttribute (),
                                              PFty_choice (
                                                  PFty_doc (PFty_xs_anyType ()),
                                                  PFty_choice (
                                                      PFty_comm (),
                                                      PFty_pi (NULL)))))))) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
                /* Special rewrite: Push down the #pf:merge-adjacent-text-nodes
                   function if its input is a sequence where at least one
                   argument does not contain text nodes. */
                else if (LL(p)->kind == c_seq) {
                    if (!PFty_subtype (PFty_opt (PFty_text ()),
                                       TY(LLL(p)))) {
                        PFfun_t *pf_matn
                            = function (
                                  PFqname (
                                      PFns_pf,
                                      "merge-adjacent-text-nodes"));
                        
                        /* push #pf:matn into right sequence constructor input */
                        *p = *seq (LLL(p), APPLY (pf_matn, LLR(p)));
                        PFty_check (p);

                        rewritten = true;

                        /*
                         * Re-label entire subtree. Type-checking may have
                         * modified all the state labels in the subtree, so
                         * we have to restore them.
                         */
                        PFcoreopt_label (p);
                    } else if (!PFty_subtype (PFty_opt (PFty_text ()),
                                              TY(LLR(p)))) {
                        PFfun_t *pf_matn
                            = function (
                                  PFqname (
                                      PFns_pf,
                                      "merge-adjacent-text-nodes"));
                        
                        /* push #pf:matn into left sequence constructor input */
                        *p = *seq (APPLY (pf_matn, LLL(p)), LLR(p));
                        PFty_check (p);

                        rewritten = true;

                        /*
                         * Re-label entire subtree. Type-checking may have
                         * modified all the state labels in the subtree, so
                         * we have to restore them.
                         */
                        PFcoreopt_label (p);
                    }
                }
            }
            break;

        /* CoreExpr:           apply (arg (CoreExpr, arg (CoreExpr, nil))) */
        case 26:
            /*
             * fn:concat does not need to append an empty string
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "concat"))) {
                if (LRL(p)->kind == c_lit_str && !strcmp (LRL(p)->sem.str,"")) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }

            /*
             * fn:string-join() applied to an empty sequence
             * returns an empty string and applied to a singleton
             * sequence returns the singleton
             */
            if (! PFqname_eq (p->sem.fun->qname,
                              PFqname (PFns_fn, "string-join"))) {
                if (PFty_subtype (TY(LL(p)), PFty_empty ())) {
                    *p = *str ("");
                    TY(p) = PFty_xs_string ();

                    /* assign new node a state label */
                    relabel (p, kids);
                    rewritten = true;
                    break;
                }
                else if (PFty_subtype (TY(LL(p)), PFty_xs_string ())) {
                    *p = *LL(p);
                    rewritten = true;
                    break;
                }
            }
            break;

        /* SequenceTypeCast:   seqcast (SequenceType, CoreExpr) */
        /* CoreExpr:           cast (SequenceType, CoreExpr) */
        case 27:
            if (PFty_subtype (TY(L(p)), TY(R(p))) &&
                PFty_subtype (TY(R(p)), TY(L(p)))) {
                *p = *R(p);
                rewritten = true;
                break;
            } else if (PFty_subtype (TY(L(p)),
                                     PFty_opt (PFty_xs_string ())) &&
                       (R(p)->kind == c_seqcast || R(p)->kind == c_cast) &&
                       PFty_subtype (TY(RL(p)), 
                                     PFty_opt (PFty_untypedAtomic ())) &&
                       PFty_subtype (TY(RR(p)), PFty_xs_string ())) {
                /* remove two adjacent cast operators that cast from string
                   to untypedAtomic and back to string */
                *p = *RR(p);
                rewritten = true;
                break;                    
            } 
            break;
            
        /* Atom:                var */
        case 28:
            {
                /*
                 * See the comment in the declaration of var_env and
                 * the rule that processes let-bindings to understand
                 * what's going on here.
                 */
                unsigned short h = hash (p->sem.var);

                /*
                 * Look up this variable in the variable replacement
                 * environment.  If we find it there, do the replacement.
                 */
                for (unsigned int i = 0; i < PFarray_last (var_env[h]); i++)
                    if (((bind_t *) PFarray_at (var_env[h], i))->var
                            == p->sem.var) {
                        *p = *((bind_t *) PFarray_at (var_env[h], i))->atom;
                        rewritten = true;
                        break;
                    }
            }
            break;

        /* CoreExpr:           LocationSteps */
        case 29:
            /* remove bogus steps starting from attribute nodes */
            assert (p->kind == c_locsteps);
            if (L(p)->kind != c_parent &&
                PFty_subtype (TY(R(p)), PFty_star (PFty_xs_anyAttribute ()))) {
                *p = *empty ();
                TY(p) = PFty_empty ();
                rewritten = true;
                break;
            }
            break;

        default:
            break;
    }

    return rewritten;
}

/*
 * Re-label a match pattern.
 *
 * Start with node @a p and relabel the subtree below. However, stop
 * if @a p is one of the pattern leaves, passed as the argument @a kids.
 */
static void 
relabel (PFcnode_t *p,  PFcnode_t **kids)
{
    unsigned int i;

    for (i = 0; i < MAX_KIDS; i++) {
        if (kids[i] && p == kids[i])
            return;
    }

    /* Relabel p's children. */
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFcoreopt_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        relabel (L(p), kids);
        STATE_LABEL(p) = PFcoreopt_state (OP_LABEL(p),
                                          STATE_LABEL(L(p)),
                                          0);
    }
    else if (!L(p) && R(p)) {
        relabel (R(p), kids);
        STATE_LABEL(p) = PFcoreopt_state (OP_LABEL(p),
                                          STATE_LABEL(R(p)),
                                          0);
    }
    else {
        relabel (L(p), kids);
        relabel (R(p), kids);
        STATE_LABEL(p) = PFcoreopt_state (OP_LABEL(p),
                                          STATE_LABEL(L(p)),
                                          STATE_LABEL(R(p)));
    }

}

/* Collect all let (and position) bound variables and additionally
   store the number of references in the same nesting depth. If the
   variables are referenced in a nested scope their counter is set to
   -1 to indicate that the may not be rewritten. */
static void
collect_var_usage (PFcnode_t *c, char base, PFcnode_t *parent, int child)
{
    switch (c->kind) {
        case c_var:
            /*
             * Look up the top-most variable in the variable environment
             * with a matching name and mark it as used.
             */
            for (unsigned int i = 0; i < PFarray_last (unused_var_env); i++)
                if (((bind_t *) PFarray_at (unused_var_env, i))->var
                        == c->sem.var) {
                    /* check if the variable was bound in the same scope */
                    if (base != c->sem.var->base)
                        c->sem.var->used = -1;
                    else if (c->sem.var->used >= 0)
                        c->sem.var->used++; 
                    
                    if (c->sem.var->used == 1)
                        /* add variable to the variable reference environment */
                        *((bind_t *) PFarray_add (used_var_env))
                            = (bind_t) { .var = c->sem.var,
                                         .atom = parent,
                                         .child = child };
                    break;
                }
            break;
        
        case c_flwr:
        {
            char old_base = base;
            collect_var_usage (L(c), base, c, 0);
            collect_var_usage (R(c), base, c, 1);
            /* reset all new scopes introduced by a for loop */
            base = old_base;
        } break;
        
        case c_let:
            assert (L(c)->kind == c_letbind);
            
            collect_var_usage (LR(c), base, L(c), 1);
            
            /* add variable to the environment */
            *((bind_t *) PFarray_add (unused_var_env))
                = (bind_t) { .var = LL(c)->sem.var,
                             .atom = parent,
                             .child = child };
            /* reset reference counter */
            LL(c)->sem.var->used = 0;
            /* record the current scope */
            LL(c)->sem.var->base = base;

            collect_var_usage (R(c), base, c, 1);
            break;
            
        case c_for:
            assert (L(c)->kind == c_forbind &&
                    LL(c)->kind == c_forvars &&
                    LLL(c)->kind == c_var);
            
            collect_var_usage (LR(c), base, L(c), 1);
            
            /* a for loop increases the nesting depth */
            base++;

            if (LLR(c)->kind == c_var) {
                /* add variable to the environment */
                *((bind_t *) PFarray_add (unused_var_env))
                    = (bind_t) { .var = LLR(c)->sem.var,
                                 .atom = parent,
                                 .child = child };
                /* reset reference counter */
                LLR(c)->sem.var->used = 0;
                /* record the current scope */
                LLR(c)->sem.var->base = base;
            }
            
            collect_var_usage (R(c), base, c, 1);
            break;
            
        case c_main:
            /* first collect global variables before
               analyzing user-defined functions */
            collect_var_usage (R(c), base, c, 1);
            collect_var_usage (L(c), base, c, 0);
            break;
            
        case c_recursion:
            /* ignore recursion variable */
            collect_var_usage (R(c), base, c, 1);
            break;
            
        case c_param: 
            /* ignore used-defined function variables */
            collect_var_usage (L(c), base, c, 0);
            break;
            
        default:
            for (unsigned int i = 0; i < PFCNODE_MAXCHILD && c->child[i]; i++)
                collect_var_usage (c->child[i], base, c, i);
    }
}

/**
 * Optimize Core tree, with static type information available.
 *
 * @param r root of the XQuery Core tree
 * @return the optimized XQuery Core tree
 */
PFcnode_t *
PFcoreopt (PFcnode_t *r)
{
    /* ensure that we at least once remove unused variables */
    bool unused_var = true;

    assert (r);

    /* set up variable replacement environment */
    for (unsigned short i = 0; i < HASH_BUCKETS; i++)
        var_env[i] = PFarray (sizeof (bind_t));

    /* set up a variable environment to record unused variables */
    unused_var_env = PFarray (sizeof (bind_t)),
    /* set up a variable environment to record variable references */
    used_var_env = PFarray (sizeof (bind_t)),

    /* label the Core tree bottom up */
    PFcoreopt_label (r);

    /* invoke rewriting (reduce) and rewrite as long as something changes */
    while (reduce (r, 1) || unused_var) {
        PFvar_t *var;
        PFcnode_t *p, *n, *up;
        int c, uc;
        
        /* clean up variable environment */
        for (unsigned short i = 0; i < HASH_BUCKETS; i++)
            PFarray_last (var_env[i]) = 0;
        
        /* clean up unused and single variable environment */
        PFarray_last (unused_var_env) = 0;
        PFarray_last (used_var_env) = 0;
    
        /* make sure that we stop if we do not remove unused variables */
        unused_var = false;
        
        /* collect the variable usage information */ 
        collect_var_usage (r, 0, NULL, -1);

        /* remove all unused variables and expand variables 
           that are referenced only once in the same nesting depth*/
        for (unsigned int i = PFarray_last (unused_var_env); i > 0; i--) {
            var = ((bind_t *) PFarray_at (unused_var_env, i-1))->var;
            p = ((bind_t *) PFarray_at (unused_var_env, i-1))->atom;
            c = ((bind_t *) PFarray_at (unused_var_env, i-1))->child;

            /* make sure that we only remove bindings if they
               are still referenced */
            if (!p->child[c]) continue;
            
            n = p->child[c];
            if (!var->used) {
                if (n->kind == c_let) {
                    p->child[c] = R(n);
                    
                    /* mark n as inaccessable */
                    L(n) = NULL;
                    R(n) = NULL;

                    unused_var = true;
                } else if (n->kind == c_for) {
                    LLR(n) = nil ();
                    unused_var = true;
                }
            } else if (var->used == 1 && n->kind == c_let)
                for (unsigned int j = 0; j < PFarray_last (used_var_env); j++)
                    if (var == ((bind_t *) PFarray_at (used_var_env, j))->var) {
                        up = ((bind_t *) PFarray_at (used_var_env, j))->atom;
                        uc = ((bind_t *) PFarray_at (used_var_env, j))->child;
                        /* make sure that we only replace variables that
                           are still referenced */
                        if (up->child[uc]) {
                            /* replace variable by its corresponding
                               Core expression... */
                            up->child[uc] = LR(n);

                            /* ... and remove the variable binding */
                            p->child[c] = R(n);
                            
                            /* mark L(n) as inaccessable */
                            LL(n) = NULL;
                            LR(n) = NULL;

                            /* mark n as inaccessable */
                            L(n) = NULL;
                            R(n) = NULL;

                            unused_var = true;
                        }
                        /* for performance reasons remove the binding
                           from the environment */
                        *((bind_t *) PFarray_at (used_var_env, j))
                            = *((bind_t *) PFarray_top (used_var_env));
                        PFarray_del (used_var_env);
                        j--;
                        break;
                    }
        }
        
        if (unused_var)
            /* label the Core tree bottom up */
            PFcoreopt_label (r);
    }

    return r;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
