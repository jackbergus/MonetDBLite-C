%{

/*
 * Rewrite/Optimize MIL algebra expression tree/graph.
 *
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2005 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */


#include "pathfinder.h"
#include "oops.h"
#include "mem.h"
#include "milalgebra.h"
#include "mil.h"

#include <stdio.h>
#include <assert.h>

/*
 * Accessors for the burg matcher
 */
typedef struct PFma_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Prog

/*
 * Node indentifiers. Keep these properly aligned with the
 * node kinds in include/milalgebra.h!
 */
%term lit_oid    =  1
%term lit_int    =  2
%term lit_dbl    =  3
%term lit_str    =  4
%term lit_bit    =  5
%term new        =  6
%term insert     =  7
%term bun        =  8
%term seqbase    =  9
%term project    = 10
%term reverse    = 11
%term sort       = 12
%term ctrefine   = 13
%term join       = 14
%term leftjoin   = 15
%term cross      = 16
%term mirror     = 17
%term kunique    = 18
%term mark_grp   = 19
%term mark       = 20
%term count      = 21
%term append     = 22
%term oid        = 23
%term moid       = 24
%term mint       = 25
%term mstr       = 26
%term mdbl       = 27
%term mbit       = 28
%term madd       = 29
%term msub       = 30
%term mmult      = 31
%term mdiv       = 32
%term serialize  = 33
%term ser_args   = 34

%%

Prog: serialize (BatExpr, ser_args (BatExpr, ser_args (BatExpr, ser_args (BatExpr, ser_args (BatExpr, ser_args (BatExpr, BatExpr)))))) = 1 (10);

BatExpr:  new                                           =  2 (10);
BatExpr:  insert (BatExpr, bun (AtomExpr, AtomExpr))    =  3 (10);
BatExpr:  seqbase (BatExpr, AtomExpr)                   =  4 (10);
BatExpr:  reverse (BatExpr)                             =  5 (10);
BatExpr:  mark (BatExpr, AtomExpr)                      =  6 (10);
BatExpr:  sort (BatExpr)                                =  7 (10);
BatExpr:  mark_grp (BatExpr, BatExpr)                   =  8 (10);
BatExpr:  project (BatExpr, AtomExpr)                   =  9 (10);
BatExpr:  kunique (BatExpr)                             = 10 (10);
BatExpr:  leftjoin (BatExpr, BatExpr)                   = 11 (10);
BatExpr:  cross (BatExpr, BatExpr)                      = 12 (10);
BatExpr:  mirror (BatExpr)                              = 13 (10);
BatExpr:  ctrefine (BatExpr, BatExpr)                   = 14 (10);
BatExpr:  join (BatExpr, BatExpr)                       = 15 (10);
BatExpr:  append (BatExpr, BatExpr)                     = 16 (10);

BatExpr:  moid (BatExpr)                                = 17 (10);
BatExpr:  mint (BatExpr)                                = 18 (10);
BatExpr:  mstr (BatExpr)                                = 19 (10);
BatExpr:  mdbl (BatExpr)                                = 20 (10);
BatExpr:  mbit (BatExpr)                                = 21 (10);

BatExpr:  madd (BatExpr, AtomExpr)                      = 22 (10);
BatExpr:  madd (AtomExpr, BatExpr)                      = 23 (10);
BatExpr:  madd (BatExpr, BatExpr)                       = 24 (10);
BatExpr:  msub (BatExpr, AtomExpr)                      = 25 (10);
BatExpr:  msub (AtomExpr, BatExpr)                      = 26 (10);
BatExpr:  msub (BatExpr, BatExpr)                       = 27 (10);
BatExpr:  mmult (BatExpr, AtomExpr)                     = 28 (10);
BatExpr:  mmult (AtomExpr, BatExpr)                     = 29 (10);
BatExpr:  mmult (BatExpr, BatExpr)                      = 30 (10);
BatExpr:  mdiv (BatExpr, AtomExpr)                      = 31 (10);
BatExpr:  mdiv (AtomExpr, BatExpr)                      = 32 (10);
BatExpr:  mdiv (BatExpr, BatExpr)                       = 33 (10);

AtomExpr: Literal                                       = 100 (10);
AtomExpr: oid (AtomExpr)                                = 101 (10);
AtomExpr: count (BatExpr)                               = 102 (10);

Literal:  lit_oid                                       = 201 (10);
Literal:  lit_int                                       = 202 (10);
Literal:  lit_str                                       = 203 (10);
Literal:  lit_dbl                                       = 204 (10);
Literal:  lit_bit                                       = 205 (10);

BatExpr:  reverse (reverse (BatExpr))                   = 300 (1);

%%

#include "milalgebra_mnemonic.h"

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFma_op_t *p, int goalnt)
{
    int        rule;      /* rule number that matches for this node */
    short     *nts;       /* target non-terminals for the leaf nodes of
                             the current rule */
    PFma_op_t *kids[10];  /* leaf nodes of this rule */

    /* determine rule that matches for this non-terminal */
    rule = PFma_opt_rule (STATE_LABEL (p), goalnt);

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFma_opt_nts[rule];
    PFma_opt_kids (p, rule, kids);

    /*
     * Recursively invoke rewriting.  This means bottom-up rewriting.
     */
    unsigned short i;
    for (i = 0; nts[i]; i++)
        reduce (kids[i], nts[i]);

    switch (rule) {

        /* Prog: serialize (...) */
        case 1:

        /* BatExpr:  new */
        case 2:

        /* BatExpr: insert (BatExpr, bun (AtomExpr, AtomExpr)) */
        case 3:

        /* BatExpr:  seqbase (BatExpr, AtomExpr) */
        case 4:

        /* BatExpr:  reverse (BatExpr) */
        case 5:

        /* BatExpr:  mark (BatExpr, AtomExpr) */
        case 6:

        /* BatExpr:  sort (BatExpr) */
        case 7:

        /* BatExpr: mark_grp (BatExpr, BatExpr) */
        case 8:

        /* BatExpr:  project (BatExpr, AtomExpr) */
        case 9:

        /* BatExpr:  kunique (BatExpr) */
        case 10:

        /* BatExpr:  leftjoin (BatExpr, BatExpr) */
        case 11:

        /* BatExpr:  cross (BatExpr, BatExpr) */
        case 12:

        /* BatExpr:  mirror (BatExpr) */
        case 13:

        /* BatExpr:  ctrefine (BatExpr, BatExpr) */
        case 14:

        /* BatExpr:  join (BatExpr, BatExpr) */
        case 15:

        /* BatExpr:  append (BatExpr, BatExpr) */
        case 16:

        /* BatExpr:  moid (BatExpr) */
        case 17:

        /* BatExpr:  mint (BatExpr) */
        case 18:

        /* BatExpr:  mstr (BatExpr) */
        case 19:

        /* BatExpr:  mdbl (BatExpr) */
        case 20:

        /* BatExpr:  mbit (BatExpr) */
        case 21:

        /* BatExpr:  madd (BatExpr, AtomExpr) */
        case 22:
        /* BatExpr:  madd (AtomExpr, BatExpr) */
        case 23:
        /* BatExpr:  madd (BatExpr, BatExpr) */
        case 24:

        /* BatExpr:  msub (BatExpr, AtomExpr) */
        case 25:
        /* BatExpr:  msub (AtomExpr, BatExpr) */
        case 26:
        /* BatExpr:  msub (BatExpr, BatExpr) */
        case 27:

        /* BatExpr:  mmult (BatExpr, AtomExpr) */
        case 28:
        /* BatExpr:  mmult (AtomExpr, BatExpr) */
        case 29:
        /* BatExpr:  mmult (BatExpr, BatExpr) */
        case 30:

        /* BatExpr:  mdiv (BatExpr, AtomExpr) */
        case 31:
        /* BatExpr:  mdiv (AtomExpr, BatExpr) */
        case 32:
        /* BatExpr:  mdiv (BatExpr, BatExpr) */
        case 33:

        /* AtomExpr: Literal */
        case 100:
            break;

        /* AtomExpr: oid (AtomExpr) */
        case 101:

        /* AtomExpr: count (AtomExpr) */
        case 102:

        /* Literal: lit_oid */
        case 201:

        /* Literal: lit_int */
        case 202:
            break;

        /* Literal: lit_str */
        case 203:
            break;

        /* Literal: lit_dbl */
        case 204:
            break;

        /* Literal: lit_bit */
        case 205:
            break;

        /* BatExpr: reverse (reverse (BatExpr)) */
        case 300:
            /* replace `reverse (reverse (p))' by `p' */
            *p = *LL(p);
            break;

        default:
            PFinfo (OOPS_NOTICE, "untranslated expression (rule %i)", rule);
            break;
    }

}


/**
 * Translate MIL algebra tree in a MIL program.
 */
PFma_op_t *
PFma_opt (PFma_op_t *n)
{
    assert (n);

    /* Attach Burg labels in a tree walk bottom-up */
    PFma_opt_label (n);

    /* Perform rewriting */
    reduce (n, 1);

    return n;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
