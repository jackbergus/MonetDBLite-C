/* -*- c-basic-offset:4; c-indentation-style:"k&r"; indent-tabs-mode:nil -*- */
%{

/*
 * Compile physical algebra tree into a MIL program.
 *
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Original Code has initially been developed by the Database &
 * Information Systems Group at the University of Konstanz, Germany and
 * is now maintained by the Database Systems Group at the Technische
 * Universitaet Muenchen, Germany.  Portions created by the University of
 * Konstanz and the Technische Universitaet Muenchen are Copyright (C)
 * 2000-2005 University of Konstanz and (C) 2005-2007 Technische
 * Universitaet Muenchen, respectively.  All Rights Reserved.
 *
 *
 * $Id$
 */


#include "pathfinder.h"

#include <assert.h>

#include "oops.h"
#include "mem.h"
#include "physical.h"
#include "alg_dag.h"
#include "properties.h"
#include "mil.h"

#include "subtyping.h"

#include <stdio.h>

/** mnemonic for a sort specification list */
#define sortby(...)     PFord_order_intro (__VA_ARGS__)

/*
 * Accessors for the burg matcher
 */
typedef struct PFpa_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/physical.h!
 */
%term serialize      =   1
%term lit_tbl        =   2
%term empty_tbl      =   3
%term attach         =   4
%term cross          =  10
%term leftjoin       =  11
%term eqjoin         =  14
%term semijoin       =  15
%term thetajoin      =  16
%term unq2_thetajoin =  17
%term unq1_thetajoin =  18
%term project        =  19
%term select         =  20
%term val_select     =  21
%term append_union   =  23
%term merge_union    =  24
%term intersect      =  25
%term difference     =  26
%term sort_distinct  =  27
%term std_sort       =  28
%term refine_sort    =  29
%term fun_1to1       =  30
%term eq             =  40
%term eq_atom        =  41
%term gt             =  42
%term gt_atom        =  43
%term bool_not       =  45
%term bool_and       =  46
%term bool_or        =  47
%term bool_and_atom  =  48
%term bool_or_atom   =  49
%term hash_count     =  55
%term avg            =  56
%term max_           =  57
%term min_           =  58
%term sum            =  59
%term number         =  60
%term type           =  63
%term type_assert    =  64
%term cast           =  65
%term llscj_anc      = 100
%term llscj_anc_self = 101
%term llscj_attr     = 102
%term llscj_child    = 103
%term llscj_desc     = 104
%term llscj_desc_self= 105
%term llscj_foll     = 106
%term llscj_foll_sibl= 107
%term llscj_parent   = 108
%term llscj_prec     = 109
%term llscj_prec_sibl= 110
%term doc_tbl        = 120
%term doc_access     = 121
%term twig           = 122
%term fcns           = 123
%term docnode        = 124
%term element        = 125
%term attribute      = 126
%term textnode       = 127
%term comment        = 128
%term processi       = 129
%term content        = 130
%term merge_adjacent = 131
%term roots          = 132
%term fragment       = 133
%term frag_union     = 134
%term empty_frag     = 135
%term cond_err       = 140
%term nil            = 141
%term trace          = 142
%term trace_msg      = 143
%term trace_map      = 144
%term rec_fix        = 145
%term rec_param      = 146
%term rec_arg        = 147
%term rec_base       = 148
%term rec_border     = 149
%term string_join    = 150

%%

Query:    serialize (FragList, Rel)                                =   1 (10);
Query:    serialize (FragList, empty_tbl)                          =   2 (10);

Rel:      lit_tbl                                                  =  10 (10);
Rel:      empty_tbl                                                =  11 (10);
Rel:      attach (Rel)                                             =  12 (10);
Rel:      cross (Rel, Rel)                                         =  13 (10);
Rel:      leftjoin (Rel, Rel)                                      =  14 (10);
Rel:      eqjoin (Rel, Rel)                                        =  15 (10);
Rel:      semijoin (Rel, Rel)                                      =  16 (10);
Rel:      thetajoin (Rel, Rel)                                     =  17 (10);
Rel:      unq2_thetajoin (Rel, Rel)                                =  18 (10);
Rel:      unq1_thetajoin (Rel, Rel)                                =  19 (10);
Rel:      project (Rel)                                            =  20 (10);
Rel:      select (Rel)                                             =  21 (10);
Rel:      val_select (Rel)                                         =  22 (10);
Rel:      append_union (Rel, Rel)                                  =  23 (10);
Rel:      append_union (hash_count (Rel),
                        attach (difference 
                                    (Rel, 
                                     project (hash_count (Rel))))) =  24 (40);
Rel:      merge_union (Rel, Rel)                                   =  25 (10);
Rel:      intersect (Rel, Rel)                                     =  26 (10);
Rel:      difference (Rel, Rel)                                    =  27 (10);
Rel:      sort_distinct (Rel)                                      =  30 (10);
Rel:      sort_distinct (std_sort (Rel))                           =  31 (10);
Rel:      sort_distinct (refine_sort (Rel))                        =  32 (10);
Rel:      std_sort (Rel)                                           =  33 (10);
Rel:      refine_sort (Rel)                                        =  34 (10);
Rel:      fun_1to1 (Rel)                                           =  40 (10);
Rel:      eq (Rel)                                                 =  50 (10);
Rel:      eq_atom (Rel)                                            =  51 (10);
Rel:      gt (Rel)                                                 =  52 (10);
Rel:      gt_atom (Rel)                                            =  53 (10);
Rel:      bool_not (Rel)                                           =  61 (10);
Rel:      bool_and (Rel)                                           =  62 (10);
Rel:      bool_or (Rel)                                            =  63 (10);
Rel:      bool_and_atom (Rel)                                      =  64 (10);
Rel:      bool_or_atom (Rel)                                       =  65 (10);
Rel:      hash_count (Rel)                                         =  66 (10);
Rel:      avg (Rel)                                                =  67 (10);
Rel:      max_ (Rel)                                               =  68 (10);
Rel:      min_ (Rel)                                               =  69 (10);
Rel:      sum (Rel)                                                =  70 (10);
Rel:      number (Rel)                                             =  73 (10);
Rel:      type (Rel)                                               =  74 (10);
Rel:      type_assert (Rel)                                        =  75 (10);
Rel:      cast (Rel)                                               =  76 (10);

Rel:      llscj_anc (FragList, Rel)                                =  80 (10);
Rel:      llscj_anc_self (FragList, Rel)                           =  81 (10);
Rel:      llscj_attr (FragList, Rel)                               =  82 (10);
Rel:      llscj_child (FragList, Rel)                              =  83 (10);
Rel:      llscj_desc (FragList, Rel)                               =  84 (10);
Rel:      llscj_desc_self (FragList, Rel)                          =  85 (10);
Rel:      llscj_foll (FragList, Rel)                               =  86 (10);
Rel:      llscj_foll_sibl (FragList, Rel)                          =  87 (10);
Rel:      llscj_parent (FragList, Rel)                             =  88 (10);
Rel:      llscj_prec (FragList, Rel)                               =  89 (10);
Rel:      llscj_prec_sibl (FragList, Rel)                          =  90 (10);

FragRel:  doc_tbl (Rel)                                            = 100 (10);
Rel:      doc_access (FragList, Rel)                               = 101 (10);
FragRel:  twig (Twig)                                              = 102 (10);
FragRel:  twig (attribute (Rel))                                   = 103 (10);
FragRel:  twig (textnode (Rel))                                    = 104 (10);
Fcns:     fcns (Twig, Fcns)                                        = 105 (10);
Fcns:     fcns (Twig, nil)                                         = 106 (10);
Twig:     docnode (Rel, fcns (nil, nil))                           = 107 (10);
Twig:     docnode (Rel, Fcns)                                      = 108 (10);
Twig:     element (Rel, fcns (nil, nil))                           = 109 (10);
Twig:     element (Rel, Fcns)                                      = 110 (10);
Twig:     attribute (Rel)                                          = 111 (10);
Twig:     textnode (Rel)                                           = 112 (10);
Twig:     comment (Rel)                                            = 113 (10);
Twig:     processi (Rel)                                           = 114 (10);
Twig:     content (FragList, Rel)                                  = 115 (10);
FragRel:  merge_adjacent (FragList, Rel)                           = 116 (10);

Rel:      roots (FragRel)                                          = 120 (10);
Frag:     fragment (FragRel)                                       = 121 (10);
FragList: frag_union (FragList, Frag)                              = 122 (10);
FragList: empty_frag                                               = 123 (10);

Rel:      cond_err (Rel, Rel)                                      = 130 (10);
Rel:      cond_err (Rel, empty_tbl)                                = 131 (10);
Rel:      trace (Rel, trace_msg (Rel, Map))                        = 135 (10);
Rel:      trace (Rel, trace_msg (Rel, nil))                        = 136 (10);
Map:      trace_map (Rel, Map)                                     = 137 (10);
Map:      trace_map (Rel, nil)                                     = 138 (10);

Rel:      rec_fix (Rec, Rel)                                       = 140 (10);
Rec:      rec_param (rec_arg (Rel, Rel), Rec)                      = 141 (10);
Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec)                = 142 (10);
Rec:      nil                                                      = 143 (10);
Rel:      rec_base                                                 = 144 (10);
Rel:      rec_border (Rel)                                         = 145 (10);

Rel:      string_join (Rel, Rel)                                   = 150 (10);

%%

#include "mil_mnemonic.h"

/**
 * We collect the MIL program during compilation here.
 */
static PFmil_t *milprog = NULL;

/**
 * Processing is done bottom-up. This is just the order in
 * which we want to print our code. So we keep the whole
 * MIL program in the variable #milprog, and append commands
 * as we go. Think of it as ``executing'' the commands
 * right away.
 */
#define execute(...) milprog = seq (milprog, __VA_ARGS__)

/**
 * Represents a MIL variable.
 *
 * The variable has a name (that is automatically generated).
 * The @a pins field keeps track of the number of references
 * to this variable.  A variable may not be destroyed before
 * @a pins drops to zero.
 */
struct mvar_t {
    PFmil_ident_t   name;
    unsigned int    pins;
};

/** short-hand for struct mvar_t */
typedef struct mvar_t mvar_t;

/**
 * Remember @em all variables that we deal with during the compiler
 * run in here.  We want to re-use variables as much as possible to
 * reduce the number of active variables in the MIL program.  This
 * should help MonetDB with its memory management.
 *
 * Each time we need a new variable, we try to re-use an old one
 * from here.  We thus search for a variable with pin count zero.
 * If we cannot find any, we create a new variable and append it to
 * the list.
 */
PFarray_t *mvars = NULL;

/**
 * Return a ``new'' trace id. This id is used to refer
 * to a certain trace relation.
 */
static unsigned int
new_trace_id (void)
{
    /* the trace_id corresponds to the oids
       in the trace containers */
    static unsigned int trace_id = 1;
    return trace_id++;
}

/**
 * The state information necessary to build a twig 
 * of multiple node constructors in one go.
 */
struct twig_state_t {
    unsigned int pre;          /* pre id in the twig tree */
    unsigned int parent;       /* pre id of the parent in the twig tree */
    unsigned int size;         /* static size value of a node */
    unsigned int level;        /* static level of a twig node */
    PFarray_t   *elem_vars;    /* ordered list of node constructor
                                  representations */
    PFarray_t   *attr_vars;    /* ordered list of attribute constructor
                                  representations */
    PFmil_t     *loop;         /* loop relation */
    bool         elem_content; /* information if a content operator
                                  with element nodes appears in the twig */
};

/** short-hand for struct twig_state_t */
typedef struct twig_state_t twig_state_t;

/** current twig state */
static twig_state_t *twig_state;

/**
 * Return a ``new'' valid variable.  Will try to re-use an old,
 * no longer needed, variable, if possible.  For this, the
 * function searches #mvars for a variable with @a pins = 0. If
 * no such variable can be found, a new one will be created and
 * appended to the list.  
 *
 * The new variable will be initialized with the pin count given
 * in @a pins.
 */
static mvar_t *
new_var (unsigned int pins)
{
    static unsigned int   varno = PF_MIL_RES_VAR_COUNT;
    mvar_t               *var   = NULL;

    assert (mvars);
    assert (varno < 10000);

    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        if ((var = (mvar_t *) PFarray_at (mvars, i))->pins == 0) {
            var->pins = pins;
            return var;
        }

    /* If we were not successful, create a new entry */
    var = (mvar_t *) PFarray_add (mvars);

    var->name = varno++;
    var->pins = pins;

    return var;
}

/**
 * Pin a variable (i.e., increment its pin count by @a count).
 */
static void
pin (mvar_t *v, unsigned int count)
{
    v->pins += count;
}

/**
 * Unpin a variable (i.e., decrement its pin count by @a count).
 * If the pin count reaches zero, automatically generates a MIL
 * statement that assigns @c unused to the variable, marking it
 * a candidate for MonetDB's garbage collection.
 */
static void
unpin (mvar_t *v, unsigned int count)
{
    if (v->pins < count) {
        PFinfo (OOPS_WARNING, "pin count below zero");
        v->pins = 0;
    } else
        v->pins -= count;
    if (!v->pins)
        execute (assgn (var (v->name), unused ()));
}


/**
 * Environment entry.  In each physical algebra tree node, we keep
 * an environment that maps an attribute/type combination to the
 * #mvar_t struct that holds the corresponding MIL variable.
 */
struct env_t {
    PFalg_att_t          att;
    PFalg_simple_type_t  ty;
    mvar_t              *mvar;
};
typedef struct env_t env_t;

/**
 * Create a new (empty) environment for #env_t entries.
 *
 * With each node in the physical algebra DAG, we keep such an
 * environment that maps an attribute/type combination onto the
 * #mvar_t item that implements it. (Think of this as the mapping
 * from attribute/type to the BAT that represents that combination.
 */
static PFarray_t *
new_env (void)
{
    return PFarray (sizeof (env_t));
}

/**
 * Add an item to environment.
 */
void
env_add (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty, mvar_t *v)
{
    assert (ty == aat_nat || ty == aat_int || ty == aat_str || ty == aat_dec
            || ty == aat_dbl || ty == aat_bln || ty == aat_qname 
            || ty == aat_uA || ty == aat_pre || ty == aat_attr
            || ty == aat_pfrag || ty == aat_afrag);

    *(env_t *) PFarray_add (env)
        = (env_t) { .att = att, .ty = ty, .mvar = v };
#ifndef NDEBUG
    execute ( comment ("    %s: %s(%s)", 
                       PFmil_var_str (v->name), 
                       PFatt_str (att), 
                       PFalg_simple_type_str (ty)));
#endif
}

/**
 * Return environment size.
 */
unsigned int
env_count (const PFarray_t *env)
{
    return PFarray_last (env);
}

/**
 * Return environment item at index @a i.
 */
env_t
env_at (const PFarray_t *env, unsigned int i)
{
    assert (i < PFarray_last (env));

    return *(env_t *) PFarray_at ((PFarray_t *) env, i);
}

/**
 * Worker for env_mvar ().  Yields NULL if the MIL variable could not be
 * found in the enviroment @a env (in specific cases, this is not an error).
 */ 
static mvar_t *
env_mvar_unsafe (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {

        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        if (entry.att == att && entry.ty == ty)
            return entry.mvar;
    }
    return NULL;
}

/**
 * Look up an entry in the environment @a env, given a combination
 * of attribute (@a att) and type (@a ty) as the search key.
 */
mvar_t *
env_mvar (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    mvar_t *mvar = env_mvar_unsafe (env, att, ty);
    if (mvar)
        return mvar;

#ifndef NDEBUG
    fprintf (stderr, "looking for att: %s, ty: 0x%X\n", PFatt_str (att), ty);
    fprintf (stderr, "environment looks like:\n");
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        fprintf (stderr, "  att: %s, type: 0x%X, mvar->name: %s\n",
                 PFatt_str (entry.att), entry.ty, 
                 PFmil_var_str (entry.mvar->name));
    }
#endif

    PFoops (OOPS_FATAL,
            "attribute '%s' with type '0x%X' not found in environment",
            PFatt_str (att), ty);
    /* we don't ever get here */
    return NULL;
}

PFmil_t *
VAR (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    return var (env_mvar (env, att, ty)->name);
}

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RLL(p) L(L(R(p)))
#define RLR(p) R(L(R(p)))
#define RLRL(p) L(R(L(R(p))))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))

#define MAX_KIDS 10

#define SEEN(p) ((p)->bit_dag)

enum axis_t {
      ax_anc
    , ax_anc_self
    , ax_child
    , ax_desc
    , ax_desc_self
    , ax_foll
    , ax_foll_sibl
    , ax_parent
    , ax_prec
    , ax_prec_sibl
};

static PFalg_simple_type_t type_of (PFpa_op_t *n, PFalg_att_t att);
static PFmil_t * literal (PFalg_atom_t atom);

/* helper to handle loop-lifted staircase join operator */
static void llscj (enum axis_t axis, const PFpa_op_t *p);
/* translate binary coparison operator (eq/gt) */
static void bin_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                      PFpa_op_t *p);
static void bin_comp_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                           PFpa_op_t *p);
/* translate binary Boolean operator (and/or) */
static void bin_bool (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                      PFpa_op_t *p);
static void bin_bool_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                           PFpa_op_t *p);
/* translate unary operators (Boolean not) */
static void unary_op (PFmil_t * (*op) (const PFmil_t *), PFpa_op_t *p);

/* Generic handling of aggregation functions (avg, max, min and sum). */
static void aggr_function (PFmil_t * (*op) (const PFmil_t *),
                           PFmil_t * (*gop) (const PFmil_t *),
                           PFpa_op_t *p);

/** MIL implementation types for algebra types */
static PFmil_type_t impl_types[] = {
      [aat_nat]   = mty_oid
    , [aat_int]   = mty_lng
    , [aat_str]   = mty_str
    , [aat_uA]    = mty_str
    , [aat_dec]   = mty_dbl
    , [aat_dbl]   = mty_dbl
    , [aat_bln]   = mty_bit
    , [aat_qname] = mty_oid
    , [aat_pre]   = mty_oid
    , [aat_attr]  = mty_oid
    , [aat_pfrag] = mty_oid
    , [aat_afrag] = mty_oid
};

/** implementation type for a given algebra type, as a MIL node */
#ifndef NDEBUG
#define implty(n) type (impl_types[n] \
                        ? impl_types[n] \
                        : (PFoops (OOPS_FATAL, "illegal type in implty()"), (PFmil_type_t)0))
#else
#define implty(n) type (impl_types[n])
#endif

/* forward declaration */
static void reduce (PFpa_op_t * p, int goalnt);

/**
 * Alternative reducer function. Introduces code that is invariant
 * to the recursion before the recursion body is translated.
 */
static void
reduce_border (PFpa_op_t * p, int goalnt, PFarray_t *border_vars)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */

    assert (p);

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* guard against too dep recursion */
    PFrecursion_fence();

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);
    
    switch (rule) {
        /* Rel:      rec_fix (Rec, Rel) */
        case 140:
            /* only follow the parameters */
            reduce_border (kids[0], nts[0], border_vars);
            break;
            
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
            /* only follow the seeds */
            reduce_border (kids[0], nts[0], border_vars);
            /* and the rest of the parameter list */
            reduce_border (kids[2], nts[2], border_vars);
            break;

        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
            /* follow the rest of the parameter list */
            reduce_border (kids[1], nts[1], border_vars);
            break;

        /* Rec:      nil */
        case 143:
            /* nothing to be done */
            break;
            
        /* Rel:      rec_border (Rel) */
        case 145:
            if (!p->env) {
                /* translate sub-DAG starting at the border */
                reduce (p, goalnt);
                assert (p->env);
                /* increase the pin count by one to avoid releasing the
                   variables before the end of the while loop and remember 
                   which variables to unpin afterwards */
                for (unsigned int i = 0; i < env_count (p->env); i++) {
                    pin (env_at (p->env, i).mvar, 1);
                    *(mvar_t **) PFarray_add (border_vars) 
                        = env_at (p->env, i).mvar;
                }
            }
            break;
            
        default:
            for (unsigned short i = 0; nts[i]; i++)
                reduce_border (kids[i], nts[i], border_vars);
    }
}

/**
 * Alternative reducer function. Copes with patterns that are
 * larger than the burg patterns (e.g., variable parameter lists
 * required for the recursion operator). It contains the
 * respective action code for some of the above burg patterns.
 */
static void
reduce1 (PFpa_op_t * p, int goalnt, PFarray_t *border_vars)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */

    assert (p);
    /* reduce1 should be called only once for each pattern */
    if (p->env)
        return;

    /* guard against too dep recursion */
    PFrecursion_fence();

    p->env = new_env ();
    
    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);
    
#ifndef NDEBUG
    execute (comment ("Begin rule (reduce1): \"%s\"", PFmilgen_string[rule]));
#endif

    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
            /* only generate MIL code for the seed */
            reduce (kids[0], nts[0]);
            
            /* relink the enviroment of arg to its base */
            L(p)->sem.rec_arg.base->env = p->env;
            
            /* Copy the result of the the seed into a new variable.
               This variable is pinned for each call of the base
               (base and paramter both refer to the same environment)
               and additionally for each parameter to avoid that the
               variable is overwritten during generation of the recursion. */
            for (unsigned int i = 0; i < env_count (LL(p)->env); i++) {
                mvar_t *tmp  = new_var (p->refctr + 
                                        L(p)->sem.rec_arg.base->refctr);

                /* copy variable */
                execute (
                    assgn (var (tmp->name),
                           var (env_at (LL(p)->env, i).mvar->name)));
                
                /* add the variable to the current environment
                   (and thus also to the base environment) */
                env_add (p->env,
                         env_at (LL(p)->env, i).att,
                         env_at (LL(p)->env, i).ty,
                         tmp);
                
                /* unpin the seed once -- the recursion now does not
                   reference it anymore */
                unpin (((env_t *) PFarray_at (kids[0]->env, i))->mvar, 1);
            }

            /* translate all the remaining seeds */
            reduce1 (kids[2], nts[2], border_vars);

            /* translate all expressions that are invariant to
               the recursion body */
            reduce_border (kids[1], nts[1], border_vars);
            break;

        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
            /* relink the enviroment of arg to its base */
            L(p)->sem.rec_arg.base->env = p->env;

            /* For each column and type in the empty table generate
               a new bat and assign it to the variables used by the
               recursion. */
            for (unsigned int col = 0; col < LL(p)->schema.count; col++) {
                if (!LL(p)->schema.items[col].type)
                    PFoops (OOPS_FATAL,
                            "empty sequence should never "
                            "occur in MIL generation.");

                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & LL(p)->schema.items[col].type) {
                        mvar_t *tmp  = new_var (p->refctr + 
                                                L(p)->sem.rec_arg.base->refctr);

                        /* assign an empty BAT to the new variable */
                        execute (
                            assgn (var (tmp->name),
                                   seqbase (new (type (mty_void), implty (t)),
                                            lit_oid (0))));
                        
                        /* add the variable to the current environment
                           (and thus also to the base environment) */
                        env_add (p->env,
                                 LL(p)->schema.items[col].name,
                                 t,
                                 tmp);
                    }
            }

            /* translate all the remaining seeds */
            reduce1 (kids[1], nts[1], border_vars);

            /* translate all expressions that are invariant to
               the recursion body */
            reduce_border (kids[0], nts[0], border_vars);
            break;

        /* Rec:      nil */
        case 143:
            /* no MIL code needed */
            break;
            
        default:
            PFoops (OOPS_FATAL,
                    "cannot cope with rule %d in "
                    "alternative reduce function",
                    rule);
    }

#ifndef NDEBUG
    execute (comment ("End rule (reduce1): \"%s\"", PFmilgen_string[rule]));
    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

}

/**
 * Alternative reducer function. Copes with patterns that are
 * larger than the burg patterns (e.g., variable parameter lists
 * required for the recursion operator). It contains the
 * respective action code for some of the above burg patterns.
 */
static void
reduce2 (PFpa_op_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    int           pos_body;       /* position of the recursion body in the
                                     list of kids */

    /* reduce2 should be only called after reduce1 */
    if (!p->env)
        PFoops (OOPS_FATAL,
                "cannot cope with function reduce2 "
                "as long as reduce1 was not called.");

    /* guard against too dep recursion */
    PFrecursion_fence();

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);
    
#ifndef NDEBUG
    execute (comment ("Begin rule (reduce2): \"%s\"", PFmilgen_string[rule]));
#endif

    pos_body = 0;
    
    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
            pos_body = 1; /* discard the seed */
        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
            /* only generate MIL code for the body */
            reduce (kids[pos_body], nts[pos_body]);
            /* translate all the remaining parts of the body */
            reduce2 (kids[pos_body + 1], nts[pos_body + 1]);
            
            /* ensure that we have a 1:1 mapping of the environments */
            assert (PFarray_last (p->env) == PFarray_last (LR(p)->env));
            
            /* Reassign the variables. Thus the initial seed relations
               are overwritten by the result of the recursion */
            for (unsigned int i = 0; i < PFarray_last (p->env); i++) {
                env_t entry = env_at (p->env, i);

                /* find the corresponding variable in res for the variable in p */
                mvar_t *tmp = env_mvar (LR(p)->env, entry.att, entry.ty);

                execute (
                    assgn (var (entry.mvar->name),
                           var (tmp->name)));
                   
                /* unpin the recursion once -- the recursion now does not
                   reference it anymore */
                unpin (tmp, 1);
            }
            break;

        /* Rec:      nil */
        case 143:
            /* no MIL code needed */
            break;
            
        default:
            PFoops (OOPS_FATAL,
                    "cannot cope with rule %d in "
                    "alternative reduce function",
                    rule);
    }

#ifndef NDEBUG
    execute (comment ("End rule (reduce2): \"%s\"", PFmilgen_string[rule]));
    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

}

/**
 * Alternative reducer function. Copes with patterns that are
 * larger than the burg patterns (e.g., variable parameter lists
 * required for the recursion operator). It contains the
 * respective action code for some of the above burg patterns.
 */
static void
reduce3 (PFpa_op_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    int           pos_list;       /* position of the param list in the
                                     list of kids */

    /* reduce3 should be only called after reduce1 */
    if (!p->env)
        PFoops (OOPS_FATAL,
                "cannot cope with function reduce3 "
                "as long as reduce1 was not called.");

    /* guard against too dep recursion */
    PFrecursion_fence();

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);
    
#ifndef NDEBUG
    execute (comment ("Begin rule (reduce3): \"%s\"", PFmilgen_string[rule]));
#endif

    pos_list = 1;
    
    switch (rule) {
        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
            pos_list = 2; /* discard the seed */
        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
            /* translate all the remaining parts of the list */
            reduce3 (kids[pos_list], nts[pos_list]);
            
            /* release the remaining pins that ensured that the
               recursion input arguments were not overwritten
               during the recursion. */
            for (unsigned int i = 0; i < PFarray_last (p->env); i++) {
                unpin (env_at (p->env, i).mvar, p->refctr);
            }
            break;

        /* Rec:      nil */
        case 143:
            /* no MIL code needed */
            break;
            
        default:
            PFoops (OOPS_FATAL,
                    "cannot cope with rule %d in "
                    "alternative reduce function",
                    rule);
    }

#ifndef NDEBUG
    execute (comment ("End rule (reduce3): \"%s\"", PFmilgen_string[rule]));
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

}

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFpa_op_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */

    if (p->env)
        return;

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* guard against too deep recursion */
    PFrecursion_fence();

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    switch (rule) {
        /* Query:    serialize (FragList, Rel) */
        case 1:
        /* Query:    serialize (FragList, empty_tbl) */
        case 2:
        /* FragRel:  twig (Twig) */
        case 102:
        /* Fcns:     fcns (Twig, Fcns) */
        case 105:
        /* Twig:     docnode (Rel, Fcns) */
        case 108:
        /* Twig:     element (Rel, Fcns) */
        case 110:
        /* Rel:      rec_fix (Rec, Rel) */
        case 140:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     * (ensure that the fragment information is translated after 
     *  the value part)
     */
    if (!topdown)
        for (unsigned short i = MAX_KIDS; i > 0; i--)
            if (kids[i - 1])
                reduce (kids[i - 1], nts[i - 1]);

    if (p->env)
        return;

    p->env = new_env ();

#ifndef NDEBUG
    execute (comment ("Begin rule: \"%s\"", PFmilgen_string[rule]));
#endif

    switch (rule) {

        /* Query:   serialize (FragList, Rel) */
        case 1:
        {
            mvar_t *intVAL, *dblVAL, *decVAL, *strVAL;
            mvar_t *item, *kind, *err, *time;
            PFalg_simple_type_t ty;
            bool sorted = false;
            PFalg_att_t pa_item = p->sem.serialize.item;
            PFmil_t *oldmilprog, *bodymilprog;

            /* save the current mil program */
            oldmilprog = milprog;
           
            /* create a new empty milprog */
            milprog = nop ();
           
            /*
            PFmil_t *args = NULL;
            */

            execute (
                assgn (var (PF_MIL_VAR_WS), new_ws ()));
            reduce (kids[1], nts[1]);
            reduce (kids[0], nts[0]);

            /* add timing information */
            time = new_var (1);
            execute (assgn (var (time->name), usec ()));
            
            /* Set up all the value containers for print_result().
             * (It is actually too much overhead to introduce the value
             * containers just for printing. But this way we can re-use
             * Jan F's print_result() and stay compatible with the
             * ``summer branch''.
             */

            intVAL = new_var (1);
            dblVAL = new_var (1);
            /*decVAL = new_var (1); as we currently have no
                                    decimal support we use doubles */
            decVAL = dblVAL;
            strVAL = new_var (1);
            item = new_var (1);
            kind = new_var (1);

            execute (
                assgn (var (intVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (mty_lng), type (mty_void)),
                                    true)),
                           lit_oid (0))),
                assgn (var (dblVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (mty_dbl), type (mty_void)),
                                    true)),
                           lit_oid (0))),
                /*
                assgn (var (decVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (mty_dbl), type (mty_void)),
                                true)),
                           lit_oid (0))),
                */
                assgn (var (strVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (mty_str), type (mty_void)),
                                    true)),
                           lit_oid (0))),
                assgn (var (item->name),
                       seqbase (new (type (mty_void), type (mty_oid)),
                                lit_oid(0))),
                assgn (var (kind->name),
                       seqbase (new (type (mty_void), type (mty_int)),
                                lit_oid(0)))
                );

            ty = type_of (R(p), pa_item);

            /* consider attribute results */
            if (ty & aat_anode) {
                if (ty == aat_anode) {
                    execute (
                        assgn (var (item->name),
                               VAR (R(p)->env, pa_item, aat_attr)),
                        assgn (var (kind->name),
                               set_kind (VAR (R(p)->env, pa_item, aat_afrag),
                                         var (PF_MIL_VAR_ATTR)))
                        );
                    sorted = true;
                }
                else {
                    assert (ty & aat_attr && ty & aat_afrag);
                    execute (
                        binsert (var (item->name),
                                 select2 (
                                     VAR (R(p)->env, pa_item, aat_attr),
                                     cast (type (mty_oid), nil ()),
                                     cast (type (mty_oid), nil ()))),
                        binsert (var (kind->name),
                                 select2 (
                                     set_kind (VAR (R(p)->env, 
                                                    pa_item,
                                                    aat_afrag),
                                               var (PF_MIL_VAR_ATTR)),
                                     cast (type (mty_int), nil ()),
                                     cast (type (mty_int), nil ())))
                        );
                }
            }

            /* consider node results */
            if (ty & aat_pnode) {
                if (ty == aat_pnode) {
                    execute (
                        assgn (var (item->name),
                               VAR (R(p)->env, pa_item, aat_pre)),
                        assgn (var (kind->name),
                               set_kind (VAR (R(p)->env, pa_item, aat_pfrag),
                                         var (PF_MIL_VAR_ELEM)))
                        );
                    sorted = true;
                }
                else {
                    assert (ty & aat_pre && ty & aat_pfrag);
                    execute (
                        binsert (var (item->name),
                                 select2 (
                                     VAR (R(p)->env, pa_item, aat_pre),
                                     cast (type (mty_oid), nil ()),
                                     cast (type (mty_oid), nil ()))),
                        binsert (var (kind->name),
                                 select2 (
                                     set_kind (VAR (R(p)->env, 
                                                    pa_item,
                                                    aat_pfrag),
                                               var (PF_MIL_VAR_ELEM)),
                                     cast (type (mty_int), nil ()),
                                     cast (type (mty_int), nil ())))
                        );
                }
            }

            /* consider str results */
            if (ty & aat_str) {
                execute (
                    bappend (var (strVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_str),
                                                  cast (type (mty_str), nil ()),
                                                  cast (type (mty_str), nil ()))
                                         )))));
                if (ty == aat_str) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_str),
                                      reverse (var (strVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_str),
                                     var (PF_MIL_VAR_STR)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_str),
                                  reverse (var (strVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_str),
                                              cast (type (mty_str), nil ()),
                                              cast (type (mty_str), nil ())),
                                     var (PF_MIL_VAR_STR)))
                    );
                }
            }

            /* consider untyped results */
            if (ty & aat_uA) {
                execute (
                    bappend (var (strVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_uA),
                                                  cast (type (mty_str), nil ()),
                                                  cast (type (mty_str), nil ()))
                                         )))));
                if (ty == aat_uA) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_uA),
                                      reverse (var (strVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_uA),
                                     var (PF_MIL_VAR_STR)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_uA),
                                  reverse (var (strVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_uA),
                                              cast (type (mty_str), nil ()),
                                              cast (type (mty_str), nil ())),
                                     var (PF_MIL_VAR_STR)))
                    );
                }
            }

            /* consider int results */
            if (ty & aat_int) {
                execute (
                    bappend (var (intVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_int),
                                                  cast (type (mty_lng), nil ()),
                                                  cast (type (mty_lng), nil ()))
                                         )))));
                if (ty == aat_int) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_int),
                                      reverse (var (intVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_int),
                                     var (PF_MIL_VAR_INT)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_int),
                                  reverse (var (intVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_int),
                                              cast (type (mty_lng), nil ()),
                                              cast (type (mty_lng), nil ())),
                                     var (PF_MIL_VAR_INT)))
                    );
                }
            }

            /* consider dbl results */
            if (ty & aat_dbl) {
                execute (
                    bappend (var (dblVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_dbl),
                                                  cast (type (mty_dbl), nil ()),
                                                  cast (type (mty_dbl), nil ()))
                                         )))));
                if (ty == aat_dbl) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_dbl),
                                      reverse (var (dblVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_dbl),
                                     var (PF_MIL_VAR_DBL)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_dbl),
                                  reverse (var (dblVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_dbl),
                                              cast (type (mty_dbl), nil ()),
                                              cast (type (mty_dbl), nil ())),
                                     var (PF_MIL_VAR_DBL)))
                    );
                }
            }

            /* consider dec results */
            if (ty & aat_dec) {
                execute (
                    bappend (var (decVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       pa_item,
                                                       aat_dec),
                                                  cast (type (mty_dbl), nil ()),
                                                  cast (type (mty_dbl), nil ()))
                                         )))));
                if (ty == aat_dec) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, pa_item, aat_dec),
                                      reverse (var (decVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_dec),
                                     var (PF_MIL_VAR_DEC)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, pa_item, aat_dec),
                                  reverse (var (decVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_dec),
                                              cast (type (mty_dbl), nil ()),
                                              cast (type (mty_dbl), nil ())),
                                     var (PF_MIL_VAR_DEC)))
                    );
                }
            }

            /* consider bit results */
            if (ty & aat_bln) {
                if (ty == aat_int) {
                    execute (
                        assgn (
                            var (item->name),
                            mcast (type (mty_oid),
                                   VAR (R(p)->env, pa_item, aat_bln))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, pa_item, aat_bln),
                                     var (PF_MIL_VAR_BOOL)))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            mcast (type (mty_oid),
                                   VAR (R(p)->env, pa_item, aat_bln))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, pa_item, aat_bln),
                                              cast (type (mty_bit), nil ()),
                                              cast (type (mty_bit), nil ())),
                                     var (PF_MIL_VAR_BOOL)))
                    );
                }
            }

            if (!sorted)
                execute (
                    assgn (var (item->name),
                           sort (var (item->name), DIR_ASC)),
                    assgn (var (kind->name),
                           leftjoin (mirror (var (item->name)),
                                     var (kind->name))));

            execute (
                assgn (var (item->name),
                       reverse (mark (reverse (var (item->name)),lit_oid (0)))),
                assgn (var (kind->name),
                       reverse (mark (reverse (var (kind->name)),lit_oid (0)))),

                serialize (
                    arg (lit_str ("xml"),
                        arg (var (PF_MIL_VAR_WS),
                            arg (var (item->name),
                                arg (var (kind->name),
                                    arg (var (intVAL->name),
                                        arg (var (dblVAL->name),
                                            arg (var (decVAL->name),
                                                 var (strVAL->name))))))))));

            /*
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                if (i)
                    args = arg (args,
                                var (env_at (R(p)->env, i).mvar->name));
                else
                    args = var (env_at (R(p)->env, i).mvar->name);
            }

            execute (print (args));
            */

            unpin (intVAL, 1);
            unpin (dblVAL, 1);
            /* unpin (decVAL, 1); as we currently have no
                                           decimal support we use doubles */
            unpin (strVAL, 1);
            unpin (item, 1);
            unpin (kind, 1);

            /* add timing information */
            execute (
                assgn (var (PF_MIL_VAR_TIME_PRINT),
                       sub (usec (),
                            var (time->name))));
            unpin (time, 1);

            /* output trace information if available */
            if (new_trace_id () != 1)
                execute (
                    trace (
                        arg (var (PF_MIL_VAR_WS),
                        arg (var (PF_MIL_VAR_TRACE_OUTER),
                        arg (var (PF_MIL_VAR_TRACE_INNER),
                        arg (var (PF_MIL_VAR_TRACE_ITER),
                        arg (var (PF_MIL_VAR_TRACE_MSG),
                        arg (var (PF_MIL_VAR_TRACE_ITEM),
                        arg (var (PF_MIL_VAR_TRACE_TYPE),
                             var (PF_MIL_VAR_TRACE_REL))))))))));
            
            /* make the old mil program the active one */
            bodymilprog = milprog;
            milprog = oldmilprog;
           
            err = new_var (1);

            execute (
                catch_ (var (err->name), bodymilprog),
                if_ (not (isnil (var (PF_MIL_VAR_WS))),
                     destroy_ws (var (PF_MIL_VAR_WS)),
                     nop ()),
                if_ (not (isnil (var (err->name))),
                     error (var (err->name)),
                     nop ()));
            
            unpin (err, 1);
        } break;

        /* Query:   serialize (FragList, empty_tbl) */
        case 2:
        {
            mvar_t *intVAL, *dblVAL, *decVAL, *strVAL;
            mvar_t *item, *kind, *err, *time;
            PFmil_t *oldmilprog, *bodymilprog;

            /* save the current mil program */
            oldmilprog = milprog;
           
            /* create a new empty milprog */
            milprog = nop ();
           
            reduce (kids[0], nts[0]);

            /* add timing information */
            time = new_var (1);
            execute (assgn (var (time->name), usec ()));
            
            /* Set up all the value containers for print_result().
             * (It is actually too much overhead to introduce the value
             * containers just for printing. But this way we can re-use
             * Jan F's print_result() and stay compatible with the
             * ``summer branch''.
             */

            intVAL = new_var (1);
            dblVAL = new_var (1);
            decVAL = new_var (1);
            strVAL = new_var (1);
            item = new_var (1);
            kind = new_var (1);

            execute (
                assgn (var (PF_MIL_VAR_WS), new_ws ()),
                assgn (
                    var (intVAL->name),
                    seqbase (new (type (mty_void), type (mty_lng)),
                             lit_oid (0))),
                assgn (
                    var (dblVAL->name),                
                    seqbase (new (type (mty_void), type (mty_dbl)),
                             lit_oid (0))),
                assgn (
                    var (decVAL->name),                
                    seqbase (new (type (mty_void), type (mty_dbl)),
                             lit_oid (0))),
                assgn (
                    var (strVAL->name),                
                    seqbase (new (type (mty_void), type (mty_str)),
                             lit_oid (0))),
                assgn (
                    var (item->name),
                    seqbase (new (type (mty_void), type (mty_oid)),
                             lit_oid (0))),
                assgn (
                    var (kind->name),
                    seqbase (new (type (mty_void), type (mty_int)),
                             lit_oid (0))),
                serialize (
                    arg (lit_str ("xml"),
                        arg (var (PF_MIL_VAR_WS),
                            arg (var (item->name),
                                arg (var (kind->name),
                                    arg (var (intVAL->name),
                                        arg (var (dblVAL->name),
                                            arg (var (decVAL->name),
                                                 var (strVAL->name))))))))));
            
            unpin (intVAL, 1);
            unpin (dblVAL, 1);
            unpin (decVAL, 1);
            unpin (strVAL, 1);
            unpin (item, 1);
            unpin (kind, 1);

            /* add timing information */
            execute (
                assgn (var (PF_MIL_VAR_TIME_PRINT),
                       sub (usec (),
                            var (time->name))));
            unpin (time, 1);

            /* make the old mil program the active one */
            bodymilprog = milprog;
            milprog = oldmilprog;
           
            err = new_var (1);

            execute (
                catch_ (var (err->name), bodymilprog),
                if_ (not (isnil (var (PF_MIL_VAR_WS))),
                     destroy_ws (var (PF_MIL_VAR_WS)),
                     nop ()),
                if_ (not (isnil (var (err->name))),
                     error (var (err->name)),
                     nop ()));

            unpin (err, 1);
        } break;

        /* Rel:      lit_tbl */
        case 10:

            /* iterate over table columns */
            for (unsigned int col = 0; col < p->schema.count; col++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & p->schema.items[col].type) {
                        /* special support for QNames */
                        if (t == aat_qname)
                        {
                            /* insert qnames into working set
                               and insert corresponding offsets
                               into result */
                            mvar_t *v = new_var (p->refctr);

                            env_add (p->env, p->schema.items[col].name, t, v);

                            execute (
                                assgn (
                                    var (v->name),
                                    seqbase (
                                        new (type (mty_void), implty (t)),
                                        lit_oid (0))));

                            for (unsigned int row = 0;
                                    row < p->sem.lit_tbl.count; row++)
                                execute (
                                    append (
                                        var (v->name),
                                   /* add_qname changes the working set 
                                      in 'var (PF_MIL_VAR_WS)' as side effect */
                                        add_qname (lit_str (
                                                       PFqname_prefix (
                                                           p->sem.lit_tbl
                                                                 .tuples[row]
                                                                 .atoms[col]
                                                                 .val.qname)),
                                                   lit_str (
                                                       PFqname_uri (
                                                           p->sem.lit_tbl
                                                                 .tuples[row]
                                                                 .atoms[col]
                                                                 .val.qname)),
                                                   lit_str (
                                                       PFqname_loc (
                                                           p->sem.lit_tbl
                                                                 .tuples[row]
                                                                 .atoms[col]
                                                                 .val.qname)),
                                                   var (PF_MIL_VAR_WS))));

                            execute (access (var (v->name), BAT_READ));
                        } else {
                            mvar_t *v = new_var (p->refctr);
                            env_add (p->env, p->schema.items[col].name, t, v);

                            execute (
                                assgn (
                                    var (v->name),
                                    seqbase (
                                        new (type (mty_void), implty (t)),
                                        lit_oid (0))));

                            for (unsigned int row = 0;
                                    row < p->sem.lit_tbl.count; row++)
                                execute (
                                    append (
                                        var (v->name),
                                        t == p->sem.lit_tbl.tuples[row]
                                                            .atoms[col].type
                                        ? literal (p->sem.lit_tbl.tuples[row]
                                                                  .atoms[col])
                                        : cast (implty (t), nil ())));

                            execute (access (var (v->name), BAT_READ));
                        }
                    }

            break;

        /* Rel:     empty_tbl */
        case 11:
            PFoops (OOPS_FATAL,
                    "empty sequence should never occur in MIL generation."
                    " (optimizations disabled?)");
            break;

        /* Rel:      attach (Rel) */
        case 12:
        {
            /* copy all the existing variables */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }

            /* now create the new column */
            mvar_t *v = new_var (p->refctr);
            env_add (p->env, p->sem.attach.attname,
                     p->sem.attach.value.type, v);

            execute (
                assgn (var (v->name),
                       project (var (env_at (p->env, 0).mvar->name),
                                literal (p->sem.attach.value))));

        } break;

        /* Rel:      cross (Rel, Rel) */
        case 13:
        {
            mvar_t *v  = new_var (1);
            mvar_t *v1 = new_var (1);
            mvar_t *v2 = new_var (1);

            if (!env_count (L(p)->env) || !env_count (R(p)->env))
                PFoops (OOPS_FATAL, "Cross does not cope with empty schemas");

            /* The cross product of two relations with cardinality 1
               requires no MIL code. */
            if (PFprop_card (L(p)->prop) == 1 &&
                PFprop_card (R(p)->prop) == 1) {
                /* copy all the existing variables */
                for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                    env_t entry = env_at (L(p)->env, i);

                    env_add (p->env, entry.att, entry.ty, entry.mvar);

                    pin (entry.mvar, p->refctr);
                }
                /* copy all the existing variables */
                for (unsigned int i = 0; i < PFarray_last (R(p)->env); i++) {

                    env_t entry = env_at (R(p)->env, i);

                    env_add (p->env, entry.att, entry.ty, entry.mvar);

                    pin (entry.mvar, p->refctr);
                }
                unpin (v, 1);
                unpin (v1, 1);
                unpin (v2, 1);
                break;
            }

            execute (
                assgn (var (v->name),
                       cross (
                           project (var (env_at (L(p)->env, 0).mvar->name),
                                    nil ()),
                           reverse (
                               project (var (env_at (R(p)->env, 0).mvar->name),
                                        nil ())))),
                assgn (var (v1->name),
                       reverse (mark (var (v->name), lit_oid (0)))),
                assgn (var (v2->name),
                       reverse (mark (reverse (var (v->name)), lit_oid (0)))));

            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                mvar_t *tmp  = new_var (p->refctr);
                /* expand variables */
                execute (
                    assgn (var (tmp->name),
                           leftjoin (var (v1->name),
                                     var (env_at (L(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (tmp->name),
                           reverse (mark (reverse (var (tmp->name)),
                                          lit_oid (0)))));
                
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         tmp);
            }
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                mvar_t *tmp  = new_var (p->refctr);
                /* expand variables */
                execute (
                    assgn (var (tmp->name),
                           leftjoin (var (v2->name),
                                     var (env_at (R(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (tmp->name),
                           reverse (mark (reverse (var (tmp->name)),
                                          lit_oid (0)))));
                
                env_add (p->env,
                         env_at (R(p)->env, i).att,
                         env_at (R(p)->env, i).ty,
                         tmp);
            }

            unpin (v, 1);
            unpin (v1, 1);
            unpin (v2, 1);
        }
            break;

        /* Rel:      leftjoin (Rel, Rel) */
        case 14:
        /* Rel:      eqjoin (Rel, Rel) */
        case 15:
        {
            /*
             * We actually cannot guarantee that MonetDB applies a
             * MergeJoin (tactical optimization may choose other
             * implementations). By using leftjoin(), however, we
             * can guarantee the result to be correctly ordered.
             */
            PFalg_simple_type_t lty = type_of (L(p), p->sem.eqjoin.att1);
            PFalg_simple_type_t rty = type_of (R(p), p->sem.eqjoin.att2);
            PFalg_simple_type_t t = 0;
            mvar_t *l = NULL;
            mvar_t *r = NULL;
            mvar_t *tmp1 = new_var (1);
            mvar_t *tmp[2] = { [0] = new_var (1), [1] = new_var (1) };

            assert (lty == rty);

            for (t = 1; t; t <<= 1) {
                if (t & lty && t & rty) {
                    l = env_mvar_unsafe (L(p)->env, p->sem.eqjoin.att1, t);
                    r = env_mvar_unsafe (R(p)->env, p->sem.eqjoin.att2, t);
                    break;
                }
            }

            if (t != lty || t != rty)
                PFoops (OOPS_FATAL, 
                        "multi-predicate joins are not supported yet");

            if (!l || !r)
                PFoops (OOPS_FATAL, "incompatible types in Join");

            execute (
                assgn (var (tmp1->name),
                       leftjoin (var (l->name), reverse (var (r->name)))),
                assgn (var (tmp[0]->name),
                       reverse (mark (var (tmp1->name), lit_oid (0)))),
                assgn (var (tmp[1]->name),
                       reverse (
                           mark (reverse (var (tmp1->name)), lit_oid (0)))));

            unpin (tmp1, 1);

            for (unsigned short c = 0; c < 2; c++) {
                for (unsigned int i = 0; i < env_count (p->child[c]->env); i++)
                {

                     mvar_t *v = new_var (p->refctr);

                     execute (
                          assgn (var (v->name),
                                 leftjoin (
                                      var (tmp[c]->name),
                                      var (env_at (p->child[c]->env,
                                                   i).mvar->name))),
                          /* because leftjoin does not know that we have 
                             exactly one match for each tuple in v,
                             we need to make the heads void ourselves */
                          assgn (var (v->name),
                                 reverse (mark (reverse (var (v->name)),
                                                lit_oid (0))))
                          );

                     env_add (p->env,
                              env_at (p->child[c]->env, i).att,
                              env_at (p->child[c]->env, i).ty,
                              v);
                }
            }

            unpin (tmp[0], 1);
            unpin (tmp[1], 1);

        } break;

        /* Rel:      semijoin (Rel, Rel) */
        case 16:
        {
            PFalg_simple_type_t lty = type_of (L(p), p->sem.eqjoin.att1);
            PFalg_simple_type_t rty = type_of (R(p), p->sem.eqjoin.att2);
            PFalg_simple_type_t t = 0;
            mvar_t *l = NULL;
            mvar_t *r = NULL;
            mvar_t *res = new_var (1);

            assert (lty == rty);

            for (t = 1; t; t <<= 1) {
                if (t & lty && t & rty) {
                    l = env_mvar_unsafe (L(p)->env, p->sem.eqjoin.att1, t);
                    r = env_mvar_unsafe (R(p)->env, p->sem.eqjoin.att2, t);
                    break;
                }
            }

            if (t != lty || t != rty)
                PFoops (OOPS_FATAL, 
                        "multi-predicate semijoins are not supported yet");

            if (!l || !r)
                PFoops (OOPS_FATAL, "incompatible types in semijoin");

            /* apply semijoin */
            execute (
                assgn (var (res->name),
                       kintersect (reverse (var (l->name)),
                                   reverse (var (r->name)))),
                assgn (var (res->name),
                       reverse (mark (reverse (var (res->name)),
                                      lit_oid (0)))));

            /* map all columns */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++)
            {

                 mvar_t *v = new_var (p->refctr);

                 execute (
                      assgn (var (v->name),
                             leftjoin (
                                  var (res->name),
                                  var (env_at (L(p)->env,
                                               i).mvar->name))),
                      /* because leftjoin does not know that we have 
                         exactly one match for each tuple in v,
                         we need to make the heads void ourselves */
                      assgn (var (v->name),
                             reverse (mark (reverse (var (v->name)),
                                            lit_oid (0))))
                      );

                 env_add (p->env,
                          env_at (L(p)->env, i).att,
                          env_at (L(p)->env, i).ty,
                          v);
            }

            unpin (res, 1);
        } break;

        /* Rel:      thetajoin (Rel, Rel) */
        case 17:
        {
            unsigned int shared_cols = 0;
            bool match_found;
            bool initialized = false;

            PFalg_simple_type_t ltype = 0;
            PFmil_t *args = NULL;
            mvar_t  *res = new_var (1);
            mvar_t  *lmap = new_var (1);
            mvar_t  *rmap = new_var (1);

            /* first try to match all equality predicates in one go 
               (using a special multi-column MIL intersect proc) */
            for (unsigned int i = 0; i < p->sem.thetajoin.count; i++)
                if (p->sem.thetajoin.pred[i].comp == alg_comp_eq) {
                    initialized = true;
                    match_found = false;
                    ltype = type_of (L(p), p->sem.thetajoin.pred[i].left);
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & ltype) {
                            mvar_t *l = env_mvar (
                                            L(p)->env,
                                            p->sem.thetajoin.pred[i].left,
                                            t);
                            mvar_t *r = env_mvar_unsafe (
                                            R(p)->env,
                                            p->sem.thetajoin.pred[i].right,
                                            t);

                            if (r) {
                                if (!shared_cols)
                                    args = arg (var (l->name), var (r->name));
                                else
                                    args = arg (args, arg (var (l->name), 
                                                           var (r->name)));
                                shared_cols++;
                                match_found = true;
                            }
                        }
                    if (!match_found) {
                        /* If one join argument has no match we
                           can return an empty result */
                        shared_cols = 0;
                        execute (assgn (var (res->name),
                                        seqbase (new (type (mty_void), 
                                                      type (mty_oid)),
                                                 lit_oid (0))));
                        break;
                    }
                }

            /* apply the multi-column equi-join */
            if (shared_cols) {
                execute (assgn (var (res->name), 
                                mc_intersect (args)),
                         assgn (var (lmap->name),
                                reverse (mark (var (res->name), lit_oid (0)))),
                         assgn (var (rmap->name),
                                reverse (mark (reverse (var (res->name)),
                                               lit_oid (0)))));
            }
            
            /* If there was no equality predicate apply a normal inequality
               thetajoin to the first predicate.
               For all remaining predicates (also the ones that appear in 
               combination with equi-join predicates we apply a selection
               (post) filter. */
            for (unsigned int i = 0; i < p->sem.thetajoin.count; i++)
                if (p->sem.thetajoin.pred[i].comp != alg_comp_eq) {
                    mvar_t *l, *r;
                    bool type_match = false;
                    
                    ltype = type_of (L(p), p->sem.thetajoin.pred[i].left);
                    assert (monomorphic (ltype));
                    
                    if (ltype & aat_node) {
                        /* FIXME */
                        assert (!(ltype & aat_anode) &&
                                "cope with attribute node inequality");

                        mvar_t *lpre, *rpre, *lfrag, *rfrag;
                        
                        l = new_var (1);
                        r = new_var (1);
                        
                        lpre = env_mvar (
                                   L(p)->env,
                                   p->sem.thetajoin.pred[i].left,
                                   aat_pre);
                        lfrag = env_mvar (
                                    L(p)->env,
                                    p->sem.thetajoin.pred[i].left,
                                    aat_pfrag);
                        
                        rpre = env_mvar_unsafe (
                                   R(p)->env,
                                   p->sem.thetajoin.pred[i].right,
                                   aat_pre);
                        rfrag = env_mvar_unsafe (
                                    R(p)->env,
                                    p->sem.thetajoin.pred[i].right,
                                    aat_pfrag);

                        if (rpre && rfrag) {
                            mvar_t *tmp_res = new_var (1);
                            execute (assgn (var (tmp_res->name),
                                            zip_nodes (
                                                var (lfrag->name),
                                                var (lpre->name),
                                                nil (),
                                                var (rfrag->name),
                                                var (rpre->name),
                                                nil ())),
                                     assgn (var (l->name),
                                            fetch (var (tmp_res->name),
                                                   lit_int (0))),
                                     assgn (var (r->name),
                                            fetch (var (tmp_res->name),
                                                   lit_int (1))));
                            unpin (tmp_res, 1);
                            type_match = true;
                        }
                    } else {
                        l = env_mvar (
                                L(p)->env,
                                p->sem.thetajoin.pred[i].left,
                                ltype);
                        r = env_mvar_unsafe (
                                R(p)->env,
                                p->sem.thetajoin.pred[i].right,
                                ltype);
                        if (r) type_match = true;
                    }

                    if (type_match) {
                        if (!initialized) {
                            /* As there was no equi-join condition and 
                               this is the first inequality predicate
                               we evaluate a thetajoin */

                            PFmil_t *comp;
                            /* find the correct comparison */
                            switch (p->sem.thetajoin.pred[i].comp) {
                                case alg_comp_eq:
                                    comp = var (PF_MIL_VAR_EQ); break; 
                                case alg_comp_gt:
                                    comp = var (PF_MIL_VAR_GT); break; 
                                case alg_comp_ge:
                                    comp = var (PF_MIL_VAR_GE); break; 
                                case alg_comp_lt:
                                    comp = var (PF_MIL_VAR_LT); break; 
                                case alg_comp_le:
                                    comp = var (PF_MIL_VAR_LE); break; 
                                default:
                                    PFoops (OOPS_FATAL, "incorrect comparison");
                            }

                            execute (assgn (var (res->name),
                                            tjoin (
                                                var (l->name),
                                                reverse (var (r->name)),
                                                comp,
                                                PFmil_mmult (
                                                    count (var (r->name)),
                                                    lit_lng (64)))),
                                     assgn (var (lmap->name),
                                            reverse (mark (var (res->name),
                                                           lit_oid (0)))),
                                     assgn (var (rmap->name),
                                            reverse (
                                                mark (reverse (var (res->name)),
                                                      lit_oid (0)))));
                        } else {
                            /* apply a (post) filter */
                            
                            PFmil_t * (*op) (const PFmil_t *, const PFmil_t *);
                            /* find the correct comparison */
                            switch (p->sem.thetajoin.pred[i].comp) {
                                case alg_comp_eq:
                                    op = PFmil_meq; break; 
                                case alg_comp_gt:
                                    op = PFmil_mgt; break; 
                                case alg_comp_ge:
                                    op = PFmil_mge; break; 
                                case alg_comp_lt:
                                    op = PFmil_mlt; break; 
                                case alg_comp_le:
                                    op = PFmil_mle; break; 
                                case alg_comp_ne:
                                    op = PFmil_mne; break; 
                                default:
                                    assert(0);
                                    op = NULL;
                            }

                            /* apply filter and update the mapping
                               relations lmap and rmap */
                            execute (assgn (var (res->name), 
                                            op (leftjoin (
                                                    var (lmap->name),
                                                    var (l->name)),
                                                leftjoin (
                                                    var (rmap->name),
                                                    var (r->name)))),
                                     assgn (var (res->name),
                                            reverse (
                                                mark (select_ (
                                                          var (res->name),
                                                          lit_bit (true)),
                                                      lit_oid (0)))),
                                     assgn (var (lmap->name),
                                            leftjoin (
                                                var (res->name),
                                                var (lmap->name))),
                                     assgn (var (rmap->name),
                                            leftjoin (
                                                var (res->name),
                                                var (rmap->name))));
                        }

                        initialized = true;
                    } else {
                        /* If one join argument has no match we
                           can return an empty result */
                        execute (assgn (var (lmap->name),
                                        seqbase (new (type (mty_void), 
                                                      type (mty_oid)),
                                                 lit_oid (0))),
                                 assgn (var (rmap->name),
                                        seqbase (new (type (mty_void), 
                                                      type (mty_oid)),
                                                 lit_oid (0))));
                        break;
                    }
                    if (ltype & aat_node) {
                        unpin (l, 1);
                        unpin (r, 1);
                    }
                }
            /* release temporary variable res */
            unpin (res, 1);

            /* map all matching tuples (of the left input relation) */
            for (unsigned int col = 0; col < env_count (L(p)->env); col++) {
                 mvar_t *a = new_var (p->refctr);

                 execute (
                      assgn (var (a->name),
                             leftjoin (
                                 var (lmap->name),
                                 var (env_at (L(p)->env, col).mvar->name))));
                      
                 env_add (p->env,
                          env_at (L(p)->env, col).att,
                          env_at (L(p)->env, col).ty,
                          a);
            }
            unpin (lmap, 1);

            /* map all matching tuples (of the right input relation) */
            for (unsigned int col = 0; col < env_count (R(p)->env); col++) {
                 mvar_t *a = new_var (p->refctr);

                 execute (
                      assgn (var (a->name),
                             leftjoin (
                                 var (rmap->name),
                                 var (env_at (R(p)->env, col).mvar->name))));
                      
                 env_add (p->env,
                          env_at (R(p)->env, col).att,
                          env_at (R(p)->env, col).ty,
                          a);
            }
            unpin (rmap, 1);
            
        } break;

        /* Rel:      unq2_thetajoin (Rel, Rel) */
        case 18:
        {
            PFalg_simple_type_t lty = type_of (L(p),
                                               p->sem.unq_thetajoin.left);
            PFalg_simple_type_t rty = type_of (R(p),
                                               p->sem.unq_thetajoin.right);
            PFalg_simple_type_t t = 0;
            mvar_t *l = NULL;
            mvar_t *r = NULL;
            mvar_t *ldist = NULL;
            mvar_t *rdist = NULL;
            mvar_t *res = new_var (1);
            mvar_t *left, *right;
            PFmil_t *comp;

            assert (lty == rty);
            assert (type_of (L(p), p->sem.unq_thetajoin.ldist) == aat_nat);
            assert (type_of (R(p), p->sem.unq_thetajoin.rdist) == aat_nat);

            /* find the variable names for the distinct attributes */
            ldist = env_mvar_unsafe (L(p)->env,
                                     p->sem.unq_thetajoin.ldist, aat_nat);
            rdist = env_mvar_unsafe (R(p)->env,
                                     p->sem.unq_thetajoin.rdist, aat_nat);

            /* find the variable names for the join attributes */
            for (t = 1; t; t <<= 1)
                if (t & lty && t & rty) {
                    l = env_mvar_unsafe (L(p)->env,
                                         p->sem.unq_thetajoin.left, t);
                    r = env_mvar_unsafe (R(p)->env,
                                         p->sem.unq_thetajoin.right, t);
                    break;
                }
            
            /* check consistency */
            if (t != lty || t != rty || !ldist || !rdist)
                PFoops (OOPS_FATAL, 
                        "multi-predicate thetajoins (with duplicate remvoval)"
                        " are not supported");

            if (!l || !r)
                PFoops (OOPS_FATAL, "incompatible types in thetajoin");

            /* find the correct comparison */
            switch (p->sem.unq_thetajoin.comp) {
                case alg_comp_eq: comp = var (PF_MIL_VAR_EQ); break; 
                case alg_comp_gt: comp = var (PF_MIL_VAR_GT); break; 
                case alg_comp_ge: comp = var (PF_MIL_VAR_GE); break; 
                case alg_comp_lt: comp = var (PF_MIL_VAR_LT); break; 
                case alg_comp_le: comp = var (PF_MIL_VAR_LE); break; 
                default:
                    PFoops (OOPS_FATAL, "incorrect comparison");
            }

            /* add the two result columns to the environment */
            left = new_var (p->refctr);
            right = new_var (p->refctr);
            env_add (p->env, p->sem.unq_thetajoin.ldist, aat_nat, left);
            env_add (p->env, p->sem.unq_thetajoin.rdist, aat_nat, right);

            /* apply the duplicate removing thetajoin */
            execute (
                assgn (var (res->name),
                       unq2_tjoin (leftjoin (reverse (var (ldist->name)),
                                             var (l->name)),
                                   leftjoin (reverse (var (rdist->name)),
                                             var (r->name)),
                                   comp)),
                assgn (var (left->name),
                       reverse (mark (var (res->name),
                                      lit_oid (0)))),
                assgn (var (left->name),
                       assert_order (var (left->name))),
                assgn (var (right->name),
                       reverse (mark (reverse (var (res->name)),
                                      lit_oid (0)))));

            unpin (res, 1);
        } break;

        /* Rel:      unq1_thetajoin (Rel, Rel) */
        case 19:
        {
            PFalg_simple_type_t lty = type_of (L(p),
                                               p->sem.unq_thetajoin.left);
            PFalg_simple_type_t rty = type_of (R(p),
                                               p->sem.unq_thetajoin.right);
            PFalg_simple_type_t t = 0;
            mvar_t *l = NULL;
            mvar_t *r = NULL;
            mvar_t *ldist = NULL;
            mvar_t *rdist = NULL;
            mvar_t *res = new_var (p->refctr);
            PFmil_t *comp;

            assert (lty == rty);
            assert (type_of (L(p), p->sem.unq_thetajoin.ldist) == aat_nat);
            assert (type_of (R(p), p->sem.unq_thetajoin.rdist) == aat_nat);

            /* find the variable names for the distinct attributes */
            ldist = env_mvar_unsafe (L(p)->env,
                                     p->sem.unq_thetajoin.ldist, aat_nat);
            rdist = env_mvar_unsafe (R(p)->env,
                                     p->sem.unq_thetajoin.rdist, aat_nat);

            /* find the variable names for the join attributes */
            for (t = 1; t; t <<= 1)
                if (t & lty && t & rty) {
                    l = env_mvar_unsafe (L(p)->env,
                                         p->sem.unq_thetajoin.left, t);
                    r = env_mvar_unsafe (R(p)->env,
                                         p->sem.unq_thetajoin.right, t);
                    break;
                }
            
            /* check consistency */
            if (t != lty || t != rty || !ldist || !rdist)
                PFoops (OOPS_FATAL, 
                        "multi-predicate thetajoins (with duplicate remvoval)"
                        " are not supported");

            if (!l || !r)
                PFoops (OOPS_FATAL, "incompatible types in thetajoin");

            /* find the correct comparison */
            switch (p->sem.unq_thetajoin.comp) {
                case alg_comp_eq: comp = var (PF_MIL_VAR_EQ); break; 
                case alg_comp_gt: comp = var (PF_MIL_VAR_GT); break; 
                case alg_comp_ge: comp = var (PF_MIL_VAR_GE); break; 
                case alg_comp_lt: comp = var (PF_MIL_VAR_LT); break; 
                case alg_comp_le: comp = var (PF_MIL_VAR_LE); break; 
                default:
                    PFoops (OOPS_FATAL, "incorrect comparison");
            }

            /* add the two result columns to the environment */
            env_add (p->env, p->sem.unq_thetajoin.ldist, aat_nat, res);

            /* apply the duplicate removing thetajoin */
            execute (
                assgn (var (res->name),
                       reverse(
                           mark (
                               unq1_tjoin (
                                   leftjoin (reverse (var (ldist->name)),
                                             var (l->name)),
                                   leftjoin (reverse (var (rdist->name)),
                                             var (r->name)),
                                   var (ldist->name),
                                   var (rdist->name),
                                   comp),
                               lit_oid (0)))));
        } break;

        /* Rel:      project (Rel) */
        case 20:
            /*
             * Algebra projection is a no-op. We only fill the
             * environment in node p appropriately.
             */
            for (unsigned int i = 0; i < p->sem.proj.count; i++)
                 for (PFalg_simple_type_t t = 1; t; t <<= 1)
                      if (t & type_of (L(p), p->sem.proj.items[i].old)) {

                           mvar_t *v = env_mvar (L(p)->env,
                                                 p->sem.proj.items[i].old,
                                                 t);

                           env_add (p->env, p->sem.proj.items[i].new, t, v);
                           pin (v, p->refctr);

                      }

            break;

        /* Rel:      select (Rel) */
        case 21:
        {
            mvar_t *v = new_var (1);

            /*
             * For the predicate column c do
             *
             *  v := c.select (true).mark (0@0).reverse ();
             */
            execute (
                assgn (
                    var (v->name),
                    reverse (
                        mark (
                            select_(VAR (L(p)->env, p->sem.select.att,aat_bln),
                                    lit_bit (true)),
                            lit_oid (0)))));

            /*
             * Then join any BAT in L(p)'s environment with v
             */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                mvar_t *w = new_var (p->refctr);

                execute (
                    assgn (var (w->name),
                           leftjoin (var (v->name),
                                     var (env_at (L(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (w->name),
                           reverse (mark (reverse (var (w->name)),
                                          lit_oid (0)))));

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         w);
            }

            /* release v */
            unpin (v, 1);

        } break;

        /* Rel:      val_select (Rel) */
        case 22:
        {
            mvar_t *v = new_var (1);

            assert (type_of (p, p->sem.attach.attname) ==
                    p->sem.attach.value.type);
            /*
             * For the predicate column c do
             *
             *  v := c.select (atom).mark (0@0).reverse ();
             */
            execute (
                assgn (
                    var (v->name),
                    reverse (
                        mark (
                            uselect (VAR (L(p)->env,
                                          p->sem.attach.attname,
                                          type_of (p, p->sem.attach.attname)),
                                     literal (p->sem.attach.value)),
                            lit_oid (0)))));

            /*
             * Then join any BAT in L(p)'s environment with v
             */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                mvar_t *w = new_var (p->refctr);

                execute (
                    assgn (var (w->name),
                           leftjoin (var (v->name),
                                     var (env_at (L(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (w->name),
                           reverse (mark (reverse (var (w->name)),
                                          lit_oid (0)))));

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         w);
            }

            /* release v */
            unpin (v, 1);

        } break;

        /* Rel:      append_union (Rel, Rel) */
        case 23:

            for (unsigned int i = 0; i < p->schema.count; i++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & p->schema.items[i].type) {

                        mvar_t *v = new_var (p->refctr);

                        /*
                         * Type t is in the result relation. See if it
                         * is also in the left operand.
                         */
                        if (t & type_of (L(p), p->schema.items[i].name))
                            /* v := l.copy */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        copy (VAR (L(p)->env,
                                                   p->schema.items[i].name,
                                                   t)),
                                        BAT_APPEND)));
                        else
                            /* v := <some BAT of L>.project(nil); */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        project (
                                            var (env_at (L(p)->env, 0).mvar
                                                                       ->name),
                                            cast (implty (t), nil ())),
                                        BAT_APPEND)));

                        /*
                         * Is t also in the right operand?
                         */
                        if (t & type_of (R(p), p->schema.items[i].name))
                            /* v.append(R); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        VAR (R(p)->env,
                                             p->schema.items[i].name,
                                             t)),
                                    BAT_READ));
                        else
                            /* v.append(<some BAT of L>.project(nil)); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        project (
                                            var (env_at (R(p)->env, 0).mvar
                                                                       ->name),
                                            cast (implty (t), nil ()))),
                                    BAT_APPEND));

                        env_add (p->env, p->schema.items[i].name, t, v);
                    }

            break;

        /* Rel:      append_union (hash_count (Rel),
                                   attach (
                                       diff (Rel, 
                                             project (hash_count (Rel))))) */
        case 24:
        {
            if (L(p) == RLRL(p) && 
                R(p)->sem.attach.attname == L(p)->sem.count.res &&
                R(p)->sem.attach.value.type == aat_int &&
                R(p)->sem.attach.value.val.int_ == 0 &&
                RLL(p)->schema.count == 1 &&
                RLR(p)->schema.count == 1 &&
                L(p)->sem.count.part != att_NULL) {

                for (unsigned int i = 0; i < LL(p)->schema.count; i++)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & LL(p)->schema.items[i].type) {

                            if (t != LL(p)->schema.items[i].type)
                                PFoops (OOPS_FATAL,
                                        "HashCount not implemented for "
                                        "polymorphic groups");

                            mvar_t *v    = new_var (1);
                            mvar_t *res  = new_var (p->refctr);
                            mvar_t *part = new_var (p->refctr);

                            execute (
                                /* v := {count}(p_in.reverse ()) */
                                assgn (
                                    var (v->name),
                                    egcount (
                                        reverse (VAR (LL(p)->env,
                                                      L(p)->sem.count.part, t)),
                                        reverse (
                                            VAR (RLL(p)->env,
                                                 RLL(p)->schema.items[0].name,
                                                 t)))),
                                /* align with integer representation (lng) */
                                assgn (var (v->name),
                                       mcast (type (mty_lng), var (v->name))),
                                /* res := v.reverse ().mark (0@0).reverse (); */
                                assgn (
                                    var (res->name),
                                    reverse (
                                        mark (
                                            reverse (var (v->name)),
                                            lit_oid (0)))),
                                /* part := v.mark (0@0).reverse (); */
                                assgn (
                                    var (part->name),
                                    reverse (
                                        mark (var (v->name), lit_oid (0)))));

                            env_add (p->env, L(p)->sem.count.res, aat_int, res);
                            env_add (p->env, L(p)->sem.count.part, t, part);

                            unpin (v, 1);
                        }

                /* the relation in hash_count is used twice in this pattern
                   - the DAG however counts only one reference - thus we 
                   increase the pin count of the affected variables */
                for (unsigned int i = 0; i < PFarray_last (LL(p)->env); i++)
                    pin (env_at (LL(p)->env, i).mvar, 1);
            }
            else
                PFoops (OOPS_FATAL, 
                        "translation in milgen.brg is incorrect "
                        "- please remove");
        } break;

        /* Rel:      merge_union (Rel, Rel) */
        case 25:
        {
            PFmil_t *grouping[2];
            PFmil_t *args;
            bool     single_column_grouping = true;
            mvar_t  *v = NULL;

            /*
             * If the grouping parameter for MergeUnion is just a
             * single column, we can use the corresponding BAT right
             * away.  Otherwise, we need to use MonetDB's CT...()
             * functions to generate a BAT that describes just that
             * grouping.
             */
            assert (PFord_order_dir_at (p->sem.merge_union.ord, 0) == DIR_ASC);

            grouping[0]
                = VAR (L(p)->env,
                       PFord_order_col_at (p->sem.merge_union.ord, 0),
                       type_of (L(p),
                                PFord_order_col_at (p->sem.merge_union.ord,
                                                    0)));
            grouping[1]
                = VAR (R(p)->env,
                       PFord_order_col_at (p->sem.merge_union.ord, 0),
                       type_of (R(p),
                                PFord_order_col_at (p->sem.merge_union.ord,
                                                    0)));

            /*
             * We know (from the ordering properties we derived) that
             * our input is appropriately ordered. The grouping
             * function CTderive(), however, also provides grouping
             * from un-ordered groups (using a hash-based implementation).
             * This way, the resulting grouping BATs will not be marked
             * as tail-ordered (although they always will be, as we
             * know from our own ordering properties). We thus need to
             * check orderings explicitly (using chk_order()).
             *
             * An alternative to CTderive() could help us in two ways:
             *
             *  (1) There's actually no need to use a hash-based
             *      implementation, if we know that our input has the
             *      correct ordering.
             *  (2) An order-aware implementation could set ordering
             *      properties correctly right away.
             */
            for (unsigned int i = 1;
                    i < PFord_count (p->sem.merge_union.ord); i++) {
                
                assert (PFord_order_dir_at (p->sem.merge_union.ord, 
                                            i) == DIR_ASC);

                single_column_grouping = false;

                grouping[0]
                    = ctderive (
                        grouping[0],
                        VAR (L(p)->env,
                             PFord_order_col_at (p->sem.merge_union.ord, i),
                             type_of (
                                 L(p),
                                 PFord_order_col_at (p->sem.merge_union.ord,
                                                     i))));
                grouping[1]
                    = ctderive (
                        grouping[1],
                        VAR (R(p)->env,
                             PFord_order_col_at (p->sem.merge_union.ord, i),
                             type_of (
                                 R(p),
                                 PFord_order_col_at (p->sem.merge_union.ord,
                                                     i))));
            }

            /*
             * If we had to CTderive(), turn the grp result into an
             * actual BAT using CTmap().
             *
             * Use chk_order() to ensure that order properties are
             * correctly derived on the back-end.
             *
             * NOTE:
             *   We only want to use chk_order() on computed BATs,
             *   *not* if grouping[i] are just the variable names of
             *   the input relations.  Otherwise, chk_order() would
             *   have a side-effect on our input, with unpredictable
             *   effects...
             */
            if (PFord_count (p->sem.merge_union.ord) > 1)
                for (unsigned int i = 0; i < 2; i++)
                    grouping[i] = chk_order (ctmap (grouping[i]));


            /* first two arguments of merged_union() are the grouping atts */
            args = arg (grouping[0], grouping[1]);

            for (unsigned int i = 0; i < p->schema.count; i++) {

                /*
                 * If we group by a single column, then we don't need
                 * to list the grouping attribute a second time.
                 */
                if (!single_column_grouping
                    || p->schema.items[i].name !=
                       PFord_order_col_at (p->sem.merge_union.ord, 0)) {

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & p->schema.items[i].type) {

                            for (unsigned short j = 0; j <= 1; j++)
                                /*
                                 * If t is among the operand's types, use the
                                 * corresponding BAT, otherwise substitute a
                                 * BAT with `nil' tail.
                                 */
                                if (t & type_of (p->child[j],
                                                 p->schema.items[i].name))
                                    args = arg (args,
                                                VAR (p->child[j]->env,
                                                     p->schema.items[i].name,
                                                     t));
                                else
                                    args = arg (args,
                                                project (grouping[j],
                                                         cast (implty(t),
                                                               nil ())));
                        }
                }
            }

            v = new_var (1);

            /* execute merged_union() and assign it to v */
            execute (assgn (var (v->name), merged_union (args)));

            unsigned int j = 1;

            /* now extract all the result BATs */
            for (unsigned int i = 0; i < p->schema.count; i++) {

                /*
                 * If we group by a single column, then the grouping
                 * attribute is to be found as the first result BAT.
                 */
                if (!single_column_grouping
                    || p->schema.items[i].name !=
                       PFord_order_col_at (p->sem.merge_union.ord, 0)) {

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & p->schema.items[i].type) {

                            mvar_t *w = new_var (p->refctr);

                            execute (
                                assgn (var (w->name),
                                       fetch (var (v->name), lit_int (j))));
                            env_add (p->env, p->schema.items[i].name, t, w);
                            j++;

                        }
                }
                else {
                    PFalg_simple_type_t t
                        = type_of (p, p->schema.items[i].name);
                    mvar_t *w = new_var (p->refctr);

                    env_add (p->env, p->schema.items[i].name, t, w);
                    execute (
                            assgn (var (w->name),
                                fetch (var (v->name), lit_int (0))));
                }
            }

            /* release our temporary variable v */
            unpin (v, 1);

        } break;

        /* Rel:      intersect (Rel, Rel) */
        case 26:
        {
            mvar_t **res, **r;
            mvar_t *is;
            unsigned int shared_cols;
            PFmil_t *intersection;

            /* prepare as many result variables and temporary variables as 
               there will be result columns */
            res = (mvar_t **) PFmalloc (sizeof (mvar_t *) * 
                                        env_count(L(p)->env));
            r   = (mvar_t **) PFmalloc (sizeof (mvar_t *) * 
                                        env_count(L(p)->env));

            shared_cols = 0;
            for (unsigned int col = 0; col < env_count (L(p)->env); col++) {
              /* in the rhs argument, try to find the column that coresponds 
                 (name, type) with the column in the lhs */ 
              r[shared_cols] = env_mvar_unsafe (R(p)->env,
                                                env_at (L(p)->env, col).att,
                                                env_at (L(p)->env, col).ty);
              if (r[shared_cols]) {
                res[shared_cols] = new_var (p->refctr);
                execute (assgn (var (res[shared_cols]->name), 
                                join (var (env_at (L(p)->env, col).mvar->name),
                                      reverse (var (r[shared_cols]->name)))));

                env_add (p->env, 
                         env_at (L(p)->env, col).att, 
                         env_at (L(p)->env, col).ty,
                         res[shared_cols]);

                shared_cols++;
              }
            }

            if (!shared_cols)
              PFoops (OOPS_FATAL, "Arguments to Intersect do not share "
                                  "any column with common name and type");

            /* compute intersection (column-by-column) */       
            intersection = var (res[0]->name);
            for (unsigned int col = 1; col < shared_cols; col++)
                intersection = sintersect (intersection, var (res[col]->name));

            is = new_var (1);
            execute (
                assgn (var (is->name), 
                       reverse (mark (tunique (intersection), lit_oid (0)))));
            
            for (unsigned int col = 0; col < shared_cols; col++)
                execute (
                    assgn (var (res[col]->name),
                           leftjoin (var (is->name), var (r[col]->name))));

            /* release temporary variable is */
            unpin (is, 1);
            
        } break;

        /* Rel:      difference (Rel, Rel) */
        case 27:
        {
            mvar_t **l, *r = NULL;
            unsigned int shared_cols;
            mvar_t  *is;
            PFmil_t *args = NULL;

            /* prepare as many temporary variables as there are input columns */
            l    = (mvar_t **) PFmalloc (sizeof (mvar_t *) * 
                                         env_count(L(p)->env));
            
            shared_cols = 0;
            for (unsigned int col = 0; col < env_count (L(p)->env); col++) {
                /* in the rhs argument, try to find the column that corresponds 
                   (name, type) with the column in the lhs */ 
                r = env_mvar_unsafe (R(p)->env, env_at (L(p)->env, col).att,
                                                env_at (L(p)->env, col).ty);
                l[col]   = env_at (L(p)->env, col).mvar;
                
                if (r) {
                    if (!shared_cols)
                        args = arg (var (l[col]->name), var (r->name));
                    else
                        args = arg (args, arg (var (l[col]->name), 
                                               var (r->name)));
                    shared_cols++;
                }
            }

            if (!shared_cols)
              PFoops (OOPS_FATAL, "Arguments to Difference do not share "
                                  "any column with common name and type");

            assert (args);

            /* in most cases we only have a single column (difference based 
               on iter) where we can choose a more efficient variant. */
            if (shared_cols == 1 &&
                env_count (L(p)->env) == 1) {
                mvar_t *res = new_var (p->refctr);

                assert (r);
                
                execute (
                    assgn (var (res->name),
                           reverse (
                               mark (
                                   reverse (
                                       kdiff (
                                           var (l[0]->name),
                                           reverse (
                                               kintersect (
                                                   reverse (var (l[0]->name)),
                                                   reverse (var (r->name)))))),
                                   lit_oid (0)))));
                     
                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         res);
                break;
            }
                
            /* compute intersection */
            is = new_var (1);
            execute (assgn (var (is->name), 
                            mc_intersect (args)),
            /* build the difference */
                     assgn (var (is->name),
                            reverse (
                                mark (
                                    kdiff (var (l[0]->name),
                                           var (is->name)),
                                    lit_oid (0)))));

            /* apply the difference on all columns */
            for (unsigned int col = 0; col < env_count (L(p)->env); col++) {
                 mvar_t *a = new_var (p->refctr);

                 execute (
                      assgn (var (a->name),
                             leftjoin (
                                  var (is->name),
                                  var (l[col]->name))));
                      
                 env_add (p->env,
                          env_at (L(p)->env, col).att,
                          env_at (L(p)->env, col).ty,
                          a);
            }
            
            /* release temporary variable is */
            unpin (is, 1);

        } break;

        /* Rel:      sort_distinct (Rel) */
        case 30:
        /* Rel:      sort_distinct (std_sort (Rel)) */
        case 31: 
        /* Rel:      sort_distinct (refine_sort (Rel)) */
        case 32: 
            /* as we have to sort anyway we can also skip the sort operator */
        {
            /*
             * Derive a single BAT from the multi-column grouping
             * (using functions from the xtables module).
             */
            mvar_t    *v = new_var (1);
            mvar_t    *first_sort_var = NULL;
            bool       initialized = false;
            PFpa_op_t *rel;

            if (L(p)->kind == pa_std_sort || L(p)->kind == pa_refine_sort)
                rel = LL(p);
            else
                rel = L(p);

            /* cope with completely constant relations */
            if (!PFord_count (p->sem.sort_distinct.ord))
                execute (assgn (var (v->name),
                                var (env_at (rel->env, 0).mvar->name)));

            for (unsigned int i = 0;
                    i < PFord_count (p->sem.sort_distinct.ord); i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & type_of (rel,
                                     PFord_order_col_at (
                                         p->sem.sort_distinct.ord,
                                         i))) {
                        if (!initialized) {
                            /* we need a hit for the first order criterion */
                            assert (!i);
                            
                            first_sort_var = env_mvar (
                                                 rel->env,
                                                 PFord_order_col_at (
                                                     p->sem.sort_distinct.ord,
                                                     i),
                                                 t);
                            execute (
                                assgn (
                                    var (v->name),
                                    reverse (
                                        sort (
                                            reverse (
                                                var (first_sort_var->name)),
                                            PFord_order_dir_at (
                                                p->sem.sort_distinct.ord,
                                                i)))));

                            initialized = true;
                        }
                        else {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (rel->env,
                                             PFord_order_col_at (
                                                 p->sem.sort_distinct.ord,
                                                 i),
                                             t),
                                        PFord_order_dir_at (
                                            p->sem.sort_distinct.ord,
                                            i))));
                        }
                    }
                }
            }

            /*
             * Variable v is now of MIL type grp and contains the
             * grouping we need.
             *
             * We get the duplicate-free equivalent of our input by
             * joining the extend of v with each input BAT (and
             * generating a new key with mark()).
             *
             * v := v.CTextend ().mark (0@0).reverse ();
             */
            execute (
                assgn (var (v->name),
                       reverse (mark (reverse (
                                          kunique( reverse (var (v->name)))),
                                      lit_oid (0)))));

            /*
             * The join with each input relation:
             *
             * out := v.join (in);
             */
            for (unsigned int i = 0; i < env_count (rel->env); i++) {
                 mvar_t *out = new_var (p->refctr);

                 execute (
                      assgn (var (out->name),
                             leftjoin (var (v->name),
                                       var (env_at (rel->env,
                                                    i).mvar->name))));

                 /* we know that the first sort criterion certainly is sorted
                    -- assert_order however only copes with ascending order */
                 if (first_sort_var == env_at (rel->env,i).mvar &&
                     PFord_order_dir_at (p->sem.sort_distinct.ord, 0)
                     == DIR_ASC)
                     execute (
                          assgn (var (out->name),
                                 assert_order (var (out->name))));

                 /* because leftjoin does not know that we have 
                    exactly one match for each tuple in v,
                    we need to make the heads void ourselves */
                 execute (
                     assgn (var (out->name),
                            reverse (mark (reverse (var (out->name)),
                                           lit_oid (0)))));

                 env_add (p->env,
                          env_at (rel->env, i).att,
                          env_at (rel->env, i).ty,
                          out);
            }

            /* release our temporary variable */
            unpin (v, 1);

        } break;

        /* Rel:      std_sort (Rel) */
        case 33:
        {
            bool    initialized    = false;
            mvar_t *v              = new_var (1);
            mvar_t *first_sort_var = NULL;

            for (unsigned int i = 0;
                    i < PFord_count (p->sem.sortby.required); i++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & type_of (L(p),
                                     PFord_order_col_at (
                                         p->sem.sortby.required,
                                         i))) {
                        if (!initialized) {
                            /* we need a hit for the first order criterion */
                            assert (!i);
                            
                            first_sort_var = env_mvar (
                                                 L(p)->env,
                                                 PFord_order_col_at (
                                                     p->sem.sortby.required,
                                                     i),
                                                 t);
                            
                            execute (
                                assgn (
                                    var (v->name),
                                    reverse (
                                        sort (
                                            reverse (
                                                var (first_sort_var->name)),
                                            PFord_order_dir_at (
                                                p->sem.sortby.required,
                                                i)))));
                            initialized = true;
                        }
                        else {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (L(p)->env,
                                             PFord_order_col_at (
                                                 p->sem.sortby.required,
                                                 i),
                                             t),
                                        PFord_order_dir_at (
                                            p->sem.sortby.required,
                                            i))));
                        }
                    }

            /* handle the case that a sort does nothing */
            if (!PFord_count (p->sem.sortby.required))
                execute (assgn (var (v->name),
                                mirror (var (env_at (L(p)->env,
                                                     0).mvar->name))));

            execute (assgn (var (v->name),
                            reverse (mark (var (v->name), lit_oid (0)))));

            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                 mvar_t *a = new_var (p->refctr);

                 execute (
                      assgn (var (a->name),
                             leftjoin (
                                  var (v->name),
                                  var (env_at (L(p)->env, i).mvar->name))));
                      
                 /* we know that the first sort criterion certainly is sorted
                    -- assert_order however only copes with ascending order */
                 if (first_sort_var == env_at (L(p)->env,i).mvar &&
                     PFord_order_dir_at (p->sem.sort_distinct.ord, 0)
                     == DIR_ASC)
                     execute (
                          assgn (var (a->name),
                                 assert_order (var (a->name))));

                  /* because leftjoin does not know that we have 
                     exactly one match for each tuple in v,
                     we need to make the heads void ourselves */
                 execute (
                     assgn (var (a->name),
                            reverse (mark (reverse (var (a->name)),
                                           lit_oid (0)))));

                 env_add (p->env,
                          env_at (L(p)->env, i).att,
                          env_at (L(p)->env, i).ty,
                          a);
            }

            unpin (v, 1);
        }
        break;

        /* Rel:      refine_sort (Rel) */
        case 34:
        {
            bool         initialized = false;
            mvar_t      *v           = new_var (1);
            unsigned int i, j;

            /*
             * Create a MonetDB grp object according to the already
             * existing order.
             */
            for (i = 0; i < PFord_count (p->sem.sortby.existing); i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & type_of (L(p),
                                     PFord_order_col_at (
                                         p->sem.sortby.existing,
                                         i))) {
                        if (!initialized) {
                            execute (
                                assgn (
                                    var (v->name),
                                    VAR (L(p)->env,
                                         PFord_order_col_at (
                                             p->sem.sortby.existing, i),
                                         t)));
                            initialized = true;
                        }
                        else {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (L(p)->env,
                                             PFord_order_col_at (
                                                 p->sem.sortby.existing, i),
                                             t),
                                        PFord_order_dir_at (
                                            p->sem.sortby.existing,
                                            i))));
                        }
                    }
                }
            }

            /*
             * Now do the remaining sorting
             */
            for (i = PFord_count (p->sem.sortby.existing);
                    i < PFord_count (p->sem.sortby.required); i++) {
                /*
                 * Be careful to implement document order on
                 * nodes correctly:
                 *
                 *  - sort by fragment first, then by pre/attr
                 *    (the aat_pfrag/aat_afrag bit is lower
                 *     than the aat_pre/aat_attr bit)
                 *  - document order of attributes and other nodes
                 *    requires extra effort
                 */
                assert(!((aat_anode & 
                          type_of (L(p),
                                   PFord_order_col_at (p->sem.sortby.required,
                                                       i))) &&
                         (aat_pnode &
                          type_of (L(p),
                                  PFord_order_col_at (p->sem.sortby.required,
                                                      i)))));

                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & type_of (L(p),
                                     PFord_order_col_at (
                                         p->sem.sortby.required,
                                         i))) {
                         execute (
                             assgn (var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (L(p)->env,
                                             PFord_order_col_at (
                                                 p->sem.sortby.required, i),
                                             t),
                                        PFord_order_dir_at (
                                            p->sem.sortby.required, i))));
                    }
            }

            execute (
                assgn (var (v->name),
                       reverse (mark (var (v->name), lit_oid (0)))));

            for (i = 0; i < env_count (L(p)->env); i++) {
                /* all columns that ensure the already existing order
                   stay unchanged. */
                for (j = 0; j < PFord_count (p->sem.sortby.existing); j++)
                    if (PFord_order_col_at (p->sem.sortby.existing, j) ==
                        env_at (L(p)->env, i).att) {
                        env_t entry = env_at (L(p)->env, i);
                        env_add (p->env, entry.att, entry.ty, entry.mvar);
                        pin (entry.mvar, p->refctr);
                        break;
                    }
                
                /* adjust the ordering for all other columns */
                if (j == PFord_count (p->sem.sortby.existing)) {
                    mvar_t *a = new_var (p->refctr);
                 
                    execute (
                        assgn (var (a->name),
                               leftjoin (
                                    var (v->name),
                                    var (env_at (L(p)->env, i).mvar->name))),
                        /* because leftjoin does not know that we have 
                           exactly one match for each tuple in v,
                           we need to make the heads void ourselves */
                        assgn (var (a->name),
                               reverse (mark (reverse (var (a->name)),
                                              lit_oid (0)))));
                 
                    env_add (p->env,
                             env_at (L(p)->env, i).att,
                             env_at (L(p)->env, i).ty,
                             a);
                }
            }

            unpin (v, 1);

        } break;

        /* Rel:      fun_1to1 (Rel) */
        case 40:
        {
            /* result variable */
            mvar_t             *res = new_var (p->refctr);
            PFalg_simple_type_t res_type = 0; 

            switch (p->sem.fun_1to1.kind) {
                case alg_fun_num_add:
                case alg_fun_num_subtract:
                case alg_fun_num_multiply:
                case alg_fun_num_divide:
                case alg_fun_num_modulo:
                case alg_fun_fn_concat:
                {
                    PFmil_t * (*op) (const PFmil_t *, const PFmil_t *) = NULL;
                    PFalg_att_t         att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = type_of (L(p), att1);

                    assert (res_type == type_of (L(p), att2));
                    assert (res_type == aat_int || res_type == aat_dec ||
                            res_type == aat_dbl || res_type == aat_str);

                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_fn_concat:
                        case alg_fun_num_add:
                            op = PFmil_madd; break;
                        case alg_fun_num_subtract:
                            op = PFmil_msub; break;
                        case alg_fun_num_multiply:
                            op = PFmil_mmult; break;
                        case alg_fun_num_divide:
                            op = PFmil_mdiv; break;
                        case alg_fun_num_modulo:
                            op = PFmil_mmod; break;
                        default:
                            break;
                    }
                    
                    /* do the arithmetics */
                    execute (
                        assgn (var (res->name),
                               op (VAR (L(p)->env, att1, res_type),
                                   VAR (L(p)->env, att2, res_type))));

                }   break;
                    
                case alg_fun_fn_abs:
                case alg_fun_fn_ceiling:
                case alg_fun_fn_floor:
                case alg_fun_fn_round:
                {
                    PFmil_t * (*op) (const PFmil_t *) = NULL;
                    PFalg_att_t         att;

                    att = p->sem.fun_1to1.refs.atts[0];
                    res_type = type_of (L(p), att);

                    assert (res_type == aat_int || res_type == aat_dec ||
                            res_type == aat_dbl);

                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_fn_abs:
                            op = PFmil_mabs; break;
                        case alg_fun_fn_ceiling:
                            op = PFmil_mceil; break;
                        case alg_fun_fn_floor:
                            op = PFmil_mfloor; break;
                        case alg_fun_fn_round:
                            op = PFmil_mround_up; break;
                        default:
                            break;
                    }

                    /* because functions are only allowed for dbl
                       we need to cast before and afterwards:
                       res := `input'.[dbl]().[`op']().[`res_type'](); */
                    if (impl_types[res_type] == mty_dbl)
                        execute (
                            assgn (var (res->name),
                                   op (VAR (L(p)->env, att, res_type))));
                    else
                        execute (
                            assgn (var (res->name),
                                   mcast (implty (res_type),
                                          op (mcast (type (mty_dbl),
                                                     VAR (L(p)->env,
                                                          att,
                                                          res_type))))));
                }   break;

                case alg_fun_fn_substring:
                {
                    PFalg_att_t        att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_str;

                    execute (
                        assgn (var (res->name),
                               mstring (VAR (L(p)->env, att1, aat_str),
                                        mcast ( type (mty_int),
                                                VAR (L(p)->env, att2, aat_int)))));

                }   break;

                case alg_fun_fn_substring_lng:
                {
                    PFalg_att_t        att1, att2, att3;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    att3 = p->sem.fun_1to1.refs.atts[2];
                    res_type = aat_str;

                    execute (
                        assgn (var (res->name),
                               mstring2 (VAR (L(p)->env, att1, aat_str),
                                         mcast ( type (mty_int),
                                                 VAR (L(p)->env, att2, aat_int)),
                                         mcast ( type (mty_int),
                                                 VAR (L(p)->env, att3, aat_int)))));
                }   break;

                case alg_fun_fn_string_length:
                {
                    PFalg_att_t         att;

                    att = p->sem.fun_1to1.refs.atts[0];
                    res_type = aat_int;

                    execute (
                        assgn (var (res->name),
                               mcast ( implty (res_type),
                                       mlength ( 
                                           VAR (L(p)->env, att, aat_str)))));

                }   break;

                case alg_fun_fn_normalize_space:
                case alg_fun_fn_upper_case:
                case alg_fun_fn_lower_case:
                {
                    PFmil_t * (*op) (const PFmil_t *) = NULL;
                    PFalg_att_t         att;

                    att = p->sem.fun_1to1.refs.atts[0];
                    res_type = aat_str;

                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_fn_upper_case:
                            op = PFmil_mtoUpper; break;
                        case alg_fun_fn_lower_case:
                            op = PFmil_mtoLower; break;
                        case alg_fun_fn_normalize_space:
                            op = PFmil_mnorm_space; break;
                        default: break;
                    }

                    execute (
                        assgn (var (res->name),
                               op (VAR (L(p)->env, att, aat_str))));

                }   break;

                case alg_fun_fn_contains:
                {
                    PFalg_att_t         att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_bln;

                    /* do the containment checks:
                       [search](strings,search_strs).[!=](-1).[oid]() */
                    execute (
                        assgn (var (res->name),
                               mnot (meq (msearch (
                                              VAR (L(p)->env, att1, aat_str),
                                              VAR (L(p)->env, att2, aat_str)),
                                          lit_int (-1)))));
                }   break;

                case alg_fun_fn_starts_with:
                case alg_fun_fn_ends_with:
                case alg_fun_fn_matches:
                {
                    PFmil_t * (*op) (const PFmil_t *, const PFmil_t *) = NULL;
                    PFalg_att_t         att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_bln;

                    switch (p->sem.fun_1to1.kind) {
                        case alg_fun_fn_starts_with:
                            op = PFmil_mstarts_with; break;
                        case alg_fun_fn_ends_with:
                            op = PFmil_mends_with; break;
                        case alg_fun_fn_matches:
                            op = PFmil_mpcre_match; break;
                        default: break;
                    }

                    execute (
                        assgn (var (res->name),
                               op (VAR (L(p)->env, att1, aat_str),
                                   VAR (L(p)->env, att2, aat_str))));
                }   break;

                case alg_fun_fn_substring_before:
                {
                    PFalg_att_t         att1, att2;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_str;

                    execute (
                        assgn (var (res->name),
                               mstring2 (VAR (L(p)->env, att1, aat_str),
                                         lit_int (0),
                                         msearch (
                                            VAR (L(p)->env, att1, aat_str),
                                            VAR (L(p)->env, att2, aat_str)))));

                }   break;

                case alg_fun_fn_substring_after:
                {
                    PFalg_att_t         att1, att2;
                    mvar_t              *search_res;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    res_type = aat_str;
                    search_res = new_var(1);

                    execute (
                        assgn ( var (search_res->name),
                                msearch ( VAR (L(p)->env, att1, aat_str),
                                          VAR (L(p)->env, att2, aat_str))),
                        assgn ( var (res->name),
                                mifthenelse ( meq ( var (search_res->name),
                                                    lit_int(-1)),
                                              lit_str(""),
                                              mstring (
                                               VAR (L(p)->env, att1, aat_str),
                                               madd ( var (search_res->name),
                                                      mlength ( VAR (L(p)->env,
                                                                     att2,
                                                                     aat_str)
                                                                       ))))));
                    unpin(search_res, 1);

                }   break;

                case alg_fun_fn_matches_flag:
                {
                    PFalg_att_t         att1, att2, att3;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    att3 = p->sem.fun_1to1.refs.atts[2];
                    res_type = aat_bln;

                    execute (
                        assgn ( var (res->name),
                                mpcre_match_flag ( 
                                    VAR (L(p)->env, att1, aat_str),
                                    VAR (L(p)->env, att2, aat_str),
                                    VAR (L(p)->env, att3, aat_str))));

                }   break;

                case alg_fun_fn_replace:
                {
                    PFalg_att_t         att1, att2, att3;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    att3 = p->sem.fun_1to1.refs.atts[2];
                    res_type = aat_str;

                    execute (
                        assgn ( var (res->name),
                                mpcre_replace (
                                    VAR (L(p)->env, att1, aat_str),
                                    VAR (L(p)->env, att2, aat_str),
                                    VAR (L(p)->env, att3, aat_str),
                                    lit_str(""))));
                }   break;

                case alg_fun_fn_replace_flag:
                {
                    PFalg_att_t         att1, att2, att3, att4;

                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[1];
                    att3 = p->sem.fun_1to1.refs.atts[2];
                    att4 = p->sem.fun_1to1.refs.atts[3];
                    res_type = aat_str;

                    execute (
                        assgn ( var (res->name),
                                mpcre_replace (
                                    VAR (L(p)->env, att1, aat_str),
                                    VAR (L(p)->env, att2, aat_str),
                                    VAR (L(p)->env, att3, aat_str),
                                    VAR (L(p)->env, att4, aat_str))));
                }   break;

                case alg_fun_fn_number:
                {
                    PFalg_att_t         att;
                    PFalg_simple_type_t att_type = 0;
                    bool                first = true;

                    att = p->sem.fun_1to1.refs.atts[0];

                    for (unsigned int i = 0; i < L(p)->schema.count; i++)
                        if (L(p)->schema.items[i].name == att) {
                            att_type = L(p)->schema.items[i].type;
                            break;
                        }

                    res_type = aat_dbl;

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & att_type) {

                            PFmil_t *casted = NULL;

                            if (t == res_type)
                                casted = VAR (L(p)->env, att, t);
                            else
                                casted
                                    = mcast (
                                        implty (res_type),
                                        VAR (L(p)->env, att, t));

                            if (first) {
                                execute (assgn (var (res->name), casted));
                                first = false;
                            }
                            else
                                execute (assgn (var (res->name),
                                                mifthenelse (
                                                    misnil (var (res->name)),
                                                    casted,
                                                    var (res->name))));
                        }

                    /* As we do not support the value NaN we need to generate
                       an error for all tuples that cannot be casted (instead
                       of generating NaN). */
                    execute (
                        if_ (exist (reverse (var (res->name)),
                                    cast (implty (res_type), nil ())),
                             error (
                                 lit_str ("We do not support the value NaN.")),
                             nop ()));
                }   break;

                case alg_fun_fn_qname:
                {
                    PFalg_att_t att1, att2;
                    att1 = p->sem.fun_1to1.refs.atts[0];
                    att2 = p->sem.fun_1to1.refs.atts[0];

                    PFmil_t *str = NULL;
                    mvar_t  *offset  = new_var (1);
                    mvar_t  *prefix  = new_var (1);
                    mvar_t  *local   = new_var (1);
                    mvar_t  *err_str = new_var (1);
                    PFmil_t *v_cast  = VAR (L(p)->env, att1, aat_str),
                            *v_uri   = VAR (L(p)->env, att2, aat_str);

                    /* split up strings using ``:'' as delimiter */
                    /* FIXME: currently we we don't retrieve the URI */
                    execute (
                        assgn (var (err_str->name),
                               check_qnames (v_cast)),
                        if_ (not (isnil (var (err_str->name))),
                             error (arg (lit_str ("err:FORG0001. "
                                                  "illegal QName '%s'."),
                                         var (err_str->name))),
                             nop ()),
                        assgn (var (offset->name),
                               msearch (v_cast, lit_str (":"))),
                        assgn (var (prefix->name),
                               mstring2 (v_cast,
                                         lit_int (0),
                                         var (offset->name))),
                        assgn (var (local->name),
                               mstring (v_cast,
                                        madd (lit_int (1),
                                              var (offset->name)))));
                    /* FIXME: do not allow "|" uris if we have
                       no namespace prefix */

                    /* add_qnames changes the working set
                       in 'var (PF_MIL_VAR_WS)' as side effect */
                    str = add_qnames (
                              var (prefix->name),
                              v_uri,
                              var (local->name),
                              var (PF_MIL_VAR_WS));

                    execute (assgn (var (res->name), str));

                    unpin (offset, 1);
                    unpin (prefix, 1);
                    unpin (local, 1);
                    unpin (err_str, 1);

                    res_type = aat_qname;
                }   break;

                case alg_fun_pf_fragment:
                    res_type = aat_pfrag;
                    res = env_mvar (L(p)->env,
                                    p->sem.fun_1to1.refs.atts[0],
                                    aat_node);
                    break;

                case alg_fun_pf_supernode:
                    assert (!"no implementation here");
                    break;
            }

            /* and put the result into p's environment */
            env_add (p->env, p->sem.fun_1to1.res, res_type, res);

            /* everything from p's child */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {
                env_t entry = env_at (L(p)->env, i);
                env_add (p->env, entry.att, entry.ty, entry.mvar);
                pin (entry.mvar, p->refctr);
            }
        }   break;

        /* Rel:      eq (Rel) */
        case 50:
            bin_comp (PFmil_meq, p);
            break;

        /* Rel:      eq_atom (Rel) */
        case 51:
            bin_comp_atom (PFmil_meq, p);
            break;

        /* Rel:      gt (Rel) */
        case 52:
            bin_comp (PFmil_mgt, p);
            break;

        /* Rel:      gt_atom (Rel) */
        case 53:
            bin_comp_atom (PFmil_mgt, p);
            break;

        /* Rel:      bool_not (Rel) */
        case 61:
            unary_op (PFmil_mnot, p);
            break;

        /* Rel:      bool_and (Rel) */
        case 62:
            bin_bool (PFmil_mand, p);
            break;

        /* Rel:      bool_or (Rel) */
        case 63:
            bin_bool (PFmil_mor, p);
            break;

        /* Rel:      bool_and_atom (Rel) */
        case 64:
            bin_bool_atom (PFmil_mand, p);
            break;

        /* Rel:      bool_or_atom (Rel) */
        case 65:
            bin_bool_atom (PFmil_mor, p);
            break;

        /* Rel:      hash_count (Rel) */
        case 66:
            if (p->sem.count.part != att_NULL) {
                for (unsigned int i = 0; i < L(p)->schema.count; i++)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            if (t != L(p)->schema.items[i].type)
                                PFoops (OOPS_FATAL,
                                        "HashCount not implemented for "
                                        "polymorphic groups");

                            mvar_t *v    = new_var (1);
                            mvar_t *res  = new_var (p->refctr);
                            mvar_t *part = new_var (p->refctr);

                            execute (
                                /* v := {count}(p_in.reverse ()) */
                                assgn (
                                    var (v->name),
                                    gcount (
                                        reverse (VAR (L(p)->env,
                                                      p->sem.count.part, t)))),
                                /* align with integer representation (lng) */
                                assgn (var (v->name),
                                       mcast (type (mty_lng), var (v->name))),
                                /* res := v.reverse ().mark (0@0).reverse (); */
                                assgn (
                                    var (res->name),
                                    reverse (
                                        mark (
                                            reverse (var (v->name)),
                                            lit_oid (0)))),
                                /* part := v.mark (0@0).reverse (); */
                                assgn (
                                    var (part->name),
                                    reverse (
                                        mark (var (v->name), lit_oid (0)))));

                            env_add (p->env, p->sem.count.res, aat_int, res);
                            env_add (p->env, p->sem.count.part, t, part);

                            unpin (v, 1);
                        }
            }
            else {

                mvar_t *v = new_var (p->refctr);
                execute (
                    assgn (var (v->name),
                           count (var (env_at (L(p)->env, 0).mvar->name))),
                    /* align with integer representation (lng) */
                    assgn (var (v->name),
                           cast (type (mty_lng), var (v->name))),
                    assgn (var (v->name),
                           append (
                               seqbase (
                                   new (type (mty_void), type (mty_lng)),
                                   lit_oid (0)),
                               var (v->name))));
                env_add (p->env, p->sem.count.res, aat_int, v);
            }
            break;

        /* Rel:      avg (Rel) */
        case 67:
             aggr_function(PFmil_avg, PFmil_gavg, p);
             break;

        /* Rel:      max_ (Rel) */
        case 68:
             aggr_function(PFmil_max, PFmil_gmax, p);
             break;

        /* Rel:      min_ (Rel) */
        case 69:
             aggr_function(PFmil_min, PFmil_gmin, p);
             break;

        /* Rel:      sum (Rel) */
        case 70:
             aggr_function(PFmil_sum, PFmil_gsum, p);
             break;

        /* Rel:      number (Rel) */
        case 73:
        {
            mvar_t *res = new_var (p->refctr);

            assert (env_count (L(p)->env));

            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }

            /* and add the newly numbered one */
            if (p->sem.number.part != att_NULL)
                execute (
                    assgn (var (res->name),
                           mark_grp (
                               VAR (p->env,
                                    p->sem.number.part,
                                    type_of (p, p->sem.number.part)),
                               project (
                                   kunique (
                                       reverse (
                                           VAR (p->env,
                                                p->sem.number.part,
                                                type_of (p, p->sem.number.part))
                                           )),
                                   lit_oid (1)))));
            else if (env_at (L(p)->env, 0).ty == aat_pfrag)
                /* As in many cases two adjacent path steps are separated
                   by a number operator and the fragment is constant we
                   try to avoid an additional dependency on the fragment
                   to ease 'materialize' operator removal. */
                execute (
                    assgn (var (res->name),
                           mark (VAR (L(p)->env,
                                      env_at (L(p)->env, 0).att,
                                      aat_pre),
                                 lit_oid (1))));
            else
                execute (
                    assgn (var (res->name),
                           mark (var (env_at (L(p)->env, 0).mvar->name),
                                 lit_oid (1))));

            /* put the result into p's environment */
            env_add (p->env, p->sem.number.attname, aat_nat, res);
        } break;

        /* Rel:      type (Rel) */
        case 74:
        {
            mvar_t             *res = new_var (p->refctr);
            PFalg_simple_type_t input_ty = 0;

            /* and put the result into p's environment */
            env_add (p->env, p->sem.type.res, aat_bln, res);

            /* everything from p's child */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);

                /* collect the types of the 'type' column */
                if (entry.att == p->sem.type.att)
                    input_ty = entry.ty | input_ty;
            }

            if (!(p->sem.type.ty & input_ty))
                /* cope with the case that our schema does not provide
                   the type represented by p->sem.type.ty */
                execute (
                    assgn (var (res->name),
                           project (var (env_at (L(p)->env, 0).mvar->name),
                                    lit_bit (false))));

            else if (p->sem.type.ty == aat_node &&
                     input_ty & aat_pre &&
                     input_ty & aat_attr)
                /* both pre values and attributes are available and allowed */
                execute (
                    assgn (var (res->name),
                           mor (
                               mnot (misnil (VAR (L(p)->env,
                                             p->sem.type.att,
                                             aat_pre))),
                               mnot (misnil (VAR (L(p)->env,
                                             p->sem.type.att,
                                             aat_attr))))));

            else if (p->sem.type.ty == aat_pnode ||
                     (p->sem.type.ty == aat_node &&
                      input_ty & aat_pre))
                /* pre values are available and allowed */
                execute (
                    assgn (var (res->name),
                           mnot (misnil (VAR (L(p)->env,
                                         p->sem.type.att,
                                         aat_pre)))));

            else if (p->sem.type.ty == aat_anode ||
                     (p->sem.type.ty == aat_node &&
                      input_ty & aat_attr))
                /* attributes are available and allowed */
                execute (
                    assgn (var (res->name),
                           mnot (misnil (VAR (L(p)->env,
                                         p->sem.type.att,
                                         aat_attr)))));

            else
                /* we have one simple type */
                execute (
                    assgn (var (res->name),
                           mnot (misnil (VAR (L(p)->env,
                                         p->sem.type.att,
                                         p->sem.type.ty)))));

        }
            break;

        /* Rel:      type_assert (Rel) */
        case 75:
            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Rel:      cast (Rel) */
        case 76:
            for (unsigned int i = 0; i < L(p)->schema.count; i++)
            {
                bool att_needed = true;
                mvar_t *v = NULL;

                /* cast as qname requires additional document access */
                if (L(p)->schema.items[i].name == p->sem.cast.att &&
                    p->sem.cast.ty == aat_qname) {

                    v = new_var (p->refctr);

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if ((t & L(p)->schema.items[i].type) &&
                            (t != aat_str && t != aat_uA && t != aat_qname))
                            PFoops (OOPS_FATAL,
                                    "cast to type QName is only possible "
                                    "for type QName and type string.%i", t);

                    bool   qn = false;

                    /* nothing to do - just assign it to a new variable */
                    if (L(p)->schema.items[i].type & aat_qname)
                    {
                        execute (assgn (var (v->name),
                                        VAR (L(p)->env, p->sem.cast.att,
                                             L(p)->schema.items[i].type)));
                        qn = true;
                    }

                    if (L(p)->schema.items[i].type & aat_str
                         || L(p)->schema.items[i].type & aat_uA)
                    {
                        PFmil_t *str = NULL;
                        mvar_t  *offset  = new_var (1);
                        mvar_t  *prefix  = new_var (1);
                        mvar_t  *local   = new_var (1);
                        mvar_t  *err_str = new_var (1);
                        PFmil_t *v_cast  =
                                     VAR (L(p)->env, p->sem.cast.att,
                                          L(p)->schema.items[i].type);

                        /* split up strings using ``:'' as delimiter */
                        /* FIXME: currently we we don't retrieve the URI */
                        execute (
                            assgn (var (err_str->name),
                                   check_qnames (v_cast)),
                            if_ (not (isnil (var (err_str->name))),
                                 error (arg (lit_str ("err:FORG0001. "
                                                      "illegal QName '%s'."),
                                             var (err_str->name))),
                                 nop ()),
                            assgn (var (offset->name),
                                   msearch (v_cast, lit_str (":"))),
                            assgn (var (prefix->name),
                                   mstring2 (v_cast,
                                             lit_int (0),
                                             var (offset->name))),
                            assgn (var (local->name),
                                   mstring (v_cast,
                                            madd (lit_int (1),
                                                  var (offset->name)))));

                        /* add_qnames changes the working set
                           in 'var (PF_MIL_VAR_WS)' as side effect */
                        str = add_qnames (
                                  var (prefix->name),
                                  project (var (prefix->name),
                                           lit_str ("")),
                                  var (local->name),
                                  var (PF_MIL_VAR_WS));

                        if (qn) /* combine both qname tables */
                            execute (assgn (var (v->name),
                                            mifthenelse (
                                                misnil (var (v->name)),
                                                str,
                                                var (v->name))));
                        else
                            execute (assgn (var (v->name), str));

                        unpin (offset, 1);
                        unpin (prefix, 1);
                        unpin (local, 1);
                        unpin (err_str, 1);
                    }
                }
                else if (L(p)->schema.items[i].name == p->sem.cast.att) {

                    unsigned int   parts = 0;
                    mvar_t        *bln_tmp = NULL;
                    v = new_var (p->refctr);

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            PFmil_t *casted = NULL;

                            if (t == p->sem.cast.ty)
                                casted = VAR (L(p)->env, p->sem.cast.att, t);

                            else if ((t == aat_str || t == aat_uA) &&
                                     p->sem.cast.ty == aat_bln) {
                                /* The cast from string or untypedAtomic
                                   to boolean is only allowed for a few
                                   values. Here the values are checked and
                                   the respective result is returned. */
                                mvar_t *true_values;
                                mvar_t *false_values = new_var (1);

                                bln_tmp = new_var (1);
                                true_values = bln_tmp;

                                /* collect all strings that map to 'true' */
                                execute (assgn (var (true_values->name),
                                                meq (VAR (L(p)->env,
                                                          p->sem.cast.att,
                                                          t),
                                                     lit_str("true"))),
                                         assgn (var (true_values->name),
                                                mor (var (true_values->name),
                                                     meq (VAR (L(p)->env,
                                                               p->sem.cast.att,
                                                               t),
                                                          lit_str("1")))),
                                /* collect all strings that map to 'false' */
                                         assgn (var (false_values->name),
                                                meq (VAR (L(p)->env,
                                                          p->sem.cast.att,
                                                          t),
                                                     lit_str("false"))),
                                         assgn (var (false_values->name),
                                                mor (var (false_values->name),
                                                     meq (VAR (L(p)->env,
                                                               p->sem.cast.att,
                                                               t),
                                                          lit_str("0")))),
                                /* generate an error message for all other
                                   strings */
                                         if_ (
                                             exist (
                                                 reverse (
                                                     mor (
                                                         var (
                                                             true_values->name),
                                                         var (
                                                             false_values->name)
                                                         )),
                                                 lit_bit (false)),

                                             error (
                                                 t == aat_uA
                                                 ? lit_str ("err:FORG0001. "
                                                            "casting from "
                                                            "untypedAtomic "
                                                            "to boolean "
                                                            "failed.")
                                                 : lit_str ("err:FORG0001. "
                                                            "casting from "
                                                            "string to "
                                                            "boolean failed.")
                                                 ),
                                             nop ()));

                                casted = var (true_values->name);
                                /* note: casted == bln_tmp */
                                unpin (false_values, 1);
                            }
                            else
                                casted
                                    = mcast (
                                        implty (p->sem.cast.ty),
                                        VAR (L(p)->env, p->sem.cast.att, t));

                            if (parts)
                                execute (assgn (var (v->name),
                                                mifthenelse (
                                                    misnil (var (v->name)),
                                                    casted,
                                                    var (v->name))));
                            else
                                execute (assgn (var (v->name), casted));

                            parts++;

                            /* Unpin the temporary variable
                               bln_tmp if it has been pinned. */
                            if (bln_tmp) {
                                unpin (bln_tmp, 1);
                                bln_tmp = NULL;
                            }
                        }
                    execute (
                        if_ (exist (reverse (var (v->name)),
                                    cast (implty (p->sem.cast.ty), nil ())),
                             error (lit_str ("err:FORG0001.")),
                             nop ()));
                }

                if (L(p)->schema.items[i].name == p->sem.cast.att &&
                    p->sem.cast.att != p->sem.cast.res)
                    env_add (p->env, p->sem.cast.res, p->sem.cast.ty, v);
                else if (L(p)->schema.items[i].name == p->sem.cast.att)
                {
                    att_needed = false;
                    env_add (p->env, p->sem.cast.att, p->sem.cast.ty, v);
                }

                if (att_needed) {
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            mvar_t *v = env_mvar (L(p)->env,
                                                  L(p)->schema.items[i].name,
                                                  t);

                            env_add (p->env, L(p)->schema.items[i].name, t, v);
                            pin (v, p->refctr);
                        }
                }
            } break;

        /* Rel:      llscj_anc (FragList, Rel) */
        case 80:
            llscj (ax_anc, p);
            break;

        /* Rel:      llscj_anc_self (FragList, Rel) */
        case 81:
            llscj (ax_anc_self, p);
            break;

        /* Rel:      llscj_attr (FragList, Rel) */
        case 82:
        {
            /* abbreviations for input expressions */
            PFty_t           ty  = p->sem.scjoin.ty;

            /* MIL equivalents of input expression */
            PFmil_t *iter;
            PFmil_t *pre;
            PFmil_t *frag;

            mvar_t  *tmp;      /* helper variable */
            mvar_t  *ret_iter; /* var to which we assign the `iter' result */
            mvar_t  *ret_attr; /* var to which we assign the `pre' result */
            mvar_t  *ret_frag; /* var to which we assign the `kind' result */

            /*
             * Determine generic input arguments.
             */
            assert (p); assert (R(p)); assert (R(p)->env);
            iter = VAR (R(p)->env, p->sem.scjoin.iter, aat_nat);
            pre = VAR (R(p)->env, p->sem.scjoin.item, aat_pre);
            frag = VAR (R(p)->env, p->sem.scjoin.item, aat_pfrag);
            assert (iter); assert (pre); assert (frag);

            tmp      = new_var (1);
            ret_iter = new_var (p->refctr);
            ret_attr  = new_var (p->refctr);
            ret_frag = new_var (p->refctr);

            /* first get all attribute nodes... */
            execute (
                assgn (var (tmp->name),
                       mvaljoin (pre, frag, fetch (var (PF_MIL_VAR_WS),
                                                   var (PF_MIL_VAR_ATTR_OWN)))),
                assgn (var (ret_attr->name),
                       reverse (mark (reverse (var (tmp->name)), lit_oid (0)))),
                assgn (var (ret_frag->name),
                       leftjoin (reverse (mark (var (tmp->name), lit_oid (0))),
                                 frag)),
                assgn (var (ret_iter->name),
                       leftjoin (reverse (mark (var (tmp->name), lit_oid (0))),
                                 iter)));

            /* ... then filter out all nodes, whose name test does not match */
            if (PFty_subtype (ty, PFty_xs_anyAttribute ())) {

                /* Is it just a generic attribute kind test?
                   (e.g. .../attribute()) */
                if (PFty_subtype (PFty_xs_anyAttribute (), ty))
                    ;

                /* Is it a test on attribute kind and local name only? */
                else if (PFty_subtype (
                            PFty_attr (
                                PFqname (PFns_wild,
                                         PFqname_loc (
                                             PFty_name (PFty_defn (ty)))),
                                PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (
                                   mposjoin (
                                       var (ret_attr->name),
                                       var (ret_frag->name),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_QN))),
                                   mposjoin (
                                       var (ret_attr->name),
                                       var (ret_frag->name),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_CONT))),
                               fetch (var (PF_MIL_VAR_WS),
                                      var (PF_MIL_VAR_QN_LOC)))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_loc (
                                                PFty_name (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name),
                                         var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name),
                                         var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name),
                                         var (ret_iter->name))));

                /* Or maybe a test on attribute kind and namespace only? */
                else if (PFty_subtype (
                            PFty_attr (
                                PFqname (
                                    PFqname_ns (PFty_name (PFty_defn (ty))),
                                    NULL),
                                PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (
                                   mposjoin (var (ret_attr->name),
                                             var (ret_frag->name),
                                             fetch (var (PF_MIL_VAR_WS),
                                                    var (PF_MIL_VAR_ATTR_QN))),
                                   mposjoin (
                                       var (ret_attr->name),
                                       var (ret_frag->name),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_CONT))),
                                   fetch (var (PF_MIL_VAR_WS),
                                          var (PF_MIL_VAR_QN_URI)))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_uri (
                                                PFty_name (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name),
                                         var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name),
                                         var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name),
                                         var (ret_iter->name))));

                /* A test on attribute kind and full QName? */
                else if (PFty_subtype (
                            PFty_attr (PFty_name (PFty_defn (ty)),
                                       PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (
                                  mposjoin (var (ret_attr->name),
                                            var (ret_frag->name),
                                            fetch (var (PF_MIL_VAR_WS),
                                                   var (PF_MIL_VAR_ATTR_QN))),
                                  mposjoin (var (ret_attr->name),
                                            var (ret_frag->name),
                                            fetch (var (PF_MIL_VAR_WS),
                                                   var (PF_MIL_VAR_ATTR_CONT))),
                                  fetch (var (PF_MIL_VAR_WS),
                                         var (PF_MIL_VAR_QN_LOC)))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_loc (
                                                PFty_name (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name),
                                         var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name),
                                         var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name),
                                         var (ret_iter->name))),
                        assgn (var (tmp->name),
                               mposjoin (
                                   mposjoin (var (ret_attr->name),
                                             var (ret_frag->name),
                                             fetch (var (PF_MIL_VAR_WS),
                                                    var (PF_MIL_VAR_ATTR_QN))),
                                   mposjoin (
                                       var (ret_attr->name),
                                       var (ret_frag->name),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_ATTR_CONT))),
                                   fetch (var (PF_MIL_VAR_WS),
                                          var (PF_MIL_VAR_QN_URI)))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_uri (
                                                PFty_name (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name),
                                         var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name),
                                         var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name),
                                         var (ret_iter->name))));

                /*
                 * If we couldn't figure out what attribute test we got,
                 * give up.
                 *
                 * NOTE: The surface language actually allows such tests. We
                 *       just cannot implement them (yet):
                 *
                 *        doc("foo")/attribute::attribute(shoeSize, xs:integer)
                 */
                else
                    PFoops (OOPS_FATAL,
                            "Problem with an XPath step: cannot evaluate "
                            "node test `%s'", PFty_str (ty));
            }
            else
                PFoops (OOPS_FATAL,
                        "Problem with an XPath step: cannot evaluate "
                        "node test `%s'", PFty_str (ty));

            /* because leftjoin does not know that we have
               exactly one match for each tuple in v,
               we need to make the heads void ourselves */
            execute (
                assgn (var (ret_attr->name),
                       reverse (mark (reverse (var (ret_attr->name)),
                                      lit_oid (0)))),
                assgn (var (ret_frag->name),
                       reverse (mark (reverse (var (ret_frag->name)),
                                      lit_oid (0)))),
                assgn (var (ret_iter->name),
                       reverse (mark (reverse (var (ret_iter->name)),
                                      lit_oid (0)))));

            /* The implementation of the attribute path step has to be
               checked in respect to the input and output orderings.
               As long as the check has not be done we choose the safe
               variant of using chk_order instead of assert_order. */
            if (PFord_implies (p->sem.scjoin.out, sortby (p->sem.scjoin.iter)))
                execute (
                    assgn (var (ret_iter->name),
                           chk_order (var (ret_iter->name))));

            env_add (p->env, p->sem.scjoin.iter, aat_nat, ret_iter);

            env_add (p->env, p->sem.scjoin.item, aat_attr, ret_attr);
            env_add (p->env, p->sem.scjoin.item, aat_afrag, ret_frag);

            unpin (tmp, 1);
        }
            break;

        /* Rel:      llscj_child (FragList, Rel) */
        case 83:
            llscj (ax_child, p);
            break;

        /* Rel:      llscj_desc (FragList, Rel) */
        case 84:
            llscj (ax_desc, p);
            break;

        /* Rel:      llscj_desc_self (FragList, Rel) */
        case 85:
            llscj (ax_desc_self, p);
            break;

        /* Rel:      llscj_foll (FragList, Rel) */
        case 86:
            llscj (ax_foll, p);
            break;

        /* Rel:      llscj_foll_sibl (FragList, Rel) */
        case 87:
            llscj (ax_foll_sibl, p);
            break;

        /* Rel:      llscj_parent (FragList, Rel) */
        case 88:
            llscj (ax_parent, p);
            break;

        /* Rel:      llscj_prec (FragList, Rel) */
        case 89:
            llscj (ax_prec, p);
            break;

        /* Rel:      llscj_prec_sibl (FragList, Rel) */
        case 90:
            llscj (ax_prec_sibl, p);
            break;

        /* FragRel:  doc_tbl (Rel) */
        case 100:
        {
            mvar_t *time;

            /* copy the iter BAT */
            mvar_t *iter = env_mvar (L(p)->env, p->sem.ii.iter, aat_nat);

            env_add (p->env, p->sem.ii.iter, aat_nat, iter);
            pin (iter, p->refctr);

            /* add timing information */
            time = new_var (1);
            execute (assgn (var (time->name), usec ()));

            /* temporary variable */
            mvar_t *v = new_var (1);
            /* result BATs */
            mvar_t *frag = new_var (p->refctr);
            mvar_t *pre  = new_var (p->refctr);

            env_add (p->env, p->sem.ii.item, aat_pre, pre);
            env_add (p->env, p->sem.ii.item, aat_pfrag, frag);

            execute (
                 assgn (var (v->name),
                        doc_tbl (var (PF_MIL_VAR_WS),
                                 VAR (L(p)->env, p->sem.ii.item, aat_str))),
                 assgn (var (pre->name), fetch (var (v->name), lit_int (1))),
                 assgn (var (frag->name), fetch (var (v->name), lit_int (2))),
                 assgn (var (PF_MIL_VAR_WS), fetch (var (v->name), lit_int (0)))
                 );

            unpin (v, 1);

            /* add timing information */
            execute (
                assgn (var (PF_MIL_VAR_TIME_LOAD),
                       add (var (PF_MIL_VAR_TIME_LOAD),
                            sub (usec (),
                                 var (time->name)))));
            unpin (time, 1);

        } break;

        /* Rel:      doc_access (FragList, Rel) */
        case 101:
        {
            mvar_t *str   = new_var (p->refctr);

            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                pin (env_at (R(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (R(p)->env, i).att,
                         env_at (R(p)->env, i).ty,
                         env_at (R(p)->env, i).mvar);
            }

            /* lookup the values in the documents using mposjoin */
            switch (p->sem.doc_access.doc_col)
            {
                case (doc_atext):
                    {
                        PFmil_t *attr  = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_attr);
                        PFmil_t *afrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_afrag);

                        execute (
                            assgn (var (str->name),
                                   mposjoin (
                                       mposjoin (
                                           attr,
                                           afrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_ATTR_PROP))),
                                       mposjoin (
                                           attr,
                                           afrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_ATTR_CONT))),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_PROP_VAL)))));
                    }
                    break;
                case (doc_text):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_PROP))),
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_CONT))),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_PROP_TEXT)))));
                    }
                    break;
                case (doc_comm):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_PROP))),
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_CONT))),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_PROP_COM)))));
                    }
                    break;
                case (doc_pi_text):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_PROP))),
                                       mposjoin (
                                           pre,
                                           pfrag,
                                           fetch (var (PF_MIL_VAR_WS),
                                                  var (PF_MIL_VAR_PRE_CONT))),
                                       fetch (var (PF_MIL_VAR_WS),
                                              var (PF_MIL_VAR_PROP_INS)))));
                    }
                    break;
                default:
                    PFoops (OOPS_FATAL,
                            "unexpected document column in doc_access (%i)",
                            p->sem.doc_access.doc_col);
            }

            env_add (p->env, p->sem.doc_access.res, aat_str, str);
        }
            break;

        /* FragRel:  twig (Twig) */
        case 102:
        { /* top-down */
            unsigned int i;
            mvar_t *root_pre, *root_frag, *root_iter,
                   *mmu_res, *seqb, *newPre, *tmp;

            /* backup old twig state before traversing the children... */
            twig_state_t *old_twig_state = twig_state;

            /* ... and create a new one */
            twig_state = PFmalloc (sizeof (twig_state_t));
            twig_state->pre          = 0;
            twig_state->parent       = 0;
            twig_state->size         = 0;
            twig_state->level        = 0;
            twig_state->elem_vars    = PFarray (sizeof (mvar_t *));
            twig_state->attr_vars    = PFarray (sizeof (mvar_t *));
            twig_state->loop         = NULL;
            twig_state->elem_content = false;

            /* translate the child operators */
            reduce(kids[0], nts[0]);

            root_iter = new_var (p->refctr);
            root_pre  = new_var (p->refctr);
            root_frag = new_var (p->refctr);
            mmu_res   = new_var (1);
            seqb      = new_var (1);
            newPre    = new_var (1);

            /* the result of the twig construction will be stored
               in the variables root_iter, root_pre, and root_frag */
            env_add (p->env, p->sem.ii.iter, aat_nat,   root_iter);
            env_add (p->env, p->sem.ii.item, aat_pre,   root_pre);
            env_add (p->env, p->sem.ii.item, aat_pfrag, root_frag);

            /* FIXME: We cannot cope with a single content operator
               that provides only attribute nodes */

            /* merge all input node constructors
               (in the correct order -- the one stored
                in twig_state->elem_vars) */
            if (PFarray_last (twig_state->elem_vars) > 1) {
                mvar_t *mmu_input = new_var (1);

                /* create relation to hold all the input relations
                   for the merged_union operation */
                execute (
                    assgn (var (mmu_input->name),
                           seqbase (new (type (mty_void), type (mty_bat)),
                                    lit_oid (0))));

                /* fill in all input relations (in the correct order) */
                for (i = 0; i < PFarray_last (twig_state->elem_vars); i++) {
                    tmp = *(mvar_t **) PFarray_at (twig_state->elem_vars, i);
                    execute (bappend (var (mmu_input->name), var (tmp->name)));
                    unpin (tmp, 1);
                }

                /* apply merged union operation over multiple inputs */
                execute (
                    assgn (var (mmu_res->name),
                           multi_merged_union (var (mmu_input->name))));
                unpin (mmu_input, 1);

            } else {
                /* no merged_union needed in case we only have a single
                   constructor (with possibly multiple attributes) */
                assert (PFarray_last (twig_state->elem_vars) == 1);
                tmp = *(mvar_t **) PFarray_at (twig_state->elem_vars, 0);

                execute (assgn (var (mmu_res->name), var (tmp->name)));
                unpin (tmp, 1);
            }

            /* Generate the MIL code necessary for document, element,
               textnodes, comments, and processing-instructions */
            execute (

                /* get the offset for the first free node id:
                   seqb := oid (ws.fetch(PRE_SIZE).fetch(WS).count() +
                                ws.fetch(PRE_SIZE).fetch(WS).seqbase().int());
                */
                assgn (var (seqb->name),
                       cast (
                           type (mty_oid),
                           add (
                               count (
                                   fetch (
                                       fetch (
                                           var (PF_MIL_VAR_WS),
                                           var (PF_MIL_VAR_PRE_SIZE)),
                                       var (PF_MIL_VAR_WS_CONT))),
                               cast (
                                   type (mty_int),
                                   seqbase_lookup (
                                       fetch (
                                           fetch (
                                               var (PF_MIL_VAR_WS),
                                               var (PF_MIL_VAR_PRE_SIZE)),
                                           var (PF_MIL_VAR_WS_CONT))))))),
                /* create a column with the new pre numbers:
                   newPre := mmu_res.fetch(0).mark(seqb); */
                assgn (var (newPre->name),
                       mark (
                           fetch (var (mmu_res->name), lit_int (0)),
                           var (seqb->name))),


                /* fill the constructed nodes into the ws */

                /* size:
                   ws.fetch(PRE_SIZE).fetch(WS).append (mmu_res.fetch(2)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_SIZE)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (2))),
                /* level:
                   ws.fetch(PRE_LEVEL).fetch(WS).append (mmu_res.fetch(3)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_LEVEL)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (3))),
                /* kind:
                   ws.fetch(PRE_KIND).fetch(WS).append (mmu_res.fetch(4)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_KIND)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (4))),
                /* prop:
                   ws.fetch(PRE_PROP).fetch(WS).append (mmu_res.fetch(5)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_PROP)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (5))),
                /* cont:
                   ws.fetch(PRE_CONT).fetch(WS).append (mmu_res.fetch(6)); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_CONT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         fetch (var (mmu_res->name), lit_int (6))),
                /* pre_nid:
                   ws.fetch(PRE_NID).fetch(WS).append (newPre); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_NID)),
                             var (PF_MIL_VAR_WS_CONT)),
                         var (newPre->name)),
                /* nid_rid:
                   ws.fetch(NID_RID).fetch(WS).append (newPre); */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_NID_RID)),
                             var (PF_MIL_VAR_WS_CONT)),
                         var (newPre->name)),

                /* select roots and fill environment */

                /* collect new pre values of the root nodes:
                   root_pre := mmu_res.fetch(1).reverse().mark(seqb).reverse()
                                      .ord_uselect(0@0).mark(0@0).reverse(); */
                assgn (var (root_pre->name),
                       reverse (
                           mark (
                               uselect (
                                   reverse (
                                       mark (
                                           reverse (
                                               fetch (
                                                   var (mmu_res->name),
                                                   lit_int (1))),
                                           var (seqb->name))),
                                   lit_oid (0)),
                               lit_oid (0)))),

                /* prepare new iter column:
                   root_iter := root_pre.leftjoin (mmu_res.fetch(0)
                                                          .reverse.mark(seqb)
                                                          .reverse()); */
                assgn (var (root_iter->name),
                       leftjoin (
                           var (root_pre->name),
                           reverse (
                               mark (
                                   reverse (
                                       fetch (
                                           var (mmu_res->name),
                                           lit_int (0))),
                                   var (seqb->name))))),
                /* prepare the new fragment column:
                   root_frag := root_pre.leftjoin (mmu_res.fetch(6)
                                                          .reverse.mark(seqb)
                                                          .reverse()); */
                assgn (var (root_frag->name),
                       leftjoin (
                           var (root_pre->name),
                           reverse (
                               mark (
                                   reverse (
                                       fetch (
                                           var (mmu_res->name),
                                           lit_int (6))),
                                   var (seqb->name))))),

                /* make the fragment boundaries known:
                   ws.fetch(FRAG_ROOT)
                     .fetch(WS)
                     .insert(root_pre.reverse().project(oid_nil).reverse()); */
                binsert (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_FRAG_ROOT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         reverse (
                             project (
                                 reverse (var (root_pre->name)),
                                 lit_oid (0)))) );

            unpin (seqb, 1);

            /* map root attributes (dslink (iter, pre))
               and add them to the ws */
            if (PFarray_last (twig_state->attr_vars)) {
                PFmil_t *bodymilprog, *oldmilprog;
                mvar_t  *a_iter  = new_var (1);
                mvar_t  *a_pre   = new_var (1);
                mvar_t  *a_qn    = new_var (1);
                mvar_t  *a_val   = new_var (1);
                mvar_t  *a_cont  = new_var (1);
                mvar_t  *count   = new_var (1);
                mvar_t  *mapping = new_var (1);
                mvar_t  *sorting = new_var (1);

                /* first collect the overall size */
                execute (assgn (var (count->name), lit_int (0)));
                for (i = 0; i < PFarray_last (twig_state->attr_vars); i++) {
                    tmp = *(mvar_t **) PFarray_at (twig_state->attr_vars, i);
                    execute (assgn (var (count->name),
                                    add (var (count->name),
                                         count (var (tmp->name)))));
                }

                oldmilprog = milprog;
                /* start new milprog for the nesting:
                   'if (...) {...} else {}' */
                milprog = nop ();

                /* create relation to hold all the input relations
                   for the append operation */
                execute (
                    assgn (var (a_iter->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))),
                    assgn (var (a_pre->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))),
                    assgn (var (a_qn->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))),
                    assgn (var (a_val->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))),
                    assgn (var (a_cont->name),
                           seqbase (new (type (mty_void), type (mty_oid)),
                                    lit_oid (0))));

                /* add all possible root attributes
                   (references stored in twig_state->attr_vars) */
                for (i = 0; i < PFarray_last (twig_state->attr_vars); i++) {
                    tmp = *(mvar_t **) PFarray_at (twig_state->attr_vars, i);
                    execute (
                        bappend (var (a_iter->name),
                                 fetch (var (tmp->name), lit_int (0))),
                        bappend (var (a_pre->name),
                                 fetch (var (tmp->name), lit_int (1))),
                        bappend (var (a_qn->name),
                                 fetch (var (tmp->name), lit_int (2))),
                        bappend (var (a_val->name),
                                 fetch (var (tmp->name), lit_int (3))),
                        bappend (var (a_cont->name),
                                 fetch (var (tmp->name), lit_int (4))));
                    unpin (tmp, 1);
                }

                execute (
                    /* collect the references to the parent element nodes:
                       mapping := ds_link (a_iter, mmu_res.fetch(0),
                                           a_pre, mmu_res.fetch(1)); */
                    assgn (var (mapping->name),
                           mc_intersect (
                               arg (
                                   arg (
                                       var (a_iter->name),
                                       fetch (var (mmu_res->name),
                                              lit_int (0))),
                                   arg (
                                       var (a_pre->name),
                                       fetch (var (mmu_res->name),
                                              lit_int (1)))))),

                    /* get the pre values and align them
                       with the attribute values:
                       mapping := a_iter.mirror()
                                        .leftjoin(mapping.join(newPre)); */
                    assgn (var (mapping->name),
                           leftjoin (mirror (var (a_iter->name)),
                                     join (var (mapping->name),
                                           var (newPre->name)))),

                    /* fill the constructed attributes into the ws */

                    /* own:
                       ws.fetch(ATTR_OWN).fetch(WS).append(mapping); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_OWN)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             var (mapping->name)),
                    /* qn:
                       ws.fetch(ATTR_QN).fetch(WS).append(a_qn); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_QN)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             var (a_qn->name)),
                    /* prop:
                       ws.fetch(ATTR_PROP).fetch(WS).append(a_val); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_PROP)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             var (a_val->name)),
                    /* cont:
                       ws.fetch(ATTR_CONT).fetch(WS).append(a_cont); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_CONT)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             var (a_cont->name)));
                unpin (mapping, 1);

                /* check for duplicate attributes and generate
                   a runtime error if duplicates have been found. */
                execute (
                    /* sorting := a_iter.reverse().sort().reverse(); */
                    assgn (
                        var (sorting->name),
                        reverse (sort (reverse (var (a_iter->name)), DIR_ASC))),
                    /* sorting := sorting.CTrefine (a_pre); */
                    assgn (
                        var (sorting->name),
                        ctrefine (
                            var (sorting->name),
                            var (a_pre->name),
                            DIR_ASC)),
                    /* sorting := sorting.CTrefine (
                                              mposjoin (a_qn,
                                                        a_cont,
                                                        ws.fetch(QN_URI))); */
                    assgn (
                        var (sorting->name),
                        ctrefine (
                            var (sorting->name),
                            mposjoin (
                                var (a_qn->name),
                                var (a_cont->name),
                                fetch (
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_QN_URI))),
                            DIR_ASC)),
                    /* sorting := sorting.CTrefine (
                                              mposjoin (a_qn,
                                                        a_cont,
                                                        ws.fetch(QN_LOC))); */
                    assgn (
                        var (sorting->name),
                        ctrefine (
                            var (sorting->name),
                            mposjoin (
                                var (a_qn->name),
                                var (a_cont->name),
                                fetch (
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_QN_LOC))),
                            DIR_ASC)),
                    /* if (sorting.count() != sorting.tunique().count())
                       { ERROR ("..."); } else {} */
                    if_ (not (eq (count (var (sorting->name)),
                              count (tunique (var (sorting->name))))),
                         error (lit_str ("err:XQDY0025: attribute names are not"
                                         " unique in constructed element.")),
                         nop ()));
                unpin (sorting, 1);

                unpin (a_iter, 1);
                unpin (a_pre, 1);
                unpin (a_qn, 1);
                unpin (a_val, 1);
                unpin (a_cont, 1);

                /* store nested MIL code */
                bodymilprog = milprog;
                /* activate old mil program */
                milprog = oldmilprog;

                /* fill in the MIL code for root attributes:
                   if (count > 0) { ... } else { } */
                execute (
                    if_ (gt (var (count->name), lit_int (0)),
                    /* then */ bodymilprog,
                    /* else */ nop ()));

                unpin (count, 1);
            }

            /* collect and update content attributes (mvaljoin) */
            if (twig_state->elem_content) {
                mvar_t *attr = new_var (1);
                mvar_t *item = new_var (1);
                mvar_t *cont = new_var (1);

                execute (
                    /* lookup attribute ids for all subtree nodes:
                       attr := mvaljoin (mmu_res.fetch(7),
                                         mmu_res.fetch(8),
                                         ws.fetch(ATTR_OWN)); */
                    assgn (
                        var (attr->name),
                        mvaljoin (
                            fetch (var (mmu_res->name), lit_int (7)),
                            fetch (var (mmu_res->name), lit_int (8)),
                            fetch (
                                var (PF_MIL_VAR_WS),
                                var (PF_MIL_VAR_ATTR_OWN)))),

                    /* align the resulting attribute ids and the fragment
                       information:
                       item := attr.reverse().mark(0@0).reverse();
                       cont := attr.mark(0@0).reverse()
                                   .leftjoin(mmu_res.fetch(8)); */
                    assgn (var (item->name),
                           reverse (
                               mark (
                                   reverse (
                                       var (attr->name)),
                                   lit_oid (0)))),
                    assgn (var (cont->name),
                           leftjoin (
                               reverse (
                                   mark (
                                       var (attr->name),
                                       lit_oid (0))),
                               fetch (var (mmu_res->name), lit_int (8)))),

                    /* fill the constructed attributes into the ws */

                    /* own:
                       ws.fetch(ATTR_OWN).fetch(WS)
                         .append(attr.mark(0@0).reverse().leftjoin(newPre)); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_OWN)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             leftjoin (
                                 reverse (
                                     mark (
                                         var (attr->name),
                                         lit_oid (0))),
                                 var (newPre->name))),
                    /* qn:
                       ws.fetch(ATTR_QN).fetch(WS)
                         .append(mposjoin(item,cont,ws.fetch(ATTR_QN))); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_QN)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_QN)))),
                    /* prop:
                       ws.fetch(ATTR_PROP).fetch(WS)
                         .append(mposjoin(item,cont,ws.fetch(ATTR_PROP))); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_PROP)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_PROP)))),
                    /* cont:
                       ws.fetch(ATTR_CONT).fetch(WS)
                         .append(mposjoin(item,cont,ws.fetch(ATTR_CONT))); */
                    bappend (fetch (
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_CONT)),
                                 var (PF_MIL_VAR_WS_CONT)),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (
                                     var (PF_MIL_VAR_WS),
                                     var (PF_MIL_VAR_ATTR_CONT)))),
                    );
                unpin (attr, 1);
                unpin (item, 1);
                unpin (cont, 1);
            }

            unpin (mmu_res, 1);
            unpin (newPre, 1);

            /* reset old twig state */
            twig_state = old_twig_state;
        }
            break;

        /* FragRel:  twig (attribute (Rel)) */
        case 103:
        {
            mvar_t *seqb = new_var (1);
            mvar_t *root_attr = new_var (p->refctr);
            mvar_t *root_frag = new_var (p->refctr);
            mvar_t *iter = env_mvar (LL(p)->env,
                                     L(p)->sem.iter_item1_item2.iter,
                                     aat_nat);
            PFmil_t *qn  = VAR (LL(p)->env,
                                L(p)->sem.iter_item1_item2.item1,
                                aat_qname);
            PFmil_t *val = VAR (LL(p)->env,
                                L(p)->sem.iter_item1_item2.item2,
                                aat_str);

            execute (
                /* get first free pre value */
                assgn (var (seqb->name),
                       cast (
                           type (mty_oid),
                           add (
                               count (
                                   fetch (
                                       fetch (
                                           var (PF_MIL_VAR_WS),
                                           var (PF_MIL_VAR_ATTR_OWN)),
                                       var (PF_MIL_VAR_WS_CONT))),
                               cast (
                                   type (mty_int),
                                   seqbase_lookup (
                                       fetch (
                                           fetch (
                                               var (PF_MIL_VAR_WS),
                                               var (PF_MIL_VAR_ATTR_OWN)),
                                           var (PF_MIL_VAR_WS_CONT))))))),
                /* own */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_ATTR_OWN)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (qn, cast (type (mty_oid), nil ()))),
                /* qn */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_ATTR_QN)),
                             var (PF_MIL_VAR_WS_CONT)),
                         qn),
                /* prop */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_ATTR_PROP)),
                             var (PF_MIL_VAR_WS_CONT)),
                         add_content (val,
                                      var (PF_MIL_VAR_WS),
                                      var (PF_MIL_VAR_PROP_VAL))),
                /* cont */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_ATTR_CONT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (qn, var (PF_MIL_VAR_WS_CONT))),

                /* new root pre values */
                assgn (var (root_attr->name),
                       mark (qn, var (seqb->name))),
                /* fragment information */
                assgn (var (root_frag->name),
                       project (qn, var (PF_MIL_VAR_WS_CONT))));

            unpin (seqb, 1);
            pin (iter, p->refctr);
            env_add (p->env, p->sem.ii.iter, aat_nat,   iter);
            env_add (p->env, p->sem.ii.item, aat_attr,  root_attr);
            env_add (p->env, p->sem.ii.item, aat_afrag, root_frag);
        }
            break;

        /* FragRel:  twig (textnode (Rel)) */
        case 104:
        {
            mvar_t *seqb = new_var (1);
            mvar_t *root_pre  = new_var (p->refctr);
            mvar_t *root_frag = new_var (p->refctr);
            mvar_t *iter = env_mvar (LL(p)->env, L(p)->sem.ii.iter, aat_nat);
            PFmil_t *item = VAR (LL(p)->env, L(p)->sem.ii.item, aat_str);

            execute (
                /* get first free pre value */
                assgn (var (seqb->name),
                       cast (
                           type (mty_oid),
                           add (
                               count (
                                   fetch (
                                       fetch (
                                           var (PF_MIL_VAR_WS),
                                           var (PF_MIL_VAR_PRE_SIZE)),
                                       var (PF_MIL_VAR_WS_CONT))),
                               cast (
                                   type (mty_int),
                                   seqbase_lookup (
                                       fetch (
                                           fetch (
                                               var (PF_MIL_VAR_WS),
                                               var (PF_MIL_VAR_PRE_SIZE)),
                                           var (PF_MIL_VAR_WS_CONT))))))),
                /* size */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_SIZE)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (item, lit_int (0))),
                /* level */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_LEVEL)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (item, cast (type (mty_chr), lit_int (0)))),
                /* kind */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_KIND)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (item, var (PF_MIL_VAR_KIND_TEXT))),
                /* prop */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_PROP)),
                             var (PF_MIL_VAR_WS_CONT)),
                         add_content (item,
                                      var (PF_MIL_VAR_WS),
                                      var (PF_MIL_VAR_PROP_TEXT))),
                /* cont */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_CONT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         project (item, var (PF_MIL_VAR_WS_CONT))),
                /* pre_nid */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_PRE_NID)),
                             var (PF_MIL_VAR_WS_CONT)),
                         mark (item, var (seqb->name))),
                /* nid_rid */
                bappend (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_NID_RID)),
                             var (PF_MIL_VAR_WS_CONT)),
                         mark (item, var (seqb->name))),

                /* new root pre values */
                assgn (var (root_pre->name),
                       mark (item, var (seqb->name))),
                /* fragment information */
                assgn (var (root_frag->name),
                       project (item, var (PF_MIL_VAR_WS_CONT))),

                /* make the fragment boundaries known */
                binsert (fetch (
                             fetch (
                                 var (PF_MIL_VAR_WS),
                                 var (PF_MIL_VAR_FRAG_ROOT)),
                             var (PF_MIL_VAR_WS_CONT)),
                         reverse (
                             project (
                                 reverse (var (root_pre->name)),
                                 lit_oid (0)))));

            unpin (seqb, 1);
            pin (iter, p->refctr);
            env_add (p->env, p->sem.ii.iter, aat_nat,   iter);
            env_add (p->env, p->sem.ii.item, aat_pre,   root_pre);
            env_add (p->env, p->sem.ii.item, aat_pfrag, root_frag);
        }
            break;

        /* Fcns:     fcns (Twig, Fcns) */
        case 105:
        { /* top-down */

            /* traverse the DAG in sequence order */
            reduce(kids[0], nts[0]);
            reduce(kids[1], nts[1]);

            /* propagate the size information of the content
               operators underneath */
            if (env_count (L(p)->env) &&
                env_count (R(p)->env)) {
                mvar_t *v = new_var (1);
                mvar_t *l = env_at (L(p)->env, 0).mvar;
                mvar_t *r = env_at (R(p)->env, 0).mvar;

                assert (env_count (L(p)->env) == 1);
                assert (env_count (R(p)->env) == 1);

                execute (
                    assgn (var (v->name),
                           madd (var (l->name), var (r->name))));

                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         v);

            } else if (env_count (L(p)->env)) {

                assert (env_count (L(p)->env) == 1);
                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         env_at (L(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else if (env_count (R(p)->env)) {

                assert (env_count (R(p)->env) == 1);
                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);
            }
        }
            break;

        /* Fcns:     fcns (Twig, nil) */
        case 106:
            /* propagate the size information of the content
               operators underneath */
            if (env_count (L(p)->env)) {
                assert (env_count (L(p)->env) == 1);
                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         env_at (L(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);
            }
            break;

        /* Twig:     docnode (Rel, fcns (nil, nil)) */
        case 107:
        {
            mvar_t  *v = new_var (1);
            PFmil_t *iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);

            execute (
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->pre))),
                /* size */
                bappend (var (v->name),
                         project (iter, lit_int (0))),
                /* level */
                bappend (var (v->name),
                         project (iter,
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_DOC))),
                /* prop */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
            twig_state->pre++;
            twig_state->size++;
        }
            break;

        /* Twig:     docnode (Rel, Fcns) */
        case 108:
        { /* top-down */
            unsigned int old_twig_state_pre,
                         old_twig_state_parent,
                         old_twig_state_size;
            mvar_t  *v = new_var (1);
            mvar_t  *size = new_var (1);
            PFmil_t *iter;

            /* translate the qnames */
            reduce(kids[0], nts[0]);

            iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);

            /* add the element representation into the ordered
               twig state list to ensure that the constructed node
               appears before all children */
            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;

            /* store the twig state information
               and prepare for the translation of the children */
            old_twig_state_pre    = twig_state->pre;
            old_twig_state_parent = twig_state->parent;
            old_twig_state_size   = twig_state->size;

            twig_state->parent = twig_state->pre;
            twig_state->pre++;
            twig_state->size = 0;
            twig_state->level++;
            /* Use the iter column of the root twig operator
               as loop relation for the content operator.

               NOTE: We have to use the root twig operator
               (the one the content operator is nested in)
               as otherwise the variable stored in twig_state->loop
               might not be pinned anymore before the content operator
               can use it. */
            if (!twig_state->loop)
                twig_state->loop = iter;

            /* translate the children */
            reduce(kids[1], nts[1]);

            /* reset the level information */
            twig_state->level--;

            /* calculate the sizes */
            if (env_count (R(p)->env) && twig_state->size) {
                mvar_t *content_size = env_at (R(p)->env, 0).mvar;

                assert (env_count (R(p)->env) == 1);

                execute (
                    assgn (var (size->name),
                           madd (var (content_size->name),
                                 lit_int (twig_state->size))));

                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else if (env_count (R(p)->env)) {
                mvar_t *content_size = env_at (R(p)->env, 0).mvar;

                assert (env_count (R(p)->env) == 1);

                execute (
                    assgn (var (size->name),
                           var (content_size->name)));

                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else {
                execute (
                    assgn (var (size->name),
                           project (iter, lit_int (twig_state->size))));
            }

            execute (
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (old_twig_state_pre))),
                /* size */
                bappend (var (v->name), var (size->name)),
                /* level */
                bappend (var (v->name),
                         project (iter,
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_DOC))),
                /* prop */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            unpin (size, 1);

            twig_state->size = twig_state->size + old_twig_state_size + 1;
            twig_state->parent = old_twig_state_parent;
        }
            break;

        /* Twig:     element (Rel, fcns (nil, nil)) */
        case 109:
        {
            mvar_t  *v = new_var (1);
            PFmil_t *iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);
            PFmil_t *item = VAR (L(p)->env, p->sem.ii.item, aat_qname);

            execute (
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->pre))),
                /* size */
                bappend (var (v->name),
                         project (iter, lit_int (0))),
                /* level */
                bappend (var (v->name),
                         project (iter,
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_ELEM))),
                /* prop */
                bappend (var (v->name), item),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
            twig_state->pre++;
            twig_state->size++;
        }
            break;

        /* Twig:     element (Rel, Fcns) */
        case 110:
        { /* top-down */
            unsigned int old_twig_state_pre,
                         old_twig_state_parent,
                         old_twig_state_size;
            mvar_t  *v = new_var (1);
            mvar_t  *size = new_var (1);
            PFmil_t *iter, *item;

            /* translate the qnames */
            reduce(kids[0], nts[0]);
            
            iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);
            item = VAR (L(p)->env, p->sem.ii.item, aat_qname);
            
            /* add the element representation into the ordered
               twig state list to ensure that the constructed node
               appears before all children */
            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
            
            /* store the twig state information
               and prepare for the translation of the children */ 
            old_twig_state_pre    = twig_state->pre;
            old_twig_state_parent = twig_state->parent;
            old_twig_state_size   = twig_state->size;

            twig_state->parent = twig_state->pre;
            twig_state->pre++;
            twig_state->size = 0;
            twig_state->level++;
            /* Use the iter column of the root twig operator
               as loop relation for the content operator.
               
               NOTE: We have to use the root twig operator 
               (the one the content operator is nested in)
               as otherwise the variable stored in twig_state->loop
               might not be pinned anymore before the content operator
               can use it. */
            if (!twig_state->loop)
                twig_state->loop = iter;
            
            /* translate the children */
            reduce(kids[1], nts[1]);
            
            /* reset the level information */
            twig_state->level--;
            
            /* calculate the sizes */
            if (env_count (R(p)->env) && twig_state->size) {
                mvar_t *content_size = env_at (R(p)->env, 0).mvar;
                
                assert (env_count (R(p)->env) == 1);
                
                execute (
                    assgn (var (size->name),
                           madd (var (content_size->name),
                                 lit_int (twig_state->size))));

                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else if (env_count (R(p)->env)) {
                mvar_t *content_size = env_at (R(p)->env, 0).mvar;
                
                assert (env_count (R(p)->env) == 1);
                
                execute (
                    assgn (var (size->name),
                           var (content_size->name)));

                env_add (p->env,
                         env_at (R(p)->env, 0).att,
                         env_at (R(p)->env, 0).ty,
                         env_at (R(p)->env, 0).mvar);
                pin (env_at (p->env, 0).mvar, 1);

            } else {
                execute (
                    assgn (var (size->name),
                           project (iter, lit_int (twig_state->size))));
            }

            execute (
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (old_twig_state_pre))),
                /* size */
                bappend (var (v->name), var (size->name)),
                /* level */
                bappend (var (v->name),
                         project (iter, 
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_ELEM))),
                /* prop */
                bappend (var (v->name), item),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));
                        
            unpin (size, 1);
                        
            twig_state->size = twig_state->size + old_twig_state_size + 1;
            twig_state->parent = old_twig_state_parent;
        }
            break;
        
        /* Twig:     attribute (Rel) */
        case 111:
        {
            mvar_t  *v = new_var (1);
            mvar_t  *prop = new_var (1);
            PFmil_t *iter = VAR (L(p)->env,
                                 p->sem.iter_item1_item2.iter,
                                 aat_nat);
            PFmil_t *qn   = VAR (L(p)->env, 
                                 p->sem.iter_item1_item2.item1,
                                 aat_qname);
            PFmil_t *val  = VAR (L(p)->env,
                                 p->sem.iter_item1_item2.item2,
                                 aat_str);

            execute (
                assgn (var (prop->name),
                       add_content (val, 
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PROP_VAL))),
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre (parent) */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->parent))),
                /* qname */
                bappend (var (v->name), qn),
                /* value */
                bappend (var (v->name), var (prop->name)),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))));
                        
            unpin (prop, 1);
                        
            *(mvar_t **) PFarray_add (twig_state->attr_vars) = v;
        }
            break;
        
        /* Twig:     textnode (Rel) */
        case 112:
        {
            mvar_t  *v = new_var (1);
            mvar_t  *prop = new_var (1);
            PFmil_t *iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);
            PFmil_t *item = VAR (L(p)->env, p->sem.ii.item, aat_str);

            execute (
                assgn (var (prop->name),
                       add_content (item, 
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PROP_TEXT))),
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->pre))),
                /* size */
                bappend (var (v->name),
                         project (iter, lit_int (0))),
                /* level */
                bappend (var (v->name),
                         project (iter, 
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_TEXT))),
                /* prop */
                bappend (var (v->name), var (prop->name)),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));
                        
            unpin (prop, 1);
                        
            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
            twig_state->pre++;
            twig_state->size++;
        }
            break;
        
        /* Twig:     comment (Rel) */
        case 113:
        {
            mvar_t  *v = new_var (1);
            mvar_t  *prop = new_var (1);
            PFmil_t *iter = VAR (L(p)->env, p->sem.ii.iter, aat_nat);
            PFmil_t *item = VAR (L(p)->env, p->sem.ii.item, aat_str);

            execute (
                assgn (var (prop->name),
                       add_content (item, 
                                    var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PROP_COM))),
                assgn (var (v->name),
                       seqbase (new (type (mty_void), type (mty_bat)),
                                lit_oid (0))),
                /* iter */
                bappend (var (v->name), iter),
                /* pre */
                bappend (var (v->name),
                         project (iter, lit_oid (twig_state->pre))),
                /* size */
                bappend (var (v->name),
                         project (iter, lit_int (0))),
                /* level */
                bappend (var (v->name),
                         project (iter, 
                                  cast (type (mty_chr),
                                        lit_int (twig_state->level)))),
                /* kind */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_KIND_COM))),
                /* prop */
                bappend (var (v->name), var (prop->name)),
                /* cont */
                bappend (var (v->name),
                         project (iter, var (PF_MIL_VAR_WS_CONT))),
                /* old_pre */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))),
                /* old_cont */
                bappend (var (v->name),
                         project (iter, cast (type (mty_oid), nil ()))));

            unpin (prop, 1);
                        
            *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
            twig_state->pre++;
            twig_state->size++;
        }
            break;
        
        /* Twig:     processi (Rel) */
        case 114:
            assert (!"not implemented yet");
            break;
        
        /* Twig:     content (FragRel, Rel) */
        case 115:
        {
            PFalg_simple_type_t item_ty = 0;
            mvar_t *a_iter = NULL, *a_item = NULL, *a_cont = NULL,
                   *p_iter = NULL, *p_item = NULL, *p_cont = NULL;
            bool treat_attr = false, treat_pre = false;
            
            /* look up item type */
            for (unsigned int i = 0; i < R(p)->schema.count; i++)
                if (p->sem.ii.item == R(p)->schema.items[i].name) {
                    item_ty = R(p)->schema.items[i].type;
                    break;
                }
            assert (item_ty);

            /* based on the item type treat only attributes or other nodes */
            if (item_ty == aat_pnode) {
                treat_pre = true;
                p_iter = env_mvar (R(p)->env, p->sem.ii.iter, aat_nat);
                p_item = env_mvar (R(p)->env, p->sem.ii.item, aat_pre);
                p_cont = env_mvar (R(p)->env, p->sem.ii.item, aat_pfrag);
            } else if (item_ty == aat_anode) {
                treat_attr = true;
                a_iter = env_mvar (R(p)->env, p->sem.ii.iter, aat_nat);
                a_item = env_mvar (R(p)->env, p->sem.ii.item, aat_attr);
                a_cont = env_mvar (R(p)->env, p->sem.ii.item, aat_afrag);
            } else /* mixed content */ {
                mvar_t *iter, *tmp;
                treat_pre  = true;
                treat_attr = true;
                p_iter = new_var (1);
                p_item = new_var (1);
                p_cont = new_var (1);
                a_iter = new_var (1);
                a_item = new_var (1);
                a_cont = new_var (1);
                
                iter = env_mvar (R(p)->env, p->sem.ii.iter, aat_nat);
                /* split up by nodes... */
                
                /* p_item := pre.select(oid_nil, oid_nil);
                   p_iter := p_item.reverse().leftjoin (iter)
                                   .reverse().mark(0@0).reverse();
                   p_item := p_item.reverse().mark(0@0).reverse(); */
                tmp = env_mvar (R(p)->env, p->sem.ii.item, aat_pre);
                execute (
                    assgn (
                        var (p_item->name),
                        select2 (
                            var (tmp->name),
                            cast (type (mty_oid), nil ()),
                            cast (type (mty_oid), nil ()))),
                    assgn (
                        var (p_iter->name),
                        reverse (
                            mark (
                                reverse (
                                    leftjoin (
                                        reverse (
                                            var (p_item->name)),
                                        var (iter->name))),
                                lit_oid (0)))),
                    assgn (
                        var (p_item->name),
                        reverse (
                            mark (
                                reverse (
                                    var (p_item->name)),
                                lit_oid (0)))));
                /* p_cont := pfrag.select(oid_nil, oid_nil).tmark(0@0); */
                tmp = env_mvar (R(p)->env, p->sem.ii.item, aat_pfrag);
                execute (
                    assgn (
                        var (p_cont->name),
                        reverse (
                            mark (
                                reverse (
                                    select2 (
                                        var (tmp->name),
                                        cast (type (mty_oid), nil ()),
                                        cast (type (mty_oid), nil ()))),
                                lit_oid (0)))));

                /* ... and attributes */
                        
                /* a_item := attr.select(oid_nil, oid_nil);
                   a_iter := a_item.reverse().leftjoin (iter)
                                   .reverse().mark(0@0).reverse();
                   a_item := a_item.reverse().mark(0@0).reverse(); */
                tmp = env_mvar (R(p)->env, p->sem.ii.item, aat_attr);
                execute (
                    assgn (
                        var (a_item->name),
                        select2 (
                            var (tmp->name),
                            cast (type (mty_oid), nil ()),
                            cast (type (mty_oid), nil ()))),
                    assgn (
                        var (a_iter->name),
                        reverse (
                            mark (
                                reverse (
                                    leftjoin (
                                        reverse (
                                            var (a_item->name)),
                                        var (iter->name))),
                                lit_oid (0)))),
                    assgn (
                        var (a_item->name),
                        reverse (
                            mark (
                                reverse (
                                    var (a_item->name)),
                                lit_oid (0)))));
                /* a_cont := afrag.select(oid_nil, oid_nil).tmark(0@0); */
                tmp = env_mvar (R(p)->env, p->sem.ii.item, aat_afrag);
                execute (
                    assgn (
                        var (a_cont->name),
                        reverse (
                            mark (
                                reverse (
                                    select2 (
                                        var (tmp->name),
                                        cast (type (mty_oid), nil ()),
                                        cast (type (mty_oid), nil ()))),
                                lit_oid (0)))));
            }
            
            /* first handle root attributes */
            if (treat_attr) {
                mvar_t  *v = new_var (1);

                /* collect attribute names, values, and container... */
                execute (
                    assgn (var (v->name),
                           seqbase (new (type (mty_void), type (mty_bat)),
                                    lit_oid (0))),
                    /* iter */
                    bappend (var (v->name), var (a_iter->name)),
                    /* pre (parent) */
                    bappend (var (v->name),
                             project (var (a_iter->name),
                                      lit_oid (twig_state->parent))),
                    /* qname */
                    bappend (var (v->name),
                             mposjoin (
                                 var (a_item->name),
                                 var (a_cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_ATTR_QN)))),
                    /* value */
                    bappend (var (v->name),
                             mposjoin (
                                 var (a_item->name),
                                 var (a_cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_ATTR_PROP)))),
                    /* cont */
                    bappend (var (v->name),
                             mposjoin (
                                 var (a_item->name),
                                 var (a_cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_ATTR_CONT)))));

                /* ... and add them to list of root attributes */ 
                *(mvar_t **) PFarray_add (twig_state->attr_vars) = v;
            }
            
            if (treat_pre) {
                mvar_t  *unq_iter, *scj_res, *root_level, *content_level;
                mvar_t  *iter = new_var (1);
                mvar_t  *item = new_var (1);
                mvar_t  *cont = new_var (1);
                mvar_t  *v    = new_var (1);

                unq_iter = new_var (1);
                scj_res  = new_var (1);
                /* evaluate descendant-or-self::node() step:
                   unq_iter := p_iter.mirror();
                   scj_res := loop_lifted_descendant_or_self_step (
                                  p_iter, p_item, p_cont, ws, 0);
                   iter := scj_res.fetch(0);
                   item := scj_res.fetch(1);
                   # cont is probably a fake project
                   cont := scj_res.fetch(2);
                   # avoid iter being a fake project
                   iter := materialize(iter, item); */
                execute (
                    assgn (
                        var (unq_iter->name),
                        mirror (var (p_iter->name))),
                    assgn (
                        var (scj_res->name),
                        llscj_desc_self (
                            var (unq_iter->name),
                            var (p_item->name),
                            var (p_cont->name),
                            var (PF_MIL_VAR_WS),
                            lit_int (0))),
                    assgn (
                        var (iter->name),
                        fetch(var (scj_res->name), lit_int (0))),
                    assgn (
                        var (item->name),
                        fetch(var (scj_res->name), lit_int (1))),
                    assgn (
                        var (cont->name),
                        fetch(var (scj_res->name), lit_int (2))),
                    assgn (
                        var (iter->name),
                        materialize (
                            var (iter->name),
                            var (item->name))));
                unpin (unq_iter, 1);
                unpin (scj_res, 1);
                    
                root_level    = new_var (1);
                content_level = new_var (1);
                /* collect node values and insert them into
                   list of twig constructors:
                   v := new(void, bat).seqbase(0@0);
                   v.append(iter.leftjoin(p_iter).chk_order());
                   v.append(item.project(%twig_state->pre%));
                   v.append(mposjoin(item,cont,ws.fetch(PRE_SIZE)));
                   root_level := mposjoin(p_item,p_cont,ws.fetch(PRE_LEVEL));
                   # map root_level to the correct cardinality
                   root_level := iter.leftjoin(root_level);
                   content_level := mposjoin(item,cont,ws.fetch(PRE_LEVEL)); 
                   content_level := [-](content_level, root_level);
                   content_level := [+](content_level, %twig_state->level%);
                   v.append(content_level);
                   v.append(mposjoin(item,cont,ws.fetch(PRE_KIND)));
                   v.append(mposjoin(item,cont,ws.fetch(PRE_PROP)));
                   v.append(mposjoin(item,cont,ws.fetch(PRE_CONT)));
                   v.append(item);
                   # avoid cont being a fake project
                   v.append(materialize (cont, item));
                   */
                execute (
                    assgn (var (v->name),
                           seqbase (new (type (mty_void), type (mty_bat)),
                                    lit_oid (0))),
                    /* iter */
                    bappend (var (v->name), 
                             chk_order (
                                 leftjoin (
                                     var (iter->name),
                                     var (p_iter->name)))),
                    /* pre */
                    bappend (var (v->name),
                             project (
                                 var (item->name),
                                 lit_oid (twig_state->pre))),
                    /* size */
                    bappend (var (v->name),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_SIZE)))),
                    /* level */
                    assgn (
                        var (root_level->name),
                         mposjoin (
                             var (p_item->name),
                             var (p_cont->name),
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PRE_LEVEL)))),
                    assgn (
                        var (root_level->name),
                        leftjoin (
                            var (iter->name),
                            var (root_level->name))),
                    assgn (
                        var (content_level->name),
                         mposjoin (
                             var (item->name),
                             var (cont->name),
                             fetch (var (PF_MIL_VAR_WS),
                                    var (PF_MIL_VAR_PRE_LEVEL)))),
                    assgn (
                        var (content_level->name),
                        msub (
                            var (content_level->name),
                            var (root_level->name))),
                    assgn (
                        var (content_level->name),
                        madd (
                            var (content_level->name),
                            cast (
                                type (mty_chr),
                                lit_int (twig_state->level)))),
                    bappend (var (v->name),
                             var (content_level->name)),
                    /* kind */
                    bappend (var (v->name),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_KIND)))),
                    /* prop */
                    bappend (var (v->name),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_PROP)))),
                    /* cont */
                    bappend (var (v->name),
                             mposjoin (
                                 var (item->name),
                                 var (cont->name),
                                 fetch (var (PF_MIL_VAR_WS),
                                        var (PF_MIL_VAR_PRE_CONT)))),
                    /* old_pre */
                    bappend (var (v->name),
                             var (item->name)),
                    /* old_cont */
                    bappend (var (v->name),
                             materialize (
                                 var (cont->name),
                                 var (item->name))));
                unpin (root_level, 1);
                unpin (content_level, 1);
                unpin (iter, 1);
                unpin (item, 1);
                unpin (cont, 1);
                        
                *(mvar_t **) PFarray_add (twig_state->elem_vars) = v;
                twig_state->pre++;
                /* tell the twig constructor to handle
                   subtree attribute copies */
                twig_state->elem_content = true;
                
                /* add summed sizes to the environment */
                if (twig_state->loop) {
                    mvar_t *sizes = new_var (1);
                    mvar_t *gsize = new_var (1);

                    /* sizes := mposjoin(p_item,p_cont,ws.fetch(PRE_SIZE);
                       # don't forget the node itself
                       sizes := [+](sizes, 1);
                       sizes := p_iter.reverse().leftjoin(sizes);
                       gsize := {sum}(sizes,%twig_state->loop%.reverse());
                       # map back to head values
                       sizes := %twig_state->loop%.leftjoin(gsize); */
                    execute (
                        assgn (
                            var (sizes->name),
                            mposjoin (
                                var (p_item->name),
                                var (p_cont->name),
                                fetch (var (PF_MIL_VAR_WS),
                                       var (PF_MIL_VAR_PRE_SIZE)))),
                        assgn (
                            var (sizes->name),
                            madd (var (sizes->name), lit_int (1))),
                        assgn (
                            var (sizes->name),
                            leftjoin (
                                reverse (var (p_iter->name)),
                                var (sizes->name))),
                        assgn (
                            var (gsize->name),
                            egsum (
                                var (sizes->name),
                                reverse (twig_state->loop))),
                        assgn (
                            var (gsize->name),
                            leftjoin (
                                twig_state->loop,
                                var (gsize->name))));
                    unpin (sizes, 1);
                    /* add the grouped sizes to the variable environment */
                    env_add (p->env, att_NULL, aat_int, gsize);
                }
            }

            if (treat_pre && treat_attr) {
                unpin (p_iter, 1);
                unpin (p_item, 1);
                unpin (p_cont, 1);
                unpin (a_iter, 1);
                unpin (a_item, 1);
                unpin (a_cont, 1);
            }
        }
            break;
        
        /* Rel:      merge_adjacent (FragList, Rel) */
        case 116:
        {
            PFmil_t *iter = NULL, *pre = NULL, *pfrag = NULL;

            /* copy all the existing variables */
            for (unsigned int i = 0; i < PFarray_last (R(p)->env); i++) {
                env_t entry = env_at (R(p)->env, i);

                if (entry.att == p->sem.ii.iter && entry.ty == aat_nat) {
                    iter = var (entry.mvar->name);
                    env_add (p->env, entry.att, entry.ty, entry.mvar);
                    pin (entry.mvar, p->refctr);
                }
                else if (entry.att == p->sem.ii.item && entry.ty == aat_pre)
                    pre = var (entry.mvar->name);
                else if (entry.att == p->sem.ii.item &&
                         entry.ty == aat_pfrag)
                    pfrag = var (entry.mvar->name);
                else {
                    env_add (p->env, entry.att, entry.ty, entry.mvar);
                    pin (entry.mvar, p->refctr);
                }
            }
            assert (iter && pre && pfrag);

            mvar_t *v  = new_var (1);
            mvar_t *res_pre = new_var (p->refctr);
            mvar_t *res_frag = new_var (p->refctr);

            execute (
                assgn (var (v->name),
                       merge_adjacent (iter, pre, pfrag, var (PF_MIL_VAR_WS))),
                assgn (var (res_pre->name), 
                       fetch (var (v->name), lit_oid (1))),
                assgn (var (res_frag->name), 
                       fetch (var (v->name), lit_oid (2))),
                assgn (var (PF_MIL_VAR_WS), 
                       fetch (var (v->name), lit_oid (0))));

            unpin (v, 1);
            env_add (p->env, p->sem.ii.item, aat_pre, res_pre);
            env_add (p->env, p->sem.ii.item, aat_pfrag, res_frag);

        } break;

        /* Rel:      roots (FragRel) */
        case 120:
            /* copy all the attributes from our argument */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                pin (env_at (L(p)->env, i).mvar, p->refctr);

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Frag:     fragment (FragRel) */
        case 121:
            break;

        /* FragList: frag_union (FragList, Frag) */
        case 122:
            break;

        /* FragList: empty_frag */
        case 123:
            break;

        /* Rel:      cond_err (Rel, Rel) */
        case 130:
            execute (
                if_ (exist (reverse (VAR (R(p)->env, p->sem.err.att, aat_bln)),
                            lit_bit (false)),
                     error (lit_str (p->sem.err.str)),
                     nop ()));
                       
            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Rel:      cond_err (Rel, empty_tbl) */
        case 131:
            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;
            
        /* Rel:      trace (Rel, trace_msg (Rel, Map)) */
        case 135:
        /* Rel:      trace (Rel, trace_msg (Rel, nil)) */
        case 136:
        {
            unsigned trace_id = new_trace_id ();
            PFmil_t *iter = NULL,
                    *item = NULL;
            
            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);

                /* as a side effect fill in the trace information */ 
                if (env_at (L(p)->env, i).att == p->sem.ii.iter) {
                    /* fill in the iter information */
                    execute (
                        insert (var (PF_MIL_VAR_TRACE_ITER),
                                lit_oid (trace_id),
                                var (env_at (L(p)->env, i).mvar->name)));
                }
                else if (env_at (L(p)->env, i).att == p->sem.ii.item) {
                    /* fill in the item information */
                    execute (
                        insert (var (PF_MIL_VAR_TRACE_ITEM),
                                lit_oid (trace_id),
                                var (env_at (L(p)->env, i).mvar->name)),
                        insert (var (PF_MIL_VAR_TRACE_TYPE),
                                lit_oid (trace_id),
                                lit_int (env_at (L(p)->env, i).ty)));
                }
            }

            /* collect the message information */
            iter = VAR (RL(p)->env, R(p)->sem.ii.iter, aat_nat);
            assert (iter);
            item = VAR (RL(p)->env, R(p)->sem.ii.item, aat_str);
            assert (item);
            
            execute (
                insert (var (PF_MIL_VAR_TRACE_MSG),
                        lit_oid (trace_id),
                        leftjoin (reverse (iter), item)));

            /* fill in the relationship between the trace and the
               last map relation */
            if (RR(p)->kind == pa_nil)
                execute (
                    insert (var (PF_MIL_VAR_TRACE_REL),
                            lit_oid (0),
                            lit_oid (trace_id)));
            else
                execute (
                    insert (var (PF_MIL_VAR_TRACE_REL),
                            lit_oid (RR(p)->sem.trace_map.trace_id),
                            lit_oid (trace_id)));
        }   break;

        /* Map:      trace_map (Rel, Map) */
        case 137:
        /* Map:      trace_map (Rel, nil) */
        case 138:
        {
            unsigned trace_id = new_trace_id ();
            /* store the trace_id */
            p->sem.trace_map.trace_id = trace_id;
            
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                if (env_at (L(p)->env, i).att == p->sem.trace_map.outer) {
                    /* fill in the iter information */
                    execute (
                        insert (var (PF_MIL_VAR_TRACE_OUTER),
                                lit_oid (trace_id),
                                var (env_at (L(p)->env, i).mvar->name)));
                }
                else if (env_at (L(p)->env, i).att == p->sem.trace_map.inner) {
                    /* fill in the item information */
                    execute (
                        insert (var (PF_MIL_VAR_TRACE_INNER),
                                lit_oid (trace_id),
                                var (env_at (L(p)->env, i).mvar->name)));
                }
            }

            /* fill in the relationship between the map relations */
            if (R(p)->kind == pa_nil)
                execute (
                    insert (var (PF_MIL_VAR_TRACE_REL),
                            lit_oid (0),
                            lit_oid (trace_id)));
            else
                execute (
                    insert (var (PF_MIL_VAR_TRACE_REL),
                            lit_oid (R(p)->sem.trace_map.trace_id),
                            lit_oid (trace_id)));
        }   break;
            
        /* Rel:      rec_fix (Rec, Rel) */
        case 140:
        {
            PFmil_t *oldmilprog, *bodymilprog;
            PFarray_t *res_env;
            mvar_t *old_count, *new_count;
            PFarray_t *border_vars = PFarray (sizeof (mvar_t *));
            
            /* Generate code for the seeds and bind them to the new variables.
               In addition generate code for all expressions that are 
               invariant to the recursion body (all expressions underneath
               a rec_border operator) and pin the variables holding the 
               results once more such they are not released in the recursion
               body (references stored in border_vars). */
            reduce1(kids[0], nts[0], border_vars);
           
            old_count = new_var (1);
            new_count = new_var (1);

            /* initialize the result counters */
            execute (
                assgn (var (old_count->name), 
                       lit_int (-1)),
                assgn (var (new_count->name), 
                       lit_int (0)));
                       
            /* save the current mil program */
            oldmilprog = milprog;
           
            /* create a new empty milprog */
            milprog = nop ();
           
            /* translate the recursion body and 
               reassign the recursion variables */
            reduce2(kids[0], nts[0]);
           
            /* get the result environment */
            reduce(kids[1], nts[1]);
            res_env = R(p)->env;

            /* update the result counters */
            execute (
                assgn (var (old_count->name), 
                       var (new_count->name)),
                assgn (var (new_count->name),
                       count (var (env_at (res_env, 0).mvar->name))));

            /* make the old mil program the active one */
            bodymilprog = milprog;
            milprog = oldmilprog;
           
            /* apply the while statement */
            execute (
                while_ (
                  gt (var (new_count->name),
                      var (old_count->name)),
                  bodymilprog));

            /* the condition variables are not needed anymore */
            unpin (new_count, 1);
            unpin (old_count, 1);
            
            /* copy all the result attributes */
            for (unsigned int i = 0; i < env_count (res_env); i++) {
                pin (env_at (res_env, i).mvar,
                     p->refctr);
                
                env_add (p->env,
                         env_at (res_env, i).att,
                         env_at (res_env, i).ty,
                         env_at (res_env, i).mvar);
            }
            
            /* release the additional pins of the variables
               representing the recursion invariant expressions */
            for (unsigned int i = 0; i < PFarray_last (border_vars); i++)
                unpin (*(mvar_t **) PFarray_at (border_vars, i), 1);
            
            /* release all the pins of the while loop arguments */
            reduce3(kids[0], nts[0]);

            /* ensure that the child of p (the first argument) still
               has one pin left to release (see bottom of function reduce) */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++)
                pin (env_at (L(p)->env, i).mvar, 1);
        } break;

        /* Rec:      rec_param (rec_arg (Rel, Rel), Rec) */
        case 141:
        /* Rec:      rec_param (rec_arg (empty_tbl, Rel), Rec) */
        case 142:
        /* Rec:      nil */
        case 143:
            /* the rules are called via reduce1, reduce2, and reduce3 */
            break;

        /* Rel:      rec_base */
        case 144:
            /* no MIL code needed */

            /* The environment already contains the bindings.
               See rules:
                  rec_param (rec_arg (Rel, Rel), Rec)
                and
                  rec_param (rec_arg (empty_tbl, Rel), Rec))
                in function reduce1 */
            break;

        /* Rel:      rec_border (Rel) */
        case 145:
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Rel:      string_join (Rel, Rel) */
        case 150:
        {
            mvar_t *str  = new_var (1);
            mvar_t *iter = new_var (p->refctr);
            mvar_t *item = new_var (p->refctr);

            execute (
                assgn (var (str->name),
                       string_join (
                           leftjoin (
                               reverse (VAR(L(p)->env,
                                            p->sem.ii.iter,
                                            aat_nat)),
                               VAR(L(p)->env, p->sem.ii.item, aat_str)),
                           leftjoin (
                               reverse (VAR(R(p)->env,
                                            p->sem.ii.iter,
                                            aat_nat)),
                               VAR(R(p)->env, p->sem.ii.item, aat_str)))),
                assgn (var (iter->name), 
                       reverse (mark (var (str->name), lit_oid (0)))),
                assgn (var (item->name), 
                       reverse (
                           mark (reverse (var (str->name)), lit_oid (0)))));

            unpin (str, 1);
            env_add (p->env, p->sem.ii.iter, aat_nat, iter);
            env_add (p->env, p->sem.ii.item, aat_str, item);
        }
            break;

        default:
            PFoops (OOPS_FATAL, "unknown rule %u", rule);
            break;
    }

    for (unsigned short c = 0; nts[c]; c++)
        for (unsigned int i = 0; i < PFarray_last (kids[c]->env); i++)
            unpin (((env_t *) PFarray_at (kids[c]->env, i))->mvar, 1);

#ifndef NDEBUG
    execute (comment ("End rule: \"%s\"", PFmilgen_string[rule]));

    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

}

static PFalg_simple_type_t
type_of (PFpa_op_t *n, PFalg_att_t att)
{
    assert (n);

    for (unsigned int i = 0; i < n->schema.count; i++)
        if (n->schema.items[i].name == att)
            return n->schema.items[i].type;

    PFoops (OOPS_FATAL,
            "cannot determine implementation type of algebra expression");

    assert (0); /* never reached due to "exit" in "PFoops" */
    return aat_nat; /* pacify picky compilers */
}


/**
 * Compile a physical algebra literal value into its MIL equivalent.
 */
static PFmil_t *
literal (PFalg_atom_t atom)
{
    switch (atom.type) {

        case aat_nat:  return lit_oid (atom.val.nat_);
        case aat_int:  return lit_lng (atom.val.int_);
        case aat_uA:
        case aat_str:  return lit_str (atom.val.str);
        case aat_dec:  return lit_dbl (atom.val.dec_);
        case aat_dbl:  return lit_dbl (atom.val.dbl);
        case aat_bln:  return lit_bit (atom.val.bln);
        case aat_qname:  
            return add_qname (lit_str (PFqname_prefix (atom.val.qname)),
                              lit_str (PFqname_uri (atom.val.qname)),
                              lit_str (PFqname_loc (atom.val.qname)),
                              var (PF_MIL_VAR_WS));
        default:
            break;
    }

    PFoops (OOPS_FATAL,
            "A relational algebra type (%u) has not yet "
            "been implemented.", atom.type);

    assert (0); /* never reached due to "exit" in "PFoops" */
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `node()' */
static PFmil_t *
llscj_node (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_node()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `element()' */
static PFmil_t *
llscj_elem (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_elem (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_elem (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_elem (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_elem (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_elem (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_elem (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_elem (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_elem()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `text()' */
static PFmil_t *
llscj_text (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_text (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_text (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_text (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_text (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_text (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_text (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_text (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_text (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_text (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_text (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_text()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `comment()' */
static PFmil_t *
llscj_comm (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_comm (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_comm (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_comm (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_comm (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_comm (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_comm (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_comm (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_comm (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_comm (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_comm (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_comm()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `processing-instr()' */
static PFmil_t *
llscj_pi (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_pi (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_pi (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_pi (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_pi (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_pi (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_pi (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_pi (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_pi (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_pi (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_pi (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_pi()");
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test for some local name, but a wildcard namespace
 */
static PFmil_t *
llscj_elem_loc (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                const PFmil_t *loc)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_anc_self:
            return llscj_anc_self_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_child:
            return llscj_child_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_desc:
            return llscj_desc_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_desc_self:
            return llscj_desc_self_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_foll:
            return llscj_foll_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_parent:
            return llscj_parent_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_prec:
            return llscj_prec_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_loc (iter, item, frag, ws, ord, loc);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test for some namespace, but a wildcard local name
 */
static PFmil_t *
llscj_elem_ns (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
               const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
               const PFmil_t *ns)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_anc_self:
            return llscj_anc_self_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_child:
            return llscj_child_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_desc:
            return llscj_desc_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_desc_self:
            return llscj_desc_self_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_foll:
            return llscj_foll_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_parent:
            return llscj_parent_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_prec:
            return llscj_prec_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_ns (iter, item, frag, ws, ord, ns);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test with a fully qualified QName
 */
static PFmil_t *
llscj_elem_nsloc (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                  const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                  const PFmil_t *ns, const PFmil_t *loc)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_anc_self:
            return llscj_anc_self_elem_nsloc (iter, item, frag, ws, ord, ns,
                                              loc);
        case ax_child:
            return llscj_child_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_desc:
            return llscj_desc_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_desc_self:
            return llscj_desc_self_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
        case ax_foll:
            return llscj_foll_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
        case ax_parent:
            return llscj_parent_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_prec:
            return llscj_prec_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is a
 * processing-instruction test with a given target
 */
static PFmil_t *
llscj_pi_targ (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                  const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                  const PFmil_t *target)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_pi_targ (iter, item, frag, ws, ord, target);
        case ax_anc_self:
            return llscj_anc_self_pi_targ (iter, item, frag, ws, ord, target);
        case ax_child:
            return llscj_child_pi_targ (iter, item, frag, ws, ord, target);
        case ax_desc:
            return llscj_desc_pi_targ (iter, item, frag, ws, ord, target);
        case ax_desc_self:
            return llscj_desc_self_pi_targ (iter, item, frag, ws, ord, target);
        case ax_foll:
            return llscj_foll_pi_targ (iter, item, frag, ws, ord, target);
        case ax_foll_sibl:
            return llscj_foll_sibl_pi_targ (iter, item, frag, ws, ord, target);
        case ax_parent:
            return llscj_parent_pi_targ (iter, item, frag, ws, ord, target);
        case ax_prec:
            return llscj_prec_pi_targ (iter, item, frag, ws, ord, target);
        case ax_prec_sibl:
            return llscj_prec_sibl_pi_targ (iter, item, frag, ws, ord, target);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * Translate loop-lifted staircase joins.
 */
static void
llscj (enum axis_t axis, const PFpa_op_t *p)
{
    /* abbreviations for input expressions */
    PFty_t           ty  = p->sem.scjoin.ty;
    PFord_ordering_t in  = p->sem.scjoin.in;
    PFord_ordering_t out = p->sem.scjoin.out;

    /* MIL equivalents of input expression */
    PFmil_t *iter;
    PFmil_t *item;
    PFmil_t *frag;

    int      o;           /* helper to compute order specifier */
    PFmil_t *order;       /* order specifier for llscj MIL functions */
    PFmil_t *scj = NULL;  /* MIL expression that evaluates llscj */

    mvar_t  *tmp;         /* helper variable */
    mvar_t  *ret_iter;    /* variable to which we assign the `iter' result */
    mvar_t  *ret_pre;     /* variable to which we assign the `pre' result */
    mvar_t  *ret_frag;    /* variable to which we assign the `kind' result */
    
    PFalg_att_t pa_iter = p->sem.scjoin.iter; 
    PFalg_att_t pa_item = p->sem.scjoin.item; 
    
    /*
     * Determine generic input arguments.
     */
    assert (p); assert (R(p)); assert (R(p)->env);
    iter = VAR (R(p)->env, pa_iter, aat_nat); assert (iter);
    item = VAR (R(p)->env, pa_item, aat_pre); assert (item);
    frag = VAR (R(p)->env, pa_item, aat_pfrag); assert (frag);

    /*
     * Determine in- and output orderings.
     * MIL functions expect this information encoded in an integer
     * value that we build up here.
     */
    if (PFord_implies (in, sortby (pa_iter, pa_item)))
        o = 0;
    else if (PFord_implies (in, sortby (pa_item, pa_iter)))
        o = 1;
    else
        PFoops (OOPS_FATAL, "illegal argument for input ordering");

    if (PFord_implies (out, sortby (pa_iter, pa_item)))
        o |= 0;
    else if (PFord_implies (out, sortby (pa_item, pa_iter)))
        o |= 2;
    else
        PFoops (OOPS_FATAL, "illegal argument for output ordering");

    order = lit_int (o);

    if (PFty_subtype (ty, PFty_xs_anyElement ())) {

        /* This is a test for element nodes */

        /* Is it just a generic element kind test? (e.g. .../element()) */
        if (PFty_subtype (PFty_xs_anyElement (), ty))

            scj = llscj_elem (axis, iter, item, frag,
                              var (PF_MIL_VAR_WS), order);

        /* Is it a test on element kind and local name only? */
        else if (PFty_subtype (
                    PFty_elem (
                        PFqname (PFns_wild,
                                 PFqname_loc (PFty_name (PFty_defn (ty)))),
                        PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_loc (axis, iter, item, frag,
                                  var (PF_MIL_VAR_WS), order,
                                  lit_str (PFqname_loc (
                                               PFty_name (PFty_defn (ty)))));

        /* Or maybe a test on element kind and namespace only? */
        else if (PFty_subtype (
                    PFty_elem (PFqname (PFqname_ns (PFty_name (PFty_defn (ty))),
                                        NULL),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_ns (axis, iter, item, frag,
                                 var (PF_MIL_VAR_WS), order,
                                 lit_str (PFqname_uri (
                                              PFty_name (PFty_defn (ty)))));

        /* A test on element kind and full QName? */
        else if (PFty_subtype (
                    PFty_elem (PFty_name (PFty_defn (ty)),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_nsloc (
                    axis, iter, item, frag, var (PF_MIL_VAR_WS), order,
                    lit_str (PFqname_uri (PFty_name (PFty_defn (ty)))),
                    lit_str (PFqname_loc (PFty_name (PFty_defn (ty)))));
        /*
         * If we couldn't figure out what element test we got, give up.
         *
         * NOTE: The surface language actually allows such tests. We
         *       just cannot implement them (yet):
         *
         *        doc("foo")/child::element(shoeSize, xs:integer)
         */
        else
            PFoops (OOPS_FATAL,
                    "Problem with an XPath step: cannot evaluate "
                    "node test `%s'", PFty_str (ty));
    }
    /* If the node test wasn't some element test, maybe it is a text() test? */
    else if (PFty_subtype (ty, PFty_text ())) {
        scj = llscj_text (axis, iter, item, frag, var (PF_MIL_VAR_WS), order);
    }
    /* or a comment() test? */
    else if (PFty_subtype (ty, PFty_comm ())) {
        scj = llscj_comm (axis, iter, item, frag, var (PF_MIL_VAR_WS), order);
    }
    /* some test for processing-instructions? */
    else if (PFty_subtype (ty, PFty_pi (NULL))) {
        /* maybe we look for _any_ pi, regardless of its target? */
        if (PFty_subtype (PFty_pi (NULL), ty))
            scj = llscj_pi (axis, iter, item, frag, var (PF_MIL_VAR_WS), order);
        /* or was there a target specified? */
        else
            scj = llscj_pi_targ (
                    axis, iter, item, frag, var (PF_MIL_VAR_WS), order,
                    lit_str (PFqname_loc (PFty_name (PFty_defn (ty)))));
    }
    /* If all these cases did not apply, it is probably a node() test. */
    else if (PFty_subtype (PFty_xs_anyNode (), ty)) {
        scj = llscj_node (axis, iter, item, frag, var (PF_MIL_VAR_WS), order);
    }
    /* If we still couldn't find out, we probably need to give up. */
    else
        PFoops (OOPS_FATAL,
                "Problem with an XPath step: cannot evaluate "
                "node test `%s'", PFty_str (ty));

    assert (scj);

    /*
     * tmp  := scj (...);            # constructed just before
     * iter := tmp.fetch (0);
     * pre  := tmp.fetch (1);
     * kind := tmp.fetch (2);
     */
    tmp      = new_var (1);

    /*
     * Should we actually do materialize at runtime? In most cases
     * we should be able to see at compile time if columns are guaranteed
     * to be constant. We could then avoid carrying around the column at
     * all.
     *
     * Problem is: We do consider a `constant' property in our algebra
     * (not fully, yet, but the ideas are there). This property, however
     * only looks at ``real'' algebra columns. Here, materialize operates
     * on only part of a ``real'' column. The ``real'' column `item' is
     * implemented as `pre|kind' for nodes. And while kind may be constant,
     * pre probably won't.
     */
    execute (assgn (var (tmp->name), scj));

    ret_pre  = new_var (p->refctr);
    ret_frag = new_var (p->refctr);
    execute (
         assgn (var (ret_pre->name), fetch (var (tmp->name), lit_int (1))),
         assgn (var (ret_frag->name), 
                materialize (fetch (var (tmp->name), lit_int (2)),
                             var (ret_pre->name))));
    env_add (p->env, pa_item, aat_pre, ret_pre);
    env_add (p->env, pa_item, aat_pfrag, ret_frag);

    ret_iter = new_var (p->refctr);
    execute (
         assgn (var (ret_iter->name), 
                materialize (fetch (var (tmp->name), lit_int (0)),
                             fetch (var (tmp->name), lit_int (1)))));
    env_add (p->env, pa_iter, aat_nat, ret_iter);

    unpin (tmp, 1);

}

/**
 * Generic handling of binary operators, where both operands
 * are a BAT (in contrast to when one operand is known to be constant
 * and thus needs not be materialized as a BAT).
 *
 * @param op A MIL multiplex operation that implements the binary
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
bin_op (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
        PFpa_op_t *p, PFalg_simple_type_t arg_ty, PFalg_simple_type_t ret_ty)
{
    mvar_t              *res = new_var (p->refctr);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.binary.att1, arg_ty),
                   VAR (L(p)->env, p->sem.binary.att2, arg_ty))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.binary.res, ret_ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

#if 0
    GCC: defined but never used
/**
 * Generic binary arithmetic operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_arith (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));
    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl ||
            ty == aat_str);

    bin_op (op, p, ty, ty);
}
#endif

/**
 * node comparison operator, where both operands are a BAT
 * (in contrast to when one operand is known to be constant
 * and thus needs not be materialized as a BAT).
 *
 * @param op A MIL multiplex operation that implements the binary
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
node_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    mvar_t              *res = new_var (p->refctr);

    if (op == PFmil_mgt) {
        /* do the comparison: 
           frag1 > frag2 || (frag1 = frag2 && pre1 > pre2) */
        execute (
            assgn (
                var (res->name),
                PFmil_mor (
                    op (VAR (L(p)->env, p->sem.binary.att1, aat_pfrag),
                        VAR (L(p)->env, p->sem.binary.att2, aat_pfrag)),
                    PFmil_mand (
                        PFmil_meq (
                            VAR (L(p)->env, p->sem.binary.att1, aat_pfrag),
                            VAR (L(p)->env, p->sem.binary.att2, aat_pfrag)),
                        op (VAR (L(p)->env, p->sem.binary.att1, aat_pre),
                            VAR (L(p)->env, p->sem.binary.att2, aat_pre))))));
    } else if (op == PFmil_meq) {
        /* do the comparison: 
           frag1 = frag2 && pre1 = pre2 */
        execute (
            assgn (var (res->name),
                   PFmil_mand (
                       op (VAR (L(p)->env, p->sem.binary.att1, aat_pfrag),
                           VAR (L(p)->env, p->sem.binary.att2, aat_pfrag)),
                       op (VAR (L(p)->env, p->sem.binary.att1, aat_pre),
                           VAR (L(p)->env, p->sem.binary.att2, aat_pre)))));
    } else PFoops (OOPS_FATAL, "Unknown comparison for nodes.");

    /* and put the result into p's environment */
    env_add (p->env, p->sem.binary.res, aat_bln, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

/**
 * Generic binary comparison operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));

    if (ty & ~aat_node) {
        assert (ty == aat_int || ty == aat_dec ||
                ty == aat_dbl || ty == aat_str ||
                ty == aat_bln);
        bin_op (op, p, ty, aat_bln);
    } else if (ty == aat_pnode) {
        node_comp (op, p);
    } else
        PFoops (OOPS_FATAL,
                "Mil implementation of binary comparison for type %i unknown",
                ty);
}

/**
 * Generic binary Boolean operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_bool (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));
    assert (ty == aat_bln);

    bin_op (op, p, ty, aat_bln);
}

/**
 * Generic handling of arithmetic operators, where one operand is
 * known to be constant. (We don't need to materialize that attribute
 * as a BAT, but pass it as a const argument to MonetDB's [+].
 *
 * @param op A MIL multiplex operation that implements the arithmetic
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
bin_op_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
             PFpa_op_t *p,
             PFalg_simple_type_t arg_ty, PFalg_simple_type_t ret_ty)
{
    mvar_t              *res = new_var (p->refctr);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.bin_atom.att1, arg_ty),
                   literal (p->sem.bin_atom.att2))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.bin_atom.res, ret_ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

#if 0
    GCC: defined but never used
static void
bin_arith_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl);
    assert (ty == p->sem.bin_atom.att2.type);

    bin_op_atom (op, p, ty, ty);
}
#endif

static void
bin_comp_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl ||
            ty == aat_str || ty == aat_nat || ty == aat_bln);
    assert (ty == p->sem.bin_atom.att2.type);

    bin_op_atom (op, p, ty, aat_bln);
}

static void
bin_bool_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_bln);
    assert (ty == p->sem.bin_atom.att2.type);

    bin_op_atom (op, p, ty, aat_bln);
}

/**
 * Generic handling of unary operators (Boolean negation).
 *
 * @param op A MIL multiplex operation that implements the
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
unary_op (PFmil_t * (*op) (const PFmil_t *), PFpa_op_t *p)
{
    mvar_t              *res = new_var (p->refctr);
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.unary.att);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.unary.att, ty))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.unary.res, ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

/**
 * Generic handling of aggregation functions (avg, max, min and sum).
 *
 * @param op  A MIL operation that implements the function
 *            of interest (as a function pointer to the
 *            constructor function).
 * @param gop A MIL operation that implements the function
 *            of interest (as a function pointer to the
 *            constructor function), grouped version.
 * @param p   The physical algebra tree node that we are to translate.
 *            This function will actually fill @a p's environment
 *            <code>p->env</code>.
 */
static void 
aggr_function (PFmil_t * (*op) (const PFmil_t *),
               PFmil_t * (*gop) (const PFmil_t *),
               PFpa_op_t *p) 
{
     PFalg_att_t part = p->sem.aggr.part;
     PFalg_att_t att = p->sem.aggr.att;
     PFalg_att_t res = p->sem.aggr.res;
     bool has_part = part != att_NULL;
     PFalg_simple_type_t poly_att_type = 0;
     PFalg_simple_type_t poly_part_type = 0;
     PFalg_simple_type_t poly_res_type = 0;
     /* determine res type */
     for (unsigned int i = 0; i < p->schema.count; i++) {
          if (p->schema.items[i].name == res) {
               poly_res_type = p->schema.items[i].type;
               break;
          }
     }
     /* determine att and part type */
     for (unsigned int i = 0; i < L(p)->schema.count; i++) {
          if (L(p)->schema.items[i].name == part)
               poly_part_type = L(p)->schema.items[i].type;
          else if (L(p)->schema.items[i].name == att)
               poly_att_type = L(p)->schema.items[i].type;
     }
     /* sanity checks */
     if (poly_att_type == 0) 
          PFoops (OOPS_FATAL,
                  "attribute `%s' referenced in aggregation function "
                  "not found", 
                  PFatt_str (att));
     if (has_part && poly_part_type == 0)
          PFoops (OOPS_FATAL,
                  "attribute `%s' referenced in aggregation function "
                  "not found", 
                  PFatt_str (part));
     if (poly_res_type == 0) 
          PFoops (OOPS_FATAL,
                  "attribute `%s' referenced in aggregation function "
                  "not found", 
                  PFatt_str (res));
     if (!monomorphic(poly_att_type) || !monomorphic(poly_res_type)
         || (has_part && !monomorphic(poly_part_type)))
          PFoops (OOPS_FATAL,
                  "Aggregation function not implemented for "
                  "polymorphic groups");
     PFalg_simple_type_t att_type = (PFalg_simple_type_t)poly_att_type;
     PFalg_simple_type_t res_type = (PFalg_simple_type_t)poly_res_type;
     if (has_part) {
          PFalg_simple_type_t part_type 
               = (PFalg_simple_type_t)poly_part_type;
          mvar_t *v    = new_var (1);
          mvar_t *res_var  = new_var (p->refctr);
          mvar_t *part_var = new_var (p->refctr);
          
          execute (
               /* v := 
                  {gop}(att.reverse().join(part).reverse()) */
               assgn (
                    var (v->name),
                    gop (
                         reverse (
                              join (
                                   reverse (VAR (L(p)->env, 
                                                 att, 
                                                 att_type)),
                                   VAR (L(p)->env, 
                                        part, 
                                        part_type))))),
               /* res := v.reverse ().mark (0@0).reverse (); */
               assgn (
                    var (res_var->name),
                    reverse (
                         mark (
                              reverse (var (v->name)),
                              lit_oid (0)))),
               /* part := v.mark (0@0).reverse (); */
               assgn (
                    var (part_var->name),
                    reverse (
                         mark (var (v->name), lit_oid (0)))));
          
          env_add (p->env, res, res_type, res_var);
          env_add (p->env, part, part_type, part_var);
          
          unpin (v, 1);
     }
     else {
          mvar_t *v = new_var (p->refctr);
          execute (
               assgn (var (v->name),
                      op (VAR (L(p)->env, att, att_type))),
               assgn (var (v->name),
                      append (
                           seqbase (
                                new (type (mty_void), implty (res_type)),
                                lit_oid (0)),
                           var (v->name))));
          env_add (p->env, res, res_type, v);
     }
}

static void
inc_refctr (PFpa_op_t *n)
{
    assert (n);

    /* count number of incoming edges */
    n->refctr++;

    /* only descend once */
    if (SEEN(n))
        return;
    else
        SEEN(n) = true;
    
    for (unsigned int i = 0; i < PFPA_OP_MAXCHILD && n->child[i]; i++)
        inc_refctr (n->child[i]);
}

static void
label (PFpa_op_t *p)
{
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        if (!SEEN(L(p))) label (L(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
    }
    else if (!L(p) && R(p)) {
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
    }
    else {
        if (!SEEN(L(p))) label (L(p));
        if (!SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
    }
    SEEN(p) = true;
}

/**
 * Translate MIL algebra tree in a MIL program.
 */
PFmil_t *
PFmilgen (PFpa_op_t *n)
{
    PFmil_t *bodymilprog;

    assert (n);

    /* set counters in algebra tree nodes */
    inc_refctr (n);
    PFpa_dag_reset (n);

    /* initialize list of variables we use */
    mvars = PFarray (sizeof (mvar_t));

    /* enrich algebra tree with state labels for subsequent reduce() call */
    label (n);
    PFpa_dag_reset (n);

    /* we start with an empty MIL program */
    milprog = declare (unused ());

    execute (declare (var (PF_MIL_VAR_WS)),
             assgn (unused (), nil ()));

    /* prepare the storage structure for the side
       effect of a trace operator: the trace output */
    execute (comment ("trace structure"),
             declare (var (PF_MIL_VAR_TRACE_OUTER)),
             declare (var (PF_MIL_VAR_TRACE_INNER)),
             declare (var (PF_MIL_VAR_TRACE_ITER )),
             declare (var (PF_MIL_VAR_TRACE_MSG  )),
             declare (var (PF_MIL_VAR_TRACE_ITEM )),
             declare (var (PF_MIL_VAR_TRACE_TYPE )),
             declare (var (PF_MIL_VAR_TRACE_REL  )),
             assgn (var (PF_MIL_VAR_TRACE_OUTER),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_INNER),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_ITER ),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_MSG  ),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_ITEM ),
                    new (type (mty_oid), type (mty_bat))),
             assgn (var (PF_MIL_VAR_TRACE_TYPE ),
                    new (type (mty_oid), type (mty_int))),
             assgn (var (PF_MIL_VAR_TRACE_REL  ),
                    new (type (mty_oid), type (mty_oid))));
    
    /* dummy initialization */
    twig_state = NULL;

    /* start compilation */
    reduce (n, 1);

#ifndef NDEBUG
    mvar_t *var = NULL;
    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        if ((var = (mvar_t *) PFarray_at (mvars, i))->pins) {
            if (var->pins == 1)
                PFinfo (OOPS_WARNING, 
                        "variable %s stilled pinned once.",
                        PFmil_var_str (var->name));
            else
                PFinfo (OOPS_WARNING, 
                        "variable %s stilled pinned %i times.",
                        PFmil_var_str (var->name), var->pins);
        }
#endif

    bodymilprog = milprog;
    
    milprog = seq (module (lit_str ("pathfinder")),
                   module (lit_str ("mkey")),
                   /* add timing information */
                   declare (var (PF_MIL_VAR_TIME_LOAD)),
                   declare (var (PF_MIL_VAR_TIME_QUERY)),
                   declare (var (PF_MIL_VAR_TIME_PRINT)),
                   assgn (var (PF_MIL_VAR_TIME_LOAD), lit_int (0)),
                   assgn (var (PF_MIL_VAR_TIME_PRINT), lit_int (0)),
                   assgn (var (PF_MIL_VAR_TIME_QUERY), usec ()));
    
    /* prepend variable declarations before the actual program */
    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        milprog = seq (milprog, 
                       declare (
                           var (((mvar_t *) PFarray_at (mvars, i))->name)));

    milprog = seq (milprog,
                   bodymilprog,
                   /* add timing information */
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          sub (usec (),
                               var (PF_MIL_VAR_TIME_QUERY))),
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          sub (var (PF_MIL_VAR_TIME_QUERY),
                               var (PF_MIL_VAR_TIME_LOAD))),
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          sub (var (PF_MIL_VAR_TIME_QUERY),
                               var (PF_MIL_VAR_TIME_PRINT))),
                   assgn (var (PF_MIL_VAR_TIME_LOAD),
                          div (
                              cast (type (mty_dbl),
                                    var (PF_MIL_VAR_TIME_LOAD)),
                              lit_dbl (1000.0))),
                   assgn (var (PF_MIL_VAR_TIME_QUERY),
                          div (
                              cast (type (mty_dbl),
                                    var (PF_MIL_VAR_TIME_QUERY)),
                              lit_dbl (1000.0))),
                   assgn (var (PF_MIL_VAR_TIME_PRINT),
                          div (
                              cast (type (mty_dbl),
                                    var (PF_MIL_VAR_TIME_PRINT)),
                              lit_dbl (1000.0))));

    return milprog;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
