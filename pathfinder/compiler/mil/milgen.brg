/* -*- c-basic-offset:4; c-indentation-style:"k&r"; indent-tabs-mode:nil -*- */
%{

/*
 * Compile physical algebra tree into a MIL program.
 *
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2006 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */


#include "pathfinder.h"

#include <assert.h>

#include "oops.h"
#include "mem.h"
#include "physical.h"
#include "properties.h"
#include "mil.h"

#include "subtyping.h"

#include <stdio.h>

/*
 * Accessors for the burg matcher
 */
typedef struct PFpa_op_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind)

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers.
 * Keep them aligned with the node kinds in include/physical.h!
 */
%term serialize      =   1
%term lit_tbl        =   2
%term empty_tbl      =   3
%term attach         =   4
%term cross          =  10
%term leftjoin       =  11
%term eqjoin         =  14
%term project        =  15
%term select         =  16
%term append_union   =  20
%term merge_union    =  21
%term intersect      =  22
%term difference     =  23
%term sort_distinct  =  24
%term std_sort       =  25
%term refine_sort    =  26
%term num_add        =  30
%term num_add_atom   =  31
%term num_sub        =  32
%term num_sub_atom   =  33
%term num_mult       =  34
%term num_mult_atom  =  35
%term num_div        =  36
%term num_div_atom   =  37
%term num_mod        =  38
%term num_mod_atom   =  39
%term eq             =  40
%term eq_atom        =  41
%term gt             =  42
%term gt_atom        =  43
%term num_neg        =  44
%term bool_not       =  45
%term bool_and       =  46
%term bool_or        =  47
%term bool_and_atom  =  48
%term bool_or_atom   =  49
%term hash_count     =  55
%term avg	     =  56
%term max_	     =  57
%term min_	     =  58
%term sum	     =  59
%term merge_rownum   =  60
%term hash_rownum    =  61
%term number         =  62
%term type           =  63
%term type_assert    =  64
%term cast           =  65
%term llscj_anc      = 100
%term llscj_anc_self = 101
%term llscj_attr     = 102
%term llscj_child    = 103
%term llscj_desc     = 104
%term llscj_desc_self= 105
%term llscj_foll     = 106
%term llscj_foll_sibl= 107
%term llscj_parent   = 108
%term llscj_prec     = 109
%term llscj_prec_sibl= 110
%term doc_tbl        = 120
%term doc_access     = 121
%term element        = 122
%term element_tag    = 123
%term attribute      = 124
%term textnode       = 125
%term docnode        = 126
%term comment        = 127
%term processi       = 128
%term merge_adjacent = 129
%term roots          = 130
%term fragment       = 131
%term frag_union     = 132
%term empty_frag     = 133
%term cond_err       = 140
%term concat         = 150
%term contains       = 151
%term string_join    = 152

%%

Query:    serialize (FragList, Rel)                                =   1 (10);
Query:    serialize (FragList, empty_tbl)                          =   2 (10);

Rel:      lit_tbl                                                  =  10 (10);
Rel:      empty_tbl                                                =  11 (10);
Rel:      attach (Rel)                                             =  12 (10);
Rel:      cross (Rel, Rel)                                         =  13 (10);
Rel:      leftjoin (Rel, Rel)                                      =  14 (10);
Rel:      eqjoin (Rel, Rel)                                        =  15 (10);
Rel:      project (Rel)                                            =  20 (10);
Rel:      select (Rel)                                             =  21 (10);
Rel:      append_union (Rel, Rel)                                  =  22 (10);
Rel:      append_union (hash_count (Rel),
                        attach (difference 
                                    (Rel, 
                                     project (hash_count (Rel))))) =  23 (40);
Rel:      merge_union (Rel, Rel)                                   =  24 (10);
Rel:      intersect (Rel, Rel)                                     =  25 (10);
Rel:      difference (Rel, Rel)                                    =  26 (10);
Rel:      sort_distinct (Rel)                                      =  30 (10);
Rel:      sort_distinct (std_sort (Rel))                           =  31 (10);
Rel:      sort_distinct (refine_sort (Rel))                        =  32 (10);
Rel:      std_sort (Rel)                                           =  33 (10);
Rel:      refine_sort (Rel)                                        =  34 (10);
Rel:      num_add (Rel)                                            =  40 (10);
Rel:      num_sub (Rel)                                            =  41 (10);
Rel:      num_mult (Rel)                                           =  42 (10);
Rel:      num_div (Rel)                                            =  43 (10);
Rel:      num_mod (Rel)                                            =  44 (10);
Rel:      num_add_atom (Rel)                                       =  45 (10);
Rel:      num_sub_atom (Rel)                                       =  46 (10);
Rel:      num_mult_atom (Rel)                                      =  47 (10);
Rel:      num_div_atom (Rel)                                       =  48 (10);
Rel:      num_mod_atom (Rel)                                       =  49 (10);
Rel:      eq (Rel)                                                 =  50 (10);
Rel:      eq_atom (Rel)                                            =  51 (10);
Rel:      gt (Rel)                                                 =  52 (10);
Rel:      gt_atom (Rel)                                            =  53 (10);
Rel:      num_neg (Rel)                                            =  60 (10);
Rel:      bool_not (Rel)                                           =  61 (10);
Rel:      bool_and (Rel)                                           =  62 (10);
Rel:      bool_or (Rel)                                            =  63 (10);
Rel:      bool_and_atom (Rel)                                      =  64 (10);
Rel:      bool_or_atom (Rel)                                       =  65 (10);
Rel:      hash_count (Rel)                                         =  66 (10);
Rel:      avg (Rel)                                                =  67 (10);
Rel:      max_ (Rel)                                               =  68 (10);
Rel:      min_ (Rel)                                               =  69 (10);
Rel:      sum (Rel)                                                =  70 (10);
Rel:      merge_rownum (Rel)                                       =  71 (10);
Rel:      hash_rownum (Rel)                                        =  72 (10);
Rel:      number (Rel)                                             =  73 (10);
Rel:      type (Rel)                                               =  74 (10);
Rel:      type_assert (Rel)                                        =  75 (10);
Rel:      cast (Rel)                                               =  76 (10);

Rel:      llscj_anc (FragList, Rel)                                =  80 (10);
Rel:      llscj_anc_self (FragList, Rel)                           =  81 (10);
Rel:      llscj_attr (FragList, Rel)                               =  82 (10);
Rel:      llscj_child (FragList, Rel)                              =  83 (10);
Rel:      llscj_desc (FragList, Rel)                               =  84 (10);
Rel:      llscj_desc_self (FragList, Rel)                          =  85 (10);
Rel:      llscj_foll (FragList, Rel)                               =  86 (10);
Rel:      llscj_foll_sibl (FragList, Rel)                          =  87 (10);
Rel:      llscj_parent (FragList, Rel)                             =  88 (10);
Rel:      llscj_prec (FragList, Rel)                               =  89 (10);
Rel:      llscj_prec_sibl (FragList, Rel)                          =  90 (10);

FragRel:  doc_tbl (Rel)                                            = 100 (10);
Rel:      doc_access (FragList, Rel)                               = 101 (10);
FragRel:  element (FragList, element_tag (Rel, empty_tbl))         = 102 (10);
FragRel:  element (FragList, element_tag (Rel, Rel))               = 103 (10);
FragRel:  attribute (Rel, Rel)                                     = 104 (10);
FragRel:  textnode (Rel)                                           = 105 (10);
FragRel:  docnode (FragList, Rel)                                  = 106 (10);
FragRel:  comment (Rel)                                            = 107 (10);
FragRel:  processi (Rel)                                           = 108 (10);
FragRel:  merge_adjacent (FragList, Rel)                           = 109 (10);

Rel:      roots (FragRel)                                          = 120 (10);
Frag:     fragment (FragRel)                                       = 121 (10);
FragList: frag_union (FragList, Frag)                              = 122 (10);
FragList: empty_frag                                               = 123 (10);

Rel:      cond_err (Rel, Rel)                                      = 130 (10);
Rel:      concat (Rel)                                             = 140 (10);
Rel:      contains (Rel)                                           = 141 (10);
Rel:      string_join (Rel, Rel)                                   = 142 (10);

%%

#include "mil_mnemonic.h"

/**
 * We collect the MIL program during compilation here.
 */
static PFmil_t *milprog = NULL;

/**
 * Processing is done bottom-up. This is just the order in
 * which we want to print our code. So we keep the whole
 * MIL program in the variable #milprog, and append commands
 * as we go. Think of it as ``executing'' the commands
 * right away.
 */
#define execute(...) milprog = seq (milprog, __VA_ARGS__)

/**
 * Represents a MIL variable.
 *
 * The variable has a name (that is automatically generated).
 * The @a pins field keeps track of the number of references
 * to this variable.  A variable may not be destroyed before
 * @a pins drops to zero.
 */
struct mvar_t {
    PFmil_ident_t   name;
    unsigned int    pins;
};

/** short-hand for struct mvar_t */
typedef struct mvar_t mvar_t;

/**
 * Remember @em all variables that we deal with during the compiler
 * run in here.  We want to re-use variables as much as possible to
 * reduce the number of active variables in the MIL program.  This
 * should help MonetDB with its memory management.
 *
 * Each time we need a new variable, we try to re-use an old one
 * from here.  We thus search for a variable with pin count zero.
 * If we cannot find any, we create a new variable and append it to
 * the list.
 */
PFarray_t *mvars = NULL;

/**
 * Return a ``new'' valid variable.  Will try to re-use an old,
 * no longer needed, variable, if possible.  For this, the
 * function searches #mvars for a variable with @a pins = 0. If
 * no such variable can be found, a new one will be created and
 * appended to the list.  
 *
 * The new variable will be initialized with the pin count given
 * in @a pins.
 */
static mvar_t *
new_var (unsigned int pins)
{
    static unsigned int   varno = 0;
    mvar_t               *var   = NULL;

    assert (mvars);
    assert (varno < 10000);

    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        if ((var = (mvar_t *) PFarray_at (mvars, i))->pins == 0) {
            var->pins = pins;
            return var;
        }

    /* If we were not successful, create a new entry */
    var = (mvar_t *) PFarray_add (mvars);

    var->name = PFmalloc (sizeof ("a0000"));
    sprintf ((char *) var->name, "a%04u", varno++);

    var->pins = pins;

    return var;
}

/**
 * Pin a variable (i.e., increment its pin count by @a count).
 */
static void
pin (mvar_t *v, unsigned int count)
{
    v->pins += count;
}

/**
 * Unpin a variable (i.e., decrement its pin count by @a count).
 * If the pin count reaches zero, automatically generates a MIL
 * statement that assigns @c unused to the variable, marking it
 * a candidate for MonetDB's garbage collection.
 */
static void
unpin (mvar_t *v, unsigned int count)
{
    if (v->pins < count) {
        PFinfo (OOPS_WARNING, "pin count below zero");
        v->pins = 0;
    } else
        v->pins -= count;

    if (!v->pins)
        execute (assgn (var (v->name), unused ()));
}


/**
 * Environment entry.  In each physical algebra tree node, we keep
 * an environment that maps an attribute/type combination to the
 * #mvar_t struct that holds the corresponding MIL variable.
 */
struct env_t {
    PFalg_att_t          att;
    PFalg_simple_type_t  ty;
    mvar_t              *mvar;
};
typedef struct env_t env_t;

/**
 * Create a new (empty) environment for #env_t entries.
 *
 * With each node in the physical algebra DAG, we keep such an
 * environment that maps an attribute/type combination onto the
 * #mvar_t item that implements it. (Think of this as the mapping
 * from attribute/type to the BAT that represents that combination.
 */
static PFarray_t *
new_env (void)
{
    return PFarray (sizeof (env_t));
}

/**
 * Add an item to environment.
 */
void
env_add (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty, mvar_t *v)
{
    assert (ty == aat_nat || ty == aat_int || ty == aat_str || ty == aat_dec
            || ty == aat_dbl || ty == aat_bln || ty == aat_qname
            || ty == aat_pre || ty == aat_attr
            || ty == aat_pfrag || ty == aat_afrag);

    *(env_t *) PFarray_add (env)
        = (env_t) { .att = att, .ty = ty, .mvar = v };
}

/**
 * Return environment size.
 */
unsigned int
env_count (const PFarray_t *env)
{
    return PFarray_last (env);
}

/**
 * Return environment item at index @a i.
 */
env_t
env_at (const PFarray_t *env, unsigned int i)
{
    assert (i < PFarray_last (env));

    return *(env_t *) PFarray_at ((PFarray_t *) env, i);
}

/**
 * Worker for env_mvar ()
 */ 
static mvar_t *
env_mvar_worker (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    for (unsigned int i = 0; i < PFarray_last (env); i++) {

        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        if (entry.att == att && entry.ty == ty)
            return entry.mvar;
    }
    return NULL;
}

/**
 * Look up an entry in the environment @a env, given a combination
 * of attribute (@a att) and type (@a ty) as the search key.
 */
mvar_t *
env_mvar (const PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    mvar_t *mvar = env_mvar_worker (env, att, ty);
    if (mvar)
        return mvar;

    /* FIXME: DEBUGGING ONLY */
    fprintf (stderr, "looking for att: %s, ty: %u\n", PFatt_str (att), ty);
    fprintf (stderr, "environment looks like:\n");
    for (unsigned int i = 0; i < PFarray_last (env); i++) {
        env_t entry = *(env_t *) PFarray_at ((PFarray_t *) env, i);

        fprintf (stderr, "  att: %s, type: %u, mvar->name: %s\n",
                         PFatt_str (entry.att), entry.ty, entry.mvar->name);
    }

    PFoops (OOPS_FATAL,
            "attribute '%s' with type '%u' not found in environment",
            PFatt_str (att), ty);
    /* we don't ever get here */
    return NULL;
}

PFmil_t *
VAR (PFarray_t *env, PFalg_att_t att, PFalg_simple_type_t ty)
{
    return var (env_mvar (env, att, ty)->name);
}

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RLL(p) L(L(R(p)))
#define RLR(p) R(L(R(p)))
#define RLRL(p) L(R(L(R(p))))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))

#define MAX_KIDS 10

#define SEEN(p) ((p)->bit_mil_ctr)
#define LABEL_SEEN(p) ((p)->bit_mil_label)

enum axis_t {
      ax_anc
    , ax_anc_self
    , ax_child
    , ax_desc
    , ax_desc_self
    , ax_foll
    , ax_foll_sibl
    , ax_parent
    , ax_prec
    , ax_prec_sibl
};

static PFalg_simple_type_t type_of (PFpa_op_t *n, PFalg_att_t att);
static PFmil_t * literal (PFalg_atom_t atom);

/* helper to handle loop-lifted staircase join operator */
static void llscj (enum axis_t axis, const PFpa_op_t *p);
/* translate arithmetic operators where both arguments are a BAT */
static void bin_arith (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                       PFpa_op_t *p);
/* translate arithmetic operators where one argument is an atom */
static void bin_arith_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                            PFpa_op_t *p);
/* translate binary coparison operator (eq/gt) */
static void bin_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                      PFpa_op_t *p);
static void bin_comp_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                           PFpa_op_t *p);
/* translate binary Boolean operator (and/or) */
static void bin_bool (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                      PFpa_op_t *p);
static void bin_bool_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                           PFpa_op_t *p);
/* translate unary operators (numeric negation, Boolean not) */
static void unary_op (PFmil_t * (*op) (const PFmil_t *), PFpa_op_t *p);

/* Generic handling of aggregation functions (avg, max, min and sum). */
static void aggr_function(PFmil_t * (*op) (const PFmil_t *), PFmil_t * (*gop) (const PFmil_t *),
			  PFpa_op_t *p);

/* check if attribute @a attr is required */
static bool attr_req (PFprop_t *prop, PFalg_att_t attr);

/** MIL implementation types for algebra types */
static PFmil_type_t impl_types[] = {
      [aat_nat]   = m_oid
    , [aat_int]   = m_lng
    , [aat_str]   = m_str
    , [aat_dec]   = m_dbl
    , [aat_dbl]   = m_dbl
    , [aat_bln]   = m_bit
    , [aat_qname] = m_oid
    , [aat_pre]   = m_oid
    , [aat_attr]  = m_oid
    , [aat_pfrag] = m_oid
    , [aat_afrag] = m_oid
};

/** implementation type for a given algebra type, as a MIL node */
#ifndef NDEBUG
#define implty(n) type (impl_types[n] \
                        ? impl_types[n] \
                        : (PFoops (OOPS_FATAL, "illegal type in implty()"), 0))
#else
#define implty(n) type (impl_types[n])
#endif

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFpa_op_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFpa_op_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */

    if (p->env)
        return;

    /* determine rule that matches for this non-terminal */
    rule = PFmilgen_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */
    assert(rule);

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFmilgen_nts[rule];
    PFmilgen_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    switch (rule) {
        /* Query:    serialize (FragList, Rel) */
        case 1:
        /* Query:    serialize (FragList, empty_tbl) */
        case 2:
            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    if (!topdown)
        for (unsigned short i = 0; nts[i]; i++)
            reduce (kids[i], nts[i]);

    if (p->env)
        return;

    p->env = new_env ();

    switch (rule) {

        /* Query:   serialize (FragList, Rel) */
        case 1:
        {
            mvar_t *intVAL, *dblVAL, *decVAL, *strVAL;
            mvar_t *item, *kind;
            PFalg_simple_type_t ty;
            bool sorted = false;

            /*
            PFmil_t *args = NULL;
            */

            execute (
                assgn (unused (), nil ()),
                assgn (var ("ws"), new_ws ()));
            reduce (kids[0], nts[0]);
            reduce (kids[1], nts[1]);

            /* Set up all the value containers for print_result().
             * (It is actually too much overhead to introduce the value
             * containers just for printing. But this way we can re-use
             * Jan F's print_result() and stay compatible with the
             * ``summer branch''.
             */

            intVAL = new_var (1);
            dblVAL = new_var (1);
            /*decVAL = new_var (1); as we currently have no decimal support we use doubles */
            decVAL = dblVAL;
            strVAL = new_var (1);
            item = new_var (1);
            kind = new_var (1);

            execute (
                assgn (var (intVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_lng), type (m_void)), true)),
                           lit_oid (0))),
                assgn (var (dblVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_dbl), type (m_void)), true)),
                           lit_oid (0))),
                /*
                assgn (var (decVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_dbl), type (m_void)), true)),
                           lit_oid (0))),
                */
                assgn (var (strVAL->name),
                       seqbase (
                           reverse (
                               key (new (type (m_str), type (m_void)), true)),
                           lit_oid (0))),
                assgn (var (item->name),
                       seqbase (new (type (m_void), type (m_oid)), lit_oid(0))),
                assgn (var (kind->name),
                       seqbase (new (type (m_void), type (m_int)), lit_oid(0)))
                );

            ty = type_of (R(p), att_item);

            /* consider attribute results */
            if (ty & aat_anode) {
                if (ty == aat_anode) {
                    execute (
                        assgn (var (item->name),
                               VAR (R(p)->env, att_item, aat_attr)),
                        assgn (var (kind->name),
                               set_kind (VAR (R(p)->env, att_item, aat_afrag),
                                         var ("ATTR")))
                        );
                    sorted = true;
                }
                else {
                    assert (ty & aat_attr && ty & aat_afrag);
                    execute (
                        binsert (var (item->name),
                                 select2 (
                                     VAR (R(p)->env, att_item, aat_attr),
                                     cast (type (m_oid), nil ()),
                                     cast (type (m_oid), nil ()))),
                        binsert (var (kind->name),
                                 select2 (
                                     set_kind (VAR (R(p)->env, 
                                                    att_item,
                                                    aat_afrag),
                                               var ("ATTR")),
                                     cast (type (m_int), nil ()),
                                     cast (type (m_int), nil ())))
                        );
                }
            }

            /* consider node results */
            if (ty & aat_pnode) {
                if (ty == aat_pnode) {
                    execute (
                        assgn (var (item->name),
                               VAR (R(p)->env, att_item, aat_pre)),
                        assgn (var (kind->name),
                               set_kind (VAR (R(p)->env, att_item, aat_pfrag),
                                         var ("ELEM")))
                        );
                    sorted = true;
                }
                else {
                    assert (ty & aat_pre && ty & aat_pfrag);
                    execute (
                        binsert (var (item->name),
                                 select2 (
                                     VAR (R(p)->env, att_item, aat_pre),
                                     cast (type (m_oid), nil ()),
                                     cast (type (m_oid), nil ()))),
                        binsert (var (kind->name),
                                 select2 (
                                     set_kind (VAR (R(p)->env, 
                                                    att_item,
                                                    aat_pfrag),
                                               var ("ELEM")),
                                     cast (type (m_int), nil ()),
                                     cast (type (m_int), nil ())))
                        );
                }
            }

            /* consider str results */
            if (ty & aat_str) {
                execute (
                    bappend (var (strVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       att_item,
                                                       aat_str),
                                                  cast (type (m_str), nil ()),
                                                  cast (type (m_str), nil ()))
                                         )))));
                if (ty == aat_str) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, att_item, aat_str),
                                      reverse (var (strVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_str),
                                     var ("STR")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, att_item, aat_str),
                                  reverse (var (strVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_str),
                                              cast (type (m_str), nil ()),
                                              cast (type (m_str), nil ())),
                                     var ("STR")))
                    );
                }
            }

            /* consider int results */
            if (ty & aat_int) {
                execute (
                    bappend (var (intVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       att_item,
                                                       aat_int),
                                                  cast (type (m_lng), nil ()),
                                                  cast (type (m_lng), nil ()))
                                         )))));
                if (ty == aat_int) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, att_item, aat_int),
                                      reverse (var (intVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_int),
                                     var ("INT")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, att_item, aat_int),
                                  reverse (var (intVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_int),
                                              cast (type (m_lng), nil ()),
                                              cast (type (m_lng), nil ())),
                                     var ("INT")))
                    );
                }
            }

            /* consider dbl results */
            if (ty & aat_dbl) {
                execute (
                    bappend (var (dblVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       att_item,
                                                       aat_dbl),
                                                  cast (type (m_dbl), nil ()),
                                                  cast (type (m_dbl), nil ()))
                                         )))));
                if (ty == aat_dbl) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, att_item, aat_dbl),
                                      reverse (var (dblVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_dbl),
                                     var ("DBL")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, att_item, aat_dbl),
                                  reverse (var (dblVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_dbl),
                                              cast (type (m_dbl), nil ()),
                                              cast (type (m_dbl), nil ())),
                                     var ("DBL")))
                    );
                }
            }

            /* consider dec results */
            if (ty & aat_dec) {
                execute (
                    bappend (var (decVAL->name),
                             reverse (
                                 kunique (
                                     reverse (
                                         select2 (VAR (R(p)->env,
                                                       att_item,
                                                       aat_dec),
                                                  cast (type (m_dbl), nil ()),
                                                  cast (type (m_dbl), nil ()))
                                         )))));
                if (ty == aat_dec) {
                    execute (
                        assgn (
                            var (item->name),
                            leftjoin (VAR (R(p)->env, att_item, aat_dec),
                                      reverse (var (decVAL->name)))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_dec),
                                     var ("DEC")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            join (VAR (R(p)->env, att_item, aat_dec),
                                  reverse (var (decVAL->name)))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_dec),
                                              cast (type (m_dbl), nil ()),
                                              cast (type (m_dbl), nil ())),
                                     var ("DEC")))
                    );
                }
            }

            /* consider bit results */
            if (ty & aat_bln) {
                if (ty == aat_int) {
                    execute (
                        assgn (
                            var (item->name),
                            mcast (type (m_oid),
                                   VAR (R(p)->env, att_item, aat_bln))),
                        assgn (
                            var (kind->name),
                            project (VAR (R(p)->env, att_item, aat_bln),
                                     var ("BOOL")))
                        );
                    sorted = true;
                }
                else {
                    execute (
                        binsert (
                            var (item->name),
                            mcast (type (m_oid),
                                   VAR (R(p)->env, att_item, aat_bln))),
                        binsert (
                            var (kind->name),
                            project (select2 (VAR (R(p)->env, att_item, aat_bln),
                                              cast (type (m_bit), nil ()),
                                              cast (type (m_bit), nil ())),
                                     var ("BOOL")))
                    );
                }
            }

            if (!sorted)
                execute (
                    assgn (var (item->name),
                           sort (var (item->name))),
                    assgn (var (kind->name),
                           leftjoin (mirror (var (item->name)),
                                     var (kind->name))));

            execute (
                assgn (var (item->name),
                       reverse (mark (reverse (var (item->name)),lit_oid (0)))),
                assgn (var (kind->name),
                       reverse (mark (reverse (var (kind->name)),lit_oid (0)))),

                serialize (
                    arg (lit_str ("xml"),
                        arg (var ("ws"),
                            arg (var (item->name),
                                arg (var (kind->name),
                                    arg (var (intVAL->name),
                                        arg (var (dblVAL->name),
                                            arg (var (decVAL->name),
                                                 var (strVAL->name))))))))));

            /*
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                if (i)
                    args = arg (args,
                                var (env_at (R(p)->env, i).mvar->name));
                else
                    args = var (env_at (R(p)->env, i).mvar->name);
            }

            execute (print (args));
            */

        } break;

        /* Query:   serialize (FragList, empty_tbl) */
        case 2:
        {
            mvar_t *intVAL, *dblVAL, *decVAL, *strVAL;
            mvar_t *item, *kind;

            reduce (kids[0], nts[0]);

            /* Set up all the value containers for print_result().
             * (It is actually too much overhead to introduce the value
             * containers just for printing. But this way we can re-use
             * Jan F's print_result() and stay compatible with the
             * ``summer branch''.
             */

            intVAL = new_var (1);
            dblVAL = new_var (1);
            decVAL = new_var (1);
            strVAL = new_var (1);
            item = new_var (1);
            kind = new_var (1);

            execute (
                assgn (var ("ws"), new_ws ()),
                assgn (var (intVAL->name),
                       seqbase (new (type (m_void), type (m_lng)), lit_oid (0))),
                assgn (var (dblVAL->name),                
                       seqbase (new (type (m_void), type (m_dbl)), lit_oid (0))),
                assgn (var (decVAL->name),                
                       seqbase (new (type (m_void), type (m_dbl)), lit_oid (0))),
                assgn (var (strVAL->name),                
                       seqbase (new (type (m_void), type (m_str)), lit_oid (0))),
                assgn (var (item->name),
                       seqbase (new (type (m_void), type (m_oid)), lit_oid (0))),
                assgn (var (kind->name),
                       seqbase (new (type (m_void), type (m_int)), lit_oid (0))),
                serialize (
                    arg (lit_str ("xml"),
                        arg (var ("ws"),
                            arg (var (item->name),
                                arg (var (kind->name),
                                    arg (var (intVAL->name),
                                        arg (var (dblVAL->name),
                                            arg (var (decVAL->name),
                                                 var (strVAL->name))))))))));
            unpin (intVAL, 1);
            unpin (dblVAL, 1);
            unpin (decVAL, 1);
            unpin (strVAL, 1);
            unpin (item, 1);
            unpin (kind, 1);
        } break;

        /* Rel:      lit_tbl */
        case 10:

            /* iterate over table columns */
            for (unsigned int col = 0; col < p->schema.count; col++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & p->schema.items[col].type) {
                        /* special support for QNames */
                        if (t == aat_qname)
                        {
                            /* insert qnames into working set
                               and insert corresponding offsets
                               into result */
                            mvar_t *v = new_var (p->refctr);

                            env_add (p->env, p->schema.items[col].name, t, v);

                            execute (
                                assgn (
                                    var (v->name),
                                    seqbase (
                                        new (type (m_void), implty (t)),
                                        lit_oid (0))));

                            for (unsigned int row = 0;
                                    row < p->sem.lit_tbl.count; row++)
                                execute (
                                    append (
                                        var (v->name),
                                        /* add_qname changes the working set 
                                           in 'var ("ws")' as side effect */
                                        add_qname (lit_str (
                                                       PFqname_ns (
                                                           p->sem.lit_tbl
                                                                 .tuples[row]
                                                                 .atoms[col]
                                                                 .val.qname)),
                                                   lit_str (
                                                       PFqname_uri (
                                                           p->sem.lit_tbl
                                                                 .tuples[row]
                                                                 .atoms[col]
                                                                 .val.qname)),
                                                   lit_str (
                                                       PFqname_loc (
                                                           p->sem.lit_tbl
                                                                 .tuples[row]
                                                                 .atoms[col]
                                                                 .val.qname)),
                                                   var ("ws"))));

                            execute (access (var (v->name), BAT_READ));
                        } else {
                            mvar_t *v = new_var (p->refctr);
                            env_add (p->env, p->schema.items[col].name, t, v);

                            execute (
                                assgn (
                                    var (v->name),
                                    seqbase (
                                        new (type (m_void), implty (t)),
                                        lit_oid (0))));

                            for (unsigned int row = 0;
                                    row < p->sem.lit_tbl.count; row++)
                                execute (
                                    append (
                                        var (v->name),
                                        t == p->sem.lit_tbl.tuples[row]
                                                            .atoms[col].type
                                        ? literal (p->sem.lit_tbl.tuples[row]
                                                                  .atoms[col])
                                        : cast (implty (t), nil ())));

                            execute (access (var (v->name), BAT_READ));
                        }
                    }

            break;

        /* Rel:     empty_tbl */
        case 11:
            PFoops (OOPS_FATAL,
                    "empty sequence should never occur in mil generation.");
            break;

        /* Rel:      attach (Rel) */
        case 12:
        {
            /* copy all the existing variables */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }

            /* now create the new column */
            mvar_t *v = new_var (p->refctr);
            env_add (p->env, p->sem.attach.attname,
                     p->sem.attach.value.type, v);

            execute (
                assgn (var (v->name),
                       project (var (env_at (p->env, 0).mvar->name),
                                literal (p->sem.attach.value))));

        } break;

        /* Rel:      cross (Rel, Rel) */
        case 13:
        {
            mvar_t *v  = new_var (1);
            mvar_t *v1 = new_var (1);
            mvar_t *v2 = new_var (1);

            if (!env_count (L(p)->env) || !env_count (R(p)->env))
                PFoops (OOPS_FATAL, "Cross does not cope with empty schemas");

            execute (
                assgn (var (v->name),
                       cross (project (var (env_at (L(p)->env, 0).mvar->name),
                                    nil ()),
                              reverse (
                                  project (var (env_at (R(p)->env, 0).mvar->name),
                                        nil ())))),
                assgn (var (v1->name),
                       reverse (mark (var (v->name), lit_oid (0)))),
                assgn (var (v2->name),
                       reverse (mark (reverse (var (v->name)), lit_oid (0)))));

            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                mvar_t *tmp  = new_var (p->refctr);
                /* expand variables */
                execute (
                    assgn (var (tmp->name),
                           leftjoin (var (v1->name),
                                     var (env_at (L(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (tmp->name),
                           reverse (mark (reverse (var (tmp->name)),
                                          lit_oid (0)))));
                
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         tmp);
            }
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                mvar_t *tmp  = new_var (p->refctr);
                /* expand variables */
                execute (
                    assgn (var (tmp->name),
                           leftjoin (var (v2->name),
                                     var (env_at (R(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (tmp->name),
                           reverse (mark (reverse (var (tmp->name)),
                                          lit_oid (0)))));
                
                env_add (p->env,
                         env_at (R(p)->env, i).att,
                         env_at (R(p)->env, i).ty,
                         tmp);
            }

            unpin (v, 1);
            unpin (v1, 1);
            unpin (v2, 1);
        }
            break;

        /* Rel:      leftjoin (Rel, Rel) */
        case 14:
        /* Rel:      eqjoin (Rel, Rel) */
        case 15:
        {
            /*
             * We actually cannot guarantee that MonetDB applies a
             * MergeJoin (tactical optimization may choose other
             * implementations). By using leftjoin(), however, we
             * can guarantee the result to be correctly ordered.
             */
            PFalg_simple_type_t lty = type_of (L(p), p->sem.eqjoin.att1);
            PFalg_simple_type_t rty = type_of (R(p), p->sem.eqjoin.att2);
            mvar_t *l = NULL;
            mvar_t *r = NULL;
            mvar_t *tmp1 = new_var (1);
            mvar_t *tmp[2] = { [0] = new_var (1), [1] = new_var (1) };

            assert (lty == rty);

            for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                if (t == lty && t == rty) {
                    l = env_mvar_worker (L(p)->env, p->sem.eqjoin.att1, t);
                    r = env_mvar_worker (R(p)->env, p->sem.eqjoin.att2, t);
                    break;
                }
            }

            if (!l || !r)
                PFoops (OOPS_FATAL, "incompatible types in Join");

            execute (
                assgn (var (tmp1->name),
                       leftjoin (var (l->name), reverse (var (r->name)))),
                assgn (var (tmp[0]->name),
                       reverse (mark (var (tmp1->name), lit_oid (0)))),
                assgn (var (tmp[1]->name),
                       reverse (
                           mark (reverse (var (tmp1->name)), lit_oid (0)))));

            unpin (tmp1, 1);

            for (unsigned short c = 0; c < 2; c++)
                for (unsigned int i = 0; i < env_count (p->child[c]->env); i++)
                    if (attr_req (p->prop, env_at (p->child[c]->env, i).att)) {

                        mvar_t *v = new_var (p->refctr);

                        execute (
                            assgn (var (v->name),
                                leftjoin (
                                    var (tmp[c]->name),
                                    var (env_at (p->child[c]->env,
                                                 i).mvar->name))),
                            /* because leftjoin does not know that we have 
                               exactly one match for each tuple in v,
                               we need to make the heads void ourselves */
                            assgn (var (v->name),
                                   reverse (mark (reverse (var (v->name)),
                                                  lit_oid (0))))
                            );

                        env_add (p->env,
                                 env_at (p->child[c]->env, i).att,
                                 env_at (p->child[c]->env, i).ty,
                                 v);
                    }

            unpin (tmp[0], 1);
            unpin (tmp[1], 1);

        } break;

        /* Rel:      project (Rel) */
        case 20:
            /*
             * Algebra projection is a no-op. We only fill the
             * environment in node p appropriately.
             */
            for (unsigned int i = 0; i < p->sem.proj.count; i++)
              if (attr_req (p->prop, p->sem.proj.items[i].new))
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & type_of (L(p), p->sem.proj.items[i].old)) {

                        mvar_t *v = env_mvar (L(p)->env,
                                              p->sem.proj.items[i].old,
                                              t);

                        env_add (p->env, p->sem.proj.items[i].new, t, v);
                        pin (v, p->refctr);

                    }

            break;

        /* Rel:      select (Rel) */
        case 21:
        {
            mvar_t *v = new_var (1);

            /*
             * For the predicate column c do
             *
             *  v := c.select (true).mark (0@0).reverse ();
             */
            execute (
                assgn (
                    var (v->name),
                    reverse (
                        mark (
                            select_(VAR (L(p)->env, p->sem.select.att,aat_bln),
                                    lit_bit (true)),
                            lit_oid (0)))));

            /*
             * Then join any BAT in L(p)'s environment with v
             */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                mvar_t *w = new_var (p->refctr);

                execute (
                    assgn (var (w->name),
                           leftjoin (var (v->name),
                                     var (env_at (L(p)->env, i).mvar->name))),
                    /* because leftjoin does not know that we have 
                       exactly one match for each tuple in v,
                       we need to make the heads void ourselves */
                    assgn (var (w->name),
                           reverse (mark (reverse (var (w->name)),
                                          lit_oid (0)))));

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         w);
            }

            /* release v */
            unpin (v, 1);

        } break;

        /* Rel:      append_union (Rel, Rel) */
        case 22:

            for (unsigned int i = 0; i < p->schema.count; i++)
                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & p->schema.items[i].type) {

                        mvar_t *v = new_var (p->refctr);

                        /*
                         * Type t is in the result relation. See if it
                         * is also in the left operand.
                         */
                        if (t & type_of (L(p), p->schema.items[i].name))
                            /* v := l.copy */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        copy (VAR (L(p)->env,
                                                   p->schema.items[i].name,
                                                   t)),
                                        BAT_APPEND)));
                        else
                            /* v := <some BAT of L>.project(nil); */
                            execute (
                                assgn (
                                    var (v->name),
                                    access (
                                        project (
                                            var (env_at (L(p)->env, 0).mvar
                                                                       ->name),
                                            cast (implty (t), nil ())),
                                        BAT_APPEND)));

                        /*
                         * Is t also in the right operand?
                         */
                        if (t & type_of (R(p), p->schema.items[i].name))
                            /* v.append(R); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        VAR (R(p)->env,
                                             p->schema.items[i].name,
                                             t)),
                                    BAT_READ));
                        else
                            /* v.append(<some BAT of L>.project(nil)); */
                            execute (
                                access (
                                    bappend (
                                        var (v->name),
                                        project (
                                            var (env_at (R(p)->env, 0).mvar
                                                                       ->name),
                                            cast (implty (t), nil ()))),
                                    BAT_APPEND));

                        env_add (p->env, p->schema.items[i].name, t, v);
                    }

            break;

        /* Rel:      append_union (hash_count (Rel),
                                   attach (diff (Rel, 
                                                 project (hash_count (Rel))))) */
        case 23:
        {
            if (L(p) == RLRL(p) && 
                R(p)->sem.attach.attname == att_item &&
                R(p)->sem.attach.value.type == aat_int &&
                R(p)->sem.attach.value.val.int_ == 0 &&
                RLL(p)->schema.count == 1 &&
                RLL(p)->schema.items[0].name == att_iter &&
                RLR(p)->schema.count == 1 &&
                RLR(p)->schema.items[0].name == att_iter &&
                L(p)->sem.count.part != att_NULL) {

                for (unsigned int i = 0; i < LL(p)->schema.count; i++)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & LL(p)->schema.items[i].type) {

                            if (t != LL(p)->schema.items[i].type)
                                PFoops (OOPS_FATAL,
                                        "HashCount not implemented for "
                                        "polymorphic groups");

                            mvar_t *v    = new_var (1);
                            mvar_t *res  = new_var (p->refctr);
                            mvar_t *part = new_var (p->refctr);

                            execute (
                                /* v := {count}(p_in.reverse ()) */
                                assgn (
                                    var (v->name),
                                    egcount (
                                        reverse (VAR (LL(p)->env,
                                                      L(p)->sem.count.part, t)),
                                        reverse (VAR (RLL(p)->env,
                                                      att_iter, t)))),
                                /* align with integer representation (lng) */
                                assgn (var (v->name),
                                       mcast (type (m_lng), var (v->name))),
                                /* res := v.reverse ().mark (0@0).reverse (); */
                                assgn (
                                    var (res->name),
                                    reverse (
                                        mark (
                                            reverse (var (v->name)),
                                            lit_oid (0)))),
                                /* part := v.mark (0@0).reverse (); */
                                assgn (
                                    var (part->name),
                                    reverse (
                                        mark (var (v->name), lit_oid (0)))));

                            env_add (p->env, L(p)->sem.count.res, aat_int, res);
                            env_add (p->env, L(p)->sem.count.part, t, part);

                            unpin (v, 1);
                        }

                /* the relation in hash_count is used twice in this pattern
                   - the DAG however counts only one reference - thus we 
                   increase the pin count of the affected variables */
                for (unsigned int i = 0; i < PFarray_last (LL(p)->env); i++)
                    pin (env_at (LL(p)->env, i).mvar, 1);
            }
            else
                PFoops (OOPS_FATAL, 
                        "translation in milgen.brg is incorrect "
                        "- please remove");
        } break;

        /* Rel:      merge_union (Rel, Rel) */
        case 24:
        {
            PFmil_t *grouping[2];
            PFmil_t *args;
            bool     single_column_grouping = true;
            mvar_t  *v = NULL;

            /*
             * If the grouping parameter for MergeUnion is just a
             * single column, we can use the corresponding BAT right
             * away.  Otherwise, we need to use MonetDB's CT...()
             * functions to generate a BAT that describes just that
             * grouping.
             */
            grouping[0]
                = VAR (L(p)->env,
                       PFord_order_at (p->sem.merge_union.ord, 0),
                       type_of (L(p),
                                PFord_order_at (p->sem.merge_union.ord, 0)));
            grouping[1]
                = VAR (R(p)->env,
                       PFord_order_at (p->sem.merge_union.ord, 0),
                       type_of (R(p),
                                PFord_order_at (p->sem.merge_union.ord, 0)));

            /*
             * We know (from the ordering properties we derived) that
             * our input is appropriately ordered. The grouping
             * function CTderive(), however, also provides grouping
             * from un-ordered groups (using a hash-based implementation).
             * This way, the resulting grouping BATs will not be marked
             * as tail-ordered (although they always will be, as we
             * know from our own ordering properties). We thus need to
             * check orderings explicitly (using chk_order()).
             *
             * An alternative to CTderive() could help us in two ways:
             *
             *  (1) There's actually no need to use a hash-based
             *      implementation, if we know that our input has the
             *      correct ordering.
             *  (2) An order-aware implementation could set ordering
             *      properties correctly right away.
             */
            for (unsigned int i = 1;
                    i < PFord_count (p->sem.merge_union.ord); i++) {

                single_column_grouping = false;

                grouping[0]
                    = ctderive (
                        grouping[0],
                        VAR (L(p)->env,
                             PFord_order_at (p->sem.merge_union.ord, i),
                             type_of (
                                 L(p),
                                 PFord_order_at (p->sem.merge_union.ord, i))));
                grouping[1]
                    = ctderive (
                        grouping[1],
                        VAR (R(p)->env,
                             PFord_order_at (p->sem.merge_union.ord, i),
                             type_of (
                                 R(p),
                                 PFord_order_at (p->sem.merge_union.ord, i))));
            }

            /*
             * If we had to CTderive(), turn the grp result into an
             * actual BAT using CTmap().
             */
            if (PFord_count (p->sem.merge_union.ord) > 1)
                for (unsigned int i = 0; i < 2; i++)
                    grouping[i] = ctmap (grouping[i]);


            /* first two arguments of merged_union() are the grouping atts */
            args = arg (chk_order (grouping[0]), chk_order (grouping[1]));

            for (unsigned int i = 0; i < p->schema.count; i++) {

                /*
                 * If we group by a single column, then we don't need
                 * to list the grouping attribute a second time.
                 */
                if (!single_column_grouping
                    || p->schema.items[i].name !=
                       PFord_order_at (p->sem.merge_union.ord, 0)) {

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & p->schema.items[i].type) {

                            for (unsigned short j = 0; j <= 1; j++)
                                /*
                                 * If t is among the operand's types, use the
                                 * corresponding BAT, otherwise substitute a
                                 * BAT with `nil' tail.
                                 */
                                if (t & type_of (p->child[j],
                                                 p->schema.items[i].name))
                                    args = arg (args,
                                                VAR (p->child[j]->env,
                                                     p->schema.items[i].name,
                                                     t));
                                else
                                    args = arg (args,
                                                project (grouping[j],
                                                         cast (implty(t),
                                                               nil ())));
                        }
                }
            }

            v = new_var (1);

            /* execute merged_union() and assign it to v */
            execute (assgn (var (v->name), merged_union (args)));

            unsigned int j = 1;

            /* now extract all the result BATs */
            for (unsigned int i = 0; i < p->schema.count; i++) {

                /*
                 * If we group by a single column, then the grouping
                 * attribute is to be found as the first result BAT.
                 */
                if (!single_column_grouping
                    || p->schema.items[i].name !=
                       PFord_order_at (p->sem.merge_union.ord, 0)) {

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & p->schema.items[i].type) {

                            mvar_t *w = new_var (p->refctr);

                            execute (
                                assgn (var (w->name),
                                       fetch (var (v->name), lit_int (j))));
                            env_add (p->env, p->schema.items[i].name, t, w);
                            j++;

                        }
                }
                else {
                    PFalg_simple_type_t t
                        = type_of (p, p->schema.items[i].name);
                    mvar_t *w = new_var (p->refctr);

                    env_add (p->env, p->schema.items[i].name, t, w);
                    execute (
                            assgn (var (w->name),
                                fetch (var (v->name), lit_int (0))));
                }
            }

            /* release our temporary variable v */
            unpin (v, 1);

        } break;

        /* Rel:      intersect (Rel, Rel) */
        case 25:
            PFoops (OOPS_FATAL,
                    "intersect not implemented yet.");
            break;

        /* Rel:      difference (Rel, Rel) */
        case 26:
            
            if (env_count (L(p)->env) == 1) {

                mvar_t *v = new_var (p->refctr);

                execute (
                    assgn (
                        var (v->name),
                        reverse (
                            mark (
                                kdiff (
                                    reverse (
                                        var (env_at (L(p)->env, 0).mvar->name)),
                                    reverse (VAR (R(p)->env,
                                                  env_at (L(p)->env, 0).att,
                                                  env_at (L(p)->env, 0).ty))),
                                lit_oid (0)))));

                env_add (p->env,
                         env_at (L(p)->env, 0).att,
                         env_at (L(p)->env, 0).ty,
                         v);
            }
            else
                PFoops (OOPS_FATAL,
                        "don't know how to handle physical Difference operator "
                        "with more than one attribute.");

            break;

        /* Rel:      sort_distinct (Rel) */
        case 30:
        /* Rel:      sort_distinct (std_sort (Rel)) */
        case 31: 
        /* Rel:      sort_distinct (refine_sort (Rel)) */
        case 32: 
            /* as we have to sort anyway we can also skip the sort operator */
        {
            /*
             * Derive a single BAT from the multi-column grouping
             * (using functions from the xtables module).
             */
            mvar_t  *v = new_var (1);
            bool     initialized = false;
            PFpa_op_t *rel;

            if (L(p)->kind == pa_std_sort || L(p)->kind == pa_refine_sort)
                rel = LL(p);
            else
                rel = L(p);

            /* cope with completely constant relations */
            if (!PFord_count (p->sem.sort_distinct.ord))
                execute (assgn (var (v->name),
                                var (env_at (rel->env, 0).mvar->name)));

            for (unsigned int i = 0;
                    i < PFord_count (p->sem.sort_distinct.ord); i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & type_of (rel,
                                     PFord_order_at (p->sem.sort_distinct.ord,
                                                     i))) {
                        if (!initialized) {
                            execute (
                                assgn (
                                    var (v->name),
                                    reverse (
                                        sort (
                                            reverse (VAR (rel->env,
                                                          PFord_order_at (
                                                              p->sem
                                                               .sort_distinct
                                                               .ord, i), 
                                                     t))))));
                            initialized = true;
                        }
                        else {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (rel->env,
                                             PFord_order_at (p->sem
                                                               .sort_distinct
                                                               .ord, i),
                                             t))));
                        }
                    }
                }
            }

            /*
             * Variable v is now of MIL type grp and contains the
             * grouping we need.
             *
             * We get the duplicate-free equivalent of our input by
             * joining the extend of v with each input BAT (and
             * generating a new key with mark().
             *
             * v := v.CTextend ().mark (0@0).reverse ();
             */
            execute (
                assgn (var (v->name),
                       reverse (mark (reverse (
                                          kunique( reverse (var (v->name)))),
                                      lit_oid (0)))));

            /*
             * The join with each input relation:
             *
             * out := v.join (in);
             */
            for (unsigned int i = 0; i < env_count (rel->env); i++)
                if (attr_req (p->prop, env_at (rel->env, i).att)) {

                    mvar_t *out = new_var (p->refctr);

                    execute (
                        assgn (var (out->name),
                               leftjoin (var (v->name),
                                         var (env_at (rel->env,
                                                      i).mvar->name))),
                        /* because leftjoin does not know that we have 
                           exactly one match for each tuple in v,
                           we need to make the heads void ourselves */
                        assgn (var (out->name),
                               reverse (mark (reverse (var (out->name)),
                                              lit_oid (0)))));

                    env_add (p->env,
                             env_at (rel->env, i).att,
                             env_at (rel->env, i).ty,
                             out);
                }

            /* release our temporary variable */
            unpin (v, 1);

        } break;

        /* Rel:      std_sort (Rel) */
        case 33:
            {
                unsigned int  count = 0;
                mvar_t       *v     = new_var (1);

                for (unsigned int i = 0;
                        i < PFord_count (p->sem.sortby.required); i++)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & type_of (L(p),
                                         PFord_order_at (p->sem.sortby.required,
                                                         i))) {
                            if (count) {
                                execute (
                                    assgn (
                                        var (v->name),
                                        ctrefine (
                                            var (v->name),
                                            VAR (L(p)->env,
                                                 PFord_order_at (
                                                     p->sem.sortby.required,
                                                     i),
                                                 t))));
                            }
                            else {
                                execute (
                                    assgn (
                                        var (v->name),
                                        reverse (sort (reverse (
                                            VAR (L(p)->env,
                                                 PFord_order_at (
                                                     p->sem.sortby.required,
                                                     i),
                                                 t))))));
                            }
                            count++;
                        }

                execute (assgn (var (v->name),
                                reverse (mark (var (v->name), lit_oid (0)))));

                for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                    if (attr_req (p->prop, env_at (L(p)->env, i).att)) {

                        mvar_t *a = new_var (p->refctr);

                        execute (
                            assgn (var (a->name),
                                   leftjoin (
                                       var (v->name),
                                       var (env_at (L(p)->env, i).mvar->name))),
                            /* because leftjoin does not know that we have 
                               exactly one match for each tuple in v,
                               we need to make the heads void ourselves */
                            assgn (var (a->name),
                                   reverse (mark (reverse (var (a->name)),
                                                  lit_oid (0)))));

                        env_add (p->env,
                                 env_at (L(p)->env, i).att,
                                 env_at (L(p)->env, i).ty,
                                 a);
                    }

                unpin (v, 1);
            }
            break;

        /* Rel:      refine_sort (Rel) */
        case 34:
        {
            mvar_t  *v = new_var (1);
            bool     initialized = false;

            /*
             * Create a MonetDB grp object according to the already
             * existing order.
             */
            for (unsigned int i = 0;
                    i < PFord_count (p->sem.sortby.existing); i++) {
                for (PFalg_simple_type_t t = 1; t; t <<= 1) {
                    if (t & type_of (L(p),
                                     PFord_order_at (p->sem.sortby.existing,
                                                     i))) {
                        if (!initialized) {
                            execute (
                                assgn (
                                    var (v->name),
                                    VAR (L(p)->env,
                                    PFord_order_at (p->sem
                                                      .sortby
                                                      .existing, i),
                                    t)));
                            initialized = true;
                        }
                        else {
                            execute (
                                assgn (
                                    var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (L(p)->env,
                                             PFord_order_at (p->sem
                                                               .sortby
                                                               .existing, i),
                                             t))));
                        }
                    }
                }
            }

            /*
             * Now do the remaining sorting
             */
            for (unsigned int i = PFord_count (p->sem.sortby.existing);
                    i < PFord_count (p->sem.sortby.required); i++) {
                /*
                 * Be careful to implement document order on
                 * nodes correctly:
                 *
                 *  - sort by fragment first, then by pre/attr
                 *    (the aat_pfrag/aat_afrag bit is lower
                 *     than the aat_pre/aat_attr bit)
                 *  - document order of attributes and other nodes
                 *    requires extra effort
                 */
                assert(!((aat_anode & 
                          type_of (L(p),
                                   PFord_order_at (p->sem.sortby.required,
                                                   i))) &&
                         (aat_pnode &
                          type_of (L(p),
                                  PFord_order_at (p->sem.sortby.required,
                                                  i)))));

                for (PFalg_simple_type_t t = 1; t; t <<= 1)
                    if (t & type_of (L(p),
                                     PFord_order_at (p->sem.sortby.required,
                                                     i))) {
                         execute (
                             assgn (var (v->name),
                                    ctrefine (
                                        var (v->name),
                                        VAR (L(p)->env,
                                             PFord_order_at (p->sem
                                                               .sortby
                                                               .required,
                                                             i),
                                             t))));
                    }
            }

            execute (
                assgn (var (v->name),
                       reverse (mark (var (v->name), lit_oid (0)))));

            for (unsigned int i = 0; i < env_count (L(p)->env); i++)
                if (attr_req (p->prop, env_at (L(p)->env, i).att)) {

                    mvar_t *a = new_var (p->refctr);

                    execute (
                        assgn (var (a->name),
                            leftjoin (
                                var (v->name),
                                var (env_at (L(p)->env, i).mvar->name))),
                        /* because leftjoin does not know that we have 
                           exactly one match for each tuple in v,
                           we need to make the heads void ourselves */
                        assgn (var (a->name),
                               reverse (mark (reverse (var (a->name)),
                                              lit_oid (0))))
                        );

                    env_add (p->env,
                             env_at (L(p)->env, i).att,
                             env_at (L(p)->env, i).ty,
                             a);
                }

            unpin (v, 1);

        } break;

        /* Rel:      num_add (Rel) */
        case 40:
            bin_arith (PFmil_madd, p);
            break;

        /* Rel:      num_sub (Rel) */
        case 41:
            bin_arith (PFmil_msub, p);
            break;

        /* Rel:      num_mult (Rel) */
        case 42:
            bin_arith (PFmil_mmult, p);
            break;

        /* Rel:      num_div (Rel) */
        case 43:
            bin_arith (PFmil_mdiv, p);
            break;

        /* Rel:      num_mod (Rel) */
        case 44:
            bin_arith (PFmil_mmod, p);
            break;

        /* Rel:      num_add_atom (Rel) */
        case 45:
            bin_arith_atom (PFmil_madd, p);
            break;

        /* Rel:      num_sub_atom (Rel) */
        case 46:
            bin_arith_atom (PFmil_msub, p);
            break;

        /* Rel:      num_mult_atom (Rel) */
        case 47:
            bin_arith_atom (PFmil_mmult, p);
            break;

        /* Rel:      num_div_atom (Rel) */
        case 48:
            bin_arith_atom (PFmil_mdiv, p);
            break;

        /* Rel:      num_mod_atom (Rel) */
        case 49:
            bin_arith_atom (PFmil_mmod, p);
            break;

        /* Rel:      eq (Rel) */
        case 50:
            bin_comp (PFmil_meq, p);
            break;

        /* Rel:      eq_atom (Rel) */
        case 51:
            bin_comp_atom (PFmil_meq, p);
            break;

        /* Rel:      gt (Rel) */
        case 52:
            bin_comp (PFmil_mgt, p);
            break;

        /* Rel:      gt_atom (Rel) */
        case 53:
            bin_comp_atom (PFmil_mgt, p);
            break;

        /* Rel:      num_neg (Rel) */
        case 60:
            unary_op (PFmil_mneg, p);
            break;

        /* Rel:      bool_not (Rel) */
        case 61:
            unary_op (PFmil_mnot, p);
            break;

        /* Rel:      bool_and (Rel) */
        case 62:
            bin_bool (PFmil_mand, p);
            break;

        /* Rel:      bool_or (Rel) */
        case 63:
            bin_bool (PFmil_mor, p);
            break;

        /* Rel:      bool_and_atom (Rel) */
        case 64:
            bin_bool_atom (PFmil_mand, p);
            break;

        /* Rel:      bool_or_atom (Rel) */
        case 65:
            bin_bool_atom (PFmil_mor, p);
            break;

        /* Rel:      hash_count (Rel) */
        case 66:
            if (p->sem.count.part != att_NULL) {
                for (unsigned int i = 0; i < L(p)->schema.count; i++)
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            if (t != L(p)->schema.items[i].type)
                                PFoops (OOPS_FATAL,
                                        "HashCount not implemented for "
                                        "polymorphic groups");

                            mvar_t *v    = new_var (1);
                            mvar_t *res  = new_var (p->refctr);
                            mvar_t *part = new_var (p->refctr);

                            execute (
                                /* v := {count}(p_in.reverse ()) */
                                assgn (
                                    var (v->name),
                                    gcount (
                                        reverse (VAR (L(p)->env,
                                                      p->sem.count.part, t)))),
                                /* align with integer representation (lng) */
                                assgn (var (v->name),
                                       mcast (type (m_lng), var (v->name))),
                                /* res := v.reverse ().mark (0@0).reverse (); */
                                assgn (
                                    var (res->name),
                                    reverse (
                                        mark (
                                            reverse (var (v->name)),
                                            lit_oid (0)))),
                                /* part := v.mark (0@0).reverse (); */
                                assgn (
                                    var (part->name),
                                    reverse (
                                        mark (var (v->name), lit_oid (0)))));

                            env_add (p->env, p->sem.count.res, aat_int, res);
                            env_add (p->env, p->sem.count.part, t, part);

                            unpin (v, 1);
                        }
            }
            else {

                mvar_t *v = new_var (p->refctr);
                execute (
                    assgn (var (v->name),
                           count (var (env_at (L(p)->env, 0).mvar->name))),
                    /* align with integer representation (lng) */
                    assgn (var (v->name),
                           cast (type (m_lng), var (v->name))),
                    assgn (var (v->name),
                           append (
                               seqbase (
                                   new (type (m_void), type (m_lng)),
                                   lit_oid (0)),
                               var (v->name))));
                env_add (p->env, p->sem.count.res, aat_int, v);
            }
            break;

        /* Rel:      avg (Rel) */
        case 67:
	     aggr_function(PFmil_avg, PFmil_gavg, p);
	     break;

        /* Rel:      max_ (Rel) */
        case 68:
	     aggr_function(PFmil_max, PFmil_gmax, p);
	     break;

        /* Rel:      min_ (Rel) */
        case 69:
	     aggr_function(PFmil_min, PFmil_gmin, p);
	     break;

        /* Rel:      sum (Rel) */
        case 70:
	     aggr_function(PFmil_sum, PFmil_gsum, p);
	     break;

        /* Rel:      merge_rownum (Rel) */
        case 71:
        {
            mvar_t *v = new_var (p->refctr);

            /* copy all the attributes from our argument */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                pin (env_at (L(p)->env, i).mvar, p->refctr);

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }

            /* and add the newly numbered one */
            if (p->sem.rownum.part != att_NULL)
                execute (
                    assgn (var (v->name),
                           mark_grp (
                               VAR (p->env,
                                    p->sem.rownum.part,
                                    type_of (p, p->sem.rownum.part)),
                               project (
                                   kunique (
                                       reverse (
                                           VAR (p->env,
                                                p->sem.rownum.part,
                                                type_of (p, p->sem.rownum.part))
                                           )),
                                   lit_oid (1)))));
            else
                execute (
                    assgn (var (v->name),
                           mark (var (env_at (L(p)->env, 0).mvar->name),
                                 lit_oid (1))));

            env_add (p->env, p->sem.rownum.attname, aat_nat, v);

        } break;

        /* Rel:      hash_rownum (Rel) */
        case 72:
            PFoops (OOPS_FATAL,
                    "hash_rownum not implemented yet.");
            break;

        /* Rel:      number (Rel) */
        case 73:
        {
            mvar_t *res = new_var (p->refctr);

            assert (env_count (L(p)->env));

            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }

            /* and add the newly numbered one */
            if (p->sem.number.part != att_NULL)
                execute (
                    assgn (var (res->name),
                           mark_grp (
                               VAR (p->env,
                                    p->sem.number.part,
                                    type_of (p, p->sem.number.part)),
                               project (
                                   kunique (
                                       reverse (
                                           VAR (p->env,
                                                p->sem.number.part,
                                                type_of (p, p->sem.number.part))
                                           )),
                                   lit_oid (1)))));
            else
                execute (
                    assgn (var (res->name),
                           mark (var (env_at (L(p)->env, 0).mvar->name),
                                 lit_oid (1))));

            /* put the result into p's environment */
            env_add (p->env, p->sem.number.attname, aat_nat, res);
        } break;

        /* Rel:      type (Rel) */
        case 74:
        {
            mvar_t              *res = new_var (p->refctr);

            /* and put the result into p's environment */
            env_add (p->env, p->sem.type.res, aat_bln, res);

            /* everything from p's child */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }
            /* we have one simple type */
            if (p->sem.type.ty == aat_node)
                execute (
                    assgn (var (res->name),
                           mor (
                               mnot (misnil (VAR (L(p)->env,
                                             p->sem.type.att,
                                             aat_pre))),
                               mnot (misnil (VAR (L(p)->env,
                                             p->sem.type.att,
                                             aat_attr))))));
            else if (p->sem.type.ty == aat_pnode)
                execute (
                    assgn (var (res->name),
                           mnot (misnil (VAR (L(p)->env,
                                         p->sem.type.att,
                                         aat_pre)))));
            else if (p->sem.type.ty == aat_anode)
                execute (
                    assgn (var (res->name),
                           mnot (misnil (VAR (L(p)->env,
                                         p->sem.type.att,
                                         aat_attr)))));
            else
                execute (
                    assgn (var (res->name),
                           mnot (misnil (VAR (L(p)->env,
                                         p->sem.type.att,
                                         p->sem.type.ty)))));

        }
            break;

        /* Rel:      type_assert (Rel) */
        case 75:
            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Rel:      cast (Rel) */
        case 76:
            for (unsigned int i = 0; i < L(p)->schema.count; i++)
            {
                bool att_needed = true;
                mvar_t *v = new_var (p->refctr);

                /* cast as qname requires additional document access */
                if (L(p)->schema.items[i].name == p->sem.cast.att &&
                    p->sem.cast.ty == aat_qname) {

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if ((t & L(p)->schema.items[i].type) &&
                            (t != aat_str && t != aat_qname))
                            PFoops (OOPS_FATAL,
                                    "cast to type QName is only possible "
                                    "for type QName and type string.%i", t);

                    bool   qn = false;

                    /* nothing to do - just assign it to a new variable */
                    if (L(p)->schema.items[i].type & aat_qname)
                    {
                        execute (assgn (var (v->name), 
                                        VAR (L(p)->env, p->sem.cast.att,
                                             L(p)->schema.items[i].type)));
                        qn = true;
                    }

                    if (L(p)->schema.items[i].type & aat_str)
                    {
                        PFmil_t *str = NULL;
                        mvar_t  *offset = new_var (1);
                        mvar_t  *prefix = new_var (1);
                        mvar_t  *local  = new_var (1);
                        PFmil_t *v_cast = 
                                     VAR (L(p)->env, p->sem.cast.att,
                                          L(p)->schema.items[i].type);

                        /* split up strings using ``:'' as delimiter */
                        /* FIXME: currently we don't check names and
                                  we don't retrieve the URI */
                        execute (
                            assgn (var (offset->name),
                                   msearch (v_cast, lit_str (":"))),
                            assgn (var (prefix->name),
                                   mstring2 (v_cast,
                                             lit_int (0),
                                             var (offset->name))),
                            assgn (var (local->name),
                                   mstring (v_cast,
                                            madd (lit_int (1),
                                                  var (offset->name)))));

                        /* add_qnames changes the working set 
                           in 'var ("ws")' as side effect */
                        str = add_qnames (
                                  var (prefix->name),
                                  project (var (prefix->name),
                                           lit_str ("")),
                                  var (local->name),
                                  var ("ws"));

                        if (qn) /* combine both qname tables */
                            execute (assgn (var (v->name),
                                            mifthenelse (
                                                misnil (var (v->name)),
                                                str,
                                                var (v->name))));
                        else
                            execute (assgn (var (v->name), str));

                        unpin (offset, 1);
                        unpin (prefix, 1);
                        unpin (local, 1);
                    }
                }
                else if (L(p)->schema.items[i].name == p->sem.cast.att) {

                    unsigned int   parts = 0;

                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            PFmil_t *casted = NULL;

                            if (t == p->sem.cast.ty)
                                casted = VAR (L(p)->env, p->sem.cast.att, t);
                            else
                                casted
                                    = mcast (
                                        implty (p->sem.cast.ty),
                                        VAR (L(p)->env, p->sem.cast.att, t));

                            if (parts)
                                execute (assgn (var (v->name),
                                                mifthenelse (
                                                    misnil (var (v->name)),
                                                    casted,
                                                    var (v->name))));
                            else
                                execute (assgn (var (v->name), casted));

                            parts++;
                        }
                }

                if (L(p)->schema.items[i].name == p->sem.cast.att &&
                    p->sem.cast.att != p->sem.cast.res)
                    env_add (p->env, p->sem.cast.res, p->sem.cast.ty, v);
                else if (L(p)->schema.items[i].name == p->sem.cast.att)
                {
                    att_needed = false;
                    env_add (p->env, p->sem.cast.att, p->sem.cast.ty, v);
                }

                if (att_needed &&
                    (attr_req (p->prop, L(p)->schema.items[i].name))) {
                    for (PFalg_simple_type_t t = 1; t; t <<= 1)
                        if (t & L(p)->schema.items[i].type) {

                            mvar_t *v = env_mvar (L(p)->env,
                                                  L(p)->schema.items[i].name,
                                                  t);

                            env_add (p->env, L(p)->schema.items[i].name, t, v);
                            pin (v, p->refctr);
                        }
                }
            } break;

        /* Rel:      llscj_anc (FragList, Rel) */
        case 80:
            llscj (ax_anc, p);
            break;

        /* Rel:      llscj_anc_self (FragList, Rel) */
        case 81:
            llscj (ax_anc_self, p);
            break;

        /* Rel:      llscj_attr (FragList, Rel) */
        case 82:
        {
            /* abbreviations for input expressions */
            PFty_t           ty  = p->sem.scjoin.ty;

            /* MIL equivalents of input expression */
            PFmil_t *iter;
            PFmil_t *pre;
            PFmil_t *frag;

            mvar_t  *tmp;         /* helper variable */
            mvar_t  *ret_iter;    /* variable to which we assign the `iter' result */
            mvar_t  *ret_attr;     /* variable to which we assign the `pre' result */
            mvar_t  *ret_frag;    /* variable to which we assign the `kind' result */
            
            /*
             * Determine generic input arguments.
             */
            assert (p); assert (R(p)); assert (R(p)->env);
            iter = VAR (R(p)->env, att_iter, aat_nat); assert (iter);
            pre = VAR (R(p)->env, att_item, aat_pre); assert (pre);
            frag = VAR (R(p)->env, att_item, aat_pfrag); assert (frag);

            tmp      = new_var (1);
            ret_iter = new_var (p->refctr);
            ret_attr  = new_var (p->refctr);
            ret_frag = new_var (p->refctr);

            /* first get all attribute nodes... */
            execute (
                assgn (var (tmp->name), 
                       mvaljoin (pre, frag, fetch (var("ws"),
                                                    var("ATTR_OWN")))),
                assgn (var (ret_attr->name),
                       reverse (mark (reverse (var (tmp->name)), lit_oid (0)))),
                assgn (var (ret_frag->name),
                       leftjoin (reverse (mark (var (tmp->name), lit_oid (0))),
                                 frag)),
                assgn (var (ret_iter->name),
                       leftjoin (reverse (mark (var (tmp->name), lit_oid (0))),
                                 iter)));

            /* ... then filter out all nodes, whose name test does not match */
            if (PFty_subtype (ty, PFty_xs_anyAttribute ())) {

                /* Is it just a generic attribute kind test? (e.g. .../attribute()) */
                if (PFty_subtype (PFty_xs_anyAttribute (), ty))
                    ;

                /* Is it a test on attribute kind and local name only? */
                else if (PFty_subtype (
                            PFty_attr (PFqname (PFns_wild,
                                                PFty_qname (PFty_defn (ty)).loc),
                                       PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_QN"))),
                                         mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_CONT"))),
                                         fetch (var("ws"), var("QN_LOC")))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_loc (
                                                PFty_qname (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name), var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name), var (ret_iter->name))));

                /* Or maybe a test on attribute kind and namespace only? */
                else if (PFty_subtype (
                            PFty_attr (PFqname (PFty_qname (PFty_defn (ty)).ns,
                                                NULL),
                                       PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_QN"))),
                                         mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_CONT"))),
                                         fetch (var("ws"), var("QN_URI")))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_uri (
                                                PFty_qname (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name), var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name), var (ret_iter->name))));

                /* A test on attribute kind and full QName? */
                else if (PFty_subtype (
                            PFty_attr (PFty_qname (PFty_defn (ty)),
                                       PFty_xs_anySimpleType ()),
                            ty))
                    execute (
                        assgn (var (tmp->name),
                               mposjoin (mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_QN"))),
                                         mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_CONT"))),
                                         fetch (var("ws"), var("QN_LOC")))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_loc (
                                                PFty_qname (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name), var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name), var (ret_iter->name))),
                        assgn (var (tmp->name),
                               mposjoin (mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_QN"))),
                                         mposjoin (var (ret_attr->name),
                                                   var (ret_frag->name),
                                                   fetch (var("ws"),
                                                          var("ATTR_CONT"))),
                                         fetch (var("ws"), var("QN_URI")))),
                        assgn (var (tmp->name),
                               uselect (var (tmp->name),
                                        lit_str (
                                            PFqname_uri (
                                                PFty_qname (
                                                    PFty_defn (ty)))))),
                        assgn (var (tmp->name),
                               reverse (mark (var (tmp->name), lit_oid (0)))),
                        assgn (var (ret_attr->name),
                               leftjoin (var (tmp->name), var (ret_attr->name))),
                        assgn (var (ret_frag->name),
                               leftjoin (var (tmp->name), var (ret_frag->name))),
                        assgn (var (ret_iter->name),
                               leftjoin (var (tmp->name), var (ret_iter->name))));

                /*
                 * If we couldn't figure out what attribute test we got, give up.
                 *
                 * NOTE: The surface language actually allows such tests. We
                 *       just cannot implement them (yet):
                 *
                 *        doc("foo")/attribute::attribute(shoeSize, xs:integer)
                 */
                else
                    PFoops (OOPS_FATAL,
                            "Problem with an XPath step: cannot evaluate "
                            "node test `%s'", PFty_str (ty));
            }
            else
                PFoops (OOPS_FATAL,
                        "Problem with an XPath step: cannot evaluate "
                        "node test `%s'", PFty_str (ty));

            /* because leftjoin does not know that we have 
               exactly one match for each tuple in v,
               we need to make the heads void ourselves */
            execute (
                assgn (var (ret_attr->name),
                       reverse (mark (reverse (var (ret_attr->name)),
                                      lit_oid (0)))),
                assgn (var (ret_frag->name),
                       reverse (mark (reverse (var (ret_frag->name)),
                                      lit_oid (0)))),
                assgn (var (ret_iter->name),
                       reverse (mark (reverse (var (ret_iter->name)),
                                      lit_oid (0)))));

            if (attr_req (p->prop, att_iter))
                env_add (p->env, att_iter, aat_nat, ret_iter);
            else
                unpin (ret_iter, p->refctr);

            if (attr_req (p->prop, att_item)) {
                env_add (p->env, att_item, aat_attr, ret_attr);
                env_add (p->env, att_item, aat_afrag, ret_frag);
            } else {
                unpin (ret_attr, p->refctr);
                unpin (ret_frag, p->refctr);
            }

            unpin (tmp, 1);
        }
            break;

        /* Rel:      llscj_child (FragList, Rel) */
        case 83:
            llscj (ax_child, p);
            break;

        /* Rel:      llscj_desc (FragList, Rel) */
        case 84:
            llscj (ax_desc, p);
            break;

        /* Rel:      llscj_desc_self (FragList, Rel) */
        case 85:
            llscj (ax_desc_self, p);
            break;

        /* Rel:      llscj_foll (FragList, Rel) */
        case 86:
            llscj (ax_foll, p);
            break;

        /* Rel:      llscj_foll_sibl (FragList, Rel) */
        case 87:
            llscj (ax_foll_sibl, p);
            break;

        /* Rel:      llscj_parent (FragList, Rel) */
        case 88:
            llscj (ax_parent, p);
            break;

        /* Rel:      llscj_prec (FragList, Rel) */
        case 89:
            llscj (ax_prec, p);
            break;

        /* Rel:      llscj_prec_sibl (FragList, Rel) */
        case 90:
            llscj (ax_prec_sibl, p);
            break;

        /* FragRel:  doc_tbl (Rel) */
        case 100:
        {
            if (attr_req (p->prop, att_iter)) {
                /* copy the iter BAT */
                mvar_t *iter = env_mvar (L(p)->env, att_iter, aat_nat);

                env_add (p->env, att_iter, aat_nat, iter);
                pin (iter, p->refctr);
            }

            if (attr_req (p->prop, att_item)) {
                /* temporary variable */
                mvar_t *v = new_var (1);
                /* result BATs */
                mvar_t *frag = new_var (p->refctr);
                mvar_t *pre  = new_var (p->refctr);

                env_add (p->env, att_item, aat_pre, pre);
                env_add (p->env, att_item, aat_pfrag, frag);

                execute (
                    assgn (var (v->name),
                           doc_tbl (var ("ws"),
                                    VAR (L(p)->env, att_item, aat_str))),
                    assgn (var ("ws"), fetch (var (v->name), lit_int (0))),
                    assgn (var (pre->name), fetch (var (v->name), lit_int (1))),
                    assgn (var (frag->name), fetch (var (v->name), lit_int (2)))
                    );
            }
        } break;

        /* Rel:      doc_access (FragList, Rel) */
        case 101:
        {
            mvar_t *str   = new_var (p->refctr);

            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (R(p)->env); i++) {
                pin (env_at (R(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (R(p)->env, i).att,
                         env_at (R(p)->env, i).ty,
                         env_at (R(p)->env, i).mvar);
            }

            /* lookup the values in the documents using mposjoin */
            switch (p->sem.doc_access.doc_col)
            {
                case (doc_atext):
                    {
                        PFmil_t *attr  = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_attr);
                        PFmil_t *afrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_afrag);

                        execute (
                            assgn (var (str->name),
                                   mposjoin (mposjoin (attr,
                                                       afrag,
                                                       fetch (var("ws"),
                                                              var("ATTR_PROP"))),
                                             mposjoin (attr,
                                                       afrag,
                                                       fetch (var("ws"),
                                                              var("ATTR_CONT"))),
                                             fetch (var("ws"), var("PROP_VAL")))));
                    }
                    break;
                case (doc_text):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (mposjoin (pre,
                                                       pfrag,
                                                       fetch (var("ws"),
                                                              var("PRE_PROP"))),
                                             mposjoin (pre,
                                                       pfrag,
                                                       fetch (var("ws"),
                                                              var("PRE_CONT"))),
                                             fetch (var("ws"), var("PROP_TEXT")))));
                    }
                    break;
                case (doc_comm):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (mposjoin (pre,
                                                       pfrag,
                                                       fetch (var("ws"),
                                                              var("PRE_PROP"))),
                                             mposjoin (pre,
                                                       pfrag,
                                                       fetch (var("ws"),
                                                              var("PRE_CONT"))),
                                             fetch (var("ws"), var("PROP_COM")))));
                    }
                    break;
                case (doc_pi_text):
                    {
                        PFmil_t *pre  = VAR (R(p)->env,
                                             p->sem.doc_access.att,
                                             aat_pre);
                        PFmil_t *pfrag = VAR (R(p)->env,
                                              p->sem.doc_access.att,
                                              aat_pfrag);
                        execute (
                            assgn (var (str->name),
                                   mposjoin (mposjoin (pre,
                                                       pfrag,
                                                       fetch (var("ws"),
                                                              var("PRE_PROP"))),
                                             mposjoin (pre,
                                                       pfrag,
                                                       fetch (var("ws"),
                                                              var("PRE_CONT"))),
                                             fetch (var("ws"), var("PROP_INS")))));
                    }
                    break;
                default:
                    PFoops (OOPS_FATAL, 
                            "unexpected document column in doc_access (%i)",
                            p->sem.doc_access.doc_col);
            }

            env_add (p->env, p->sem.doc_access.res, aat_str, str);
        }
            break;

        /* FragRel: element (FragList, element_tag (Rel, empty_lit_tbl)) */
        case 102:
        {
            /* copy the iter BAT */
            if (attr_req (p->prop, att_iter)) {
                mvar_t *iter = env_mvar (L(R(p))->env, att_iter, aat_nat);
                env_add (p->env, att_iter, aat_nat, iter);
                pin (iter, p->refctr);
            }

            if (attr_req (p->prop, att_item)) {
                /* temporary variable */
                mvar_t *v = new_var (1);
                /* result BATs */
                mvar_t *pre  = new_var (p->refctr);
                mvar_t *frag = new_var (p->refctr);
                env_add (p->env, att_item, aat_pre, pre);
                env_add (p->env, att_item, aat_pfrag, frag);

                execute (
                    assgn (var (v->name),
                           empty_element (VAR (L(R(p))->env, 
                                               att_item, aat_qname),
                                          var ("ws"))),
                    assgn (var ("ws"), fetch (var (v->name), lit_int (0))),
                    assgn (var (pre->name), fetch (var (v->name), 
                                                   lit_int (1))),
                    assgn (var (frag->name), fetch (var (v->name),
                                                    lit_int (2)))
                    );
            }
        } break;

        /* FragRel: element (FragList, element_tag (Rel, Rel)) */
        case 103:
        {
            /* copy the iter BAT */
            if (attr_req (p->prop, att_iter)) {
                mvar_t *iter = env_mvar (L(R(p))->env, att_iter, aat_nat);
                env_add (p->env, att_iter, aat_nat, iter);
                pin (iter, p->refctr);
            }

            if (attr_req (p->prop, att_item)) {
                PFmil_t *pre, *pfrag, *attr, *afrag;
                mvar_t *tmp;

                /* temporary variable */
                mvar_t *v = new_var (1);
                /* result BATs */
                mvar_t *res_pre = new_var (p->refctr);
                mvar_t *res_frag = new_var (p->refctr);

                env_add (p->env, att_item, aat_pre, res_pre);
                env_add (p->env, att_item, aat_pfrag, res_frag);

                /* check occurrence of attributes and other nodes
                   and react accordingly */ 
                if ((tmp = env_mvar_worker (R(R(p))->env, att_item, aat_pre)))
                {
                    pre = var (tmp->name);
                    pfrag = VAR (R(R(p))->env, att_item, aat_pfrag);
                } else {
                    pre = seqbase (new (type (m_void), type (m_oid)),
                                   lit_oid (0));
                    pfrag = pre;
                }
                
                if ((tmp = env_mvar_worker (R(R(p))->env, att_item, aat_attr)))
                {
                    attr = var (tmp->name);
                    afrag = VAR (R(R(p))->env, att_item, aat_afrag);
                } else {
                    attr = seqbase (new (type (m_void), type (m_oid)),
                                   lit_oid (0));
                    afrag = attr;
                }

                execute (
                    assgn (var (v->name),
                           element (VAR (L(R(p))->env, att_iter, aat_nat),
                                    VAR (L(R(p))->env, att_item, aat_qname),
                                    VAR (R(R(p))->env, att_iter, aat_nat),
                                    pre, pfrag, attr, afrag,
                                    var ("ws"))),
                    assgn (var ("ws"), fetch (var (v->name), lit_int (0))),
                    assgn (var (res_pre->name), 
                           fetch (var (v->name), lit_int (1))),
                    assgn (var (res_frag->name),
                           fetch (var (v->name), lit_int (2)))
                    );
            }

        } break;

        /* FragRel: attribute (Rel, Rel) */
        case 104:
        {
            /* temporary variable */
            mvar_t *v = new_var (1);
            /* result BATs */
            mvar_t *attr  = new_var (p->refctr);
            mvar_t *frag = new_var (p->refctr);

            env_add (p->env, p->sem.attr.res, aat_attr, attr);
            env_add (p->env, p->sem.attr.res, aat_afrag, frag);

            execute (
                assgn (var (v->name),
                       attribute (VAR (L(p)->env, p->sem.attr.qn, aat_qname),
                                  VAR (R(p)->env, p->sem.attr.val, aat_str),
                                  var ("ws"))),
                assgn (var ("ws"), fetch (var (v->name), lit_int (0))),
                assgn (var (attr->name), fetch (var (v->name), lit_int (1))),
                assgn (var (frag->name), fetch (var (v->name), lit_int (2)))
                );

            /* copy all the existing variables of the qname relation */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }
        } break;

        /* FragRel: textnode (Rel) */
        case 105:
        {
            /* temporary variable */
            mvar_t *v = new_var (1);
            /* result BATs */
            mvar_t *pre  = new_var (p->refctr);
            mvar_t *frag = new_var (p->refctr);

            env_add (p->env, p->sem.textnode.res, aat_pre, pre);
            env_add (p->env, p->sem.textnode.res, aat_pfrag, frag);

            execute (
                assgn (var (v->name),
                       textnode (VAR (L(p)->env, p->sem.textnode.item, aat_str),
                                 var ("ws"))),
                assgn (var ("ws"), fetch (var (v->name), lit_int (0))),
                assgn (var (pre->name), fetch (var (v->name), lit_int (1))),
                assgn (var (frag->name), fetch (var (v->name), lit_int (2)))
                );
            unpin (v, 1);

            /* copy all the existing variables */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }
        } break;

        /* Rel:      docnode (FragList, Rel) */
        case 106:
            PFoops (OOPS_FATAL,
                    "docnode not implemented yet.");
            break;

        /* Rel:      comment (Rel) */
        case 107:
            PFoops (OOPS_FATAL,
                    "comment not implemented yet.");
            break;

        /* Rel:      processi (Rel) */
        case 108:
            PFoops (OOPS_FATAL,
                    "processing-instruction not implemented yet.");
            break;

        /* Rel:      merge_adjacent (FragList, Rel) */
        case 109:
        {
            PFmil_t *iter = NULL, *pre = NULL, *pfrag = NULL;

            /* copy all the existing variables */
            for (unsigned int i = 0; i < PFarray_last (R(p)->env); i++) {
                env_t entry = env_at (R(p)->env, i);

                if (entry.att == att_iter && entry.ty == aat_nat) {
                    iter = var (entry.mvar->name);
                    env_add (p->env, entry.att, entry.ty, entry.mvar);
                    pin (entry.mvar, p->refctr);
                }
                else if (entry.att == att_item && entry.ty == aat_pre)
                    pre = var (entry.mvar->name);
                else if (entry.att == att_item && entry.ty == aat_pfrag)
                    pfrag = var (entry.mvar->name);
                else {
                    env_add (p->env, entry.att, entry.ty, entry.mvar);
                    pin (entry.mvar, p->refctr);
                }
            }
            assert (iter && pre && pfrag);

            mvar_t *v  = new_var (1);
            mvar_t *res_pre = new_var (p->refctr);
            mvar_t *res_frag = new_var (p->refctr);

            execute (
                assgn (var (v->name),
                       merge_adjacent (iter, pre, pfrag, var ("ws"))),
                assgn (var ("ws"), 
                       fetch (var (v->name), lit_oid (0))),
                assgn (var (res_pre->name), 
                       fetch (var (v->name), lit_oid (1))),
                assgn (var (res_frag->name), 
                       fetch (var (v->name), lit_oid (2))));

            unpin (v, 1);
            env_add (p->env, att_item, aat_pre, res_pre);
            env_add (p->env, att_item, aat_pfrag, res_frag);

        } break;

        /* Rel:      roots (FragRel) */
        case 120:
            /* copy all the attributes from our argument */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {

                pin (env_at (L(p)->env, i).mvar, p->refctr);

                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Frag:     fragment (FragRel) */
        case 121:
            break;

        /* FragList: frag_union (FragList, Frag) */
        case 122:
            break;

        /* FragList: empty_frag */
        case 123:
            break;

        /* Rel:      cond_err (Rel, Rel) */
        case 130:
            execute (
                if_ (exist (reverse (VAR (R(p)->env, p->sem.err.att, aat_bln)),
                            lit_bit (false)),
                     error (lit_str (p->sem.err.str)),
                     nop ()));
                       
            /* copy all the attributes */
            for (unsigned int i = 0; i < env_count (L(p)->env); i++) {
                pin (env_at (L(p)->env, i).mvar, p->refctr);
                env_add (p->env,
                         env_at (L(p)->env, i).att,
                         env_at (L(p)->env, i).ty,
                         env_at (L(p)->env, i).mvar);
            }
            break;

        /* Rel:      concat (Rel) */
        case 140:
            bin_arith (PFmil_madd, p);
            break;

        /* Rel:      contains (Rel) */
        case 141:
        {
            mvar_t              *res = new_var (p->refctr);

            /* do the containment checks:
               [search](strings,search_strs).[!=](-1).[oid]() */
            execute (
                assgn (var (res->name),
                              mnot (meq (msearch (
                                             VAR (L(p)->env,
                                                  p->sem.binary.att1,
                                                  aat_str),
                                             VAR (L(p)->env,
                                                  p->sem.binary.att2,
                                                  aat_str)),
                                         lit_int (-1)))));

            /* and put the result into p's environment */
            env_add (p->env, p->sem.binary.res, aat_bln, res);

            /* everything from p's child */
            for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

                env_t entry = env_at (L(p)->env, i);

                env_add (p->env, entry.att, entry.ty, entry.mvar);

                pin (entry.mvar, p->refctr);
            }
        } break;

        /* Rel:      string_join (Rel, Rel) */
        case 142:
        {
            mvar_t *str  = new_var (1);
            mvar_t *iter = new_var (p->refctr);
            mvar_t *item = new_var (p->refctr);

            execute (
                assgn (var (str->name),
                       string_join (
                           leftjoin (
                               reverse (VAR(L(p)->env, att_iter, aat_nat)),
                               VAR(L(p)->env, att_item, aat_str)),
                           leftjoin (
                               reverse (VAR(R(p)->env, att_iter, aat_nat)),
                               VAR(R(p)->env, att_item, aat_str)))),
                assgn (var (iter->name), 
                       reverse (mark (var (str->name), lit_oid (0)))),
                assgn (var (item->name), 
                       reverse (
                           mark (reverse (var (str->name)), lit_oid (0)))));

            unpin (str, 1);
            env_add (p->env, att_iter, aat_nat, iter);
            env_add (p->env, att_item, aat_str, item);
        }
            break;

        default:
            PFoops (OOPS_FATAL, "unknown rule %u", rule);
            break;
    }

    for (unsigned short c = 0; nts[c]; c++)
        for (unsigned int i = 0; i < PFarray_last (kids[c]->env); i++)
            unpin (((env_t *) PFarray_at (kids[c]->env, i))->mvar, 1);

#ifndef NDEBUG
    for (unsigned int i = 0; i < PFarray_last (p->env); i++)
        assert (((env_t *) PFarray_at (p->env, i))->mvar->pins);
#endif

#ifndef NDEBUG
    /* Debugging only: assign column names to BATs */
    /* switch off debugging information as it triggers errors in MonetDB...
    for (unsigned int i = 0; i < env_count (p->env); i++)
        execute (col_name (var (env_at (p->env, i).mvar->name),
                           lit_str (PFatt_str (env_at (p->env, i).att))));
    */
#endif

}

static PFalg_simple_type_t
type_of (PFpa_op_t *n, PFalg_att_t att)
{
    assert (n);

    for (unsigned int i = 0; i < n->schema.count; i++)
        if (n->schema.items[i].name == att)
            return n->schema.items[i].type;

    PFoops (OOPS_FATAL,
            "cannot determine implementation type of algebra expression");

    assert (0); /* never reached due to "exit" in "PFoops" */
    return aat_nat; /* pacify picky compilers */
}


/**
 * Compile a physical algebra literal value into its MIL equivalent.
 */
static PFmil_t *
literal (PFalg_atom_t atom)
{
    if (atom.special == amm_min)
        switch (atom.type) {
            case aat_int:  return lit_min (m_lng);
            case aat_str:  return lit_min (m_str);
            case aat_dec:  return lit_min (m_dbl);
            case aat_dbl:  return lit_min (m_dbl);
            case aat_bln:  return lit_min (m_bit);
            default:
                break;
        }
    else if (atom.special == amm_max)
        switch (atom.type) {
            case aat_int:  return lit_max (m_lng);
            case aat_str:  return lit_max (m_str);
            case aat_dec:  return lit_max (m_dbl);
            case aat_dbl:  return lit_max (m_dbl);
            case aat_bln:  return lit_max (m_bit);
            default:
                break;
        }
    else
        switch (atom.type) {

            case aat_nat:  return lit_oid (atom.val.nat);
            case aat_int:  return lit_lng (atom.val.int_);
            case aat_str:  return lit_str (atom.val.str);
            case aat_dec:  return lit_dbl (atom.val.dec);
            case aat_dbl:  return lit_dbl (atom.val.dbl);
            case aat_bln:  return lit_bit (atom.val.bln);
            case aat_qname:  
                return add_qname (lit_str (PFqname_ns (atom.val.qname)),
                                  lit_str (PFqname_uri (atom.val.qname)),
                                  lit_str (PFqname_loc (atom.val.qname)),
                                  var ("ws"));
            default:
                break;
        }

    PFoops (OOPS_FATAL,
            "A relational algebra type (%u) has not yet "
            "been implemented.", atom.type);

    assert (0); /* never reached due to "exit" in "PFoops" */
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `node()' */
static PFmil_t *
llscj_node (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_node()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `element()' */
static PFmil_t *
llscj_elem (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_elem (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_elem (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_elem (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_elem (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_elem (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_elem (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_elem (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_elem()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `text()' */
static PFmil_t *
llscj_text (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_text (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_text (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_text (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_text (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_text (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_text (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_text (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_text (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_text (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_text (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_text()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `comment()' */
static PFmil_t *
llscj_comm (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_comm (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_comm (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_comm (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_comm (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_comm (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_comm (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_comm (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_comm (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_comm (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_comm (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_comm()");
    return NULL; /* pacify picky compilers */
}

/** helper to handle staircase join steps with node test `processing-instr()' */
static PFmil_t *
llscj_pi (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
            const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_pi (iter, item, frag, ws, ord);
        case ax_anc_self:
            return llscj_anc_self_pi (iter, item, frag, ws, ord);
        case ax_child:
            return llscj_child_pi (iter, item, frag, ws, ord);
        case ax_desc: 
            return llscj_desc_pi (iter, item, frag, ws, ord);
        case ax_desc_self:
            return llscj_desc_self_pi (iter, item, frag, ws, ord);
        case ax_foll:
            return llscj_foll_pi (iter, item, frag, ws, ord);
        case ax_foll_sibl:
            return llscj_foll_sibl_pi (iter, item, frag, ws, ord);
        case ax_parent:
            return llscj_parent_pi (iter, item, frag, ws, ord);
        case ax_prec:
            return llscj_prec_pi (iter, item, frag, ws, ord);
        case ax_prec_sibl:
            return llscj_prec_sibl_pi (iter, item, frag, ws, ord);
    }

    assert (!"problem in llscj_pi()");
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test for some local name, but a wildcard namespace
 */
static PFmil_t *
llscj_elem_loc (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                const PFmil_t *loc)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_anc_self:
            return llscj_anc_self_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_child:
            return llscj_child_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_desc:
            return llscj_desc_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_desc_self:
            return llscj_desc_self_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_foll:
            return llscj_foll_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_parent:
            return llscj_parent_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_prec:
            return llscj_prec_elem_loc (iter, item, frag, ws, ord, loc);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_loc (iter, item, frag, ws, ord, loc);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test for some namespace, but a wildcard local name
 */
static PFmil_t *
llscj_elem_ns (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
               const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
               const PFmil_t *ns)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_anc_self:
            return llscj_anc_self_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_child:
            return llscj_child_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_desc:
            return llscj_desc_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_desc_self:
            return llscj_desc_self_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_foll:
            return llscj_foll_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_parent:
            return llscj_parent_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_prec:
            return llscj_prec_elem_ns (iter, item, frag, ws, ord, ns);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_ns (iter, item, frag, ws, ord, ns);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is an
 * element test with a fully qualified QName
 */
static PFmil_t *
llscj_elem_nsloc (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                  const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                  const PFmil_t *ns, const PFmil_t *loc)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_anc_self:
            return llscj_anc_self_elem_nsloc (iter, item, frag, ws, ord, ns,
                                              loc);
        case ax_child:
            return llscj_child_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_desc:
            return llscj_desc_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_desc_self:
            return llscj_desc_self_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
        case ax_foll:
            return llscj_foll_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_foll_sibl:
            return llscj_foll_sibl_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
        case ax_parent:
            return llscj_parent_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_prec:
            return llscj_prec_elem_nsloc (iter, item, frag, ws, ord, ns, loc);
        case ax_prec_sibl:
            return llscj_prec_sibl_elem_nsloc (iter, item, frag, ws, ord, ns,
                                               loc);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * helper to handle staircase join steps where the node test is a
 * processing-instruction test with a given target
 */
static PFmil_t *
llscj_pi_targ (enum axis_t axis, const PFmil_t *iter, const PFmil_t *item,
                  const PFmil_t *frag, const PFmil_t *ws, const PFmil_t *ord,
                  const PFmil_t *target)
{
    switch (axis) {
        case ax_anc:
            return llscj_anc_pi_targ (iter, item, frag, ws, ord, target);
        case ax_anc_self:
            return llscj_anc_self_pi_targ (iter, item, frag, ws, ord, target);
        case ax_child:
            return llscj_child_pi_targ (iter, item, frag, ws, ord, target);
        case ax_desc:
            return llscj_desc_pi_targ (iter, item, frag, ws, ord, target);
        case ax_desc_self:
            return llscj_desc_self_pi_targ (iter, item, frag, ws, ord, target);
        case ax_foll:
            return llscj_foll_pi_targ (iter, item, frag, ws, ord, target);
        case ax_foll_sibl:
            return llscj_foll_sibl_pi_targ (iter, item, frag, ws, ord, target);
        case ax_parent:
            return llscj_parent_pi_targ (iter, item, frag, ws, ord, target);
        case ax_prec:
            return llscj_prec_pi_targ (iter, item, frag, ws, ord, target);
        case ax_prec_sibl:
            return llscj_prec_sibl_pi_targ (iter, item, frag, ws, ord, target);
    }

    assert (0); /* we should never come here! */
    return NULL; /* pacify picky compilers */
}

/**
 * Translate loop-lifted staircase joins.
 */
static void
llscj (enum axis_t axis, const PFpa_op_t *p)
{
    /* abbreviations for input expressions */
    PFty_t           ty  = p->sem.scjoin.ty;
    PFord_ordering_t in  = p->sem.scjoin.in;
    PFord_ordering_t out = p->sem.scjoin.out;

    /* MIL equivalents of input expression */
    PFmil_t *iter;
    PFmil_t *item;
    PFmil_t *frag;

    int      o;           /* helper to compute order specifier */
    PFmil_t *order;       /* order specifier for llscj MIL functions */
    PFmil_t *scj = NULL;  /* MIL expression that evaluates llscj */

    mvar_t  *tmp;         /* helper variable */
    mvar_t  *ret_iter;    /* variable to which we assign the `iter' result */
    mvar_t  *ret_pre;     /* variable to which we assign the `pre' result */
    mvar_t  *ret_frag;    /* variable to which we assign the `kind' result */
    
    /*
     * Determine generic input arguments.
     */
    assert (p); assert (R(p)); assert (R(p)->env);
    iter = VAR (R(p)->env, att_iter, aat_nat); assert (iter);
    item = VAR (R(p)->env, att_item, aat_pre); assert (item);
    frag = VAR (R(p)->env, att_item, aat_pfrag); assert (frag);

    /*
     * Determine in- and output orderings.
     * MIL functions expect this information encoded in an integer
     * value that we build up here.
     */
    if (PFord_implies (in, PFord_refine (PFord_refine (PFordering (), att_iter),
                                         att_item)))
        o = 0;
    else if (PFord_implies (in, PFord_refine (PFord_refine (PFordering (),
                                                            att_item),
                                              att_iter)))
        o = 1;
    else
        PFoops (OOPS_FATAL, "illegal argument for input ordering");

    if (PFord_implies (out, PFord_refine (PFord_refine (PFordering (), att_iter),
                                          att_item)))
        o |= 0;
    else if (PFord_implies (out, PFord_refine (PFord_refine (PFordering (),
                                                             att_item),
                                               att_iter)))
        o |= 2;
    else
        PFoops (OOPS_FATAL, "illegal argument for output ordering");

    order = lit_int (o);

    if (PFty_subtype (ty, PFty_xs_anyElement ())) {

        /* This is a test for element nodes */

        /* Is it just a generic element kind test? (e.g. .../element()) */
        if (PFty_subtype (PFty_xs_anyElement (), ty))

            scj = llscj_elem (axis, iter, item, frag, var ("ws"), order);

        /* Is it a test on element kind and local name only? */
        else if (PFty_subtype (
                    PFty_elem (PFqname (PFns_wild,
                                        PFty_qname (PFty_defn (ty)).loc),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_loc (axis, iter, item, frag, var ("ws"), order,
                                  lit_str (PFqname_loc (
                                               PFty_qname (PFty_defn (ty)))));

        /* Or maybe a test on element kind and namespace only? */
        else if (PFty_subtype (
                    PFty_elem (PFqname (PFty_qname (PFty_defn (ty)).ns,
                                        NULL),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_ns (axis, iter, item, frag, var ("ws"), order,
                                 lit_str (PFqname_uri (
                                              PFty_qname (PFty_defn (ty)))));

        /* A test on element kind and full QName? */
        else if (PFty_subtype (
                    PFty_elem (PFty_qname (PFty_defn (ty)),
                               PFty_xs_anyType ()),
                    ty))
            scj = llscj_elem_nsloc (
                    axis, iter, item, frag, var ("ws"), order,
                    lit_str (PFqname_uri (PFty_qname (PFty_defn (ty)))),
                    lit_str (PFqname_loc (PFty_qname (PFty_defn (ty)))));
        /*
         * If we couldn't figure out what element test we got, give up.
         *
         * NOTE: The surface language actually allows such tests. We
         *       just cannot implement them (yet):
         *
         *        doc("foo")/child::element(shoeSize, xs:integer)
         */
        else
            PFoops (OOPS_FATAL,
                    "Problem with an XPath step: cannot evaluate "
                    "node test `%s'", PFty_str (ty));
    }
    /* If the node test wasn't some element test, maybe it is a text() test? */
    else if (PFty_subtype (ty, PFty_text ())) {
        scj = llscj_text (axis, iter, item, frag, var ("ws"), order);
    }
    /* or a comment() test? */
    else if (PFty_subtype (ty, PFty_comm ())) {
        scj = llscj_comm (axis, iter, item, frag, var ("ws"), order);
    }
    /* some test for processing-instructions? */
    else if (PFty_subtype (ty, PFty_pi (NULL))) {
        /* maybe we look for _any_ pi, regardless of its target? */
        if (PFty_subtype (PFty_pi (NULL), ty))
            scj = llscj_pi (axis, iter, item, frag, var ("ws"), order);
        /* or was there a target specified? */
        else
            scj = llscj_pi_targ (
                    axis, iter, item, frag, var ("ws"), order,
                    lit_str (PFqname_loc (PFty_qname (PFty_defn (ty)))));
    }
    /* If all these cases did not apply, it is probably a node() test. */
    else if (PFty_subtype (PFty_xs_anyNode (), ty)) {
        scj = llscj_node (axis, iter, item, frag, var ("ws"), order);
    }
    /* If we still couldn't find out, we probably need to give up. */
    else
        PFoops (OOPS_FATAL,
                "Problem with an XPath step: cannot evaluate "
                "node test `%s'", PFty_str (ty));

    assert (scj);

    /*
     * tmp  := scj (...);            # constructed just before
     * iter := tmp.fetch (0);
     * pre  := tmp.fetch (1);
     * kind := tmp.fetch (2);
     */
    tmp      = new_var (1);

    /*
     * Should we actually do materialize at runtime? In most cases
     * we should be able to see at compile time if columns are guaranteed
     * to be constant. We could then avoid carrying around the column at
     * all.
     *
     * Problem is: We do consider a `constant' property in our algebra
     * (not fully, yet, but the ideas are there). This property, however
     * only looks at ``real'' algebra columns. Here, materialize operates
     * on only part of a ``real'' column. The ``real'' column `item' is
     * implemented as `pre|kind' for nodes. And while kind may be constant,
     * pre probably won't.
     */
    execute (assgn (var (tmp->name), scj));

    if (attr_req (p->prop, att_item)) {
        ret_pre  = new_var (p->refctr);
        ret_frag = new_var (p->refctr);
        execute (
            assgn (var (ret_pre->name), fetch (var (tmp->name), lit_int (1))),
            assgn (var (ret_frag->name), 
                   materialize (fetch (var (tmp->name), lit_int (2)),
                                var (ret_pre->name))));
        env_add (p->env, att_item, aat_pre, ret_pre);
        env_add (p->env, att_item, aat_pfrag, ret_frag);
    }

    if (attr_req (p->prop, att_iter)) {
        ret_iter = new_var (p->refctr);
        execute (
            assgn (var (ret_iter->name), 
                   materialize (fetch (var (tmp->name), lit_int (0)),
                                fetch (var (tmp->name), lit_int (1)))));
        env_add (p->env, att_iter, aat_nat, ret_iter);
    }



    unpin (tmp, 1);

}

/**
 * Generic handling of binary operators, where both operands
 * are a BAT (in contrast to when one operand is known to be constant
 * and thus needs not be materialized as a BAT).
 *
 * @param op A MIL multiplex operation that implements the binary
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
bin_op (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
        PFpa_op_t *p, PFalg_simple_type_t arg_ty, PFalg_simple_type_t ret_ty)
{
    mvar_t              *res = new_var (p->refctr);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.binary.att1, arg_ty),
                   VAR (L(p)->env, p->sem.binary.att2, arg_ty))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.binary.res, ret_ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

/**
 * Generic binary arithmetic operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_arith (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));
    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl ||
            ty == aat_str);

    bin_op (op, p, ty, ty);
}

/**
 * node comparison operator, where both operands are a BAT
 * (in contrast to when one operand is known to be constant
 * and thus needs not be materialized as a BAT).
 *
 * @param op A MIL multiplex operation that implements the binary
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
node_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    mvar_t              *res = new_var (p->refctr);

    if (op == PFmil_mgt) {
        /* do the comparison: 
           frag1 > frag2 || (frag1 = frag2 && pre1 > pre2) */
        execute (
            assgn (
                var (res->name),
                PFmil_mor (
                    op (VAR (L(p)->env, p->sem.binary.att1, aat_pfrag),
                        VAR (L(p)->env, p->sem.binary.att2, aat_pfrag)),
                    PFmil_mand (
                        PFmil_meq (
                            VAR (L(p)->env, p->sem.binary.att1, aat_pfrag),
                            VAR (L(p)->env, p->sem.binary.att2, aat_pfrag)),
                        op (VAR (L(p)->env, p->sem.binary.att1, aat_pre),
                            VAR (L(p)->env, p->sem.binary.att2, aat_pre))))));
    } else if (op == PFmil_meq) {
        /* do the comparison: 
           frag1 = frag2 && pre1 = pre2 */
        execute (
            assgn (var (res->name),
                   PFmil_mand (
                       op (VAR (L(p)->env, p->sem.binary.att1, aat_pfrag),
                           VAR (L(p)->env, p->sem.binary.att2, aat_pfrag)),
                       op (VAR (L(p)->env, p->sem.binary.att1, aat_pre),
                           VAR (L(p)->env, p->sem.binary.att2, aat_pre)))));
    } else PFoops (OOPS_FATAL, "Unknown comparison for nodes.");

    /* and put the result into p's environment */
    env_add (p->env, p->sem.binary.res, aat_bln, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

/**
 * Generic binary comparison operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_comp (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));

    if (ty & ~aat_node) {
        assert (ty == aat_int || ty == aat_dec || ty == aat_dbl || ty == aat_str);
        bin_op (op, p, ty, aat_bln);
    } else if (ty == aat_pnode) {
        node_comp (op, p);
    } else
        PFoops (OOPS_FATAL,
                "Mil implementation of binary comparison for type %i unknown",
                ty);
}

/**
 * Generic binary Boolean operator. In addition to bin_op() does
 * additional type checks.
 */
static void
bin_bool (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *), PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.binary.att1);

    assert (ty == type_of (L(p), p->sem.binary.att2));
    assert (ty == aat_bln);

    bin_op (op, p, ty, aat_bln);
}

/**
 * Generic handling of arithmetic operators, where one operand is
 * known to be constant. (We don't need to materialize that attribute
 * as a BAT, but pass it as a const argument to MonetDB's [+].
 *
 * @param op A MIL multiplex operation that implements the arithmetic
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
bin_op_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
             PFpa_op_t *p,
             PFalg_simple_type_t arg_ty, PFalg_simple_type_t ret_ty)
{
    mvar_t              *res = new_var (p->refctr);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.bin_atom.att1, arg_ty),
                   literal (p->sem.bin_atom.att2))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.bin_atom.res, ret_ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

static void
bin_arith_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl);
    assert (ty == p->sem.bin_atom.att2.type);

    bin_op_atom (op, p, ty, ty);
}

static void
bin_comp_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_int || ty == aat_dec || ty == aat_dbl ||
            ty == aat_str || ty == aat_nat);
    assert (ty == p->sem.bin_atom.att2.type);

    bin_op_atom (op, p, ty, aat_bln);
}

static void
bin_bool_atom (PFmil_t * (*op) (const PFmil_t *, const PFmil_t *),
                PFpa_op_t *p)
{
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.bin_atom.att1);

    assert (ty == aat_bln);
    assert (ty == p->sem.bin_atom.att2.type);

    bin_op_atom (op, p, ty, aat_bln);
}

/**
 * Generic handling of unary operators (numeric and Boolean negation).
 *
 * @param op A MIL multiplex operation that implements the
 *           operation of interest (as a function pointer to the
 *           constructor function).
 * @param p  The physical algebra tree node that we are to translate.
 *           This function will actually fill @a p's environment
 *           <code>p->env</code>.
 */
static void
unary_op (PFmil_t * (*op) (const PFmil_t *), PFpa_op_t *p)
{
    mvar_t              *res = new_var (p->refctr);
    PFalg_simple_type_t  ty = type_of (L(p), p->sem.unary.att);

    /* do the arithmetics */
    execute (
        assgn (var (res->name),
               op (VAR (L(p)->env, p->sem.unary.att, ty))));

    /* and put the result into p's environment */
    env_add (p->env, p->sem.unary.res, ty, res);

    /* everything from p's child */
    for (unsigned int i = 0; i < PFarray_last (L(p)->env); i++) {

        env_t entry = env_at (L(p)->env, i);

        env_add (p->env, entry.att, entry.ty, entry.mvar);

        pin (entry.mvar, p->refctr);
    }
}

/**
 * Generic handling of aggregation functions (avg, max, min and sum).
 *
 * @param op  A MIL operation that implements the function
 *            of interest (as a function pointer to the
 *            constructor function).
 * @param gop A MIL operation that implements the function
 *            of interest (as a function pointer to the
 *            constructor function), grouped version.
 * @param p   The physical algebra tree node that we are to translate.
 *            This function will actually fill @a p's environment
 *            <code>p->env</code>.
 */
static void 
aggr_function(PFmil_t * (*op) (const PFmil_t *), PFmil_t * (*gop) (const PFmil_t *),
	      PFpa_op_t *p) 
{
     PFalg_att_t part = p->sem.aggr.part;
     PFalg_att_t att = p->sem.aggr.att;
     PFalg_att_t res = p->sem.aggr.res;
     bool has_part = part != att_NULL;
     PFalg_type_t poly_att_type = 0;
     PFalg_type_t poly_part_type = 0;
     PFalg_type_t poly_res_type = 0;
     /* determine res type */
     for (unsigned int i = 0; i < p->schema.count; i++) {
	  if (p->schema.items[i].name == res) {
	       poly_res_type = p->schema.items[i].type;
	       break;
	  }
     }
     /* determine att and part type */
     for (unsigned int i = 0; i < L(p)->schema.count; i++) {
	  if (L(p)->schema.items[i].name == part)
	       poly_part_type = L(p)->schema.items[i].type;
	  else if (L(p)->schema.items[i].name == att)
	       poly_att_type = L(p)->schema.items[i].type;
     }
     /* sanity checks */
     if (poly_att_type == 0) 
	  PFoops (OOPS_FATAL,
		  "attribute `%s' referenced in aggregation function "
		  "not found", 
		  PFatt_str (att));
     if (has_part && poly_part_type == 0)
	  PFoops (OOPS_FATAL,
		  "attribute `%s' referenced in aggregation function "
		  "not found", 
		  PFatt_str (part));
     if (poly_res_type == 0) 
	  PFoops (OOPS_FATAL,
		  "attribute `%s' referenced in aggregation function "
		  "not found", 
		  PFatt_str (res));
     if (!monomorphic(poly_att_type) || !monomorphic(poly_res_type)
	 || (has_part && !monomorphic(poly_part_type)))
	  PFoops (OOPS_FATAL,
		  "Aggregation function not implemented for "
		  "polymorphic groups");
     PFalg_simple_type_t att_type = (PFalg_simple_type_t)poly_att_type;
     PFalg_simple_type_t res_type = (PFalg_simple_type_t)poly_res_type;
     if (has_part) {		    		
	  PFalg_simple_type_t part_type 
	       = (PFalg_simple_type_t)poly_part_type;
	  mvar_t *v    = new_var (1);
	  mvar_t *res_var  = new_var (p->refctr);
	  mvar_t *part_var = new_var (p->refctr);
	  
	  execute (
	       /* v := 
		  {gop}(att.reverse().join(part).reverse()) */
	       assgn (
		    var (v->name),
		    gop (
			 reverse (
			      join (
				   reverse (VAR (L(p)->env, 
						 att, 
						 att_type)),
				   VAR (L(p)->env, 
					part, 
					part_type))))),
	       /* res := v.reverse ().mark (0@0).reverse (); */
	       assgn (
		    var (res_var->name),
		    reverse (
			 mark (
			      reverse (var (v->name)),
			      lit_oid (0)))),
	       /* part := v.mark (0@0).reverse (); */
	       assgn (
		    var (part_var->name),
		    reverse (
			 mark (var (v->name), lit_oid (0)))));
	  
	  env_add (p->env, res, res_type, res_var);
	  env_add (p->env, part, part_type, part_var);
	  
	  unpin (v, 1);
     }
     else {
	  mvar_t *v = new_var (p->refctr);
	  execute (
	       assgn (var (v->name),
		      op (VAR (L(p)->env, att, att_type))),
	       assgn (var (v->name),
		      append (
			   seqbase (
				new (type (m_void), implty (res_type)),
				lit_oid (0)),
			   var (v->name))));
	  env_add (p->env, res, res_type, v);
     }
}

/**
 * check if attribute @a attr is required.
 * The icols property is used to decide wether an attribute
 * is needed. If however no icols attributes are present all
 * attributes are added (!PFprop_icols_count()).
 */
static bool
attr_req (PFprop_t *prop, PFalg_att_t attr)
{
    return PFprop_icol (prop, attr) || !PFprop_icols_count (prop);
}

static void
inc_refctr (PFpa_op_t *n)
{
    assert (n);

    /* count number of incoming edges */
    n->refctr++;

    /* only descent once */
    if (SEEN(n))
        return;
    else
        SEEN(n) = true;
    
    for (unsigned int i = 0; i < PFPA_OP_MAXCHILD && n->child[i]; i++)
        inc_refctr (n->child[i]);
}

static void
label (PFpa_op_t *p)
{
    if (!L(p) && !R(p)) {
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p), 0, 0);
    }
    else if (L(p) && !R(p)) {
        if (!LABEL_SEEN(L(p))) label (L(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         0);
    }
    else if (!L(p) && R(p)) {
        if (!LABEL_SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(R(p)),
                                         0);
    }
    else {
        if (!LABEL_SEEN(L(p))) label (L(p));
        if (!LABEL_SEEN(R(p))) label (R(p));
        STATE_LABEL(p) = PFmilgen_state (OP_LABEL(p),
                                         STATE_LABEL(L(p)),
                                         STATE_LABEL(R(p)));
    }
    LABEL_SEEN(p) = true;
}

/**
 * Translate MIL algebra tree in a MIL program.
 */
PFmil_t *
PFmilgen (PFpa_op_t *n)
{
    assert (n);

    /* set counters in algebra tree nodes */
    inc_refctr (n);

    /* initialize list of variables we use */
    mvars = PFarray (sizeof (mvar_t));

    /* enrich algebra tree with state labels for subsequent reduce() call */
    label (n);

    /* we start with an empty MIL program */
    milprog = declare (unused ());

    execute (declare (var ("ws")));

    /* start compilation */
    reduce (n, 1);

    /* prepend variable declarations before the actual program */
    for (unsigned int i = 0; i < PFarray_last (mvars); i++)
        milprog = seq (declare (var (((mvar_t *) PFarray_at (mvars, i))->name)),
                       milprog);

    return milprog;
}

/* vim:set shiftwidth=4 expandtab filetype=c: */
