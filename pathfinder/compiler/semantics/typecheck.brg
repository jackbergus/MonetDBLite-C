%{

/**
 * @file
 *
 * Type check XQuery Core tree.
 *
 * This phase attaches static type information to the XQuery Core
 * tree and checks for correct typedness.
 *
 * Copyright Notice:
 * -----------------
 *
 * The contents of this file are subject to the Pathfinder Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Pathfinder system.
 *
 * The Initial Developer of the Original Code is the Database &
 * Information Systems Group at the University of Konstanz, Germany.
 * Portions created by the University of Konstanz are Copyright (C)
 * 2000-2005 University of Konstanz.  All Rights Reserved.
 *
 *
 * $Id$
 */ 

/* always include pathfinder.h first! */
#include "pathfinder.h"
#include <assert.h>
#include <stdio.h>

#include "oops.h"
#include "core.h"
#include "qname.h"
/* #include "mem.h" */

/* PFvar_t */
#include "variable.h"

#include "subtyping.h"

/*
 * Accessors for the burg matcher
 */
typedef struct PFcnode_t *NODEPTR_TYPE;

/* accessor to the node kind */
#define OP_LABEL(p)    ((p)->kind) 

/* accessors to left and right child node */
#define LEFT_CHILD(p)  ((p)->child[0])
#define RIGHT_CHILD(p) ((p)->child[1])

/* the state determined during bottom-up labeling is stored here */
#define STATE_LABEL(p) ((p)->state_label)

/* If something goes wrong, call PFoops */
#define PANIC(...) PFoops (OOPS_BURG, __VA_ARGS__)

%}

/* start non-terminal */
%start Query

/*
 * Node identifiers. Keep these properly aligned with the node kinds
 * in include/core.h!
 */
%term var                =  1 /**< variable */
%term lit_str            =  2 /**< string literal */
%term lit_int            =  3 /**< integer literal */
%term lit_dec            =  4 /**< decimal literal */
%term lit_dbl            =  5 /**< double literal */
%term nil                =  6 /**< end-of-sequence marker */

%term seq                =  7 /**< sequence construction */
%term ordered            =  8
%term unordered          =  9

%term let                = 10 /**< let expression */
%term letbind            = 11 /**< binding part of a let expression */
%term for_               = 12 /**< for expression */
%term forbind            = 13 /**< binding part of a for expression */
%term forvars            = 14 /**< variable pair (var + pos. var) of a for */

%term orderby            = 15 /**< orderby clause */
%term orderspecs         = 16 /**< list of order specs */

%term apply              = 17 /**< function application */
%term arg                = 18 /**< function argument (list) */

%term typesw             = 19 /**< typeswitch clause */
%term cases              = 20 /**< case concatenation for typeswitch */
%term case_              = 21 /**< single case for typeswitch */
%term default_           = 22 /**< default branch in typeswitch */
%term seqtype            = 23 /**< a SequenceType */
%term seqcast            = 24 /**< cast along <: */
%term proof              = 25 /**< typechecker only: prove <: relationship */
%term subty              = 26 /**< subtype condition for proof() */
%term stattype           = 27 /**< static type of expression. Required for
                                   fs:convert-operand. Will be removed during
                                   typechecking and replaced by seqtype, as
                                   soon as types are known. */

%term if_                = 28 /**< if-then-else conditional */
%term then_else          = 29 /**< then- and else-branches of an
                                   if-then-else conditional */

%term locsteps           = 30 /**< path of location steps only */
%term ancestor           = 31 /**< the parent, the parent's parent,... */
%term ancestor_or_self   = 32 /**< the parent, the parent's parent,... + self */
%term attribute          = 33 /**< attributes of the context node */
%term child              = 34 /**< children of the context node */
%term descendant         = 35 /**< children, children's children,... + self */
%term descendant_or_self = 36 /**< children, children's children,... */
%term following          = 37 /**< nodes after current node (document order) */
%term following_sibling  = 38 /**< all following nodes with same parent */
%term parent             = 39 /**< parent node (exactly one or none) */
%term preceding          = 40 /**< nodes before context node (document order) */
%term preceding_sibling  = 41 /**< all preceding nodes with same parent */
%term self               = 42 /**< the context node itself */

%term elem               = 43 /**< the element constructor */
%term attr               = 44 /**< the attribute constructor */
%term text               = 45 /**< the text constructor */
%term doc                = 46 /**< the document constructor */
%term comment            = 47 /**< the comment constructor */
%term pi                 = 48 /**< the processing-instruction constructor */
%term tag                = 49 /**< the tagname for elem. and attr. constr. */

%term true_              = 50 /**< built-in function `fn:true ()' */
%term false_             = 51 /**< built-in function `fn:false ()' */
%term empty              = 52 /**< built-in function `empty' */
%term main               = 53 /**< tree root
                                   Separates function declarations from
                                   the query body. */
%term fun_decls          = 54 /**< list of function declarations */
%term fun_decl           = 55 /**< function declaration */
%term params             = 56 /**< function declaration parameter list */
%term param              = 57 /**< function declaration parameter */
%term cast               = 58 /**< XQuery `cast as' operation */

%%

Query:              main (FunctionDecls, CoreExpr)              =   1 (10);
Query:              CoreExpr                                    =   2 (10);

CoreExpr:           Atom                                        =   3 (10);
CoreExpr:           SequenceTypeCast                            =   4 (10);

CoreExpr:           for_ (forbind (forvars (var, nil),
                                   Atom),
                          CoreExpr)                             =   5 (10);
CoreExpr:           for_ (forbind (forvars (var, var),
                                   Atom),
                          CoreExpr)                             =   6 (10);

CoreExpr:           let (letbind (var, CoreExpr), CoreExpr)     =   7 (10);

CoreExpr:           if_ (Atom, then_else (CoreExpr, CoreExpr))  =   8 (10);

CoreExpr:           seq (Atom, Atom)                            =   9 (10);

CoreExpr:           typesw (Atom,
                            cases (case_ (SequenceType,
                                          CoreExpr),
                                   default_ (CoreExpr)))        =  10 (10);

SequenceTypeCast:   seqcast (SequenceType, CoreExpr)            =  11 (10);

CoreExpr:           proof (subty (CoreExpr, SequenceType),
                           CoreExpr)                            =  12 (10);

SequenceType:       seqtype                                     =  14 (10);
SequenceType:       stattype (Atom)                             =  15 (10);

CoreExpr:           LocationSteps                               =  16 (10);

LocationStep:       ancestor (SequenceType)                     =  17 (10);
LocationStep:       ancestor_or_self (SequenceType)             =  18 (10);
LocationStep:       attribute (SequenceType)                    =  19 (10);
LocationStep:       child (SequenceType)                        =  20 (10);
LocationStep:       descendant (SequenceType)                   =  21 (10);
LocationStep:       descendant_or_self (SequenceType)           =  22 (10);
LocationStep:       following (SequenceType)                    =  23 (10);
LocationStep:       following_sibling (SequenceType)            =  24 (10);
LocationStep:       parent (SequenceType)                       =  25 (10);
LocationStep:       preceding (SequenceType)                    =  26 (10);
LocationStep:       preceding_sibling (SequenceType)            =  27 (10);
LocationStep:       self (SequenceType)                         =  28 (10);

LocationSteps:      locsteps (LocationStep, LocationSteps)      =  29 (10);
LocationSteps:      locsteps (LocationStep, Atom)               =  30 (10);

CoreExpr:           apply (FunctionArgs)                        =  31 (10);

FunctionArgs:       nil                                         =  32 (10);
FunctionArgs:       arg (FunctionArg, FunctionArgs)             =  33 (10);

FunctionArg:        Atom                                        =  34 (10);
/*
 * FIXME: Should we also need this one here?
FunctionArg:        SequenceTypeCast;
 */

CoreExpr:           elem (tag, CoreExpr)                        =  35 (10);
CoreExpr:           elem (CoreExpr, CoreExpr)                   =  36 (10);

CoreExpr:           attr (tag, CoreExpr)                        =  37 (10);
CoreExpr:           attr (CoreExpr, CoreExpr)                   =  38 (10);

CoreExpr:           text (CoreExpr)                             =  39 (10);
CoreExpr:           doc (CoreExpr)                              =  40 (10);
CoreExpr:           comment (CoreExpr)                          =  41 (10);
CoreExpr:           pi (Atom, Atom)                             =  42 (10);
CoreExpr:           pi (lit_str, Atom)                          =  43 (10);

CoreExpr:           ordered (CoreExpr)                          =  44 (10);
CoreExpr:           unordered (CoreExpr)                        =  45 (10);

CoreExpr:           orderby (OrderSpecs, CoreExpr)              =  46 (10);

OrderSpecs:         orderspecs (CoreExpr, nil)                  =  47 (10);
OrderSpecs:         orderspecs (CoreExpr, OrderSpecs)           =  48 (10);

CoreExpr:           cast (SequenceType, CoreExpr)               =  49 (10);

Atom:               var                                         =  50 (10);
Atom:               LiteralValue                                =  51 (10);

LiteralValue:       lit_str                                     =  52 (10);
LiteralValue:       lit_int                                     =  53 (10);
LiteralValue:       lit_dec                                     =  54 (10);
LiteralValue:       lit_dbl                                     =  55 (10);
LiteralValue:       true_                                       =  56 (10);
LiteralValue:       false_                                      =  57 (10);
LiteralValue:       empty                                       =  58 (10);

FunctionDecls:      nil                                         =  65 (10);
FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls)     =  66 (10);

FunctionDecl:       fun_decl (ParamList, FunctionBody)          =  67 (10);

ParamList:          nil                                         =  68 (10);
ParamList:          params (FunParam, ParamList)                =  69 (10);

FunctionBody:       CoreExpr                                    =  70 (10);

FunParam:           param (SequenceType, var)                   =  71 (10);

%%

/*
 * Easily access subtree-parts.
 */
/** starting from p, make a step left */
#define L(p) (LEFT_CHILD(p))
/** starting from p, make a step right */
#define R(p) (RIGHT_CHILD(p))
/** starting from p, make two steps left */
#define LL(p) L(L(p))
/** starting from p, make a step left, then a step right */
#define LR(p) R(L(p))
/** starting from p, make a step right, then a step left */
#define RL(p) L(R(p))
/** starting from p, make two steps right */
#define RR(p) R(R(p))
/* ... and so on ... */
#define RRL(p) L(R(R(p)))
#define RRRL(p) L(R(R(R(p))))
#define RRRRL(p) L(R(R(R(R(p)))))
#define RRRRRL(p) L(R(R(R(R(R(p))))))
#define RRRRRR(p) R(R(R(R(R(R(p))))))
#define LLR(p) R(L(L(p)))
#define RRR(p) R(R(R(p)))
#define LLL(p) L(L(L(p)))
#define LLLL(p) L(L(L(L(p))))
#define LLLLL(p) L(L(L(L(L(p)))))
#define LLLLR(p) R(L(L(L(L(p)))))
#define LLLR(p) R(L(L(L(p))))
#define RLL(p) L(L(R(p)))
#define RLLR(p) R(L(L(R(p))))
#define RLLL(p) L(L(L(R(p))))
#define RLR(p) R(L(R(p)))
#define RRLL(p) L(L(R(R(p))))
#define RRLR(p) R(L(R(R(p))))

/** Type of a core tree node */
#define TY(p) ((p)->type)

/** Maximum number of pattern leaves */
#define MAX_KIDS 10

/** mnemonic XQuery Core constructors */
#include "core_mnemonic.h"

static PFfun_t * overload (PFqname_t qn, PFcnode_t *args);
static PFty_t specific (PFfun_t *fn, PFcnode_t *args);

/**
 * Reducer function. This is the heart of this source file. It
 * contains all the action code for the above burg patterns.
 */
static void
reduce (PFcnode_t * p, int goalnt)
{
    int           rule;           /* rule number that matches for this node */
    short        *nts;            /* target non-terminals for the leaf nodes of
                                     the current rule */
    PFcnode_t    *kids[MAX_KIDS]; /* leaf nodes of this rule */
    bool          topdown;        /* is this a top-down rule? */

    /* determine rule that matches for this non-terminal */
    rule = PFtypecheck_rule (STATE_LABEL (p), goalnt);

    /* PFinfo (OOPS_NOTICE, "match for rule %i", rule); */

    /* initialize the kids[] vector */
    for (unsigned short i = 0; i < MAX_KIDS; i++)
        kids[i] = NULL;

    /*
     * prepare recursive traversal: get information on leaf nodes of
     * this rule
     */
    nts = PFtypecheck_nts[rule];
    PFtypecheck_kids (p, rule, kids);

    /* PFinfo (OOPS_NOTICE, "in rule %u", rule); */

    switch (rule) {
        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:
        /* CoreExpr:           for_ (forbind (forvars (var, nil),
                                              Atom),
                                     CoreExpr) */
        case 5:

        /* CoreExpr:           for_ (forbind (forvars (var, var),
                                              Atom),
                                     CoreExpr) */
        case 6:

        /* CoreExpr:           let (letbind (var, CoreExpr), CoreExpr) */
        case 7:

            topdown = true;
            break;

        default:
            topdown = false;
    }

    /*
     * Recursively invoke compilation.  This means bottom-up compilation.
     */
    if (!topdown)
        for (unsigned short i = 0; nts[i]; i++)
            reduce (kids[i], nts[i]);

    switch (rule) {

        /* Query:              main (FunctionDecls, CoreExpr) */
        case 1:
            /* TOPDOWN */

            /*
             * Type-check query body before any user-defined function.
             * This way we type all global variables (they have been
             * replaced by `let ...' clauses around the query body),
             * before we type any function body. (Note that function
             * bodies may refer global variables.)
             */
            reduce (kids[1], nts[1]);
            reduce (kids[0], nts[0]);
            break;

        /* Query:              CoreExpr */
        case 2:
	    break;

        /* CoreExpr:           Atom */
        case 3:
            break;

        /* CoreExpr:           SequenceTypeCast */
        case 4:
            break;

        /* CoreExpr:           for_ (forbind (forvars (var, nil),
                                              Atom),
                                     CoreExpr) */
        case 5:
        {   /* TOPDOWN */

            /* W3C XQuery, 5.8.2
             *
             *  E |- Atom : t1   E[Var : prime (t1)] |- CoreExpr : t2
             * -------------------------------------------------------
             *  for_ (Var, nil, Atom, CoreExpr) : t2 . quantifier (t1)
             */
            PFty_t t1, t2;

            /* nil : none */
            TY(LLR(p)) = PFty_none ();

            /* E |- Atom : t1 */
            reduce (kids[0], nts[0]);
            t1 = TY(LR(p));

            /* Var : prime (t1) */
            TY(LLL(p)) = *PFty_simplify (PFty_prime (PFty_defn (t1)));

            /* E[Var : prime (t1)] |- CoreExpr : t2 */
            assert (LLL(p)->sem.var);
            TY( LLL(p)->sem.var ) = TY(LLL(p));
            reduce (kids[1], nts[1]);
            t2 = TY(R(p));

            TY(p) = *PFty_simplify ((PFty_quantifier (PFty_defn (t1))) (t2));

        } break;

        /* CoreExpr:           for_ (forbind (forvars (var, var),
                                              Atom),
                                     CoreExpr) */
        case 6:
        {   /* TOPDOWN */

            /* W3C XQuery, 5.8.2
             *
             *                    E |- Atom : t1   
             *  E[Var1:prime (t1), Var2:xs:integer] |- CoreExpr : t2
             * -------------------------------------------------------
             *  for_ (Var1, Var2, Atom, CoreExpr) : t2 . quantifier (t1)
             */
            PFty_t t1, t2;

            /* E |- Atom : t1 */
            reduce (kids[0], nts[0]);
            t1 = TY(LR(p));

            /* Var2 : xs:integer */
            TY(LLR(p)) = PFty_xs_integer ();
            assert (LLR(p)->sem.var);
            TY( LLR(p)->sem.var ) = TY(LLR(p));

            /* Var1 : prime (t1) */
            TY(LLL(p)) = *PFty_simplify (PFty_prime (PFty_defn (t1)));

            /* E[Var1 : prime (t1), Var2 : xs:integer] |- CoreExpr : t2 */
            assert (LLL(p)->sem.var);
            TY( LLL(p)->sem.var ) = TY(LLL(p));
            reduce (kids[1], nts[1]);
            t2 = TY(R(p));

            TY(p) = *PFty_simplify ((PFty_quantifier (PFty_defn (t1))) (t2));

        } break;

        /* CoreExpr:           let (letbind (var, CoreExpr), CoreExpr) */
        case 7:
        {   /* TOPDOWN */
            
            /* W3C XQuery, 5.8.3
             * 
             * E |- CoreExpr1 : t1   E[Var : t1] |- CoreExpr2 : t2
             * ----------------------------------------------------
             *      E |- let (Var, CoreExpr1, CoreExpr2) : t2
             */
            PFty_t t1;

            /* E |- CoreExpr1 : t1 */
            reduce (kids[0], nts[0]);
            t1 = TY(LR(p));
            TY(LL(p)) = t1;

            /* E[Var : t1] |- CoreExpr : t2 */
            assert (LL(p)->sem.var);
            TY( LL(p)->sem.var ) = t1;
            reduce (kids[1], nts[1]);

            TY(p) = TY(R(p));
        } break;

        /* CoreExpr:           if_ (Atom, then_else (CoreExpr, CoreExpr)) */
        case 8:
            /* W3C XQuery, 5.10
             *
             * E |- Atom:boolean  E |- CoreExpr1:t1  E |- CoreExpr2:t2
             * -------------------------------------------------------
             *  E |- ifthenelse (Atom, CoreExp1, CoreExpr2) : t1 | t2
             */
            if (PFty_eq (PFty_defn (TY(L(p))), PFty_boolean ()))
                TY(p) = *PFty_simplify (PFty_choice (TY(RL(p)), TY(RR(p))));
            else
                PFoops (OOPS_TYPECHECK,
                        "if-then-else condition of type %s (expected %s)",
                        PFty_str (TY(L(p))), PFty_str (PFty_boolean ()));

            break;

        /* CoreExpr:           seq (Atom, Atom) */
        case 9:
            /* W3C XQuery, 5.3.1
             * 
             * E |- Atom1 : t1    E |- Atom2 : t2
             * ----------------------------------
             *  E |- seq (Atom1, Atom2) : t1, t2
             */
            TY(p) = *PFty_simplify (PFty_seq (TY(L(p)), TY(R(p))));
            break;

        /* CoreExpr:           typesw (Atom,
                                       cases (case_ (SequenceType,
                                                     CoreExpr),
                                              default_ (CoreExpr))) */
        case 10:
        {   /* W3C XQuery, 5.12.2
             *
             *                   E |- Atom:t1  E |- SequenceType:t2  
             *           E |- CoreExpr1:t3    E |- CoreExpr2:t4    t1 <: t2
             * ---------------------------------------------------------------
             *  E |- typeswitch (Atom, cases (case_ (SequenceType, CoreExpr1),
             *                                default (CoreExpr2))) : t3
             *
             *                   E |- Atom:t1  E |- SequenceType:t2  
             *           E |- CoreExpr1:t3    E |- CoreExpr2:t4    t1 || t2
             * ---------------------------------------------------------------
             *  E |- typeswitch (Atom, cases (case_ (SequenceType, CoreExpr1),
             *                                default (CoreExpr2))) : t4
             *
             *                   E |- Atom:t1  E |- SequenceType:t2  
             *                 E |- CoreExpr1:t3    E |- CoreExpr2:t4  
             * ---------------------------------------------------------------
             *  E |- typeswitch (Atom, cases (case_ (SequenceType, CoreExpr1),
             *                                default (CoreExpr2))) : t3 | t4
             */
            PFty_t t1, t2;

            t1 = TY(L(p));
            t2 = TY(RLL(p));

            if (PFty_subtype (t1, t2))
                TY(p) = TY(RLR(p));
            else if (PFty_disjoint (t1, t2))
                TY(p) = TY(RRL(p));
            else
                TY(p) = *PFty_simplify (PFty_choice (TY(RLR(p)), TY(RRL(p))));
        } break;

        /* SequenceTypeCast:   seqcast (SequenceType, CoreExpr) */
        case 11:
            TY(p) = TY(L(p));
            break;

        /* CoreExpr:           proof (subty (CoreExpr, SequenceType),
                                      CoreExpr) */
        case 12:
            /*
             *    E |- CoreExpr1 : t1   E |- SequenceType : t2
             *                      t1 <: t2
             *                 E |- CoreExpr2 : t3
             * ----------------------------------------------------
             * E |- proof (CoreExpr1, SequenceType, CoreExpr2) : t3
             */

            /* perform the <: proof */
            if (! (PFty_subtype (TY(LL(p)), TY(LR(p)))))
                PFoops (OOPS_TYPECHECK,
                        "%s is not a subtype of %s",
                        PFty_str (TY(LL(p))),
                        PFty_str (TY(LR(p))));

            /* remove the successful proof and simply return the guarded
             * expression 
             */
            *p = *R(p);
            break;
            
        /* SequenceType:       seqtype */
        case 14:
            TY(p) = p->sem.type;
            break;

        /* SequenceType:       stattype (Atom) */
        case 15:
        {   /*
             * We now know the static type of the argument expression.
             * We can thus replace the stattype node by a seqtype node
             * carrying the respective type.
             * After typechecking there should be no more stattype nodes
             * left.
             */
            PFcnode_t *ret = PFcore_seqtype ( TY(L(p)) );
            ret->type = ret->sem.type;

            /* Set state label correctly before we return. */
            STATE_LABEL(ret) = PFtypecheck_state (OP_LABEL(ret), 0, 0);

            *p = *ret;
        }

        /* CoreExpr:           LocationSteps */
        case 16:
            break;

        /* LocationStep:       ancestor (SequenceType) */
        case 17:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       ancestor_or_self (SequenceType) */
        case 18:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       attribute (SequenceType) */
        case 19:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       child (SequenceType) */
        case 20:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       descendant (SequenceType) */
        case 21:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       descendant_or_self (SequenceType) */
        case 22:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       following (SequenceType) */
        case 23:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       following_sibling (SequenceType) */
        case 24:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       parent (SequenceType) */
        case 25:
            TY(p) = PFty_opt (TY(L(p)));
            break;

        /* LocationStep:       preceding (SequenceType) */
        case 26:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       preceding_sibling (SequenceType) */
        case 27:
            TY(p) = PFty_star (TY(L(p)));
            break;

        /* LocationStep:       self (SequenceType) */
        case 28:
            TY(p) = TY(L(p));
            break;

        /* LocationSteps:      locsteps (LocationStep, LocationSteps) */
        case 29:
            TY(p) = *PFty_simplify (PFty_quantifier (TY(R(p))) (TY(L(p))));
            break;

        /* LocationSteps:      locsteps (LocationStep, Atom) */
        case 30:
            TY(p) = *PFty_simplify (PFty_quantifier (TY(R(p))) (TY(L(p))));
            break;

        /* CoreExpr:           apply (FunctionArgs) */
        case 31:
            /* resolve overloading,
             * any type errors will be detected during resolution
             */
            p->sem.fun = overload (p->sem.fun->qname, L(p));

            /* invoke specific typing rules for standard F&O functions 
             * (W3C XQuery Formal Semantics 6.2)
             */
            TY(p) = specific (p->sem.fun, L(p));

            break;

        /* FunctionArgs:       nil */
        case 32:
            break;

        /* FunctionArgs:       arg (FunctionArg, FunctionArgs) */
        case 33:
            TY(p) = TY(L(p));
            break;

        /* FunctionArg:        Atom */
        case 34:
            break;


        /* CoreExpr:           elem (tag, CoreExpr) */
        case 35:
            TY(p) = *PFty_simplify (PFty_elem (L(p)->sem.qname, TY(R(p))));
            break;

        /* CoreExpr:           elem (CoreExpr, CoreExpr) */
        case 36:
        {   
            PFty_t t1 = TY(R(p));
            PFqname_t wild = { .ns = PFns_wild, .loc = NULL };

            if (!PFty_promotable (TY(L(p)), PFty_string ()))
                PFoops (OOPS_TYPECHECK,
                        "tag name in computed element constructor"
                        " has illegal type `%s'",
                        PFty_str (TY(L(p))));

            TY(p) = *PFty_simplify (PFty_elem (wild, t1));
        } break;

        /* CoreExpr:           attr (tag, CoreExpr) */
        case 37:
            TY(p) = *PFty_simplify (PFty_attr (L(p)->sem.qname,
                                               PFty_untypedAtomic ()));
            break;
            
        /* CoreExpr:           attr (CoreExpr, CoreExpr) */
        case 38:
        {
            PFqname_t wild = { .ns = PFns_wild, .loc = NULL };

            if (!PFty_promotable (TY(L(p)), PFty_string ()))
                PFoops (OOPS_TYPECHECK,
                        "tag name in computed attribute constructor"
                        " has illegal type '%s'",
                        PFty_str (TY(L(p))));

            TY(p)= *PFty_simplify (PFty_attr (wild, PFty_untypedAtomic ()));
        } break;

        /* CoreExpr:           text (CoreExpr) */
        case 39:
            /*
             * XQuery Draft, 3.7.3.4 (Sep 15, 2005 version):
             *
             * "If the result of atomization is an empty sequence,
             *  no text node is constructed."
             */
            if (PFty_subtype (PFty_empty (), TY(L(p))))
                TY(p) = PFty_opt (PFty_text ());
            else
                TY(p) = PFty_text ();
            break;

        /* CoreExpr:           doc (CoreExpr) */
        case 40:
            TY(p) = *PFty_simplify (PFty_doc (TY(L(p))));
            break;

        /* CoreExpr:           comment (CoreExpr) */
        case 41:
            TY(p) = PFty_comm ();
            break;

        /* CoreExpr:           pi (Atom, Atom) */
        case 42:
            if (!PFty_promotable (TY(L(p)), PFty_string ()))
                PFoops (OOPS_TYPECHECK,
                        "target name in processing-instruction constructor"
                        " has illegal type '%s'",
                        PFty_str (TY(L(p))));
            TY(p) = PFty_pi (NULL);
            break;

        /* CoreExpr:           pi (lit_str, Atom) */
        case 43:
            TY(L(p)) = PFty_string ();
            TY(p) = PFty_pi (L(p)->sem.str);
            break;

        /* CoreExpr:           ordered (CoreExpr) */
        case 44:
            TY(p) = TY(L(p));
            break;

        /* CoreExpr:           unordered (CoreExpr) */
        case 45:
            TY(p) = TY(L(p));
            break;

        /* CoreExpr:           orderby (OrderSpecs, CoreExpr) */
        case 46:
            TY(p) = TY(R(p));
            break;

        /* OrderSpecs:         orderspecs (CoreExpr, nil) */
        case 47:
            /* FIXME: Are there any type constraints on the order expression? */
            break;

        /* OrderSpecs:         orderspecs (CoreExpr, OrderSpecs) */
        case 48:
            /* FIXME: Are there any type constraints on the order expression? */
            break;

        /* CoreExpr:           cast (SequenceType, CoreExpr) */
        case 49:
            if (!PFty_subtype (TY(L(p)), PFty_opt (PFty_atomic ())))
                PFoops (OOPS_TYPECHECK,
                        "casting is only allowed to an atomic type");

            TY(p) = TY(L(p));
            break;

        /* Atom:               var */
        case 50:
            /* W3C XQuery, 5.1.2
             *
             * E.varType(Var) = t
             * -------------------
             *    E |- Var : t
             */
            assert (p->sem.var);
            TY(p) = TY( p->sem.var );
            break;

        /* Atom:               LiteralValue */
        case 51:
            break;

        /* LiteralValue:       lit_str */
        case 52:
            /* W3C XQuery, 5.1.1
             *
             * --------------------------
             * Env |- lit_str : xs:string
             */
            TY(p) = PFty_xs_string ();
            break;
     
        /* LiteralValue:       lit_int */
        case 53:
            /* W3C XQuery, 5.1.1
             *
             * ---------------------------
             * Env |- lit_int : xs:integer
             */
            TY(p) = PFty_xs_integer ();
            break;

        /* LiteralValue:       lit_dec */
        case 54:
            /* W3C XQuery, 5.1.1
             *
             * ---------------------------
             * Env |- lit_dec : xs:decimal
             */
            TY(p) = PFty_xs_decimal ();
            break;

        /* LiteralValue:       lit_dbl */
        case 55:
            /* W3C XQuery, 5.1.1
             *
             * --------------------------
             * Env |- lit_dec : xs:double
             */
            TY(p) = PFty_xs_double ();
            break;

        /* LiteralValue:       true_ */
        case 56:
            /* 
             * -------------------------
             * Env |- true_ : xs:boolean
             */
            TY(p) = PFty_xs_boolean ();
            break;

        /* LiteralValue:       false_ */
        case 57:
            /* 
             * --------------------------
             * Env |- false_ : xs:boolean
             */
            TY(p) = PFty_xs_boolean ();
            break;

        /* LiteralValue:       empty */
        case 58:
            /*
             * ------------------
             * Env |- empty_ : ()
             */
            TY(p) = PFty_empty ();
            break;
     
        /* FunctionDecls:      nil */
        case 65:
            break;

        /* FunctionDecls:      fun_decls (FunctionDecl, FunctionDecls) */
        case 66:
            break;

        /* FunctionDecl:       fun_decl (ParamList, FunctionBody) */
        case 67:
            /*
             * See if function body matches function return type.
             */
            if (!PFty_subtype (TY(R(p)), p->sem.fun->ret_ty))
                PFoops (OOPS_TYPECHECK,
                        "body of %s() evaluates to `%s' which is not "
                        "a subtype of `%s'",
                        PFqname_str (p->sem.fun->qname),
                        PFty_str (TY(R(p))), PFty_str (p->sem.fun->ret_ty));
            break;

        /* ParamList:          nil */
        case 68:
            break;

        /* ParamList:          param (FunParam, ParamList) */
        case 69:
            break;

        /* FunctionBody:       CoreExpr */
        case 70:
            break;

        /* FunParam:           param (SequenceType, var) */
        case 71:
            /*
             * Bind parameter variable to the given type. We need this
             * to type-check the function body.
             */
            TY(R(p)) = TY(L(p));
            TY(R(p)->sem.var) = TY(L(p));
            break;

        default:
            PFoops (OOPS_FATAL, "untranslated expression");
            break;
    }
}

/**
 * Resolve function overloading.  In the list of functions of the same
 * name @a qn, find the first (most specific) to match the actual
 * argument types @a args (matching is based on `can be promoted to'
 * relationship).
 *
 * @attention NB. This relies on the list of functions for name @a qn
 * to be sorted: the most specific instance comes first (see
 * semantics/xquery_fo.c)
 *
 * @param qn name of (overloaded) function
 * @param args right-deep core tree of function arguments 
 *             arg (e1, arg (e2, ..., arg (en, nil)...))
 */
static PFfun_t *
overload (PFqname_t qn, PFcnode_t *args)
{
    PFarray_t *fns;
    PFarray_t *args_str;
    PFcnode_t *arg;
    PFfun_t *fn;
    unsigned int i, a;
    bool match;
    char semi;

    assert (args && (args->kind == c_nil || args->kind == c_arg));

    fns = PFenv_lookup (PFfun_env, qn);
    assert (fns);

    for (i = 0; i < PFarray_last (fns); i++) {
        fn    = *(PFfun_t **) PFarray_at (fns, i);
        arg   = args;

        /* can all actual argument types be promoted to
         * expected formal parameter types?
         */
        for (a = 0, match = true; a < fn->arity; a++) {
            /* test if function has at least the same
               number of arguments as the tested function */
            if (arg->kind == c_nil)
            {
                match = false;
                break;
            }

            match = match && PFty_promotable (arg->child[0]->type,
                                              (fn->par_ty)[a]);
            if (!match)
                break;

            arg = arg->child[1];
            assert (arg);
        }

        /* yes, return this function (its the most specific match) */
        /* and it has the same number of arguments */
        if (match && arg->kind == c_nil)
            return fn;
    } 

    /* construct (error) message listing the actual argument types:
     * ": t1; t2; ...; tn" (NB: n >= 1 is guaranteed here)
     */
    args_str = PFarray (sizeof (char));

    semi = ':';

    do {
        PFarray_printf (args_str, "%c %s", 
                        semi,
                        PFty_str (args->child[0]->type));
        semi = ';';
        args = args->child[1];
    } while (args->kind != c_nil);

    PFinfo (OOPS_TYPECHECK, 
            "no variant of function %s accepts the given argument type(s)%s",
            PFqname_str (qn),
            (char *) PFarray_at (args_str, 0));

    PFinfo (OOPS_TYPECHECK, "maybe you meant:");

    for (unsigned int i = 0; i < PFarray_last (fns); i++) {

        fn       = *(PFfun_t **) PFarray_at (fns, i);
        args_str = PFarray (sizeof (char));

        PFarray_printf (args_str, "%s (", PFqname_str (fn->qname));

        for (unsigned int j = 0; j < fn->arity; j++) {
            PFarray_printf (args_str, "%s%s",
                    j ? ", " : "", PFty_str (fn->par_ty[j]));
        }

        PFarray_printf (args_str, ") as %s", PFty_str (fn->ret_ty));

        PFinfo (OOPS_TYPECHECK, "  %s", (char *) PFarray_at (args_str, 0));
    }

    PFoops (OOPS_TYPECHECK,
            "illegal arguments for function %s", PFqname_str (qn));

    /* just to pacify picky compilers; never reached due to "exit" in PFoops */
    return 0;
}


/**
 * Apply specific typing rules for standard XQuery F&O functions
 * (see W3C XQuery, 7.2)
 *
 * @bug
 *   This function has two arguments, both of which are even
 *   documented. But only one of them is actually used.
 *
 * @param fn function reference
 * @param args right-deep core tree of function arguments 
 * @return return type of @a fn when applied to arguments @a args
 */
static PFty_t
specific (PFfun_t *fn, PFcnode_t *args)
{
    assert (fn);
    assert (args && (args->kind == c_nil || args->kind == c_arg));

    /* #pf:distinct-doc-order() more or less returns its input */
    if (! PFqname_eq (fn->qname, PFqname (PFns_pf, "distinct-doc-order"))) {
        /* #pf:distinct-doc-order gets exactly one argument */
        assert (args->kind == c_arg && R(args)->kind == c_nil);

        return *PFty_simplify (
                (PFty_quantifier (TY(L(args)))) (PFty_prime (PFty_defn (TY(L(args))))));
    }

    /* Typing rules for fn:data() are described by the special
     * judgement `data on' (W3C FS 6.2.3), implemented in PFty_data_on()
     */
    if ((! PFqname_eq (fn->qname, PFqname (PFns_fn, "data")))
        || (! PFqname_eq (fn->qname, PFqname (PFns_pf, "typed-value")))) {
        /* fn:data() gets exactly one argument */
        assert (args->kind == c_arg && R(args)->kind == c_nil);
        return *PFty_simplify (
                (PFty_quantifier (TY(L(args))) (PFty_data_on (PFty_defn (TY(L(args)))))));
    }

    /* Typing rules for #pf:item-sequence-to-node-sequence() are described
     * by the special judgment `is2ns', implemented in PFty_is2ns(),
     * which reduces atomic types to text().
     */
    if ((! PFqname_eq (fn->qname,
                       PFqname (PFns_pf, "item-sequence-to-node-sequence")))) {
        assert (args->kind == c_arg && R(args)->kind == c_nil);
        return *PFty_simplify ((PFty_is2ns (PFty_defn (TY(L(args))))));
    }

    /* specific typing rules for fn:subsequence() */
    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "subsequence"))) {

        assert (args->kind == c_arg);

        /*
         * The W3C Formal Semantics demands a special treatment of the
         * case
         *    fn:subsequence (Expr, Num, 1)
         * (Use quantifier `?' if last argument is literal 1.)
         *
         * However, we won't see any literal constants here, as they
         * have been wrapped into fn:data() and others.  We just ignore
         * that W3C rule.  (Current draft is buggy with that respect
         * anyway.  No one knows, how those rules will look like in
         * upcoming drafts...)
         */

        /* use occurrence indicator `?' if expr contains at most one item */
        if (PFty_subtype (TY(L(args)), PFty_opt (PFty_item ())))
            return *PFty_simplify (PFty_opt (PFty_prime (TY(L(args)))));
        /* otherwise we cannot do more than `*' */
        else
            return *PFty_simplify (PFty_star (PFty_prime (TY(L(args)))));
    }

    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "exactly-one"))) {
        return *PFty_simplify (PFty_prime (PFty_defn (TY(L(args)))));
    }

    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "zero-or-one"))) {
        return *PFty_simplify (PFty_opt (PFty_prime (PFty_defn (TY(L(args))))));
    }

    if (! PFqname_eq (fn->qname, PFqname (PFns_fn, "unordered"))) {
        return *PFty_simplify (PFty_prime (PFty_defn (TY(L(args)))));
    }

    return fn->ret_ty;
}



/**
 * Type check XQuery Core tree.
 *
 * @param r root of the XQuery Core tree
 * @return @a r
 */
PFcnode_t *
PFty_check (PFcnode_t *r)
{
    assert (r);

    /* label the core tree bottom up */
    PFtypecheck_label (r);

    /* invoke compilation */
    reduce (r, 1);

    return r;
}


/* vim:set shiftwidth=4 expandtab filetype=c: */
