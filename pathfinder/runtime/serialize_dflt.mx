@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2008 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'

@f serialize_dflt
@a Jan Flokstra
@a Jan Rittinger
@t serialize_dflt

@c
/*******************************************
 * serialize_dflt.c : XML serialization functions
 * The default serialization function definitions are in this file.
 * They are called by the driver software in serialize.c
 *
 */

#include "pf_config.h"
#include "serialize.h"
/* contains dummy callback functions */
#include "serialize_null.h"
#include "pathfinder.h"
#include "pf_support.h"
#include "xrpc_const.h"

/* a lot of characters, static strings, and their sizes 
   (the idea is to reuse constant character pointers during
    serialization) */
static char s_   = ' ';
static char c_   = ':';
static char e_   = '=';
static char le_  = '<';
static char ge_  = '>';
static char sl_  = '/';
static char q_   = '?';
static char sep_ = ',';

static char *commentStart = "<!--";
static char *commentEnd = "-->";
static size_t cS_sz = 4; /* strlen (commentStart); */
static size_t cE_sz = 3; /* strlen (commentEnd); */

static char *attributeStart = "attribute ";
static char *attributeMid = " { \"";
static char *attributeEnd = "\" }";
static size_t aS_sz = 10; /* strlen (attributeStart); */
static size_t aM_sz = 4; /* strlen (attributeMid); */
static size_t aE_sz = 3; /* strlen (attributeEnd); */

static char *textnodeStart = "text {";
static char *textnodeEnd = "}";
static size_t tnS_sz = 6; /* strlen (textnodeStart); */
static size_t tnE_sz = 1; /* strlen (textnodeEnd); */

/**
 * struct dflt_ws_t stores information required during serialization
 * that may differ for each serialization invocation.
 */
struct dflt_ws_t {
    char  *restag; /* result tag name */
    char  *resprefix; /* used in 'typed' and 'xrpc' modes to set the prefix */

    char  *newline, *esc_quote; /* newline and escaped quote string */
    size_t nl_sz, esq_sz; /* length of newline and escaped quote string */
    
    /* sequence counter required for JDBC output (seq output) */
    unsigned int id_sequence_counter;
    
    /* special character mapping table */
    unsigned char isspecial_tab[UCHAR_MAX+1]; /* the main table */
    char*         special_val[32]; /* the replacements of the special chars */
    int           special_len[32]; /* the length of the replacements strings */
};
typedef struct dflt_ws_t dflt_ws_t;

/**
 * constructor function for the default workspace
 */
static dflt_ws_t *
new_dflt_ws (void)
{
    dflt_ws_t *dflt_ws_ = GDKmalloc (sizeof (dflt_ws_t));

    for(int i = 0; i < UCHAR_MAX; i++)
        /* special character mapping table */
        dflt_ws_->isspecial_tab[i] = 0;

    dflt_ws_->id_sequence_counter = 0;

    return dflt_ws_;
}

#define dflt_ws ((dflt_ws_t *) ctx->driverWs)

/**
 * The character translation section responsible for the special
 * character recognition and XML entity characters.  It consists of a
 * small main table 'isspecial_tab' containing the flags for every
 * possible character.
 *
 * The different output modes differ only in the representation of
 * tabulators, newlines, and backslashes (see function arguments).
 * The replacements for the special characters are stored in the 
 * 'special_val' array and its lengths in the 'special_len' array.
 *
 * v=0: no special char
 * v=1: special char, should be presented as octal char in output
 * v>1: special char, string repr of char is isspecial_val[v]
 */
static void init_isspecial (XqueryCtx* ctx, 
                            char *tab,
                            char* newline,
                            char *backslash)
{
    int i;
    for(i=0; i<32; i++) dflt_ws->isspecial_tab[i] = 1; /* write as octal */

    dflt_ws->isspecial_tab[(int)'\t'] = 9;
    dflt_ws->isspecial_tab[(int)'\\'] = 8;
    dflt_ws->isspecial_tab[(int)'\"'] = 7;
    dflt_ws->isspecial_tab[(int)'\''] = 6;
    /* order is important for entity only string escaping */
    dflt_ws->isspecial_tab[(int)'\n'] = 5;
    dflt_ws->isspecial_tab[(int)'\r'] = 5;	/* map \r on \n */
    dflt_ws->isspecial_tab[(int)'&']  = 4;
    dflt_ws->isspecial_tab[(int)'<']  = 3;
    dflt_ws->isspecial_tab[(int)'>']  = 2;

    dflt_ws->special_val[0] = NULL; /* not used */
    dflt_ws->special_val[1] = NULL; /* not used, 1 = write as octal */

    dflt_ws->special_val[9] = tab;
    dflt_ws->special_val[8] = backslash;
    dflt_ws->special_val[7] = "&quot;";
    dflt_ws->special_val[6] = "&apos;";
    dflt_ws->special_val[5] = newline;
    dflt_ws->special_val[4] = "&amp;";
    dflt_ws->special_val[3] = "&lt;";
    dflt_ws->special_val[2] = "&gt;";

    /* also collect the lengths of the replacment strings */
    for (i=2; i <= 9; i++)
        dflt_ws->special_len[i] = strlen (dflt_ws->special_val[i]);
}

@= emit_escaped
static void
emit_escaped@1 (XqueryCtx* ctx, char* src) {
    int start = 0, end;
    unsigned char isspecial_ch;

    for(end = 0; src[end]; end++) {
        isspecial_ch = dflt_ws->isspecial_tab[(int)(unsigned char)src[end]];
        if (isspecial_ch @2) {
            /* print all characters that were collected 
               since the last special character. */
            stream_write (ctx->out, &src[start], end - start, 1);
            start = end + 1;

            if ( isspecial_ch == 1 ) { /* print character entity */
                stream_printf(ctx->out,"&#%d;",(unsigned char)src[end]);
            } else {
                char *emit_val = dflt_ws->special_val[(int)isspecial_ch];
                int   emit_len = dflt_ws->special_len[(int)isspecial_ch];
                stream_write (ctx->out, emit_val, emit_len, 1);
            }
        }
    }
    if ( start < end )
        stream_write (ctx->out, &src[start], end - start, 1);
}

@c
/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 *
 * Emit a string with all special character escaped.
 */
@:emit_escaped(_all,)@
/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 *
 * Emit a string with all entities escaped.
 */
@:emit_escaped(_entities,&& isspecial_ch <= 5)@
/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 *
 * Emit a string with only newlines escaped.
 */
@:emit_escaped(_newline,&& isspecial_ch == 5)@

/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 *
 * Emit a string with all special character escaped in octal.
 */
static void
emit_escaped_comment (XqueryCtx* ctx, char* src) {
    int start = 0, end;

    for(end = 0; src[end]; end++) {
/* XXX do we need to do anything special for other special characters? */
        if (src[end] == '\n') {
            /* print all characters that were collected 
               since the last special character. */
            if (start < end)
                stream_write (ctx->out, &src[start], end - start, 1);
            stream_printf(ctx->out,dflt_ws->newline);
            start = end + 1;
        }
    }
    if ( start < end )
        stream_write (ctx->out, &src[start], end - start, 1);
}

/**
 * dflt driver initialization function
 */
static bool
dflt_init (XqueryCtx* ctx, char* args, char *restag, char *resprefix)
{
    (void) args;

    /* create workspace container */
    ctx->driverWs = (void *) new_dflt_ws ();

    /* initialize mapping tables and its replacement strings */
    init_isspecial (ctx, "\t", "\n", "\\");

    /* bind some often used special strings */
    dflt_ws->newline   = "\n";
    dflt_ws->nl_sz     = strlen (dflt_ws->newline);
    dflt_ws->esc_quote = "\"";
    dflt_ws->esq_sz    = strlen (dflt_ws->esc_quote);

    /* store result prefix and tag */
    dflt_ws->resprefix = resprefix;
    dflt_ws->restag    = restag;
    return SUCCESS;
}

/**
 * mapi driver initialization function
 * (The difference to the default initialization function 
 *  is the '=' character that is printed after each newline.)
 */
static bool
mapi_init (XqueryCtx* ctx, char* args, char *restag, char *resprefix)
{
    (void) args;

    /* create workspace container */
    ctx->driverWs = (void *) new_dflt_ws ();

    /* initialize mapping tables and its replacement strings */
    init_isspecial (ctx, "\t", "\n=", "\\");

    /* bind some often used special strings */
    dflt_ws->newline   = "\n=";
    dflt_ws->nl_sz     = strlen (dflt_ws->newline);
    dflt_ws->esc_quote = "\"";
    dflt_ws->esq_sz    = strlen (dflt_ws->esc_quote);

    /* store result prefix and tag */
    dflt_ws->resprefix = resprefix;
    dflt_ws->restag    = restag;
    return SUCCESS;
}

/**
 * seq driver initialization function
 */
static bool
esc_init (XqueryCtx* ctx, char* args, char *restag, char *resprefix)
{
    (void) args;
    (void) restag;
    (void) resprefix;

    /* create workspace container */
    ctx->driverWs = (void *) new_dflt_ws ();

    /* initialize mapping tables and its replacement strings */
    init_isspecial (ctx, "\\t", "\\n", "\\\\");

    /* bind some often used special strings */
    dflt_ws->newline   = "\\n";
    dflt_ws->nl_sz     = strlen (dflt_ws->newline);
    dflt_ws->esc_quote = "\\\"";
    dflt_ws->esq_sz    = strlen (dflt_ws->esc_quote);

    return SUCCESS;
}

/**
 * dflt driver cleanup function --
 * frees the space allocated for the default workspace
 */
static bool
dflt_cleanup (XqueryCtx* ctx)
{
    GDKfree (dflt_ws);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static bool
dflt_handle_startDocument (XqueryCtx* ctx, oid pre)
{
    (void) pre;
    char *tmp;
    /* print string: <?xml version="1.0" encoding="utf-8"?> */ 
    tmp = "<?xml version="; stream_write (ctx->out, tmp, strlen (tmp), 1);
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    tmp = "1.0";            stream_write (ctx->out, tmp, strlen (tmp), 1);
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    tmp = " encoding=";     stream_write (ctx->out, tmp, strlen (tmp), 1);
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    tmp = "utf-8";          stream_write (ctx->out, tmp, strlen (tmp), 1);
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    tmp = "?>";             stream_write (ctx->out, tmp, strlen (tmp), 1);
    stream_write (ctx->out, dflt_ws->newline, dflt_ws->nl_sz, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static bool
dflt_handle_endDocument (XqueryCtx* ctx)
{
    stream_write (ctx->out, dflt_ws->newline, dflt_ws->nl_sz, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static bool
dflt_handle_startElement (XqueryCtx* ctx, str prefix, str name, oid pre)
{
    (void)pre; /* the Pathfinder PRE number is not used by this fun */

    stream_write (ctx->out, &le_, 1, 1); /* < */
    if ( prefix && *prefix ) {
        stream_write (ctx->out, prefix, strlen(prefix), 1);
        stream_write (ctx->out, &c_, 1, 1); /* : */
    }
    stream_write (ctx->out, name, strlen(name), 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static bool
dflt_handle_endElement (XqueryCtx* ctx, str prefix, str name)
{
    stream_write (ctx->out, &le_, 1, 1); /* < */
    stream_write (ctx->out, &sl_, 1, 1); /* / */
    if ( prefix && *prefix ) {
        stream_write (ctx->out, prefix, strlen(prefix), 1);
        stream_write (ctx->out, &c_, 1, 1); /* : */
    }
    stream_write (ctx->out, name, strlen(name), 1);
    stream_write (ctx->out, &ge_, 1, 1); /* > */

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static bool
dflt_handle_characters (XqueryCtx* ctx, str chars)
{
    emit_escaped_entities (ctx, chars);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static bool
seq_handle_characters (XqueryCtx* ctx, str chars)
{
    emit_escaped_all (ctx, chars);

    return SUCCESS;
}

/**
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static bool
dflt_handle_ignorableWhitespace (XqueryCtx* ctx, str chars)
{
    return dflt_handle_characters (ctx, chars); /* dispatch */
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
static bool
dflt_handle_comment (XqueryCtx* ctx, str comm)
{
    stream_write (ctx->out, commentStart, cS_sz, 1);
    emit_escaped_comment (ctx, comm);
    stream_write (ctx->out, commentEnd, cE_sz, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX
 * processingInstruction() event.
 */
static bool
dflt_handle_processingInstruction (XqueryCtx* ctx, str target, str data)
{
    /* stream_printf(ctx->out,"<?%s %s?>",target,data); */
    stream_write (ctx->out, &le_, 1, 1); /* < */
    stream_write (ctx->out, &q_, 1, 1); /* ? */

    stream_write (ctx->out, target, strlen (target), 1);

    stream_write (ctx->out, &s_, 1, 1); /* ' ' */

    stream_write (ctx->out, data, strlen (data), 1);

    stream_write (ctx->out, &q_, 1, 1); /* ? */
    stream_write (ctx->out, &ge_, 1, 1); /* > */

    return SUCCESS;
}

/**
 * Output generation handler. This event completes a start Element.
 */
static bool
dflt_complete_startElement (XqueryCtx* ctx)
{
    stream_write (ctx->out, &ge_, 1, 1); /* > */

    return SUCCESS;
}

/**
 * Output generation handler. This event completes an empty start Element.
 */
static bool
dflt_complete_startElementEmpty (XqueryCtx* ctx)
{
    stream_write (ctx->out, &sl_, 1, 1); /* / */
    stream_write (ctx->out, &ge_, 1, 1); /* > */

    return SUCCESS;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a complete_* () call.
 */
static bool
dflt_handle_attribute (XqueryCtx* ctx, str prefix, str loc, str value)
{
    stream_write (ctx->out, &s_, 1, 1); /* ' ' */

    if ( prefix && *prefix && loc && *loc ) {
        stream_write (ctx->out, prefix, strlen(prefix), 1);
        stream_write (ctx->out, &c_, 1, 1); /* : */
        stream_write (ctx->out, loc, strlen(loc), 1);
    } else if ( prefix && *prefix ) { /* default namespace */
        stream_write (ctx->out, prefix, strlen(prefix), 1);
    } else {
        stream_write (ctx->out, loc, strlen(loc), 1);
    }
    stream_write (ctx->out, &e_, 1, 1); /* = */
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    emit_escaped_all (ctx, value);
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);

    return SUCCESS;
}


/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
static bool
dflt_seqEmitBool (XqueryCtx* ctx, int bv)
{
    char *bool_str = (char*)(bv ? "true" : "false");

    stream_write (ctx->out, bool_str, strlen (bool_str), 1);

    return SUCCESS;
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
static bool
dflt_seqEmitInt (XqueryCtx* ctx, lng iv)
{
    stream_printf(ctx->out,LLFMT,iv);

    return SUCCESS;
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
static bool
dflt_seqEmitDbl (XqueryCtx* ctx, dbl dv)
{
    stream_printf (ctx->out, "%f", dv);

    return SUCCESS;
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static bool
dflt_seqEmitStr (XqueryCtx* ctx, str sv)
{
    emit_escaped_all (ctx, sv);

    return SUCCESS;
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static bool
esc_seqEmitStr (XqueryCtx* ctx, str sv)
{
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    emit_escaped_all (ctx, sv);
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);

    return SUCCESS;
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static bool
text_seqEmitStr (XqueryCtx* ctx, str sv)
{
    emit_escaped_newline (ctx, sv);

    return SUCCESS;
}

/**
 * Output generation handler. Handles top-level attributes.
 */
static bool
dflt_seqEmitAttribute (XqueryCtx* ctx, str prefix, str loc, str value)
{
    stream_write (ctx->out, attributeStart, aS_sz, 1);

    if ( prefix && *prefix && loc && *loc ) {
        stream_write (ctx->out, prefix, strlen(prefix), 1);
        stream_write (ctx->out, &c_, 1, 1); /* : */
        stream_write (ctx->out, loc, strlen(loc), 1);
    } else if ( prefix && *prefix ) { /* default namespace */
        stream_write (ctx->out, prefix, strlen(prefix), 1);
    } else {
        stream_write (ctx->out, loc, strlen(loc), 1);
    }

    stream_write (ctx->out, attributeMid, aM_sz, 1);
    emit_escaped_all (ctx, value);
    stream_write (ctx->out, attributeEnd, aE_sz, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles top-level attributes.
 */
static bool
text_seqEmitAttribute (XqueryCtx* ctx, str prefix, str loc, str value)
{
    (void) ctx;
    (void) prefix;
    (void) loc;
    (void) value;
    
    GDKerror("serialize_dflt.mx: unable to print top level "
             "attribute nodes in text mode\n");
    
    return PROBLEM;
}

/**
 * Output generation handler. Handles top-level textnodes.
 */
static bool
dflt_seqEmitTextnode (XqueryCtx* ctx, str chars)
{
    stream_write (ctx->out, textnodeStart, tnS_sz, 1);
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    
    emit_escaped_entities (ctx, chars);

    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    stream_write (ctx->out, textnodeEnd, tnE_sz, 1);
    
    return SUCCESS;
}

/**
 * Output generation handler. Handles top-level textnodes.
 */
static bool
seq_seqEmitTextnode (XqueryCtx* ctx, str chars)
{
    stream_write (ctx->out, textnodeStart, tnS_sz, 1);
    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    
    emit_escaped_all (ctx, chars);

    stream_write (ctx->out, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    stream_write (ctx->out, textnodeEnd, tnE_sz, 1);
    
    return SUCCESS;
}



/**
 *
 * item sequence handlers for the data model output format
 *
 */
 
/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static bool
dm_seqStart (XqueryCtx* ctx, int count)
{
    (void)count;

    if (ctx->modes & MODE_MAPI)
    /* We need to prepend "=" to each line, so make sure
       that we print one after each newline (encoded in
       newline string 'newline')->
       In addition we print one '=' at the beginning-> */
        stream_write (ctx->out, &e_, 1, 1);

    return SUCCESS;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static bool
dm_seqEnd (XqueryCtx* ctx)
{
    stream_write (ctx->out, "\n", 1, 1);

    return SUCCESS;
}

static bool
dm_seqItemSeparator (XqueryCtx* ctx, int kind_before, int kind_after)
{
    (void)kind_before;
    (void)kind_after;
    
    stream_write (ctx->out, &sep_, 1, 1); /* , */
    stream_write (ctx->out, dflt_ws->newline, dflt_ws->nl_sz, 1);

    return SUCCESS;
}

/**
 *
 * item sequence handlers for the XML output format
 *
 */
 
/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static bool
xml_seqStart (XqueryCtx* ctx, int count)
{
    (void)count;

    if (ctx->modes & MODE_MAPI)
    /* We need to prepend "=" to each line, so make sure
       that we print one after each newline (encoded in
       newline string 'newline')->
       In addition we print one '=' at the beginning-> */
        stream_write (ctx->out, &e_, 1, 1);

    if ( !(ctx->modes & MODE_NO_HEADER) ) {
        char *init = "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
        stream_write (ctx->out, init, strlen (init), 1);
        stream_write (ctx->out, dflt_ws->newline, dflt_ws->nl_sz, 1);
    }
    if ( !(ctx->modes & MODE_NO_ROOT) ) {
        dflt_handle_startElement (ctx, NULL, dflt_ws->restag, oid_nil);
    }
    return SUCCESS;
}

/**
 * Completes the result start tag.
 */
static bool
xml_complete_seqStart (XqueryCtx* ctx)
{
    if ( !(ctx->modes & MODE_NO_ROOT) ) {
        stream_write (ctx->out, &ge_, 1, 1); /* > */
    }

    return SUCCESS;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static bool
xml_seqEnd (XqueryCtx* ctx)
{
    if ( !(ctx->modes & MODE_NO_ROOT) ) {
        dflt_handle_endElement (ctx, NULL, dflt_ws->restag);
        stream_write (ctx->out, "\n", 1, 1);
    }

    return SUCCESS;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static bool
xml_mapi_seqEnd (XqueryCtx* ctx)
{
    if ( !(ctx->modes & MODE_NO_ROOT) ) {
        dflt_handle_endElement (ctx, NULL, dflt_ws->restag);
    }
    /* a result sequence in mclient always has to end with '\n' */
    stream_write (ctx->out, "\n", 1, 1);

    return SUCCESS;
}

static bool
xml_seqItemSeparator (XqueryCtx* ctx, int kind_before, int kind_after)
{
    if ((XTRACT_KIND(kind_before) < ATOMIC) &&
        (XTRACT_KIND(kind_after) < ATOMIC))
        stream_write (ctx->out, &s_, 1, 1); /* ' ' */

    return SUCCESS;
}

/**
 *
 * item sequence handlers for the _typed_ XML output format
 *
 */
 
/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static bool
typed_xml_seqStart (XqueryCtx* ctx, int count)
{
    (void)count;

    if (ctx->modes & MODE_MAPI && !(ctx->modes & MODE_XRPC))
    /* We need to prepend "=" to each line, so make sure
       that we print one after each newline (encoded in
       newline string 'newline')->
       In addition we print one '=' at the beginning-> */
       stream_write (ctx->out, &e_, 1, 1);

    if ( !(ctx->modes & MODE_NO_HEADER) ) {
        stream_printf(ctx->out, "<?xml version=\"1.0\" encoding=\"utf-8\"?>");
        stream_write (ctx->out, dflt_ws->newline, dflt_ws->nl_sz, 1);
    }

    if (ctx->modes & MODE_XRPC) {
        stream_printf(ctx->out, "<xrpc:sequence>");
    } else {
        stream_printf(ctx->out, "<%s:sequence "
                "xmlns:%s=\"http://monetdb.cwi.nl/XQuery/results\" "
                "xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" "
                "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">",
                dflt_ws->resprefix, dflt_ws->resprefix);
    }

    return SUCCESS;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static bool
typed_xml_seqEnd (XqueryCtx* ctx)
{
    stream_printf (ctx->out, "</%s:sequence>", dflt_ws->resprefix);
    if (!(ctx->modes & MODE_XRPC))
        stream_write (ctx->out, "\n", 1, 1);

    return SUCCESS;
}

static bool
typed_xml_seqItemStart (XqueryCtx* ctx, int kind)
{
    switch (XTRACT_KIND(kind)) {
        case BOOL:
            stream_printf(ctx->out,
                    "<%s:atomic-value xsi:type=\"xs:boolean\">",
                    dflt_ws->resprefix);
            break;
        case INT:
            stream_printf(ctx->out,
                    "<%s:atomic-value xsi:type=\"xs:integer\">",
                    dflt_ws->resprefix);
            break;
        case DEC:
            stream_printf(ctx->out,
                    "<%s:atomic-value xsi:type=\"xs:decimal\">",
                    dflt_ws->resprefix);
            break;
        case DBL:
            stream_printf(ctx->out,
                    "<%s:atomic-value xsi:type=\"xs:double\">",
                    dflt_ws->resprefix);
            break;
        case STR:
            stream_printf(ctx->out,
                    "<%s:atomic-value xsi:type=\"xs:string\">",
                    dflt_ws->resprefix);
            break;
        case U_A:
            stream_printf(ctx->out,
                    "<%s:atomic-value xmlns:xdt="
                    "\"http://www.w3.org/2005/xpath-datatypes\" "
                    "xsi:type=\"xdt:untypedAtomic\">",
                    dflt_ws->resprefix);
            break;
        case ELEM:
        {   
            /* extract node kind from overloaded kind */
            switch ((char) XTRACT_CONT(kind)) {
                case 0 /* ELEMENT */:
                    stream_printf(ctx->out, "<%s:element>",
                            dflt_ws->resprefix);
                    break;
                case 1 /* TEXT */:
                    stream_printf(ctx->out, "<%s:text>",
                            dflt_ws->resprefix);
                    break;
                case 2 /* COMMENT */:
                    stream_printf(ctx->out, "<%s:comment>",
                            dflt_ws->resprefix);
                    break;
                case 3 /* PI */:
                    stream_printf(ctx->out, "<%s:processing-instruction>",
                            dflt_ws->resprefix);
                    break;
                case 4 /* DOCUMENT */:
                    stream_printf(ctx->out, "<%s:document>",
                            dflt_ws->resprefix);
                    break;
                case 5 /* COLLECTION */:
                    /* nothing to be done, here */
                    break;
                default:
                    return PROBLEM;
                    break;
            }
        }   break;
        case ATTR:
            stream_printf(ctx->out, "<%s:attribute", dflt_ws->resprefix);
            break;
        default:
            return PROBLEM;
            break;
    }
    return SUCCESS;
}

static bool
typed_xml_seqItemEnd (XqueryCtx* ctx, int kind)
{
    switch (XTRACT_KIND(kind)) {
        case BOOL:
        case INT:
        case DEC:
        case DBL:
        case STR:
        case U_A:
            stream_printf(ctx->out, "</%s:atomic-value>",
                    dflt_ws->resprefix);
            break;
        case ELEM:
        {   
            /* extract node kind from overloaded kind */
            switch (XTRACT_CONT(kind)) {
                case 0 /* ELEMENT */:
                    stream_printf(ctx->out, "</%s:element>",
                        dflt_ws->resprefix);
                    break;
                case 1 /* TEXT */:
                    stream_printf(ctx->out, "</%s:text>",
                        dflt_ws->resprefix);
                    break;
                case 2 /* COMMENT */:
                    stream_printf(ctx->out, "</%s:comment>",
                        dflt_ws->resprefix);
                    break;
                case 3 /* PI */:
                    stream_printf(ctx->out, "</%s:processing-instruction>",
                        dflt_ws->resprefix);
                    break;
                case 4 /* DOCUMENT */:
                    stream_printf(ctx->out, "</%s:document>",
                        dflt_ws->resprefix);
                    break;
                case 5 /* COLLECTION */:
                    /* nothing to be done, here */
                    break;
                default:
                    return PROBLEM;
                    break;
            }
        }   break;
        case ATTR:
            stream_write(ctx->out, "/>", 2, 1);
            break;
        default:
            return PROBLEM;
            break;
    }
    return SUCCESS;
}

/**
 *  Start serialization of XRPC response message
 */
static bool
xrpc_startSerialize(XqueryCtx *ctx)
{
    int len, ret = 0;
   

    if (ctx->xrpc_qid[0] && ctx->time_exec > ctx->xrpc_timeout) {
        GDKerror("xrpc_startSerialize: xrpc-query timed out\n");
        return PROBLEM;
    }

    /* HACK: we use GDKout and not ctx->stdout because the logger stream should see only the XML content */
    len = strlen(HTTP_200_OK);
    ret = stream_write(GDKout, HTTP_200_OK, 1, len);
    if(ret != len) return PROBLEM;

    len = strlen(SOAP_ENVELOPE);
    ret = stream_write(ctx->out, SOAP_ENVELOPE, 1, len);
    if(ret != len) return PROBLEM;

    if (ctx->xrpc_qid[0] || strstr(ctx->xrpc_mode,"trace")) {
        BATiter bi = bat_iterator(ctx->ws);
        bat bid = *(bat*) BUNtail(bi, XRPC_PARTICIPANTS);
        BAT* b = BATdescriptor(bid);
        BUN p,q;

        if (b == NULL) return PROBLEM;

        ret = stream_printf(ctx->out, "<env:Header>\n");
        if (ret >= 0 && ctx->xrpc_qid[0])
            ret = stream_printf(ctx->out, XRPC_WS_QID, ctx->xrpc_qid, ctx->xrpc_timeout);

        /* XRPC participants lists for nested transactions - append an extra item for this call */
        if(ret >= 0)
            ret = stream_printf(ctx->out, 
                " <xrpc:participants>\n  <xrpc:participant>%s,%s:"LLFMT",%s,"LLFMT",%d</xrpc:participant>\n",
                ctx->xrpc_caller, ctx->xrpc_hostport, ctx->xrpc_seqnr, ctx->xrpc_method, ctx->time_exec,
                (int) ctx->xrpc_updating);

        /* print all nested calls (obtained from response messages)  */
        bi = bat_iterator(b);
        BATloop(b,p,q) {
            if (ret < 0) break;
            ret = stream_printf(ctx->out, "  <xrpc:participant>%s</xrpc:participant>\n", BUNtail(bi,p));
        }
        if (ret >= 0) 
            ret = stream_printf(ctx->out, " </xrpc:participants>\n</env:Header>\n");

        BBPunfix(bid);
        if (ret < 0) return PROBLEM;
    }
    ret = stream_printf(ctx->out, XRPC_RES_BODY, ctx->xrpc_module, ctx->xrpc_method);
    return (ret < 0)?PROBLEM:SUCCESS;
}

/**
 *  End serialization of XRPC response message
 */
static bool
xrpc_endSerialize(XqueryCtx *ctx)
{
    stream_printf(ctx->out,
            "</xrpc:response></env:Body></env:Envelope>\n");
    return SUCCESS;
}

/**
 *
 * item sequence handlers for the JDBC/XMLDB output format
 *
 */
 
/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static bool
seq_seqStart (XqueryCtx* ctx, int count)
{
    /* write SQL-ish header */
    stream_printf(ctx->out,"&1 %d %d 1 %d\n", 
                  dflt_ws->id_sequence_counter++, count, count);
    stream_printf(ctx->out,"%% xquery.result\t# table_name\n");
    stream_printf(ctx->out,"%% xml\t# name\n");
    stream_printf(ctx->out,"%% varchar\t# type\n");
    stream_printf(ctx->out,"%% %d\t# length\n", 60);

    return SUCCESS;
}

static bool
seq_seqItemStart (XqueryCtx* ctx, int kind)
{
    (void)kind;
    
    /* SQL-ish mode: write start of tuple and open string */
    stream_write (ctx->out, "[ \"", 3, 1);

    return SUCCESS;
}

static bool
seq_seqItemEnd (XqueryCtx* ctx, int kind)
{
    (void)kind;
    
    /* SQL-ish mode: write end of string and end of tuple */
    stream_printf(ctx->out,"\"\t]\n");

    return SUCCESS;
}

/**
 *
 * Definitions of the structures containing the functions
 *
 */
struct serializeFunStruct dmSerializeFun = {
    "dm",
    dflt_init,
    dflt_cleanup,

    null_startSerialize,
    null_endSerialize,

    dflt_handle_startDocument,
    dflt_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    esc_seqEmitStr,
    dflt_seqEmitAttribute,
    dflt_seqEmitTextnode,

    dm_seqStart,
    null_complete_seqStart,
    dm_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    dm_seqItemSeparator
};

struct serializeFunStruct mapi_dmSerializeFun = {
    "dm mapi",
    mapi_init,
    dflt_cleanup,

    null_startSerialize,
    null_endSerialize,

    dflt_handle_startDocument,
    dflt_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    esc_seqEmitStr,
    dflt_seqEmitAttribute,
    dflt_seqEmitTextnode,

    dm_seqStart,
    null_complete_seqStart,
    dm_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    dm_seqItemSeparator
};

struct serializeFunStruct textSerializeFun = {
    "text",
    dflt_init,
    dflt_cleanup,

    null_startSerialize,
    null_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    text_seqEmitStr,
    text_seqEmitAttribute,
    text_seqEmitStr,

    dm_seqStart,
    null_complete_seqStart,
    dm_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    null_seqItemSeparator
};

struct serializeFunStruct mapi_textSerializeFun = {
    "text mapi",
    mapi_init,
    dflt_cleanup,

    null_startSerialize,
    null_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    text_seqEmitStr,
    text_seqEmitAttribute,
    text_seqEmitStr,

    dm_seqStart,
    null_complete_seqStart,
    dm_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    null_seqItemSeparator
};

struct serializeFunStruct xmlSerializeFun = {
    "xml",
    dflt_init,
    dflt_cleanup,

    null_startSerialize,
    null_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    xml_seqStart,
    xml_complete_seqStart,
    xml_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    xml_seqItemSeparator
};

struct serializeFunStruct mapi_xmlSerializeFun = {
    "xml mapi",
    mapi_init,
    dflt_cleanup,

    null_startSerialize,
    null_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    xml_seqStart,
    xml_complete_seqStart,
    xml_mapi_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    xml_seqItemSeparator
};

struct serializeFunStruct typed_xmlSerializeFun = {
    "xml typed",
    dflt_init,
    dflt_cleanup,

    null_startSerialize,
    null_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    typed_xml_seqStart,
    null_complete_seqStart,
    typed_xml_seqEnd,
    typed_xml_seqItemStart,
    typed_xml_seqItemEnd,
    null_seqItemSeparator
};

struct serializeFunStruct mapi_typed_xmlSerializeFun = {
    "xml mapi typed",
    mapi_init,
    dflt_cleanup,

    null_startSerialize,
    null_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    typed_xml_seqStart,
    null_complete_seqStart,
    typed_xml_seqEnd,
    typed_xml_seqItemStart,
    typed_xml_seqItemEnd,
    null_seqItemSeparator
};

struct serializeFunStruct xrpc_xmlSerializeFun = {
    "xml xrpc",
    dflt_init,
    dflt_cleanup,

    xrpc_startSerialize,
    xrpc_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_handle_characters,
    dflt_handle_attribute,
    dflt_handle_characters,

    typed_xml_seqStart,
    null_complete_seqStart,
    typed_xml_seqEnd,
    typed_xml_seqItemStart,
    typed_xml_seqItemEnd,
    null_seqItemSeparator
};

struct serializeFunStruct mapi_xrpc_xmlSerializeFun = {
    "xml mapi xrpc",
    mapi_init,
    dflt_cleanup,

    xrpc_startSerialize,
    xrpc_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_handle_characters,
    dflt_handle_attribute,
    dflt_handle_characters,

    typed_xml_seqStart,
    null_complete_seqStart,
    typed_xml_seqEnd,
    typed_xml_seqItemStart,
    typed_xml_seqItemEnd,
    null_seqItemSeparator
};

struct serializeFunStruct seqSerializeFun = {
    "seq",
    esc_init,
    dflt_cleanup,

    null_startSerialize,
    null_endSerialize,

    dflt_handle_startDocument,
    dflt_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    seq_handle_characters,
    seq_handle_characters,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    esc_seqEmitStr,
    dflt_seqEmitAttribute,
    seq_seqEmitTextnode,

    seq_seqStart,
    null_complete_seqStart,
    null_seqEnd,
    seq_seqItemStart,
    seq_seqItemEnd,
    null_seqItemSeparator
};

/* vim:set shiftwidth=4 expandtab: */
