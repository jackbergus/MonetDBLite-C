@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2006 University of Konstanz.  All Rights Reserved.
@'

@f serialize_dflt
@a Jan Flokstra
@a Jan Rittinger
@t serialize_dflt

@c
/*******************************************
 * serialize_dflt.c : XML serialization functions
 * The default serialization function definitions are in this file.
 * They are called by the driver software in serialize.c
 *
 */

#include "serialize.h"
/* contains dummy callback functions */
#include "serialize_null.h"

/* a lot of characters, static strings, and its sizes 
   (the idea is to reuse constant character pointers during
    serialization) */
static char s_   = ' ';
static char c_   = ':';
static char e_   = '=';
static char le_  = '<';
static char ge_  = '>';
static char sl_  = '/';
static char q_   = '?';
static char sep_ = ',';

static char *commentStart = "<!--";
static char *commentEnd = "-->";
static size_t cS_sz = 4; /* strlen (commentStart); */
static size_t cE_sz = 3; /* strlen (commentEnd); */

static char *attributeStart = "attribute ";
static char *attributeMid = " { ";
static char *attributeEnd = " }";
static size_t aS_sz = 10; /* strlen (attributeStart); */
static size_t aM_sz = 3; /* strlen (attributeMid); */
static size_t aE_sz = 2; /* strlen (attributeEnd); */

static char *textnodeStart = "text {";
static char *textnodeEnd = "}";
static size_t tnS_sz = 6; /* strlen (textnodeStart); */
static size_t tnE_sz = 1; /* strlen (textnodeEnd); */

/**
 * struct dflt_ws_t stores information required during serialization
 * that may differ for each serialization invocation.
 */
struct dflt_ws_t {
    char  *restag; /* result tag name */
    char  *newline, *esc_quote; /* newline and escaped quote string */
    size_t nl_sz, esq_sz; /* length of newline and escaped quote string */
    
    /* sequence counter required for JDBC output (seq output) */
    unsigned int id_sequence_counter;
    
    /* special character mapping table */
    unsigned char isspecial_tab[UCHAR_MAX+1]; /* the main table */
    char*         special_val[32]; /* the replacements of the special chars */
    int           special_len[32]; /* the length of the replacements strings */
};
typedef struct dflt_ws_t dflt_ws_t;

/**
 * constructor function for the default workspace
 */
static dflt_ws_t *
new_dflt_ws ()
{
    dflt_ws_t *dflt_ws_ = malloc (sizeof (dflt_ws_t));

    for(int i = 0; i < UCHAR_MAX; i++)
        /* special character mapping table */
        dflt_ws_->isspecial_tab[i] = 0;

    dflt_ws_->id_sequence_counter = 0;

    return dflt_ws_;
}

#define dflt_ws ((dflt_ws_t *) ctx->driverWs)

/**
 * The character translation section responsible for the special
 * character recognition and XML entity characters.  It consists of a
 * small main table 'isspecial_tab' containing the flags for every
 * possible character.
 *
 * The different output modes differ only in the representation of
 * tabulators, newlines, and backslashes (see function arguments).
 * The replacements for the special characters are stored in the 
 * 'special_val' array and its lengths in the 'special_len' array.
 *
 * v=0: no special char
 * v=1: special char, should be presented as octal char in output
 * v>1: special char, string repr of char is isspecial_val[v]
 */
static void init_isspecial (XqueryCtx* ctx, 
                            char *tab,
                            char* newline,
                            char *backslash)
{
    int i;
    for(i=0; i<32; i++) dflt_ws->isspecial_tab[i] = 1; /* write as octal */

    dflt_ws->isspecial_tab[(int)(unsigned char)'\377'] = 1; /* write as octal */
    dflt_ws->isspecial_tab[(int)'\t'] = 9;
    dflt_ws->isspecial_tab[(int)'\\'] = 8;
    dflt_ws->isspecial_tab[(int)'\"'] = 7;
    dflt_ws->isspecial_tab[(int)'\''] = 6;
    /* order is important for entity only string escaping */
    dflt_ws->isspecial_tab[(int)'\n'] = 5;
    dflt_ws->isspecial_tab[(int)'\r'] = 5;	/* map \r on \n */
    dflt_ws->isspecial_tab[(int)'&']  = 4;
    dflt_ws->isspecial_tab[(int)'<']  = 3;
    dflt_ws->isspecial_tab[(int)'>']  = 2;

    dflt_ws->special_val[0] = NULL; /* not used */
    dflt_ws->special_val[1] = NULL; /* not used, 1 = write as octal */

    dflt_ws->special_val[9] = tab;
    dflt_ws->special_val[8] = backslash;
    dflt_ws->special_val[7] = "&quot;";
    dflt_ws->special_val[6] = "&apos;";
    dflt_ws->special_val[5] = newline;
    dflt_ws->special_val[4] = "&amp;";
    dflt_ws->special_val[3] = "&lt;";
    dflt_ws->special_val[2] = "&gt;";

    /* also collect the lengths of the replacment strings */
    for (i=2; i <= 9; i++)
        dflt_ws->special_len[i] = strlen (dflt_ws->special_val[i]);
}

@= emit_escaped
static void
emit_escaped@1 (XqueryCtx* ctx, char* src) {
    int start = 0, end;
    unsigned char isspecial_ch;

    for(end = 0; src[end]; end++) {
        isspecial_ch = dflt_ws->isspecial_tab[(int)(unsigned char)src[end]];
        if (isspecial_ch @2) {
            /* print all characters that were collected 
               since the last special character. */
            stream_write (GDKout, &src[start], end - start, 1);
            start = end + 1;

            if ( isspecial_ch == 1 ) { /* print octal */
                stream_printf(GDKout,"\\%03o",(unsigned char)src[end]);
            } else {
                char *emit_val = dflt_ws->special_val[(int)isspecial_ch];
                int   emit_len = dflt_ws->special_len[(int)isspecial_ch];
                stream_write (GDKout, emit_val, emit_len, 1);
            }
        }
    }
    if ( start < end )
        stream_write (GDKout, &src[start], end - start, 1);
}

@c
/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 *
 * Emit a string with all special character escaped.
 */
@:emit_escaped(,)@
/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 *
 * Emit a string with all entities escaped.
 */
@:emit_escaped(_entities,&& isspecial_ch <= 5)@

/**
 * dflt driver initialization function
 */
static bool
dflt_init (XqueryCtx* ctx, char* args, char *restag)
{
    (void) args;

    /* create workspace container */
    ctx->driverWs = (void *) new_dflt_ws ();

    /* initialize mapping tables and its replacement strings */
    init_isspecial (ctx, "\t", "\n", "\\");

    /* bind some often used special strings */
    dflt_ws->newline   = "\n";
    dflt_ws->nl_sz     = strlen (dflt_ws->newline);
    dflt_ws->esc_quote = "\"";
    dflt_ws->esq_sz    = strlen (dflt_ws->esc_quote);

    /* store result tag */
    dflt_ws->restag    = restag;

    return SUCCESS;
}

/**
 * mapi driver initialization function
 * (The difference to the default initialization function 
 *  is the '=' character that is printed after each newline.)
 */
static bool
mapi_init (XqueryCtx* ctx, char* args, char *restag)
{
    (void) args;

    /* create workspace container */
    ctx->driverWs = (void *) new_dflt_ws ();

    /* initialize mapping tables and its replacement strings */
    init_isspecial (ctx, "\t", "\n=", "\\");

    /* bind some often used special strings */
    dflt_ws->newline   = "\n=";
    dflt_ws->nl_sz     = strlen (dflt_ws->newline);
    dflt_ws->esc_quote = "\"";
    dflt_ws->esq_sz    = strlen (dflt_ws->esc_quote);

    /* store result tag */
    dflt_ws->restag    = restag;

    return SUCCESS;
}

/**
 * seq driver initialization function
 */
static bool
esc_init (XqueryCtx* ctx, char* args, char *restag)
{
    (void) args;
    (void) restag;

    /* create workspace container */
    ctx->driverWs = (void *) new_dflt_ws ();

    /* initialize mapping tables and its replacement strings */
    init_isspecial (ctx, "\\t", "\\n", "\\\\");

    /* bind some often used special strings */
    dflt_ws->newline   = "\\n";
    dflt_ws->nl_sz     = strlen (dflt_ws->newline);
    dflt_ws->esc_quote = "\\\"";
    dflt_ws->esq_sz    = strlen (dflt_ws->esc_quote);

    return SUCCESS;
}

/**
 * dflt driver cleanup function --
 * frees the space allocated for the default workspace
 */
static bool
dflt_cleanup (XqueryCtx* ctx)
{
    free (dflt_ws);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static bool
dflt_handle_startDocument (XqueryCtx* ctx)
{
    char *tmp;
    /* print string: <?xml version="1.0" encoding="utf-8"?> */ 
    tmp = "<?xml version="; stream_write (GDKout, tmp, strlen (tmp), 1);
    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    tmp = "1.0";            stream_write (GDKout, tmp, strlen (tmp), 1);
    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    tmp = " encoding=";     stream_write (GDKout, tmp, strlen (tmp), 1);
    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    tmp = "utf-8";          stream_write (GDKout, tmp, strlen (tmp), 1);
    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    tmp = "?>";             stream_write (GDKout, tmp, strlen (tmp), 1);
    stream_write (GDKout, dflt_ws->newline, dflt_ws->nl_sz, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static bool
dflt_handle_endDocument (XqueryCtx* ctx)
{
    stream_write (GDKout, dflt_ws->newline, dflt_ws->nl_sz, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static bool
dflt_handle_startElement (XqueryCtx* ctx, str prefix, str name, oid pre)
{
    (void)ctx;
    (void)pre; /* the Pathfinder PRE number is not used by this fun */

    stream_write (GDKout, &le_, 1, 1); /* < */
    if ( prefix && *prefix ) {
        stream_write (GDKout, prefix, strlen(prefix), 1);
        stream_write (GDKout, &c_, 1, 1); /* : */
    }
    stream_write (GDKout, name, strlen(name), 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static bool
dflt_handle_endElement (XqueryCtx* ctx, str prefix, str name)
{
    (void)ctx;

    stream_write (GDKout, &le_, 1, 1); /* < */
    stream_write (GDKout, &sl_, 1, 1); /* / */
    if ( prefix && *prefix ) {
        stream_write (GDKout, prefix, strlen(prefix), 1);
        stream_write (GDKout, &c_, 1, 1); /* : */
    }
    stream_write (GDKout, name, strlen(name), 1);
    stream_write (GDKout, &ge_, 1, 1); /* > */

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static bool
dflt_handle_characters (XqueryCtx* ctx, str chars)
{
    emit_escaped_entities (ctx, chars);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static bool
dflt_handle_ignorableWhitespace (XqueryCtx* ctx, str chars)
{
    return dflt_handle_characters (ctx, chars); /* dispatch */
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
static bool
dflt_handle_comment (XqueryCtx* ctx, str comm)
{
    (void)ctx;

    stream_write (GDKout, commentStart, cS_sz, 1);
    stream_write (GDKout, comm, strlen (comm), 1);
    stream_write (GDKout, commentEnd, cE_sz, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX
 * processingInstruction() event.
 */
static bool
dflt_handle_processingInstruction (XqueryCtx* ctx, str target, str data)
{
    (void)ctx;

    /* stream_printf(GDKout,"<?%s %s?>",target,data); */
    stream_write (GDKout, &le_, 1, 1); /* < */
    stream_write (GDKout, &q_, 1, 1); /* ? */

    stream_write (GDKout, target, strlen (target), 1);

    stream_write (GDKout, &s_, 1, 1); /* ' ' */

    stream_write (GDKout, data, strlen (data), 1);

    stream_write (GDKout, &q_, 1, 1); /* ? */
    stream_write (GDKout, &ge_, 1, 1); /* > */

    return SUCCESS;
}

/**
 * Output generation handler. This event completes a start Element.
 */
static bool
dflt_complete_startElement (XqueryCtx* ctx)
{
    (void)ctx;

    stream_write (GDKout, &ge_, 1, 1); /* > */

    return SUCCESS;
}

/**
 * Output generation handler. This event completes an empty start Element.
 */
static bool
dflt_complete_startElementEmpty (XqueryCtx* ctx)
{
    (void)ctx;

    stream_write (GDKout, &sl_, 1, 1); /* / */
    stream_write (GDKout, &ge_, 1, 1); /* > */

    return SUCCESS;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a complete_* () call.
 */
static bool
dflt_handle_attribute (XqueryCtx* ctx, str prefix, str loc, str value)
{
    stream_write (GDKout, &s_, 1, 1); /* ' ' */

    if ( prefix && *prefix && loc && *loc ) {
        stream_write (GDKout, prefix, strlen(prefix), 1);
        stream_write (GDKout, &c_, 1, 1); /* : */
        stream_write (GDKout, loc, strlen(loc), 1);
    } else if ( prefix && *prefix ) { /* default namespace */
        stream_write (GDKout, prefix, strlen(prefix), 1);
    } else {
        stream_write (GDKout, loc, strlen(loc), 1);
    }
    stream_write (GDKout, &e_, 1, 1); /* = */
    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    emit_escaped (ctx, value);
    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);

    return SUCCESS;
}


/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
static bool
dflt_seqEmitBool (XqueryCtx* ctx, int bv)
{
    char *bool_str = (char*)(bv ? "true" : "false");

    (void)ctx;

    stream_write (GDKout, bool_str, strlen (bool_str), 1);

    return SUCCESS;
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
static bool
dflt_seqEmitInt (XqueryCtx* ctx, lng iv)
{
    (void)ctx;

    stream_printf(GDKout,"%lld",iv);

    return SUCCESS;
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
static bool
dflt_seqEmitDbl (XqueryCtx* ctx, dbl dv)
{
    (void)ctx;

    stream_printf (GDKout, "%f", dv);

    return SUCCESS;
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static bool
dflt_seqEmitStr (XqueryCtx* ctx, str sv)
{
    emit_escaped (ctx, sv);

    return SUCCESS;
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static bool
esc_seqEmitStr (XqueryCtx* ctx, str sv)
{
    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    emit_escaped (ctx, sv);
    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles top-level attributes.
 */
static bool
dflt_seqEmitAttribute (XqueryCtx* ctx, str prefix, str loc, str value)
{
    (void)ctx;

    stream_write (GDKout, attributeStart, aS_sz, 1);

    if ( prefix && *prefix && loc && *loc ) {
        stream_write (GDKout, prefix, strlen(prefix), 1);
        stream_write (GDKout, &c_, 1, 1); /* : */
        stream_write (GDKout, loc, strlen(loc), 1);
    } else if ( prefix && *prefix ) { /* default namespace */
        stream_write (GDKout, prefix, strlen(prefix), 1);
    } else {
        stream_write (GDKout, loc, strlen(loc), 1);
    }

    stream_write (GDKout, attributeMid, aM_sz, 1);
    stream_write (GDKout, value, strlen(value), 1);
    stream_write (GDKout, attributeEnd, aE_sz, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles top-level textnodes.
 */
static bool
dflt_seqEmitTextnode (XqueryCtx* ctx, str chars)
{
    stream_write (GDKout, textnodeStart, tnS_sz, 1);
    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    
    emit_escaped_entities (ctx, chars);

    stream_write (GDKout, dflt_ws->esc_quote, dflt_ws->esq_sz, 1);
    stream_write (GDKout, textnodeEnd, tnE_sz, 1);
    
    return SUCCESS;
}



/**
 *
 * item sequence handlers for the data model output format
 *
 */
 
/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static bool
dm_seqStart (XqueryCtx* ctx, int count)
{
    (void)count;

    if (ctx->modes & MODE_MAPI)
    /* We need to prepend "=" to each line, so make sure
       that we print one after each newline (encoded in
       newline string 'newline')->
       In addition we print one '=' at the beginning-> */
        stream_write (GDKout, &e_, 1, 1);

    return SUCCESS;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static bool
dm_seqEnd (XqueryCtx* ctx)
{
    (void)ctx;

    stream_write (GDKout, "\n", 1, 1);

    return SUCCESS;
}

static bool
dm_seqItemSeparator (XqueryCtx* ctx, int kind_before, int kind_after)
{
    (void)kind_before;
    (void)kind_after;
    
    stream_write (GDKout, &sep_, 1, 1); /* , */
    stream_write (GDKout, dflt_ws->newline, dflt_ws->nl_sz, 1);

    return SUCCESS;
}

/**
 *
 * item sequence handlers for the XML output format
 *
 */
 
/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static bool
xml_seqStart (XqueryCtx* ctx, int count)
{
    (void)count;

    if (ctx->modes & MODE_MAPI)
    /* We need to prepend "=" to each line, so make sure
       that we print one after each newline (encoded in
       newline string 'newline')->
       In addition we print one '=' at the beginning-> */
        stream_write (GDKout, &e_, 1, 1);

    if ( !(ctx->modes & MODE_NO_ROOT) ) {
        if ( !(ctx->modes & MODE_NO_HEADER) ) {
            char *init = "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
            stream_write (GDKout, init, strlen (init), 1);
            stream_write (GDKout, dflt_ws->newline, dflt_ws->nl_sz, 1);
        }

        dflt_handle_startElement (ctx, NULL, dflt_ws->restag, oid_nil);
    }
    return SUCCESS;
}

/**
 * Completes the result start tag.
 */
static bool
xml_complete_seqStart (XqueryCtx* ctx)
{
    if ( !(ctx->modes & MODE_NO_ROOT) ) {
        stream_write (GDKout, &ge_, 1, 1); /* > */
        stream_write (GDKout, dflt_ws->newline, dflt_ws->nl_sz, 1);
    }

    return SUCCESS;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static bool
xml_seqEnd (XqueryCtx* ctx)
{
    if ( !(ctx->modes & MODE_NO_ROOT) ) {
        stream_write (GDKout, dflt_ws->newline, dflt_ws->nl_sz, 1);
        dflt_handle_endElement (ctx, NULL, dflt_ws->restag);

    }
    stream_write (GDKout, "\n", 1, 1);

    return SUCCESS;
}

static bool
xml_seqItemSeparator (XqueryCtx* ctx, int kind_before, int kind_after)
{
    (void)ctx;

    if ((XTRACT_KIND(kind_before) < ATOMIC) &&
        (XTRACT_KIND(kind_after) < ATOMIC))
        stream_write (GDKout, &s_, 1, 1); /* ' ' */

    return SUCCESS;
}

/**
 *
 * item sequence handlers for the _typed_ XML output format
 *
 */
 
/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static bool
typed_xml_seqStart (XqueryCtx* ctx, int count)
{
    (void)ctx;
    (void)count;

    char *seq_start = "<result:sequence "
                      "xmlns:result=\"http://monetdb.cwi.nl/xquery-results\" "
                      "xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" "
                      "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-"
                      "instance\">";

    if (ctx->modes & MODE_MAPI)
    /* We need to prepend "=" to each line, so make sure
       that we print one after each newline (encoded in
       newline string 'newline')->
       In addition we print one '=' at the beginning-> */
        stream_write (GDKout, &e_, 1, 1);

    stream_write (GDKout, seq_start, strlen (seq_start), 1);

    return SUCCESS;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static bool
typed_xml_seqEnd (XqueryCtx* ctx)
{
    (void)ctx;

    char *seq_end = "</result:sequence>";
    stream_write (GDKout, seq_end, strlen (seq_end), 1);
    stream_write (GDKout, "\n", 1, 1);

    return SUCCESS;
}

static bool
typed_xml_seqItemStart (XqueryCtx* ctx, int kind)
{
    char *item_start;
    (void)ctx;

    switch (XTRACT_KIND(kind)) {
        case BOOL:
            item_start = "<result:atomic-value xsi:type=\"xs:boolean\">";
            break;
        case INT:
            item_start = "<result:atomic-value xsi:type=\"xs:integer\">";
            break;
        case DEC:
            item_start = "<result:atomic-value xsi:type=\"xs:decimal\">";
            break;
        case DBL:
            item_start = "<result:atomic-value xsi:type=\"xs:double\">";
            break;
        case STR:
            item_start = "<result:atomic-value xsi:type=\"xs:string\">";
            break;
        case U_A:
            item_start = "<result:atomic-value xmlns:xdt="
                         "\"http://www.w3.org/2005/xpath-datatypes\" "
                         "xsi:type=\"xdt:untypedAtomic\">";
            break;
        case ELEM:
        {   
            /* extract node kind from overloaded kind */
            switch ((char) XTRACT_CONT(kind)) {
                case 0 /* ELEMENT */:
                    item_start = "<result:element>";
                    break;
                case 1 /* TEXT */:
                    item_start = "<result:text>";
                    break;
                case 2 /* COMMENT */:
                    item_start = "<result:comment>";
                    break;
                case 3 /* PI */:
                    item_start = "<result:processing-instruction>";
                    break;
                case 4 /* DOCUMENT */:
                    item_start = "<result:document>";
                    break;
                default:
                    return PROBLEM;
                    break;
            }
        }   break;
        case ATTR:
            item_start = "<result:attribute";
            break;
        default:
            return PROBLEM;
            break;
    }
    stream_write (GDKout, item_start, strlen (item_start), 1);

    return SUCCESS;
}

static bool
typed_xml_seqItemEnd (XqueryCtx* ctx, int kind)
{
    char *item_end;
    (void)ctx;

    switch (XTRACT_KIND(kind)) {
        case BOOL:
        case INT:
        case DEC:
        case DBL:
        case STR:
        case U_A:
            item_end = "</result:atomic-value>";
            break;
        case ELEM:
        {   
            /* extract node kind from overloaded kind */
            switch (XTRACT_CONT(kind)) {
                case 0 /* ELEMENT */:
                    item_end = "</result:element>";
                    break;
                case 1 /* TEXT */:
                    item_end = "</result:text>";
                    break;
                case 2 /* COMMENT */:
                    item_end = "</result:comment>";
                    break;
                case 3 /* PI */:
                    item_end = "</result:processing-instruction>";
                    break;
                case 4 /* DOCUMENT */:
                    item_end = "</result:document>";
                    break;
                default:
                    return PROBLEM;
                    break;
            }
        }   break;
        case ATTR:
            item_end = "/>";
            break;
        default:
            return PROBLEM;
            break;
    }
    stream_write (GDKout, item_end, strlen (item_end), 1);

    return SUCCESS;
}

/**
 *
 * item sequence handlers for the soap XML output format
 *
 */
 
static bool
soap_xml_seqItemStart (XqueryCtx* ctx, int kind)
{
    char *item_start;
    (void)ctx;

    switch (XTRACT_KIND(kind)) {
        case BOOL:
            item_start = "<xs:boolean>";
            break;
        case INT:
            item_start = "<xs:integer>";
            break;
        case DEC:
        case DBL:
            item_start = "<xs:double>";
            break;
        case STR:
        case U_A:
            item_start = "<xs:string>";
            break;
        case ELEM:
            item_start = "<xs:anyNode>";
            break;
        case ATTR:
            item_start = "";
            break;
        default:
            return PROBLEM;
            break;
    }
    stream_write (GDKout, item_start, strlen (item_start), 1);

    return SUCCESS;
}

static bool
soap_xml_seqItemEnd (XqueryCtx* ctx, int kind)
{
    char *item_end;
    (void)ctx;

    switch (XTRACT_KIND(kind)) {
        case BOOL:
            item_end = "</xs:boolean>";
            break;
        case INT:
            item_end = "</xs:integer>";
            break;
        case DEC:
        case DBL:
            item_end = "</xs:double>";
            break;
        case STR:
        case U_A:
            item_end = "</xs:string>";
            break;
        case ELEM:
            item_end = "</xs:anyNode>";
            break;
        case ATTR:
            item_end = "";
            break;
        default:
            return PROBLEM;
            break;
    }
    stream_write (GDKout, item_end, strlen (item_end), 1);

    return SUCCESS;
}

static bool
soap_xml_seqItemSeparator (XqueryCtx* ctx, int kind1, int kind2)
{
    (void) ctx;
    (void) kind1;

    if (XTRACT_KIND(kind2) != ATTR)
        stream_write (GDKout, dflt_ws->newline, dflt_ws->nl_sz, 1);

    return SUCCESS;
}

/**
 *
 * item sequence handlers for the JDBC/XMLDB output format
 *
 */
 
/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static bool
seq_seqStart (XqueryCtx* ctx, int count)
{
    /* write SQL-ish header */
    stream_printf(GDKout,"&1 %d %d 1 %d\n", 
                  dflt_ws->id_sequence_counter++, count, count);
    stream_printf(GDKout,"# xquery_result\t# table_name\n");
    stream_printf(GDKout,"# xml\t# name\n");
    stream_printf(GDKout,"# varchar\t# type\n");
    stream_printf(GDKout,"# %d\t# length\n", 60);

    return SUCCESS;
}

static bool
seq_seqItemStart (XqueryCtx* ctx, int kind)
{
    (void)ctx;
    (void)kind;
    
    /* SQL-ish mode: write start of tuple and open string */
    stream_write (GDKout, "[ \"", 3, 1);

    return SUCCESS;
}

static bool
seq_seqItemEnd (XqueryCtx* ctx, int kind)
{
    (void)ctx;
    (void)kind;
    
    /* SQL-ish mode: write end of string and end of tuple */
    stream_printf(GDKout,"\"\t]\n");

    return SUCCESS;
}

/**
 *
 * Definitions of the structures containing the functions
 *
 */
struct serializeFunStruct dmSerializeFun = {
    "dm",
    dflt_init,
    dflt_cleanup,

    dflt_handle_startDocument,
    dflt_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    esc_seqEmitStr,
    dflt_seqEmitAttribute,
    dflt_seqEmitTextnode,

    dm_seqStart,
    null_complete_seqStart,
    dm_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    dm_seqItemSeparator
};

struct serializeFunStruct mapi_dmSerializeFun = {
    "dm mapi",
    mapi_init,
    dflt_cleanup,

    dflt_handle_startDocument,
    dflt_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    esc_seqEmitStr,
    dflt_seqEmitAttribute,
    dflt_seqEmitTextnode,

    dm_seqStart,
    null_complete_seqStart,
    dm_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    dm_seqItemSeparator
};

struct serializeFunStruct xmlSerializeFun = {
    "xml",
    dflt_init,
    dflt_cleanup,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    xml_seqStart,
    xml_complete_seqStart,
    xml_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    xml_seqItemSeparator
};

struct serializeFunStruct mapi_xmlSerializeFun = {
    "xml mapi",
    mapi_init,
    dflt_cleanup,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    xml_seqStart,
    xml_complete_seqStart,
    xml_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    xml_seqItemSeparator
};

struct serializeFunStruct typed_xmlSerializeFun = {
    "xml typed",
    dflt_init,
    dflt_cleanup,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    typed_xml_seqStart,
    null_complete_seqStart,
    typed_xml_seqEnd,
    typed_xml_seqItemStart,
    typed_xml_seqItemEnd,
    null_seqItemSeparator
};

struct serializeFunStruct mapi_typed_xmlSerializeFun = {
    "xml mapi typed",
    mapi_init,
    dflt_cleanup,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    typed_xml_seqStart,
    null_complete_seqStart,
    typed_xml_seqEnd,
    typed_xml_seqItemStart,
    typed_xml_seqItemEnd,
    null_seqItemSeparator
};

struct serializeFunStruct soap_xmlSerializeFun = {
    "soap xml",
    dflt_init,
    dflt_cleanup,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    xml_seqStart,
    xml_complete_seqStart,
    xml_seqEnd,
    soap_xml_seqItemStart,
    soap_xml_seqItemEnd,
    soap_xml_seqItemSeparator
};

struct serializeFunStruct mapi_soap_xmlSerializeFun = {
    "xml mapi soap",
    mapi_init,
    dflt_cleanup,

    null_handle_startDocument,
    null_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    dflt_seqEmitStr,
    dflt_handle_attribute,
    dflt_handle_characters,

    xml_seqStart,
    xml_complete_seqStart,
    xml_seqEnd,
    soap_xml_seqItemStart,
    soap_xml_seqItemEnd,
    soap_xml_seqItemSeparator
};

struct serializeFunStruct seqSerializeFun = {
    "seq",
    esc_init,
    dflt_cleanup,

    dflt_handle_startDocument,
    dflt_handle_endDocument,
    dflt_handle_startElement,
    dflt_handle_endElement,
    dflt_handle_characters,
    dflt_handle_ignorableWhitespace,
    dflt_handle_comment,
    dflt_handle_processingInstruction,

    dflt_complete_startElement,
    dflt_complete_startElementEmpty,
    dflt_handle_attribute,

    dflt_seqEmitBool,
    dflt_seqEmitInt,
    dflt_seqEmitDbl,
    esc_seqEmitStr,
    dflt_seqEmitAttribute,
    dflt_seqEmitTextnode,

    seq_seqStart,
    null_complete_seqStart,
    null_seqEnd,
    seq_seqItemStart,
    seq_seqItemEnd,
    null_seqItemSeparator
};

/* vim:set shiftwidth=4 expandtab: */
