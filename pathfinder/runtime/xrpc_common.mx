@/
Copyright Notice:
-----------------

The contents of this file are subject to the Pathfinder Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License.  You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
the License for the specific language governing rights and limitations
under the License.

The Original Code is the Pathfinder system.

The Original Code has initially been developed by the Database &
Information Systems Group at the University of Konstanz, Germany and
the Database Group at the Technische Universitaet Muenchen, Germany.
It is now maintained by the Database Systems Group at the Eberhard
Karls Universitaet Tuebingen, Germany.  Portions created by the
University of Konstanz, the Technische Universitaet Muenchen, and the
Universitaet Tuebingen are Copyright (C) 2000-2005 University of
Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
2008-2011 Eberhard Karls Universitaet Tuebingen, respectively.  All
Rights Reserved.
@
@' $Id$
@f xrpc_common
@a Ying Zhang
@t Includes header files, definitions shared by the XRPC server, XRPC client and serializer

@h
#ifndef XRPC_COMMON_H
#define XRPC_COMMON_H

/* HTTP defines */
#define XRPC_DOC_CALLBACK  "/xrpc/doc"
#define XRPC_ADM_CALLBACK  "/xrpc/admin"
#define XRPC_WSAT_CALLBACK "/xrpc/wsat"
#define XRPC_REQ_CALLBACK  "/xrpc"

#define ERR400 "400 Bad Request"
#define ERR403 "403 Forbidden"
#define ERR404 "404 Not Found"
#define ERR408 "408 Request Timeout"
#define ERR500 "500 Internal Server Error"
#define ERR504 "504 Gateway Timeout"

#define OUT_OF_MEM      "Internal Receiver Error: out-of memory"
#define NOT_WELL_FORMED "Request XML message not well-formed"
#define MAX_NR_PARAMS   1024

#define HTTP_200_OK\
    "HTTP/1.1 200 OK\r\n"\
    "Content-type: text/xml; charset=\"utf-8\"\r\n\r\n"

/* Namespaces */
#define MXQ_ADMIN   "http://monetdb.cwi.nl/XQuery/admin/"
#define SOAP_NS     "http://www.w3.org/2003/05/soap-envelope"
#define XDT_NS      "http://www.w3.org/2005/xpath-datatypes"
#define XS_NS       "http://www.w3.org/2001/XMLSchema"
#define XSI_NS      "http://www.w3.org/2001/XMLSchema-instance"
#define XRPC_NS     "http://monetdb.cwi.nl/XQuery"
#define XRPC_LOC    "http://monetdb.cwi.nl/XQuery/XRPC.xsd"
#define WSCOOR_NS   "http://docs.oasis-open.org/ws-tx/wscoor/2006/06"
#define WSAT_NS     "http://docs.oasis-open.org/ws-tx/wsat/2006/06"

#define XRPC_REQ_QN XRPC_NS"|request"
#define XRPC_RES_QN XRPC_NS"|response"

/* XRPC SOAP snippets */
#define SOAP_ENVELOPE\
    "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"\
    "<env:Envelope\n"\
    "  xmlns:env=\"" SOAP_NS "\"\n"\
    "  xmlns:xrpc=\"" XRPC_NS "\"\n"\
    "  xmlns:xdt=\"" XDT_NS "\" \n"\
    "  xmlns:xs=\"" XS_NS "\"\n"\
    "  xmlns:xsi=\"" XSI_NS "\"\n"\
    "  xsi:schemaLocation=\"" XRPC_NS " " XRPC_LOC "\">\n"

#define XRPC_WS_QID\
    " <xrpc:header xrpc:mode=\"%s\">\n"\
    "  <wscoor:CoordinationContext\n"\
    "   xmlns:wscoor=\""WSCOOR_NS"\"\n"\
    "   env:mustUnderstand=\"true\">\n"\
    "    <wscoor:Identifier>%s</wscoor:Identifier>\n"\
    "    <wscoor:Expires>"LLFMT"</wscoor:Expires>\n"\
    "    <wscoor:CoordinationType>" WSAT_NS "</wscoor:CoordinationType>\n"\
    "  </wscoor:CoordinationContext>\n"\
    " </xrpc:header>\n"

#define XRPC_REQ_BODY_OPEN\
    "<env:Body>\n"\
    " <xrpc:request\n"\
    "   xrpc:module=\"%s\"\n"\
    "   xrpc:location=\"%s\"\n"\
    "   xrpc:method=\"%s\"\n"\
    "   xrpc:arity=\""LLFMT"\"\n"\
    "   xrpc:iter-count=\""LLFMT"\"\n"\
    "   xrpc:updCall=\"%s\"\n"\
    "   xrpc:caller=\""
#define XRPC_REQ_BODY\
      XRPC_REQ_BODY_OPEN "%s:"LLFMT"\">\n"
#define XRPC_REQ_BODY_FIRST_CALLER\
      XRPC_REQ_BODY_OPEN "query\">\n"

#define XRPC_WSAT_REQ SOAP_ENVELOPE\
    "<env:Header>"\
      XRPC_WS_QID \
    "</env:Header>\n"\
    "<env:Body><wsat:%s/></env:Body>\n"\
    "</env:Envelope>"

#define XRPC_WSAT_RES SOAP_ENVELOPE\
    "<env:Header>\n"\
      XRPC_WS_QID \
    " <xrpc:participant>%s,%s:%s:%s,"LLFMT",%d</xrpc:participant>\n"\
    "</env:Header>\n"\
    "<env:Body><wsat:%s/></env:Body>\n"\
    "</env:Envelope>"

#define XRPC_RES_BODY\
    "<env:Body>\n"\
    " <xrpc:response\n"\
    "   xrpc:module=\"%s\"\n"\
    "   xrpc:method=\"%s\">\n"

#define XRPC_HTTP_CALL\
    "  <xrpc:call>"\
    "   <xrpc:sequence>"\
    "    <xrpc:atomic-value xsi:type=\"xs:string\">%s</xrpc:atomic-value>"\
    "   </xrpc:sequence>"\
    "  </xrpc:call>"

#define XRPC_PUT_CALL\
    "  <xrpc:call>"\
    "   <xrpc:sequence>"\
    "    <xrpc:atomic-value xsi:type=\"xs:string\">%s</xrpc:atomic-value>"\
    "   </xrpc:sequence>"\
    "   <xrpc:sequence>"\
    "    <xrpc:element>%s</xrpc:element>"\
    "   </xrpc:sequence>"\
    "  </xrpc:call>"

#define XRPC_REQ_FOOTER\
    " </xrpc:request>\n"\
    "</env:Body>\n"\
    "</env:Envelope>"

#ifndef HOST_NAME_MAX
#ifdef _POSIX_HOST_NAME_MAX
#define HOST_NAME_MAX _POSIX_HOST_NAME_MAX
#else 
#define HOST_NAME_MAX 255
#endif
#endif

typedef struct {
    char *qid;
    char *caller;
    lng seqnr;
    lng start;
    lng timeout;
    char *mode;
    char *module;
    char *method;
    char *location;
    int updCall;
    int hasNodeParam;
    size_t argc;
    size_t iterc;
    size_t nr_args;
    size_t max_args;
    lng **argcnt;
    int *argtpe;
    char **argval;
    lng partcnt;
    BAT *shredBAT;
} XRPCreq_t;

XRPCreq_t *XRPCreq_new(char *qid, char *caller,
        lng timeout, char *mode, char *module, char *method,
        char *location, int updCall, size_t iterc, size_t argc);
void XRPCreq_free(XRPCreq_t *req);
XRPCreq_t *xrpc_parse_message(char *err, int errlen, BAT *shredBAT,
        BAT *participants);

#endif /* XRPC_COMMON_H */

@c
#include "pf_config.h"
#include "pathfinder.h"
#include "xrpc_common.h"

XRPCreq_t *
XRPCreq_new(
        char *qid,
        char *caller,
        lng timeout,
        char *mode,
        char *module,
        char *method,
        char *location,
        int updCall,
        size_t iterc,
        size_t argc)
{
    size_t i = 0, j = 0;

    XRPCreq_t *req = (XRPCreq_t*) GDKmalloc(sizeof(XRPCreq_t));
    if(!req) return NULL;

    req->seqnr = 0;
    req->qid = qid;
    req->caller = caller;
    req->timeout = timeout;
    req->mode = mode;
    req->start = GDKusec();
    req->module = module;
    req->method = method;
    req->location = location;
    req->updCall = updCall;
    req->hasNodeParam = FALSE;
    req->argc = argc;
    req->iterc = iterc;
    req->nr_args = 0;
    req->max_args = iterc * (argc>0?argc:1) * MAX_NR_PARAMS;

    if (!(req->argcnt = (lng**) GDKmalloc(iterc * sizeof(lng*)))) {
        GDKfree(req);
        return NULL;
    }
    for (i = 0; i < iterc; i++) {
        /* we allocate _at least one_ argcnt for each parameter, so that
         * we have a place to note that a function has zero parameter */
        req->argcnt[i] = GDKmalloc((argc>0?argc:1) * sizeof(lng));
        if(!(req->argcnt[i])){
            for (j = 0; j < i; j++)
                GDKfree(req->argcnt[j]);
            GDKfree(req);
            return NULL;
        }
        req->argcnt[i][0] = 0;
        for (j = 1; j < argc; j++)
            req->argcnt[i][j] = 0;
    }

    req->argtpe = (int*) GDKmalloc(req->max_args * sizeof(int));
    if(!req->argtpe){
        for(i = 0; i < iterc; i++) GDKfree(req->argcnt[i]);
        GDKfree(req->argcnt);
        GDKfree(req);
        return NULL;
    }
   
    req->argval = (char**) GDKmalloc(req->max_args * sizeof(char *));
    if(!req->argval){
        for(i = 0; i < iterc; i++) GDKfree(req->argcnt[i]);
        GDKfree(req->argcnt);
        GDKfree(req->argtpe);
        GDKfree(req);
        return NULL;
    }

    return req;
}

void
XRPCreq_free(XRPCreq_t *req)
{
    size_t i = 0;

    if(req->qid) GDKfree(req->qid);
    for(i = 0; i < req->iterc; i++) GDKfree(req->argcnt[i]);
    GDKfree(req->argcnt);
    GDKfree(req->argtpe);
    GDKfree(req->argval);
    GDKfree(req);
}

static INLINE oid
skip_text_nodes(char *pre_kindT, oid pre, oid max) 
{
    while(pre < max && pre_kindT[pre] == TEXT) pre++;
    return pre; 
}

/* Convert string to long long int and store possible error message in
 * 'err'.  Calling function should always check 'err'.
 */
static lng
my_strtoll(
        char *err,
        int errlen,
        bte isSigned,
        char *val_ptr,
        char *attr_name)
{
    char *end_ptr = val_ptr;
    lng ret = strtoll(val_ptr, &end_ptr, 10);

    if(end_ptr == val_ptr){
        snprintf(err, errlen,
                "Invalid value (\"%s\") of numeric attribute \"%s\"",
                val_ptr, attr_name);
    } else if(ret < 0 && !isSigned){
        snprintf(err, errlen,
                "Invalid value (\"%s\") of numeric attribute \"%s\": "
                "should not be negative",
                val_ptr, attr_name);
    }
    return ret;
}

static int 
get_node_type(str typename) {
    if (strcmp(typename, XRPC_NS"|element") == 0)
        return XS_ELEMENT;
    if (strcmp(typename, XRPC_NS"|text") == 0)
        return XS_TEXT;
    if (strcmp(typename, XRPC_NS"|comment") == 0)
        return XS_COMMENT;
    if (strcmp(typename, XRPC_NS"|processing-instruction") == 0) 
        return XS_PI;
    if (strcmp(typename, XRPC_NS"|document") == 0)
        return XS_DOCUMENT;
    return -1;
} 

/**
 * @return PRE, or 0 if not found.
 */
static INLINE oid
get_pre_by_qname(
        str qname,
        oid start_pre,
        oid end_pre,
        oid *pre_propT,
        char *pre_kindT,
        BAT *qn_uri_loc)
{
    oid i;
    BUN bun = BUN_NONE;
    BATiter qn_uli = bat_iterator(qn_uri_loc);

    for (i = start_pre; i < end_pre; i++) {
        if (pre_kindT[i] == ELEMENT) {
            BUNfndVOID(bun, qn_uli, &(pre_propT[i]));
            if(bun != BUN_NONE && strcmp(BUNtail(qn_uli, bun), qname) == 0)
                return i;
        }
    }
    return 0;
}

XRPCreq_t *
xrpc_parse_message(
        char *err,
        int errlen,
        BAT *shredBAT,
        BAT *participants)
{
    XRPCreq_t *req = NULL, *res = NULL;
    char *msg = participants?XRPC_RES_QN:XRPC_REQ_QN;
    char *module = NULL, *method = NULL, *location = NULL;
    char *mode = NULL, *qid = NULL, *caller = "query";
    char *arity_str = NULL, *itercnt_str = NULL;
    char *pul = NULL, *val = NULL;
    int updCall = FALSE;
    lng timeout = 30000, argc = GDK_lng_min, iterc = -1, i = 0, j = 0, k = 0;

    BATiter shredBATi, prop_vali, qn_uli, qn_histi;
    BAT *pre_size = NULL, *pre_level = NULL, *pre_kind = NULL;
    BAT *qn_loc   = NULL, *qn_uri_loc = NULL, *qn_histo = NULL;
    BAT *prop_val = NULL,  *prop_text = NULL, *pre_prop = NULL;
    BAT *attr_own = NULL,  *attr_qn = NULL, *attr_prop = NULL;
    BAT *frag_root = NULL;
    /* Arrays holding the Tail values of some of the BATs above. */
    int   *pre_sizeT = NULL;
    char  *pre_levelT = NULL, *pre_kindT = NULL;
    char  *text_base = NULL; /* text base of prop_text tail values */
    oid   *attr_ownT = NULL, *attr_qnT = NULL, *attr_propT = NULL;
    oid   *pre_propT = NULL;
    var_t *prop_textT = NULL;

    oid msg_node_pre = 0, hdr_node_pre = 0, val_node_pre = 0;
    oid call_node_pre = 0,  seq_node_pre = 0,  tpe_node_pre = 0;
    oid next_call_node_pre = 0, next_seq_node_pre = 0, next_tpe_node_pre = 0;
    oid ao_ptr = 0; /* cursor in the attr_own bat */
    size_t nattrs = 0, nnodes = 0;
    
    /* We need to clean up the pre_size, pre_level, pre_prop and
     * pre_kind values between two node values, to prevent that
     * a node value is treated as part of the message */
    oid start_invalidate = 0; /* indicates from which node we should start with invalidation */
    char level_diff = 0; /* indicates how many levels each pre_level value of a node should be reduced. */

    shredBATi = bat_iterator(shredBAT);
@= getbat
    @1 = BATdescriptor(*(bat*)BUNtail(shredBATi,i+@2));
    if (@1 == NULL) {
        snprintf(err, errlen, "Shredded BAT @1 unavailable");
        goto cleanup;
    }
@c
    @:getbat(pre_size,PRE_SIZE)@
    @:getbat(pre_level,PRE_LEVEL)@
    @:getbat(pre_prop,PRE_PROP)@
    @:getbat(pre_kind,PRE_KIND)@
    @:getbat(prop_text,PROP_TEXT)@
    @:getbat(prop_val,PROP_VAL)@
    @:getbat(qn_uri_loc,QN_URI_LOC)@
    @:getbat(qn_histo,QN_HISTOGRAM)@
    @:getbat(qn_loc,QN_LOC)@
    @:getbat(frag_root,FRAG_ROOT)@
    @:getbat(attr_own,ATTR_OWN)@
    @:getbat(attr_qn,ATTR_QN)@
    @:getbat(attr_prop,ATTR_PROP)@

    prop_vali = bat_iterator(prop_val);
    qn_uli = bat_iterator(qn_uri_loc);
    qn_histi = bat_iterator(qn_histo);

    pre_sizeT  = (int*)  Tloc(pre_size, BUNfirst(pre_size));
    pre_levelT = (char*) Tloc(pre_level, BUNfirst(pre_level));
    pre_propT  = (oid*)  Tloc(pre_prop, BUNfirst(pre_prop));
    pre_kindT  = (char*) Tloc(pre_kind, BUNfirst(pre_kind));
    prop_textT = (var_t*)Tloc(prop_text, BUNfirst(prop_text));
    attr_ownT  = (oid*)  Tloc(attr_own, BUNfirst(attr_own));
    attr_qnT   = (oid*)  Tloc(attr_qn, BUNfirst(attr_qn));
    attr_propT = (oid*)  Tloc(attr_prop, BUNfirst(attr_prop));
    text_base  = prop_text->T->vheap->base;

    pre_level  = BATsetaccess(pre_level, BAT_WRITE);
    frag_root  = BATsetaccess(frag_root, BAT_APPEND);
    nattrs     = BATcount(attr_prop);
    nnodes     = BATcount(pre_size);

    /* get mode from the header (a bit hacked) */
    for(i=0; (size_t)i<nattrs; i++) {
        str s = (str) BUNtail(qn_uli, attr_qnT[i]);
        if (strcmp(s, XRPC_NS"|mode") == 0) {
            mode = (str) BUNtail(prop_vali, attr_propT[i]);
            break;
        }
    }

    i = BUNfirst(shredBAT);
    if (participants) {
        /* parse a SOAP header for participants (XRPC response case) */
        if ((hdr_node_pre = get_pre_by_qname(XRPC_NS"|participants",
                        msg_node_pre, msg_node_pre + pre_sizeT[msg_node_pre] + 1,
                        pre_propT, pre_kindT, qn_uri_loc)))
        {
            oid hdr_node_end = hdr_node_pre + pre_sizeT[hdr_node_pre];
            while(++hdr_node_pre <= hdr_node_end) {
                if (pre_kindT[hdr_node_pre] == ELEMENT) {
                    char *s = (char*) BUNtail(qn_uli, pre_propT[hdr_node_pre]);
                    if (strcmp(s, XRPC_NS"|participant") == 0) {
                        oid end_pre = hdr_node_pre + pre_sizeT[hdr_node_pre];
                        while(++hdr_node_pre <= end_pre) {
                            if (pre_kindT[hdr_node_pre] == TEXT) {
                                s = text_base + VarHeapVal(prop_textT, pre_propT[hdr_node_pre], prop_text->T->width);
                                BUNappend(participants, s, FALSE);
                            }
                        }
                    }
                }
            }
        }
    } else {
        /* parse a SOAP header for qid and timeout  (XRPC request case)*/
        if ((hdr_node_pre = get_pre_by_qname(WSCOOR_NS"|CoordinationContext",
                        msg_node_pre, msg_node_pre + pre_sizeT[msg_node_pre] + 1,
                        pre_propT, pre_kindT, qn_uri_loc)))
        {
            oid hdr_node_end = hdr_node_pre + pre_sizeT[hdr_node_pre];
            while(++hdr_node_pre <= hdr_node_end) {
                if (pre_kindT[hdr_node_pre] == ELEMENT) {
                    char *s = (char*) BUNtail(qn_uli, pre_propT[hdr_node_pre]);
                    int isqid = (strcmp(s, WSCOOR_NS"|Identifier") == 0);
                    if (isqid || strcmp(s, WSCOOR_NS"|Expires") == 0) {
                        oid end_pre = hdr_node_pre + pre_sizeT[hdr_node_pre];
                        while(++hdr_node_pre <= end_pre) {
                            if (pre_kindT[hdr_node_pre] == TEXT) {
                                s = text_base + VarHeapVal(prop_textT, pre_propT[hdr_node_pre], prop_text->T->width);
                                if (isqid) {
                                    qid = GDKstrdup(s);
                                } else {
                                    timeout = my_strtoll(err, errlen,
                                            FALSE, s, "timeout");
                                    if (*err) goto cleanup;
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    if (!(msg_node_pre = get_pre_by_qname(msg, 2, nnodes, pre_propT, pre_kindT, qn_uri_loc))) {
        snprintf(err, errlen, "%s: %s %s", NOT_WELL_FORMED,
                "could not find element", msg);
        goto cleanup;
    }
    call_node_pre = msg_node_pre;

    /* analyze the XRPC request information */
    if (participants) {
        argc = 1; /* responses have only a out param (argc=1) ie a result */
    } else {
        /* more XRPC request message parsing: the XRPC Request in the
         * body contains module/method etc info */
        while(ao_ptr < nattrs && attr_ownT[ao_ptr] < msg_node_pre) ao_ptr++;
        while(ao_ptr < nattrs && attr_ownT[ao_ptr] == msg_node_pre) {
            pul = (char*) BUNtail(qn_uli, BUNfirst(qn_uri_loc) + attr_qnT[ao_ptr]);
            val = (char*) BUNtail(prop_vali, BUNfirst(prop_val) + attr_propT[ao_ptr]);
            if(strcmp(pul, XRPC_NS"|module") == 0) {
                module = val;
            } else if(strcmp(pul, XRPC_NS"|location") == 0) {
                location = val;
            } else if(strcmp(pul, XRPC_NS"|method") == 0) {
                method = val;
            } else if(strcmp(pul, XRPC_NS"|arity") == 0) {
                arity_str = val;
            } else if(strcmp(pul, XRPC_NS"|iter-count") == 0) {
                itercnt_str = val;
            } else if(strcmp(pul, XRPC_NS"|caller") == 0) {
                caller = val;
            } else if(strcmp(pul,XRPC_NS"|updCall") == 0) {
                if((val[0] == 't' && val[1] == 'r' && val[2] == 'u' && val[3] == 'e') ||
                   (val[0] == 'T' && val[1] == 'r' && val[2] == 'u' && val[3] == 'e') ||
                   (val[0] == 'T' && val[1] == 'R' && val[2] == 'U' && val[3] == 'E'))
                updCall = TRUE;
            }
            ao_ptr++;
        }
        if(!(module && location && method && arity_str)) {
            snprintf(err, errlen, "The %s element didn't contain the "
                "required attributes.", msg);
            goto cleanup;
        }
        if(itercnt_str){
            iterc = my_strtoll(err, errlen, FALSE, itercnt_str,
                    "iter-count");
            if(*err) goto cleanup;
        }

        call_node_pre = get_pre_by_qname(XRPC_NS"|call", MAX(call_node_pre,msg_node_pre),
            msg_node_pre + pre_sizeT[msg_node_pre] + 1,
            pre_propT, pre_kindT, qn_uri_loc);

        argc = my_strtoll(err, errlen, FALSE, arity_str, "arity");
        if (*err) goto cleanup;
    }
    if (iterc == -1) {
        /* if no iterc was found in the request (and always for XRPC
         * responses), just count sequence elements */
        BUN p = BUNfnd(BATmirror(qn_uri_loc), XRPC_NS"|sequence");
        iterc = (p == BUN_NONE)?1:(*(lng*) BUNtail(qn_histi, p) / argc);
    }

    /* the req struct contains all parsed data (we use it also for
     * response messages) */ 
    if(!(req = XRPCreq_new(qid, caller, timeout, mode, module, method, location, updCall, iterc, argc))) {
        snprintf(err, errlen, OUT_OF_MEM);
        goto cleanup;
    }

    /* Fill the arrays 'req->argcnt', 'req->argval', 'req->argtpe' */
    /* i: index in xrpc:call; j: index of xrpc:sequence per xrpc:call */
    next_call_node_pre = call_node_pre;
    for(i = 0; 
            next_call_node_pre > 0 && next_call_node_pre < nnodes && i < iterc; 
                call_node_pre = next_call_node_pre) 
    {
        /* end of current call node */
        next_call_node_pre = call_node_pre + pre_sizeT[call_node_pre] + 1;

        for(seq_node_pre = skip_text_nodes(pre_kindT, call_node_pre + 1, next_call_node_pre), 
            next_seq_node_pre = seq_node_pre, j = 0;
                next_seq_node_pre > 0 && next_seq_node_pre < next_call_node_pre && j < argc;
                    seq_node_pre = next_seq_node_pre) 
        {
            /* end of current sequence node */
            next_seq_node_pre = seq_node_pre + pre_sizeT[seq_node_pre] + 1;
       
            for(tpe_node_pre = skip_text_nodes(pre_kindT, seq_node_pre+1, next_seq_node_pre),
                    next_tpe_node_pre = tpe_node_pre, k=0;
                next_tpe_node_pre > 0 && next_tpe_node_pre < next_seq_node_pre;
                tpe_node_pre = next_tpe_node_pre, k++) 
            {
                /* end of current xrpc:<type> node */
                next_tpe_node_pre = tpe_node_pre + pre_sizeT[tpe_node_pre]+1;

                
                /* advance our cursor in attr_own */
                while(ao_ptr < nattrs && attr_ownT[ao_ptr] < tpe_node_pre) ao_ptr++;

                if (req->nr_args == req->max_args) {
                    req->max_args *= 2;
                    char **bptr = GDKrealloc(req->argval, req->max_args * sizeof(char*));
                    if (!bptr) {
                        snprintf(err, errlen, OUT_OF_MEM);
                        goto cleanup;
                    }
                    req->argval = bptr;

                    if(!(bptr = GDKrealloc(req->argtpe, req->max_args * sizeof(int*)))) {
                        snprintf(err, errlen, OUT_OF_MEM);
                        goto cleanup;
                    }
                    req->argtpe = (int*) bptr;
                }

                pul = (char*) BUNtail(qn_uli, pre_propT[tpe_node_pre]);
                if (strcmp(pul, XRPC_NS"|atomic-value") == 0) {
                    int tpe = -1;
                    while(ao_ptr < nattrs && attr_ownT[ao_ptr] == tpe_node_pre) {
                        if(strcmp((char*)BUNtail(qn_uli, BUNfirst(qn_uri_loc)+attr_qnT[ao_ptr]),
                                    XSI_NS"|type") == 0) {
                            tpe = xquery_typenr((char*)BUNtail(prop_vali, BUNfirst(prop_val)+attr_propT[ao_ptr]));
                        }
                        ao_ptr++;
                    }
                    if(tpe < 0){
                        snprintf(err, errlen, "XRPC %s: iter["LLFMT"]/param["LLFMT"]/value["LLFMT"]"
                                " does not have an \""XSI_NS":type\"", msg+strlen(XRPC_NS)+1, i, j, k);
                        goto cleanup;
                    }
                    req->argtpe[req->nr_args] = tpe;
                    val_node_pre = tpe_node_pre + 1;
                    if(pre_sizeT[tpe_node_pre] != 1 || pre_kindT[val_node_pre] != TEXT) {
                        snprintf(err, errlen, "XRPC %s: iter["LLFMT"]/param["LLFMT"]/value["LLFMT"]"
                                "is expected to have a simple value", msg+strlen(XRPC_NS)+1, i, j, k);
                        goto cleanup;
                    }
                    req->argval[req->nr_args] = text_base + VarHeapVal(prop_textT, pre_propT[val_node_pre], prop_text->T->width);
                } else if (strcmp(pul, XRPC_NS"|attribute") == 0) {
                    while(ao_ptr < nattrs && attr_ownT[ao_ptr] < tpe_node_pre) ao_ptr++;
                    if (attr_ownT[ao_ptr] == tpe_node_pre) {
                        val_node_pre = ao_ptr;
                    } else {
                        snprintf(err, errlen, "XRPC %s: "
                                "iter["LLFMT"]/param["LLFMT"]/value["LLFMT"] "
                                "of type "XRPC_NS":attribute is expected to have a single attribute",
                                msg+strlen(XRPC_NS)+1, i, j, k);
                        goto cleanup;
                    }
                    req->hasNodeParam = TRUE;
                    req->argtpe[req->nr_args] = XS_ATTRIBUTE;
                    req->argval[req->nr_args] = (char*) (size_t) val_node_pre; 
                } else {
                    req->argtpe[req->nr_args] = get_node_type(pul);
                    if (req->argtpe[req->nr_args] == XS_DOCUMENT) {
                        /* Find the first next ELEMENT, which should be
                         * the root node of the document, and then
                         * (mis)use its previous PRE als DOC_ROOT */
                        val_node_pre = pre_sizeT[tpe_node_pre] == 0 ?
                            tpe_node_pre :
                            skip_text_nodes(pre_kindT, tpe_node_pre + 1,
                                    next_tpe_node_pre) - 1;
                        pre_kindT[val_node_pre] = 4;
                        pre_propT[val_node_pre] = oid_nil;
                    } else if (req->argtpe[req->nr_args] < 0) {
                        snprintf(err, errlen, "XRPC %s: "
                                "iter["LLFMT"]/param["LLFMT"]/value["LLFMT"] "
                                "contains unsupported type: %s\n",
                                msg+strlen(XRPC_NS)+1, i, j, k, pul);
                        goto cleanup;
                    } else {
                        val_node_pre = tpe_node_pre + 1;
                        if (req->argtpe[req->nr_args] != XS_TEXT)
                            val_node_pre = skip_text_nodes(pre_kindT,
                                    val_node_pre, next_tpe_node_pre);
                    }
                    req->argval[req->nr_args] = (char*) (size_t) val_node_pre;
                    frag_root = BUNappend(frag_root, (ptr)&val_node_pre, TRUE);
                    req->hasNodeParam = TRUE;

                    /* reassign level values for the ELEM nodes */
                    level_diff = pre_levelT[val_node_pre];
                    if(req->argtpe[req->nr_args] == XS_DOCUMENT)
                        level_diff++;
                    oid l = val_node_pre;
                    for( ; l <= (val_node_pre + pre_sizeT[val_node_pre]); l++){
                        pre_levelT[l] -= level_diff;
                    }
                    for (l = start_invalidate; l < val_node_pre; l++) {
                        pre_levelT[l] = -3;
                        pre_sizeT[l] = 0;
                    }
                    start_invalidate = val_node_pre + pre_sizeT[val_node_pre] + 1;
                }
                req->argcnt[i][j]++;
                req->nr_args++;
                next_tpe_node_pre = skip_text_nodes(pre_kindT, next_tpe_node_pre, next_seq_node_pre);
            } /* end loop 'xrpc:<type>' */
            next_seq_node_pre = skip_text_nodes(pre_kindT, next_seq_node_pre, next_call_node_pre);
            /* if this is a response messsage, we increase it itercnt (its argc
             * is always 1, i.e. j=0), otherwise, we increase its argc (i.e. j++) */
            if(participants) i++; else j++;
        } /* end loop 'xrpc:sequence' */
        next_call_node_pre = skip_text_nodes(pre_kindT, next_call_node_pre, nnodes);
        /* if this is a request message, we increase its itercnt here */
        if(!participants) i++;
    } /* end loop 'xrpc:call' */
    frag_root = BATsetaccess(frag_root, BAT_READ);
    res = req; req = NULL;
@= delbat
    if (@1) BBPunfix(@1->batCacheid);
@c
cleanup:
    if (req) XRPCreq_free(req);
    @:delbat(pre_size)@
    @:delbat(pre_level)@
    @:delbat(pre_prop)@
    @:delbat(pre_kind)@
    @:delbat(prop_text)@
    @:delbat(prop_val)@
    @:delbat(qn_uri_loc)@
    @:delbat(qn_loc)@
    @:delbat(qn_histo)@
    @:delbat(frag_root)@
    @:delbat(attr_own)@
    @:delbat(attr_qn)@
    @:delbat(attr_prop)@
    return res;
}

