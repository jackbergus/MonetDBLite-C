@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2006 University of Konstanz.  All Rights Reserved.
@'
@' $Id$
@'

@f xquery_rpc
@a Ying Zhang

@t MIL primitives to support the RPC extension for XQuery using HTTP connection

@* Introduction
This module provides new MIL primitives to support remote XQuery execution
using HTTP connection on top of MonetDB within the "Pathfinder" project.
@
@* Module Definition
@m
.MODULE xquery_rpc;

.USE pathfinder;
.USE pf_support;
.USE url;

@- HTTP server function(s)
@m
.COMMAND httpd_start(int port) : void = CMDhttpd_start;
"Start the HTTP server for RPC calls on the specified port."

@- HTTP client function(s)
@m
.COMMAND http_post(
        str location,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        BAT[void, bat] ws,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[oid, bat] = CMDhttp_post;
"Create and send a RPC request message to the specified destination"

.PRELUDE = xquery_rpc_prelude;
.EPILOGUE = xquery_rpc_epilogue;

.END xquery_rpc;

@mil
PROC rpc_receiver_start(int port) : void {
    fork(httpd_start(port));
}
ADDHELP("rpc_receiver_start", "zhang", "November 2005",
"DESCRIPTION:\n\
Start receiver for RPC calls on the specified port",
"xquery_rpc");

PROC rpc_receiver_start() : void {
    rpc_receiver_start( int(monet_environment.find("pf_httpd_port")) );
}
ADDHELP("rpc_receiver_start", "zhang", "November 2005",
"DESCRIPTION:\n\
Start receiver for RPC calls on the default port 8080",
"xquery_rpc");

PROC rpc_client(
        str local_name,
        str location,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        BAT[void, bat] ws,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : oid {

    var rpcres := http_post(location, rpc_module, rpc_uri, rpc_method, ws, 
                            fun_vid,    fun_iter,   fun_item,   fun_kind,
                            int_values, dbl_values, dec_values, str_values);

    var docBAT := bat(str,bat,WS_SIZE);
    var height := index_doc(rpcres,docBAT);
    return add_docbat(ws, docBAT, local_name, TEMP_DOC, oid(nil), height);
}
ADDHELP("rpc_client", "zhang", "November 2005",
"DESCRIPTION:\n\
Send a RPC request to the destination \"location\", save the reults in the WorkingSet and return the fragment-id of the new added document",
"xquery_rpc");

@h
#ifndef XQUERY_RPC_H
#define XQUERY_RPC_H

#include "pathfinder.h"

/* BAT related functions */
#include <gdk.h>
/* escape_url() */
#include <url.h>
/* stream functions */
#include <stream.h>
#include <time.h>

#ifdef _WIN32   /* Windows specific */
    #include <winsock.h>
    #define snprintf _snprintf
    #ifndef __MINGW32__
        #pragma comment(lib, "ws2_32")
    #endif
#else           /* UNIX specific */
    #include <sys/select.h>
    #include <sys/types.h>	/* used by socket */
    #include <sys/socket.h>
    #include <unistd.h>
    #include <netinet/in.h> /* hton and ntoh */
    #include <arpa/inet.h>  /* dotted IP addr to and from 32-bits int */
    #include <netdb.h>		/* convert domain names into IP addr */
    #include <errno.h>
    #include <ctype.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h> /* Functions to handle variable argument lists */

/* CMDshred2bats() and xquery_print_result_main() */
#include "pf_support.proto.h"
#include "shttpd.h"

#define MXQ_SIGNATURE "signature\01http://monetdb.cwi.nl/xquery/rpc"
#define MXQ_TYPE "type\01http://monetdb.cwi.nl/xquery/rpc"

#define TEXT        1
#define ELEMENT     0
#define MAXPARAMS   32
#define HTTP_PORT   8080
#define HTTPD_FUNC  "/xquery_rpc"

/* Used by the http_post client */
#define MIN_RESPONSE_SIZE       19
#define MAX_BUF_SIZE            1024*1024 /* MUST be the same as 'IO_MAX' in shttpd.c */
#define MAX_POST_HEADER_SIZE    1024
#define NR_RETRIES              3 /* #retries to connect to the RPC receiver */

#define str2buf(b, str)             \
    { b->pos += snprintf((b->buf + b->pos), (b->len - b->pos), str); }

#define value2buf(b, len, strptr, fun_item, off, i, v_type, v_cont, begin_tag, end_tag) \
    {                                                                                   \
    str2buf(b, begin_tag);                                                              \
    len = b->len - b->pos;                                                              \
    strptr = b->buf + b->pos;                                                           \
    i = *(int*)BUNtail(fun_item, BUNptr(fun_item, off));                                \
    b->pos += BATatoms[v_type].atomToStr(&strptr, &len, BUNptr(v_cont, i));             \
    str2buf(b, end_tag);                                                                \
    }

#define cleanup(obj, bit)           \
    if (obj) {                      \
        stream_close(obj);          \
        stream_destroy(obj);        \
        if (bit == 1) sock = -1;    \
    }

#define myfree(ary, i, max)         \
    if (ary) {                      \
        for(i = 0; i < max; i++)    \
            GDKfree(ary[i]);        \
        GDKfree(ary);               \
    }

/* To prevent start the HTTP server twice */
int rpc_receiver_running = 0;

#endif /* XQUERY_RPC_H */

@c
#include "xquery_rpc.h"

/* Create a HTTP client socket.
 * Returns the socket if succeeded, -1 otherwise.
 */
static int setup_connection(str location, int port, int nr_retries) {
    int i, ret, sock;
    in_addr_t addr;
    struct sockaddr_in sockaddr;
    struct hostent *resolv = NULL;

    errno = 0;
    if (isdigit((int)location[0])) {
        if ((i = inet_addr(location)) < 0) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", location);
            if (errno) GDKerror("setup_connection: %s\n", strerror(errno));
            return -1;
        }
        addr = (in_addr_t) i;
    } else {
        if (!(resolv = gethostbyname(location))) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", location);
            if (errno) GDKerror("setup_connection: %s\n", strerror(errno));
            return -1;
        }
        addr = ((struct in_addr *)resolv->h_addr_list[0])->s_addr;
    }

    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port   = htons(port);
    sockaddr.sin_addr.s_addr = addr;
    memset(&(sockaddr.sin_zero), '\0', 8);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        GDKerror("setup_connection: failed to create socket\n");
        return -1;
    }

    ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    for (i = 0; i < nr_retries && ret < 0; i++) {
        sleep(1);
        ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    }
       
    if (ret < 0) {
        GDKerror("setup_connection: could not setup connection with "
                "%s:%d\n", location, port);
        close(sock);
        return -1;
    }
    return sock;
}

/* Used by the RPC receiver to send an error message to the RPC sender.
 * The error message is sent in the format of a SOAP FAULT message.
 */
static void send_error(stream *out, bit p_body, char* http_err, char *soapcodev, char *errstr){
    if (p_body) {
        stream_printf(out, "HTTP/1.1 %s\r\n"
                "Content-Type: application/soap+xml; charset=\"utf-8\"\r\n\r\n"
                "<?xml version='1.0' ?>\n"
                "<env:Envelope\n"
                "    xmlns:env=\"http://www.w3.org/2003/05/soap-envelope\">\n"
                "  <env:Body>\n",
                http_err);
    }

    stream_printf(out,
            "    <env:Fault>\n"
            "      <env:Code>\n"
            "        <env:Value>\n"
            "          %s\n"
            "        </env:Value>\n"
            "      </env:Code>\n"
            "      <env:Reason>\n"
            "        <env:Text xml:lang=\"en\">\n"
            "          %s\n"
            "        </env:Text>\n"
            "      </env:Reason>\n"
            "    </env:Fault>\n"
            "  </env:Body>\n"
            "</env:Envelope>\n",
            soapcodev, errstr);
}

/* Calculate the number of nodes which has the name "node_name", within
 * the range 'start_pre' and 'end_pre' (incl.). */
static int count_node(BAT *shredBAT, char *node_name, int start_pre, int end_pre){
    static int first;       /* Since the values of these variables are always */
    static oid *pre_prop;   /* the same, we use 'static' here to prevent the  */
    static char *pre_kind;  /* values of these variables being retrieved at   */
    static BAT *qn_loc;     /* every call to this function */

    int i, nr = 0;
    char *qname;

    assert(start_pre > 0);
   
    first    = BUNindex(shredBAT, BUNfirst(shredBAT));
    pre_prop = (oid*) BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+PRE_PROP))));
    pre_kind = (char*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+PRE_KIND))));
    qn_loc   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+QN_LOC)));

    for (i = start_pre; i <= end_pre; i++) {
        if (pre_kind[i] == ELEMENT) {
            qname = BUNtail(qn_loc, BUNfnd(qn_loc, &(pre_prop[i])));
            if (strcmp(qname, node_name) == 0)
                nr++;
        }
    }
    return nr;
}

/* Find the first node between 'start_pre' and 'end_pre' (incl.), which
 * kind is 'ELEMENT'.
 * Return the 'pre' value of this node.
 * Return 0 if such node can not be found. */
static oid get_elem_pre(BAT *shredBAT, int start_pre, int end_pre){
    static int first;   /* values of 'first' and 'kind' are stable */
    static char *pre_kind;
    int i;

    assert(start_pre > 0 && end_pre >= start_pre);
   
    first    = BUNindex(shredBAT, BUNfirst(shredBAT));
    pre_kind = (char*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+PRE_KIND))));

    for (i = start_pre; i <= end_pre; i++) {
        if (pre_kind[i] == ELEMENT)
            return i;
    }
    return 0;
}

/* Given a node name, find the 'pre' value of the node given within the range
 * 'start_pre' and 'end_pre' (incl.).
 * Return 0 if such node can not be found. */
static oid get_node_pre(BAT *shredBAT, char *node_name, int start_pre, int end_pre){
    static int first;   /* Since the values of these variables are always */
    static oid *pre_prop;   /* the same, we use 'static' here to prevent the  */
    static char *pre_kind;  /* values of these variables being retrieved at   */
    static BAT *qn_loc; /* every call to this function */

    int i;
    char *qname;

    assert(start_pre > 0 && end_pre >= start_pre);
   
    first    = BUNindex(shredBAT, BUNfirst(shredBAT));
    pre_prop = (oid*) BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+PRE_PROP))));
    pre_kind = (char*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+PRE_KIND))));
    qn_loc   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+QN_LOC)));

    for (i = start_pre; i <= end_pre; i++) {
        if (pre_kind[i] == ELEMENT) {
            qname = BUNtail(qn_loc, BUNfnd(qn_loc, &(pre_prop[i])));
            if (strcmp(qname, node_name) == 0)
                return i;
        }
    }
    return 0;
}

/* Find the value of the attribute 'attrname', which is owned by the
 * node with the given 'pre' value.
 * NB: DO NOT free the string returned by this function!!!
 */
static char* find_attribute(BAT *shredBAT, char* attrname, oid pre){
    static size_t nattrs;
    static int first;
    static oid *attr_own, *attr_qn, *attr_prop;
    static BAT *qn_loc, *prop_val;

    oid qn = oid_nil;
    size_t i;
    BUN p;

    first    = BUNindex(shredBAT, BUNfirst(shredBAT));
    qn_loc   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+QN_LOC))   );
    prop_val = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+PROP_VAL)) );

    attr_own  = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+ATTR_OWN) )));
    attr_qn   = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+ATTR_QN)  )));
    attr_prop = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+ATTR_PROP))));

    /* Find 'attrname' in the tail of 'qn_loc' */
    p = BUNfnd(BATmirror(qn_loc), attrname);
    /* Get the position of 'attrname' in 'qn_loc' */
    if (p) qn = *(oid*) BUNhead(qn_loc, p);
    else return NULL;

    /* try to find the attribute value */
    nattrs = BATcount(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+ATTR_PROP))));
    for (i = 0; i < nattrs; i++) {
        if (attr_own[i] > pre) return NULL;
        if (attr_own[i] == pre && attr_qn[i] == qn) {
                first = BUNindex(prop_val, BUNfirst(prop_val)) + attr_prop[i];
                return (char*) BUNtail(prop_val, BUNptr(prop_val, first));
        }
    }
    return NULL;
}

/* Given the pre value of a type node, return the name of the type node as a
 * string in the form "prefix:loc" */
static char* get_type(stream *out, BAT *shredBAT, oid tnode_pre){
    static int first;
    static BAT *qn_loc, *qn_prefix;
    static oid *pre_prop;

    char *prefix, *loc, *res;
    char errstr[1024];
    int l, p;
    
    first = BUNindex(shredBAT, BUNfirst(shredBAT));
    pre_prop = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+PRE_PROP))));

    qn_prefix = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+QN_PREFIX)));
    qn_loc    = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,first+QN_LOC))   );

    first  = BUNindex(qn_prefix, BUNfirst(qn_prefix)) + tnode_pre;
    prefix = (char*) BUNtail(qn_prefix, BUNptr(qn_prefix, pre_prop[tnode_pre]));
    first  = BUNindex(qn_loc, BUNfirst(qn_loc)) + tnode_pre;
    loc    = (char*) BUNtail(qn_loc, BUNptr(qn_loc, pre_prop[tnode_pre]));

    l = strlen(loc);
    p = strlen(prefix);
    res = GDKmalloc(p + l + 2);
    if (!res) {
        snprintf(errstr, 1024, "Receiver internal error: not enough memory");
        send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
        return NULL;
    }
    strncpy(res, prefix, p);
    res[p]=':';
    strncpy((res + p + 1), loc, l);
    res[p+l+1] = '\0';
    return res;
}

static int handle_rpc_request(struct shttpd_callback_arg *arg) {
    int i = 0, j = 0, k = 0, off = 0, sock = -1, retval = GDK_FAIL;
    char *strptr = NULL, *req_msg = NULL;
    char *module = NULL, *uri = NULL, *method = NULL;
    char errstr[1024];
    stream *out = NULL;

    /* pointers to the temporarily shredded BATs and to the values in
     * shredBAT */
    BAT *shredBAT = NULL, *ws_frag = NULL;
    int *pre_size = NULL;
    char *pre_level = NULL, *pre_kind = NULL, *text_base = NULL;
    oid *pre_prop = NULL;
    var_t *prop_text = NULL;

    /* indecates from which node we should start with invalidate the
     * pre_level and the pre_size values */
    oid start_invalidate = 0;

    /* used for invalidation of the pre_level and the pre_size values */
    unsigned int l = 0, level_diff = 0, total_size;

    oid pre = 0, pnode_pre = 0, inode_pre = 0, tnode_pre = 0, vnode_pre = 0, next_frag = 0;

    /* used to save the pre_sizes of some nodes, before the node's
     * pre_size value is overwritten. */
    int root_size = 0, pnode_size = 0, inode_size = 0, tnode_size = 0;

    int iterc = 0, argc = 0;
    int **argcnt = NULL;    /* #items eash param/iter contains */
    str *argval = NULL;     /* Stores all actual values sequetially. */
    str *argtpe = NULL;     /* XQuery type of each argval */
    int nr_args = 0;      /* #values arg_val currently contains */
    int max_args = 0;    /* max #items in "argval", doubled if necessary */

    THRnew(MT_getpid(), "rpc_req_handler");

    /* Create our own output stream for further data transfer. */
    sock = shttpd_get_socket(arg);
    if (!(out = socket_wastream(sock, "rpc_response"))) {
        GDKerror("handle_rpc_request: failed to create socket_wastream for socket %d", sock);
        close(sock);
        return GDK_FAIL;
    }

    /* Retrieve the whole received RPC request message, and remove the
     * first line of the message, so that the messgae we pass to
     * CMDshred2bats starts directly with the envelope tag. */
    req_msg = shttpd_get_msg(arg);
    strptr = req_msg + strlen("<?xml"); /* skip "<?xml" */
    if ((strstr(req_msg, "<?xml") != req_msg) ||
        (strptr = strchr(strptr, (int)'<')) == NULL) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
                "XQuery RPC request: bad XML structure\n");
    }
/*
printf("\n=== DEBUG MSG: RPC request RECEIVED ======\n%s"
       "=== END DEBUG MSG: RPC request RECEIVED ===\n\n", strptr);
*/
    if ((CMDshred2bats(&shredBAT, "", strptr, "")  == GDK_FAIL)) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
                "XQuery RPC request: bad XML structure, could not shred\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }

    off       = BUNindex(shredBAT,BUNfirst(shredBAT));
    pre_size  = (int *) BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_SIZE))));
    pre_level = (char *)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_LEVEL))));
    pre_prop  = (oid *) BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_PROP))));
    pre_kind  = (char *)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_KIND))));
    prop_text = (var_t*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PROP_TEXT))));
    text_base = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT, off+PROP_TEXT)))->theap->base;
    ws_frag   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+WS_FRAG)));
    total_size = BATcount(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_SIZE))));

    /* There are at least two nodes before "SoapRpcRequest", namely
     * "Envelope" and "Body" (a "Header" node is optional). There are at
     * least two nodes after "SoapRpcRequest", namely "iter" and
     * "param". */
    if (!(pre = get_node_pre(shredBAT, "XQueryRpcRequest", 2, (pre_size[0] - 2)))) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
                "XQuery RPC request must have a \"XQueryRpcRequest\" tag\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    if ((module = find_attribute(shredBAT, "module", pre)) == NULL) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
            "XQuery RPC request: \"XQueryRpcRquest\" tag does not have a \"module\" attribute.\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    if ((uri = find_attribute(shredBAT, "uri", pre)) == NULL) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
            "XQuery RPC request: \"XQueryRpcRquest\" tag does not have a \"uri\" attribute.\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    if ((method = find_attribute(shredBAT, "method", pre)) == NULL) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
            "XQuery RPC request: \"SoapRpcRquest\" tag does not have a \"method\" attribute.\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }

    /* Calculate the number of iterations */
    iterc = count_node(shredBAT, "iter", (pre+1), pre_size[0]);
    if (iterc == 0) {
        snprintf(errstr, 1024, "XQuery RPC request [%s:%s]: should have at "
                "least one <iter> tag.\n", module, method);
        send_error(out, 1, "404 Bad Request", "env:Sender", errstr);
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    /* Calculate the number of parameters */
    /* FIXME: we now just assume each iteration contains the same number
     *        of parameters, but this is not checked! */
    argc = count_node(shredBAT, "param", (pre + 2), pre_size[0]) / iterc;

    argcnt = GDKmalloc(iterc * sizeof(int *));
    if (!argcnt) {
        snprintf(errstr, 1024, "Receiver internal error: not enough memory");
        send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    for (i = 0; i < iterc; i++) {
        argcnt[i] = GDKmalloc(argc * sizeof(int));
        if (!argcnt[i]) {
            snprintf(errstr, 1024, "Receiver internal error: not enough memory");
            send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
            goto FINISH_HANDLE_RPC_REQUEST;
        }
    }
    max_args = iterc * MAXPARAMS;
    argval = GDKmalloc(max_args * sizeof(char *));
    argtpe = GDKmalloc(max_args * sizeof(char *));
    if (!argval || !argtpe) {
        snprintf(errstr, 1024, "Receiver internal error: not enough memory");
        send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
        goto FINISH_HANDLE_RPC_REQUEST;
    }
   
    /* Fill the arrays 'argcnt', 'argval', 'argtpe' */
    inode_pre = pre;
    root_size = pre_size[0];
    for (i = 0; i < iterc; i++) {
        inode_pre  = get_node_pre(shredBAT, "iter", (inode_pre + 1), root_size);
        inode_size = pre_size[inode_pre];

        pnode_pre = inode_pre;
        for (j = 0; j < argc; j++) {
            pnode_pre  = get_node_pre(shredBAT, "param", (pnode_pre + 1), (inode_pre + inode_size));
            pnode_size = pre_size[pnode_pre];
       
            tnode_pre = pnode_pre + 1; argcnt[i][j] = 0; k = 1;
            while(tnode_pre < (pnode_pre + pnode_size) && 
                    (tnode_pre = get_elem_pre(shredBAT, tnode_pre, (pnode_pre + pnode_size))) > 0){
                tnode_size = pre_size[tnode_pre];

                if (tnode_size <= 0) {
                    snprintf(errstr, 1024, "XQuery RPC request [%s:%s]: "
                            "iteration[%d]->parameter[%d]->value[%d] does not contain value\n",
                            module, method, (i + 1), (j + 1), k);
                    send_error(out, 1, "404 Bad Request", "env:Sender", errstr);
                    goto FINISH_HANDLE_RPC_REQUEST;
                }

                if (nr_args == max_args) {
                    snprintf(errstr, 1024, 
                            "XQuery RPC request [%s:%s]: too many parameters, "
                            "maximum number of parameters is %d.\n",
                            module, method, MAXPARAMS);
                    send_error(out, 1, "404 Bad Request", "env:Sender", errstr);
                    goto FINISH_HANDLE_RPC_REQUEST;
                }

                if ((argtpe[nr_args] = get_type(out, shredBAT, tnode_pre)) == NULL) {
                    /* Error message is already sent by 'get_type' */
                    goto FINISH_HANDLE_RPC_REQUEST;
                }

                vnode_pre = tnode_pre + 1;
                if (strcmp(argtpe[nr_args], "xs:anyNode") == 0) {
                    vnode_pre = get_elem_pre(shredBAT, vnode_pre, (tnode_pre + tnode_size));
                    argval[nr_args] = GDKmalloc(32);
                    if (!argval[nr_args]) {
                        snprintf(errstr, 1024, "Receiver internal error: not enough memory");
                        send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
                        goto FINISH_HANDLE_RPC_REQUEST;
                    }
                    snprintf(argval[nr_args], 32, OIDFMT, vnode_pre);

                    ws_frag = BUNappend(ws_frag, (ptr)&vnode_pre, FALSE);
                    next_frag = vnode_pre + pre_size[vnode_pre] + 1;
                    if (next_frag < total_size){
                        ws_frag = BUNappend(ws_frag, (ptr)&next_frag, FALSE);
                    }
                    for (l = start_invalidate; l < vnode_pre; l++) {
                        pre_level[l] = pre_level[0];
                        pre_size[l] = 0;
                    }
                    level_diff = pre_level[vnode_pre];
                    for (l = vnode_pre; l <= (vnode_pre + pre_size[vnode_pre]); l++) {
                        pre_level[l] -= level_diff;
                    }
                    start_invalidate = vnode_pre + pre_size[vnode_pre] + 1;
                } else {
                    if (pre_kind[vnode_pre] != TEXT) {
                        snprintf(errstr, 1024, "XQuery RPC request [%s:%s]: "
                                "iteration[%d]->parameter[%d]->value[\"%d\"] "
                                "of type[\"%s\"] is expected to have a simple value.\n",
                                module, method, (i + 1), (j + 1), k, argtpe[nr_args]);
                        send_error(out, 1, "404 Bad Request", "env:Sender", errstr);
                        goto FINISH_HANDLE_RPC_REQUEST;
                    }
                    argval[nr_args] = GDKstrdup(text_base + prop_text[pre_prop[vnode_pre]]);
                }
                tnode_pre += (tnode_size + 1); /* skip all children of tnode and go to the next possible tnode */
                argcnt[i][j]++;
                nr_args++;
                k++;
            } /* end WHILE 'tnode_pre' */
        } /* end FOR 'argc' */
    } /* end FOR 'i < iterc' */

    /* (start_invalidate > 0) => there is at least one node parameter in
     * the request message, so invalidate all pre_level and pre_size
     * values after the last node parameter, if any. */
    if (start_invalidate > 0 && start_invalidate < total_size){
        for (l = start_invalidate; l < total_size; l++){
            pre_level[l] = pre_level[0];
            pre_size[l] = 0;
        }
    }

    /* write out our response */
    if (stream_printf(out,
                "HTTP/1.1 200 OK\r\n"
                "Content-Type: application/soap+xml; charset=\"utf-8\"\r\n\r\n"
                "<?xml version='1.0' ?>\n"
                "<env:Envelope\n"
                "    xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n"
                "    xmlns:env=\"http://www.w3.org/2003/05/soap-envelope\">\n"
                "<env:Header />\n"
                "<env:Body>\n"
                "<XQueryRpcResults \n"
                "    module=\"%s\"\n"
                "    uri=\"%s\"\n"
                "    method=\"%s\">\n",
                module, uri, method) >= 0)
    {
        argc += 1000; /* debug */
        char *err = xquery_method(out, module, uri, method, argc, iterc, argcnt, argtpe, argval, shredBAT);
        argc %= 1000;

        if (err) {
            send_error(out, 0, "", "env:Sender", err);
            goto FINISH_HANDLE_RPC_REQUEST;
        }
        stream_printf(out, "</XQueryRpcResults>\n</env:Body>\n</env:Envelope>\n");
    }
   
    retval = GDK_SUCCEED;
    goto FINISH_HANDLE_RPC_REQUEST;

FINISH_HANDLE_RPC_REQUEST:
    cleanup(out,0);
    myfree(argcnt, i, iterc);
    myfree(argtpe, i, nr_args)
    if (argval) GDKfree(argval);
    return retval;
}

int CMDhttp_post(BAT **res,
                 str location,
                 str rpc_module,
                 str rpc_uri,
                 str rpc_method,
                 BAT* ws,
                 BAT* fun_vid,
                 BAT* fun_iter,
                 BAT* fun_item,
                 BAT* fun_kind,
                 BAT* int_values,
                 BAT* dbl_values,
                 BAT* dec_values,
                 BAT* str_values) {

    int i, a, len, ret, sock = -1, port = HTTP_PORT, retval = GDK_FAIL;
    int type = 0; /* param type in C */
    buffer *b = NULL;
    str strptr = NULL;
    stream *in = NULL, *out = NULL, *bs = NULL, *bak = GDKout;
    BAT *shredBAT = NULL; /* Hold the temp BATs after the RPC response has been shredded: */
    BAT *node_item = NULL, *node_kind = NULL; /* BATs hold item|kind of a node parameter */
    BUN p_vid, p_iter, p_item, p_kind; /* Pointers to the current BUNs of the BATs. */
    str str_val = NULL;

    int argc = 0, argc_base = 0, my_argc = 0;
    int iterc = 0, iter_base = 0, my_iter = 0;
    int itemc = 0, arg_offset = 0;
    int **argcnt = NULL;    /* #items eash [iter][param] contains */
    int nr_args = 0;
    int max_args = 0;

    if ((strptr = strchr(location, (int)':')) != NULL) {
        strptr[0] = '\0'; strptr++;
        port = atoi(strptr);
    }
    if ((sock = setup_connection(location, port, NR_RETRIES)) < 0) {
        goto FINISH_HTTP_POST;
    }
    if (!(out = socket_wastream(sock, "http_send"))) {
        GDKerror("CMDhttp_post: failed to create socket_wastream\n");
        goto FINISH_HTTP_POST;
    }
    if (!(in = socket_rastream(sock, "http_receive"))) {
        GDKerror("CMDhttp_post: failed to create socket_rastream\n");
        goto FINISH_HTTP_POST;
    }

    /* Create buffer for the RPC request message */
    b = buffer_create(MAX_BUF_SIZE);
    if (!b || b->len == 0) {
        GDKerror("CMDhttp_post: failed to create outgoing buffer\n");
        goto FINISH_HTTP_POST;
    }

    b->pos = snprintf(b->buf, b->len,
            "<?xml version='1.0' ?>\n"
            "<env:Envelope\n"
            "    xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n"
            "    xmlns:env=\"http://www.w3.org/2003/05/soap-envelope\">\n"
            "<env:Header />\n"
            "<env:Body>\n"
            "<XQueryRpcRequest\n"
            "    module=\"%s\"\n"
            "    uri=\"%s\"\n"
            "    method=\"%s\">\n",
            rpc_module, rpc_uri, rpc_method);

    /* Find the number of parameters and iterations. */
    argc  = *(int*)BUNtail(fun_vid, BUNprev(fun_vid, BUNlast(fun_vid)) ) - *(int*)BUNtail(fun_vid,BUNfirst(fun_vid)) + 1;
    iterc = *(int*)BUNtail(fun_iter,BUNprev(fun_iter,BUNlast(fun_iter)));
    /*
    argc  = BATcount(BATkunique(BATmirror(fun_vid)));
    iterc = BATcount(BATkunique(BATmirror(fun_iter)));
    */

    if (!(argcnt = GDKmalloc(iterc * sizeof(int *)))) {
        GDKerror("CMDhttp_post: failed to malloc argcnt\n");
        goto FINISH_HTTP_POST;
    }
    for (i = 0; i < iterc; i++) {
        if (!(argcnt[i] = GDKmalloc(argc * sizeof(int)))) {
            GDKerror("CMDhttp_post: failed to malloc argcnt[%d]\n", i);
            goto FINISH_HTTP_POST;
        }
        for (a = 0; a < argc; a++) {
            argcnt[i][a] = 0;
        }
    }
    max_args = iterc * MAXPARAMS;

    /* Calculate the number of items contained by every parameter of
     * every iteration. */
    i = a = 0; /* i: iter counter; a: arg counter */
    iter_base = *(int*) BUNtail(fun_iter, BUNfirst(fun_iter));
    argc_base = *(int*) BUNtail(fun_vid, BUNfirst(fun_vid));
    for (p_vid  = BUNfirst(fun_vid),  p_iter = BUNfirst(fun_iter),
         p_item = BUNfirst(fun_item), p_kind = BUNfirst(fun_kind);

         p_vid  < BUNlast(fun_vid)  && p_iter < BUNlast(fun_iter) &&
         p_item < BUNlast(fun_item) && p_kind < BUNlast(fun_kind);

         p_vid  = BUNnext(fun_vid, p_vid),
         p_iter = BUNnext(fun_iter, p_iter),
         p_item = BUNnext(fun_item, p_item),
         p_kind = BUNnext(fun_kind, p_kind)) {

        if (nr_args == max_args) {
            GDKerror("CMDhttp_post: too many parameters.\n");
            goto FINISH_HTTP_POST;
        }

        i = *(int*) BUNtail(fun_iter, p_iter);
        a = *(int*) BUNtail(fun_vid, p_vid);
        argcnt[i - iter_base][a - argc_base]++;
        nr_args++;
    }
    max_args = nr_args; /* actual number of argval-s */
    nr_args = 0;

    for (my_iter = 0; my_iter < iterc; my_iter++) {
        if (argcnt[my_iter][0] > 0) {
            /* Enlarge the buffer is it is filled more than 80%.
             * FIXME: is this really necessary? Or should we just return an
             * error?
             */
            if (b->pos > (b->len * 0.8)) {
                b->len *= 2;
                b->buf = realloc(b->buf, b->len);
            }

            str2buf(b, "<iter>\n");

            for (my_argc = 0; my_argc < argc; my_argc++) {
                str2buf(b, "<param>\n");

                arg_offset = 0;
                /* add the 'argcnt' of all arg-s before 'me': */
                for (a = 0; a < my_argc; a++) {
                    for (i = 0; i < iterc; i++) {
                        arg_offset += argcnt[i][a];
                    }
                }
                /* add the 'argcnt' of iter-s before 'me': */
                for (i = 0; i < my_iter; i++) {
                    arg_offset += argcnt[i][my_argc];
                }
                /* now 'arg_offset' contains the index of the values and the
                 * types of MY iter and My argc in argval and argtpe */

                for (itemc = 0; itemc < argcnt[my_iter][my_argc]; itemc++) {
                    /* index into fun_item|fun_kind */
                    a = arg_offset + itemc;
                    type = *(int*)BUNtail(fun_kind, BUNptr(fun_kind, a));
                    if (type > WS_SIZE) {
                        str2buf(b, "<xs:anyNode>\n");

                        node_item = BUNins(BATnew(TYPE_void, TYPE_oid, 1),
                                BUNhead(fun_item, BUNptr(fun_item, a)),
                                BUNtail(fun_item, BUNptr(fun_item, a)) );
                        node_kind = BUNins(BATnew(TYPE_void, TYPE_int, 1),
                                BUNhead(fun_kind, BUNptr(fun_kind, a)),
                                BUNtail(fun_kind, BUNptr(fun_kind, a)) );
                        if (!(bs = buffer_wastream(b, "shred_node_param"))) {
                            GDKerror("CMDhttp_post: failed to create buffer_wastream"
                                    " to shred node parameter\n");
                            goto FINISH_HTTP_POST;
                        }
                        THRsetdata(0, bs);
                        xquery_print_result_main("xml-noheader-noroot", ws,
                                node_item, node_kind, int_values,
                                dbl_values, dec_values, str_values);
                        THRsetdata(0, bak);

                        str2buf(b, "</xs:anyNode>\n");
                    } else if (type == BOOL) {
                        value2buf(b, len, strptr, fun_item, a, i, TYPE_bit, int_values, "<xs:bool>", "</xs:bool>\n");
                    } else if (type == INT) {
                        value2buf(b, len, strptr, fun_item, a, i, TYPE_int, int_values, "<xs:integer>", "</xs:integer>\n");
                    } else if (type == DEC) {
                        value2buf(b, len, strptr, fun_item, a, i, TYPE_dbl, dbl_values, "<xs:decimal>", "</xs:decimal>\n");
                    } else if (type == DBL) {
                        value2buf(b, len, strptr, fun_item, a, i, TYPE_dbl, dbl_values, "<xs:double>", "</xs:double>\n");
                    } else if (type == STR || type == U_A) {
                        i = *(int*)BUNtail(fun_item, BUNptr(fun_item, a));
                        str_val = BUNtail(str_values, BUNptr(str_values, i));
                        b->pos += snprintf((b->buf + b->pos), (b->len - b->pos),
                                "<xs:string>\"%s\"</xs:string>\n", str_val);
                    } else {
                        GDKerror("CMDhttp_post: iter%d/param%d/item%d  has invalid type %d\n",
                                my_iter, my_argc, i);
                        goto FINISH_HTTP_POST;
                    }
                }
                str2buf(b, "</param>\n");
            }
            str2buf(b, "</iter>\n");
        }
    }

    str2buf(b, "</XQueryRpcRequest>\n</env:Body>\n</env:Envelope>\n");
    b->buf[b->pos] = 0;
/*
printf("\n=== DEBUG MSG: RPC request to send: (msglen = %ld) ===\n%s"
       "=== END DEBUG MSG: RPC request to send ===============\n\n",
        b->pos, b->buf);
*/
    if (stream_printf(out,
            "POST %s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Accept: text/html, text/xml, application/soap+xml\r\n"
            "Accept-Language: en-uk en-us\r\n"
            "Content-Type: text/html; charset=\"utf-8\"\r\n"
            "Content-Length: %d\r\n\r\n"
            "%s",
            HTTPD_FUNC, location, b->pos, b->buf) < (int)b->pos) {
        GDKerror("CMDhttp_post: failed to send XQuery RPC request.");
        goto FINISH_HTTP_POST;
    }


    /*** Receive all response data ***/
    b->pos = b->buf[0] = 0;
    do{
        ret = stream_read(in, (b->buf + b->pos), 1, (b->len - b->pos));
        b->pos += ret;
        if (b->pos > (b->len * 0.8)) {
            b->len *= 2;
            b->buf = realloc(b->buf, b->len);
        }
    } while (ret > 0);
    b->buf[b->pos] = 0;

    if (b->pos < MIN_RESPONSE_SIZE || !strstr((b->buf + b->pos - 16), "</env:Envelope>")) {	
        GDKerror("CMDhttp_post: failed to get response: %s\n",
                errno?strerror(errno):"no errno available");
        if (b->pos < MIN_RESPONSE_SIZE)
            GDKerror("#bytes received: %ld\n", b->pos);
        else if (!strstr((b->buf + b->pos - 16), "</env:Envelope>"))
            GDKerror("cannot find \"</env:Envelope>\" in buffer");

        GDKerror("\nDump of received data:\n%s\n", b->buf);
        goto FINISH_HTTP_POST;
    }
/*
printf("\n=== DEBUG MSG: received RPC response message ======\n%s"
       "=== END DEBUG MSG: received RPC response message ===\n\n", b->buf);
*/
    b->len = b->pos;
    b->buf = realloc(b->buf, b->len); /* release unused memory */
    strptr = strchr(b->buf, (int)' ') + 1; /* the HTTP return code */
    if (strptr[0] != '2' || strptr[1] != '0' || strptr[2] != '0' ) {
        /* Find the end of the first HTTP header line
         * and print the HTTP error code + message */
        i = 0;
        while (strptr[i] != '\r') i++;
        strptr[i] = '\0';
        GDKerror("CMDhttp_post: %s\n\n", b->buf);
        goto FINISH_HTTP_POST;
    } else if (strstr(strptr, "<env:Fault")) {
        /* Print the SOAP Fault Envelope */
        /* TODO: maybe it is better to shred the SOAP fault message
         *       and let the calling XQuery method handle it. */
        strptr = strstr((strptr + i + 1), "<env:");
        GDKerror("%s\n", strptr);
        goto FINISH_HTTP_POST;
    }

    /* Retrieve the SOAP Envelope from the response message */
    strptr = strstr(strptr, "<env:Envelope");

    if (CMDshred2bats(&shredBAT, "", strptr, "")  == GDK_FAIL) {
        GDKerror("CMDhttp_post: invalid XQuery RPC response received\n");
        goto FINISH_HTTP_POST;
    }

    *res = shredBAT;
    retval = GDK_SUCCEED;
    goto FINISH_HTTP_POST;

FINISH_HTTP_POST:
    cleanup(in, 1);
    cleanup(out, 1);
    cleanup(bs, 0);
    myfree(argcnt, i, iterc);
    if (sock > 0) close(sock);
    if (b) {
        if (b->len > 0) buffer_destroy(b);
        else            free(b);
    }
    return retval;
}

int CMDhttpd_start(int* port) {
    int sock;
       
    if (rpc_receiver_running) {
        GDKerror("CMDhttpd_start: RPC receiver already running\n");
        return GDK_FAIL;
    }
    rpc_receiver_running = 1;

    /* Initialize with specific config file, pass NULL to use default values */
    shttpd_init(NULL);

    /* Register call back function */
    shttpd_register_url(HTTPD_FUNC, &handle_rpc_request, NULL);

    /* Open listening socket */
    sock = shttpd_open_port(*port);

    /* Serve connections infinitely until someone kills us */
    for (;rpc_receiver_running;) {
        shttpd_poll(sock, 200);
    }
    return GDK_SUCCEED;
}

bat* xquery_rpc_prelude() {
    /* Nothing to do here. */
    return NULL;
}

void xquery_rpc_epilogue() {
    /* Shut down the HTTP server. */
    shttpd_fini();

    /* stop RPC receiver */
    rpc_receiver_running = 0;
}

/* vim:set shiftwidth=4 expandtab: */
