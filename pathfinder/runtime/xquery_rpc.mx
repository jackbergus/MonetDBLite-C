@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2006 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$
@'

@f xquery_rpc
@a Ying Zhang

@t MIL primitives to support the RPC extension for XQuery using HTTP connection

@* Introduction
This module provides new MIL primitives to support remote XQuery execution
using HTTP connection on top of MonetDB within the "Pathfinder" project.
@
@* Module Definition
@m
.MODULE xquery_rpc;

.USE pathfinder;
.USE pf_support;
.USE url;

@- HTTP server function(s)
@m
.COMMAND httpd_start(int port, str option) : void = CMDhttpd_start;
"Start the HTTP server for RPC calls on the specified port."

@- HTTP client function(s)
@m
.COMMAND http_post(
        str mode,
        str location,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        BAT[oid, bat] ws,
        BAT[oid, oid] fun_vid,
        BAT[oid, oid] fun_iter,
        BAT[oid, oid] fun_item,
        BAT[oid, int] fun_kind,
        BAT[oid, lng] int_values,
        BAT[oid, dbl] dbl_values,
        BAT[oid, dbl] dec_values,
        BAT[oid, str] str_values) : BAT[oid, bat] = CMDhttp_post;
"Create and send a RPC request message to the specified destination"

.PRELUDE = xquery_rpc_prelude;
.EPILOGUE = xquery_rpc_epilogue;

.END xquery_rpc;

@mil
PROC rpc_receiver_start(int port, str option) : void {
    fork(httpd_start(port, option));
}
ADDHELP("rpc_receiver_start", "zhang", "November 2005",
"PARAMETER:\n\
int: port number\n\
str: option, currently, only \"rpctime\"\n\
DESCRIPTION:\n\
Start receiver for RPC calls on the specified port",
"xquery_rpc");

PROC rpc_receiver_start(int port) : void {
    fork(httpd_start(port, ""));
}
ADDHELP("rpc_receiver_start", "zhang", "November 2005",
"DESCRIPTION:\n\
Start receiver for RPC calls on the specified port",
"xquery_rpc");

PROC rpc_receiver_start() : void {
    rpc_receiver_start( int(monet_environment.find("pf_httpd_port")), "");
}
ADDHELP("rpc_receiver_start", "zhang", "November 2005",
"DESCRIPTION:\n\
Start receiver for RPC calls on the default port as specified in \"monet_environment\" by \"pf_httpd_port\"",
"xquery_rpc");

PROC rpc_client(
        str local_name,
        str mode,
        str location,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        BAT[oid, bat] ws,
        BAT[oid, oid] fun_vid,
        BAT[oid, oid] fun_iter,
        BAT[oid, oid] fun_item,
        BAT[oid, int] fun_kind,
        BAT[oid, lng] int_values,
        BAT[oid, dbl] dbl_values,
        BAT[oid, dbl] dec_values,
        BAT[oid, str] str_values) : oid {

    var rpcres := http_post(mode, location, rpc_module, rpc_uri, rpc_method, ws, 
                            fun_vid,    fun_iter,   fun_item,   fun_kind,
                            int_values, dbl_values, dec_values, str_values);

    var time_milClntDeSeriaStart := msec();
    if (options.search("rpctime") >= 0) {
        printf("\nMIL_Client_DeSerialisation_Start: %lld msec\n", time_milClntDeSeriaStart);
    }

    var docBAT := bat(str,bat,WS_SIZE);
    var height := index_doc(rpcres,docBAT);
    var cntoid := add_docbat(ws, docBAT, local_name, TEMP_DOC, oid(nil), height);
    return cntoid;
}
ADDHELP("rpc_client", "zhang", "November 2005",
"DESCRIPTION:\n\
Send a RPC request to the destination \"location\", save the reults in the WorkingSet and return the fragment-id of the new added document",
"xquery_rpc");

PROC get_rpc_res ( 
        oid cont, 
        str local_name, 
        int nr_iters,
        BAT[oid, bat] ws, 
        BAT[oid, lng] int_values,
        BAT[oid, dbl] dbl_values, 
        BAT[oid, str] str_values) : BAT[void, bat]
{
    var res_iter := bat(void,oid,nr_iters).seqbase(0@0);
    var res_item := bat(void,oid,nr_iters).seqbase(0@0);
    var res_kind := bat(void,int,nr_iters).seqbase(0@0);
    
    # get values out of WS for later use
    var pre_size  := ws.fetch(PRE_SIZE).fetch(cont);
    var pre_level := ws.fetch(PRE_LEVEL).fetch(cont);
    var pre_prop  := ws.fetch(PRE_PROP).fetch(cont); # reference to the value tables
    var pre_kind  := ws.fetch(PRE_KIND).fetch(cont);
    var pre_nid   := ws.fetch(PRE_NID).fetch(cont);

    var qn_prefix := ws.fetch(QN_PREFIX).fetch(cont);
    var qn_loc    := ws.fetch(QN_LOC).fetch(cont); # str name of ELEM nodes
    var prop_text := ws.fetch(PROP_TEXT).fetch(cont); # str value of TEXT nodes

    # Get "pre_prop" value of an "iter" node.  It's save to use 'find',
    # since "iter" appears only once in 'qn_loc'.
    var a;
    var err := CATCH ({ a := qn_loc.reverse().find("iter"); });
    if (not(isnil(err))) {
        ERROR("get_rpc_res: RPC result should contain at lease *one* \"<iter>\" tag.\n");
    }

    # Fetch the position of the first "pre_prop" value of the "iter"
    # node.  Must use "ord_select" and "fetch", since the the "pre_prop"
    # value can appear more than once in the "pre_prop" bat.
    a := pre_prop.ord_select(a).reverse().fetch(0);

    # To reduce #iter in batloop: everything before the first "iter" is
    # not used, so remove them
    pre_size  := pre_size.slice (int(a), pre_size.count() - 1);
    pre_level := pre_level.slice(int(a), pre_level.count()- 1);
    pre_prop  := pre_prop.slice (int(a), pre_prop.count() - 1);
    pre_kind  := pre_kind.slice (int(a), pre_kind.count() - 1);

    var level_typeNode :=  pre_level.find(a).int() + 1;
    var itercnt := 0;
    var tpe := "";
    var i := int(nil);
    var d := dbl(nil);

    pre_size@batloop(){
        if (not(isnil($t))){ # Skip holes in the BATs
            var l := pre_level.fetch($h).int();
            var k := pre_kind.fetch($h);
            var prop := pre_prop.fetch($h);

            if (l < (level_typeNode + 2)) { # skip contents of a node value
                if (k = '\000') { # ELEM node
                    if (qn_loc.fetch(prop) = "iter"){
                        # A new iteration starts
                        itercnt :+= 1;
                    } else if (l = level_typeNode){
                        var prefix := qn_prefix.fetch(prop);
                        if (prefix = "xs") {
                            tpe := qn_loc.fetch(prop);
                        } else {
                            ERROR("get_rpc_res: invalid prefix of type node.  Expected \"xs\", got \"%s\".\n", prefix);
                        }
                    } else if (tpe = "anyNode"){
                        res_iter.append(oid(itercnt));
                        res_item.append(pre_nid.fetch($h));
                        i := set_kind(local_name.leftjoin(reverse(ws.fetch(DOCID_NAME))).leftjoin(reverse(ws.fetch(CONT_DOCID))).tmark(0@0), ELEM);
                        res_kind.append(i);
                        tpe := ""; # clean up type info
                    }
                } else if ( and((k = '\001'), (tpe != "")) ) { # TEXT node                
                    var val := prop_text.fetch(prop); # value in str
                    if (tpe = "integer"){
                        i := lng(val);
                        int_values.append(i);
                        res_iter.append(oid(itercnt));
                        res_item.append(int_values.reverse().find(i));
                        res_kind.append(INT);
                    } else if(tpe = "double") {
                        d := dbl(val);
                        dbl_values.append(d);
                        res_iter.append(oid(itercnt));
                        res_item.append(dbl_values.reverse().find(d));
                        res_kind.append(DBL);
                    } else if(tpe = "decimal") {
                        d := dbl(val);
                        dbl_values.append(d);
                        res_iter.append(oid(itercnt));
                        res_item.append(dbl_values.reverse().find(d));
                        res_kind.append(DEC);
                    } else if(or( (tpe = "string"), (tpe = "anyNode") )) {
                        str_values.append(val);
                        res_iter.append(oid(itercnt));
                        res_item.append(str_values.reverse().find(val));
                        res_kind.append(STR);
                    } else {
                        printf("get_rpc_res: value with unsupported type \"%s\" ignored.\n", tpe);
                    }
                    tpe := ""; # clean up type info
                }
            }
        }
    }
    return bat(void,bat,3).append(res_iter).append(res_item).append(res_kind);
}
ADDHELP("get_rpc_res", "zhang", "April 2006",
"DESCRIPTION:\n\
This proc is used to retrieve the return values of RPC call(s), which are temporarily stored in the WS. It\n\
1. retrieves the right values\n\
2. builds temporary iter|item|kind BATs\n\
3. fill in the value containers",
"xquery_rpc");

PROC doIterativeRPC(
        int nr_iters,
        str options,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        BAT[oid,bat] ws,
        BAT[oid,str] rpc_dsts,
        BAT[oid,oid] rpc_iter,
        BAT[oid,oid] fun_vid,
        BAT[oid,oid] fun_iter,
        BAT[oid,oid] fun_item,
        BAT[oid,int] fun_kind,
        BAT[oid,lng] int_values,
        BAT[oid,dbl] dbl_values,
        BAT[oid,dbl] dec_values,
        BAT[oid,str] str_values) : BAT[void,bat]
{
    var rpc_timing := str(nil);
    if (options.search("rpctime") >= 0) {
        rpc_timing := "rpctime";
    } else {
        rpc_timing := "";
    }

    var res_bats := nil;
    rpc_iter@batloop(){
        var dst := rpc_dsts.fetch(int($h)); # get iteration numbers for this destination

        var fun_iter_1iter := fun_iter.select($t);
        var fun_vid_1iter  := fun_vid.fetch(fun_iter_1iter.mirror()).tmark(0@0);
        var fun_item_1iter := fun_item.fetch(fun_iter_1iter.mirror()).tmark(0@0);
        var fun_kind_1iter := fun_kind.fetch(fun_iter_1iter.mirror()).tmark(0@0);
            fun_iter_1iter := fun_iter_1iter.tmark(0@0);

        var local_name := "rpc_res_00" + str(int($h)+1);
        var rpc_oid := oid(nil);
        var rpc_err := CATCH(
        {
            rpc_oid := rpc_client(local_name, rpc_timing, dst, 
                        rpc_module, rpc_uri, rpc_method, ws,
                        fun_vid_1iter, fun_iter_1iter, fun_item_1iter, fun_kind_1iter,
                        int_values, dbl_values, dec_values, str_values);
        });

        var time_clntDeSeria := msec();
        if (isnil(rpc_err)) {
            var res := get_rpc_res(rpc_oid, local_name, nr_iters, ws,
                                   int_values, dbl_values, str_values);
            if (isnil(res_bats)){
                res_bats := res;
            } else {
                # merge results of this iteration into existing results.
                res_bats := merged_union(res_bats.fetch(0), res.fetch(0), 
                                         res_bats.fetch(1), res.fetch(1), 
                                         res_bats.fetch(2), res.fetch(2));
            }
        } else {
            # layman's error handling simplifies debugging; better solution is more than welcome!
            ERROR("RPC call: rpc_client:\n" + rpc_err);
        }
        time_clntDeSeria := msec() - time_clntDeSeria;
        if (options.search("rpctime") >= 0) {
            printf("Client_DeSerialisation: %lld msec\n", time_clntDeSeria);
        }
    }
    return res_bats;
}
ADDHELP("doIterativeRPC", "zhang", "April 2006",
"DESCRIPTION: make a separate RPC call for ever iteration",
"xquery_rpc");

PROC doLoopLiftedRPC(
        int nr_iters,
        str options,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        BAT[oid,bat] ws,
        BAT[oid,str] rpc_dsts,
        BAT[oid,oid] fun_vid,
        BAT[oid,oid] fun_iter,
        BAT[oid,oid] fun_item,
        BAT[oid,int] fun_kind,
        BAT[oid,lng] int_values,
        BAT[oid,dbl] dbl_values,
        BAT[oid,dbl] dec_values,
        BAT[oid,str] str_values) : BAT[void,bat]
{
    var rpc_timing := str(nil);
    if (options.search("rpctime") >= 0) {
        rpc_timing := "rpctime";
    } else {
        rpc_timing := "";
    }
    var mylock := lock_create();

    var rpc_unq_dsts := rpc_dsts.tunique().hmark(0@0);
    var steps := rpc_unq_dsts.count();
    var rpc_results := bat(str,oid);
    var rpc_iter := bat(void,bat).seqbase(0@0);

    rpc_unq_dsts @ [steps] batloop(){
        var time_milClntSeria := msec();

        # get iteration numbers for this destination
        var iter_dst := rpc_dsts.ord_uselect($t).mirror();

        # retrieve the frag of fun_vid, fun_iter, fun_item and fun_kind for this iteration.
        var fun_iter_dst := fun_iter.join(iter_dst);
        var indices      := fun_iter_dst.mirror().hmark(0@0);
        var fun_vid_dst  := indices.fetchjoin(fun_vid).tmark(0@0);
            fun_iter_dst := fun_iter_dst.tmark(0@0);
        var fun_item_dst := indices.fetchjoin(fun_item).tmark(0@0);
        var fun_kind_dst := indices.fetchjoin(fun_kind).tmark(0@0);

        var local_name := "rpc_res_00" + str(int($h)+1);
        var rpc_oid;

        time_milClntSeria := msec() - time_milClntSeria;
        if (options.search("rpctime") >= 0) {
            printf("\nMIL_Client_Serialisation: %lld msec\n", time_milClntSeria);
        }

        var rpc_err := CATCH(
        {
            rpc_oid := rpc_client(local_name, rpc_timing, $t,
                            rpc_module, rpc_uri, rpc_method, ws,
                            fun_vid_dst, fun_iter_dst, fun_item_dst, fun_kind_dst, 
                            int_values, dbl_values, dec_values, str_values);
        });

        if (isnil(rpc_err)) {
            lock_set(mylock);
            rpc_results.insert(local_name,rpc_oid);
            rpc_iter.append(iter_dst.hmark(1@0));
            lock_unset(mylock);
        } else { # layman's error handling simplifies debugging; better solution is more than welcome!
            ERROR("RPC call: rpc_client:\n" + rpc_err);
        }
        var time_milClntDeSeriaEnd := msec();
        if (options.search("rpctime") >= 0) {
            printf("MIL_Client_DeSerialisation_End: %lld msec\n\n", time_milClntDeSeriaEnd);
        }
    }
    lock_destroy(mylock);

    # retrieve results for this destination, and map the results back to the original iteration number
    var proc_res := [get_rpc_res](rpc_results.tmark(0@0), rpc_results.hmark(0@0), nr_iters, const ws,
                                  const int_values, const dbl_values, const str_values);
    var res_iter := proc_res.[fetch](0).[leftfetchjoin](rpc_iter);
    var res_item := proc_res.[fetch](1);
    var res_kind := proc_res.[fetch](2);

    # initialize res_bat with the results for the first destination 
    var res_bats := bat(void,bat,3).seqbase(0@0);
    res_bats.append(res_iter.fetch(0));
    res_bats.append(res_item.fetch(0));
    res_bats.append(res_kind.fetch(0));

    # if there were more destinations, merge the result tables 
    var i := 0;
    while ((i :+= 1) < steps) {
        # initialize res_bat with the results for the first destination 
        res_bats := merged_union(res_bats.fetch(0), res_iter.fetch(i), 
                                 res_bats.fetch(1), res_item.fetch(i), 
                                 res_bats.fetch(2), res_kind.fetch(i));
    }
    return res_bats;
}
ADDHELP("doLoopLiftedRPC", "zhang", "April 2006",
"DESCRIPTION: implementation of the loop-lifted RPC",
"xquery_rpc");

@h
#ifndef XQUERY_RPC_H
#define XQUERY_RPC_H

#include "pathfinder.h"

/* BAT related functions */
#include <gdk.h>
/* escape_url() */
#include <url.h>
/* stream functions */
#include <stream.h>
#include <time.h>

#ifdef _WIN32   /* Windows specific */
    #include <winsock.h>
    #define snprintf _snprintf
    #ifndef __MINGW32__
        #pragma comment(lib, "ws2_32")
    #endif
    #define sleep(s) Sleep(1000*(s))
#else           /* UNIX specific */
    #include <sys/select.h>
    #include <sys/types.h>	/* used by socket */
    #include <sys/socket.h>
    #include <unistd.h>
    #include <netinet/in.h> /* hton and ntoh */
    #include <arpa/inet.h>  /* dotted IP addr to and from 32-bits int */
    #include <netdb.h>		/* convert domain names into IP addr */
    #include <errno.h>
    #include <ctype.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h> /* Functions to handle variable argument lists */

/* CMDshred2bats() and xquery_print_result_main() */
#include "pf_support.h"
#include "shredder.h"
#include "serialize.h"
#include "shttpd.h"

#define MXQ_SIGNATURE "signature\01http://monetdb.cwi.nl/xquery/rpc"
#define MXQ_TYPE "type\01http://monetdb.cwi.nl/xquery/rpc"

#define PFTEXT      1
#define ELEMENT     0
#define MAXPARAMS   32
#define HTTP_PORT   48080
#define HTTPD_FUNC  "/xquery_rpc"

/* Used by the http_post client */
#define MIN_RESPONSE_SIZE       19
#define MAX_BUF_SIZE            1024*1024 /* MUST be the same as 'IO_MAX' in shttpd.c */
#define MAX_POST_HEADER_SIZE    1024
#define NR_RETRIES              3 /* #retries to connect to the RPC receiver */

#define str2buf(b, str)             \
    { b->pos += snprintf((b->buf + b->pos), (b->len - b->pos), str); }

#define value2buf(b, len, strptr, fun_item, off, i, v_type, v_cont, begin_tag, end_tag) \
    {                                                                                   \
    str2buf(b, begin_tag);                                                              \
    len = b->len - b->pos;                                                              \
    strptr = b->buf + b->pos;                                                           \
    i = *(int*)BUNtail(fun_item, BUNptr(fun_item, off));                                \
    b->pos += BATatoms[v_type].atomToStr(&strptr, &len, BUNptr(v_cont, i));             \
    str2buf(b, end_tag);                                                                \
    }

#define cleanup(obj, bit)           \
    if (obj) {                      \
        stream_close(obj);          \
        stream_destroy(obj);        \
        if (bit == 1) sock = -1;    \
    }

#define myfree(ary, i, max)         \
    if (ary) {                      \
        for(i = 0; i < max; i++)    \
            GDKfree(ary[i]);        \
        GDKfree(ary);               \
    }

/* To prevent start the HTTP server twice */
int rpc_receiver_running = 0;
int servertiming = 0;

#endif /* XQUERY_RPC_H */

@c
#include "xquery_rpc.h"

/* Create a HTTP client socket.
 * Returns the socket if succeeded, -1 otherwise.
 */
static int setup_connection(str location, int port, int nr_retries) {
    int i, ret, sock;
    struct in_addr addr;
    struct sockaddr_in sockaddr;
    struct hostent *resolv = NULL;

    errno = 0;
    if (isdigit((int)location[0])) {
        if ((i = inet_addr(location)) < 0) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", location);
            if (errno) GDKerror("setup_connection: %s\n", strerror(errno));
            return -1;
        }
        addr.s_addr = (unsigned) i;
    } else {
        if (!(resolv = gethostbyname(location))) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", location);
            if (errno) GDKerror("setup_connection: %s\n", strerror(errno));
            return -1;
        }
        addr.s_addr = ((struct in_addr *)resolv->h_addr_list[0])->s_addr;
    }

    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port   = htons(port);
    sockaddr.sin_addr.s_addr = addr.s_addr;
    memset(&(sockaddr.sin_zero), '\0', 8);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        GDKerror("setup_connection: failed to create socket\n");
        return -1;
    }

    ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    for (i = 0; i < nr_retries && ret < 0; i++) {
        sleep(1);
        ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    }
       
    if (ret < 0) {
        GDKerror("setup_connection: could not setup connection with "
                "%s:%d\n", location, port);
        close(sock);
        return -1;
    }
    return sock;
}

/* Used by the RPC receiver to send an error message to the RPC sender.
 * The error message is sent in the format of a SOAP FAULT message.
 */
static void send_error(stream *out, bit p_body, char* http_err, char *soapcodev, char *errstr){
    if (p_body) {
        stream_printf(out, "HTTP/1.1 %s\r\n"
                "Content-Type: application/soap+xml; charset=\"utf-8\"\r\n\r\n"
                "<?xml version='1.0' ?>\n"
                "<env:Envelope\n"
                "    xmlns:env=\"http://www.w3.org/2003/05/soap-envelope\">\n"
                "  <env:Body>\n",
                http_err);
    }

    stream_printf(out,
            "    <env:Fault>\n"
            "      <env:Code>\n"
            "        <env:Value>\n"
            "          %s\n"
            "        </env:Value>\n"
            "      </env:Code>\n"
            "      <env:Reason>\n"
            "        <env:Text xml:lang=\"en\">\n"
            "          %s\n"
            "        </env:Text>\n"
            "      </env:Reason>\n"
            "    </env:Fault>\n"
            "  </env:Body>\n"
            "</env:Envelope>\n",
            soapcodev, errstr);
}

/* Calculate the number of nodes which has the name "node_name", within
 * the range 'start_pre' and 'end_pre' (incl.). */
static int count_node(char *node_name, int start_pre, int end_pre, oid* pre_prop, char* pre_kind, BAT* qn_loc){
    int i, nr = 0;

    assert(start_pre > 0);
    for (i = start_pre; i <= end_pre; i++) {
        if (pre_kind[i] == ELEMENT) {
            char *qname = BUNtail(qn_loc, BUNfnd(qn_loc, &(pre_prop[i])));
            if (strcmp(qname, node_name) == 0)
                nr++;
        }
    }
    return nr;
}

/* Find the first node between 'start_pre' and 'end_pre' (incl.), which
 * kind is 'ELEMENT'.
 * Return the 'pre' value of this node.
 * Return 0 if such node can not be found. */
static oid get_elem_pre(int start_pre, int end_pre, char* pre_kind){
    int i;

    assert(start_pre > 0 && end_pre >= start_pre);
    for (i = start_pre; i <= end_pre; i++) {
        if (pre_kind[i] == ELEMENT)
            return i;
    }
    return 0;
}

/* Given a node name, find the 'pre' value of the node given within the range
 * 'start_pre' and 'end_pre' (incl.).
 * Return 0 if such node can not be found. */
static oid get_node_pre(char *node_name, int start_pre, int end_pre, oid* pre_prop, char* pre_kind, BAT* qn_loc){
    int i;
    char *qname;

    assert(start_pre > 0 && end_pre >= start_pre);
    for (i = start_pre; i <= end_pre; i++) {
        if (pre_kind[i] == ELEMENT) {
            qname = BUNtail(qn_loc, BUNfnd(qn_loc, &(pre_prop[i])));
            if (strcmp(qname, node_name) == 0)
                return i;
        }
    }
    return 0;
}

/* Find the value of the attribute 'attrname', which is owned by the
 * node with the given 'pre' value.
 * NB: DO NOT free the string returned by this function!!!
 */
static char* find_attribute(char* attrname, oid pre, size_t nattrs, oid *attr_own, oid *attr_qn, oid *attr_prop, BAT *qn_loc, BAT *prop_val) {
    oid qn = oid_nil;
    size_t i;
    BUN p;

    /* Find 'attrname' in the tail of 'qn_loc' */
    p = BUNfnd(BATmirror(qn_loc), attrname);
    /* Get the position of 'attrname' in 'qn_loc' */
    if (p) qn = *(oid*) BUNhead(qn_loc, p);
    else return NULL;

    /* try to find the attribute value */
    for (i = 0; i < nattrs; i++) {
        if (attr_own[i] > pre) return NULL;
        if (attr_own[i] == pre && attr_qn[i] == qn) {
                int first = BUNindex(prop_val, BUNfirst(prop_val)) + attr_prop[i];
                return (char*) BUNtail(prop_val, BUNptr(prop_val, first));
        }
    }
    return NULL;
}

/* Given the pre value of a type node, return the name of the type node as a
 * string in the form "prefix:loc" */
static char* get_type(oid tnode_pre, oid *pre_prop, BAT *qn_loc, BAT* qn_prefix){
    char* prefix = (char*) BUNtail(qn_prefix, BUNptr(qn_prefix, pre_prop[tnode_pre]));
    char* loc    = (char*) BUNtail(qn_loc, BUNptr(qn_loc, pre_prop[tnode_pre]));
    int l = strlen(loc), p = strlen(prefix);
    char* res = GDKmalloc(p + l + 2);
    if (!res) return NULL;

    strncpy(res, prefix, p);
    res[p]=':';
    strncpy((res + p + 1), loc, l);
    res[p+l+1] = '\0';
    return res;
}

static int handle_rpc_request(struct shttpd_callback_arg *arg) {
    int i = 0, j = 0, k = 0, off = 0, sock = -1, retval = GDK_FAIL;
    char *strptr = NULL, *req_msg = NULL;
    char *module = NULL, *uri = NULL, *method = NULL;
    char errstr[1024];
    stream *out = NULL;

    /* pointers to the temporarily shredded BATs and to the values in
     * shredBAT */
    BAT *shredBAT = NULL, *ws_frag = NULL, *qn_loc = NULL, *qn_prefix = NULL, *prop_val = NULL;
    int nattrs = 0, *pre_size = NULL;
    char *pre_level = NULL, *pre_kind = NULL, *text_base = NULL;
    oid *pre_prop = NULL;
    var_t *prop_text = NULL;
    oid *attr_own = NULL, *attr_qn = NULL, *attr_prop = NULL;

    /* indecates from which node we should start with invalidate the
     * pre_level and the pre_size values */
    oid start_invalidate = 0;

    /* used for invalidation of the pre_level and the pre_size values */
    unsigned int l = 0, level_diff = 0, total_size;

    oid pre = 0, pnode_pre = 0, inode_pre = 0, tnode_pre = 0, vnode_pre = 0, next_frag = 0;

    /* used to save the pre_sizes of some nodes, before the node's
     * pre_size value is overwritten. */
    int root_size = 0, pnode_size = 0, inode_size = 0, tnode_size = 0;

    int iterc = 0, argc = 0;
    int **argcnt = NULL;    /* #items eash param/iter contains */
    str *argval = NULL;     /* Stores all actual values sequetially. */
    str *argtpe = NULL;     /* XQuery type of each argval */
    int nr_args = 0;        /* #values arg_val currently contains */
    int max_args = 0;       /* max #items in "argval", doubled if necessary */
    
    int time_servDeSeria = 0;
    
    THRnew(MT_getpid(), "rpc_req_handler");

    /* Create our own output stream for further data transfer. */
    sock = shttpd_get_socket(arg);
    if (!(out = socket_wastream(sock, "rpc_response"))) {
        GDKerror("handle_rpc_request: failed to create socket_wastream for socket %d", sock);
        close(sock);
        return GDK_FAIL;
    }

    /* Retrieve the whole received RPC request message, and remove the
     * first line of the message, so that the messgae we pass to
     * CMDshred2bats starts directly with the envelope tag. */
    req_msg = shttpd_get_msg(arg);

    /* Start timing Server DeSerialisation */
    time_servDeSeria = GDKms();
    strptr = req_msg + strlen("<?xml"); /* skip "<?xml" */
    if ((strstr(req_msg, "<?xml") != req_msg) ||
        (strptr = strchr(strptr, (int)'<')) == NULL) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
                "XQuery RPC request: bad XML structure\n");
    }

    if ((CMDshred2bats(&shredBAT, "", strptr, "")  == GDK_FAIL)) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
                "XQuery RPC request: bad XML structure, could not shred\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }

    off       = BUNindex(shredBAT,BUNfirst(shredBAT));
    pre_size  = (int *) BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_SIZE))));
    pre_level = (char *)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_LEVEL))));
    pre_prop  = (oid *) BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_PROP))));
    pre_kind  = (char *)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_KIND))));
    prop_text = (var_t*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PROP_TEXT))));
    prop_val = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PROP_VAL)) );
    qn_loc   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+QN_LOC))   );
    qn_prefix = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+QN_PREFIX)));
    text_base = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT, off+PROP_TEXT)))->theap->base;
    ws_frag   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+WS_FRAG)));
    ws_frag   = BATsetaccess(ws_frag, BAT_APPEND);
    total_size = BATcount(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+PRE_SIZE))));
    attr_own  = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+ATTR_OWN) )));
    attr_qn   = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+ATTR_QN)  )));
    attr_prop = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+ATTR_PROP))));
    nattrs = BATcount(BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,off+ATTR_PROP))));

    /* There are at least two nodes before "XQueryRpcRequest", namely
     * "Envelope" and "Body" (a "Header" node is optional). There are at
     * least two nodes after "XQueryRpcRequest", namely "iter" and
     * "param". */
    if (!(pre = get_node_pre("XQueryRpcRequest", 2, (pre_size[0] - 2), pre_prop, pre_kind, qn_loc))) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
                "XQuery RPC request must have a \"XQueryRpcRequest\" tag\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    if ((module = find_attribute("module", pre, nattrs, attr_own, attr_qn, attr_prop, qn_loc, prop_val)) == NULL) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
            "XQuery RPC request: \"XQueryRpcRquest\" tag does not have a \"module\" attribute.\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    if ((uri = find_attribute("uri", pre, nattrs, attr_own, attr_qn, attr_prop, qn_loc, prop_val)) == NULL) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
            "XQuery RPC request: \"XQueryRpcRquest\" tag does not have a \"uri\" attribute.\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    if ((method = find_attribute("method", pre, nattrs, attr_own, attr_qn, attr_prop, qn_loc, prop_val)) == NULL) {
        send_error(out, 1, "404 Bad Request", "env:Sender",
            "XQuery RPC request: \"SoapRpcRquest\" tag does not have a \"method\" attribute.\n");
        goto FINISH_HANDLE_RPC_REQUEST;
    }

    /* Calculate the number of iterations */
    iterc = count_node("iter", (pre+1), pre_size[0], pre_prop, pre_kind, qn_loc);
    if (iterc == 0) {
        snprintf(errstr, 1024, "XQuery RPC request [%s:%s]: should have at "
                "least one <iter> tag.\n", module, method);
        send_error(out, 1, "404 Bad Request", "env:Sender", errstr);
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    /* Calculate the number of parameters */
    /* FIXME: we now just assume each iteration contains the same number
     *        of parameters, but this is not checked! */
    argc = count_node("param", (pre + 2), pre_size[0], pre_prop, pre_kind, qn_loc) / iterc;

    argcnt = GDKmalloc(iterc * sizeof(int *));
    if (!argcnt) {
        snprintf(errstr, 1024, "Receiver internal error: not enough memory");
        send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
        goto FINISH_HANDLE_RPC_REQUEST;
    }
    for (i = 0; i < iterc; i++) {
        argcnt[i] = GDKmalloc(argc * sizeof(int));
        if (!argcnt[i]) {
            snprintf(errstr, 1024, "Receiver internal error: not enough memory");
            send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
            goto FINISH_HANDLE_RPC_REQUEST;
        }
    }
    max_args = iterc * MAXPARAMS;
    argval = GDKmalloc(max_args * sizeof(char *));
    argtpe = GDKmalloc(max_args * sizeof(char *));
    if (!argval || !argtpe) {
        snprintf(errstr, 1024, "Receiver internal error: not enough memory");
        send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
        goto FINISH_HANDLE_RPC_REQUEST;
    }
   
    /* Fill the arrays 'argcnt', 'argval', 'argtpe' */
    inode_pre = pre;
    root_size = pre_size[0];
    for (i = 0; i < iterc; i++) {
        inode_pre  = get_node_pre("iter", (inode_pre + 1), root_size, pre_prop, pre_kind, qn_loc);
        inode_size = pre_size[inode_pre];

        pnode_pre = inode_pre;
        for (j = 0; j < argc; j++) {
            pnode_pre  = get_node_pre("param", (pnode_pre + 1), (inode_pre + inode_size), pre_prop, pre_kind, qn_loc);
            pnode_size = pre_size[pnode_pre];
       
            tnode_pre = pnode_pre + 1; argcnt[i][j] = 0; k = 1;
            while(tnode_pre < (pnode_pre + pnode_size) && 
                    (tnode_pre = get_elem_pre(tnode_pre, (pnode_pre + pnode_size), pre_kind)) > 0){
                tnode_size = pre_size[tnode_pre];

                if (tnode_size <= 0) {
                    snprintf(errstr, 1024, "XQuery RPC request [%s:%s]: "
                            "iteration[%d]->parameter[%d]->value[%d] does not contain value\n",
                            module, method, (i + 1), (j + 1), k);
                    send_error(out, 1, "404 Bad Request", "env:Sender", errstr);
                    goto FINISH_HANDLE_RPC_REQUEST;
                }

                if (nr_args == max_args) {
                    snprintf(errstr, 1024, 
                            "XQuery RPC request [%s:%s]: too many parameters, "
                            "maximum number of parameters is %d.\n",
                            module, method, MAXPARAMS);
                    send_error(out, 1, "404 Bad Request", "env:Sender", errstr);
                    goto FINISH_HANDLE_RPC_REQUEST;
                }

                if ((argtpe[nr_args] = get_type(tnode_pre, pre_prop, qn_loc, qn_prefix)) == NULL) {
                    snprintf(errstr, 1024, "Receiver internal error: not enough memory");
                    send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
                    goto FINISH_HANDLE_RPC_REQUEST;
                }

                vnode_pre = tnode_pre + 1;
                if (strcmp(argtpe[nr_args], "xs:anyNode") == 0) {
                    vnode_pre = get_elem_pre(vnode_pre, (tnode_pre + tnode_size), pre_kind);
                    argval[nr_args] = GDKmalloc(32);
                    if (!argval[nr_args]) {
                        snprintf(errstr, 1024, "Receiver internal error: not enough memory");
                        send_error(out, 1, "404 Bad Request", "env:Receiver", errstr);
                        goto FINISH_HANDLE_RPC_REQUEST;
                    }
                    snprintf(argval[nr_args], 32, OIDFMT, vnode_pre);

                    ws_frag = BUNappend(ws_frag, (ptr)&vnode_pre, TRUE);
                    next_frag = vnode_pre + pre_size[vnode_pre] + 1;
                    if (next_frag < total_size){
                        ws_frag = BUNappend(ws_frag, (ptr)&next_frag, TRUE);
                    }
                    for (l = start_invalidate; l < vnode_pre; l++) {
                        pre_level[l] = pre_level[0];
                        pre_size[l] = 0;
                    }
                    level_diff = pre_level[vnode_pre];
                    for (l = vnode_pre; l <= (vnode_pre + pre_size[vnode_pre]); l++) {
                        pre_level[l] -= level_diff;
                    }
                    start_invalidate = vnode_pre + pre_size[vnode_pre] + 1;
                } else {
                    if (pre_kind[vnode_pre] != PFTEXT) {
                        snprintf(errstr, 1024, "XQuery RPC request [%s:%s]: "
                                "iteration[%d]->parameter[%d]->value[\"%d\"] "
                                "of type[\"%s\"] is expected to have a simple value.\n",
                                module, method, (i + 1), (j + 1), k, argtpe[nr_args]);
                        send_error(out, 1, "404 Bad Request", "env:Sender", errstr);
                        goto FINISH_HANDLE_RPC_REQUEST;
                    }
                    argval[nr_args] = GDKstrdup(text_base + prop_text[pre_prop[vnode_pre]]);
                }
                tnode_pre += (tnode_size + 1); /* skip all children of tnode and go to the next possible tnode */
                argcnt[i][j]++;
                nr_args++;
                k++;
            } /* end WHILE 'tnode_pre' */
        } /* end FOR 'argc' */
    } /* end FOR 'i < iterc' */

    /* (start_invalidate > 0) => there is at least one node parameter in
     * the request message, so invalidate all pre_level and pre_size
     * values after the last node parameter, if any. */
    if (start_invalidate > 0 && start_invalidate < total_size){
        for (l = start_invalidate; l < total_size; l++){
            pre_level[l] = pre_level[0];
            pre_size[l] = 0;
        }
    }
    /* Stop timing Server DeSerialisation */
    time_servDeSeria = GDKms() - time_servDeSeria;

    /* write out our response */
    if (stream_printf(out,
                "HTTP/1.1 200 OK\r\n"
                "Content-Type: application/soap+xml; charset=\"utf-8\"\r\n\r\n"
                "<?xml version='1.0' ?>\n"
                "<env:Envelope\n"
                "    xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n"
                "    xmlns:env=\"http://www.w3.org/2003/05/soap-envelope\">\n"
                "<env:Body>\n"
                "<XQueryRpcResults \n"
                "    module=\"%s\"\n"
                "    uri=\"%s\"\n"
                "    method=\"%s\">\n",
                module, uri, method) >= 0)
    {
        /* Start timing Server Application */
        char *err = xquery_method(out, servertiming, module, uri, method, argc, iterc, argcnt, argtpe, argval, shredBAT);
        /* Start timing Server Application */

        if (err) {
            send_error(out, 0, "", "env:Sender", err);
            goto FINISH_HANDLE_RPC_REQUEST;
        }
        stream_printf(out, "</XQueryRpcResults>\n</env:Body>\n</env:Envelope>\n");
    }

    if (servertiming){
        printf("Server_DeSerialisation: %d msec\n", time_servDeSeria);
    }

    retval = GDK_SUCCEED;
    goto FINISH_HANDLE_RPC_REQUEST;

FINISH_HANDLE_RPC_REQUEST:
    cleanup(out,0);
    myfree(argcnt, i, iterc);
    myfree(argtpe, i, nr_args)
    if (argval) GDKfree(argval);
    return retval;
}

int CMDhttp_post(BAT **res,
                 str mode,
                 str location,
                 str rpc_module,
                 str rpc_uri,
                 str rpc_method,
                 BAT* ws,
                 BAT* fun_vid,
                 BAT* fun_iter,
                 BAT* fun_item,
                 BAT* fun_kind,
                 BAT* int_values,
                 BAT* dbl_values,
                 BAT* dec_values,
                 BAT* str_values) {

    int i, a, len, ret, sock = -1, port = HTTP_PORT, retval = GDK_FAIL;
    int type = 0; /* param type in C */
    buffer *b = NULL;
    str strptr = NULL;
    stream *in = NULL, *out = NULL, *bs = NULL, *bak = GDKout;
    BAT *shredBAT = NULL; /* Hold the temp BATs after the RPC response has been shredded: */
    BAT *node_item = NULL, *node_kind = NULL; /* BATs hold item|kind of a node parameter */
    BUN p_vid, p_iter, p_item, p_kind; /* Pointers to the current BUNs of the BATs. */
    str str_val = NULL;

    int argc = 0, argc_base = 0, my_argc = 0;
    int iterc = 0, iter_base = 0, my_iter = 0;
    int itemc = 0, arg_offset = 0;
    int **argcnt = NULL;    /* #items eash [iter][param] contains */
    int nr_args = 0;
    int max_args = 0;

    int time_clntSeria = 0;
    int time_clnt2Serv = 0;
    int time_clntDeSeria = 0;
    int bytes_sent = 0, bytes_received = 0;

    ERRORcheck(!BAThdense(ws),
               "http_post: head of BAT ws must be dense.\n");
    ERRORcheck(!BAThdense(fun_vid),
               "http_post: head of BAT fun_vid must be dense.\n");
    ERRORcheck(!BAThdense(fun_iter),
               "http_post: head of BAT fun_iter must be dense.\n");
    ERRORcheck(!BAThdense(fun_item),
               "http_post: head of BAT fun_item must be dense.\n");
    ERRORcheck(!BAThdense(fun_kind),
               "http_post: head of BAT fun_kind must be dense.\n");
    ERRORcheck(!BAThdense(int_values),
               "http_post: head of BAT int_values must be dense.\n");
    ERRORcheck(!BAThdense(dbl_values),
               "http_post: head of BAT dbl_values must be dense.\n");
    ERRORcheck(!BAThdense(dec_values),
               "http_post: head of BAT dec_values must be dense.\n");
    ERRORcheck(!BAThdense(str_values),
               "http_post: head of BAT str_values must be dense.\n");

    if ((strptr = strchr(location, (int)':')) != NULL) {
        strptr[0] = '\0'; strptr++;
        port = atoi(strptr);
    }
    if ((sock = setup_connection(location, port, NR_RETRIES)) < 0) {
        goto FINISH_HTTP_POST;
    }
    if (!(out = socket_wastream(sock, "http_send"))) {
        GDKerror("CMDhttp_post: failed to create socket_wastream\n");
        goto FINISH_HTTP_POST;
    }
    if (!(in = socket_rastream(sock, "http_receive"))) {
        GDKerror("CMDhttp_post: failed to create socket_rastream\n");
        goto FINISH_HTTP_POST;
    }

    /* Start timing Client Serialisation */
    time_clntSeria = GDKms();

    /* Create buffer for the RPC request message */
    b = buffer_create(MAX_BUF_SIZE);
    if (!b || b->len == 0) {
        GDKerror("CMDhttp_post: failed to create outgoing buffer\n");
        goto FINISH_HTTP_POST;
    }

    b->pos = snprintf(b->buf, b->len,
            "<?xml version='1.0' ?>\n"
            "<env:Envelope\n"
            "    xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n"
            "    xmlns:env=\"http://www.w3.org/2003/05/soap-envelope\">\n"
            "<env:Body>\n"
            "<XQueryRpcRequest\n"
            "    module=\"%s\"\n"
            "    uri=\"%s\"\n"
            "    method=\"%s\">\n",
            rpc_module, rpc_uri, rpc_method);

    /* Find the number of parameters and iterations. */
    argc  = *(int*)BUNtail(fun_vid, BUNprev(fun_vid, BUNlast(fun_vid)) ) - *(int*)BUNtail(fun_vid,BUNfirst(fun_vid)) + 1;
    iterc = *(int*)BUNtail(fun_iter,BUNprev(fun_iter,BUNlast(fun_iter)));

    if (!(argcnt = GDKmalloc(iterc * sizeof(int *)))) {
        GDKerror("CMDhttp_post: failed to malloc argcnt\n");
        goto FINISH_HTTP_POST;
    }
    for (i = 0; i < iterc; i++) {
        if (!(argcnt[i] = GDKmalloc(argc * sizeof(int)))) {
            GDKerror("CMDhttp_post: failed to malloc argcnt[%d]\n", i);
            goto FINISH_HTTP_POST;
        }
        for (a = 0; a < argc; a++) {
            argcnt[i][a] = 0;
        }
    }
    max_args = iterc * MAXPARAMS;

    /* Calculate the number of items contained by every parameter of
     * every iteration. */
    i = a = 0; /* i: iter counter; a: arg counter */
    iter_base = *(int*) BUNtail(fun_iter, BUNfirst(fun_iter));
    argc_base = *(int*) BUNtail(fun_vid, BUNfirst(fun_vid));
    for (p_vid  = BUNfirst(fun_vid),  p_iter = BUNfirst(fun_iter),
         p_item = BUNfirst(fun_item), p_kind = BUNfirst(fun_kind);

         p_vid  < BUNlast(fun_vid)  && p_iter < BUNlast(fun_iter) &&
         p_item < BUNlast(fun_item) && p_kind < BUNlast(fun_kind);

         p_vid  = BUNnext(fun_vid, p_vid),
         p_iter = BUNnext(fun_iter, p_iter),
         p_item = BUNnext(fun_item, p_item),
         p_kind = BUNnext(fun_kind, p_kind)) {

        if (nr_args == max_args) {
            GDKerror("CMDhttp_post: too many parameters.\n");
            goto FINISH_HTTP_POST;
        }

        i = *(int*) BUNtail(fun_iter, p_iter);
        a = *(int*) BUNtail(fun_vid, p_vid);
        argcnt[i - iter_base][a - argc_base]++;
        nr_args++;
    }
    max_args = nr_args; /* actual number of argval-s */
    nr_args = 0;

    for (my_iter = 0; my_iter < iterc; my_iter++) {
        if (argcnt[my_iter][0] > 0) {
            /* Enlarge the buffer is it is filled more than 80%.
             * FIXME: is this really necessary? Or should we just return an
             * error?
             */
            if (b->pos > (b->len * 0.8)) {
                b->len *= 2;
                b->buf = realloc(b->buf, b->len);
            }

            str2buf(b, "<iter>\n");

            for (my_argc = 0; my_argc < argc; my_argc++) {
                str2buf(b, "<param>\n");

                arg_offset = 0;
                /* add the 'argcnt' of all arg-s before 'me': */
                for (a = 0; a < my_argc; a++) {
                    for (i = 0; i < iterc; i++) {
                        arg_offset += argcnt[i][a];
                    }
                }
                /* add the 'argcnt' of iter-s before 'me': */
                for (i = 0; i < my_iter; i++) {
                    arg_offset += argcnt[i][my_argc];
                }
                /* now 'arg_offset' contains the index of the values and the
                 * types of MY iter and My argc in argval and argtpe */

                for (itemc = 0; itemc < argcnt[my_iter][my_argc]; itemc++) {
                    /* index into fun_item|fun_kind */
                    a = arg_offset + itemc;
                    type = *(int*)BUNtail(fun_kind, BUNptr(fun_kind, a));
                    if (type > WS_SIZE) {
                        str2buf(b, "<xs:anyNode>\n");

                        node_item = BUNins(BATnew(TYPE_void, TYPE_oid, 1),
                                BUNhead(fun_item, BUNptr(fun_item, a)),
                                BUNtail(fun_item, BUNptr(fun_item, a)), FALSE);
                        node_kind = BUNins(BATnew(TYPE_void, TYPE_int, 1),
                                BUNhead(fun_kind, BUNptr(fun_kind, a)),
                                BUNtail(fun_kind, BUNptr(fun_kind, a)), FALSE);
                        if (!(bs = buffer_wastream(b, "shred_node_param"))) {
                            GDKerror("CMDhttp_post: failed to create buffer_wastream"
                                    " to shred node parameter\n");
                            goto FINISH_HTTP_POST;
                        }
                        THRsetdata(0, bs);
                        xquery_print_result_main("xml-noheader-noroot", ws,
                                node_item, node_kind, int_values,
                                dbl_values, dec_values, str_values);
                        THRsetdata(0, bak);

                        str2buf(b, "</xs:anyNode>\n");
                    } else if (type == BOOL) {
                        value2buf(b, len, strptr, fun_item, a, i, TYPE_bit, int_values, "<xs:bool>", "</xs:bool>\n");
                    } else if (type == INT) {
                        value2buf(b, len, strptr, fun_item, a, i, TYPE_int, int_values, "<xs:integer>", "</xs:integer>\n");
                    } else if (type == DEC) {
                        value2buf(b, len, strptr, fun_item, a, i, TYPE_dbl, dbl_values, "<xs:decimal>", "</xs:decimal>\n");
                    } else if (type == DBL) {
                        value2buf(b, len, strptr, fun_item, a, i, TYPE_dbl, dbl_values, "<xs:double>", "</xs:double>\n");
                    } else if (type == STR || type == U_A) {
                        i = *(int*)BUNtail(fun_item, BUNptr(fun_item, a));
                        str_val = BUNtail(str_values, BUNptr(str_values, i));
                        b->pos += snprintf((b->buf + b->pos), (b->len - b->pos),
                                "<xs:string>\"%s\"</xs:string>\n", str_val);
                    } else {
                        GDKerror("CMDhttp_post: iter%d/param%d/item%d  has invalid type %d\n",
                                my_iter, my_argc, i);
                        goto FINISH_HTTP_POST;
                    }
                }
                str2buf(b, "</param>\n");
            }
            str2buf(b, "</iter>\n");
        }
    }
    str2buf(b, "</XQueryRpcRequest>\n</env:Body>\n</env:Envelope>\n");
    b->buf[b->pos] = 0;
    /* Stop timing Client Serialisation */
    time_clntSeria = GDKms() - time_clntSeria;

    /* Start timing Network Send Client2Server */
    time_clnt2Serv = GDKms();
    bytes_sent = stream_printf(out,
            "POST %s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Accept: text/html, text/xml, application/soap+xml\r\n"
            "Accept-Language: en-uk en-us\r\n"
            "Content-Type: text/html; charset=\"utf-8\"\r\n"
            "Content-Length: %d\r\n\r\n"
            "%s",
            HTTPD_FUNC, location, b->pos, b->buf);
    if (bytes_sent < (int)b->pos) {
        GDKerror("CMDhttp_post: failed to send XQuery RPC request.");
        goto FINISH_HTTP_POST;
    }
    /* Stop timing Network Send Client2Server */
    time_clnt2Serv= GDKms() - time_clnt2Serv;

    /*** Receive all response data ***/
    b->pos = b->buf[0] = 0;
    do{
        ret = stream_read(in, (b->buf + b->pos), 1, (b->len - b->pos));
        b->pos += ret;
        if (b->pos > (b->len * 0.8)) {
            b->len *= 2;
            b->buf = realloc(b->buf, b->len);
        }
    } while (ret > 0);

    b->buf[b->pos] = 0;
    bytes_received = b->pos;

    /* Start timing Client DeSerialisation */
    time_clntDeSeria = GDKms();
    if (b->pos < MIN_RESPONSE_SIZE || !strstr((b->buf + b->pos - 16), "</env:Envelope>")) {	
        GDKerror("CMDhttp_post: failed to get response: %s\n",
                errno?strerror(errno):"no errno available");
        if (b->pos < MIN_RESPONSE_SIZE)
            GDKerror("#bytes received: %ld\n", b->pos);
        else if (!strstr((b->buf + b->pos - 16), "</env:Envelope>"))
            GDKerror("cannot find \"</env:Envelope>\" in buffer");

        GDKerror("\nDump of received data:\n%s\n", b->buf);
        goto FINISH_HTTP_POST;
    }
    
    b->len = b->pos;
    b->buf = realloc(b->buf, b->len); /* release unused memory */
    strptr = strchr(b->buf, (int)' ') + 1; /* the HTTP return code */
    if (strptr[0] != '2' || strptr[1] != '0' || strptr[2] != '0' ) {
        GDKerror("CMDhttp_post: %s\n\n", b->buf);
        goto FINISH_HTTP_POST;
    } else if (strstr(strptr, "<env:Fault")) {
        /* Print the SOAP Fault Envelope */
        /* TODO: maybe it is better to shred the SOAP fault message
         *       and let the calling XQuery method handle it. */
        strptr = strstr((strptr + i + 1), "<env:");
        GDKerror("%s\n", strptr);
        goto FINISH_HTTP_POST;
    }

    /* Retrieve the SOAP Envelope from the response message */
    strptr = strstr(strptr, "<env:Envelope");

    if (CMDshred2bats(&shredBAT, "", strptr, "")  == GDK_FAIL) {
        GDKerror("CMDhttp_post: invalid XQuery RPC response received\n");
        goto FINISH_HTTP_POST;
    }

    *res = shredBAT;

    retval = GDK_SUCCEED;
    goto FINISH_HTTP_POST;

FINISH_HTTP_POST:
    cleanup(in, 1);
    cleanup(out, 1);
    cleanup(bs, 0);
    myfree(argcnt, i, iterc);
    if (sock > 0) close(sock);
    if (b) {
        if (b->len > 0) buffer_destroy(b);
        else            free(b);
    }

    time_clntDeSeria = GDKms() - time_clntDeSeria;
    if ((strstr(mode, "rpctime") != NULL) && (retval == GDK_SUCCEED)) {
        printf("\n");
        printf("Client_Serialisation: %d msec\n", time_clntSeria);
        printf("Network_Client_2_Server: %d msec\n", time_clnt2Serv);
        printf("Client_DeSerialisation: %d msec\n", time_clntDeSeria);
        printf("\n");
        printf("Data_Sent: %d bytes\n", bytes_sent);
        printf("Data_Received: %d bytes\n", bytes_received);
    }

    return retval;
}

int CMDhttpd_start(int* port, str option) {
    shttpd_socket ctx;
       
    /*
    if (rpc_receiver_running) {
        GDKerror("CMDhttpd_start: RPC receiver already running\n");
        return GDK_FAIL;
    }
    */
    if (option && strstr(option, "rpcservertime") != NULL){
        servertiming = 1;
    } else {
        servertiming = 0;
    }

    if (!rpc_receiver_running) {
        rpc_receiver_running = 1;

        /* Initialize with specific config file, pass NULL to use default values */
        shttpd_init(NULL);

        /* Register call back function */
        shttpd_register_url(HTTPD_FUNC, &handle_rpc_request, NULL);
    }

    /* Open listening socket */
    ctx = shttpd_open_port(*port);

    /* Serve connections infinitely until someone kills us */
    for (;rpc_receiver_running;) {
        shttpd_poll(&ctx, 200);
    }
    return GDK_SUCCEED;
}

bat* xquery_rpc_prelude() {
    /* Nothing to do here. */
    return NULL;
}

void xquery_rpc_epilogue() {
    /* Shut down the HTTP server. */
    shttpd_fini();

    /* stop RPC receiver */
    rpc_receiver_running = 0;
}

/* vim:set shiftwidth=4 expandtab: */
