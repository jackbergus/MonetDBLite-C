@ Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2007 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$
@'

@f xrpc_server
@a Ying Zhang

@t MIL primitives for XRPC server

@* Introduction
This module provides new MIL primitives for the server side support of
remote XQuery execution using HTTP connection on top of MonetDB for the
"AmbientDB" project.
@
@* Module Definition
@m
.MODULE xrpc_server;

@- HTTP server function(s)
@m
.COMMAND rpcd_start(int port, bit open, str options) : void = CMDrpcd_start;
"Start the HTTP server for RPC calls on the specified port."

.EPILOGUE = xrpc_epilogue;
.END xrpc_server;

@mil
# initialize xrpcd_admin: IPs that can execute modules from the special
# xrpc/admin directory
var xrpc_admin := bat(str,void);
xrpc_admin.insert(reverse(split(monet_environment.find("xrpc_admin"),";"))).bbpname("xrpc_admin");

# initialize xrpcd_user: IPs that can retrieve XML documents stored in
# the database using a URL of the form:
#               http://<host>[:port]/xrpc/<name>.xml
var xrpc_user := bat(str,void);
xrpc_user.insert(reverse(split(monet_environment.find("xrpc_user"),";"))).bbpname("xrpc_user");

# initialize xrpcd_trusted: URL prefixes for modules that anybody can execute
var xrpc_trusted := bat(str,void);
xrpc_trusted.insert(reverse(split(monet_environment.find("xrpc_trusted"),";"))).bbpname("xrpc_trusted");

proc add_xrpc_trusted(BAT[str,void] prefixes) : void {
    xrpc_trusted.insert(prefixes);
}

proc add_xrpc_trusted(BAT[void,str] prefixes) : void {
    xrpc_trusted.insert(prefixes.reverse());
}

proc add_xrpc_trusted(str prefix) : void {
    xrpc_trusted.insert(prefix, nil);
}

proc get_xrpc_open() : bit {
    if (monet_environment.exist("xrpc_open")){
        return bit(monet_environment.find("xrpc_open"));
    }
    ERROR("get_xrpc_open(): xrpc_open is not set\n");
}
ADDHELP("get_xrpc_open", "zhang", "Febuary 2007",
"DESCRIPTION:\n\
Find if the XRPC server should accept connections from other hosts",
"xrpc_server");

proc get_xrpc_port() : int {
    var xrpc_port := int_nil;

    if (monet_environment.exist("xrpc_port"))
      if (length(monet_environment.find("xrpc_port")) > 0)
        xrpc_port := int(monet_environment.find("xrpc_port"));

    if (isnil(xrpc_port)) {
        var mapi_port := int_nil;
        if (monet_environment.exist("mapi_port")){
            mapi_port := int(monet_environment.find("mapi_port"));
        } else {
            ERROR("get_xrpc_port(): mapi_port is not set\n");
        }
        xrpc_port := mapi_port+1;
    }
    return xrpc_port;
}
ADDHELP("get_xrpc_port", "zhang", "Febuary 2007",
"DESCRIPTION:\n\
find/calculate the port number to be used by the XRPC server",
"xrpc_server");

proc get_xrpc_options() : str {
    if (monet_environment.exist("xrpc_options")){
        return str(monet_environment.find("xrpc_options"));
    }
    return "";
}
ADDHELP("get_xrpc_options", "zhang", "March 2007",
"DESCRIPTION:\n\
Find the options that should be pass to the XRPC server, currently only\
\"timing\"",
"xrpc_server");

PROC rpcd_start() : void {
    var port := get_xrpc_port();
    xrpc_trusted.insert("http://127.0.0.1:"+str(port),nil);
    xrpc_trusted.insert("http://localhost:"+str(port),nil);
    if (monet_environment.find("monet_welcome") = "yes") 
        printf("%c XRPC administrative console at http://localhost:%d/admin\n", int(35), port);
    fork( rpcd_start(port, get_xrpc_open(), get_xrpc_options()) );
}
ADDHELP("rpcd_start", "zhang", "Febuary 2007",
"DESCRIPTION:\n\
Start XPRC receiver using the default values as specified in \
\"monet_environment\"",
"xrpc_server");

@h
#ifndef XRPC_SERVER_H
#define XRPC_SERVER_H

#include <gdk.h>
#include <mapi.h>
#include <time.h>

#ifdef _WIN32   /* Windows specific */
    #include <winsock.h>
    #define snprintf _snprintf
    #ifndef __MINGW32__
        #pragma comment(lib, "ws2_32")
    #endif
#else           /* UNIX specific */
    #include <sys/select.h>
    #include <sys/types.h>	/* used by socket */
    #include <sys/socket.h>
    #include <unistd.h>
    #include <netinet/in.h> /* hton and ntoh */
    #include <arpa/inet.h>  /* dotted IP addr to and from 32-bits int */
    #include <netdb.h>      /* convert domain names into IP addr */
    #include <errno.h>
    #include <ctype.h>
#endif

#include <stdio.h>
#include <stdlib.h>

#include "pathfinder.h"
#include "pf_support.h"
#include "shredder.h"
#include "serialize.h"
#include "shttpd.h"

#define XRPC_REQ_CALLBACK       "/xrpc"
#define XRPC_DOC_CALLBACK       "/xrpc/doc"
#define XRPC_ADM_CALLBACK       "/xrpc/admin"
#define ERR403                  "403 Forbidden"
#define ERR404                  "404 Bad Request"
#define ERR500                  "500 Internal Server Error"
#define OUT_OF_MEM              "Internal Receiver Error: out-of memory"
#define NOT_WELL_FORMED         "Request XML message not well-formed"
#define MAX_NR_PARAMS           32

#define MXQ_ADMIN   "http://monetdb.cwi.nl/XQuery/admin/"
#define SOAP_NS     "http://www.w3.org/2003/05/soap-envelope"
#define XDT_NS      "http://www.w3.org/2005/xpath-datatypes"
#define XS_NS       "http://www.w3.org/2001/XMLSchema"
#define XSI_NS      "http://www.w3.org/2001/XMLSchema-instance"
#define XRPC_NS     "http://monetdb.cwi.nl/XQuery"
#define XRPC_LOC    "http://monetdb.cwi.nl/XQuery/XRPC.xsd"

#define XRPC_HEADER "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"  \
                    "<env:Envelope xmlns:env=\"%s\""                \
                                 " xmlns:xrpc=\"%s\""               \
                                 " xmlns:xdt=\"%s\" "               \
                                 " xmlns:xs=\"%s\""                 \
                                 " xmlns:xsi=\"%s\""                \
                                 " xsi:schemaLocation=\"%s %s\">"   \
                      "<env:Body>"                                  \
                        "<xrpc:request xrpc:module=\"%s\""          \
                                     " xrpc:location=\"%s\""        \
                                     " xrpc:method=\"%s\""          \
                                     " xrpc:arity=\"%lld\""         \
                                     " xrpc:iter-count=\"%lld\""    \
                                     " xrpc:updCall=\"%s\">"

#define XRPC_HTTP_CALL "<xrpc:call>"                                    \
                         "<xrpc:sequence>"                              \
                           "<xrpc:atomic-value xsi:type=\"xs:string\">" \
                             "%s"                                       \
                           "</xrpc:atomic-value>"                       \
                         "</xrpc:sequence>"                             \
                       "</xrpc:call>"

#define XRPC_PUT_CALL  "<xrpc:call>"                                    \
                         "<xrpc:sequence>"                              \
                           "<xrpc:atomic-value xsi:type=\"xs:string\">" \
                             "%s"                                       \
                           "</xrpc:atomic-value>"                       \
                         "</xrpc:sequence>"                             \
                         "<xrpc:sequence>"                              \
                           "<xrpc:element>%s</xrpc:element>"            \
                         "</xrpc:sequence>"                             \
                       "</xrpc:call>"

#define XRPC_FOOTER     "</xrpc:request>"   \
                      "</env:Body>"         \
                    "</env:Envelope>\n"

#endif /* XRPC_SERVER_H */

@c
#include "pf_config.h"
#include "xrpc_server.h"
#include <stream_socket.h>

extern int xrpc_port;
int rpcd_running = 0;
int timing = 0;
int listen_socket = -1;
char datadir[1024];

BAT* xrpc_trusted = NULL;
BAT* xrpc_admin = NULL;

static INLINE void
clean_up(lng **argcnt,
         char **argtpe,
         char **argval,
         lng iterc,
         lng nr_args)
{
    lng i = 0;

    if(argcnt){
        for(i = 0; i < iterc; i++) GDKfree(argcnt[i]);
        GDKfree(argcnt);
    }
    if(argtpe){
        for(i = 0; i < nr_args; i++) GDKfree(argtpe[i]);
        GDKfree(argtpe);
    }
    if(argval){
        for(i = 0; i < nr_args; i++) GDKfree(argval[i]);
        GDKfree(argval);
    }
}

static INLINE void
send_err(stream *out,
         int header,
         char *http_err,
         char *soap_err,
         char *err_reason)
{
    if (header)
        stream_printf(out, "HTTP/1.1 %s\r\n"
                "Content-type: text/xml; charset=\"utf-8\"\r\n\r\n",
                http_err);
    stream_printf(out,
            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
            "<env:Envelope xmlns:env=\"%s\">"
            "<env:Body>"
            "<env:Fault>"
            "<env:Code><env:Value>%s</env:Value></env:Code>"
            "<env:Reason>"
            "<env:Text xml:lang=\"en\">%s</env:Text>"
            "</env:Reason>"
            "</env:Fault></env:Body></env:Envelope>\n",
            SOAP_NS, soap_err, err_reason);
    stream_flush(out);
}

/**
 * Retrieves the request message from the connection and shred it to
 * BATs.
 *
 * @return BATs containing the shredded request message, or
 *         NULL if an error has occurred.
 */
static BAT *
request2bat(stream *out, char *reqmsg)
{
    char *strptr = NULL;
    lng percentage = 0;
    BAT *shredBAT = NULL;
    bit verbose = FALSE;

    if(!reqmsg){
        send_err(out, 1, ERR404, "env:Sender", "No request message!");
        return NULL;
    }

    /* Remove the first line of the message, which containing
     * "<?xml...?>", so that the message we pass to CMDshred2bats starts
     * directly with <env:Envelope ...> */
    strptr = reqmsg + 7; /* strlen("<?xml...?>") >= 7 */
    if( (strstr(reqmsg, "<?xml") != reqmsg) ||
        (strptr = strchr(strptr, (int)'<')) == NULL ) {
        send_err(out, 1, ERR404, "env:Sender", NOT_WELL_FORMED);
        return NULL;
    }
    if (!(shredBAT = BATnew(TYPE_str, TYPE_bat, 32))) {
        send_err(out, 1, ERR500, "env:Receiver", OUT_OF_MEM);
        return NULL;
    }
    
    if( CMDshred_str(shredBAT, strptr, &percentage, NULL, &verbose) == GDK_FAIL ) {
        send_err(out, 1, ERR404, "env:Sender", NOT_WELL_FORMED);
        BBPreclaim(shredBAT);
        shredBAT = NULL;
    }
    return shredBAT;
}

/**
 * Checks if a prefix of 'key' is present in a bat with a list of allowed prefixes
 *
 * Return 1 if yes, 0 otherwise.
 */
static int 
isAllowed(BAT *allowed, char* key)
{
    BUN p,q;
    BATloop(allowed, p, q) {
        char* prefix = BUNhead(allowed,p);
        if (strncmp(key, prefix, strlen(prefix)) == 0)  
            return 1;
    }
    return (BATcount(allowed) == 0);
}

/**
 * Checks if the prefix of 'location' is listed in "xrpc_trusted".
 *
 * Return 1 if yes, 0 otherwise.
 */
static int
isTrusted(stream *out, char *location)
{
    if (!isAllowed(xrpc_trusted, location)) {
        char * msg = "Called module not allowed:";
        size_t len = strlen(msg) + strlen(location) + 11;
        size_t len_x = 0, pos = 0;
        char * err;
        BUN p,q;
        BATloop(xrpc_trusted, p, q) {
            char* prefix = BUNhead(xrpc_trusted, p);
            len_x += strlen(prefix) + 4;
        }
        err = alloca(len + len_x);
        if (err) {
            len += len_x;
        } else {
            len_x = 0;
            err = alloca(len);
        }
        assert(err);
        pos += snprintf(err+pos, len-pos, "%s", msg);
        if (!len_x) {
            pos += snprintf(err+pos, len-pos, " '%s'.", location);
        } else {
            pos += snprintf(err+pos, len-pos, "\n'%s' not in", location);
            BATloop(xrpc_trusted, p, q) {
                char* prefix = BUNhead(xrpc_trusted, p);
                pos += snprintf(err+pos, len-pos, "\n'%s',", prefix);
            }
            err[pos-1] = '.';
        }
        send_err(out, 1, ERR403, "env:Sender", err);
        return 0;
    }
    return 1;
}

/**
 * Calculate the number of *nodes* which has the name "node_name" and
 * are within the range 'start_pre' and 'end_pre' (inclusive).
 *
 * @return the number of nodes found
 */
static lng
count_node(char *node_name,
           char *ns,
           oid   start_pre,
           oid   end_pre,
           oid  *pre_prop,
           char *pre_kind,
           BAT  *qn_loc,
           BAT  *qn_uri)
{
    lng nr = 0;
    oid i;

    for (i = start_pre; i <= end_pre; i++) {
        if (pre_kind[i] == ELEMENT) {
            char *qname = BUNtail(qn_loc,
                            BUNfnd(qn_loc, &(pre_prop[i])));
            char *qname_uri = BUNtail(qn_uri,
                                BUNfnd(qn_uri, &(pre_prop[i])));
            if(strcmp(qname, node_name) == 0 &&
               strcmp(qname_uri, ns)== 0)
                nr++;
        }
    }
    return nr;
}

/**
 * Find the 'pre' value of the first node between 'start_pre' and
 * 'end_pre' (inclusive), which kind is 'elem_kind'.
 *
 * @return the 'pre' value of this node, or
 *         0 if such node can not be found.
 */
static oid
get_elem_pre(oid start_pre,
             oid end_pre,
             char elem_kind,
             char *pre_kind)
{
    oid i;

    for (i = start_pre; i <= end_pre; i++) {
        if (pre_kind[i] == elem_kind)
            return i;
    }
    return 0;
}

/**
 * Given a 'node_name', find the 'pre' value of the first node between
 * 'start_pre' and 'end_pre' (inclusive), which kind is 'elem_kind'.
 * 
 * @return the 'pre' value of this node, or
 *         0 if such node can not be found.
 */
static oid
get_elem_pre_by_name(char *node_name,
                     char *ns,
                     oid   start_pre,
                     oid   end_pre,
                     char  elem_kind,
                     oid  *pre_prop,
                     char *pre_kind,
                     BAT  *qn_loc,
                     BAT  *qn_uri)
{
    oid i;

    for (i = start_pre; i <= end_pre; i++) {
        if (pre_kind[i] == elem_kind) {
            char *qname = BUNtail(qn_loc,
                            BUNfnd(qn_loc, &(pre_prop[i])));
            char *qname_uri = BUNtail(qn_uri,
                                BUNfnd(qn_uri, &(pre_prop[i])));
            if(strcmp(qname, node_name) == 0 &&
               strcmp(qname_uri, ns)== 0)
                return i;
        }
    }
    return 0;
}

/**
 * Find the value of the attribute 'attr_name', which is owned by the
 * node with the given 'pre' value.
 *
 * NB: DO NOT free the string returned by this function, because it is
 *     not copied!!!
 *
 * @return The value of the attribute 'attr_name', or
 *         NULL if attribute with such name was not found.
 */
static char *
get_attr_val(stream *out,
             int    optional,
             char  *attr_name,
             char  *ns,
             oid    pre,
             size_t nattrs,
             oid   *attr_own,
             oid   *attr_qn,
             oid   *attr_prop,
             BAT   *qn_loc,
             BAT   *qn_uri,
             BAT   *prop_val)
{
    oid qn = oid_nil ;
    size_t i = 0;
    int first = 0, len = 0;
    char *err = NULL;

    len = strlen(attr_name) + strlen(ns) + 128;
    err = alloca(len);  assert(err);

    /* Get the 'qn' of 'attr_name'.  For now, all XRPC attributes may
     * appear only once in the message, so the combination of ns+loc
     * should be unique. */
    BAT *qns = BATselect(qn_loc, attr_name, attr_name);
    BAT *nss = BATselect(qn_uri, ns, ns);
    BAT *match = BATkintersect(qns, nss);

    i = BATcount(match);
    if(i > 1){
        snprintf(err, len, "Invalid XRPC request message: multiple "
                "definitions of attribute %s:%s\n", ns, attr_name);
        send_err(out, 1, ERR404, "env:Sender", err);
        BBPreclaim(qns);
        BBPreclaim(nss);
        BBPreclaim(match);
        return NULL;
    } else if (i == 1) {
        qn = *(oid*) BUNhead(match, BUNfirst(match));

        BBPreclaim(qns);
        BBPreclaim(nss);
        BBPreclaim(match);

        /* try to find the attribute value */
        for (i = 0; i < nattrs; i++) {
            if (attr_own[i] > pre) break;
            if (attr_own[i] == pre && attr_qn[i] == qn) {
                first = BUNindex(prop_val, BUNfirst(prop_val)) +
                    attr_prop[i];
                return (char*) BUNtail(prop_val,
                        BUNptr(prop_val, first));
            }
        }
    }

    if(!optional) {
        snprintf(err, len,
                "Could not find required attribute \"%s:%s\"",
                ns, attr_name);
        send_err(out, 1, ERR404, "env:Sender", err);
    }
    return NULL;
}

/**
 * Given the pre value of a type node, return the name of the type node
 * as a string in the form 'ns_uri:loc'.
 *
 * NB: the return value of this function, if not NULL, should be freed.
 *
 * @return the name of the type node, or
 *         NULL if anything went wrong.
 */
static char *
get_type(oid  tpe_node_pre,
         oid *pre_prop,
         BAT *qn_loc)
{
    char *loc = (char*)BUNtail(qn_loc,
                    BUNptr(qn_loc, pre_prop[tpe_node_pre]));
    char *prefix = "xs";
    if(strcmp(loc, "atomic-value") == 0){
        prefix = "xrpc";
    }

    int l_len = strlen(loc);
    int p_len = strlen(prefix);
    char *res = GDKmalloc(p_len + l_len + 2);
    if(!res) return NULL;

    strncpy(res, prefix, p_len);
    res[p_len]=':';
    strncpy((res + p_len + 1), loc, l_len);
    res[p_len+l_len+1] = '\0';
    return res;
}

/**
 * Stores values of attributes "module", "location" and "method" in the
 * given parameter.
 *
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int
getFunctionInfo(stream *out,
                oid pre,
                lng nattrs,
                oid *attr_ownT,
                oid *attr_qnT,
                oid *attr_propT,
                BAT *qn_loc,
                BAT *qn_uri,
                BAT *prop_val,
                str *_module,
                str *_location,
                str *_method) {
    char *module = NULL, *location = NULL, *method = NULL;

    if (!(module = get_attr_val(out, 0, "module", XRPC_NS, pre, nattrs,
                    attr_ownT, attr_qnT, attr_propT, qn_loc, qn_uri,
                    prop_val)))
        return GDK_FAIL;

    if (!(method = get_attr_val(out, 0, "method", XRPC_NS, pre, nattrs,
                    attr_ownT, attr_qnT, attr_propT, qn_loc, qn_uri,
                    prop_val)))
        return GDK_FAIL;

    if (!(location = get_attr_val(out, 0, "location", XRPC_NS, pre,
                    nattrs, attr_ownT, attr_qnT, attr_propT, qn_loc,
                    qn_uri, prop_val)))
        return GDK_FAIL;

    *_module = module;
    *_location = location;
    *_method = method;
    return GDK_SUCCEED;
}

static lng
my_strtoll(stream *out, char *val_ptr, char *attr_name)
{
    char err[2048];

    errno = 0;
    lng ret = strtoll(val_ptr, NULL, 10);

    if(errno){
        snprintf(err, 2048,
                "Invalid value (\"%s\") of attribute \"%s\": %s",
                val_ptr, attr_name, strerror(errno));
        send_err(out, 1, ERR404, "env:Sender", err);
        return -1;
    }

    if(ret < 0){
        snprintf(err, 2048,
                "Invalid value (\"%s\") of attribute \"%s\": "
                "should not be negative",
                val_ptr, attr_name);
        send_err(out, 1, ERR404, "env:Sender", err);
        return -1;
    }
    return ret;
}

/**
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int 
getCallValues(stream *out,
              BAT *shredBAT,
              bit isAdmin,
              str *module,
              str *location,
              str *method,
              bit *_isSimpleParam,
              lng *_argc,
              lng *_iterc,
              lng *_nr_args,
              lng ***_argcnt,
              str **_argtpe,
              str **_argval)
{
    bit isSimpleParam = 1;
    lng argc = 0, iterc = 0, nr_args = 0;
    lng **argcnt;
    str *argtpe = NULL, *argval = NULL;

    lng i = 0, j = 0, k = 0, nattrs = 0;
    lng max_args = MAX_NR_PARAMS;
    char errstr[1024];

    BAT *frag_root = NULL, *pre_size = NULL;
    BAT *pre_level = NULL, *pre_kind = NULL,  *pre_prop = NULL;
    BAT *qn_loc   = NULL,  *qn_uri = NULL;
    BAT *prop_val = NULL,  *prop_text = NULL;
    BAT *attr_own = NULL,  *attr_qn = NULL, *attr_prop = NULL;
    /* Arrays holding the Tail values of some of the BATs above. */
    int   *pre_sizeT = NULL;
    char  *pre_levelT = NULL, *pre_kindT = NULL;
    char  *text_base = NULL; /* text base of prop_text tail values */
    oid   *attr_ownT = NULL, *attr_qnT = NULL, *attr_propT = NULL;
    oid   *pre_propT = NULL;
    var_t *prop_textT = NULL;

    oid pre = 0, last_pre = 0, val_node_pre = 0;
    oid seq_node_pre = 0,  call_node_pre = 0,  tpe_node_pre = 0;
    lng seq_node_size = 0, call_node_size = 0, tpe_node_size = 0;
    
    /* We need to clean up the pre_size, pre_level, pre_prop and
     * pre_kind values between two node values, to prevent that
     * a node value is treated as part of the message */
    oid start_invalidate = 0; /* indicates from which node we should
                                 start with invalidation */
    char level_diff = 0; /* indicates how many levels each pre_level
                            value of a node should be reduced. */

    i = BUNindex(shredBAT,BUNfirst(shredBAT));
    pre_size   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+PRE_SIZE) ));
    pre_level  = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+PRE_LEVEL)));
    pre_prop   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+PRE_PROP) ));
    pre_kind   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+PRE_KIND) ));
    prop_text  = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+PROP_TEXT)));
    text_base  = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+PROP_TEXT)))->theap->base;
    prop_val   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+PROP_VAL) ));
    qn_loc     = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+QN_LOC)   ));
    qn_uri     = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+QN_URI)   ));
    frag_root  = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+FRAG_ROOT)));
    attr_own   = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+ATTR_OWN) ));
    attr_qn    = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+ATTR_QN)  ));
    attr_prop  = BBP_cache(*(bat*)BUNtail(shredBAT,BUNptr(shredBAT,i+ATTR_PROP)));

    pre_sizeT  = (int*)  BUNfirst(pre_size);
    pre_levelT = (char*) BUNfirst(pre_level);
    pre_propT  = (oid*)  BUNfirst(pre_prop);
    pre_kindT  = (char*) BUNfirst(pre_kind);
    prop_textT = (var_t*)BUNfirst(prop_text);
    attr_ownT  = (oid*)  BUNfirst(attr_own);
    attr_qnT   = (oid*)  BUNfirst(attr_qn);
    attr_propT = (oid*)  BUNfirst(attr_prop);

    pre_level  = BATsetaccess(pre_level, BAT_WRITE);
    frag_root  = BATsetaccess(frag_root, BAT_APPEND);
    nattrs     = BATcount(attr_prop);
    last_pre   = (oid)pre_sizeT[0]; /* last 'pre' number, save it before
                                       it is overwritten. */

    /* There are at least two nodes before "request", namely "Envelope"
     * and "Body" (a "Header" node is optional). There are at least one
     * node after "request", namely "sequence". */
    if (!(pre = get_elem_pre_by_name("request", XRPC_NS, 2,
                    (last_pre - 1), ELEMENT, pre_propT, pre_kindT,
                    qn_loc, qn_uri))) {
        send_err(out, 1, ERR404, "env:Sender",
                "\"request\" node not found");
        return GDK_FAIL;
    }

    if(getFunctionInfo(out, pre, nattrs,
                        attr_ownT, attr_qnT, attr_propT,
                        qn_loc, qn_uri, prop_val,
                        module, location, method) == GDK_FAIL ||
        (!isAdmin && !isTrusted(out, *location)) )
        return GDK_FAIL;

    char *val_ptr = NULL;
    val_ptr = get_attr_val(out, 1, "iter-count", XRPC_NS, pre, nattrs,
            attr_ownT, attr_qnT, attr_propT, qn_loc, qn_uri, prop_val);
    if(!val_ptr) {
        /* the optional attribute "iter-count" is not available, so just
         * count the number of "call" node */
        iterc = count_node("call", XRPC_NS, pre+1, last_pre, pre_propT,
                pre_kindT, qn_loc, qn_uri);
    } else {
        iterc = my_strtoll(out, val_ptr, "iter-count");
        if(iterc < 0 )
            return GDK_FAIL;
        i = count_node("call", XRPC_NS, pre+1, last_pre, pre_propT,
                pre_kindT, qn_loc, qn_uri);
        if (iterc != i) {
            snprintf(errstr, 1024, "The value (%lld) of the attribute "
                    "\"iter-count\" does not match the number of \"call\" "
                    "nodes (%lld) in the request message", iterc, i);
            send_err(out, 1, ERR404, "env:Sender", errstr);
            return GDK_FAIL;
        }
    }

    val_ptr = get_attr_val(out, 0, "arity", XRPC_NS, pre, nattrs,
                           attr_ownT, attr_qnT, attr_propT, qn_loc,
                           qn_uri, prop_val);
    if(!val_ptr)
        return GDK_FAIL;
    argc = my_strtoll(out, val_ptr, "arity");
    if(argc < 0 )
        return GDK_FAIL;
    i = count_node("sequence", XRPC_NS, pre+2, last_pre, pre_propT,
            pre_kindT, qn_loc, qn_uri) / iterc;
    if(argc != i){
        snprintf(errstr, 1024, "The value (%lld) of the attribute "
                "\"arity\" does not match the number of \"sequence\" "
                "nodes (%lld) in each \"call\" node in the request "
                "message", argc, i);
        send_err(out, 1, ERR404, "env:Sender", errstr);
        return GDK_FAIL;
    }

    if (!(argcnt = GDKmalloc(iterc * sizeof(lng*)))) {
        send_err(out, 1, ERR500, "env:Receiver", OUT_OF_MEM);
        clean_up(argcnt, argtpe, argval, iterc, nr_args);
        return GDK_FAIL;
    }
    for (i = 0; i < iterc; i++) {
        /* we allocate _at least one_ argcnt for each parameter, so that
         * we have a place to note that a function has zero parameter */
        argcnt[i] = GDKmalloc( (argc>0?argc:1) * sizeof(lng) );
        if(!argcnt[i]){
            send_err(out, 1, ERR500, "env:Receiver", OUT_OF_MEM);
            clean_up(argcnt, argtpe, argval, iterc, nr_args);
            return GDK_FAIL;
        }
        argcnt[i][0] = 0;
        for (j = 1; j < argc; j++)
            argcnt[i][j] = 0;
    }

    max_args = iterc * (argc>0?argc:1) * MAX_NR_PARAMS;
    argval = GDKmalloc(max_args * sizeof(char *));
    argtpe = GDKmalloc(max_args * sizeof(char *));
    if (!argval || !argtpe) {
        send_err(out, 1, ERR500, "env:Receiver", OUT_OF_MEM);
        clean_up(argcnt, argtpe, argval, iterc, nr_args);
        return GDK_FAIL;
    }
   
    /* Fill the arrays 'argcnt', 'argval', 'argtpe' */
    call_node_pre = pre;
    for (i = 0; i < iterc; i++) {
        call_node_pre  = get_elem_pre_by_name("call", XRPC_NS,
                (call_node_pre + call_node_size + 1), last_pre, ELEMENT,
                pre_propT, pre_kindT, qn_loc, qn_uri);
        call_node_size = pre_sizeT[call_node_pre];
        if (call_node_size == 0) continue;

        seq_node_pre = call_node_pre;
        for (j = 0; j < argc; j++) {
            seq_node_pre  = get_elem_pre_by_name("sequence", XRPC_NS,
                    seq_node_pre+1, (call_node_pre + call_node_size),
                    ELEMENT, pre_propT, pre_kindT, qn_loc, qn_uri);
            if (seq_node_pre == 0) continue; /* This function call has
                                                no parameters */
            seq_node_size = pre_sizeT[seq_node_pre];
            if (seq_node_size == 0) continue;
       
            tpe_node_pre = seq_node_pre + 1; k = 1;
            while((tpe_node_pre <= (seq_node_pre + seq_node_size)) && 
                  (tpe_node_pre = get_elem_pre(tpe_node_pre,
                                          (seq_node_pre+seq_node_size),
                                          ELEMENT, pre_kindT)) > 0){
                tpe_node_size = pre_sizeT[tpe_node_pre];

                if (nr_args == max_args) {
                    max_args += 2048;
                    char **bptr = GDKrealloc(argval, max_args * sizeof(char *));
                    if (!bptr) {
                        send_err(out, 1, ERR500, "env:Receiver",OUT_OF_MEM);
                        clean_up(argcnt,argtpe,argval,iterc,nr_args);
                        return GDK_FAIL;
                    }
                    argval = bptr;

                    bptr = GDKrealloc(argtpe, max_args * sizeof(char *));
                    if (!bptr) {
                        send_err(out, 1, ERR500, "env:Receiver",OUT_OF_MEM);
                        clean_up(argcnt,argtpe,argval,iterc,nr_args);
                        return GDK_FAIL;
                    }
                    argtpe = bptr;
                }

                if (!(argtpe[nr_args] = get_type(tpe_node_pre,
                                            pre_propT, qn_loc)))
                {
                    send_err(out, 1, ERR500, "env:Receiver",OUT_OF_MEM);
                    clean_up(argcnt,argtpe,argval,iterc,nr_args);
                    return GDK_FAIL;
                }
                
                if(strcmp(argtpe[nr_args], "xrpc:atomic-value") == 0) {
                    GDKfree(argtpe[nr_args]); /* find sub-type of the
                                                 atomic-value */
                    char *tptr = get_attr_val(out, 0, "type", XSI_NS,
                                    tpe_node_pre, nattrs, attr_ownT,
                                    attr_qnT, attr_propT, qn_loc,
                                    qn_uri, prop_val);
                    if(!tptr){
                        send_err(out, 1, ERR404, "env:Sender",
                                "XRPC request: an \"atomic-value\" "
                                "node must have a \"type\" attribute");
                        clean_up(argcnt,argtpe,argval,iterc,nr_args);
                        return GDK_FAIL;
                    }
                    argtpe[nr_args] = GDKstrdup(tptr);

                    val_node_pre = tpe_node_pre + 1;
                    if( (tpe_node_size != 1) || 
                        (pre_kindT[val_node_pre] != TEXT) ) {
                        snprintf(errstr, 1024, "XRPC request: "
                                "iteration" LLFMT "/parameter" LLFMT
                                                  "/value" LLFMT " "
                                "of type \"%s\" is expected to have a "
                                "simple value",
                                i+1, j+1, k, argtpe[nr_args]);
                        send_err(out, 1, ERR404, "env:Sender", errstr);
                        clean_up(argcnt,argtpe,argval,iterc,nr_args);
                        return GDK_FAIL;
                    }
                    argval[nr_args] = GDKstrdup(text_base +
                            prop_textT[pre_propT[val_node_pre]]);
                } else if (strcmp(argtpe[nr_args], "xs:attribute") == 0) {
                    /* 32-bytes is enough to hold the string
                     * representation of the largest 64bits OID value */
                    argval[nr_args] = GDKmalloc(32);
                    if (!argval[nr_args]) {
                        send_err(out,1,ERR500,"env:Receiver",OUT_OF_MEM);
                        clean_up(argcnt,argtpe,argval,iterc,nr_args);
                        return GDK_FAIL;
                    }

                    val_node_pre = 0;
                    int off;
                    for (off = 0; off < nattrs; off++) {
                        if (attr_ownT[off] == tpe_node_pre) {
                            val_node_pre = off;
                            break;
                        }
                    }
                    if (val_node_pre == 0) {
                        snprintf(errstr, 1024, "XRPC request: "
                                "iteration" LLFMT "/param" LLFMT "/value" LLFMT " "
                                "does not contain a *node* value",
                                i+1, j+1, k);
                        send_err(out, 1, ERR404, "env:Sender", errstr);
                        clean_up(argcnt,argtpe,argval,iterc,nr_args);
                        return GDK_FAIL;
                    }

                    snprintf(argval[nr_args], 32, OIDFMT, val_node_pre);
                    isSimpleParam = 0;
                } else {
                    /* 32-bytes is enough to hold the string
                     * representation of the largest 64bits OID value */
                    argval[nr_args] = GDKmalloc(32);
                    if (!argval[nr_args]) {
                        send_err(out,1,ERR500,"env:Receiver",OUT_OF_MEM);
                        clean_up(argcnt,argtpe,argval,iterc,nr_args);
                        return GDK_FAIL;
                    }

                    if(strcmp(argtpe[nr_args], "xs:element") == 0) {
                        val_node_pre = get_elem_pre(tpe_node_pre+1,
                                (tpe_node_pre+tpe_node_size), ELEMENT,
                                pre_kindT);
                    } else if (strcmp(argtpe[nr_args], "xs:text") == 0) {
                        val_node_pre = get_elem_pre(tpe_node_pre+1,
                                (tpe_node_pre+tpe_node_size), TEXT,
                                pre_kindT);
                    } else if (strcmp(argtpe[nr_args], "xs:comment") == 0) {
                        val_node_pre = get_elem_pre(tpe_node_pre+1,
                                (tpe_node_pre+tpe_node_size), COMMENT,
                                pre_kindT);
                    } else if(strcmp(argtpe[nr_args],
                                "xs:processing-instruction") == 0) {
                        val_node_pre = get_elem_pre(tpe_node_pre+1,
                                (tpe_node_pre+tpe_node_size), PI,
                                pre_kindT);
                    } else if (strcmp(argtpe[nr_args], "xs:document") == 0) {
                        val_node_pre = tpe_node_pre;
                        pre_kindT[val_node_pre] = 4;
                        pre_propT[val_node_pre] = oid_nil;
                    } else {
                        snprintf(errstr, 1024, "XRPC request: "
                                "iteration" LLFMT "/param" LLFMT
                                                  "/value" LLFMT " "
                                "contains unsupported type: %s\n",
                                i+1, j+1, k, argtpe[nr_args]);
                        send_err(out, 1, ERR404, "env:Sender", errstr);
                        clean_up(argcnt,argtpe,argval,iterc,nr_args);
                        return GDK_FAIL;
                    }

                    if (val_node_pre == 0) {
                        snprintf(errstr, 1024, "XRPC request: "
                                "iteration" LLFMT "/param" LLFMT
                                                  "/value" LLFMT " "
                                "does not contain a *node* value",
                                i+1, j+1, k);
                        send_err(out, 1, ERR404, "env:Sender", errstr);
                        clean_up(argcnt,argtpe,argval,iterc,nr_args);
                        return GDK_FAIL;
                    }

                    snprintf(argval[nr_args], 32, OIDFMT, val_node_pre);
                    frag_root = BUNappend(frag_root, (ptr)&val_node_pre, TRUE);
                    isSimpleParam = 0;

                    /* reassign level values for the ELEM nodes */
                    level_diff = pre_levelT[val_node_pre];
                    if(strcmp(argtpe[nr_args], "xs:document") == 0)
                        level_diff++;
                    unsigned long long l = val_node_pre;
                    for( ; l <= (val_node_pre + pre_sizeT[val_node_pre]); l++){
                        pre_levelT[l] -= level_diff;
                    }
                    for (l = start_invalidate; l < val_node_pre; l++) {
                        pre_levelT[l] = -3;
                        pre_sizeT[l] = 0;
                    }
                    start_invalidate = val_node_pre + pre_sizeT[val_node_pre] + 1;
                }
                /* skip all children of tpe_node and go to the next
                 * possible tpe_node */
                tpe_node_pre += (tpe_node_size + 1);
                argcnt[i][j]++;
                nr_args++;
                k++;
            } /* end WHILE 'tpe_node_pre' */
        } /* end FOR 'argc' */
    } /* end FOR 'iterc' */

    *_isSimpleParam = isSimpleParam;
    *_argc = argc;
    *_iterc = iterc;
    *_nr_args = nr_args;
    *_argcnt = argcnt;
    *_argtpe = argtpe;
    *_argval = argval;
    return GDK_SUCCEED;
}

/**
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int
execQuery(mapi_client *mc,
          int serializeMode,
          char *module,
          char *location,
          char *method,
          lng argc,
          lng iterc,
          lng **argcnt,
          str *argtpe,
          str *argval,
          BAT *shredBAT)
{
	char errbuf[GDKMAXERRLEN], *errbuf_bak = GDKerrbuf;

    /* Possible values of serializeMode:
     * 0: xml-noheader-xrpc
     *    This is the normal serialize mode used for XRPC calls
     * 1: timing-xml-noheader-xrpc
     *    Let the XRPC server print the time of XRPC_Server_Application
     *    and XRPC_Network_Server_2_Client at the server side.
     * 2: xml
     *    Used for the GET, PUT, DELETE HTTP requests to avoid "xrpc"
     *    mode of serialization
     * 3. timing-xml
     *    Again, print time info at the XRPC server side, but is usually
     *    not used.
     */
    stream_printf(mc->c->fdout, "HTTP/1.1 200 OK\r\n"
            "Content-type: text/xml; "
            "charset=\"utf-8\"\r\n\r\n");

	*errbuf = 0;
	GDKsetbuf(errbuf);
    char *err = xquery_method(mc, serializeMode, module, location,
                              method, argc, iterc, argcnt, argtpe,
                              argval, shredBAT);
    if (err) {
        if(err == ((char*)-1)) {
            err = errbuf;
        }
        send_err(mc->c->fdout, 0, "", "env:Sender", err);
        return GDK_FAIL;
    }
    stream_flush(mc->c->fdout);
	GDKsetbuf(errbuf_bak);

    return GDK_SUCCEED;
}

/**
 * The XRPC server callback function.
 *
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int 
xrpc_handle_request(mapi_client *mc, struct shttpd_callback_arg *arg)
{
    BAT *shredBAT;
    char *module = NULL, *location = NULL, *method = NULL;
    bit isSimpleParam = 1;
    lng argc = 0, iterc = 0, nr_args = 0;
    lng time_xrpcServDeSeria;
    lng **argcnt = NULL; /* argcnt[iterc][argc] */
    str *argtpe = NULL, *argval = NULL;
    int serializeMode = timing; 

    time_xrpcServDeSeria = GDKusec();
    shredBAT = request2bat(mc->c->fdout, shttpd_get_msg(arg));
    if(!shredBAT)
        return GDK_FAIL;

    if( getCallValues(mc->c->fdout, shredBAT, 0,
                      &module, &location, &method,
                      &isSimpleParam, &argc, &iterc, &nr_args,
                      &argcnt, &argtpe, &argval) == GDK_FAIL ) {
        BBPreclaim(shredBAT);
        return GDK_FAIL;
    }
    time_xrpcServDeSeria = GDKusec() - time_xrpcServDeSeria;
    
    /* Execute the query and send XRPC response */
    if(execQuery(mc, serializeMode, module, location, method,
                 argc, iterc, argcnt, argtpe, argval,
                 isSimpleParam?NULL:shredBAT) == GDK_FAIL) {
        clean_up(argcnt, argtpe, argval, iterc, nr_args);
        BBPreclaim(shredBAT);
        return GDK_FAIL;
    }

    if (timing) {
        fprintf(stdout,
                "XRPC_Server_DeSerialisation:   " LLFMT " microsec\n",
                time_xrpcServDeSeria);
    }

    clean_up(argcnt, argtpe, argval, iterc, nr_args);
    BBPreclaim(shredBAT);
    return GDK_SUCCEED;
}


/**
 * The MonetDB/XQuery Document Management callback function.
 *
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int 
xrpc_handle_admin_request(mapi_client *mc, struct shttpd_callback_arg *arg)
{
    char *module = NULL, *location = NULL, *method = NULL;
    int ret, serializeMode = 0;
    bit isSimpleParam = 1;
    BAT *shredBAT;
    lng argc = 0, iterc = 0, nr_args = 0;
    lng **argcnt;
    str *argtpe, *argval;
    char dotted[80];

    struct in_addr addr = shttpd_get_inAddr(arg);
#ifdef HAVE_INET_NTOP
    (void) inet_ntop(AF_INET, (void*) &addr, dotted, sizeof(dotted));
#else
    /* not normally thread safe, but on Windows where we need this it
     * actually *is* thread safe */
    strncpy(dotted, inet_ntoa(addr), sizeof(dotted));
#endif
    if (!isAllowed(xrpc_admin, dotted)) {
        char err[1024];
        snprintf(err, 1024, "Permission denied: your host (%s) "
                "does not have admin rights", dotted);
        send_err(mc->c->fdout, 1, ERR403, "env:Sender", err);
        return GDK_FAIL;
    }

    shredBAT = request2bat(mc->c->fdout, shttpd_get_msg(arg));
    if(!shredBAT)
        return GDK_FAIL;

    if(getCallValues(mc->c->fdout, shredBAT, 1,
                     &module, &location, &method,
                     &isSimpleParam, &argc, &iterc, &nr_args,
                     &argcnt, &argtpe, &argval) == GDK_FAIL){
        BBPreclaim(shredBAT);
        return GDK_FAIL;
    }

    if(strcmp(module, MXQ_ADMIN) != 0){
        send_err(mc->c->fdout, 1, ERR404, "env:Sender",
                "Invalid namespace of admin module");
        clean_up(argcnt, argtpe, argval, iterc, nr_args);
        BBPreclaim(shredBAT);
        return GDK_FAIL;
    }

    ret = execQuery(mc, serializeMode, module, location, method, argc,
            iterc, argcnt, argtpe, argval, isSimpleParam?NULL:shredBAT);

    clean_up(argcnt, argtpe, argval, iterc, nr_args);
    BBPreclaim(shredBAT);
    return ret;
}

/**
 * Handle the document retrieving request using a URL of the form:
 *          http://<host>[:port]/xrpc/<name>.xml
 *
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int 
xrpc_handle_file_request(mapi_client *mc, struct shttpd_callback_arg *arg)
{
    char *method = NULL, *uri = shttpd_get_uri(arg);
    char location[1024];
    int ret = GDK_FAIL;
    lng **argcnt = NULL;

    lng time_xrpcServDeSeria = GDKusec();

    /* skip callback identifier that directed us here */
    uri += strlen(XRPC_DOC_CALLBACK);

    /* we don't always have the second '/' */
    if(uri[0] == '/') uri++;
    if(uri[0] == '\0'){
        send_err(mc->c->fdout, 1, ERR403, "env:Sender",
                "Directory listing denied");
        return GDK_FAIL;
    }
    snprintf(location, 1024, "http://localhost:%d/admin/admin.xq", xrpc_port);
    method = shttpd_get_method(arg);
    argcnt = GDKmalloc(sizeof(lng*));
    if (!argcnt){
        send_err(mc->c->fdout, 1, ERR500,
                "env:Receiver", OUT_OF_MEM);
        return GDK_FAIL;
    }
    argcnt[0] = GDKmalloc(2 * sizeof(lng));
    if (!argcnt[0]){
        send_err(mc->c->fdout, 1, ERR500,
                "env:Receiver", OUT_OF_MEM);
        GDKfree(argcnt);
        return GDK_FAIL;
    }
    argcnt[0][0] = argcnt[0][1] = 1;

    if (strcmp(method, "PUT") == 0) {
        lng percentage = 1;
        bit verbose = FALSE;
        BAT *shredBAT = BATnew(TYPE_str, TYPE_bat, 32);
        if (!shredBAT){
            send_err(mc->c->fdout, 1, ERR500,
                    "env:Receiver", OUT_OF_MEM);
            GDKfree(argcnt[0]);
            GDKfree(argcnt);
            return GDK_FAIL;
        }

        ret = CMDshred_str(shredBAT, shttpd_get_msg(arg), &percentage,
                NULL, &verbose);
        if (ret == GDK_FAIL) {
            BBPreclaim(shredBAT);
            shredBAT = NULL;
            send_err(mc->c->fdout, 1, ERR404, "env:Sender",
                    NOT_WELL_FORMED);
            GDKfree(argcnt[0]);
            GDKfree(argcnt);
            return ret;
        }

        str argtpe[2] = { "xs:string", "xs:document" };
        str argval[2] = { uri , "0" };
        time_xrpcServDeSeria = GDKusec() - time_xrpcServDeSeria;

        ret = execQuery(mc, 2|timing, MXQ_ADMIN, location, method, 2, 1,
                argcnt, argtpe, argval, shredBAT);
        BBPreclaim(shredBAT);
    } else { /* GET/DELETE */
        str argtpe[1] = { "xs:string" };
        str argval[1] = { uri };
        time_xrpcServDeSeria = GDKusec() - time_xrpcServDeSeria;

        ret = execQuery(mc, 2|timing, MXQ_ADMIN, location, method, 1, 1,
                argcnt, argtpe, argval, NULL);
    }

    if (timing && ret != GDK_FAIL) {
        fprintf(stdout,
                "XRPC_Server_DeSerialisation:   %lld microsec\n",
                time_xrpcServDeSeria);
    }

    GDKfree(argcnt[0]);
    GDKfree(argcnt);
    return ret;
}

/*
 * XRPC MAPI client handler (overrides the xquery_client_engine)
 */
static void 
xrpc_client_engine(mapi_client *mc)
{
    struct shttpd_callback_arg *arg = (struct shttpd_callback_arg *) mc->arg;
    char *uri = shttpd_get_uri(arg);

    if (strncmp(uri, XRPC_ADM_CALLBACK, strlen(XRPC_ADM_CALLBACK)) == 0) {
        (void) xrpc_handle_admin_request(mc, arg);
    } else if (strncmp(uri, XRPC_DOC_CALLBACK, strlen(XRPC_DOC_CALLBACK)) == 0) {
        (void) xrpc_handle_file_request(mc, arg); /* GET/PUT/DELETE file request */
    } else if (strncmp(uri, XRPC_REQ_CALLBACK, strlen(XRPC_REQ_CALLBACK)) == 0) {
        (void) xrpc_handle_request(mc, arg);
    }

    /* clean up */
    mc->engine = xquery_client_engine;
    xquery_client_end(mc, NULL);
    shttpd_finish(arg);
}


/*
 * handle request asynchronously using a MAPI xquery client
 */
static int
xrpc_fork_mapiclient(struct shttpd_callback_arg *arg)
{
    /* get a MAPI thread from the xquery client pool */
    int sock = shttpd_get_socket(arg);
    
    stream *fdin = socket_rastream(sock, "XRPC read");
    if (fdin && stream_errnr(fdin) == 0) {
        stream *fdout = wbstream(socket_wastream(sock, "XRPC write"), 8192);
        if (fdout && stream_errnr(fdout) == 0) {
            mapi_client *mc = MAPIclient(fdin, fdout, "xquery");
            if (mc) {
                /* override xquery_client_engine (will be restored later) */ 
                mc->engine = xrpc_client_engine;
                mc->arg = (char*) arg; /* HACK! pass xrpc arg */
                MT_up_sema(mc->s, "XRPC"); /* activate the thread */
                return 0;
            }
            stream_close(fdout);
            stream_destroy(fdout);
        }
        stream_close(fdin);
        stream_destroy(fdin);
    }
    shttpd_finish(arg);
    return -1;
}

int
CMDrpcd_start(int *port, bit *open, str option)
{
    shttpd_socket ctx;
    char *s;
    
    if (rpcd_running) {
        stream_printf(GDKout,
                "\nRPC receiver already running (on port %d)\n",
                xrpc_port);
        return GDK_SUCCEED;
    }

    xrpc_port = *port;
    rpcd_running = 1;

    /* find 'datadir' (often datadir = <prefix>/share), otherwise use
     * "/usr/share", hence, httpd serves out <datadir>/MonetDB/xrpc */
    if( !(s = GDKgetenv("datadir")) ){
        snprintf(datadir, 1024, "%cusr%cshare%cMonetDB%cxrpc",
                DIR_SEP, DIR_SEP, DIR_SEP, DIR_SEP);
    } else {
        snprintf(datadir, 1024, "%s%cMonetDB%cxrpc", s, DIR_SEP, DIR_SEP);
    }
    shttpd_setopt("document_root", datadir);

    shttpd_init(NULL); /* Initialize httpsd thread */

    if (option && strstr(option, "timing") != NULL)
        timing = 1;

    /* Register call back function, for XRPC (admin) requests, and XML (get/put/delete) file handling */
    shttpd_register_url(XRPC_REQ_CALLBACK,  xrpc_fork_mapiclient, NULL);
    shttpd_register_url(XRPC_DOC_CALLBACK,  xrpc_fork_mapiclient, NULL);
    shttpd_register_url(XRPC_ADM_CALLBACK, xrpc_fork_mapiclient, NULL);

    /* get admin bats */
    if (xrpc_trusted == NULL)
        xrpc_trusted = BATdescriptor(BBPindex("xrpc_trusted"));
    if (xrpc_admin == NULL) 
        xrpc_admin = BATdescriptor(BBPindex("xrpc_admin"));
    assert(xrpc_trusted && xrpc_admin);

    /* Open listening socket */
    ctx = shttpd_open_port(xrpc_port, *open);
    listen_socket = ctx.sock;

    /* Serve connections infinitely until someone kills us */
    for ( ; rpcd_running; ) shttpd_poll(&ctx, 200);

    return GDK_SUCCEED;
}

void xrpc_epilogue(void)
{
    shttpd_fini();      /* Shut down the HTTP server. */
    rpcd_running = 0;   /* Stop RPC server */
    close(listen_socket);
    if (xrpc_trusted) {
        BBPunfix(xrpc_trusted->batCacheid);
        xrpc_trusted = NULL;
    }
    if (xrpc_admin) {
        BBPunfix(xrpc_trusted->batCacheid);
        xrpc_admin = NULL;
    }
}
/* vim:set shiftwidth=4 expandtab: */
