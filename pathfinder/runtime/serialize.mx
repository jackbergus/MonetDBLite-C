@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'

@f serialize
@a Jan Flokstra
@t serialize

@c

/*******************************************
 * serialize.c : XML serialization
 *
 */

#include <gdk.h>
#include <monet.h>

#include "pathfinder.h"

#define MAXTAGDEPTH        1024

#define WS_BATS     HEIGHT

/**
 *
 * 0. SMALL UTILITY SECTION
 *
 * Here a structure is defined to prevent too much alloc/free actions.
 * If the size of a string is smaller then SMART_STR_SZ the value is
 * stored in stack_buff[] within the structure. Otherwise it is strdupped and
 * freed like usual.
 */


#define SMART_STR_SZ    32

typedef struct {
    char stack_buff[SMART_STR_SZ];
    str  val;
} SmartStrBuff;

static int ssb_alloc(SmartStrBuff* ssb, str s) {
    if ( s ) {
        size_t l = strlen(s)+1;

        if ( l <= SMART_STR_SZ )
            return (ssb->val = memcpy(&ssb->stack_buff,s,l)) != NULL;
        else
            return (ssb->val = strdup(s)) != NULL;
    } else
        ssb->val = NULL;
    return 1;
}

static void ssb_free(SmartStrBuff* ssb) {
    if ( ssb->val && (ssb->val != (str)&ssb->stack_buff) ) {
        free( ssb->val );
    }
    ssb->val = NULL;
}

/**
 *
 */

/* #define DEBUGNS */

struct XmlNsFrame; /* forward */
typedef struct XmlNsFrame {
    char*			prefix;
    char*			uri;
    struct XmlNsFrame*	prev;
    struct XmlNsFrame*	next;
} XmlNsFrame;

int xmlNsInit(XmlNsFrame** top) {
#ifdef DEBUGNS
    stream_printf(GDKout,"+NS:xmlNsInit()\n");
#endif
    *top = NULL;
    return 1;
}

char* xmlNsFind(XmlNsFrame** top, char* prefix) {
    XmlNsFrame* fp = (*top);

    while( fp ) {
        if (prefix == NULL) {
            if (fp->prefix == NULL) {
#ifdef DEBUGNS
                stream_printf(GDKout,"+NS:xmlNsFind(NULL)=NULL)\n");
#endif
                return fp->uri;
            }
        } else if (fp->prefix != NULL && strcmp(prefix,fp->prefix) == 0) {
#ifdef DEBUGNS
            stream_printf(GDKout,"+NS:xmlNsFind(\"%s\")=\"%s\")\n",prefix,fp->uri);
#endif
            return fp->uri;
        }
        fp = fp->prev;
    }
    return NULL;
}

XmlNsFrame* xmlNsPush(XmlNsFrame** top, char* prefix, char* uri) {
    XmlNsFrame* fp = (XmlNsFrame*)malloc(sizeof(XmlNsFrame));

    if ( fp ) {
#ifdef DEBUGNS
        stream_printf(GDKout,"+NS:xmlNsPush(\"%s\",\"%s\")\n",prefix,uri);
#endif
        fp->prefix = NULL;
        if ( prefix && !( fp->prefix = strdup(prefix)) ) return NULL;
        if ( !(fp->uri    = strdup(uri)) ) return NULL;
        /* */
        fp ->next  = NULL;
        if ( *top ) {
            (*top)->next = fp;
            fp->prev     = *top;
        } else {
            fp->prev = NULL;
        }
        *top     = fp;
    }
    return fp;
}

int xmlNsPop2(XmlNsFrame** top, XmlNsFrame* newTop) {
    XmlNsFrame* fp = (*top);

#ifdef DEBUGNS
    stream_printf(GDKout,"+NS:xmlNsPop2(%d)\n",(int)newTop);
#endif
    while (fp != newTop ) {
        XmlNsFrame* old = fp;
        fp = fp->prev;
#ifdef DEBUGNS
        stream_printf(GDKout,"+NS:-popping(\"%s\",\"%s\")\n",old->prefix,old->uri);
#endif
        free(old->prefix);
        free(old->uri);
        free(old);
    }
    if ( (*top = newTop) ) {
        (*top)->next = NULL;
    };
    return 1;
}

int xmlNsDispose(XmlNsFrame** top) { return xmlNsPop2(top,NULL); }

/**
 *
 * I. THE CONTEXT NODE DEFINITION AND USAGE PART
 *
 * This structure contains the context of the print session.
 * It has several functions. But its main use is the administration
 * of all BATs containing the XML documents.
 *
 */

typedef struct SerializeFrame {
    oid             pre;
    int             empty;  /* boolean indicating node is empty */
    XmlNsFrame*		nsMark;
    SmartStrBuff    ssb_ns;
    SmartStrBuff    ssb_name;
} SerializeFrame;

typedef struct {
    int     dmMode;         /* Data model flag, true if printing in
                             * data-model mode, eg. look like GALAX */
    int     saxMode;        /* true if printing a Sax-O-Phone stream */
    int     mapiMode;       /* for DM or XML mode that should go on a
                               MapiClient stream */
    int     norootMode;     /* do not generate <XQueryResult> root node */
    int     noheaderMode;   /* do not generate xml header */
    int     typedMode;      /* surrant every single value with an extra
                               tag, with the XQuery type of this value
                               as the tag name */
    int     printMode;      /* true if printing SQL-ish/MCL-ish output,
                               is used by JDBC/XML:DB at the moment */
    char*   restag;         /* root element name XQueryResult */
    char*   dmSeparator;    /* seperation char in DM mode */
    BAT*    ws;             /* working set BAT */
    int     curFRAG;        /* current fragment used by working set */
    BAT*    curBAT[WS_BATS];/* The BAT's of the current fragment*/
    /* */
    XmlNsFrame* nsTop;	/* top of the namespace stack */
    /**
     * Next elements is a stack used during printing to store the
     * pre-value, name, namespace of the nodes currently being printed.
     */
    int     stackPtr;
    SerializeFrame	tagStack[MAXTAGDEPTH];
    /* */
    int     nAttrOnLine; /* used by top result print routine to count the
                          * number of top-level result items printed on
                          * the current line.
                          */
} XqueryCtx;

/**
 * The local error handler for the serialization.
 */
static int fatal_err(XqueryCtx* ctx, const char *msg, ...) {
    va_list msgs;
    char    errmsg[1024];

    (void)ctx;
    va_start (msgs, msg);
    vsnprintf (errmsg, 1024, msg, msgs);
    va_end (msgs);
    /* */
    GDKerror("XML Generation: %s\n",errmsg);
    /* */
    return 0;
}

/**
 * Functions fills a new context() record with mode and BAT data and
 * initializes all other data structures.
 */

static BAT* fetchWsContextBAT(XqueryCtx* ctx, BAT* ws, int batID, int wsID) {
    BUN bun;
    oid BATid = (oid)batID;
    oid WSid  = (oid)wsID;

    if ( wsID < 0 ) {
        fatal_err(ctx,"fetchWsContextBAT: NO wsID CONTEXT SELECTED");
        return NULL;
    }
    if ( !(bun = BUNfnd(ws,&BATid)) ) {
        fatal_err(ctx,"fetchWsContextBAT: NOT FOUND BAT[%d]",batID);
        return NULL;
    }


    BAT* batbat;

    if ( !( batbat = BATdescriptor(*(bat*)bun)) ) {
        fatal_err(ctx,"fetchWsContextBAT:FETCH BATBAT for WS[%d][%d] FAILED\n",batID ,wsID);
        return NULL;
    }

    BUN bbun = BUNfnd(batbat,&WSid);
    BAT *res = NULL;
    if ( !bbun ) {
        BBPunfix( BBPcacheid( batbat ) );
        fatal_err(ctx,"fetchWsContextBAT:NOT FOUND BAT[%d][%d] in WS!!!!\n",batID,wsID);
        return NULL;
    } else {
        if ( !(res = BATdescriptor(*(bat*)bbun)) ) {
            BBPunfix( BBPcacheid( batbat ) );
            fatal_err(ctx,"fetchWsContextBAT:FETCH WS[%d][%d] FAILED\n",batID,wsID);
            return NULL;
        }
    }
    BBPunfix( BBPcacheid( batbat ) );
    return res;
}


static int switchWsContext(XqueryCtx* ctx, int wsID) {
    int res = ctx->curFRAG;

    if ( ctx->curFRAG != wsID ) {
        int i;

        if ( ctx->curFRAG >= 0 ) {
            /* close the old open context BAT's */
            for(i=0; i<WS_BATS; i++) {
                if ( ctx->curBAT[i] ) {
                    BBPunfix( BBPcacheid(ctx->curBAT[i]));
                    ctx->curBAT[i] = NULL;
                }
            }
        }
        ctx->curFRAG   = wsID;
    }
    return res;
}

static int createWsContext(XqueryCtx* ctx, BAT* ws, int wsID, str mode) {
    int i;

    ctx->dmMode = ctx->mapiMode = ctx->printMode = 0;
    ctx->norootMode = ctx->noheaderMode = ctx->typedMode = 0;
    ctx->saxMode = 1;
    xmlNsInit( &ctx->nsTop );

    /* choose a mode: {dm,xml,sax} */ 
    if ( strstr(mode,"dm")) {
        ctx->dmMode = 1; ctx->saxMode = 0;
    } else if (strstr(mode,"xml")) {
        ctx->dmMode = ctx->saxMode = 0;
        /* we may omit the synthetic root element */ 
        if (strstr(mode,"noheader")) {
            ctx->noheaderMode = 1;
        }
        if (strstr(mode, "typed")) {
            ctx->typedMode = 1;
        }
        if (strstr(mode,"noroot")) {
            ctx->norootMode = 1;
        } else {
            ctx->restag = strstr(mode,"root-");
            if (ctx->restag == NULL) {
                ctx->restag = "XQueryResult"; /* default root tag */
            } else {
                ctx->restag += 5; /* rest of mode is root tag */
            }
        }
    }
    if (!ctx->saxMode) {
        /* add mapi = characters at the start of each line */
        if (strstr(mode,"mapi")) {
            ctx->mapiMode = 1;
        }
        /* go into SQL-ish/MCL-ish mode */
        if (strstr(mode, "seq")) {
            ctx->dmMode = ctx->printMode = 1;
        }
    }
    ctx->dmSeparator =
        (ctx->mapiMode ? ",\n=" : (ctx->printMode ? ",\\n" : ",\n"));
    ctx->ws        = ws;
    ctx->curFRAG   = -1; /* empty, no frag loaded */

    /* initialize with all wsBAT()'s closed */
    for(i=0; i<WS_BATS; i++) {
        ctx->curBAT[i] = NULL;
    }
    /* */
    if ( wsID >= 0 )
        switchWsContext(ctx, wsID);
    /* */
    ctx->stackPtr  = 0;
    /* */
    return 1;
}

static int disposeWsContext(XqueryCtx* ctx) {
    xmlNsDispose( &ctx->nsTop );
    return 1;
}

/**
 * Return if there are still nodes on stack.
 */
static int moreTags(XqueryCtx* ctx) {
    return (ctx->stackPtr > 0);
}

/**
 * Push the pre-value, namespace and nodename of stack
 */
static int pushTag(XqueryCtx* ctx, oid pre, str ns, str name, int empty) {
    ctx->tagStack[ctx->stackPtr].pre    = pre;
    ctx->tagStack[ctx->stackPtr].empty  = empty;
    ctx->tagStack[ctx->stackPtr].nsMark = NULL;
    if (!ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_ns,   ns) )
        return 0;
    if (!ssb_alloc(&ctx->tagStack[ctx->stackPtr].ssb_name, name) )
        return 0;;
    ctx->stackPtr++;
    return 1;
}

/**
 * Three function to retrieve the pre-value, namespace or nodename of the
 * top element on the stack.
 */
static INLINE SerializeFrame* topSF(XqueryCtx* ctx) {
    return &ctx->tagStack[ctx->stackPtr-1];
}

static str topNs(XqueryCtx* ctx)    {return topSF(ctx)->ssb_ns.val;}
static str topName(XqueryCtx* ctx)  {return topSF(ctx)->ssb_name.val;}


/**
 * Pop the top element of the stack. Means that processing the node has
 * finished.
 */
static void popTag(XqueryCtx* ctx) {
    /* de-alloc the ns and name strings */
    ssb_free(&topSF(ctx)->ssb_ns);
    ssb_free(&topSF(ctx)->ssb_name);

    XmlNsFrame *xnf;
    if ( (xnf = topSF(ctx)->nsMark) ) {
        xmlNsPop2(&ctx->nsTop,xnf->prev);
    }
    --ctx->stackPtr;
}

static int handle_attribute(XqueryCtx* ctx, str uri, str prefix, str loc, str value, int top); /* forward */

static int checkNsChange(XqueryCtx* ctx, str par_uri, str par_prefix, int top) {
    char *uri, *prefix;

    if ( strcmp(par_uri,str_nil) == 0 || *par_uri == 0 )
        uri = NULL;
    else
        uri = par_uri;
    if ( strcmp(par_prefix,str_nil) == 0 || *par_prefix == 0 )
        prefix = NULL;
    else
        prefix = par_prefix;
    if ( uri ) {
        char* currentURI = xmlNsFind(&ctx->nsTop,prefix);

        if ( !(currentURI && (strcmp(currentURI,uri) == 0)) ) {
            /* change of URI for this prefix */
            XmlNsFrame* xnf;

            if ( !(xnf = xmlNsPush(&ctx->nsTop,prefix,uri)) ) {
                fatal_err(ctx,"xmlNsPush: out of memory\n");
                return 0;
            }
            /* generate the xmlns:xxx=uri tag */
            handle_attribute(ctx,(str)str_nil,"xmlns",prefix,uri,top);

            SerializeFrame* sf = topSF(ctx);

            if ( !sf->nsMark ) {
                /* not the first nsFrame in this context */
                sf->nsMark = xnf;
            }
        }
    }
    return 1;
}

/**
 *
 * II. THE OUTPUT HANDLER PART
 *
 * The emit functions are used to encapsulate the Sax-O-Phone event
 * emission functions.
 * The current implementation emits the Sax-O-Phone events as if they are
 * a BAT.
 *
 * TODO: solve characters() newline in string problem.
 *
 */

static int emit_start() {
    stream_printf(GDKout,"#-------------------------#\n");
    stream_printf(GDKout,"# h     SAXtape           #\n");
    stream_printf(GDKout,"# str   str               #\n");
    stream_printf(GDKout,"#-------------------------#\n");
    return 1;
}

/**
 * The character translation section responsible for the special
 * character recognition and XML entity characters.  It consists of a
 * small main table 'isspecial_tab' containing the flags for every
 * possible character.
 * v=0: no special char
 * v<3: special char, should be presented as octal char in output
 * v>=3: special char, string repr of char is isspecial_val[v+mode]
 *
 * mode = 0 sax
 * mode = 1 dm/xml
 * mode = 2 dm/xml (mapi)
 */

static unsigned char  isspecial_tab[UCHAR_MAX+1] = { 0 }; /* the main table */
static char*          isspecial_val[32]; /* the values of the special chars */

static void init_isspecial() {
    int i;
    for(i=0; i<32; i++) isspecial_tab[i] = 1; /* means write as octal */
    isspecial_val[0] = "[*ERROR*]"; /* not used */
    isspecial_tab[(int)(unsigned char)'\377'] = 1; /* means write as octal */
    isspecial_val[1] = "[*ERROR*]"; /* not used, 1 = write as octal */
    isspecial_val[2] = "[*ERROR*]"; /* not used, 2 = write as octal */
    isspecial_val[3] = "[*ERROR*]"; /* not used, 3 = write as octal */
    isspecial_tab[(int)'\t'] = 4;
    isspecial_val[4] = "\\t";
    isspecial_val[5] = "\t"; /* don't escape */
    isspecial_val[6] = isspecial_val[5];
    isspecial_tab[(int)'\n'] = 7;
    isspecial_tab[(int)'\r'] = 7;	/* map \r on \n */
    isspecial_val[7] = "\\n";
    isspecial_val[8] = "\n"; /* don't escape */
    isspecial_val[9] = "\n="; /* this is the only diff between mapi and non-mapi */
    isspecial_tab[(int)'\\'] = 10;
    isspecial_val[10] = "\\\\";
    isspecial_val[11] = "\\"; /* don't escape */
    isspecial_val[12] = isspecial_val[11];
    isspecial_tab[(int)'\"'] = 13;
    isspecial_val[13] = "&quot;";
    isspecial_val[14] = isspecial_val[13];
    isspecial_val[15] = isspecial_val[13];
    isspecial_tab[(int)'\''] = 16;
    isspecial_val[16] = "&apos;";
    isspecial_val[17] = isspecial_val[16];
    isspecial_val[18] = isspecial_val[16];
    isspecial_tab[(int)'&'] = 19;
    isspecial_val[19] = "&amp;";
    isspecial_val[20] = isspecial_val[19];
    isspecial_val[21] = isspecial_val[19];
    isspecial_tab[(int)'<'] = 22;
    isspecial_val[22] = "&lt;";
    isspecial_val[23] = isspecial_val[22];
    isspecial_val[24] = isspecial_val[22];
    isspecial_tab[(int)'>'] = 25;
    isspecial_val[25] = "&gt;";
    isspecial_val[26] = isspecial_val[25];
    isspecial_val[27] = isspecial_val[25];
}

/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 */
static int emit_escaped(char* src, int mode, int onlyEntity) {
    /* Emit a string with all special character escaped. Inspired by
     * function strToStr() in gdk_atoms.mx
     */
    int start=0,end;
    unsigned char isspecial_ch;

    if (isspecial_tab[0] == 0) /* module not initialized yet */
        init_isspecial();
    for(end = 0; src[end]; end++) {
        if ( (isspecial_ch = isspecial_tab[(int)(unsigned char)src[end]]) ) {
            stream_write(GDKout,&src[start],end-start,1);
            start = end + 1;

            if ( isspecial_ch < 3 ) {
                stream_printf(GDKout,"\\%03o",(unsigned char)src[end]);
            } else {
                char *emit_val = isspecial_val[mode+(int)isspecial_ch];

                /* if ( onlyEntity && (*emit_val!='&') ) */
                if (
                        onlyEntity &&
                        src[end] !='<' &&
                        src[end] !='>' &&
                        src[end] !='&' &&
                        src[end] != '\n'
                   ) {
                    start--; /* char should normally be printed */
                } else {
                    stream_write(GDKout,emit_val,strlen(emit_val),1);
                }
            }
        }
    }
    if ( start < end ) {
        stream_write(GDKout,&src[start],end-start,1);
    }
    return 1;
}

static int emit(char* eventName, char* val, int escaped) {
    if ( val ) {
        if ( escaped ) {
            stream_printf(GDKout,"[\"%s\",\t\"",eventName);
            if ( !emit_escaped(val, escaped-1, 0/*ALL*/) )
                return 0;
            stream_printf(GDKout,"\"]\n");
        } else {
            stream_printf(GDKout,"[\"%s\",\t\"%s\"]\n",eventName,val);
        }
    } else
        stream_printf(GDKout,"[\"%s\",\tnil]\n",eventName);
    return 1;
}

static int emit_end() {
    return 1;
}

/*
 *
 * The output handlers. Responslibe for generating the output representing
 * the handles xml structure. Cuurently 3 output structures are used:
 *
 * 1) plain xml text (ctx->saxMode is false)
 * 2) xml Sax-O-Phone stream (ctx->saxMode is true AND SAXOPHONE=1 )
 * 3) My own SAX event stream (ctx->saxMode is true AND SAXOPHONE=0 )
 *
 */

/* The SAXOPHONE define is a temporary flag used by JF to compile 'in'
 * his own Sax-O-Phone version which he thinks is much more efficient
 * than the original (but not as fancy) of course.
 */
#define SAXOPHONE 1

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static int handle_startDocument(XqueryCtx* ctx) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit_start() )
                return 0;
        } else
            stream_printf(GDKout,"<S\n");
    } else if (ctx->mapiMode) { /* xml mode (mapi) */
        stream_printf(GDKout,"=<?xml version=\"1.0\" encoding=\"utf-8\"?>\n=");
    } else if (ctx->printMode) { /* SQL-ish mapi */
        stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n");
    } else { /* xml mode */
        stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static int handle_endDocument(XqueryCtx* ctx) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit_end() )
                return 0;
        } else
            stream_printf(GDKout,"<E\n");
    } else { /* xmlMode */
        stream_printf(GDKout,"\n");
    }
    return 1;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static int handle_attribute(XqueryCtx* ctx, str uri, str prefix, str loc, str value, int top) {
    if ( !checkNsChange(ctx,uri,prefix,top) )
        return 0;
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( loc && *loc) {
                if (!emit(" attribute",loc,0) )
                    return 0;
                if ( prefix && *prefix )
                    if ( !emit(" attribute prefix",prefix,0) )
                        return 0;
            } else if (prefix && *prefix) {
                /* default namespace */
                if (!emit(" attribute",prefix,0) )
                    return 0;
            }
            if ( !emit(" attribute value",value,0) )
                return 0;
        } else {
            stream_printf(GDKout,"<A %s=\"%s\"\n",loc,value);
        }
    } else if (ctx->printMode) {
        if ( prefix && *prefix && loc && *loc ) {
            stream_printf(GDKout," %s:%s=\\\"%s\\\"",prefix,loc,value);
        } else if (prefix && *prefix) {
            /* default namespace */
            stream_printf(GDKout," %s=\\\"%s\\\"",prefix,value);
        } else {
            stream_printf(GDKout," %s=\\\"%s\\\"",loc,value);
        }
    } else if (ctx->dmMode && top) { /* dmMode */
        if ( prefix && *prefix ) {
            if ( strcmp(prefix,"xmlns")==0 ) {
                if (loc && *loc) {
                    stream_printf(GDKout,"attribute %s:%s { %s }%s",prefix,loc,value,ctx->dmSeparator);
                } else {
                    /* default namespace */
                    stream_printf(GDKout,"attribute %s { %s }%s",prefix,value,ctx->dmSeparator);
                }
            } else
                stream_printf(GDKout,"attribute %s:%s { %s }",prefix,loc,value);
        } else {
            stream_printf(GDKout,"attribute %s { %s }",loc,value);
        }
    } else { /* xmlMode */
        if ( prefix && *prefix && loc && *loc ) {
            stream_printf(GDKout," %s:%s=",prefix,loc);
        } else if ( prefix && *prefix ) {
            /* default namespace */
            stream_printf(GDKout," %s=",prefix);
        } else {
            stream_printf(GDKout," %s=",loc);
        }
        /* stream_printf(GDKout,"\"%s\"",value); */
        stream_printf(GDKout,"\"");
        emit_escaped(value, 1+ctx->mapiMode, 0/*ALL*/);
        stream_printf(GDKout,"\"");
    }
    return 1;
}

/**
 * Output generation handler. This one of my own invented event indicating
 * there will be no more attribute events for this node.
 */
static int handle_attributeEnd(XqueryCtx* ctx, int emptyNode) {
    if (ctx->saxMode ) {
    } else { /* xmlMode */
        if ( emptyNode )
            stream_printf(GDKout,"/");
        stream_printf(GDKout,">");
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static int handle_startElement(XqueryCtx* ctx, str ns, str name /*,str *atts*/) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit("startElement",NULL,0) )
                return 0;
            if ( ns && *ns )
                if ( !emit(" prefix",ns,0) )
                    return 0;
            if ( !emit(" localname",name,0) )
                return 0;
        } else {
            stream_printf(GDKout,"<s %s\n",name);
        }
    } else { /* xmlMode */
        if ( ns && *ns ) {
            stream_printf(GDKout,"<%s:%s",ns,name);
        } else {
            stream_printf(GDKout,"<%s",name);
        }
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static int handle_endElement(XqueryCtx* ctx, str ns, str name, int emptyNode) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit("endElement",NULL,0) )
                return 0;
            if ( ns && *ns )
                if ( !emit(" prefix",ns,0) )
                    return 0;
            if ( !emit(" localname",name,0) )
                return 0;
        } else {
            stream_printf(GDKout,"<e %s\n",name);
        }
    } else { /* xmlMode */
        if ( !emptyNode ) {
            if ( ns && *ns ) {
                stream_printf(GDKout,"</%s:%s>",ns,name);
            } else {
                stream_printf(GDKout,"</%s>",name);
            }
        }
    }
    return 1;
}

/**
 * Output generation handler. One on my own again. This one should handle a
 * reference. Don't know wat to to about it now.
 */
static int handle_reference(XqueryCtx* ctx, str name) {
    (void)ctx;
    (void)name;
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static int handle_characters(XqueryCtx* ctx, str ch, str top) {
    /* INCOMPLETE, we need to escape stuff here
    */
    if ( ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if (!emit("characters",NULL,0))
                return 0;
            if (!emit(" pcdata",ch,1))
                return 0;
        } else {
            stream_printf(GDKout,"%s\n",ch); /* ESCAPE !! */
        }
    } else { /* xmlMode */
        if ( ctx->printMode ) { /* SQL-ish/MCL-ish mode */
            if ( ctx->dmMode && top )
                stream_printf(GDKout,"%s {\\\"", top);

            /* we need to escape newlines */
            emit_escaped(ch, ctx->saxMode, 1 /*JUST ENTITIES*/ );

            if ( ctx->dmMode && top )
                stream_printf(GDKout,"\\\"}");
        } else if ( ctx->mapiMode ) {
            /* we need to prepend "=" to each line, so
               make sure that we print one after each
               newline */
            /*
             * str nl;
             * while ((nl = strchr(ch, '\n')) != NULL) {
             * 	nl++;
             * 	stream_printf(GDKout, "%.*s=", (nl - ch), ch);
             * 	ch = nl;
             * }
             */
            if ( ctx->dmMode && top )
                stream_printf(GDKout,"%s {\"", top);

            emit_escaped(ch,1+ctx->mapiMode, 1/*JUST ENTITIES*/ );

            if ( ctx->dmMode && top )
                stream_printf(GDKout,"\"}");
        } else {
            /*
             * stream_printf(GDKout,"%s",ch);
             */
            if ( ctx->dmMode && top )
                stream_printf(GDKout,"%s {\"", top);

            emit_escaped(ch,1+ctx->mapiMode, 1/*JUST ENTITIES*/ );

            if ( ctx->dmMode && top )
                stream_printf(GDKout,"\"}");
        }
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static int handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
    return handle_characters(ctx,ch,0); /* dispatch */
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
static int handle_comment(XqueryCtx* ctx, str comm) {
    if (ctx->saxMode ) {
        /* incomplete */
    } else { /* xmlMode */
        stream_printf(GDKout,"<!--%s-->",comm);
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX
 * processingInstruction() event.
 */
static int handle_processingInstruction(XqueryCtx* ctx, str target, str data) {
    if (ctx->saxMode ) {
        /* incomplete */
    } else { /* xmlMode */
        stream_printf(GDKout,"<?%s %s?>",target,data);
    }
    return 1;
}


/**
 * The wsBAT() function is responsible for 'demand-loading' the BAT with index
 * 'batId in the current working set. No BAT is loaded until it is needed. This
 * solves some funny problems with loading BAT's which were not needed
 * anyway.
 */
#define wsBAT(_b, ctx, batId) {                                 \
    if (ctx->curBAT[batId] == NULL) {                           \
        ctx->curBAT[batId] = _b = fetchWsContextBAT(ctx, ctx->ws, batId, ctx->curFRAG);\
        if (_b == NULL) return wsBATerror(ctx,batId,ctx->curFRAG);  \
    }                                                           \
    _b = ctx->curBAT[batId];                                    \
}

static int wsBATerror(XqueryCtx* ctx, int batId, int fragId)
{
    fatal_err(ctx, "unable to load wsBAT[%d] of frag %d", batId, fragId);    
    return 0;
}

#define IS_FAKE_PROJECT(b) ((b->batCount == 1) & (b->hseqbase == oid_nil) & (b->htype == TYPE_void))

/**
 * Utility function. It reads the tail value of an element in a
 * [void,any] BAT indexed by oid_index.
 */
#define idxTV(res, ctx, b, oid_index) {                         \
    if (IS_FAKE_PROJECT(b)) {                                   \
        res = BUNtail(b,BUNfirst(b)); /* fake project */        \
    } else if (b->batCount) {                                   \
        BUN _bun = NULL;                                        \
        BUNfndVOID(_bun, b, &oid_index);                        \
        if (_bun == NULL)                                       \
            return idxTVerror1(ctx,b,oid_index);                \
        res = BUNtail(b,_bun);                                  \
    } else                                                      \
        return idxTVerror2(ctx,b);                              \
    if (res == NULL)                                            \
        return idxTVerror3(ctx,b,oid_index);                    \
}

static int idxTVerror1(XqueryCtx* ctx, BAT *b, oid oid_index)
{ 
    fatal_err(ctx, "%s BAT does not have a " OIDFMT " head.\n",
                    b?BBP_logical(b->batCacheid):"NULL", oid_index);
    return 0;
}

static int idxTVerror2(XqueryCtx* ctx, BAT *b)
{ 
    fatal_err(ctx, "%s BAT is empty.\n",
                    b?BBP_logical(b->batCacheid):"NULL");
    return 0;
}

static int idxTVerror3(XqueryCtx* ctx, BAT *b, oid oid_index)
{ 
    fatal_err(ctx, "%s BAT has a " OIDFMT " head, but tail is NULL.\n",
                    b?BBP_logical(b->batCacheid):"NULL", oid_index);
    return 0;
}

/**
 * Reads the index tailvalue in a Working Set BAT
 */
#define idxTVinWS(res, ctx, batId, oid_index) {                 \
    BAT* _b;                                                    \
    wsBAT(_b, ctx, batId);                                      \
    idxTV(res,ctx,_b,oid_index);                                \
}

/**
 * Reads the index tailvalue in a Working Set BAT or when fragId is not the
 * current working set it reads in the BAT outside the working set.
 */
#define idxTVinWSorFRGN(res, ctx, fragId, batId, oid_index) {   \
    if (ctx->curFRAG == fragId) {                               \
        idxTVinWS(res,ctx,batId,oid_index);                     \
    } else {                                                    \
        res = idxTVinWS_expensive(ctx,fragId,batId,oid_index);  \
        if (res == NULL) return 0;                              \
    }                                                           \
}


static int idxTV_expensive(ptr *res, XqueryCtx* ctx, BAT *b, oid oid_index)
{
    idxTV(*res,ctx,b,oid_index);
    return 1;
}

static ptr idxTVinWS_expensive(XqueryCtx* ctx, int fragId, int batId, oid oid_index) 
{
    BAT *b = fetchWsContextBAT(ctx, ctx->ws, batId, fragId);
    ptr res = NULL;
    if (b == NULL) {
        (void) wsBATerror(ctx, fragId, batId);
    } else {
        (void) idxTV_expensive(&res,ctx,b,oid_index);
        BBPunfix( BBPcacheid( b ) );
    }
    return res;
}

/**
 * Handle the generation of the attributes of the node with oid 'pre'. This
 * function is only called from the xquery_node_print() function.
 */

static int process_attr(XqueryCtx* ctx, int frag, oid id, int top) {
    str val, uri, prefix, loc; 
    oid qn_oid, prop_oid;
    int afrag;
    ptr res;

    idxTVinWSorFRGN(res, ctx, frag,  ATTR_PROP, id);       prop_oid = *(oid*)      res;
    idxTVinWSorFRGN(res, ctx, frag,  ATTR_FRAG, id);       afrag    = (int)*(oid*) res;
    idxTVinWSorFRGN(res, ctx, afrag, PROP_VAL,  prop_oid); val      = (str)        res;
    idxTVinWSorFRGN(res, ctx, frag,  ATTR_QN,   id);       qn_oid   = *(oid*)      res;
    idxTVinWSorFRGN(res, ctx, afrag, QN_URI,    qn_oid);   uri      = (str)        res;
    idxTVinWSorFRGN(res, ctx, afrag, QN_PREFIX, qn_oid);   prefix   = (str)        res;
    idxTVinWSorFRGN(res, ctx, afrag, QN_LOC,    qn_oid);   loc      = (str)        res;

    return handle_attribute(ctx, uri, prefix, loc, val, top);
}

static int process_node_attr(XqueryCtx* ctx, int nFRAG, oid pre, int emptyNode) {
    BAT *b;

    wsBAT(b, ctx, ATTR_OWN);
    if ( !(b  = BATuselect(b,&pre,&pre)) )
        return fatal_err(ctx,"process_node_attr: uselect fails\n");
    BUN p, q;
    BATloop(b, p, q) {
        oid id = *(oid*)BUNhead(b, p);
        if ( ! process_attr(ctx,nFRAG,id,0/*top*/) ) {
            BBPunfix( BBPcacheid( b ) );
            return 0;
        }
    }
    BBPunfix( BBPcacheid( b ) );
    return handle_attributeEnd(ctx,emptyNode);
}

/**
 * Handle the generation of the node with oid 'pre'.
 */
static int xquery_node_print(XqueryCtx* ctx, oid pre, BAT* pre_frag, int top) {
    ptr res;
    chr kind;
    oid prop;

    idxTVinWS(res,ctx,PRE_KIND,pre);
    kind = *(chr*) res;
    idxTVinWS(res,ctx,PRE_PROP,pre);
    prop = *(oid*) res;
    int vFRAG = ctx->curFRAG;
    if ( pre_frag ) {
        idxTV(res,ctx,pre_frag,pre);
        vFRAG = (int)*(oid*)res;
    }
    switch( kind ) {
        case (char)0:
            {	/* ELEMENT */
                str uri, prefix, loc;
                idxTVinWSorFRGN(res,ctx,vFRAG,QN_URI,prop);
                uri   = (str)res;
                idxTVinWSorFRGN(res,ctx,vFRAG,QN_PREFIX,prop);
                prefix   = (str)res;
                idxTVinWSorFRGN(res,ctx,vFRAG,QN_LOC,prop);
                loc = (str)res;
                if ( !handle_startElement(ctx,prefix,loc) )
                    return 0;
                idxTVinWS(res,ctx,PRE_SIZE,pre);
                int size = *(int*)res;
                if (!pushTag(ctx,pre+size,prefix,loc,(size==0)))
                    return 0;
                /* check for change of prefix/uri. 'top' is not
                 * propagated here because an attribute inside an
                 * element can never be top-level.
                 */
                if ( ! checkNsChange(ctx,uri,prefix,0) )
                    return 0;
                if ( !process_node_attr(ctx,ctx->curFRAG,pre,(size==0)))
                    return 0;
                break;
            }
        case (char)1:
            {	/* PFTEXT */
        
                idxTVinWSorFRGN(res,ctx,vFRAG,PROP_TEXT,prop);
                if ( !handle_characters(ctx,(str)res,(top?"text":0)))
                    return 0;
                break;
            }
        case (char)2:
            {	/* COMMENT */
                idxTVinWSorFRGN(res,ctx,vFRAG,PROP_COM,prop);
                if ( !handle_comment(ctx,(str)res))
                    return 0;
                break;
            }
        case (char)3:
            {	/* PI */
                str target, data;
                idxTVinWSorFRGN(res,ctx,vFRAG,PROP_TGT,prop);
                target = (str) res;
                idxTVinWSorFRGN(res,ctx,vFRAG,PROP_INS,prop);
                data = (str) res;
                if (!handle_processingInstruction(ctx,target,data))
                    return 0;
                break;
            }
        case (char)4:
            {	/* DOCUMENT */
                /* The node represents an entire document */
                int offset;
                idxTVinWS(res,ctx,PRE_SIZE,pre);
                offset = *(int*)res;
                if (!pushTag(ctx,pre+offset,"","",0/*false*/))
                    return 0;
                break;
            }
        default:
            return fatal_err(ctx,"Unknow kind IN xquery_node_print");
    }
    return 1;
}

#define ALLTAGS INT_MAX

/**
 * handle the closing tag of a document.
 */
static int xquery_endtag_print(XqueryCtx* ctx, oid pre) {
    while( moreTags(ctx) && ((pre==ALLTAGS)||(pre > topSF(ctx)->pre)) ) { /*?? */
        if ( *topName(ctx) )
            if ( !handle_endElement(ctx,topNs(ctx),topName(ctx),topSF(ctx)->empty))
                return 0;
        popTag(ctx);
    }
    return 1;
}

/**
 * handle the range of pre numbers [from .. to]
 */
static int xquery_pre_range(XqueryCtx* ctx, BAT* b, oid from, oid to) {
    BUN p, q;
    if ( from == 0 ) /* first BUN, because of 1..n/0..n-1 problem */
        p = BUNfirst(b);
    else
        BUNfndOID(p, b, (ptr)(&from));
    for(q = BUNlast(b); p<q; p = BUNnext(b, p)) {
        oid pre = *(oid*)BUNhead(b, p);
        do {
            if ( !xquery_node_print(ctx, pre, 0 /*pre_frag*/, 0 /*false*/))
                return 0;
            if ( !xquery_endtag_print(ctx,++pre) )
                return 0;
        } while( moreTags(ctx) && (pre<to) );
    }
    if ( moreTags(ctx) ) {
        /* INCOMPLETE, the next line works but WHY? Should work without */
        if ( !xquery_endtag_print(ctx,ALLTAGS) )
            return 0;
    }
    return 1;
}

static int MY_xquery_pre_range(XqueryCtx* ctx, oid from, oid to, BAT* pre_frag, int top, int lastVal) {
    oid pre = from;

    if ( ctx->typedMode ){
        stream_printf(GDKout, "<xs:anyNode>\n");
    }

    do {
        if ( !xquery_node_print(ctx, pre,pre_frag,top&&(from==to)) /*cheat*/ )
            return 0;
        if ( !xquery_endtag_print(ctx,++pre) )
            return 0;
    } while( moreTags(ctx) && (pre<=to) );

    if ( ctx->typedMode ) {
        stream_printf(GDKout,"\n</xs:anyNode>");
        if ( !lastVal )
            stream_printf(GDKout, "\n");
        }
    return 1;
}

/**
 *
 * X. THE MAIN XML DOCUMENT PRINTING PART
 *
 * Main XML document printing routine
 */

static int ws_documentIndex(BAT* ws, str docName) {
    oid doc_loaded_idx = (oid)DOC_LOADED;

    BUN b = BUNfnd(ws,&doc_loaded_idx);

    if ( !b )
        return fatal_err(0,"ws_documentIndex: unable to find docbat in WS");

    BAT* doc_loaded = BATdescriptor(*(bat*)b);

    BUN p, q;
    BATloop(doc_loaded, p, q) {
        oid docId = *(oid*)BUNhead(doc_loaded, p);
        str docNm = (str)BUNtail(doc_loaded, p);

        if ( strcmp(docName,docNm) == 0 ) {
            BBPunfix( BBPcacheid( doc_loaded ) );
            return docId;
        }
    }
    BBPunfix( BBPcacheid( doc_loaded ) );
    return -1;
}

int xquery_print_doc_main(str mode, BAT* ws, str docName) {
    int docIndex = ws_documentIndex(ws,docName);
    BAT *b;
    if ( docIndex < 0 ) {
        GDKwarning("serialize.mx:xquery_print_doc_main: unable to find document \"%s\" in working set!\n",docName);
        return GDK_SUCCEED;
    }
    /* */
    XqueryCtx  ctx_struct, *ctx = &ctx_struct;
    if ( !createWsContext(ctx,ws,docIndex,mode) )
        return GDK_FAIL;
    /* */
    wsBAT(b,ctx,PRE_SIZE);
    if ( !handle_startDocument(ctx) )
        return GDK_FAIL;
    if ( !xquery_pre_range(ctx,b,0/*start*/,1 /* first is doc ? */) )
        return GDK_FAIL;
    if ( !handle_endDocument(ctx) )
        return GDK_FAIL;
    switchWsContext(ctx,-1); /* close all open context BAT's */
    /* */
    if ( !disposeWsContext(ctx) )
        return GDK_FAIL;
    /* */
    return GDK_SUCCEED;
}

/**
 * XI. THE MAIN PATHFINDER QUERY RESULT PART
 *
 * First the event/emit handlers for the sequnce are defined and after that
 * the main function
 */


/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static int id_sequence_counter = 0;
static int seqHeadStart(XqueryCtx* ctx, BAT* item) {
    if (ctx->printMode) {
        /* write SQL-ish header */
        stream_printf(GDKout,"&1 %d %d 1 %d\n",
            id_sequence_counter++, BATcount(item), BATcount(item));
        stream_printf(GDKout,"# xquery_result\t# table_name\n");
        stream_printf(GDKout,"# xml\t# name\n");
        stream_printf(GDKout,"# varchar\t# type\n");
        stream_printf(GDKout,"# %d\t# length\n", 60);
    } else if (ctx->dmMode == 0  && ctx->norootMode == 0) { /* dmMode has no header */
        if (ctx->noheaderMode == 0) {
            if (ctx->mapiMode) {
                stream_printf(GDKout,"=<?xml version=\"1.0\" encoding=\"utf-8\"?>\n=");
            } else if ( !ctx->saxMode ) {
                stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
            }
        }
        handle_startElement(ctx, NULL, ctx->restag);
        ctx->nAttrOnLine = 0;
    }
    return 1;
}

static int seqHeadEnd(XqueryCtx* ctx) {
    if (ctx->dmMode == 0  && ctx->norootMode == 0) { /* dmMode has no header */
        handle_attributeEnd(ctx, 0);
        if ( !ctx->saxMode )
            stream_printf(GDKout,
                    (ctx->mapiMode ? "\n=" : (ctx->printMode ? "\\n" : "\n")));
    }
    return 1;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static int  seqEnd(XqueryCtx* ctx) {
    if ( ctx->saxMode ) {
        if (!ctx->norootMode) {
            handle_endElement(ctx, NULL, ctx->restag, 0 /* not empty*/);
        }
    } else if (ctx->printMode) {
        /* do nothing! SQL-ish/MCL-ish output has no footer */
    } else if (ctx->dmMode) {
        stream_printf(GDKout, "\n");
    } else if (ctx->mapiMode) {
        stream_write(GDKout,"\n=", 2, 1);
        if (!ctx->norootMode) stream_printf(GDKout,"</%s>\n", ctx->restag);
    } else {
        stream_write(GDKout,"\n", 1, 1);
        if (!ctx->norootMode) stream_printf(GDKout, "</%s>\n", ctx->restag);
    }
    return 1;
}


/**
 * Emit a NODE element of an XQUERY/Pathfinder result sequence
 */
static int seqEmitNode(XqueryCtx* ctx, oid preVal, BAT* pre_frag, int top, int lastVal) {
    ptr res;
    /* incomplete, different for dmMode ?? */
    idxTVinWS(res,ctx,PRE_SIZE,preVal);
    return MY_xquery_pre_range(ctx,preVal,preVal+*(int*) res, pre_frag, top, lastVal);
}

/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
static int  seqEmitBool(XqueryCtx* ctx, int bv, int lastVal) {
    char *bool_str = (char*)(bv ? "true" : "false");

    if ( ctx->saxMode ) {
        return handle_characters(ctx,bool_str,0);
    } else if ( ctx->dmMode ) {
        stream_printf(GDKout,"%s ",bool_str);
    } else {
        ctx->nAttrOnLine++;
        if ( ctx->typedMode ) {
            stream_printf(GDKout,"<xs:boolean>\n");
        }
        stream_printf(GDKout,"%s ",bool_str);
        if ( ctx->typedMode ) {
            stream_printf(GDKout,"\n</xs:boolean>");
            if ( !lastVal )
                stream_printf(GDKout, "\n");
        }
    }
    return 1;
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
static int  seqEmitInt(XqueryCtx* ctx, lng iv, int lastVal) {
    if ( ctx->saxMode ) {
        char buff[32];

        sprintf(buff,"%lld",iv);
        return handle_characters(ctx,buff,0);
    } else if ( ctx->dmMode ) {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"%lld",iv);
    } else {
        ctx->nAttrOnLine++;
        if ( ctx->typedMode ) {
            stream_printf(GDKout,"<xs:integer>\n");
        }
        stream_printf(GDKout,"%lld ",iv);
        if ( ctx->typedMode ) {
            stream_printf(GDKout,"\n</xs:integer>");
            if ( !lastVal )
                stream_printf(GDKout, "\n");
        }
    }
    return 1;
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
static int  seqEmitDbl(XqueryCtx* ctx, dbl dv, int lastVal) {
    if ( ctx->saxMode ) {
        char buff[32];

        sprintf(buff,"%f",dv);
        return handle_characters(ctx,buff,0);
    } else if ( ctx->dmMode ) {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"%f",dv);
    } else {
        ctx->nAttrOnLine++;
        if ( ctx->typedMode ) {
            stream_printf(GDKout,"<xs:double>\n");
        }
        stream_printf(GDKout,"%f ",dv);
        if ( ctx->typedMode ) {
            stream_printf(GDKout,"\n</xs:double>");
            if ( !lastVal )
                stream_printf(GDKout, "\n");
        }
    }
    return 1;
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static int  seqEmitStr(XqueryCtx* ctx, str sv, int lastVal) {
    if ( ctx->saxMode ) {
        return handle_characters(ctx,sv,"text");
    } else if ( ctx->printMode ) { /* SQL-ish/MCL-ish mode */
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"\\\"");
        emit_escaped(sv, ctx->saxMode, 0 /*ALL*/);
        stream_printf(GDKout,"\\\"");
    } else if ( ctx->dmMode ) {
        ctx->nAttrOnLine++;
        stream_printf(GDKout,"\"");
        emit_escaped( sv, 1+ctx->mapiMode, 0/*ALL*/ );
        stream_printf(GDKout,"\"");
    } else {
        ctx->nAttrOnLine++;
        if ( ctx->typedMode ) {
            stream_printf(GDKout,"<xs:string>\n");
        }
        stream_printf(GDKout,"\"");
        emit_escaped( sv, 1+ctx->mapiMode, 0/*ALL*/);
        stream_printf(GDKout,"\" ");
        if ( ctx->typedMode ) {
            stream_printf(GDKout,"\n</xs:string>");
            if ( !lastVal )
                stream_printf(GDKout, "\n");
        }
    }
    return 1;
}

/**
 * Main XQUERY/Pathfinder result sequence printing routine. Arguments are
 * mode: "xml" or "sax"
 * ws : the working set
 * max_iter : often 1@0. we can also print multiple iters for soap or debugging
 * item/item/kind : sequence result BATs (iter as a constant bat)
 * intVAL,dblVAL,strVAL : BATSs containing the values of seq elements
 * remainder BATs: conatins the data for the document nodes
 *
 * iter and kind may be 'fake' (i.e. constant) bats and quite often are; item cannot be fake.
 *
 * The function iterates through the item/kind BAT's and retrieves the values
 * from the xxxVAL BATs. Then it calls one of the seqXXXXX() functions
 * defined above to handle the output generation.
 */

#define BATloop_off(b,p,q,w,o,s)\
        for(w=BUNsize(b), p=BUNptr(b,BUNindex(b,BUNfirst(b))+o), q=p+s*w; p<q; p+=w) 

int xquery_print_result(
        str  mode,
        BAT* ws,
        size_t niters,
        BAT* loop,
        BAT* iter,
        BAT* item, 
        BAT* kind,
        BAT* intVAL,
        BAT* dblVAL,
        BAT* strVAL)
{
    size_t xx, yy, curcnt = 0, maxcnt = BATcount(item), buncnt;
    XqueryCtx ctx_struct, *ctx = &ctx_struct;
    if ( !createWsContext(ctx,ws,-1,mode) )
        return GDK_FAIL;

    /* loop over the iterations (usually only 1) */
    for(yy=0; yy<niters; yy++, curcnt += buncnt) {
        oid it = *(oid*) BUNhead(loop, BUNptr(loop, BUNindex(loop, BUNfirst(loop))+yy));
        BUN p, q;
        ptr res;

        buncnt = maxcnt;
        if (niters > 1) {
            if (IS_FAKE_PROJECT(iter)) {
                if (*(oid*) BUNtail(iter, BUNfirst(iter)) != it) buncnt = 0;
            } else {
                /* in case of a non-constant iter bat, find out how many
                 * items we have in this iteration */
                BATloop_off(iter,p,q,xx,curcnt,maxcnt) 
                    if (*(oid*) BUNtail(iter,p) != it) break;
                buncnt = ((p - BUNfirst(iter)) / xx) - curcnt;
            }
        } 

        if ( !seqHeadStart(ctx, item) )
            return GDK_FAIL;
        if ( ! ctx->dmMode ) {
            /* If the mode is not the DM mode do a scan of all attributes here
             * and generate the appropriate calls to connect them to the
             * head tag of the result document
             */
            BATloop_off(item,p,q,xx,curcnt,buncnt) { 
                oid pre = *(oid*)BUNhead(item, p);
                oid valoid = *(oid*)BUNtail(item, p);
                int cmbn_frag_kind;
                idxTV(res,ctx,kind,pre);
                cmbn_frag_kind = *(int*)res;

                if ( XTRACT_KIND(cmbn_frag_kind) == ATTR ) {
                    int frag = XTRACT_FRAG(cmbn_frag_kind);
                    if ( !process_attr(ctx,frag,valoid,1/* top */) )
                        return GDK_FAIL;
                }
            }
        }
        if ( !seqHeadEnd(ctx) )
            return GDK_FAIL;
        /* */
        int cnt = 0; /* loopcounter, used for checking when to print commas. */
        BATloop_off(item,p,q,xx,curcnt,buncnt) {
            oid pre = *(oid*)BUNhead(item, p);
            oid valoid = *(oid*)BUNtail(item, p);
            int cmbn_frag_kind, lastVal = (p + xx < q ) ? 0 : 1;
            idxTV(res,ctx,kind,pre);
            cmbn_frag_kind = *(int*)res;
            if (ctx->printMode) {
                /* SQL-ish mode: write start of tuple and open string */
                stream_printf(GDKout, "[ \"");
            } else if ( cnt && ctx->dmMode  ) {
                /* should print a separator here */
                stream_printf(GDKout,"%s",ctx->dmSeparator);
            }
            switch( XTRACT_KIND(cmbn_frag_kind) ) {
                case ATTR:
                    if ( ctx->dmMode ) {
                        int frag = XTRACT_FRAG(cmbn_frag_kind);
                        if ( !process_attr(ctx,frag,valoid,1/* top */) )
                            return GDK_FAIL;
                    }
                    break;
                case ELEM:
                    {
                        int frag = XTRACT_FRAG(cmbn_frag_kind);
                        /* if ( ctx->dmMode ),check for first kind text { "t" }
                         * check idxTVinWSorFRGN(ctx,frag,PRE_KIND,valoid);
                         * for TEXT
                         */
                        /*
                        if( ctx->typedMode && cnt == 0) {
                            stream_printf(GDKout,"<xs:anyNode>\n");
                        }
                        */
                        int oldCtx = switchWsContext(ctx,frag);
                        BAT *b;
                        wsBAT(b,ctx,PRE_FRAG)
                            if ( !seqEmitNode(ctx, valoid, b, 1/*top*/, lastVal) )
                                return GDK_FAIL;
                        switchWsContext(ctx,oldCtx);

                        /*
                        if( ctx->typedMode && lastVal) {
                            stream_printf(GDKout,"\n</xs:anyNode>");
                        }
                        */

                        break;
                    };
                case NODE:
                    /* INCOMPLETE, suppose just ignore ?*/
                    break;
                case BOOL:
                    if ( !seqEmitBool(ctx,valoid, lastVal) )
                        return GDK_FAIL;
                    break;
                case DBL:
                case DEC:
                    idxTV(res,ctx,dblVAL,valoid);
                    if (!seqEmitDbl(ctx,*(dbl*)res, lastVal) )
                        return GDK_FAIL; /* INCOMPLETE ?diff between d and e */
                    break;
                case INT:
                    idxTV(res,ctx,intVAL,valoid);
                    if ( !seqEmitInt(ctx,*(lng*)res, lastVal) )
                        return GDK_FAIL;
                    break;
                case STR:
                case U_A:
                    idxTV(res,ctx,strVAL,valoid);
                    if ( !seqEmitStr(ctx,(str)res, lastVal) )
                        return GDK_FAIL;
                    break;
                default:
                    GDKerror("serialize.mx:xquery_print_result_main: [kind=%d, frag=%d]\n",
                            XTRACT_KIND(cmbn_frag_kind),XTRACT_FRAG(cmbn_frag_kind));
                    fatal_err(ctx,"UNKNOW_TYPE(\'%c\'ch(%d))\n",cmbn_frag_kind,cmbn_frag_kind);
                    return GDK_FAIL;
            }
            if (ctx->printMode) {
                /* SQL-ish mode: write end of string and end of tuple */
                stream_printf(GDKout,"\"\t]\n");
            }
            cnt++;
        }
        /* */
        if ( !seqEnd(ctx) )
            return GDK_FAIL;
    } 
    switchWsContext(ctx,-1); /* close all open context BAT's */
    return disposeWsContext(ctx)?GDK_SUCCEED:GDK_FAIL;
}

int xquery_print_result_loop(
        str  mode,
        BAT* ws,
        BAT* loop, 
        BAT* iter, 
        BAT* item, 
        BAT* kind,
        BAT* intVAL,
        BAT* dblVAL,
        BAT* strVAL)
{
    size_t niters = BATcount(loop);
    return xquery_print_result(mode, ws, niters?niters:1, loop, iter, item, kind, intVAL, dblVAL, strVAL);
}

int xquery_print_result_main(
        str  mode,
        BAT* ws,
        BAT* item, 
        BAT* kind,
        BAT* intVAL,
        BAT* dblVAL,
        BAT* decVAL,
        BAT* strVAL)
{
    (void) decVAL;
    return xquery_print_result(mode, ws, 1, item, item, item, kind, intVAL, dblVAL, strVAL);
}
/* vim:set shiftwidth=4 expandtab: */
