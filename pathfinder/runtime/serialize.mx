@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' the Database Group at the Technische Universitaet Muenchen, Germany.
@' It is now maintained by the Database Systems Group at the Eberhard
@' Karls Universitaet Tuebingen, Germany.  Portions created by the
@' University of Konstanz, the Technische Universitaet Muenchen, and the
@' Universitaet Tuebingen are Copyright (C) 2000-2005 University of
@' Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
@' 2008-2010 Eberhard Karls Universitaet Tuebingen, respectively.  All
@' Rights Reserved.
@'

@f serialize
@a Jan Flokstra
@a Jan Rittinger
@t serialize

@c
/**
 * The serialization code consists of 8 different blocks:
 * 
 *    I. LOCAL HELPER FUNCTIONS
 *       * local error routine
 *       * timer functions
 *       
 *   II. TAGNAME STACK HANDLING FUNCTIONS
 *       * tagname stack access (push/pop/find item)
 *       
 *  III. NAMESPACE HANDLING FUNCTIONS
 *       * namespace stack intialization/disposal
 *       * namespace stack access (push/pop/find item)
 *       * namespace attribute generation
 *         - elements
 *         - attributes (also contains the 'real' attribute callbacks)
 * 
 *   IV. THE DOCUMENT MANAGEMENT FUNCTIONS
 *       * lookup of values/columns in the working set container
 *
 *    V. THE CONTEXT NODE SERIALIZATION PART
 *       * attribute/node function that collect the nodes of a given
 *         range and its values before triggering the node callbacks
 *
 *   VI. INITIALIZATION AND CLEANUP FUNCTIONS OF THE MAIN ROUTINES 
 *       * intialization/disposal of the structures required by
 *         result drivers (e.g. serialization mode selection)
 *
 *  VII. THE MAIN XML DOCUMENT PRINTING PART
 *       * functions that lookup the document container and
 *         trigger the CONTEXT NODE SERIALIZATION PART
 * 
 * VIII. THE MAIN PATHFINDER QUERY RESULT SERIALIZATION
 *       * driver that triggers the respective callbacks and 
 *         helper functions (I.- VI.)
 */
@h
#ifndef SERIALIZE_H
#define SERIALIZE_H

#include "gdk.h"

/* boolean type `bool' and constants `true', `false' */
#ifdef HAVE_STDBOOL_H
#include <stdbool.h>
#elif !defined(HAVE_BOOL)
#define bool    char
#define true    (char)1
#define false   (char)0
#endif

#define SUCCESS true
#define PROBLEM false

#define MAXTAGDEPTH        1024

#define WS_BATS     WS_SIZE

/* serialization modes */
#define MODE_XML       (1 << 0)
#define MODE_DM        (1 << 1)
#define MODE_TEXT      (1 << 2)
#if 0
#define MODE_SAX       (1 << 3)
#endif
#define MODE_MAPI      (1 << 4)
#define MODE_SEQ       (1 << 5)
#define MODE_NO_ROOT   (1 << 6)
#define MODE_NO_HEADER (1 << 7) /* without the line <?xml ...?> */
#define MODE_TYPED     (1 << 8)
#define MODE_XRPC      (1 << 9)

#ifdef WIN32
#ifndef LIBSERIALIZE
#define serialize_export extern __declspec(dllimport)
#else
#define serialize_export extern __declspec(dllexport)
#endif
#else
#define serialize_export extern
#endif

serialize_export stream* xrpc_log_message(str msg, lng xrpc_seqnr);
extern int do_fn_deep_eq(BAT** resbat, BAT* ws, BAT* litem, BAT* lkind, BAT* ritem, BAT* rkind);

struct XmlNsFrame; /* forward */
typedef struct XmlNsFrame {
    char              *prefix;
    char              *uri;
    struct XmlNsFrame *prev;
    struct XmlNsFrame *next;
} XmlNsFrame;

typedef struct SerializeFrame {
    oid         limit;
    char       *prefix;
    char       *name;
    XmlNsFrame *nsMark;
} SerializeFrame;

/**
 * The definition of the working-set BAT structure. For every bat in the
 * working set there is a structure of this type in the wsMatrix matrix
 * representation of the working set. The first dimension is the container
 * of the bat and the second is the BAT id.
 */
typedef struct wsBatDescr {
    BAT *bat;
    ptr  fake_prj;
} wsBatDescr;

struct serializeFunStruct; /* forward */

/**
 * The serialization context structure. All context/runtime data is
 * accessed through this function.
 */
typedef struct XqueryCtx {
    stream*     out;      /* output stream */
    int         modes;     /* list of bit-wise encode modes */
    struct serializeFunStruct* driverFun; /* the output handling functions */
    void*       driverWs;  /* optional driver workspace */
    
    BAT*        ws;        /* working set BAT */
    int         wsConts;   /* The number of containers in the working set */
    wsBatDescr *wsMatrix;  /* the direct references to BATs collected in ws */
    
    XmlNsFrame *nsTop;     /* top of the namespace stack */
    /**
     * Next elements is a stack used during printing to store the
     * pre-value, name, namespace of the nodes currently being printed.
     */
    int         stackPtr;
    SerializeFrame tagStack[MAXTAGDEPTH];

    /* xrpc response header things */
    str         xrpc_module;
    str         xrpc_method;  
    str         xrpc_qid;
    str         xrpc_caller;
    str         xrpc_mode;
    str         xrpc_hostport;
    bit         xrpc_updating;
    lng         xrpc_seqnr;
    lng         xrpc_timeout;
    lng         time_exec;

    /* private application defined space */
    void*	_private;   
} XqueryCtx;

/**
 * printing callback struct
 *
 * XqueryCtx is only used by the sequence layout handlers
 * and serialization modes that print into a user-defined
 * buffer (whose reference is stored in the XqueryCtx).
 */ 
typedef struct serializeFunStruct {
    const char* name;
    /* the initialization handler */
    bool (*init)(XqueryCtx* ctx, char* args, char* restag,
                 char* resprefix);
    /* the clean up handler */
    bool (*cleanup)(XqueryCtx* ctx);

    /* handlers of start/end of serialization.  These functions are
     * only executed _once_ for every serialization. */
    bool (*handle_startSerialize)(XqueryCtx* ctx);
    bool (*handle_endSerialize)(XqueryCtx* ctx);
    
    /* the (part of) document handler functions */
    bool (*handle_startDocument)(XqueryCtx* ctx, oid pre);
    bool (*handle_endDocument)(XqueryCtx* ctx);
    bool (*handle_startElement)(XqueryCtx* ctx,
                                str prefix, str name, oid pre);
    bool (*handle_endElement)(XqueryCtx* ctx, str prefix, str name);
    bool (*handle_characters)(XqueryCtx* ctx, str chars);
    bool (*handle_ignorableWhitespace)(XqueryCtx* ctx, str chars);
    bool (*handle_comment)(XqueryCtx* ctx, str comm);
    bool (*handle_processingInstruction)(XqueryCtx* ctx,
                                         str target, str data);

    /* additional callbacks for attributes and
       start tag completion */
    bool (*complete_startElement)(XqueryCtx* ctx);
    bool (*complete_startElementEmpty)(XqueryCtx* ctx);
    bool (*handle_attribute)(XqueryCtx* ctx, 
                             str prefix, str loc, str value);

    /* the top level item handlers 
       (except elements, comments, and processing-instructions) */
    bool (*seqEmitBool)(XqueryCtx* ctx, int bv);
    bool (*seqEmitInt)(XqueryCtx* ctx, lng iv);
    bool (*seqEmitDbl)(XqueryCtx* ctx, dbl dv);
    bool (*seqEmitStr)(XqueryCtx* ctx, str sv);
    bool (*seqEmitAttribute)(XqueryCtx* ctx,
                             str prefix, str loc, str value);
    bool (*seqEmitTextnodes)(XqueryCtx* ctx, str chars);

    /* and finally the sequence layout handlers */
    bool (*seqStart)(XqueryCtx* ctx, int count);
    bool (*complete_seqStart)(XqueryCtx* ctx);
    bool (*seqEnd)(XqueryCtx* ctx);
    bool (*seqItemStart)(XqueryCtx* ctx, int kind);
    bool (*seqItemEnd)(XqueryCtx* ctx, int kind);
    bool (*seqItemSeparator)(XqueryCtx* ctx, int kind_bef, int kind_aft);
} serializeFunStruct;

/* list of all available callback routines */
extern struct serializeFunStruct
    nullSerializeFun,
#if 0
    saxSerializeFun,
#endif
    dmSerializeFun,
    mapi_dmSerializeFun,
    textSerializeFun,
    mapi_textSerializeFun,
    xmlSerializeFun,
    mapi_xmlSerializeFun,
    typed_xmlSerializeFun,
    mapi_typed_xmlSerializeFun,
    xrpc_xmlSerializeFun,
    mapi_xrpc_xmlSerializeFun,
    seqSerializeFun;

/* hack to allow direct calls in serialize_pftijah.mx */
int
xquery_print_doc_DRIVER (
    str                 mode, 
    serializeFunStruct *driverFun,
    char               *driverArg,
    BAT                *ws,
    str                 docName);

/* hack to allow direct calls in serialize_pftijah_options.mx */
int
xquery_print_result_DRIVER (
    str                 mode,
    serializeFunStruct *driverFun, /* unused */
    char               *driverArg, /* unused */
    BAT                *ws,
    BUN                 niters,
    BAT                *loop,
    BAT                *iter,
    BAT                *item, 
    BAT                *kind,
    BAT                *intVAL,
    BAT                *dblVAL,
    BAT                *strVAL,
    /* xrpc response header things */
    str                xrpc_module,   
    str                xrpc_method,   
    str                xrpc_qid, 
    str                xrpc_caller, 
    str                xrpc_mode,
    str                xrpc_hostport,
    bit                *xrpc_updating,
    lng                *xrpc_seqnr,
    lng                *xrpc_timeout,
    lng                *xrpc_start);

/* hack to allow direct calls in xrpc_client.mx */
int
xquery_print_result_driver (
    stream             *fp,
    str                 mode,
    serializeFunStruct *driverFun, /* unused */
    char               *driverArg, /* unused */
    BAT                *ws,
    BUN                 niters,
    BAT                *loop,
    BAT                *iter,
    BAT                *item, 
    BAT                *kind,
    BAT                *intVAL,
    BAT                *dblVAL,
    BAT                *strVAL,
    /* xrpc response header things */
    str                xrpc_module,   
    str                xrpc_method,   
    str                xrpc_qid, 
    str                xrpc_caller, 
    str                xrpc_mode,
    str                xrpc_hostport,
    bit                *xrpc_updating,
    lng                *xrpc_seqnr,
    lng                *xrpc_timeout,
    lng                *time_exec);

#endif /* SERIALIZE_H */
@c

/*******************************************
 * serialize.c : XML serialization
 *
 */

#include <pf_config.h>
#include "serialize.h"
#include "pf_support.h"

static char* xrpc_log_dir(void);

/**
 *
 * I. LOCAL HELPER FUNCTIONS
 *
 */

/**
 * The local error handler for the serialization.
 */
static void
fatal_err(XqueryCtx* ctx, const char *msg, ...)
{
    va_list msgs;
    char    errmsg[1024];

    (void)ctx;
    va_start (msgs, msg);
    vsnprintf (errmsg, sizeof(errmsg), msg, msgs);
    errmsg[sizeof(errmsg) - 1] = 0;
    va_end (msgs);

    GDKerror("XML Generation: %s\n",errmsg);
}

/* some timer functions */
/* #define SHOW_TIMING */

#ifdef SHOW_TIMING

static char *
timer_str (long elapsed)
{
    char *tm, *str;

    tm = str = strdup ("000h 00m 00s 000ms 000us");

    if (elapsed / 3600000000UL) {
        str += sprintf (str, "%03ldh ", elapsed / 3600000000UL);
        elapsed %= 3600000000UL;
    }

    if (elapsed / 60000000UL) {
        str += sprintf (str, "%02ldm ", elapsed / 60000000UL);
        elapsed %= 60000000UL;
    }

    if (elapsed / 1000000UL) {
        str += sprintf (str, "%02lds ", elapsed / 1000000UL);
        elapsed %= 1000000UL;
    }

    if (elapsed / 1000UL) {
        str += sprintf (str, "%03ldms ", elapsed / 1000UL);
        elapsed %= 1000UL;
    }

    str += sprintf (str, "%03ldus", elapsed);

    return tm;
}

#define TIMER_START() \
        struct timeval now; \
        (void) gettimeofday (&now, 0); \
        long start = now.tv_sec * 1000000 + now.tv_usec;
#define TIMER_STOP(...) \
        gettimeofday (&now, 0); \
        long stop = now.tv_sec * 1000000 + now.tv_usec; \
        fprintf(stderr, __VA_ARGS__); \
        fprintf(stderr, ": %s\n", timer_str (abs (stop - start)));
#else
#define TIMER_START()
#define TIMER_STOP(...)
#endif


/**
 *
 * II. TAGNAME STACK HANDLING FUNCTIONS
 *
 */

/**
 * Three function to retrieve the pre-value, prefix or nodename of the
 * top element on the stack.
 */
#define topSF(ctx)    (&ctx->tagStack[(ctx)->stackPtr - 1])
#define topPrefix(ctx)    (topSF(ctx)->prefix)
#define topName(ctx)  (topSF(ctx)->name)

/**
 * Return true if there are still nodes on stack.
 */
#define moreTags(ctx) ((ctx)->stackPtr > 0)
#define someMoreTags(ctx,i) ((ctx)->stackPtr > (i))

/**
 * Push the pre-value, namespace and nodename of stack
 */
static bool
pushTag(XqueryCtx* ctx, oid pre, str prefix, str name) {
    ctx->tagStack[ctx->stackPtr].limit  = pre;
    ctx->tagStack[ctx->stackPtr].prefix = prefix;
    ctx->tagStack[ctx->stackPtr].name = name;
    ctx->tagStack[ctx->stackPtr].nsMark = NULL;
    ctx->stackPtr++;

    if (ctx->stackPtr == MAXTAGDEPTH)
        return PROBLEM;

    return SUCCESS;
}

/* forward declaration */
static void xmlNsPop2 (XmlNsFrame** top, XmlNsFrame* newTop);

/**
 * Pop the top element of the stack. Means that processing the node has
 * finished.
 */
static void
popTag (XqueryCtx* ctx) 
{
    XmlNsFrame *xnf;
    if ( (xnf = topSF(ctx)->nsMark) ) {
        xmlNsPop2(&ctx->nsTop,xnf->prev);
    }
    --ctx->stackPtr;
}


/**
 *
 * III. NAMESPACE HANDLING FUNCTIONS
 *
 */

/* #define DEBUGNS */

static void
xmlNsInit (XmlNsFrame** top)
{
#ifdef DEBUGNS
    stream_printf(GDKerr,"+NS:xmlNsInit()\n");
#endif

    *top = NULL;
}

static XmlNsFrame *
xmlNsPush (XmlNsFrame** top, char* prefix, char* uri)
{
    XmlNsFrame* fp = (XmlNsFrame*) GDKmalloc (sizeof (XmlNsFrame));

    if ( fp ) {
#ifdef DEBUGNS
        stream_printf (GDKerr, "+NS:xmlNsPush(\"%s\",\"%s\")\n", prefix, uri);
#endif
        fp->prefix = NULL;
        fp->uri    = NULL;

        if ( prefix && !(fp->prefix = GDKstrdup(prefix)) ) return NULL;
        if ( uri    && !(fp->uri    = GDKstrdup(uri))    ) return NULL;

        fp ->next  = NULL;
        if ( *top ) {
            (*top)->next = fp;
            fp->prev     = *top;
        } else {
            fp->prev = NULL;
        }
        *top     = fp;
    }
    return fp;
}

static void
xmlNsPop2 (XmlNsFrame** top, XmlNsFrame* newTop)
{
    XmlNsFrame* fp = (*top);

#ifdef DEBUGNS
    stream_printf(GDKerr,"+NS:xmlNsPop2(%d)\n",(int)newTop);
#endif

    while (fp != newTop ) {
        XmlNsFrame* old = fp;
        fp = fp->prev;
#ifdef DEBUGNS
        stream_printf(GDKerr,
                      "+NS:-popping(\"%s\",\"%s\")\n",
                      old->prefix, old->uri);
#endif
        GDKfree(old->prefix);
        GDKfree(old->uri);
        GDKfree(old);
    }
    
    *top = newTop;

    if (newTop) {
        (*top)->next = NULL;
    };
}

static void
xmlNsDispose(XmlNsFrame** top)
{
    xmlNsPop2(top,NULL);
}

static char *
xmlNsPrefixFind (XmlNsFrame** top, char* uri)
{
    XmlNsFrame* fp = (*top);

    while( fp ) {
        if (fp->uri != NULL &&
            !strcmp (uri, fp->uri)) {
#ifdef DEBUGNS
            stream_printf (GDKerr,
                           "+NS:xmlNsPrefixFind(\"%s\")=\"%s\")\n",
                           uri, fp->uri);
#endif
            return fp->prefix;
        }
        fp = fp->prev;
    }
    return NULL;
}

static char *
xmlNsUriFind (XmlNsFrame** top, char* prefix)
{
    XmlNsFrame* fp = (*top);

    while( fp ) {
        if (fp->prefix != NULL &&
            !strcmp (prefix, fp->prefix)) {
#ifdef DEBUGNS
            stream_printf (GDKerr,
                           "+NS:xmlNsUriFind(\"%s\")=\"%s\")\n",
                           prefix, fp->prefix);
#endif
            return fp->uri;
        }
        fp = fp->prev;
    }
    return NULL;
}

@= addNsLink
    /* link the current namespace entry (xnf)
       to the active element node (topSF(ctx)) */ 
    SerializeFrame* sf = topSF(ctx);

    if ( !sf->nsMark ) {
        /* not the first nsFrame in this context */
        sf->nsMark = xnf;
    }

@= checkElemNsChange
/**
 * Namespace checking function for element that introduces a namespace
 * attribute whenever necessary.
 *
 * This function relies on the fact that each element can redefine
 * every namespace (except the special ones) as it creates a new 
 * 'namespace scope'.
 */
static bool
check@1NsChange (XqueryCtx* ctx, str par_uri, str par_prefix)
{
    char *uri, *prefix;

    assert (par_uri && par_prefix);

    if (!strcmp (par_uri, str_nil))
        uri = NULL;
    else
        uri = par_uri;

    if (!strcmp (par_prefix, str_nil))
        prefix = NULL;
    else
        prefix = par_prefix;

    char* currentURI = xmlNsUriFind (&ctx->nsTop, prefix);
    
    /* either: matching prefix found and URIs differ 
       -> redefine namespace
       or: no matching prefix found and we have a namespace that differs from
           the default element namespace (prefix = "", uri = "")
       -> define namespace */
    if ( (currentURI && strcmp (currentURI, uri)) ||
         (!currentURI && (*par_prefix != 0 || *par_uri != 0)) ) {
        
        /* redefine this prefix with the new URI */
        XmlNsFrame* xnf;

        if ( !(xnf = xmlNsPush (&ctx->nsTop, prefix, uri)) ) {
            fatal_err(ctx,"xmlNsPush: out of memory\n");
            return PROBLEM;
        }
        /* generate the xmlns:xxx=uri tag */
        ctx->driverFun->@2 (ctx, "xmlns", prefix, uri);

        @3
    }
    return SUCCESS;
}
@c
@:checkElemNsChange(Elem,handle_attribute,@:addNsLink@)@
@:checkElemNsChange(TopAttrHelper,seqEmitAttribute,(void)xnf; /* pacify compiler */)@

@= checkAttrNsChange
static bool
check@1AttrNsChange (XqueryCtx* ctx,
                     str par_uri,
                     str par_prefix,
                     str loc,
                     str val)
{
    char *uri, *prefix;

    assert (par_uri && par_prefix);

    /* attributes without prefix do not have a namespace */
    if (*par_prefix == 0)
        return ctx->driverFun->@2 (ctx, par_prefix, loc, val);

    if (!strcmp (par_uri, str_nil))
        uri = NULL;
    else
        uri = par_uri;

    if (!strcmp (par_prefix, str_nil))
        prefix = NULL;
    else
        prefix = par_prefix;

/* @3 is bound to 1 in case of a top level attribute
   and 0 otherwise. This allows more readable C macros in-place
   instead of pasting the code with Mx macros */

#if @3 /* top level attribute */
    XmlNsFrame *fp = ctx->nsTop;
    
    /* check in current node context if a namespace
       with this prefix is declared */
    while (fp) {
        if (!strcmp (prefix, fp->prefix))
            break;
            
        fp = fp->prev;
    }
#else /* embedded attribute */
    XmlNsFrame *limit = topSF(ctx)->nsMark,
               *fp = ctx->nsTop;
    
    /* no namespace conflicts arise in the current element */
    if (!limit) {
        if (!check@4NsChange (ctx, par_uri, par_prefix))
            return PROBLEM;

        return ctx->driverFun->@2 (ctx, prefix, loc, val);
    }


    /* check in current node context if a namespace
       with this prefix is declared */
    while (fp) {
        if (!strcmp (prefix, fp->prefix))
            break;
            
        if (fp == limit)
            fp = NULL;
        else
            fp = fp->prev;
    }
#endif
    
    /* no namespace conflicts arise in the namespace stack */
    if (!fp) {
        if (!check@4NsChange (ctx, par_uri, par_prefix))
            return PROBLEM;

        return ctx->driverFun->@2 (ctx, prefix, loc, val);
    }


    /* uri and prefix match -> no namespace attribute needed */
    if (!strcmp (uri, fp->uri))
        return ctx->driverFun->@2 (ctx, prefix, loc, val);


    /* uri is defined with an available (but differing) prefix:
       use the alternative prefix */
    char *currentUri, *currentPrefix = xmlNsPrefixFind (&ctx->nsTop, uri);
    if (currentPrefix && 
        (currentUri = xmlNsUriFind (&ctx->nsTop, currentPrefix)) &&
        /* check if prefix has been redeclared */
        !strcmp (currentUri, uri))
        return ctx->driverFun->@2 (ctx, currentPrefix, loc, val);


    /* no alternatives left - generate new prefix */
    int i = 1;
    char *newPrefix = (char *) GDKmalloc (strlen (prefix) + sizeof ("_000"));
    sprintf (newPrefix, "%s_%i", prefix, i);
    
    /* check if new prefix is unused (and generate new one if used) */
    while (xmlNsUriFind (&ctx->nsTop, newPrefix)) {
        i++;
        if (i == 1000) { GDKfree (newPrefix); return PROBLEM; }
        sprintf (newPrefix, "%s_%i", prefix, i);
    }
        
    /* store this new prefix with the URI */
    XmlNsFrame* xnf;

    if ( !(xnf = xmlNsPush (&ctx->nsTop, newPrefix, uri)) ) {
        fatal_err(ctx,"xmlNsPush: out of memory\n");
        { GDKfree (newPrefix); return PROBLEM; }
    }
    /* generate the xmlns:xxx=uri tag */
    if (!ctx->driverFun->@2 (ctx, "xmlns", newPrefix, uri))
        { GDKfree (newPrefix); return PROBLEM; }

    @5 /* link the current namespace entry to the active element node */
        
    if (!ctx->driverFun->@2 (ctx, newPrefix, loc, val))
        { GDKfree (newPrefix); return PROBLEM; }

    GDKfree (newPrefix);

    return SUCCESS;
}        
@c
@:checkAttrNsChange(,   handle_attribute,0,Elem,         @:addNsLink@)@
@:checkAttrNsChange(Top,seqEmitAttribute,1,TopAttrHelper,(void)xnf; /* pacify compiler */)@


/**
 *
 * IV. THE DOCUMENT MANAGEMENT FUNCTIONS
 *
 */

/* #define DEBUGWS */

/**
 * Functions fills a new context() record with mode and BAT data and
 * initializes all other data structures.
 */

#define CHECKWSMI(CTX,F,B,R) if (((F)>=CTX->wsConts)||((B)>=WS_BATS)) \
    { fatal_err (CTX,"WSbat [%d,%d] out of range.",F,B); R; }
#define WSMI(F,B) ((F)*WS_BATS+B)

#define IS_FAKE_PROJECT(b) ((b->batCount == 1) & \
                            (b->hseqbase == oid_nil) & \
                            (b->htype == TYPE_void))

static bool
initWsMatrix(XqueryCtx* ctx)
{
    oid first = 0;
    BUN bun;
    BAT* batbat = NULL;
    if ( (bun = BUNfnd(ctx->ws,&first)) == BUN_NONE ) {
        fatal_err(ctx,"initWsMatrix: cannot find ws-bat[0]");
        return PROBLEM;
    }
    if ( !( batbat = BATdescriptor(*(bat*)Tloc(ctx->ws, bun))) ) {
        fatal_err(ctx,"initWsMatrix: cannot find ws-bat[0]");
        return PROBLEM;
    }

    ctx->wsConts = BATcount(batbat);
    BBPunfix( BBPcacheid( batbat ) );
    if ( !( ctx->wsMatrix = (wsBatDescr*) GDKmalloc(ctx->wsConts*WS_BATS*sizeof(wsBatDescr))) ) {
        return PROBLEM;
    }
    for(int i=0; i<ctx->wsConts; i++) {
        for(int j=0; j<WS_BATS; j++) {
         CHECKWSMI(ctx,i,j,return PROBLEM);
         wsBatDescr* bd = &ctx->wsMatrix[WSMI(i,j)];

         bd->bat = NULL;
        }
    }
#ifdef DEBUGWS
    stream_printf(GDKerr, "+ initWsMatrix(wsConts=%d, wsBats=%d).\n",
                  ctx->wsConts, ctx->wsBats);
#endif

    return SUCCESS;
}

static bool
disposeWsMatrix(XqueryCtx* ctx)
{
    for(int i=0; i<ctx->wsConts; i++) {
        for(int j=0; j<WS_BATS; j++) {
         CHECKWSMI(ctx,i,j,continue);
         wsBatDescr* bd = &ctx->wsMatrix[WSMI(i,j)];

         if ( bd->bat ) {
#ifdef DEBUGWS
          stream_printf(GDKerr,
                              "+ disposeWsMatrix(close(cont=%d,bats=%d))\n",
                              i, j);
#endif
          BBPunfix( BBPcacheid( bd->bat ) );
          bd->bat = NULL;
         }
        }
    }
#ifdef DEBUGWS
    stream_printf(GDKerr,"+ disposeWsMatrix() finished.\n");
#endif
    return SUCCESS;
}

static BAT *
fetchWsBaseBAT(XqueryCtx* ctx, BAT* ws, int batID)
{
    BUN bun;
    oid BATid = (oid)batID;

    if ( (bun = BUNfnd(ws,&BATid)) == BUN_NONE ) {
        fatal_err(ctx,"fetchWsContextBAT: NOT FOUND BAT[%d]",batID);
        return NULL;
    }
    BAT* batbat;
    if ( !( batbat = BATdescriptor(*(bat*)Tloc(ws, bun))) ) {
        fatal_err(ctx,
                  "fetchWsBaseBAT:FETCH BASEBAT for WS[%d] FAILED\n",
                  batID);
        return NULL;
    }
    return batbat;
}

/* lookup a BAT referenced in the working set BAT ws by batID and contID */
static BAT *
fetchWsContextBAT (XqueryCtx* ctx, BAT* ws, int contID, int batID)
{
    BUN bun;
    oid BATid = (oid)batID;
    oid CONTid  = (oid)contID;

    if ( contID < 0 ) {
        fatal_err(ctx,"fetchWsContextBAT: NO contID CONTEXT SELECTED");
        return NULL;
    }
    if ( (bun = BUNfnd(ws,&BATid)) == BUN_NONE ) {
        fatal_err(ctx,"fetchWsContextBAT: NOT FOUND BAT[%d]",batID);
        return NULL;
    }
    BAT* batbat;
    if ( !( batbat = BATdescriptor(*(bat*)Tloc(ws, bun))) ) {
        fatal_err(ctx,
                  "fetchWsContextBAT:FETCH BATBAT for WS[%d][%d] FAILED\n",
                  batID, contID);
        return NULL;
    }
    BUN bbun = BUNfnd(batbat,&CONTid);
    BAT *res = NULL;
    if ( bbun == BUN_NONE ) {
        BBPunfix( BBPcacheid( batbat ) );
        fatal_err(ctx,
                  "fetchWsContextBAT:NOT FOUND BAT[%d][%d] in WS!!!!\n",
                  batID, contID);
        return NULL;
    } else {
        if ( !(res = BATdescriptor(*(bat*)Tloc(batbat, bbun))) ) {
            BBPunfix( BBPcacheid( batbat ) );
            fatal_err(ctx,
                      "fetchWsContextBAT:FETCH WS[%d][%d] FAILED\n",
                      batID,contID);
            return NULL;
        }
    }
    BBPunfix( BBPcacheid( batbat ) );
    return res;
}

/* lookup a BAT referenced by batID and contID.
   -- If the BAT is not already loaded it will be looked
   up in the working set BAT ws */
static wsBatDescr *
getMatrixBATrecord (XqueryCtx* ctx, int contID, int batID)
{
    wsBatDescr* bd;

    CHECKWSMI(ctx,contID,batID,return PROBLEM);
    bd = &ctx->wsMatrix[WSMI(contID,batID)];
    
    if ( !bd->bat ) {
        if ( !(bd->bat = fetchWsContextBAT(ctx,ctx->ws,contID,batID)) ) {
#ifdef DEBUGWS
         stream_printf(GDKerr,
                          "+ getMatrixBAT(open(cont=%d,bats=%d)) = FAIL\n",
                          contID, batID);
#endif
         return NULL;
        }
        if ( IS_FAKE_PROJECT(bd->bat) ) {
	     BATiter bi = bat_iterator(bd->bat);
             bd->fake_prj = BUNtail(bi,BUNfirst(bd->bat));
        } else
             bd->fake_prj = 0;
     
#ifdef DEBUGWS
     stream_printf(GDKerr,
                      "+ getMatrixBAT(open(cont=%d,bats=%d)) = SUCCES\n",
                      contID, batID);
#endif
    }
    return bd;
}

static INLINE BAT *
getMatrixBAT (XqueryCtx* ctx, int contID, int batID)
{
     wsBatDescr* res = getMatrixBATrecord(ctx,contID,batID);

     return (res?res->bat:NULL);
}

/**
 * The getWsBAT() function is responsible for the BAT with index
 * 'batID from container' contID in the working set
 */
#define getWsBAT(_b, bi, ctx, contID, batID) {                        \
    _b = getMatrixBAT(ctx,contID,batID);                              \
    if ( _b == NULL ) {                                               \
        fatal_err(ctx, "getWsBAT(id=%d,cont=%d) fails",batID,contID); \
        return GDK_FAIL;                                              \
    }                                                                 \
    bi = bat_iterator(_b); (void)bi;				      \
}

static int
idxTVerror1 (XqueryCtx* ctx, BAT *b, oid oid_index)
{ 
    fatal_err(ctx, "%s BAT does not have a " OIDFMT " head.\n",
             b?BBP_logical(b->batCacheid):"NULL", oid_index);
    return GDK_FAIL;
}

static int
idxTVerror2 (XqueryCtx* ctx, BAT *b)
{ 
    BATprint(b); 
    fatal_err(ctx, "%s BAT is empty.\n",
             b?BBP_logical(b->batCacheid):"NULL");
    return GDK_FAIL;
}

static int
idxTVerror3 (XqueryCtx* ctx, BAT *b, oid oid_index)
{ 
    fatal_err(ctx, "%s BAT has a " OIDFMT " head, but tail is NULL.\n",
             b?BBP_logical(b->batCacheid):"NULL", oid_index);
    return GDK_FAIL;
}

/**
 * Utility function. It reads the tail value of an element in a
 * [void,any] BAT indexed by oid_index.
 */
#define findTailValue(res, ctx, b, oid_index) {                 \
    BATiter bi = bat_iterator(b);				\
    /* fprintf(stderr,"** idxTV()\n");*/               		\
    if (IS_FAKE_PROJECT(b)) {                                   \
        res = BUNtail(bi,BUNfirst(b)); /* fake project */       \
    } else if (b->batCount) {                                   \
        BUN _bun = BUN_NONE;                                    \
        BUNfndVOID(_bun, bi, &oid_index);                       \
        if (_bun == BUN_NONE)                                   \
            return idxTVerror1(ctx,b,oid_index);                \
        res = BUNtail(bi,_bun);                                 \
    } else                                                      \
        return idxTVerror2(ctx,b);                              \
    if (res == NULL)                                            \
        return idxTVerror3(ctx,b,oid_index);                    \
}

#define findTailValue2(fun, res, b, oid_index) {                \
    BATiter bi = bat_iterator(b);				\
    BUN _bun = BUN_NONE;                                        \
    _bun = fun (b, oid_index);                                  \
    if (_bun == BUN_NONE)                                       \
        return idxTVerror1 (ctx, b, oid_index);                 \
    res = BUNtail (bi, _bun);                                    \
    if (res == NULL)                                            \
        return idxTVerror3(ctx,b,oid_index);                    \
}
        
#define getWsValue(RES, ctx, contID, batID, oid_index) {        \
    RES = readWsValue(ctx,contID,batID,oid_index);              \
    if ( RES == NULL )                                          \
        return idxTVerror3(ctx,NULL,oid_index);                 \
}

static ptr
readWsValue (XqueryCtx* ctx, int contID, int batID, oid oid_index)
{
    wsBatDescr* mr = getMatrixBATrecord(ctx,contID,batID);

    if ( mr ) {
        if ( mr->fake_prj)
          return mr->fake_prj;
        else {
            BAT* b = mr->bat;
            BATiter bi = bat_iterator(b);

            if (b->batCount) {
                BUN _bun = BUN_NONE;
                BUNfndVOID(_bun, bi, &oid_index);
                if (_bun == BUN_NONE) {
                    idxTVerror1(ctx,b,oid_index);
                    return NULL;
                }
                return BUNtail(bi,_bun);
            } else {
                idxTVerror2(ctx,b);
                return NULL;
            }
        }
    }
    return NULL;
}


/**
 *
 * V. THE CONTEXT NODE SERIALIZATION PART
 *
 */

/**
 * Handle the generation of an attribute with oid 'id'
 * stored in container 'cont'.
 */
@= process_attr
static bool
process_@1attr (XqueryCtx* ctx, int cont, oid id)
{
    str val, uri, prefix, loc; 
    oid qn_oid, prop_oid;
    int acont;
    ptr r;

    getWsValue(r, ctx, cont,  ATTR_PROP, id);       prop_oid = *(oid*)      r;
    getWsValue(r, ctx, cont,  ATTR_CONT, id);       acont    = (int)*(oid*) r;
    getWsValue(r, ctx, acont, PROP_VAL,  prop_oid); val      = (str)        r;
    getWsValue(r, ctx, cont,  ATTR_QN,   id);       qn_oid   = *(oid*)      r;
    getWsValue(r, ctx, acont, QN_URI,    qn_oid);   uri      = (str)        r;
    getWsValue(r, ctx, acont, QN_PREFIX, qn_oid);   prefix   = (str)        r;
    getWsValue(r, ctx, acont, QN_LOC,    qn_oid);   loc      = (str)        r;

    /* generate the attribute callbacks 
       (and if necessary the corresponding namespace attributes) */
    return check@2AttrNsChange (ctx, uri, prefix, loc, val);
}
@c
@:process_attr(top_,Top)@
@:process_attr(,)@

/**
 * Generate all the attributes linked to a certain node 'pre' 
 * in container 'cont'.
 */
static bool
process_node_attr (XqueryCtx* ctx, int cont, oid pre) {
    BAT     *pre_nid, *attr_own_shr, *attr_own_prv, *attr_own_chk;
    BATiter pre_nidi, attr_own_shri, attr_own_prvi, attr_own_chki;
    BUN idx;
    oid base, nid = oid_nil, *attr_own;
    BUN p;
    
    /* translate pre value into nid value */
    getWsBAT(pre_nid, pre_nidi, ctx,cont,PRE_NID);
    BUNfndVOID(p, pre_nidi, &pre);
    if ( p != BUN_NONE ) {
        nid = *(oid*)BUNtail(pre_nidi,p);
    } else {
        fatal_err(ctx,"process_node_attr: "OIDFMT" not within ["OIDFMT","OIDFMT"]", 
                  pre, *(oid*)BUNhead(pre_nidi,BUNfirst(pre_nid)), 
                  *(oid*)BUNhead(pre_nidi,BUNlast(pre_nid)-1));
        return PROBLEM;
    }

    /* look up all the attribute ids for a given nid 
     * for updatable bats, we had to create a hash table for each serialization (query).
     * the solution is to use an out-of-date shared attr_own bat with a hash table
     * in conjunction with a (presumably small) private new part.
     */

    /* first probe the private (i.e. last) part of the attr table */
    getWsBAT(attr_own_prv, attr_own_prvi, ctx, cont, ATTR_OWN_PRIVATE);
    base = attr_own_prv->hseqbase - BUNfirst(attr_own_prv);
    attr_own_prvi.b = attr_own_prv = BATmirror(attr_own_prv);
    if (BATprepareHash(attr_own_prv)) {
        fatal_err(ctx,"process_node_attr: hash table creation\n");
        return PROBLEM;
    }
    HASHloop_oid(attr_own_prvi, attr_own_prv->H->hash, idx, (ptr)&nid) {
        oid id = base + idx;
        if ( ! process_attr (ctx, cont, id) )
            return PROBLEM;
    }

    /* then check the old shared part that has a hash table. 
     * results need to be checked against the current version and nils filtered out.
     */
    getWsBAT(attr_own_chk, attr_own_chki, ctx, cont, ATTR_OWN);
    getWsBAT(attr_own_shr, attr_own_shri, ctx, cont, ATTR_OWN_SHARED);
    base = attr_own_shr->hseqbase - BUNfirst(attr_own_shr);
    attr_own = ((oid*) Tloc(attr_own_chk, BUNfirst(attr_own_chk))) - base;
    attr_own_shri.b = attr_own_shr = BATmirror(attr_own_shr);
    if (BATprepareHash(attr_own_shr)) {
        fatal_err(ctx,"process_node_attr: hash table creation\n");
        return PROBLEM;
    }
    HASHloop_oid(attr_own_shri, attr_own_shr->H->hash, idx, (ptr)&nid) {
        oid id = base + idx;
        if ( attr_own[id] != oid_nil && !process_attr (ctx, cont, id) )
            return PROBLEM;
    }
    return SUCCESS;
}

/**
 * Generate the subtree ranging from node 'pre' to node 'to'.
 */
static bool
emitNodesInRange_ (XqueryCtx* ctx, oid pre, oid to, BAT* pre_cont, oid cont,
                   int stack_offset)
{
    ptr res;
    chr kind;
    oid prop;
    int vCONT = cont;

    do {
        getWsValue(res,ctx,cont,PRE_KIND,pre);
        kind = *(chr*) res;
        
        /* jump over holes introduced by updates */
        if (kind == chr_nil) {
            getWsValue(res,ctx,cont,PRE_SIZE,pre);
            int size = (*(int*)res) & GDK_int_max;
            pre = pre + size + 1;
            continue;
        }
    
        /* print end element */
        while( someMoreTags(ctx, stack_offset) && pre > topSF(ctx)->limit ) {
            if ( !ctx->driverFun->handle_endElement(
                                      ctx,
                                      topPrefix(ctx),
                                      topName(ctx)) )
                return PROBLEM;
            popTag(ctx);
        }

        /* get container and value reference */
        if ( pre_cont ) {
            findTailValue(res,ctx,pre_cont,pre);
            vCONT = (int)*(oid*)res;
        }
        getWsValue(res,ctx,cont,PRE_PROP,pre);
        prop = *(oid*) res;
        
        switch( kind ) {
            case (char)0:
                {   /* ELEMENT */
                    str uri, prefix, name;
                    int size;
                    
                    getWsValue (res, ctx, vCONT, QN_URI, prop);
                    uri    = (str) res;
                    getWsValue (res, ctx, vCONT, QN_PREFIX, prop);
                    prefix = (str) res;
                    getWsValue (res, ctx, vCONT, QN_LOC, prop);
                    name   = (str) res;

                    if (!ctx->driverFun->handle_startElement(
                                             ctx,
                                             prefix,
                                             name,
                                             pre))
                        return PROBLEM;

                    getWsValue(res,ctx,cont,PRE_SIZE,pre);
                    size = *(int*)res;

                    /* We always have to push the tag as the
                       namespace resolution may refer to it. */
                    if (!pushTag(ctx,pre+size,prefix,name))
                        return PROBLEM;

                    /* check for change of prefix/uri.  */
                    if (!checkElemNsChange (ctx, uri, prefix))
                        return PROBLEM;
                        
                    /* trigger the serialization of the corresponding
                       attributes. */
                    if (!process_node_attr(ctx,cont,pre))
                        return PROBLEM;

                    if (size) {
                        if (!ctx->driverFun->complete_startElement(ctx))
                            return PROBLEM;
                    }
                    else {
                        popTag (ctx);
                        if (!ctx->driverFun->complete_startElementEmpty(ctx))
                            return PROBLEM;
                    }
                    break;
                }
            case (char)1:
                {   /* PFTEXT */
                    getWsValue(res,ctx,vCONT,PROP_TEXT,prop);
                    if (!ctx->driverFun->handle_characters (ctx, (str)res))
                        return PROBLEM;
                    break;
                }
            case (char)2:
                {   /* COMMENT */
                    getWsValue(res,ctx,vCONT,PROP_COM,prop);
                    if (!ctx->driverFun->handle_comment (ctx, (str)res))
                        return PROBLEM;
                    break;
                }
            case (char)3:
                {   /* PI */
                    str target, data;
                    getWsValue(res,ctx,vCONT,PROP_TGT,prop);
                    target = (str) res;
                    getWsValue(res,ctx,vCONT,PROP_INS,prop);
                    data = (str) res;
                    if (!ctx->driverFun->handle_processingInstruction (
                                             ctx, target, data))
                        return PROBLEM;
                    break;
                }
            case (char)4:
                {   /* DOCUMENT */
                    /* all callbacks are triggered in caller function */
                    break;
                }
            case (char)5:
                {   /* COLLECTION */
                    /* nothing to be done, here */
                    break;
                }
            case (char)6:
                {   /* REFERENCE */
                    /* recursively invoke node printing */
                    oid pre = prop, pre_size;
                    getWsValue(res, ctx, vCONT, PRE_SIZE, pre);
                    pre_size = pre + *(int*) res;

                    BAT *b;
                    BATiter bi;
                    getWsBAT(b, bi, ctx, vCONT, PRE_CONT);
                    if ( !emitNodesInRange_ (ctx,
                                             pre,
                                             pre_size,
                                             IS_FAKE_PROJECT(b)?NULL:b,
                                             vCONT,
                                             ctx->stackPtr) )
                        return PROBLEM;
                    break;
                }
            default:
                fatal_err (ctx,
                           "Unknown kind %d IN xquery_node_print",
                           (int)kind);
                return PROBLEM;
        }
        pre++;
    } while (pre <= to);

    /* in case the last nodes where deleted 
       we skipped the end element handling */
    while( someMoreTags(ctx, stack_offset) ) {
        if ( !ctx->driverFun->handle_endElement(
                                  ctx,
                                  topPrefix(ctx),
                                  topName(ctx)) )
            return PROBLEM;
        popTag(ctx);
    }

    return SUCCESS;
}
static bool
emitNodesInRange (XqueryCtx* ctx, oid pre, oid to, BAT* pre_cont, oid cont)
{
    return emitNodesInRange_ (ctx, pre, to, pre_cont, cont, 0);
}

/**
 *
 * VI. INITIALIZATION AND CLEANUP FUNCTIONS OF THE MAIN ROUTINES 
 *
 */
char* match(char* mode, char* key) {
    char *s = strstr(mode, key);
    char *t = s + strlen(key);
    if ((s != NULL) && (s == mode || s[-1] == '-') && (*t == 0 || *t == '-'))
        return s;
    return NULL;
}

static bool
createWsContext (XqueryCtx*        ctx,
                 BAT*              ws,
                 str               mode,
                 serializeFunStruct*    driverFun,
                 char*             driverArg,
                 stream*           fp)
{
    char *restag = NULL;
    char *resprefix = NULL;

    memset(ctx, 0, sizeof(XqueryCtx));

    /* set the output stream */
    ctx->out = fp;

    /* store the working set ws */
    ctx->ws = ws;
    
    /* initialize the namespace stack */
    xmlNsInit( &ctx->nsTop );
    
    /* reset the tagname stack */
    ctx->stackPtr  = 0;
    
    /* initialize the structure that stores the BAT
       references of the working set BATs */
    if ( !initWsMatrix(ctx) )
        return PROBLEM;
    
    /* reset the modes */
    ctx->modes = 0;

    /* choose a mode: {xml, dm, text, sax} */ 
    if (match(mode,"xml")) {
        ctx->modes = MODE_XML;

        /* four special options for xml mode:
           noroot, root-name, noheader, and typed */
        /* user specified result tag */
        restag = match(mode,"root");
        if (restag && restag[4]) {
            *restag = 0; /* cut off the suffix not to have false matches later */
            restag += 5; /* rest of mode is root tag */
        } else {
            restag = "XQueryResult"; /* default root tag */
        }
        if (match(mode,"noroot"))
            ctx->modes = ctx->modes | MODE_NO_ROOT;

        /* we may omit the synthetic root element */ 
        if (match(mode,"noheader"))
            ctx->modes = ctx->modes | MODE_NO_HEADER;

        /* we may wrap each item in an element
           specifying its type */
        if (match(mode, "xrpc")) {
            resprefix = "xrpc";
            ctx->modes = ctx->modes | MODE_XRPC;
            /* in "XRPC" mode, the line "<?xml ...?>" is printed by
             * handle_startSerialize() and we do not want to get this
             * line printed twice, so when "XRPC" mode is used,
             * "NO_HEADER" mode should also be used. */
            ctx->modes = ctx->modes | MODE_NO_HEADER;
        } else if (match(mode, "typed")) {
            resprefix = "result";
            ctx->modes = ctx->modes | MODE_TYPED;
        }
    }
    /* list seq mode before dm mode as it might be used a subclass */
    else if (match(mode, "seq"))
        ctx->modes = MODE_SEQ;
    else if (match(mode,"dm"))
        ctx->modes = MODE_DM;
    else if (match(mode,"text"))
        ctx->modes = MODE_TEXT;
#if 0
    else if (match(mode,"sax")) {
        ctx->modes = MODE_SAX;

        /* sax stream can be also enclosed
           in additional root element (or not) */
        restag = match(mode,"root");
        if (restag && restag[4]) {
            *restag = 0; /* cut off the suffix not to have false matches later */
            restag += 5; /* rest of mode is root tag */
        } else {
            restag = "XQueryResult"; /* default root tag */
        }
        if (match(mode,"noroot"))
            ctx->modes = ctx->modes | MODE_NO_ROOT;
    }
#endif
    else {
        /* no format chosen - use xml (with default root tag) */
        ctx->modes = MODE_XML;
        restag = "XQueryResult"; /* default root tag */
    }

    /* add mapi = characters at the start of each line */
    if ((ctx->modes & (MODE_DM | MODE_TEXT | MODE_XML )) &&
         match(mode,"mapi"))
        ctx->modes = ctx->modes | MODE_MAPI;


    /* choose the correct set of callback functions */
    if (driverFun) {
        ctx->driverFun = driverFun;
    }
#if 0
    else if ( ctx->modes & MODE_SAX ) {
        ctx->driverFun = & saxSerializeFun;
    }
#endif
    /* list seq mode before dm mode as it might be used a subclass */
    else if ( ctx->modes & MODE_SEQ ) {
        ctx->driverFun = & seqSerializeFun;
    }
    else if ( ctx->modes & MODE_DM ) {
        if ( ctx->modes & MODE_MAPI )
            ctx->driverFun = & mapi_dmSerializeFun;
        else
            ctx->driverFun = & dmSerializeFun;
    }
    else if ( ctx->modes & MODE_TEXT ) {
        if ( ctx->modes & MODE_MAPI )
            ctx->driverFun = & mapi_textSerializeFun;
        else
            ctx->driverFun = & textSerializeFun;
    }
    else if ( ctx->modes & MODE_XML ) {
        if ( ctx->modes & MODE_MAPI &&  ctx->modes & MODE_TYPED )
            ctx->driverFun = & mapi_typed_xmlSerializeFun;
        else if ( ctx->modes & MODE_MAPI && ctx->modes & MODE_XRPC )
            ctx->driverFun = & mapi_xrpc_xmlSerializeFun;
        else if ( ctx->modes & MODE_TYPED )
            ctx->driverFun = & typed_xmlSerializeFun;
        else if ( ctx->modes & MODE_XRPC )
            ctx->driverFun = & xrpc_xmlSerializeFun;
        else if ( ctx->modes & MODE_MAPI )
            ctx->driverFun = & mapi_xmlSerializeFun;
        else
            ctx->driverFun = & xmlSerializeFun;
    }
    else
        return PROBLEM;
    
    if ( !ctx->driverFun->init(ctx, driverArg, restag, resprefix) )
        return PROBLEM;

    return SUCCESS;
}

static bool
disposeWsContext (XqueryCtx* ctx)
{
    xmlNsDispose( &ctx->nsTop );
    if ( !disposeWsMatrix(ctx) )
        return(0);
    return SUCCESS;
}

/**
 *
 * VII. THE MAIN XML DOCUMENT PRINTING PART
 *
 */

static BAT *
wsADMbat (BAT* ws, oid o)
{
    BAT* res = NULL;
    BUN b = BUNfnd(ws,&o);

    if ( b == BUN_NONE ) {
        fatal_err(0,"wsADMbat: unable to find bat[%d@0] in WS",o);
    } else {
        res = BATdescriptor(*(bat*)Tloc(ws,b));
    }
    return res;
}

static int
ws_documentIndex (BAT* ws, str docName)
{
    int res = PROBLEM;
    BAT* open_name;
    if ( !(open_name=wsADMbat(ws,OPEN_NAME)) ) {
        fatal_err(0,"ws_documentIndex: unable to find CONT_NAME in WS");
        return PROBLEM;
    }
    open_name = BATmirror(open_name);
    if (!BATprepareHash(open_name)) {
	BATiter open_namei = bat_iterator(open_name);
        BUN p;
        HASHfnd_str(p, open_namei, docName);
        if (p != BUN_NONE) {
            res = p - BUNfirst(open_name);
        }
    }
    BBPunfix( BBPcacheid( open_name ) );
    return res;
}

static oid
ws_documentContainer (BAT* ws, str docName)
{
    int res = PROBLEM;
    BAT* open_name;
    if ( !(open_name=wsADMbat(ws,OPEN_NAME)) ) {
        fatal_err(0,"ws_documentIndex: unable to find CONT_NAME in WS");
        return PROBLEM;
    }
    BAT* open_cont;
    if ( !(open_cont=wsADMbat(ws,OPEN_CONT)) ) {
        fatal_err(0,"ws_documentIndex: unable to find CONT_COLLID in WS");
        BBPunfix( BBPcacheid( open_name ) );
        return PROBLEM;
    }
    open_name = BATmirror(open_name);
    if (!BATprepareHash(open_name)) {
	BATiter open_namei = bat_iterator(open_name), open_conti = bat_iterator(open_cont);
        BUN p;
        HASHfnd_str(p, open_namei, docName);
        if (p != BUN_NONE) {
            BUN idx = p - BUNfirst(open_name);
	    res = idx;
            p = BUNfirst(open_cont) + idx;
            if (p < BUNlast(open_cont)) {
                res = *(oid*) BUNtail(open_conti, p); 
            }
        }
    }
    BBPunfix( BBPcacheid( open_name ) );
    BBPunfix( BBPcacheid( open_cont ) );
    return res;
}

oid doc_startOid(XqueryCtx* ctx, oid docIndex, oid docContainer) {
    BUN bun;

    BAT* open_docid;
    
    if ( !(open_docid = fetchWsBaseBAT(ctx,ctx->ws,OPEN_DOCID)) )
    	return oid_nil;

    if ( (bun = BUNfnd(open_docid,&docIndex)) == BUN_NONE) {
            fatal_err(ctx,"doc_startOid: cannot find startOid for doc[" OIDFMT "]",docIndex);
	          return oid_nil;
    }
    BATiter open_docidi = bat_iterator(open_docid);
    oid icdocId = *(oid*)BUNtail(open_docidi,bun);
    BAT* frag_root;
    BATiter frag_rooti;
    getWsBAT(frag_root, frag_rooti, ctx, docContainer, FRAG_ROOT);
    /* */
    if ( (bun = BUNfnd(frag_root,&icdocId)) == BUN_NONE ) {
            fatal_err(ctx,"doc_startOid: cannot find startOid for doc[" OIDFMT "]",docIndex);
	    return oid_nil;
    }
    return *(oid*)BUNtail(frag_rooti,bun);
}

int
xquery_print_doc_DRIVER (
    str                 mode, 
    serializeFunStruct *driverFun,
    char               *driverArg,
    BAT                *ws,
    str                 docName)
{
    TIMER_START();
    oid docIndex	= ws_documentIndex(ws,docName);
    oid docContainer	= ws_documentContainer(ws,docName);
    if (0) stream_printf(GDKout,"ws_[documentIndex,container](%s) = " OIDFMT "," OIDFMT "," OIDFMT "\n",docName,docIndex,docContainer);
    int res = GDK_FAIL;
    if (!docIndex) {
        GDKerror("serialize.mx: unable to find document \"%s\" in working set!\n", docName);
    } else { 
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        if (createWsContext(ctx,ws,mode,driverFun,driverArg,GDKout)) {
	    oid start_oid = doc_startOid(ctx,docIndex, docContainer);
            if (0) stream_printf(GDKout,"ws_[documentIndex,container,startOid](%s) = " OIDFMT "," OIDFMT "," OIDFMT "\n",docName,docIndex,docContainer,start_oid);
	    if ( start_oid == oid_nil )
	        return GDK_FAIL;
            if (ctx->driverFun->handle_startDocument(ctx,start_oid)) {
                ptr p;

                if ( 0 /* old implementation, restore if necessary */ ) {
                  getWsValue(p, ctx, docContainer, PRE_SIZE, 0 /* start */);
		  if (emitNodesInRange (ctx, 0,  *(int*) p, NULL, docContainer))
		    if (ctx->driverFun->handle_endDocument(ctx))
		        res = GDK_SUCCEED;
		} else { /* the new container implementation */
                  getWsValue(p, ctx, docContainer, PRE_SIZE, start_oid);
		  /* oid sz = *(int*) p; */
		  oid sz = (*(int*) p) & ~(1U<<31);
                  if (emitNodesInRange (ctx, start_oid,start_oid+sz, NULL, docContainer)) {
                    if (ctx->driverFun->handle_endDocument(ctx)) {
                        res = GDK_SUCCEED;
                    }
                  }
	        }
            }
        }
        if (!disposeWsContext(ctx)) {
            res = GDK_FAIL;
        }
    }
    TIMER_STOP("# serialization of \"%s\"",docName);
    return res;
}

/**
 *
 * VIII. THE MAIN PATHFINDER QUERY RESULT SERIALIZATION
 *
 */

static BUN
fake_lookup_bun (BAT *b, oid offset)
{
    BUN res = BUNfirst(b);
    (void) offset;
    return res;
}

static BUN
lookup_bun (BAT *b, oid offset)
{
    BATiter bi = bat_iterator(b);
    BUN res;
    BUNfndVOID(res, bi, &offset);

    return res;
}

/* misuse the SET_CONT_KIND macro to overload
   the kind values with the node kind */
#define COMBN_NKIND_KIND(X,Y) SET_CONT_KIND(X,Y)

#define BATloop_off(b,p,q,o,s)\
        for(p=BUNfirst(b)+o, q=p+s; p<q; p++) 

/**
 * Main XQUERY/Pathfinder result sequence printing routine. 
 * Arguments are
 * mode: e.g. "xml", "sax", "seq", "dm", "text", ("noroot", "typed")
 * ws : the working set
 * max_iter : often 1@0. we can also print multiple iters for XRPC or debugging
 * item/item/kind : sequence result BATs (iter as a constant bat)
 * intVAL,dblVAL,strVAL : BATSs containing the values of seq elements
 * remainder BATs: contains the data for the document nodes
 *
 * iter and kind may be 'fake' (i.e. constant) bats and quite often are;
 * item cannot be fake.
 *
 * The function iterates through the item/kind BAT's and retrieves either
 * the values from the xxxVAL BATs or the nodes. In the latter case it calls
 * one of the seqXXXXX() functions. The implementations of these callback
 * functions are provied in the serialize_*.mx files.
 */
int 
xquery_print_result_driver (
    stream*             fp,
    str                 mode,
    serializeFunStruct *driverFun, /* unused */
    char               *driverArg, /* unused */
    BAT                *ws,
    BUN                 niters,
    BAT                *loop,
    BAT                *iter,
    BAT                *item, 
    BAT                *kind,
    BAT                *intVAL,
    BAT                *dblVAL,
    BAT                *strVAL,
    /* xrpc response header things */
    str                xrpc_module,   
    str                xrpc_method,   
    str                xrpc_qid, 
    str                xrpc_caller, 
    str                xrpc_mode,
    str                xrpc_hostport,
    bit                *xrpc_updating,
    lng                *xrpc_seqnr,
    lng                *xrpc_timeout,
    lng                *time_exec)
{
    TIMER_START();

    BATiter loopi = bat_iterator(loop), iteri = bat_iterator(iter);
    BATiter itemi = bat_iterator(item);
    BUN yy, curcnt, maxcnt, buncnt;
    XqueryCtx ctx_struct, *ctx = &ctx_struct;
    static BUN (*fun_k) (BAT *, oid);

    /* prepare serialization */ 
    if ( !createWsContext (ctx, ws, mode, driverFun, driverArg, fp) )
        return GDK_FAIL;

    /* fill in the XRPC specific fields for the response header */
    ctx->xrpc_module = xrpc_module;
    ctx->xrpc_method = xrpc_method;
    ctx->xrpc_qid = xrpc_qid;
    ctx->xrpc_caller = xrpc_caller;
    ctx->xrpc_mode = xrpc_mode;
    ctx->xrpc_seqnr = xrpc_seqnr?*xrpc_seqnr:0;
    ctx->xrpc_updating = xrpc_updating?*xrpc_updating:0;
    ctx->xrpc_timeout = xrpc_timeout?*xrpc_timeout:0;
    ctx->time_exec = time_exec?*time_exec:0;
    ctx->xrpc_hostport = xrpc_hostport;

    curcnt = 0;
    maxcnt = BATcount (item);
    buncnt = maxcnt;
    
    /* decide lookup method for BAT kind once for all items */
    if (IS_FAKE_PROJECT(kind))
        fun_k = fake_lookup_bun;
    else
        fun_k = lookup_bun;

    /* Start of serialization, print everything that should only be
     * printed once every serialization. */
    if ( !ctx->driverFun->handle_startSerialize(ctx) )
        return GDK_FAIL;

    /* loop over the iterations (usually only 1) */
    for(yy=0; yy < niters; yy++, curcnt += buncnt, maxcnt -= buncnt) {
        oid cur_iter = *(oid*) BUNhead(loopi, BUNfirst(loop) + yy);
        oid index, valoid;
        BUN p, q;
        ptr res;
        int cmbn_cont_kind, cur_kind, old_kind, cont = 0;
        char node_kind = 0;

        /* modify buncnt (only necessary for multiple iterations) */
        if (niters > 1) {
            if (IS_FAKE_PROJECT(iter)) {
                /* iterations do not match */
                if (*(oid*) BUNtail(iteri, BUNfirst(iter)) != cur_iter)
                    buncnt = 0;
                else
                    buncnt = maxcnt;
            } else {
                /* in case of a non-constant iter bat, find out how many
                 * items we have in this iteration */
                BATloop_off (iter, p, q, curcnt, maxcnt) 
                    if (*(oid*) BUNtail(iteri, p) != cur_iter) break;
                buncnt = (p - BUNfirst(iter)) - curcnt;
            }
        }

        /**
         *
         * the output for one item sequence (or rather one iteration)
         *
         */
        
        /* start of item sequence callback */
        if ( !ctx->driverFun->seqStart(
                  ctx,
                  buncnt - curcnt /* number of items to print */) )
            return GDK_FAIL;

        /* some serialization modes may print all attributes up front
           (here xml and sax mode, where xml mode is not typed) */
        if (ctx->modes & (MODE_XML /* | MODE_SAX*/ ) && 
            /* TYPED and XRPC modes take care of attribute themselves */
            !(ctx->modes & MODE_TYPED) && !(ctx->modes & MODE_XRPC) &&
            /* forget top-level attributes if we have no root nodes */
            !(ctx->modes & (MODE_NO_ROOT)) ) {

            /* scan of all attributes here and generate the appropriate
               calls to connect them to the head tag of the result document */
            BATloop_off (item, p, q, curcnt, buncnt) { 
                index = *(oid*)BUNhead(itemi, p);
                valoid = *(oid*)BUNtail(itemi, p);
                findTailValue2 (fun_k, res, kind, index);
                cmbn_cont_kind = *(int*) res;

                if ( XTRACT_KIND(cmbn_cont_kind) == ATTR ) {
                    cont = XTRACT_CONT(cmbn_cont_kind);
                    if ( !process_top_attr (ctx, cont, valoid) )
                        return GDK_FAIL;
                }
            }
        }
        /* complete start of item sequence callback */
        if ( !ctx->driverFun->complete_seqStart(ctx) )
            return GDK_FAIL;

        /* process item sequence */
        old_kind = 0;

        BATloop_off (item, p, q, curcnt, buncnt) {
            index = *(oid*)BUNhead(itemi, p);
            valoid = *(oid*)BUNtail(itemi, p);
            findTailValue2 (fun_k, res, kind, index);
            cmbn_cont_kind = *(int*) res;
            cur_kind = XTRACT_KIND(cmbn_cont_kind);
            
            /* get the node kind information for correct
               item start/end printing */
            if (cur_kind == ELEM) {
                cont = XTRACT_CONT(cmbn_cont_kind);
                /* lookup node kind */
                getWsValue (res, ctx, cont, PRE_KIND, valoid);
                node_kind = *(chr*) res;
            }
            
            if (old_kind) /* skip the first iteration */
                /* add an item separator */
                if ( !ctx->driverFun->seqItemSeparator(
                               ctx, old_kind, cur_kind) )
                    return GDK_FAIL;
                
            /* start of item callback */
            if ( !ctx->driverFun->seqItemStart(
                                      ctx, 
                                      COMBN_NKIND_KIND (node_kind,
                                                        cur_kind)) )
                return GDK_FAIL;
                 
            switch( cur_kind ) {
                case ATTR:
                    /* print attributes for all modes that were skipped
                       before */
                    if (!(ctx->modes & (MODE_XML /*|MODE_SAX*/ )) ||
                        (ctx->modes & MODE_TYPED) ||
                        (ctx->modes & MODE_XRPC)) {
                        cont = XTRACT_CONT(cmbn_cont_kind);
                        if ( !process_top_attr (ctx, cont, valoid) )
                            return GDK_FAIL;

                        /* throw away all namespace declarations */
                        xmlNsDispose( &ctx->nsTop );
                    }
                    break;
                case ELEM:
                    {
                        /* node_kind and cont have been already looked up */
			if (!valoid) {
                    		GDKerror ("serialize.mx: cannot print the special collection node.\n");
                    		return GDK_FAIL;
			}

                        /* print top level text nodes */
                        if (node_kind == (char)1 /* TEXT */) {
                            oid prop, val_cont;
                            
                            /* get value container */
                            getWsValue(res, ctx, cont, PRE_CONT, valoid);
                            val_cont = *(oid*) res;
                            /* get value reference */
                            getWsValue(res, ctx, cont, PRE_PROP, valoid);
                            prop = *(oid*) res;

                            getWsValue (res, ctx, val_cont, PROP_TEXT, prop);
                            if ( !ctx->driverFun->seqEmitTextnodes (
                                                      ctx, (str)res) )
                                return GDK_FAIL; 
                            break;
                        }
                        /* print all other nodes (in most cases complete
                           subtrees) */
                        else {
                            oid pre = valoid, pre_size;
                            getWsValue(res, ctx, cont, PRE_SIZE, pre);
                            pre_size = pre + *(int*) res;

                            /* handle document start callback
                               if we have a document node */
                            if (node_kind == (char)4 /* DOCUMENT */)
                                if ( !ctx->driverFun->handle_startDocument (
                                                          ctx,pre) )
                                    return GDK_FAIL;

                            BAT *b;
			    BATiter bi;
                            getWsBAT(b, bi, ctx, cont, PRE_CONT);
                            if ( !emitNodesInRange (ctx, 
                                                    pre,
                                                    pre_size, 
                                                    IS_FAKE_PROJECT(b)?NULL:b,
                                                    cont) )
                                return GDK_FAIL;
                                
                            /* handle document end callback
                               if we have a document node */
                            if (node_kind == (char)4 /* DOCUMENT */)
                                if ( !ctx->driverFun->handle_endDocument (
                                                          ctx) )
                                    return GDK_FAIL; 

                            break;
                        }
                        break;
                    };
                case BOOL:
                    if ( !ctx->driverFun->seqEmitBool(ctx, valoid) )
                        return GDK_FAIL;
                    break;
                case DBL:
                case DEC:
                    findTailValue(res, ctx, dblVAL, valoid);
                    if (!ctx->driverFun->seqEmitDbl(ctx,*(dbl*)res) )
                        return GDK_FAIL; /* INCOMPLETE ?diff between d and e */
                    break;
                case INT:
                    findTailValue(res, ctx, intVAL, valoid);
                    if ( !ctx->driverFun->seqEmitInt(ctx,*(lng*)res) )
                        return GDK_FAIL;
                    break;
                case STR:
                case U_A:
                    findTailValue(res, ctx, strVAL, valoid);
                    if ( !ctx->driverFun->seqEmitStr(ctx,(str)res) )
                        return GDK_FAIL;
                    break;
                default:
                    GDKerror ("serialize.mx:xquery_print_result_main: "
                              "[kind=%d, cont=%d]\n",
                              cur_kind,
                              XTRACT_CONT(cmbn_cont_kind));
                    fatal_err (ctx, "UNKNOW_TYPE(\'%c\'ch(%d))\n",
                               cmbn_cont_kind, cmbn_cont_kind);
                    return GDK_FAIL;
            }

            /* end of item callback */
            if ( !ctx->driverFun->seqItemEnd(
                                      ctx, 
                                      COMBN_NKIND_KIND (node_kind,
                                                        cur_kind)) )
                return GDK_FAIL;

            /* this avoids the separator printing for attributes
               in the XML mode (without the typed xml mode) that
               have been removed from the result sequence */
            if (!(ctx->modes & (MODE_XML /* | MODE_SAX */ )) ||
                ctx->modes & MODE_TYPED ||
                cur_kind != ATTR)
                /* the kind value in 'cur_kind' 
                   is the old one for the next iteration */
                old_kind = cur_kind;
        }

        /* end of item sequence callback */
        if ( !ctx->driverFun->seqEnd(ctx) ) return GDK_FAIL;
    } 

    /* End of serialization, print everything that should only be
     * printed once every serialization. */
    if ( !ctx->driverFun->handle_endSerialize(ctx) )
        return GDK_FAIL;
    
    if ( !disposeWsContext(ctx) )
        return GDK_FAIL;

    TIMER_STOP("# result serialization");

    return GDK_SUCCEED;
}

int
draw_queryflow(
        int xrpc_updating,
        lng xrpc_seqnr,
        str xrpc_method,
        lng time_exec,
        str xrpc_hostport,
        BAT *participants)
{
    int ret = 0;
    stream *s = NULL;
    char *ptr = NULL, *logdir = xrpc_log_dir();
    char base_name[2048], dotFile[2052], caller[1024], dst[1024];
    char dstNID[1024], fcn[1024], time[64], *seqnr = NULL;
    char dotcmd[1024];
    BUN p, q;
    BATiter bi;

    if (logdir == NULL) return GDK_FAIL;
    snprintf(base_name, 2048, "%sqflow_"LLFMT, logdir, xrpc_seqnr);
    snprintf(dotFile, 2048, "%s.dot", base_name);

    /* replace all non-alpha-numeric chars in the string with '_', so
     * that it can be used as the ID of nodes in dot file */
    strcpy(dstNID, xrpc_hostport);
    for(ptr=dstNID; *ptr; ptr++) { 
        if(!isalnum(*ptr)) *ptr = '_'; 
    }

    if(!(s = open_wastream(dotFile))) return GDK_FAIL;
    ret = stream_printf(s,
            "digraph G {\n"
            " ratio=2\n"
            " node [style=filled, color=\".7 .3 1.0\"];\n"
            " subgraph cluster_%s {\n"
            "  node [style=filled,color=\"%s\"];\n"   
            "  style=filled;\n"
            "  color=yellow;\n"
            "  label=\"%s\";\n"
            "  %s_"LLFMT"[label=\"%s\"];\n"
            " }\n"
            " query->%s_"LLFMT"[headURL=\"http://%s/logs/req_"LLFMT".xml\"]\n"
            " %s_"LLFMT"->query[label=\""LLFMT"ms\",headURL=\"http://%/logs/res_"LLFMT".xml\"]\n\n",
            dstNID,
            (xrpc_updating==1)?"orange":(xrpc_updating==2)?"red":(xrpc_updating==3)?"green":".7 .3 1.0",
            xrpc_hostport,
            dstNID, xrpc_seqnr, xrpc_method,
            dstNID, xrpc_seqnr, xrpc_hostport, xrpc_seqnr,
            dstNID, xrpc_seqnr, time_exec, xrpc_hostport, xrpc_seqnr) < 0;

    bi = bat_iterator(participants);
    BATloop(participants, p, q) {
        if (sscanf(BUNtail(bi,p), "%[^','],%[^','],%[^','],%s,%d", caller, dst, fcn, time, &xrpc_updating) != 5) {
            GDKerror("draw_queryflow: sscanf failed");
            stream_destroy(s);
            return GDK_FAIL;
        }
        seqnr = strrchr(dst, ':');
        if(!seqnr) {
            GDKerror("draw_queryflow: invalid value of participant: %s.", dst);
            stream_destroy(s);
            return GDK_FAIL;
        }
        seqnr[0] = '\0'; /* cut off the seqnr from the dst string */
        seqnr++;

        ptr = caller;
        do { if(!isalnum(ptr[0])) ptr[0] = '_'; ptr++; } while (ptr[0]);

        strcpy(dstNID, dst);
        ptr = dstNID;
        do { if(!isalnum(ptr[0])) ptr[0] = '_'; ptr++; } while (ptr[0]);

        ret = ret || (stream_printf(s,
                " subgraph cluster_%s {\n"
                "   node [style=filled,color=\"%s\"];\n"
                "   style=filled;\n"
                "   color=yellow;\n"
                "   label=\"%s\";\n"
                "   %s_%s[label=\"%s\"];\n"
                " }\n"
                " %s->%s_%s[headURL=\"http://%s/logs/req_%s.xml\"]\n"
                " %s_%s->%s[label=\"%sms\",headURL=\"http://%s/logs/res_%s.xml\"]\n\n",
                dstNID,
                (xrpc_updating==1)?"orange":(xrpc_updating==2)?"red":(xrpc_updating==3)?"green":".7 .3 1.0",
                dst,
                dstNID, seqnr, fcn,
                caller, dstNID, seqnr, dst, seqnr,
                dstNID, seqnr, caller, time, dst, seqnr) < 0);
    }
    ret = ret || (stream_write(s, "}", 1, 1) < 0);
    stream_close(s);
    stream_destroy(s);
    
    snprintf(dotcmd, 1024, "dot -Tcmapx -o%s.xml -Tgif -o%s.gif %s 2> %s.err", base_name, base_name, dotFile, dotFile);
    if (ret || system(dotcmd) < 0) {
        GDKerror("draw_queryflow: failed to generate query flow graph using \"dot\"");
        return GDK_FAIL;
    }

    return GDK_SUCCEED;
}


char xrpc_logdir_buf[1024], *xrpc_logdir = NULL;
static char*
xrpc_log_dir(void) {
    char *docroot = NULL;
    if (xrpc_logdir == NULL && (docroot = GDKgetenv("xrpc_docroot")) != NULL) {
        snprintf(xrpc_logdir_buf, 1024, "%s%clogs%c", docroot, DIR_SEP, DIR_SEP);
        if (GDKcreatedir(xrpc_logdir_buf)) {
            xrpc_logdir = xrpc_logdir_buf;
        } else {
            GDKerror("get_xrpc_logdir: directory %s not writable.", xrpc_logdir_buf);
        }
    }
    return xrpc_logdir;
}


stream*
xrpc_log_message(str msg, lng xrpc_seqnr) {
    char logfile[1024], *logdir = xrpc_log_dir();
    stream* fp = NULL;
    if (logdir) {
        snprintf(logfile, 1024, "%s%s_" LLFMT ".xml", logdir, msg, xrpc_seqnr);
        fp = open_wastream(logfile);
    }
    if (!fp || stream_errnr(fp)) {
        GDKerror("print_result: could not open logfile for writing\n");
        if (fp) stream_destroy(fp);
        return NULL;
    }
    return fp;
}

int 
xquery_print_result_DRIVER (
    str                 mode,
    serializeFunStruct *driverFun,
    char               *driverArg,
    BAT                *ws,
    BUN                 niters,
    BAT                *loop,
    BAT                *iter,
    BAT                *item, 
    BAT                *kind,
    BAT                *intVAL,
    BAT                *dblVAL,
    BAT                *strVAL,
    /* xrpc response header things */
    str                xrpc_module,   
    str                xrpc_method,   
    str                xrpc_qid, 
    str                xrpc_caller, 
    str                xrpc_mode,
    str                xrpc_hostport,
    bit                *xrpc_updating,
    lng                *xrpc_seqnr,
    lng                *xrpc_timeout,
    lng                *xrpc_start)
{
    stream *fp = GDKout;
    int ret, trace = xrpc_method && *xrpc_method && xrpc_mode && strstr(xrpc_mode, "trace");
    (void) driverFun;
    (void) driverArg;

    lng time_exec;

    if (xrpc_start)
	 time_exec = (GDKusec() - *xrpc_start) / 1000;
    else
	 time_exec = 0;

    if (trace) {
        stream* logstream = xrpc_log_message("res",*xrpc_seqnr);
        fp = logstream?attach_teestream(fp, logstream):NULL;
        if (fp == NULL) return GDK_FAIL;
        if (strcmp(xrpc_caller, "query") == 0) {
            BATiter wsi = bat_iterator(ws);
            BAT *participants = BATdescriptor(*(bat*) BUNtail(wsi, XRPC_PARTICIPANTS));
            int ret = GDK_FAIL;
            if (participants) {
                ret = draw_queryflow(*xrpc_updating, *xrpc_seqnr, xrpc_method, time_exec, xrpc_hostport, participants);
                BBPunfix(participants->batCacheid);
            }
            if (ret == GDK_FAIL) {
                detach_teestream(fp);
                return ret;
            }
        }
    }
    ret = xquery_print_result_driver (
               fp,
               mode,
               driverFun, /* set of printing callback function */
               driverArg, /* optional arguments for the callback functions */
               ws,
               niters?niters:1, /* number of iterations */
               loop, /* loop relation */
               iter, /* iter relation */
               item, /* item relation */
               kind, /* kind relation */
               intVAL,
               dblVAL,
               strVAL,
               xrpc_module,   
               xrpc_method,   
               xrpc_qid, 
               xrpc_caller, 
               xrpc_mode, 
               xrpc_hostport,
               xrpc_updating, 
               xrpc_seqnr, 
               xrpc_timeout, 
               &time_exec);
  
     if (trace) detach_teestream(fp);
     return ret; 
}

#define FNDEEPEQTRACE 0

#define DACH(CTX) ((struct DuplAttrChk*)CTX->_private)

#define DACH_MAXATTR	32
#define DACH_MAXBUFF	8192

typedef struct DuplAttrChk {
	int	equal;
	int	building;
	char*	elname; /* tagname of the current element */
	int	alist_cur;
	int	alist_max;
	char**	alist;
	int	abuff_cur;
	int	abuff_max;
	char*	abuff;
} Dach;

static int
dach_alloc(struct DuplAttrChk* dach) {
    dach->alist_cur = 0;
    dach->alist_max = DACH_MAXATTR;
    dach->alist = GDKmalloc(dach->alist_max*sizeof(char*));
    dach->abuff_cur = 0;
    dach->abuff_max = DACH_MAXBUFF;
    dach->abuff = GDKmalloc(dach->abuff_max*sizeof(char));
    return 1;
}

static int
dach_free(struct DuplAttrChk* dach) {
    GDKfree(dach->alist);
    dach->alist = NULL;
    GDKfree(dach->abuff);
    dach->abuff = NULL;
    return 1;
}

static INLINE void
dach_start_build(struct DuplAttrChk* dach, char* elname) {
    dach->elname 	= elname;
    dach->alist_cur	= 0;
    dach->abuff_cur	= 0;
    dach->abuff[0]	= 0;
    dach->equal 	= 0;
    dach->building	= 1;
}

static INLINE void
dach_start_check(struct DuplAttrChk* dach) {
    dach->equal 	= 1; /* true until otherwise proven */
    dach->building	= 0;
}

static INLINE void
dach_finish_check(struct DuplAttrChk* dach) {
    if ( dach->equal ) { /* still equal */
	for(int i=0; i<dach->alist_cur; i++) {
	    if (dach->alist[i] ) {
    	        if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: no corresponding left attr: <%s ... %s\n",dach->elname, dach->alist[i]);
	        dach->equal = 0; /* not deep equal */
	    }
        }
    }
}

static INLINE int
dach_add2buff(struct DuplAttrChk* dach, char* s) {
    int l = strlen(s) + 1;
    if ( (dach->abuff_cur + l) > dach->abuff_max ) {
	dach->abuff_max *= 2;
    	if ( !(dach->abuff = GDKrealloc(dach->abuff, dach->abuff_max)))
	    return 0;
    }
    memcpy(&dach->abuff[dach->abuff_cur],s,l);
    dach->abuff_cur += l-1;
    return 1;
}

static bool
dach_handle_attribute (XqueryCtx* ctx, str prefix, str loc, str value)
{
    struct DuplAttrChk* dach = DACH(ctx);
    
    int start = dach->abuff_cur;

    if ( prefix && *prefix && loc && *loc ) {
        dach_add2buff(dach, prefix);
        dach_add2buff(dach, ":");
        dach_add2buff(dach, loc);
    } else if ( prefix && *prefix ) { /* default namespace */
        dach_add2buff(dach, prefix);
    } else {
        dach_add2buff(dach, loc);
    }
    dach_add2buff(dach, "=");
    dach_add2buff(dach, "\"");
    dach_add2buff(dach, value);
    dach_add2buff(dach, "\"");
    dach->abuff_cur++;
    /* */
    char* newattr = &dach->abuff[start];
    /* */
    if ( dach->building ) {
        if ( dach->alist_cur == dach->alist_max ) {
	    dach->alist_max *= 2;
	    if ( !(dach->alist = GDKrealloc(dach->alist, dach->abuff_max*sizeof(char*))))
	    	return 0;
	}
	dach->alist[dach->alist_cur++] = newattr;
    } else {
    	/* just checking */
	int i;
	for(i=0; i<dach->alist_cur; i++) {
	    if (dach->alist[i] && (strcmp(dach->alist[i],newattr)==0) ) {
		dach->alist[i] = 0; /* found corresponding attr */
	        break;
	    }
	}
	if ( (i==dach->alist_cur) && dach->equal) {
	    /* did not find attr, so not deep equal */
    	    if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: no corresponding right attr: <%s ... %s\n",dach->elname, newattr);
	    dach->equal = 0;
	}
	dach->abuff_cur = start; /* reclaim string space */
    }
    if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: dach_handle_attribute[%s](%s)\n",(dach->building?"build":"check"),newattr);
    return SUCCESS;
}

/*
 *
 *
 */

static int
fn_deep_eq_scan(XqueryCtx* ctx, oid* pre, oid to, BAT* pre_cont, oid cont, int* vCONT)
{
    ptr res;
    chr kind;
    *vCONT = cont;
    /* int poppedTags = 0; */

    if (*pre>to)
    	return 9999; /* end of scan */
    do {
        getWsValue(res,ctx,cont,PRE_KIND,*pre);
        kind = *(chr*) res;
        
        /* jump over holes introduced by updates */
        if (kind == chr_nil) {
            getWsValue(res,ctx,cont,PRE_SIZE,*pre);
            int size = (*(int*)res) & GDK_int_max;
            *pre = *pre + size + 1;
            continue;
        }
    
	/*
         * while( moreTags(ctx) && *pre > topSF(ctx)->limit ) {
         *   popTag(ctx);
	 *   poppedTags++;
         * }
	 */

        /* get container and value reference */
        if ( pre_cont ) {
            findTailValue(res,ctx,pre_cont,*pre);
            *vCONT = (int)*(oid*)res;
        }
	/*
         * getWsValue(res,ctx,cont,PRE_PROP,*pre);
         * prop = *(oid*) res;
	 */
        
        switch( kind ) {
            case (char)0: /* ELEMENT */
            case (char)1: /* PFTEXT */
            case (char)2: /* COMMENT */
            case (char)3: /* PI */
		    return (int)kind;
            case (char)4:
                {   /* DOCUMENT */
                    /* INCOMPLETE, what to do here ??? */
                    break;
                }
            case (char)5:
                {   /* COLLECTION */
                    /* nothing to be done, here */
                    break;
                }
            default:
                fatal_err (ctx,
                           "Unknow kind %d IN fn_deep_eq_scan",
                           (int)kind);
                return PROBLEM;
        }
        (*pre)++;
    } while (*pre <= to);
    /* 
     * while( moreTags(ctx) ) {
     *   popTag(ctx);
     *   poppedTags++;
     * }
     */
    return 9999;
}

static int
fn_deep_eq_range(
	XqueryCtx* ctx,
	oid lpre, oid lto, BAT* lpre_cont, oid lcont,
	oid rpre, oid rto, BAT* rpre_cont, oid rcont
	)
{
    do {
	ptr res;
        int lvCONT, rvCONT;

        int lkind = fn_deep_eq_scan(ctx,&lpre,lto,lpre_cont,lcont,&lvCONT);
        int rkind = fn_deep_eq_scan(ctx,&rpre,rto,rpre_cont,rcont,&rvCONT);

	if ( lkind != rkind ) {
    	    if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: not eq range_king(%d,%d).\n",lkind,rkind);
	    return 0;
	}
	if ( lkind == 9999 ) {
    	    if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: end of range for both sides.\n");
	    return 1; /* end of range, equal */
	} else {
            getWsValue(res,ctx,lcont,PRE_PROP,lpre);
            oid lprop = *(oid*) res;
            getWsValue(res,ctx,rcont,PRE_PROP,rpre);
            oid rprop = *(oid*) res;
	    if (lkind == 0 ) { /* ELEMENT */
                getWsValue (res, ctx, lvCONT, QN_URI, lprop);
                str luri    = (str) res;
                getWsValue (res, ctx, rvCONT, QN_URI, rprop);
                str ruri    = (str) res;
                getWsValue (res, ctx, lvCONT, QN_PREFIX, lprop);
                str lprefix = (str) res;
                getWsValue (res, ctx, rvCONT, QN_PREFIX, rprop);
                str rprefix = (str) res;
                getWsValue (res, ctx, lvCONT, QN_LOC, lprop);
                str lname   = (str) res;
                getWsValue (res, ctx, rvCONT, QN_LOC, rprop);
                str rname   = (str) res;
		/* */
    	        if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: comparing ELEMENTS(<%s>,<%s>).\n",lname,rname);
		if ( strcmp(lname,rname) != 0 ) {
    	            if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: comparing ELEMENTS(<%s>,<%s>) FAILS.\n",lname,rname);
	 	    return 0;
		}
		if ( ((luri && ruri) && strcmp(luri,ruri) != 0) || (luri && !ruri) || (!luri && ruri) )  {
    	            if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: comparing ELEMENTS(<%s>) URI(%s,%s) FAILS.\n",lname,luri,ruri);
		    return 0;
		}
		if ( ((lprefix && rprefix) && strcmp(lprefix,rprefix) != 0) || (lprefix && !rprefix) || (!lprefix && rprefix) )  {
    	            if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: comparing ELEMENTS(<%s>) PREFIX(%s,%s) FAILS.\n",lname,lprefix,rprefix);
		    return 0;
		}
		/* now handle the attributes of the node */
		dach_start_build(DACH(ctx),lname);
		process_node_attr(ctx,lcont,lpre);
		dach_start_check(DACH(ctx));
		process_node_attr(ctx,rcont,rpre);
		dach_finish_check(DACH(ctx));
		if ( !DACH(ctx)->equal ) {
		    return 0;
		}
	     } else if (lkind == 1 ) { /* STR */
                getWsValue(res,ctx,lvCONT,PROP_TEXT,lprop);
		str lstr = (str)res;
                getWsValue(res,ctx,rvCONT,PROP_TEXT,rprop);
		str rstr = (str)res;
    	        if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: comparing STR(\"%s\",\"%s\").\n",lstr,rstr);
		if ( strcmp(lstr,rstr) != 0 ) {
    	            if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: deep-equal STR(\"%s\",\"%s\") == FALSE.\n",lstr,rstr);
	 	    return 0;
	        }
	     } else if (lkind == 2 ) { /* COMMENT */
                getWsValue(res,ctx,lvCONT,PROP_COM,lprop);
		str lcom = (str)res;
                getWsValue(res,ctx,rvCONT,PROP_COM,rprop);
		str rcom = (str)res;
		if ( strcmp(lcom,rcom) != 0 ) {
    	            if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: deep-equal COMMENT(\"%s\",\"%s\") == FALSE.\n",lcom,rcom);
	 	    return 0;
		}
	     } else if (lkind == 3 ) { /* PI */
                    getWsValue(res,ctx,lvCONT,PROP_TGT,lprop);
                    str ltarget = (str) res;
                    getWsValue(res,ctx,lvCONT,PROP_INS,lprop);
                    str ldata = (str) res;
                    getWsValue(res,ctx,rvCONT,PROP_TGT,rprop);
                    str rtarget = (str) res;
                    getWsValue(res,ctx,rvCONT,PROP_INS,rprop);
                    str rdata = (str) res;
		if ( strcmp(ltarget,rtarget) != 0 || strcmp(ldata,rdata) != 0) {
    	            if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: deep-equal PI(%s,%s),PI(%s,%s) == FALSE.\n",ltarget,ldata,rtarget,rdata);
	 	    return 0;
		}
	     } else {
		stream_printf(GDKout,"#eqdebug: unknown kind: %d\n",lkind);
	        return 0;
	     }
	}
	lpre++;
	rpre++;
    } while ( 1 );
}

static int 
fn_deep_eq_node(XqueryCtx* ctx, int lcont, oid loid, int rcont, oid roid) {
    ptr res;

    if ( (loid == roid) && (lcont == rcont) ) /* nodes are identical */
        return 1;
    getWsValue (res, ctx, lcont, PRE_KIND, loid);
    int l_kind = *(chr*) res;
    getWsValue (res, ctx, rcont, PRE_KIND, roid);
    int r_kind = *(chr*) res;
    /* */
    if ( l_kind == r_kind ) {
        if (l_kind == (char)1 /* TEXT */) {
            oid lprop, lval_cont;
            /* get value container */
            getWsValue(res, ctx, lcont, PRE_CONT, loid);
            lval_cont = *(oid*) res;
            /* get value reference */
            getWsValue(res, ctx, lcont, PRE_PROP, loid);
            lprop = *(oid*) res;
            getWsValue (res, ctx, lval_cont, PROP_TEXT, lprop);
	    str lstr = (str)res;
	    /* */
            oid rprop, rval_cont;
            /* get value container */
            getWsValue(res, ctx, rcont, PRE_CONT, roid);
            rval_cont = *(oid*) res;
            /* get value reference */
            getWsValue(res, ctx, rcont, PRE_PROP, roid);
            rprop = *(oid*) res;
            getWsValue (res, ctx, rval_cont, PROP_TEXT, rprop);
	    str rstr = (str)res;
	    /* */
	    if ( strcmp(lstr,rstr) != 0 ) {
    	        if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: not eq STR(%s,%s).\n",lstr,rstr);
		return 0;
	    }
	} else {
            oid lpre = loid, lpre_size;
            getWsValue(res, ctx, lcont, PRE_SIZE, lpre);
            lpre_size = lpre + *(int*) res;
            BAT *lb;
	    BATiter lbi;
            getWsBAT(lb, lbi, ctx, lcont, PRE_CONT);

            oid rpre = roid, rpre_size;
            getWsValue(res, ctx, rcont, PRE_SIZE, rpre);
            rpre_size = rpre + *(int*) res;
            BAT *rb;
	    BATiter rbi;
            getWsBAT(rb, rbi, ctx, rcont, PRE_CONT);

            return fn_deep_eq_range(
	    		ctx, 
                        lpre, lpre_size, IS_FAKE_PROJECT(lb)?NULL:lb, lcont,
                        rpre, rpre_size, IS_FAKE_PROJECT(rb)?NULL:rb, rcont
		   );
	}
    } else {
    	if (FNDEEPEQTRACE) stream_printf(GDKout,"#eqdebug: kind not equal.\n");
	return 0;
    }
    return 1;
}

int
do_fn_deep_eq(BAT** resbat, BAT* ws, BAT* litem, BAT* lkind, BAT* ritem, BAT* rkind)
{
    /* TODO
     * - ignore namespaces and URI's, surprising?
     * - check length of both args
     * - do eq() for basevalues in parameter sequences
     * - comments and pi's in nodes ??
     */
    struct serializeFunStruct mySerializeFun;
    memcpy(&mySerializeFun,&nullSerializeFun,sizeof(struct serializeFunStruct));
    mySerializeFun.handle_attribute = dach_handle_attribute;

    XqueryCtx  ctx_struct, *ctx = &ctx_struct;
    if (!createWsContext(ctx,ws,"xml",&mySerializeFun,"",GDKout))
        return GDK_FAIL;
    struct DuplAttrChk dach; /* hander of attribute equality check */
    ctx->_private = &dach;
    if (!dach_alloc(&dach))
    	return GDK_FAIL;

    *resbat = BATnew(TYPE_void,TYPE_bit,BATcount(litem));

    static BUN (*l_fun_k) (BAT *, oid);
    static BUN (*r_fun_k) (BAT *, oid);
    if (IS_FAKE_PROJECT(lkind))
        l_fun_k = fake_lookup_bun;
    else
        l_fun_k = lookup_bun;
    if (IS_FAKE_PROJECT(rkind))
        r_fun_k = fake_lookup_bun;
    else
        r_fun_k = lookup_bun;

    BATseqbase(*resbat,0);

    BUN lp, lq;
    BATiter litemi = bat_iterator(litem);
    BATloop(litem, lp, lq) {
        ptr res;
        oid index = *(oid*)BUNhead(litemi, lp);

        oid loid  = *(oid*)BUNtail(litemi, lp);

        findTailValue(res, ctx, ritem, index);
	oid roid = *(oid*)res;

        int cck;

        findTailValue2 (l_fun_k, res, lkind, index);
        cck = *(int*)res;
        if ( XTRACT_KIND(cck) != ELEM) {
	    GDKerror("unexpected left non ELEM");
	    return GDK_FAIL;
	}
        int lcont = XTRACT_CONT(cck);

        findTailValue2 (r_fun_k, res, rkind, index);
        cck = *(int*)res;
        if ( XTRACT_KIND(cck) != ELEM) {
	    GDKerror("unexpected right non ELEM");
	    return GDK_FAIL;
	}
        int rcont = XTRACT_CONT(cck);

        bit eq;

	if ( fn_deep_eq_node(ctx,lcont,loid,rcont,roid) ) {
	    eq = TRUE;
	} else {
	    eq = FALSE;
	}
	BUNappend(*resbat,&eq,FALSE);
    }
    if (!dach_free(&dach))
    	return GDK_FAIL;
    if ( !disposeWsContext(ctx) )
        return GDK_FAIL;
    BBPfix((*resbat)->batCacheid);
    if ( 0 ) {
        BATprintf(GDKout,litem);
        BATprintf(GDKout,*resbat);
    }
    return  GDK_SUCCEED;
}
