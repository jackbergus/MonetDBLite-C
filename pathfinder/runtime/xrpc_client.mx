@ Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2007 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$
@'

@f xrpc_client
@a Ying Zhang

@t MIL primitives of XRPC client

@* Introduction
This module provides new MIL primitives for the client side support of
remote XQuery execution using HTTP connection on top of MonetDB for
the "AmbientDB" project.
@
@* Module Definition
@m
.MODULE xrpc_client;

@- HTTP client function(s)
@m
.COMMAND http_post(
        str options,
        str dst,
        str moduleNS,
        str location,
        str method,
        int updCall,
        int arity,
        lng itercnt,
        BAT[void, bat] ws,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[str, bat] = CMDhttp_post;
"Create and send a RPC request message to the specified destination"

.END xrpc_client;

@mil
PROC rpc_client(
        str local_name,
        str options,
        str dst,
        str moduleNS,
        str location,
        str method,
        int updCall,
        int arity,
        lng iterc,
        BAT[void, BAT] ws,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : oid {

    var rpcres := http_post(options, dst, moduleNS, location, method,
                    updCall, arity, iterc, ws, fun_vid, fun_iter, fun_item,
                    fun_kind, int_values, dbl_values, dec_values, str_values);

    var time_xrpcClntDeSeria := usec();

    var ret := oid_nil;
    if (updCall != 1)
        ret := ws_opencoll(ws, rpcres, local_name, TEMP_DOC);

    time_xrpcClntDeSeria := usec() - time_xrpcClntDeSeria;
    if (options.search("timing") >= 0) {
        printf("XRPC_Client_DeSerialisation (ws_opencoll):    %lld microsec\n",
                time_xrpcClntDeSeria);
    }

    return ret;
}
ADDHELP("rpc_client", "zhang", "November 2005",
"DESCRIPTION:\n\
Send a RPC request to the destination \"dst\", save the results in the \
WorkingSet and return the fragment-id of the new added document",
"xrpc_client");

PROC get_rpc_res ( 
        oid cont, 
        str local_name, 
        BAT[void, bat] ws, 
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values, 
        BAT[void, str] str_values) : BAT[void, bat]
{
    var res_iter := bat(void,oid).seqbase(0@0);
    var res_item := bat(void,oid).seqbase(0@0);
    var res_kind := bat(void,int).seqbase(0@0);
    
    var pre_size  := ws.fetch(PRE_SIZE).fetch(cont);
    var pre_level := ws.fetch(PRE_LEVEL).fetch(cont).access(BAT_WRITE);
    var pre_prop  := ws.fetch(PRE_PROP).fetch(cont).access(BAT_WRITE);
    var pre_kind  := ws.fetch(PRE_KIND).fetch(cont).access(BAT_WRITE);

    var qn_prefix := ws.fetch(QN_PREFIX).fetch(cont);
    var qn_uri    := ws.fetch(QN_URI).fetch(cont);
    var qn_loc    := ws.fetch(QN_LOC).fetch(cont);
    var prop_text := ws.fetch(PROP_TEXT).fetch(cont);

    var attr_own  := ws.fetch(ATTR_OWN).fetch(cont);
    var attr_qn   := ws.fetch(ATTR_QN).fetch(cont);
    var attr_prop := ws.fetch(ATTR_PROP).fetch(cont);
    var prop_val  := ws.fetch(PROP_VAL).fetch(cont);

    # Get "pre_prop" value of an "sequence" node.
    var seq_prop;
    var err := CATCH ({ seq_prop := qn_loc.ord_select("sequence").reverse().fetch(0); });
    if (not(isnil(err))) {
        if(count(qn_loc.ord_select("Fault")) = 0) {
            ERROR("get_rpc_res expects at least *one* \"<sequence>\" tag.\n");
        } else {
            var fault_value_pre := qn_loc.ord_select("Value").reverse().fetch(0);
                fault_value_pre := pre_prop.ord_select(fault_value_pre).reverse().fetch(0);
                fault_value_pre := pre_prop.fetch(int(fault_value_pre)+1);
            var fault_value     := prop_text.fetch(fault_value_pre);

            var fault_text_pre := qn_loc.ord_select("Text").reverse().fetch(0);
                fault_text_pre := pre_prop.ord_select(fault_text_pre).reverse().fetch(0);
                fault_text_pre := pre_prop.fetch(int(fault_text_pre)+1);
            var fault_text     := prop_text.fetch(fault_text_pre);
            ERROR("Remote execution failed.\n" +
                  "SOAP Fault Code: %s\n" +
                  "SOAP Fault Reason:\n%s\n",
                  fault_value, fault_text);
        }
    }

    # Fetch the position of the first "pre_prop" value of the "sequence"
    # node.  Must use "ord_select" and "fetch", since the the "pre_prop"
    # value can appear more than once in the "pre_prop" bat.
    seq_prop := pre_prop.ord_select(seq_prop).reverse().fetch(0);

    var tpe_node_level :=  pre_level.find(seq_prop).int() + 1;
    var itercnt := 0;
    var tpe := "";
    var subtpe := "";
    var xrpc_ns := "http://monetdb.cwi.nl/XQuery";
    var xsi_ns := "http://www.w3.org/2001/XMLSchema-instance";
 
    # To reduce #iter: everything before the first "sequence" is
    # not used, so do not iterate over them.
    var i := int(seq_prop);
    var size := pre_size.fetch(0);
    while(i <= size){
        var inc := 1;
        if (not(isnil(pre_size.fetch(i)))) { # Skip holes in the BATs
            var pre   := oid(i);
            var level := pre_level.fetch(pre).int();
            var kind  := pre_kind.fetch(pre);
            var prop  := pre_prop.fetch(pre);

            if (level = (tpe_node_level - 1)) {
                var loc := qn_loc.fetch(prop);
                var uri := qn_uri.fetch(prop);
                if (and((loc = "sequence"), (uri = xrpc_ns))) {
                    itercnt :+= 1; # A new iteration starts
                }
            } else if (level = tpe_node_level) {
                var tpe_node_ns := qn_uri.fetch(prop);
                if (tpe_node_ns != xrpc_ns) {
                    ERROR("get_rpc_res (pre %d): invalid " +
                          "namespace of a type node.  Expected " +
                          "\"%s\", got \"%s\".\n",
                          pre, xrpc_ns, tpe_node_ns);
                }
                tpe := qn_loc.fetch(prop);
                if (tpe = "atomic-value") {
                    var tpe_qn_qn := qn_loc.ord_select("type").mirror();
                    var tpe_qn_ns := qn_uri.ord_select(xsi_ns);
                    tpe_qn_qn := tpe_qn_qn.join(tpe_qn_ns).mirror();

                    var tpe_attr_qn := attr_qn.join(tpe_qn_qn);
                    var tpe_attr_attr := attr_own.ord_select(pre).mirror();
                    tpe_attr_attr := tpe_attr_attr.join(tpe_attr_qn).mirror();
                    if (count(tpe_attr_attr) != 1) {
                        ERROR("get_rpc_res (batloop %d): " +
                              "\"atomic-value\" should only have one " +
                              "\"xsi:type\" attributed!\n", pre);
                    }
                    var tpe_attr_prop := tpe_attr_attr.join(attr_prop);
                    subtpe := tpe_attr_prop.join(prop_val).fetch(0);
                    subtpe := subtpe.substring(subtpe.search(":") + 2); # remove the prefix
                } else if (tpe = "document") {
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                    # Replace the values of this type node with values
                    # for a document node
                    pre_level := replace(pre_level, pre, ('\000' - '\001'));
                    pre_prop  := replace(pre_prop,  pre, oid_nil);
                    pre_kind  := replace(pre_kind,  pre, '\004');
                    inc := pre_size.fetch(i);
                } else if (tpe = "attribute") {
                    var attr := attr_own.select(pre);
                    var aprop := attr.mirror().join(attr_prop);

                    res_iter.append(oid(itercnt));
                    res_item.append(aprop);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ATTR);
                    res_kind.append(k);
                }
            } else if (level = (tpe_node_level + 1)) {
                # 'tpe' was set during the previous iteration of 'batloop'
                if (tpe = "element"){
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                    inc := pre_size.fetch(i);
                } else if (tpe = "text") { # text value of a text node
                    if (kind != '\001'){
                        ERROR("get_rpc_res (batloop %d): a text node " +
                              "should have a single text value\n", pre);
                    }
                    # FIXME: does this work?
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                } else if (tpe = "atomic-value") { # string value of an atomic-value
                    var val := prop_text.fetch(prop); # value in str
                    if (subtpe = "boolean"){ 
                        var o := oid(toUpper(val) = "TRUE");
                        res_iter.append(oid(itercnt));
                        res_item.append(o);
                        res_kind.append(BOOL);
                    } else if (subtpe = "integer"){
                        var i := lng(val);
                        int_values.append(i);
                        res_iter.append(oid(itercnt));
                        res_item.append(int_values.reverse().find(i));
                        res_kind.append(INT);
                    } else if(subtpe = "decimal") {
                        var d := dbl(val);
                        dbl_values.append(d);
                        res_iter.append(oid(itercnt));
                        res_item.append(dbl_values.reverse().find(d));
                        res_kind.append(DEC);
                    } else if(or( (subtpe = "float"), (subtpe = "double") )) {
                        var d := dbl(val);
                        dbl_values.append(d);
                        res_iter.append(oid(itercnt));
                        res_item.append(dbl_values.reverse().find(d));
                        res_kind.append(DBL);
                    } else if(or(subtpe = "string", subtpe = "untypedAtomic")) {
                        str_values.append(val);
                        res_iter.append(oid(itercnt));
                        res_item.append(str_values.reverse().find(val));
                        res_kind.append(STR);
                    } else {
                        printf("get_rpc_res (batloop %d): atomic " +
                               "value with unsupported type \"%s\" " +
                               "ignored.\n", subtpe);
                    }
                } else if (tpe = "comment") { # text value of a comment node                
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                } else if (tpe = "processing-instruction") { # text value of a PI node
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                } 
                tpe := ""; # clean up type info
            } # END 'if (level = ...)'
        } # END 'if (not(isnil(pre_size.fetch(i))))'
        i := i + inc;
    } # END 'while(i < size)'

    pre_level := ws.fetch(PRE_LEVEL).fetch(cont);
    pre_prop  := ws.fetch(PRE_PROP).fetch(cont);
    pre_kind  := ws.fetch(PRE_KIND).fetch(cont);

    return bat(void,bat,4).append(res_iter).append(res_item).append(res_kind).access(BAT_READ);
}
ADDHELP("get_rpc_res", "zhang", "April 2006",
"DESCRIPTION:\n\
This proc is used to retrieve the return values of RPC call(s), which \
are temporarily stored in the WS. It\n\
1. retrieves the right values\n\
2. builds temporary iter|item|kind BATs\n\
3. fill in the value containers",
"xrpc_client");

PROC doLoopLiftedRPC(
        str options,
        str moduleNS,
        str location,
        str method,
        int updCall,
        int arity,
        lng iterc_total,
        BAT[void, BAT] ws,
        BAT[oid,  str] dsts,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[void,bat]
{
    var mylock := lock_create();

    var unq_dsts := dsts.tunique().hmark(0@0);
    var steps := unq_dsts.count();
    # we assume each dst has the same #iterations
    var iterc := iterc_total / steps;
    var rpc_results := bat(str,oid);
    var rpc_iter := bat(void,bat).seqbase(0@0);
    var off := count(ws.fetch(CONT_NAME));

    unq_dsts @ [steps] batloop(){
        var time_xrpcClntSeria := usec();

        # get iteration numbers for this destination
        var iter_dst := [oid](rpc_dsts.ord_uselect($t).reverse());
            iter_dst := iter_dst.reverse().mirror();

        # retrieve the frag of fun_vid, fun_iter, fun_item and fun_kind
        # for this iteration.

        # order of 'fun_iter' needs to be preserved, so use 'leftjoin',
        # iso. 'join'.
        var fun_iter_dst := fun_iter.leftjoin(iter_dst);
        var indices      := fun_iter_dst.mirror().hmark(0@0);
        var fun_vid_dst  := indices.fetchjoin(fun_vid).tmark(0@0);
        var fun_item_dst := indices.fetchjoin(fun_item).tmark(0@0);
        var fun_kind_dst := indices.fetchjoin(fun_kind).tmark(0@0);

        # renumber the iters, starting from 1
        fun_iter_dst := fun_iter_dst.leftjoin(iter_dst.mark(1@0));
        fun_iter_dst := [oid](fun_iter_dst.tmark(0@0));

        time_xrpcClntSeria := usec() - time_xrpcClntSeria;
        if (options.search("timing") >= 0) {
            printf("XRPC_Client_Serialisation (get_dst_params):   %lld microsec\n",
                    time_xrpcClntSeria);
        }

        var local_name := "rpc_res_00" + str(int($h)+off);
        var rpc_oid := oid(nil);
        var rpc_err := CATCH(
        {
            rpc_oid := rpc_client(local_name, options, $t, moduleNS,
                         location, method, updCall, arity, iterc, ws,
                         fun_vid_dst, fun_iter_dst, fun_item_dst,
                         fun_kind_dst, int_values, dbl_values,
                         dec_values, str_values);
        });

        var time_xrpcClntDeSeria := usec();

        if (isnil(rpc_err)) {
            if (updCall != 1) {
                lock_set(mylock);
                rpc_results.insert(local_name,rpc_oid);
                rpc_iter.append(iter_dst.hmark(1@0));
                lock_unset(mylock);
            }
            time_xrpcClntDeSeria := usec() - time_xrpcClntDeSeria;
            if (options.search("timing") >= 0) {
                printf("XRPC_Client_DeSerialisation (insert_rpc_oid): %lld microsec\n",
                        time_xrpcClntDeSeria);
            }
        } else {
            # We do not want to discard results from other destinations
            # where executions might have succeeded, so we only print a
            # message by error, iso. terminate the execution with 'ERROR'
            printf("!ERROR: during RPC call to \"%s\"\n%s\n",
                    $t, rpc_err);
        }
    }
    lock_destroy(mylock);

    var time_xrpcClntDeSeria := usec();

    var res_iter := bat(void,oid).seqbase(0@0);
    var res_item := bat(void,oid).seqbase(0@0);
    var res_kind := bat(void,int).seqbase(0@0);
    var res_bats := bat(void,bat,4).seqbase(0@0);

    if ( updCall = 1 ){
        # If called function is an updating function, there is no
        # results to retrieve.  So, return empty BATs.
        res_bats.append(res_iter).append(res_item).append(res_kind);
        return res_bats.access(BAT_READ);
    }

    if( count(rpc_results) = 0 ) {
        ERROR("doLoopLiftedRPC: execution failed at all destinations");
    }

    # retrieve results for this destination, and map the results back to
    # the original iteration number
    var proc_res := [get_rpc_res](rpc_results.tmark(0@0),
            rpc_results.hmark(0@0), const ws, const int_values,
            const dbl_values, const str_values);

    res_iter := proc_res.[fetch](0).[leftfetchjoin](rpc_iter);
    res_item := proc_res.[fetch](1);
    res_kind := proc_res.[fetch](2);

    # initialize res_bat with the results for the first destination
    res_bats.append(res_iter.fetch(0));
    res_bats.append(res_item.fetch(0));
    res_bats.append(res_kind.fetch(0));

    # if there were more destinations, merge the result tables 
    var i := 0;
    while ((i :+= 1) < steps) {
        # initialize res_bat with the results for the first destination 
        res_bats := merged_union(res_bats.fetch(0), res_iter.fetch(i), 
                                 res_bats.fetch(1), res_item.fetch(i), 
                                 res_bats.fetch(2), res_kind.fetch(i));
    }

    time_xrpcClntDeSeria := usec() - time_xrpcClntDeSeria;
    if (options.search("timing") >= 0) {
        printf("XRPC_Client_DeSerialisation (get_rpc_res):    %lld microsec\n",
                time_xrpcClntDeSeria);
    }

    return res_bats;
}
ADDHELP("doLoopLiftedRPC", "zhang", "April 2006",
"DESCRIPTION: implementation of the loop-lifted RPC",
"xrpc_client");

@h
#ifndef XRPC_CLIENT_H
#define XRPC_CLIENT_H

#include "xrpc_server.h"

#define MAX_BUF_SIZE            (1024*1024)
#define NR_RETRIES              3

#endif /* XRPC_CLIENT_H */

@c
#include "pf_config.h"
#include "xrpc_client.h"
#include <stream_socket.h>

#define errCheck(iterc, argc, ws,                                      \
            fvid, fiter, fitem, fkind,                                 \
            int_val, dbl_val, dec_val, str_val) {                      \
    ERRORcheck(iterc < 0,                                              \
               "CMDhttp_post: iterc must not be negative (<0).\n");    \
    ERRORcheck(argc < 0,                                               \
               "CMDhttp_post: argc must not be negative (<0).\n");     \
    ERRORcheck(!BAThdense(ws),                                         \
               "CMDhttp_post: head of 'ws' must be dense.\n");         \
    ERRORcheck(!BAThdense(fun_vid),                                    \
               "CMDhttp_post: head of 'fun_vid' must be dense.\n");    \
    ERRORcheck(!BAThdense(fun_iter),                                   \
               "CMDhttp_post: head of 'fun_iter' must be dense.\n");   \
    ERRORcheck(!BAThdense(fun_item),                                   \
               "CMDhttp_post: head of 'fun_item' must be dense.\n");   \
    ERRORcheck(!BAThdense(fun_kind),                                   \
               "CMDhttp_post: head of 'fun_kind' must be dense.\n");   \
    ERRORcheck(!BAThdense(int_values),                                 \
               "CMDhttp_post: head of 'int_values' must be dense.\n"); \
    ERRORcheck(!BAThdense(dbl_values),                                 \
               "CMDhttp_post: head of 'dbl_values' must be dense.\n"); \
    ERRORcheck(!BAThdense(dec_values),                                 \
               "CMDhttp_post: head of 'dec_values' must be dense.\n"); \
    ERRORcheck(!BAThdense(str_values),                                 \
               "CMDhttp_post: head of 'str_values' must be dense.\n"); \
}

#define str2buf(b, str) {                               \
    unsigned int len = strlen(str) + 1;                 \
    if (len > (b->len - b->pos)) {                      \
        GDKerror("CMDhttp_post: buffer overflow\n");    \
        return GDK_FAIL;                                \
    }                                                   \
    len = snprintf((b->buf + b->pos), len, str);        \
    b->pos += len;                                      \
}

#define clean_up(sock, s1, s2, b, argcnt, iterc) {      \
    lng i = 0;                                          \
    if (sock > 0) close(sock);                          \
    if(s1){                                             \
        stream_close(s1); stream_destroy(s1);           \
    }                                                   \
    if(s2){                                             \
        stream_close(s2); stream_destroy(s2);           \
    }                                                   \
    if (b) {                                            \
        if (b->len > 0) buffer_destroy(b);              \
        else            free(b);                        \
    }                                                   \
    if(argcnt) {                                        \
        for(i = 0; i < iterc; i++) GDKfree(argcnt[i]);  \
        GDKfree(argcnt);                                \
    }                                                   \
}

/* Serialize value specified by 'offset' and 'fun_item' surrounded by
 * 'begin_tag' and 'end_tag' into buffer 'b'.
 * 
 * Returns: GDK_SUCCEED if succeeded, GDK_FAIL otherwise.
 */
static int
value2buf(buffer *b, BAT *fun_item, oid offset, int valueType, BAT *valueContainer, char *begin_tag, char *end_tag)
{
    int len;
    char *strptr;
    oid i;
    
    str2buf(b, begin_tag);
    len = (b->len - b->pos) < GDK_int_max ? (b->len - b->pos) : GDK_int_max;
    strptr = b->buf + b->pos;
    i = *(oid*)BUNtail(fun_item, BUNptr(fun_item, offset));
    b->pos += BATatoms[valueType].atomToStr(&strptr, &len,
                BUNtail(valueContainer, BUNptr(valueContainer, i)));
    str2buf(b, end_tag);
    return GDK_SUCCEED;
}

/* Create a HTTP client socket.
 *
 * Returns: a socket number if succeeded, -1 otherwise.
 */
static int
setup_connection(str dst)
{
    struct in_addr      addr;
    struct sockaddr_in  sockaddr;
    struct hostent     *resolv = NULL;
    int i, ret, sock, port = 0;
    str strptr = NULL;
    
    errno = 0;

    /* 'dst' has the form 'URL[:port]' */
    if ((strptr = strchr(dst, (int)':')) != NULL) {
        strptr[0] = '\0'; strptr++;
        port = strtol(strptr, (char **)NULL, 10);
        if (errno) {
            GDKerror("setup_connection: invalid port number: %s\n",
                    strerror(errno));
            return -1;
        }
    } else { /* find the default port number from "monet_environment" */
        if( !(strptr = GDKgetenv("xrpc_port")) || !(*strptr) ){
            if( !(strptr = GDKgetenv("mapi_port")) ){
                GDKerror("setup_connection: could not find \"mapi_port\"\n");
                return -1;
            }
            port = atoi(strptr) + 1; 
        } else {
            port = atoi(strptr);
        }
    }

    if (isdigit((int)dst[0])) {
        if ((i = inet_addr(dst)) < 0) {
            GDKerror("setup_connection: invalid IP address \"%s\": %s\n",
                    dst, errno?strerror(errno):".");
            return -1;
        }
        addr.s_addr = (unsigned) i;
    } else {
        if (!(resolv = gethostbyname(dst))) {
            GDKerror("setup_connection: invalid IP address \"%s\": %s\n",
                    dst, errno?strerror(errno):".");
            return -1;
        }
        addr.s_addr = ((struct in_addr *)resolv->h_addr_list[0])->s_addr;
    }

    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port   = htons(port);
    sockaddr.sin_addr.s_addr = addr.s_addr;
    memset(&(sockaddr.sin_zero), '\0', 8);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        GDKerror("setup_connection: failed to create socket\n");
        return -1;
    }

    ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    for (i = NR_RETRIES; i > 0 && ret < 0; i--) {
        if (ret < 0){
            GDKwarning("setup_connection: could not set up connection with %s:%d : %s\n",
                    dst, port, errno?strerror(errno):".");
            GDKwarning("setup_connection: %d tries left\n", i);
            errno = 0;
        }
        sleep(1);
        ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    }

    if (ret < 0) {
        GDKerror("setup_connection: failed to setup connection with %s:%d : %s\n",
                dst, port, errno?strerror(errno):".");
        close(sock);
        return -1;
    }
    return sock;
}

/**
 * @return WS BAT, or
 *         NULL by error
 */
static BAT *
getWsBAT(BAT *ws, int contID, int batID)
{
    BAT *b = NULL, *batbat = NULL;
    BUN bun = NULL, bbun = NULL;
    oid CONTid = (oid)contID;
    oid BATid  = (oid)batID;

    if (contID < 0){
        GDKerror("getWsBAT: contID mush NOT be negative\n");
        return NULL;
    }

    if ( !(bun = BUNfnd(ws,&BATid)) ) {
        GDKerror("getWsBAT: NOT FOUND BAT[%d]",batID);
        return NULL;
    }
    if ( !( batbat = BATdescriptor(*(bat*)bun)) ) {
        GDKerror("getWsBAT:FETCH BATBAT for WS[%d][%d] FAILED\n",
                 batID, contID);
        return NULL;
    }
    bbun = BUNfnd(batbat,&CONTid);
    if ( !bbun ) {
        BBPunfix( BBPcacheid( batbat ) );
        GDKerror("getWsBAT:NOT FOUND BAT[%d][%d] in WS!!!!\n",
                 batID, contID);
        return NULL;
    } else {
        if ( !(b = BATdescriptor(*(bat*)bbun)) ) {
            BBPunfix( BBPcacheid( batbat ) );
            GDKerror("getWsBAT:FETCH WS[%d][%d] FAILED\n",
                     batID, contID);
            return NULL;
        }
    }
    BBPunfix( BBPcacheid( batbat ) );
    return b;
}

/**
 * Find the 'pre_kind' value of 'item_index'-th BUN of the PRE_KIND BAT
 * of the container 'contID' from the working set.
 *
 * @param ws The whole working set.
 * @param contID container ID.
 * @param item_index BUN index in the PRE_KIND BAT.
 * @return the 'pre_kind' value, or
 *         GDK_chr_min by error
 */
static chr
getELEMkind(BAT *ws, int contID, oid item_index)
{
    BAT *b  = NULL;
    BUN bun = NULL;
    chr ret;

    if(!(b = getWsBAT(ws, contID, PRE_KIND)))
        return GDK_chr_min;

    if (!b->batCount){
        GDKerror("getELEMkind: %s BAT is empty.\n",
                b?BBP_logical(b->batCacheid):"NULL");
        return GDK_chr_min;
    }
    BUNfndVOID(bun, b, &item_index);
    if (!bun){
        GDKerror("%s BAT does not contain value " OIDFMT
                 " in its head column.\n",
                 b?BBP_logical(b->batCacheid):"NULL", item_index);
        return GDK_chr_min;
    }

    ret = *(chr*)BUNtail(b,bun);
    BBPunfix( BBPcacheid(b));
    return ret;
}

static void
handle_soap_fault_msg(char *errmsg)
{
    char *strptr, *strptr2;

    strptr = strstr(errmsg, "<env:Value");
    if(!strptr) {
        GDKerror("handle_soap_fault_msg: SOAP Fault message not "
                 "well-formed: could not find \"<env:Value\".\n%s\n",
                 errmsg);
    }
    strptr = strchr(strptr, '>'); assert(strptr);
    strptr2 = strstr(++strptr, "</env:Value>");
    if( (!strptr) || (!strptr2) ) {
        GDKerror("handle_soap_fault_msg: SOAP Fault message not "
                 "well-formed at \"<env:Value>.\n%s\n", errmsg);
        return;
    }
    strptr2[0] = '\0';
    GDKerror("SOAP Fault Code  : %s\n", strptr);
    strptr2[0] = '<';

    strptr = strstr(strptr2+12, "<env:Text");
    if(!strptr) {
        GDKerror("handle_soap_fault_msg: SOAP Fault message not "
                 "well-formed: could not find \"<env:Text\".\n%s\n",
                 errmsg);
        return;
    }
    strptr = strchr(strptr, '>') + 1;
    strptr2 = strstr(strptr, "</env:Text>");
    if( (!strptr) || (!strptr2) ) {
        GDKerror("handle_soap_fault_msg: SOAP Fault message not "
                 "well-formed at \"<env:Text>\".\n%s\n", errmsg);
        return;
    }
    strptr2[0] = '\0';
    GDKerror("SOAP Fault Reason:\n%s\n", strptr);
}

/**
 * try to receive the response message and shred it into shredBAT
 * Returns shredBAT, or
 *         NULL on error
 */
static BAT *
response2bat(int sock,
             char *dst,
             buffer *b,
             int updCall,
             lng *time_xrpcClntDeSeria)
{
    char *strptr = NULL;
    int ret;
    stream *in;
    BAT *shredBAT;

    if( !(in = socket_rastream(sock, "http_receive")) ){
        GDKerror("response2bat: failed to create socket_rastream\n");
        return NULL;
    }

    b->pos = 0;
    errno = 0;
    if( !(ret = stream_readline(in, b->buf, 1024)) ){
        GDKerror("response2bat: failed to receive response from %s", dst);
        if(errno) GDKerror(": %s", strerror(errno));
        GDKerror(".\n");
        stream_close(in); stream_destroy(in);
        return NULL;
    }

    if( !(strptr = strchr(b->buf, ' ')) ){
        GDKerror("response2bat: invalid response from %s:\n%s\n",
                dst, b->buf);
        stream_close(in); stream_destroy(in);
        return NULL;
    }

    if (strncmp(++strptr, "200", 3) != 0) {
        b->buf[ret] = '\0';
        GDKerror("HTTP Error Code  : %s\n", b->buf + 9);

        b->pos = 0;
        do{ /* read the SOAP Fault message */
            errno = 0;
            ret = stream_read(in, (b->buf + b->pos), 1, (b->len - b->pos));
            if (ret > 0) b->pos += ret;
        } while (ret > 0);
        if (ret < 0) {
            GDKerror("response2bat: failed to receive response from %s",
                    dst);
            if(errno) GDKerror(": %s", strerror(errno));
            GDKerror(".\n");
            return NULL;
        }
        b->buf[b->pos] = 0;
        handle_soap_fault_msg(b->buf);
        stream_close(in); stream_destroy(in);
        return NULL;
    }

    do{ /* read the HTTP header and throw it away */
        errno = 0;
        ret = stream_readline(in, b->buf, 1024);
        b->buf[ret] = '\0';
        if(ret == 1 && b->buf[0] == '\r')
            ret = 0; /* end-of-HTTP-header found */
    } while (ret > 0);
    if (ret < 0) {
        GDKerror("response2bat: failed to receive response from %s",
                dst);
        if(errno) GDKerror(": %s", strerror(errno));
        GDKerror(".\n");
        stream_close(in); stream_destroy(in);
        return NULL;
    }

    /* Start timing Client DeSerialisation */
    *time_xrpcClntDeSeria = GDKusec();
    if (!(shredBAT = BATnew(TYPE_str, TYPE_bat, 32))){
        GDKerror("response2bat: failed to malloc shredBAT\n");
        stream_close(in); stream_destroy(in);
        return NULL;
    }

    if (updCall) {
        b->pos = 0;
        do{ /* Check for error message */
            errno = 0;
            ret = stream_read(in, (b->buf + b->pos), 1, (b->len - b->pos));
            if (ret > 0) b->pos += ret;
        } while (ret > 0);
        b->buf[b->pos] = 0;
        stream_close(in); stream_destroy(in);

        if(b->pos == 0){ /* no error message => operation succeeded */
            *time_xrpcClntDeSeria = GDKusec() - *time_xrpcClntDeSeria;
            return shredBAT;
        } else {
            handle_soap_fault_msg(b->buf);
            BBPreclaim(shredBAT);
            return NULL;
        }
    }

    if(shred(shredBAT, NULL, NULL, in, 0, NULL, NULL, NULL) ==GDK_FAIL) {
        GDKerror("response2bat: invalid XRPC response received\n");
        BBPreclaim(shredBAT);
        stream_close(in); stream_destroy(in);
        return NULL;
    }

    /* Stop timing Client DeSerialisation */
    *time_xrpcClntDeSeria = GDKusec() - *time_xrpcClntDeSeria;
    stream_close(in); stream_destroy(in);
    return shredBAT;
}

int
CMDhttp_post(BAT **res, str options, str dst, str rpc_module,
        str rpc_uri, str rpc_method, int *updCall, int *arity,
        lng *itercnt, BAT *ws, BAT *fun_vid, BAT *fun_iter,
        BAT *fun_item, BAT *fun_kind, BAT *int_values, BAT *dbl_values,
        BAT *dec_values, BAT *str_values)
{
    int sock = -1;
    buffer *b = NULL;
    str str_val = NULL;
    stream *out = NULL, *bs = NULL;
    /* Hold the temp BATs after the RPC response has been shredded: */
    BAT *shredBAT = NULL;
    /* BATs hold item|kind of a node parameter */
    BAT *node_item = NULL, *node_kind = NULL;
    /* Pointers to the current BUNs of the BATs. */
    BUN p_vid, p_iter, p_item, p_kind;

    lng i, a, nr_args = 0, max_args = 0, arg_offset = 0;
    lng argc = *arity, my_argc = 0;
    lng iterc = *itercnt, my_iter = 0;
    lng **argcnt = NULL; /* #items each [iter][param] contains */

    /* BATs needed for serializing attributes */
    BAT *attr_qn = NULL, *attr_prop = NULL;
    BAT *qn_prefix = NULL, *qn_loc = NULL, *prop_val = NULL;

    lng time_xrpcClntSeria = 0, time_xrpcClntDeSeria = 0;
    lng time_xrpcClnt2Serv = 0;
    size_t bytes_sent = 0;
    char *protocol = strstr(dst, "://");
    if (protocol) dst = protocol+3; 

    errCheck(iterc, argc, ws, fun_vid, fun_iter, fun_item, fun_kind,
            int_values, dbl_values, dec_values, str_values);


    if ((sock = setup_connection(dst)) < 0) {
        return GDK_FAIL;
    }
    if (!(out = socket_wastream(sock, "http_send"))) {
        GDKerror("CMDhttp_post: failed to create socket_wastream\n");
        close(sock);
        return GDK_FAIL;
    }

    /* Start timing Client Serialisation */
    time_xrpcClntSeria = GDKusec();

    /* Create buffer for the RPC request message */
    b = buffer_create(MAX_BUF_SIZE);
    if (!b || b->len == 0) {
        GDKerror("CMDhttp_post: failed to create outgoing buffer\n");
        clean_up(sock, out, bs, b, argcnt, iterc);
        return GDK_FAIL;
    }

    b->pos = snprintf(b->buf, b->len, XRPC_HEADER,
            SOAP_NS, XRPC_NS, XS_NS, XSI_NS, XRPC_NS, XRPC_LOC,
            rpc_module, rpc_uri, rpc_method);

    if (!(argcnt = GDKmalloc(iterc * sizeof(lng*)))) {
        GDKerror("CMDhttp_post: failed to malloc argcnt\n");
        clean_up(sock, out, bs, b, argcnt, iterc);
        return GDK_FAIL;
    }
    for (i = 0; i < iterc; i++) {
        /* we allocate at least _one_ argcnt for each parameter, so that
         * we have a place to note that a function has zero parameter */
        if (!(argcnt[i] = GDKmalloc((argc>0?argc:1) * sizeof(lng)))) {
            GDKerror("CMDhttp_post: failed to malloc argcnt[" SZFMT "]\n", i);
            clean_up(sock, out, bs, b, argcnt, iterc);
            return GDK_FAIL;
        }
        argcnt[i][0] = 0;
        for (a = 1; a < argc; a++) {
            argcnt[i][a] = 0;
        }
    }
    max_args = iterc * MAX_NR_PARAMS;

    /* Calculate the number of values contained by every parameter of
     * every iteration. */
    i = a = 0; /* i: iter counter; a: arg counter */
    for (p_vid  = BUNfirst(fun_vid),  p_iter = BUNfirst(fun_iter),
         p_item = BUNfirst(fun_item), p_kind = BUNfirst(fun_kind);

         p_vid  < BUNlast(fun_vid)  && p_iter < BUNlast(fun_iter) &&
         p_item < BUNlast(fun_item) && p_kind < BUNlast(fun_kind);

         p_vid  = BUNnext(fun_vid, p_vid),
         p_iter = BUNnext(fun_iter, p_iter),
         p_item = BUNnext(fun_item, p_item),
         p_kind = BUNnext(fun_kind, p_kind)) {

        i = *(oid*) BUNtail(fun_iter, p_iter);
        a = *(oid*) BUNtail(fun_vid,  p_vid);
        argcnt[i-1][a]++;
        nr_args++;
        if (nr_args == max_args) {
            GDKerror("CMDhttp_post: too many parameters.\n");
            clean_up(sock, out, bs, b, argcnt, iterc);
            return GDK_FAIL;
        }
    }
    max_args = nr_args; /* actual number of argval-s */
    nr_args = 0;

    /* TODO: reuse serialization code to generate the message */
    for (my_iter = 0; my_iter < iterc; my_iter++) {
        /* Enlarge the buffer if it is filled more than 80%.
         * FIXME: is this really necessary? Or should we just return an
         * error?
         */
        if (b->pos > (b->len * 0.8)) {
            b->len *= 2;
            char *bptr = realloc(b->buf, b->len);
            if (!bptr) {
                GDKerror("CMDhttp_post: failed to allocate larger message buffer.\n");
                clean_up(sock, out, bs, b, argcnt, iterc);
                return GDK_FAIL;
            }
            b->buf = bptr;
        }

        if (argc == 0) {
            str2buf(b, "<xrpc:call/>");
            continue;
        }

        str2buf(b, "<xrpc:call>"); /* start an iteration */
        for (my_argc = 0; my_argc < argc; my_argc++) {
            if (argcnt[my_iter][my_argc] == 0) {
                str2buf(b, "<xrpc:sequence/>");
                continue;
            }
            arg_offset = 0;
            /* add the 'argcnt' of all arg-s before 'me': */
            for (a = 0; a < my_argc; a++) {
                for (i = 0; i < iterc; i++)
                    arg_offset += argcnt[i][a];
            }
            /* add the 'argcnt' of iter-s before 'me': */
            for (i = 0; i < my_iter; i++) {
                arg_offset += argcnt[i][my_argc];
            }
            /* now 'arg_offset' contains the start position of the
             * values of my_iter and my_argc in the fun_* BATs */

            str2buf(b, "<xrpc:sequence>"); /* start a parameter */
            int k;
            for (k= 0; k < argcnt[my_iter][my_argc]; k++) {
                int cmbn_cont_kind = 0, cur_kind = 0, contID = 0;
                chr elem_kind = 0;
                oid item;

                a = arg_offset + k; /* index into fun_item|fun_kind */
                item= *(oid*)BUNtail(fun_item, BUNptr(fun_item, a));
                cmbn_cont_kind = *(int*)BUNtail(fun_kind, BUNptr(fun_kind, a));
                cur_kind = XTRACT_KIND(cmbn_cont_kind);

                switch (cur_kind) {
                    case BOOL:
                        value2buf(b, fun_item, a, TYPE_bit, int_values,
                                "<xrpc:atomic-value xsi:type=\"xs:boolean\">",
                                "</xrpc:atomic-value>");
                        break;
                    case INT:
                        value2buf(b, fun_item, a, TYPE_lng, int_values,
                                "<xrpc:atomic-value xsi:type=\"xs:integer\">",
                                "</xrpc:atomic-value>");
                        break;
                    case DEC:
                        value2buf(b, fun_item, a, TYPE_dbl, dbl_values,
                                "<xrpc:atomic-value xsi:type=\"xs:decimal\">",
                                "</xrpc:atomic-value>");
                        break;
                    case DBL:
                        value2buf(b, fun_item, a, TYPE_dbl, dbl_values,
                                "<xrpc:atomic-value xsi:type=\"xs:double\">",
                                "</xrpc:atomic-value>");
                        break;
                    case STR:
                        i = *(oid*)BUNtail(fun_item, BUNptr(fun_item, a));
                        str_val = BUNtail(str_values, BUNptr(str_values, i));
                        b->pos += snprintf((b->buf + b->pos), (b->len - b->pos),
                                        "<xrpc:atomic-value xsi:type=\"xs:string\">%s"
                                        "</xrpc:atomic-value>", str_val);
                        break;
                    case U_A:
                        i = *(oid*)BUNtail(fun_item, BUNptr(fun_item, a));
                        str_val = BUNtail(str_values, BUNptr(str_values, i));
                        b->pos += snprintf((b->buf + b->pos), (b->len - b->pos),
                                        "<xrpc:atomic-value xmlns:xdt=\"%s\" "
                                        "xsi:type=\"xdt:untypedAtomic\">"
                                        "%s</xrpc:atomic-value>",
                                        XDT_NS, str_val);
                        break;
                    case ATTR:
                    {
                        str2buf(b, "<xrpc:attribute");
                        contID = XTRACT_CONT(cmbn_cont_kind);

                        attr_qn   = getWsBAT(ws, contID, ATTR_QN);
                        attr_prop = getWsBAT(ws, contID, ATTR_PROP);
                        prop_val  = getWsBAT(ws, contID, PROP_VAL);
                        qn_prefix = getWsBAT(ws, contID, QN_PREFIX);
                        qn_loc    = getWsBAT(ws, contID, QN_LOC);
                        if( (!attr_qn) || (!attr_prop) || (!prop_val) ||
                            (!qn_prefix) || (!qn_loc) ){
                            clean_up(sock, out, bs, b, argcnt, iterc);
                            return GDK_FAIL;
                        }
                        
                        i = *(oid*)BUNtail(fun_item, BUNptr(fun_item, a));
                        a = *(oid*)BUNtail(attr_qn, BUNptr(attr_qn, i));
                        char *prefix = (char*)BUNtail(qn_prefix, BUNptr(qn_prefix, a));
                        char *loc    = (char*)BUNtail(qn_loc,    BUNptr(qn_loc, a));
                        a = *(oid*)BUNtail(attr_prop, BUNptr(attr_prop,i));
                        char *attr_val = (char*)BUNtail(prop_val, BUNptr(prop_val, a));

                        str2buf(b, " ");
                        if (prefix && *prefix){
                            str2buf(b, prefix);
                            str2buf(b, ":");
                        }
                        str2buf(b, loc);
                        str2buf(b, "=\"");
                        str2buf(b, attr_val);
                        str2buf(b, "\"/>");
                        break;
                    }
                    case ELEM:
                    {
                        contID = XTRACT_CONT(cmbn_cont_kind);
                        elem_kind = getELEMkind(ws, contID, item);
                        if (elem_kind == GDK_chr_min) {
                            clean_up(sock, out, bs, b, argcnt, iterc);
                            return GDK_FAIL;
                        }
                        switch(elem_kind) {
                            case 0: str2buf(b, "<xrpc:element>");                break;
                            case 1: str2buf(b, "<xrpc:text>");                   break;
                            case 2: str2buf(b, "<xrpc:comment>");                break;
                            case 3: str2buf(b, "<xrpc:processing-instruction>"); break;
                            case 4: str2buf(b, "<xrpc:document>");               break;
                            case 5: /* COLLECTION: nothing to be done, here */   break;
                            default:
                                GDKerror("CMDhttp_post: call%d/sequence%d/item%d has "
                                        "invalid type %d\n", my_iter, my_argc, i);
                                clean_up(sock, out, bs, b, argcnt, iterc);
                                return GDK_FAIL;
                        }
                        /* print body of the node */
                        node_item = BUNins( BATnew(TYPE_void, TYPE_oid, 1),
                                            BUNhead(fun_item, BUNptr(fun_item, a)),
                                            BUNtail(fun_item, BUNptr(fun_item, a)), FALSE );
                        node_kind = BUNins( BATnew(TYPE_void, TYPE_int, 1),
                                            BUNhead(fun_kind, BUNptr(fun_kind, a)),
                                            BUNtail(fun_kind, BUNptr(fun_kind, a)), FALSE );
                        if (!(bs = buffer_wastream(b, "shred_element"))) {
                            GDKerror("CMDhttp_post: failed to create buffer_wastream to "
                                    "shred element parameter\n");
                            clean_up(sock, out, bs, b, argcnt, iterc);
                            return GDK_FAIL;
                        }
                        xquery_print_result_driver(bs,
                                "xml-noheader-noroot", NULL, NULL, NULL, NULL,
                                ws, 1,
                                node_item, node_item, node_item, node_kind,
                                int_values, dbl_values, str_values);

                        if(BBPreclaim(node_item) == -1){
                            GDKerror("CMDhttp_post: failed to destroy "
                                    "BAT \"node_item\", because it is in "
                                    "use by other process!");
                            GDKerror("THIS SHOULD NEVER HAPPEN!!!");
                            clean_up(sock, out, bs, b, argcnt, iterc);
                            return GDK_FAIL;
                        }

                        if(BBPreclaim(node_kind) == -1){
                            GDKerror("CMDhttp_post: failed to destroy "
                                    "BAT \"node_item\", because it is in "
                                    "use by other process!");
                            GDKerror("THIS SHOULD NEVER HAPPEN!!!");
                            clean_up(sock, out, bs, b, argcnt, iterc);
                            return GDK_FAIL;
                        }

                        switch(elem_kind) {
                            case 0: str2buf(b, "</xrpc:element>");                break;
                            case 1: str2buf(b, "</xrpc:text>");                   break;
                            case 2: str2buf(b, "</xrpc:comment>");                break;
                            case 3: str2buf(b, "</xrpc:processing-instruction>"); break;
                            case 4: str2buf(b, "</xrpc:document>");               break;
                            case 5: /* COLLECTION: nothing to be done, here */    break;
                            default:
                                GDKerror("CMDhttp_post: should have never reached here!");
                                clean_up(sock, out, bs, b, argcnt, iterc);
                                return GDK_FAIL;
                        }
                    }   break;
                    default:
                        GDKerror("CMDhttp_post: call%d/sequence%d/item%d has invalid type %d\n",
                                my_iter, my_argc, i);
                        clean_up(sock, out, bs, b, argcnt, iterc);
                        return GDK_FAIL;
                }
            }
            str2buf(b, "</xrpc:sequence>");
        }
        str2buf(b, "</xrpc:call>");
    }
    str2buf(b, XRPC_FOOTER);
    b->buf[b->pos] = 0;
    /* Stop timing Client Serialisation */
    time_xrpcClntSeria = GDKusec() - time_xrpcClntSeria;

    /* Start timing Network Send Client2Server */
    time_xrpcClnt2Serv = GDKusec();
    bytes_sent = stream_printf(out,
            "POST %s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Accept: text/html, text/xml, application/soap+xml\r\n"
            "Accept-Language: en-uk en-us\r\n"
            "Content-Type: text/html; charset=\"utf-8\"\r\n"
            "Content-Length: " SZFMT "\r\n\r\n"
            "%s",
            XRPCD_CALLBACK, dst, b->pos, b->buf);
    if (bytes_sent < b->pos) {
        GDKerror("CMDhttp_post: failed to send XRPC request.");
        clean_up(sock, out, bs, b, argcnt, iterc);
        return GDK_FAIL;
    }
    /* Stop timing Network Send Client2Server */
    time_xrpcClnt2Serv= GDKusec() - time_xrpcClnt2Serv;

    shredBAT = response2bat(sock, dst, b, *updCall, &time_xrpcClntDeSeria);
    if(!shredBAT) {
        clean_up(sock, out, bs, b, argcnt, iterc);
        return GDK_FAIL;
    }

    if (options && strstr(options, "timing")) {
        stream_printf(GDKout,
                "XRPC_Client_Serialisation (create_req_msg):   " LLFMT " microsec\n"
                "XRPC_Network_Client_2_Server:  " LLFMT " microsec\n"
                "XRPC_Data_Sent:                " SZFMT " bytes\n\n"
                "XRPC_Client_DeSerialisation (response2bat):   " LLFMT " microsec\n",
                time_xrpcClntSeria,
                time_xrpcClnt2Serv,
                bytes_sent,
                time_xrpcClntDeSeria);
    }

    clean_up(-1, out, bs, b, argcnt, iterc);
    *res = shredBAT;
    return GDK_SUCCEED;
}
/* vim:set shiftwidth=4 expandtab: */
