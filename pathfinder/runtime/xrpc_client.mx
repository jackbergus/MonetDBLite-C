@/
Copyright Notice:
-----------------

The contents of this file are subject to the Pathfinder Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License.  You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
the License for the specific language governing rights and limitations
under the License.

The Original Code is the Pathfinder system.

The Original Code has initially been developed by the Database &
Information Systems Group at the University of Konstanz, Germany and
the Database Group at the Technische Universitaet Muenchen, Germany.
It is now maintained by the Database Systems Group at the Eberhard
Karls Universitaet Tuebingen, Germany.  Portions created by the
University of Konstanz, the Technische Universitaet Muenchen, and the
Universitaet Tuebingen are Copyright (C) 2000-2005 University of
Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
2008-2010 Eberhard Karls Universitaet Tuebingen, respectively.  All
Rights Reserved.
@
@' $Id$
@'

@f xrpc_client
@a Ying Zhang

@t MIL primitives of XRPC client

@* Introduction
This module provides new MIL primitives for the client side support of
remote XQuery execution using HTTP connection on top of MonetDB for
the "AmbientDB" project.
@
@* Module Definition
@m
.MODULE xrpc_client;

@- HTTP client function(s)
@m

.USE lock;

.COMMAND http_post(
        str genType,
        str mode,
        str qid,
        str xrpc_hostport,
        bit firstCaller,
        lng seqnr,
        lng timeout,
        str dst,
        str module,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng itercnt,
        BAT[void, bat] ws,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[str, bat] = CMDhttp_post;
"Create and send a RPC request message to the specified destination"

.COMMAND get_rpc_res ( 
        oid cont, 
        BAT[void, bat] ws, 
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values, 
        BAT[void, str] str_values) : BAT[void, bat] = CMDget_rpc_res;
"Retrieve values from the response message and return as a iter|item|kind bat"

.COMMAND xrpc_commit(str qid, str mode, BAT[void,str] participants) : void = CMDxrpc_2pc_commit;
"coordinate a 2pc commit"

.END xrpc_client;

@mil

PROC doLoopLiftedRPC(
        str modname,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng niters,
        BAT[void, BAT] ws,
        BAT[oid,  str] dsts,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[void,bat]
{
    var unq_dsts := dsts.tunique().hmark(0@0);
    var steps := unq_dsts.count();
    var rpcerr_lock := lock_create(); # guards rpc_errors
    var rpc_errors := ""; # holds errors from each destination
    var rpcres_lock := lock_create(); # guards rpc_results and rpc_iter
    var rpc_results := bat(str,bat);
    var rpc_iter := bat(void,bat).seqbase(0@0);
    var off := count(ws.fetch(CONT_NAME));

    # unlock the working set while making the calls (enables circular patterns nested 2PC xrpc calls)
    var wslock;
    if (xrpc_qid != "") {  
        lock_set(xrpc_lock);
        var err := CATCH(wslock := xrpc_locks.fetch(reverse(xrpc_qids).find(xrpc_qid)));
        lock_unset(xrpc_lock);
        if (not(isnil(err))) ERROR(err);
        lock_unset(wslock);
    }
    unq_dsts @ [steps] batloop(){
        var time_xrpcClntSeria := usec();

        # get iteration numbers for this destination
        var iter_dst := [oid](rpc_dsts.ord_uselect($t).reverse());
            iter_dst := iter_dst.reverse().mirror();
        var itercnt := iter_dst.count().lng();

        # retrieve the frag of fun_vid, fun_iter, fun_item and fun_kind
        # for this iteration.

        # order of 'fun_iter' needs to be preserved, so use 'leftjoin',
        # iso. 'join'.
        var fun_iter_dst := fun_iter.leftjoin(iter_dst);
        var indices      := fun_iter_dst.hmark(0@0);
        var fun_vid_dst  := indices.leftfetchjoin(fun_vid);
        var fun_item_dst := indices.leftfetchjoin(fun_item);
        var fun_kind_dst := indices.leftfetchjoin(fun_kind);

        # renumber the iters, starting from 1
        fun_iter_dst := fun_iter_dst.leftjoin(iter_dst.mark(1@0));
        fun_iter_dst := [oid](fun_iter_dst.tmark(0@0));

        time_xrpcClntSeria := usec() - time_xrpcClntSeria;
        if (genType.search("timing") >= 0) {
            printf("XRPC_Client_Serialisation (get_dst_params):   %lld microsec\n",
                    time_xrpcClntSeria);
        }

        var local_name := "rpc_res_00" + str(int($h)+off);
        var rpc_res, timeout := max(0LL,xrpc_timeout - ((usec() - time_start)/1000));
        var rpc_err := CATCH(rpc_res := http_post(genType, xrpc_mode, xrpc_qid,
                    xrpc_hostport, (xrpc_caller = ""),
                    xrpc_seqnr, timeout, $t, modname, location, method,
                    updCall, arity, itercnt, ws, fun_vid_dst, fun_iter_dst, fun_item_dst,
                    fun_kind_dst, int_values, dbl_values, dec_values, str_values));

        var time_xrpcClntDeSeria := usec();

        if (isnil(rpc_err)) {
            lock_set(rpcres_lock);
            rpc_results.insert(local_name,rpc_res);
            rpc_iter.append(iter_dst.hmark(0@0));
            lock_unset(rpcres_lock);

            time_xrpcClntDeSeria := usec() - time_xrpcClntDeSeria;
            if (genType.search("timing") >= 0) {
                printf("XRPC_Client_DeSerialisation (insert_rpc_res): %lld microsec\n",
                        time_xrpcClntDeSeria);
            }
        } else {
            printf("doLoopLiftedRPC: error occurred at %s:\n%s\n", $t, rpc_err);
            # A none-isolation XRPC query: we do not want to discard
            # results from other destinations where executions might
            # have succeeded, so we only print a message by error,
            # iso. terminate the execution with 'ERROR'
            lock_set(rpcerr_lock);
            CATCH({ rpc_errors := rpc_errors + $t + ": " + rpc_err + "\n"; });
            lock_unset(rpcerr_lock);
        }
    }
    if (xrpc_qid != "") lock_set(wslock);
    lock_destroy(rpcres_lock);
    lock_destroy(rpcerr_lock);

    var time_xrpcClntDeSeria := usec();

    var res_iter := bat(void,oid).seqbase(0@0);
    var res_item := bat(void,oid).seqbase(0@0);
    var res_kind := bat(void,int).seqbase(0@0);
    var res_bats := bat(void,bat,4).seqbase(0@0);

    if(count(rpc_results) = 0) {
        ERROR("doLoopLiftedRPC: execution failed at all destinations:\n%s\n", rpc_errors);
    } else if(rpc_errors != "") {
        ERROR("doLoopLiftedRPC: execution failed at some destinations:\n%s\n", rpc_errors);
    }

    # retrieve results for this destination, and map the results back to
    # the original iteration number
    var proc_res := [get_rpc_res](
            [ws_opencoll](const ws, rpc_results.tmark(0@0), rpc_results.hmark(0@0), TEMP_DOC),
            const ws, const int_values, const dbl_values, const str_values);

    res_iter := bat(void,bat).seqbase(0@0); 
                proc_res.[fetch](0)@batloop() res_iter.append($t.leftfetchjoin(rpc_iter.find($h)));
    res_item := proc_res.[fetch](1);
    res_kind := proc_res.[fetch](2);

    # initialize res_bat with the results for the first destination
    res_bats.append(res_iter.fetch(0));
    res_bats.append(res_item.fetch(0));
    res_bats.append(res_kind.fetch(0));

    # if there were more destinations, merge the result tables 
    var i := 0;
    while ((i :+= 1) < steps) {
        # initialize res_bat with the results for the first destination 
        res_bats := merged_union(res_bats.fetch(0), res_iter.fetch(i), 
                                 res_bats.fetch(1), res_item.fetch(i), 
                                 res_bats.fetch(2), res_kind.fetch(i));
    }

    time_xrpcClntDeSeria := usec() - time_xrpcClntDeSeria;
    if (genType.search("timing") >= 0) {
        printf("XRPC_Client_DeSerialisation (get_rpc_res):    %lld microsec\n",
                time_xrpcClntDeSeria);
    }
    return res_bats;
}
ADDHELP("doLoopLiftedRPC", "zhang", "April 2006",
"DESCRIPTION: implementation of the loop-lifted RPC",
"xrpc_client");

PROC doIterativeRPC(
        str modname,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng niters,
        BAT[void,BAT] ws,
        BAT[oid, str] dsts,
        BAT[void,oid] fun_vid,
        BAT[void,oid] fun_iter,
        BAT[void,oid] fun_item,
        BAT[void,int] fun_kind,
        BAT[void,lng] int_values,
        BAT[void,dbl] dbl_values,
        BAT[void,dbl] dec_values,
        BAT[void,str] str_values) : BAT[void,bat]
{
    # unlock the working set while making the calls (enables circular patterns nested 2PC xrpc calls)
    var wslock;
    if (xrpc_qid != "") {  
        lock_set(xrpc_lock);
        var err := CATCH(wslock := xrpc_locks.fetch(reverse(xrpc_qids).find(xrpc_qid)));
        lock_unset(xrpc_lock);
        if (not(isnil(err))) ERROR(err);
    }

    var time_xrpcClntSeria := 0;
    var time_xrpcClntDeSeria := 0;

    var res_bats := nil;
    var h := 0;
    var t := 1;
    while (lng(h) < niters){
        # get function parameters for this destination
        var time_xrpcClntSeriaStart := usec();
        var dst := dsts.fetch(h);
        var cur_fun_iter := fun_iter.select(oid(t));
        var cur_fun_vid  := fun_vid.fetch(cur_fun_iter.mirror()).tmark(0@0);
        var cur_fun_item := fun_item.fetch(cur_fun_iter.mirror()).tmark(0@0);
        var cur_fun_kind := fun_kind.fetch(cur_fun_iter.mirror()).tmark(0@0);
        # renumber cur_fun_iter, we only have one iteration
        cur_fun_iter := cur_fun_iter.tmark(0@0).project(1@0);
        time_xrpcClntSeria := time_xrpcClntSeria + (usec() - time_xrpcClntSeriaStart);

        var local_name := "rpc_res_00" + str(h+1);
        if (xrpc_qid != "") lock_unset(wslock);
        var rpc_res, timeout := max(0LL,xrpc_timeout - ((usec() - time_start)/1000));
        var rpc_err := CATCH(rpc_res := http_post(genType, xrpc_mode, xrpc_qid, xrpc_hostport, (xrpc_caller = ""), 
                    xrpc_seqnr, timeout, dst, modname, location, method,
                    updCall, arity, lng(1), ws, cur_fun_vid, cur_fun_iter, cur_fun_item,
                    cur_fun_kind, int_values, dbl_values, dec_values, str_values));
        if (xrpc_qid != "") lock_set(wslock);


        # add result of this iteration to result BATs
        var time_xrpcClntDeSeriaStart := usec();
        if (isnil(rpc_err)) {
            var rpc_oid := ws_opencoll(ws, rpc_res, local_name, TEMP_DOC);
            var res := get_rpc_res(rpc_oid, ws, int_values, dbl_values, str_values);
            if (isnil(res_bats)){
                res_bats := res;
            } else {
                # merge results of this iteration into existing results.
                res_bats := merged_union(res_bats.fetch(0), res.fetch(0), 
                                         res_bats.fetch(1), res.fetch(1), 
                                         res_bats.fetch(2), res.fetch(2));
            }
        } else {
            # We do not want to discard results from other destinations
            # where executions might have succeeded, so we only print a
            # WARNING by error, iso. terminate the execution with 'ERROR'
            printf("!WARNING: doIterativeRPC: ");
            printf("error occurred during RPC call to \"%s\".\n", dst);
            printf("!WARNING: Received error was: \n%s\n", rpc_err);
        }
        h := h + 1;
        t := t + 1;

        time_xrpcClntDeSeria := time_xrpcClntDeSeria + (usec() - time_xrpcClntDeSeriaStart);
    }

    var time_xrpcClntDeSeriaStart := usec();
    time_xrpcClntDeSeria := time_xrpcClntDeSeria + (usec() - time_xrpcClntDeSeriaStart);

    if (genType.search("timing") >= 0) {
        printf("XRPC_Client_Serialisation (get_dst_params):   %lld microsec\n",
                time_xrpcClntSeria);
        printf("Client_DeSerialisation (get_rpc_res):        %lld msec\n",
                time_xrpcClntDeSeria);
    }

    if(isnil(res_bats)) {
        ERROR("doIterativeRPC: execution of all iterations failed");
    }

    return res_bats;
}
ADDHELP("doIterativeRPC", "zhang", "April 2006",
"DESCRIPTION: make a separate RPC call for ever iteration",
"xrpc_client");

PROC doRPC(
        str modname,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng niters,
        BAT[void, BAT] ws,
        BAT[oid,  str] dsts,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[void,bat]
{
    if (search(xrpc_mode,"iterative") >= 0) 
        return doIterativeRPC(modname, location, method, updCall, arity, niters,
                              ws, dsts, fun_vid, fun_iter, fun_item, fun_kind, int_values, dbl_values, dec_values, str_values);
    else
        return doLoopLiftedRPC(modname, location, method, updCall, arity, niters,
                               ws, dsts, fun_vid, fun_iter, fun_item, fun_kind, int_values, dbl_values, dec_values, str_values);
}


@h
#ifndef XRPC_CLIENT_H
#define XRPC_CLIENT_H

#define MAX_BUF_SIZE            (1024*1024)
#define NR_RETRIES              3

#endif /* XRPC_CLIENT_H */

@c
#include "pf_config.h"
#include <gdk.h>
#include <stream_socket.h>
#ifdef _WIN32   /* Windows specific */
    #include <winsock.h>
    #define snprintf _snprintf
    #ifndef __MINGW32__
        #pragma comment(lib, "ws2_32")
    #endif
#else           /* UNIX specific */
    #include <sys/select.h>
    #include <sys/types.h>  /* used by socket */
    #include <sys/socket.h>
    #include <unistd.h>     /* gethostname() */
    #include <netinet/in.h> /* hton and ntoh */
    #include <arpa/inet.h>  /* dotted IP addr to and from 32-bits int */
    #include <netdb.h>      /* gethostbyname() */
    #include <ctype.h>
#endif
#include "pathfinder.h"
#include "pf_support.h"
#include "shredder.h"
#include "serialize.h"
#include "xrpc_common.h"
#include "xrpc_client.h"

int 
CMDget_rpc_res(BAT **res, 
        oid *cont, 
        BAT *ws, 
        BAT *int_values,
        BAT *dbl_values, 
        BAT *str_values) 
{
    lng ok = GDK_FAIL;
    oid i, j, it;
    char err[4098];
    BATiter wi = bat_iterator(ws);
    BAT *participants = BATdescriptor(*(bat*) BUNtail(wi, XRPC_PARTICIPANTS));

    if (participants) {
        BAT *shredBAT = BATnew(TYPE_void, TYPE_bat, BATTINY);
        if (shredBAT) {
            XRPCreq_t *req;
            /* create a list of all main document bats (as parse_message likes it that way) */
            for(i=0; i <= ATTR_PROP; i++) {
                BAT *b = BATdescriptor(*(bat*) BUNtail(wi, i));
                if (b) {
                    BATiter bi = bat_iterator(b);
                    BUNappend(shredBAT, BUNtail(bi, *cont), FALSE);
                    BBPunfix(b->batCacheid);
                }
            }
            err[0] = '\0';
            req = xrpc_parse_message(err, 4098, shredBAT, participants);
            if (req) { 
                BAT *res_iter = BATnew(TYPE_void, TYPE_oid, req->nr_args);
                if (res_iter) {
                    BAT *res_item = BATnew(TYPE_void, TYPE_oid, req->nr_args);
                    if (res_item) {
                        BAT *res_kind = BATnew(TYPE_void, TYPE_int, req->nr_args);
                        if (res_kind) {
                            *res = BATnew(TYPE_void, TYPE_bat, 3);
                            if (*res) {
                                lng *argcnt = req->argcnt[0];
                                char *err = NULL;
                                BUNappend(*res, &res_iter->batCacheid, FALSE);
                                BUNappend(*res, &res_item->batCacheid, FALSE);
                                BUNappend(*res, &res_kind->batCacheid, FALSE);
                                BATseqbase(res_iter, 0);
                                BATseqbase(res_item, 0);
                                BATseqbase(res_kind, 0);
                                BATseqbase(*res, 0);
       
                                /* get all values fro all result sequences one by one */ 
                                for(it=i=j=0; i<req->nr_args; i++,j++) {
                                    char* err = xquery_parse_val(req->argtpe[i], req->argval[i], res_item, res_kind,
                                                                 int_values, dbl_values, str_values, NULL, *cont);
                                    if (err) break;

                                    /* set the correct iteration number */
                                    while (j == (unsigned) argcnt[it]) { 
                                        j=0; it++; 
                                    }
                                    BUNappend(res_iter, &it, FALSE);
                                }
                                if (err) GDKerror(err); 
                                else ok = GDK_SUCCEED;
                            }
                            BBPunfix(res_kind->batCacheid);
                        }  
                        BBPunfix(res_item->batCacheid);
                    }
                    BBPunfix(res_iter->batCacheid);
                }
                XRPCreq_free(req);
            } else {
                GDKerror(err);
            }
            BBPreclaim(shredBAT);
        }
        BBPunfix(participants->batCacheid);
    }
    return ok;
}


static buffer *
clean_up(stream *bs, lng **argcnt, lng iterc)
{
    lng i = 0;
    if(bs){
        buffer_destroy(mnstr_get_buffer(bs));
        mnstr_close(bs); mnstr_destroy(bs);
    }
    if(argcnt) {
        for(i = 0; i < iterc; i++) GDKfree(argcnt[i]);
        GDKfree(argcnt);
    }
    return NULL;
}

static void
handle_error_msg(char *errmsg)
{
    char *strptr, *strptr2;

    strptr = strstr(errmsg, "<env:Value");
    if(!strptr) {
        GDKerror(errmsg);
        return;
    }
    strptr = strchr(strptr, '>'); assert(strptr);
    strptr2 = strstr(++strptr, "</env:Value>");
    if( (!strptr) || (!strptr2) ) {
        GDKerror("handle_error_msg: SOAP Fault message not "
                 "well-formed at \"<env:Value>.\n%s\n", errmsg);
        return;
    }
    strptr2[0] = '\0';
    GDKerror("SOAP Fault Code  : %s\n", strptr);
    strptr2[0] = '<';

    strptr = strstr(strptr2+12, "<env:Text");
    if(!strptr) {
        GDKerror("handle_error_msg: SOAP Fault message not "
                 "well-formed: could not find \"<env:Text\".\n%s\n",
                 errmsg);
        return;
    }
    strptr = strchr(strptr, '>') + 1;
    strptr2 = strstr(strptr, "</env:Text>");
    if( (!strptr) || (!strptr2) ) {
        GDKerror("handle_error_msg: SOAP Fault message not "
                 "well-formed at \"<env:Text>\".\n%s\n", errmsg);
        return;
    }
    strptr2[0] = '\0';
    GDKerror("SOAP Fault Reason:\n%s\n", strptr);
}

/* Create a HTTP client socket.
 *
 * Returns: a socket number if succeeded, -1 otherwise.
 */
static SOCKET
setup_connection(str dst, int *port)
{
    struct in_addr      addr;
    struct sockaddr_in  sockaddr;
    struct hostent     *resolv = NULL;
    int i, p = 0;
    SOCKET ret, sock = INVALID_SOCKET;
    str strptr = NULL;
   
    /* remove whitespace characters at the beginning and the end of the
     * string */
    while(dst[0] == ' '  || dst[0] == '\t' ||
          dst[0] == '\r' || dst[0] == '\n')
        dst++;
    i = strlen(dst) -1;
    while(dst[i] == ' '  || dst[i] == '\t' ||
          dst[i] == '\r' || dst[i] == '\n')
        i--;
    dst[i + 1] = '\0';

    strptr = strstr(dst, "://");
    if (strptr) strptr += 3; 
    else strptr = dst;

    /* 'dst' has the form 'URL[:port]' */
    if ((strptr = strchr(strptr, (int)':')) != NULL) {
        strptr[0] = '\0'; strptr++;
        p = strtol(strptr, (char **)NULL, 10);
        if (p <= 0) {
            GDKerror("setup_connection: invalid port number: %s\n", strptr);
            return INVALID_SOCKET;
        }
    } else { /* find the default port number from "monet_environment" */
        if( !(strptr = GDKgetenv("xrpc_port")) || !(*strptr) ){
            if( !(strptr = GDKgetenv("mapi_port")) ){
                GDKerror("setup_connection: could not find \"mapi_port\"\n");
                return INVALID_SOCKET;
            }
            p = atoi(strptr) + 1; 
        } else {
            p = atoi(strptr);
        }
    }

    if (isdigit((int) (unsigned char) dst[0])) {
        if ((i = inet_addr(dst)) < 0) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", dst);
            return INVALID_SOCKET;
        }
        addr.s_addr = (unsigned) i;
    } else {
        if (!(resolv = gethostbyname(dst))) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", dst);
            return INVALID_SOCKET;
        }
        addr.s_addr = ((struct in_addr *)resolv->h_addr_list[0])->s_addr;
    }

    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port   = htons(p);
    sockaddr.sin_addr.s_addr = addr.s_addr;
    memset(&(sockaddr.sin_zero), '\0', 8);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) != INVALID_SOCKET) {
        GDKerror("setup_connection: failed to create socket\n");
        return INVALID_SOCKET;
    }

    ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    for (i = NR_RETRIES; i > 0 && ret == INVALID_SOCKET; i--) {
        MT_sleep_ms(1);
        ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    }

    if (ret == INVALID_SOCKET) {
        GDKerror("setup_connection: failed to setup connection with %s:%d\n", dst, p);
        closesocket(sock);
        return INVALID_SOCKET;
    }

    *port = p;
    return sock;
}

/**
 * contID < 0 indicates ws[batID] is a simple BAT, i.e., a BAT without a
 * BAT tail.
 *
 * @return ws[batID] or ws[batID][contID] or NULL on error
 */
static BAT *
getBatFromContainer(BAT *ws, int batID, int contID)
{
    BAT *b = NULL, *batbat = NULL;
    BUN bun = BUN_NONE, bbun = BUN_NONE;
    oid CONTid = (oid)contID, BATid  = (oid)batID;
    BATiter wsi, batbati;

    assert(ws && batID >= 0);

    wsi = bat_iterator(ws);
    BUNfndOID(bun, wsi, (ptr)&BATid);
    if(bun == BUN_NONE) {
        GDKerror("getBatFromContainer: BAT ws[%d] not found\n",batID);
        return NULL;
    }
    if( !(batbat = BATdescriptor(*(bat*)Tloc(ws,bun))) ) {
        GDKerror("getBatFromContainer: failed to fetch BAT ws[%d]\n", batID);
        return NULL;
    }

    if(contID < 0) return batbat; /* this is a simple BAT, just return it */

    batbati = bat_iterator(batbat);
    BUNfndOID(bbun, batbati, (ptr)&CONTid);
    if(bbun == BUN_NONE) {
        BBPunfix(BBPcacheid(batbat));
        GDKerror("getBatFromContainer: BAT ws[%d][%d] not found\n", batID, contID);
        return NULL;
    }
    if( !(b = BATdescriptor(*(bat*)Tloc(batbat,bbun))) ) {
        BBPunfix(BBPcacheid(batbat));
        GDKerror("getBatFromContainer: failed to fetch BAT ws[%d][%d]\n", batID, contID);
        return NULL;
    }

    BBPunfix(BBPcacheid(batbat));
    return b;
}

/**
 * Find the 'pre_kind' value of 'item_index'-th BUN of the PRE_KIND BAT
 * of the container 'contID' from the working set.
 *
 * @param ws The whole working set.
 * @param contID container ID.
 * @param item_index BUN index in the PRE_KIND BAT.
 * @return the 'pre_kind' value, or
 *         GDK_chr_min by error
 */
static chr
getELEMkind(BAT *ws, int contID, oid item_index)
{
    BATiter bi;
    BAT *b  = NULL;
    BUN bun = BUN_NONE;
    chr ret;

    if(!(b = getBatFromContainer(ws, PRE_KIND, contID)))
        return GDK_chr_min;

    if (!b->batCount){
        GDKerror("getELEMkind: %s BAT is empty.\n",
                b?BBP_logical(b->batCacheid):"NULL");
        return GDK_chr_min;
    }
    bi.b = b;
    BUNfndVOID(bun, bi, &item_index);
    if (bun == BUN_NONE){
        GDKerror("%s BAT does not contain value " OIDFMT
                 " in its head column.\n",
                 b?BBP_logical(b->batCacheid):"NULL", item_index);
        return GDK_chr_min;
    }

    ret = *(chr*)BUNtail(bi,bun);
    BBPunfix( BBPcacheid(b));
    return ret;
}

/**
 * try to receive the response message and shred it into shredBAT
 * Returns shredBAT, or
 *         NULL on error
 */
static BAT *
response2bat(
        bool timing,
        stream *in,
        char *host,
        int port,
        bool updCall)
{
    lng time_xrpcClntDeSeria = 0;
    char respStatus[1024];
    int ret;
    buffer *resp;
    BAT *shredBAT;
    (void) updCall;

    /* Create buffer for the RPC response message */
    resp = buffer_create(MAX_BUF_SIZE);
    if (!resp || resp->len == 0) {
        GDKerror("response2bat: failed to create buffer for XRPC response message\n");
        goto error;
    }

    if( !(ret = mnstr_readline(in, respStatus, 1024)) ){
        GDKerror("response2bat: failed to receive response from %s:%d", host, port);
        goto error;
    }

    /* We only speak HTTP/1.1 */
    if( ret < 13 || /* we should have at least "HTTP/1.1 nnn ", 13 chars */
        /* FIXME: could use strncmp here */
        strstr(respStatus, "HTTP/1.1 ") != respStatus ||
        respStatus[12] != ' ' ||
        respStatus[ret -2] != '\r' ) {
        GDKerror("response2bat: invalid response from \"%s:%d\":\n", host, port);
        do{ /* read and print everything we can receive */
            if(respStatus[ret-2] == '\r')
                respStatus[ret -2] = '\0'; /* overwrite '\r' */
            GDKerror("%s\n", respStatus);
            ret = mnstr_readline(in, respStatus, 1024);
        } while (ret > 0);
        goto error;
    }
    respStatus[ret -2] = '\0';

    do{ /* read the HTTP header and throw it away */
        ret = mnstr_readline(in, resp->buf, 1024);
        if(ret == 2 && resp->buf[0] == '\r')
            ret = 0; /* end-of-HTTP-header found */
    } while (ret > 0);
    if (ret < 0) {
        GDKerror("response2bat: failed to receive response from %s:%d", host, port);
        goto error;
    }

    /* Now, we can check the response status */
    if(respStatus[9] != '2' || respStatus[10] != '0' || respStatus[11] != '0') {
        GDKerror("HTTP Error Code  : %s\n", respStatus+9);

        resp->pos = 0;
        do{ /* read the SOAP Fault message */
            ret = mnstr_read(in, (resp->buf + resp->pos), 1, (resp->len - resp->pos));
            if (ret > 0) resp->pos += ret;
        } while (ret > 0);
        if (ret < 0) {
            GDKerror("response2bat: failed to receive response from %s:%d", host, port);
            goto error;
        }
        resp->buf[resp->pos] = 0;
        handle_error_msg(resp->buf);
        goto error;
    }

    /* Start timing Client DeSerialisation */
    time_xrpcClntDeSeria = GDKusec();
    if (!(shredBAT = BATnew(TYPE_str, TYPE_bat, 32))){
        GDKerror("response2bat: failed to malloc shredBAT\n");
        goto error;
    }

    if(shred(shredBAT, NULL, NULL, in, 0, NULL, NULL, NULL) ==GDK_FAIL) {
        GDKerror("response2bat: invalid XRPC response received\n");
        BBPreclaim(shredBAT);
        goto error;
    }
    /* Stop timing Client DeSerialisation */
    time_xrpcClntDeSeria = GDKusec() - time_xrpcClntDeSeria;
    if (timing) {
        mnstr_printf(GDKout,
                "XRPC_Client_DeSerialisation (response2bat):   " LLFMT " microsec\n",
                time_xrpcClntDeSeria);
    }

    return shredBAT;
  error:
    if (resp)
        buffer_destroy(resp);
    return NULL;
}

static buffer *
byvalue_request(
        bool timing,
        str genType,
        str rpc_mode,
        str qid,
        str xrpc_hostport,
        bool firstCaller,
        lng seqnr,
        lng timeout,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        bool updCall,
        lng arity,
        lng iterc,
        BAT *ws,
        BAT *fun_vid,
        BAT *fun_iter,
        BAT *fun_item,
        BAT *fun_kind,
        BAT *int_values,
        BAT *dbl_values,
        BAT *dec_values,
        BAT *str_values)
{
    BATiter fun_itemi = bat_iterator(fun_item), fun_kindi = bat_iterator(fun_kind);
    int ret = -1;
    buffer *b = NULL;
    stream *bs = NULL;
    /* Hold the temp BATs after the RPC response has been shredded: */
    /* Might be NULL if the oid tail of a fun_* BAT is dense */
    oid *fvid_lst = NULL, *fiter_lst = NULL, *fitem_lst = NULL;
    oid fvid_seqbase = 0, fiter_seqbase = 0, fitem_seqbase = 0;
    int *fkind_lst = NULL;
    lng *intVals = NULL;
    dbl *dblVals = NULL;
    oid cnt = oid_nil;
    /* BATs hold item|kind of a node parameter */
    BAT *node_item = NULL, *node_kind = NULL;

    (void) genType;

    lng i, a, arg_offset = 0;
    lng my_argc = 0, my_iter = 0;
    lng **argcnt = NULL; /* #items each [iter][param] contains */

    /* BATs needed for serializing attributes */
    BAT *attr_qn = NULL, *attr_prop = NULL;
    BAT *qn_prefix = NULL, *qn_loc = NULL, *prop_val = NULL;
    BATiter strValsi;

    (void) dec_values;

    /* Start timing Client Serialisation */
    lng time_xrpcClntSeria = GDKusec();

    fvid_lst  = (oid*) Tloc(fun_vid, BUNfirst(fun_vid));
    fiter_lst = (oid*) Tloc(fun_iter, BUNfirst(fun_iter));
    fitem_lst = (oid*) Tloc(fun_item, BUNfirst(fun_item));
    fkind_lst = (int*) Tloc(fun_kind, BUNfirst(fun_kind));
    intVals   = (lng*) Tloc(int_values, BUNfirst(int_values));
    dblVals   = (dbl*) Tloc(dbl_values, BUNfirst(dbl_values));
    strValsi  = bat_iterator(str_values);
    fvid_seqbase = fun_vid->hseqbase;
    fiter_seqbase = fun_iter->hseqbase;
    fitem_seqbase = fun_item->hseqbase;
    
    /* Create buffer for the RPC request message */
    if((b = buffer_create(MAX_BUF_SIZE)) && b->len > 0) {
        if (!(bs = buffer_wastream(b, "xrpcrequest"))) {
            GDKerror("byvalue_request: failed to create buffer_wastream\n");
            buffer_destroy(b);
            return NULL;
        }
    } else {
        GDKerror("byvalue_request: failed to create outgoing buffer\n");
        if (b)
            buffer_destroy(b);
        return NULL;
    }

    if (!(argcnt = GDKmalloc(iterc * sizeof(lng*)))) {
        GDKerror("byvalue_request: failed to malloc argcnt\n");
        return clean_up(bs, argcnt, iterc);
    }
    for (i = 0; i < iterc; i++) {
        /* we allocate at least _one_ argcnt for each parameter, so that
         * we have a place to note that a function has zero parameter */
        if (!(argcnt[i] = GDKmalloc((arity>0?arity:1) * sizeof(lng)))) {
            GDKerror("byvalue_request: failed to malloc argcnt[" LLFMT "]\n", i);
            return clean_up(bs, argcnt, iterc);
        }
        argcnt[i][0] = 0;
        for (a = 1; a < arity; a++) {
            argcnt[i][a] = 0;
        }
    }

    /* Calculate the number of values contained by every parameter of
     * every iteration. */
    i = a = 0; /* i: iter counter; a: arg counter */
    for (cnt = 0; cnt < BATcount(fun_vid); cnt++){
        i = fiter_lst ? fiter_lst[cnt] : cnt + fiter_seqbase;
        a = fvid_lst ? fvid_lst[cnt] : cnt + fvid_seqbase;
        argcnt[i-1][a]++;
    }

    /* soap env header and xrpc request header */
    ret = mnstr_printf(bs, SOAP_ENVELOPE);
    if (ret < 0) 
        return clean_up(bs, argcnt, iterc);

    if(qid && *qid) { /* an XRPC query that requires 2PC */
        ret = mnstr_printf(bs, "<env:Header>" XRPC_WS_QID "</env:Header>" , qid, timeout, rpc_mode);
        if (ret < 0) 
            return clean_up(bs, argcnt, iterc);
    }

    if(firstCaller) {
        ret = mnstr_printf(bs, XRPC_REQ_BODY_FIRST_CALLER,
                rpc_module, rpc_uri, rpc_method, arity, iterc,
                updCall?"true":"false");
    } else {
        ret = mnstr_printf(bs, XRPC_REQ_BODY, rpc_module, rpc_uri,
                rpc_method, arity, iterc, updCall?"true":"false",
                xrpc_hostport, seqnr);
    }
    if (ret < 0) 
        return clean_up(bs, argcnt, iterc);

    for (my_iter = 0; my_iter < iterc; my_iter++) {
        if (arity == 0) {
            ret = mnstr_write(bs, "<xrpc:call/>", 1, 12);
            if (ret != 12) return clean_up(bs, argcnt, iterc);
            continue;
        }

        ret = mnstr_write(bs, "<xrpc:call>", 1, 11); /* start an iteration */
        if (ret != 11) return clean_up(bs, argcnt, iterc);
        for (my_argc = 0; my_argc < arity; my_argc++) {
            if (argcnt[my_iter][my_argc] == 0) {
                ret = mnstr_write(bs, "<xrpc:sequence/>", 1, 16);
                if (ret != 16) return clean_up(bs, argcnt, iterc);
                continue;
            }
            arg_offset = 0;
            /* add the 'argcnt' of all arg-s before 'me': */
            for (a = 0; a < my_argc; a++) {
                for (i = 0; i < iterc; i++)
                    arg_offset += argcnt[i][a];
            }
            /* add the 'argcnt' of iter-s before 'me': */
            for (i = 0; i < my_iter; i++) {
                arg_offset += argcnt[i][my_argc];
            }
            /* now 'arg_offset' contains the start position of the
             * values of my_iter and my_argc in the fun_* BATs */

            ret = mnstr_write(bs, "<xrpc:sequence>", 1, 15); /* start a parameter */
            if (ret != 15) return clean_up(bs, argcnt, iterc);
            int k;
            chr elem_kind = 0;
            oid item = 0;
            int cmbn_cont_kind = 0, cur_kind = 0, contID = 0;
            for (k= 0; k < argcnt[my_iter][my_argc]; k++) {

                a = arg_offset + k; /* index into fun_item|fun_kind */
                item = fitem_lst ? fitem_lst[a] : a + fitem_seqbase;
                cmbn_cont_kind = fkind_lst[a];
                cur_kind = XTRACT_KIND(cmbn_cont_kind);
                contID = XTRACT_CONT(cmbn_cont_kind);

                switch (cur_kind) {
                    case BOOL:
                        ret = mnstr_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:boolean\">%s</xrpc:atomic-value>",
                                intVals[item] == TRUE ? "true" : "false");
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case INT:
                        ret = mnstr_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:integer\">%lld</xrpc:atomic-value>",
                                intVals[item]);
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case DEC:
                        ret = mnstr_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:decimal\">%f</xrpc:atomic-value>",
                                dblVals[item]);
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case DBL:
                        ret = mnstr_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:double\">%f</xrpc:atomic-value>",
                                dblVals[item]);
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case STR:
                    case U_A:
                        ret = mnstr_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:string\">%s</xrpc:atomic-value>",
                                (char*)BUNtail(strValsi, item));
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    case ATTR:
                    {
                        contID = XTRACT_CONT(cmbn_cont_kind);

                        attr_qn   = getBatFromContainer(ws, ATTR_QN, contID);
                        attr_prop = getBatFromContainer(ws, ATTR_PROP, contID);
                        prop_val  = getBatFromContainer(ws, PROP_VAL, contID);
                        qn_prefix = getBatFromContainer(ws, QN_PREFIX, contID);
                        qn_loc    = getBatFromContainer(ws, QN_LOC, contID);
                        if( (!attr_qn) || (!attr_prop) || (!prop_val) ||
                            (!qn_prefix) || (!qn_loc) ){
                            return clean_up(bs, argcnt, iterc);
                        }

                        BATiter attr_qni = bat_iterator(attr_qn);
                        BATiter qn_prefixi = bat_iterator(qn_prefix);
                        BATiter qn_loci = bat_iterator(qn_loc);
                        BATiter attr_propi = bat_iterator(attr_prop);
                        BATiter prop_vali = bat_iterator(prop_val);
                        
                        i = *(oid*)BUNtail(fun_itemi, a);
                        a = *(oid*)BUNtail(attr_qni, i);
                        char *prefix = (char*)BUNtail(qn_prefixi, a);
                        char *loc    = (char*)BUNtail(qn_loci,    a);
                        a = *(oid*)BUNtail(attr_propi, i);
                        char *attr_val = (char*)BUNtail(prop_vali, a);

                        ret = mnstr_write(bs, "<xrpc:attribute ", 1, 16);
                        if (ret != 16) return clean_up(bs, argcnt, iterc);
                        if (prefix && *prefix){
                            ret = mnstr_printf(bs, "%s:", prefix);
                            if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        }
                        ret = mnstr_printf(bs, "%s=\"%s\"/>", loc, attr_val);
                        if (ret <= 0) return clean_up(bs, argcnt, iterc);
                        break;
                    }
                    case ELEM:
                    {
                        contID = XTRACT_CONT(cmbn_cont_kind);
                        elem_kind = getELEMkind(ws, contID, item);
                        if (elem_kind == GDK_chr_min) {
                            return clean_up(bs, argcnt, iterc);
                        }
                        switch(elem_kind) {
                            case 0: ret = mnstr_write(bs, "<xrpc:element>", 1, 14);
                                    if (ret != 14) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 1: ret = mnstr_write(bs, "<xrpc:text>", 1, 11);
                                    if (ret != 11) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 2: ret = mnstr_write(bs, "<xrpc:comment>", 1, 14);
                                    if (ret != 14) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 3: ret = mnstr_write(bs, "<xrpc:processing-instruction>", 1, 29);
                                    if (ret != 29) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 4: ret = mnstr_write(bs, "<xrpc:document>", 1, 15);
                                    if (ret != 15) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 5: /* COLLECTION: nothing to be done, here */   break;
                            default:
                                GDKerror("byvalue_request: call%d/sequence%d/item%d has "
                                        "invalid type %d\n", my_iter, my_argc, i);
                                return clean_up(bs, argcnt, iterc);
                        }
                        /* print body of the node */
                        node_item = BUNins( BATnew(TYPE_void, TYPE_oid, 1),
                                            BUNhead(fun_itemi, a),
                                            BUNtail(fun_itemi, a), FALSE );
                        node_kind = BUNins( BATnew(TYPE_void, TYPE_int, 1),
                                            BUNhead(fun_kindi, a),
                                            BUNtail(fun_kindi, a), FALSE );
                        xquery_print_result_driver( bs, "xml-noheader-noroot",
                                NULL, NULL, ws, 1,
                                node_item, node_item, node_item, node_kind,
                                int_values, dbl_values, str_values,
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

                        if(BBPreclaim(node_item) == -1){
                            GDKerror("byvalue_request: failed to destroy BAT \"node_item\", "
                                    "because it is in use by other process!");
                            GDKerror("THIS SHOULD NEVER HAPPEN!!!");
                            return clean_up(bs, argcnt, iterc);
                        }

                        if(BBPreclaim(node_kind) == -1){
                            GDKerror("byvalue_request: failed to destroy BAT \"node_item\", "
                                    "because it is in use by other process!");
                            GDKerror("THIS SHOULD NEVER HAPPEN!!!");
                            return clean_up(bs, argcnt, iterc);
                        }

                        switch(elem_kind) {
                            case 0: ret = mnstr_write(bs, "</xrpc:element>", 1, 15);
                                    if (ret != 15) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 1: ret = mnstr_write(bs, "</xrpc:text>", 1, 12);
                                    if (ret != 12) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 2: ret = mnstr_write(bs, "</xrpc:comment>", 1, 15);
                                    if (ret != 15) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 3: ret = mnstr_write(bs, "</xrpc:processing-instruction>", 1, 30);
                                    if (ret != 30) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 4: ret = mnstr_write(bs, "</xrpc:document>", 1, 16);
                                    if (ret != 16) return clean_up(bs, argcnt, iterc);
                                    break;
                            case 5: /* COLLECTION: nothing to be done, here */    break;
                            default:
                                GDKerror("byvalue_request: should have never reached here!");
                                return clean_up(bs, argcnt, iterc);
                        }
                    }   break;
                    default:
                        GDKerror("byvalue_request: call%d/sequence%d/item%d has invalid type %d\n",
                                my_iter, my_argc, i);
                        return clean_up(bs, argcnt, iterc);
                }
            }
            ret = mnstr_write(bs, "</xrpc:sequence>", 1, 16);
            if (ret != 16) return clean_up(bs, argcnt, iterc);
        }
        ret = mnstr_write(bs, "</xrpc:call>", 1, 12);
        if (ret != 12) return clean_up(bs, argcnt, iterc);
    }
    ret = mnstr_write(bs, "</xrpc:request></env:Body></env:Envelope>\n", 1, 42);
    if (ret != 42) return clean_up(bs, argcnt, iterc);
    /* Stop timing Client Serialisation */
    time_xrpcClntSeria = GDKusec() - time_xrpcClntSeria;
    if (timing) {
        mnstr_printf(GDKout,
                "XRPC_Client_Serialisation (create_req_msg):   " LLFMT " microsec\n",
                time_xrpcClntSeria);
    }

    return mnstr_get_buffer(bs);
}

int
CMDhttp_post(
        BAT **res,
        str genType,
        str rpc_mode,
        str qid,
        str xrpc_hostport,
        bool *firstCaller,
        lng *seqnr,
        lng *timeout,
        str dst,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        bool *updCall,
        lng *arity,
        lng *itercnt,
        BAT *ws,
        BAT *fun_vid,
        BAT *fun_iter,
        BAT *fun_item,
        BAT *fun_kind,
        BAT *int_values,
        BAT *dbl_values,
        BAT *dec_values,
        BAT *str_values)
{
    int port = -1;
    SOCKET sock = INVALID_SOCKET;
    stream *in = NULL, *out = NULL;
    buffer *req = NULL;
    size_t bytes_sent = 0;
    BAT *shredBAT = NULL;
    bool timing = (genType && strstr(genType, "timing")) ? TRUE : FALSE;

    ERRORcheck((*itercnt) < 0, "CMDhttp_post: itercnt must not be negative (<0).\n");
    ERRORcheck((*arity) < 0, "CMDhttp_post: arity must not be negative (<0).\n");
    ERRORcheck(!BAThdense(ws), "CMDhttp_post: head of 'ws' must be dense.\n");
    ERRORcheck(!BAThdense(fun_vid), "CMDhttp_post: head of 'fun_vid' must be dense.\n");
    ERRORcheck(!BAThdense(fun_iter), "CMDhttp_post: head of 'fun_iter' must be dense.\n");
    ERRORcheck(!BAThdense(fun_item), "CMDhttp_post: head of 'fun_item' must be dense.\n");
    ERRORcheck(!BAThdense(fun_kind), "CMDhttp_post: head of 'fun_kind' must be dense.\n");
    ERRORcheck(!BAThdense(int_values), "CMDhttp_post: head of 'int_values' must be dense.\n");
    ERRORcheck(!BAThdense(dbl_values), "CMDhttp_post: head of 'dbl_values' must be dense.\n");
    ERRORcheck(!BAThdense(dec_values), "CMDhttp_post: head of 'dec_values' must be dense.\n");
    ERRORcheck(!BAThdense(str_values), "CMDhttp_post: head of 'str_values' must be dense.\n");

    if ((sock = setup_connection(dst, &port)) < 0)
        return GDK_FAIL;
    if (!(out = socket_wastream(sock, "http_send"))) {
        GDKerror("do_simple_query: failed to create socket_wastream for sending XRPC request\n");
        closesocket(sock);
        return GDK_FAIL;
    }

    if(!(req = byvalue_request(timing, genType, rpc_mode, qid, xrpc_hostport, *firstCaller, *seqnr, *timeout, rpc_module, rpc_uri, rpc_method,
                    *updCall, *arity, *itercnt, ws, fun_vid, fun_iter,
                    fun_item, fun_kind, int_values, dbl_values,
                    dec_values, str_values))){
        mnstr_close(out); mnstr_destroy(out);
        return GDK_FAIL;
    }
    req->buf[req->pos] = '\0';

    /* Start timing Network Send Client2Server */
    lng time_xrpcClnt2Serv = GDKusec();
    bytes_sent = mnstr_printf(out,
            "POST %s HTTP/1.1\r\n"
            "Host: %s:%d\r\n"
            "Accept: text/html, text/xml, application/soap+xml\r\n"
            "Accept-Language: en-uk en-us\r\n"
            "Content-Type: text/html; charset=\"utf-8\"\r\n"
            "Content-Length: " SZFMT "\r\n\r\n"
            "%s",
            XRPC_REQ_CALLBACK, dst, port, req->pos, req->buf);
    if (bytes_sent < req->pos) {
        GDKerror("do_simple_query: failed to send XRPC request.");
        mnstr_close(out); mnstr_destroy(out);
        buffer_destroy(req);
        closesocket(sock);
        return GDK_FAIL;
    }
    /* Stop timing Network Send Client2Server */
    time_xrpcClnt2Serv= GDKusec() - time_xrpcClnt2Serv;
    if (timing) {
        mnstr_printf(GDKout,
                "XRPC_Network_Client_2_Server:  " LLFMT " microsec\n"
                "XRPC_Data_Sent:                " SZFMT " bytes\n\n",
                time_xrpcClnt2Serv,
                bytes_sent);
    }

    if( !(in = socket_rastream(sock, "http_receive")) ){
        GDKerror("do_simple_query: failed to create socket_rastream\n");
        return GDK_FAIL;
    }
    shredBAT = response2bat(timing, in, dst, port, *updCall);

    mnstr_close(out); mnstr_destroy(out);
    mnstr_close(in); mnstr_destroy(in);
    buffer_destroy(req);

    if(!shredBAT) return GDK_FAIL;
    *res = shredBAT;
    return GDK_SUCCEED;
}



/* send a WSAT request */
static int
xrpc_2pc_send(SOCKET sock, char* dst, int port, str msg) { 
    stream *out = NULL;
    
    if (!(out = socket_wastream(sock, "http_send"))) {
        GDKerror("xrpc_2pc_commit: failed to create socket_wastream for sending XRPC request\n");
        return GDK_FAIL;
    }
    if (mnstr_printf(out,
            "POST %s HTTP/1.1\r\n"
            "Host: %s:%d\r\n"
            "Accept: text/html, text/xml, application/soap+xml\r\n"
            "Accept-Language: en-uk en-us\r\n"
            "Content-Type: text/html; charset=\"utf-8\"\r\n"
            "Content-Length: " SZFMT "\r\n\r\n"
            XRPC_WSAT_CALLBACK, dst, port, strlen(msg), msg) < 0) 
    {
        GDKerror("xrpc_2pc_commit: failed to send XRPC request header.");
        return GDK_FAIL;
    }
    if (mnstr_write(out, msg, 1, strlen(msg)) < 0) {
        GDKerror("xrpc_2pc_commit: failed to send XRPC request.");
        return GDK_FAIL;
    }
    mnstr_close(out);
    mnstr_destroy(out);
    return GDK_SUCCEED;
}

/* get a WSAT response */
static int
xrpc_2pc_recv(SOCKET sock, char* dst, int port, str msg) { 
    stream *in = NULL;
    BAT* shredBAT;
    int ret = GDK_FAIL;

    if( !(in = socket_rastream(sock, "http_receive")) ){
        GDKerror("do_simple_query: failed to create socket_rastream\n");
        return GDK_FAIL;
    }
    shredBAT = response2bat(0, in, dst, port, 0);
    if (shredBAT) {
        BATiter si = bat_iterator(shredBAT);
        BAT *qn_uri_loc = BATdescriptor(*(bat*) BUNtail(si, QN_URI_LOC));
        if (qn_uri_loc) {
            if (BUNfnd(qn_uri_loc, msg)) ret = GDK_SUCCEED;
            BBPunfix(qn_uri_loc->batCacheid);
        }
    }
    BBPreclaim(shredBAT);
    mnstr_close(in);
    mnstr_destroy(in);
    return ret;
}
    
int
CMDxrpc_2pc_commit(str qid, str mode, lng* xrpc_timeout, lng* time_start, BAT* participants) {
    int i, j, ret=GDK_FAIL, cnt=0, npart = BATcount(participants);
    str *part = (str*) alloca(npart*sizeof(npart));
    int *port = (int*) alloca(npart*sizeof(int));
    SOCKET *sock = (SOCKET*) alloca(npart*sizeof(SOCKET)), xrpc_updating;
    char dst[1024], msg[1024], *r; 
    BATiter pi = bat_iterator(participants);
    BUN p,q;
  
    /* get all URIs of peers that performed updates */ 
    BATloop(participants, p, q) {
        str s = (str) BUNtail(pi, p); 
        if (sscanf(s, "%[^','],%[^','],%[^','],%s,%d", 
                   msg, dst, msg, msg, &xrpc_updating) != 5 
            || (r=strrchr(dst,':')) == NULL) 
        {
            GDKerror("draw_queryflow: sscanf failed");
            goto cleanup;
        }
        if (xrpc_updating == 1) { /* a request that did updates */
            *r = 0;
            for(i=0; i<cnt; i++) 
                if (strcmp(part[i],dst) == 0) break;

            if (i == cnt) { /* not already in the list? */
                char* p = strchr(part[i] = GDKstrdup(dst), ':');
                port[i] = 80;
                if (p) { *p = 0; port[i] = atoi(p+1); }
                if ((sock[i] = setup_connection(part[i], port+i)) < 0) goto cleanup;
                cnt++;
            }
        }
    }

    /* create Prepare and Commit SOAP messages */
    snprintf(msg, 1024, XRPC_WSAT_REQ, mode, qid, *xrpc_timeout - (GDKusec() - *time_start), "Prepare");
    for(i=0; i<cnt; i++) 
       if (xrpc_2pc_send(sock[i], part[i], port[i], msg) == GDK_FAIL) break;
    for(j=0; j<i; j++) 
       if (xrpc_2pc_recv(sock[j], part[j], port[j], WSAT_NS"|Prepared") == GDK_FAIL) break;

    if (j == cnt) ret = GDK_SUCCEED;
    snprintf(msg, 1024, XRPC_WSAT_REQ, mode, qid, *xrpc_timeout - (GDKusec() - *time_start), (ret == GDK_SUCCEED) ? "Commit" : "Abort");
    for(j=0; j<cnt; j++) 
       if (xrpc_2pc_send(sock[j], part[j], port[j], msg) == GDK_FAIL) ret = GDK_FAIL;
    for(i=0; i<j; i++) 
       if (xrpc_2pc_recv(sock[i], part[i], port[i], WSAT_NS"|Committed") == GDK_FAIL) ret = GDK_FAIL;
cleanup:
    for(i=0; i<cnt; i++) {
        if (part[i]) GDKfree(part[i]);
        if (sock[i] != INVALID_SOCKET) closesocket(sock[i]);
    }
    return ret;
}
/* vim:set shiftwidth=4 expandtab: */
