@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2008 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'

@f serialize_null
@a Jan Flokstra
@a Jan Rittinger
@t serialize_null

@h

#ifndef SERIALIZE_NULL_H
#define SERIALIZE_NULL_H

#include "serialize.h"

bool null_init (XqueryCtx *ctx, char *args, char *restag, char *resprefix, char *module, char *method);
bool null_cleanup (XqueryCtx *ctx);
bool null_startSerialize (XqueryCtx *ctx);
bool null_endSerialize (XqueryCtx *ctx);
bool null_handle_startDocument (XqueryCtx* ctx, oid pre);
bool null_handle_endDocument (XqueryCtx* ctx);
bool null_handle_startElement (XqueryCtx* ctx, str prefix, str name, oid pre);
bool null_handle_endElement (XqueryCtx* ctx, str prefix, str name);
bool null_handle_characters (XqueryCtx* ctx, str chars);
bool null_handle_ignorableWhitespace (XqueryCtx* ctx, str chars);
bool null_handle_comment (XqueryCtx* ctx, str comm);
bool null_handle_processingInstruction (XqueryCtx* ctx, str target, str data);
bool null_complete_startElement (XqueryCtx* ctx);
bool null_complete_startElementEmpty (XqueryCtx* ctx);
bool null_handle_attribute (XqueryCtx* ctx, str prefix, str loc, str value);
bool null_seqEmitBool (XqueryCtx* ctx, int bv);
bool null_seqEmitInt (XqueryCtx* ctx, lng iv);
bool null_seqEmitDbl (XqueryCtx* ctx, dbl dv);
bool null_seqEmitStr (XqueryCtx* ctx, str sv);
bool null_seqStart (XqueryCtx* ctx, int count);
bool null_complete_seqStart (XqueryCtx* ctx);
bool null_seqEnd (XqueryCtx* ctx);
bool null_seqItemStart (XqueryCtx* ctx, int kind);
bool null_seqItemEnd (XqueryCtx* ctx, int kind);
bool null_seqItemSeparator (XqueryCtx* ctx, int kind1, int kind2);

#endif /* SERIALIZE_NULL_H */

@c

#include "pf_config.h"
#include "serialize_null.h"

/*******************************************
 * serialize_null.c : dummy XML serialization functions
 * These callbacks will be used whenever no output is needed.
 */

/**
 * NULL driver initialization function
 */
bool
null_init (XqueryCtx *ctx, char *args, char *restag, char *resprefix, char *module, char *method)
{
    (void) ctx;
    (void) args;
    (void) restag;
    (void) resprefix;
    (void) module;
    (void) method;

    ctx->driverWs = NULL; /* driverWs not used */
    return SUCCESS;
}

/**
 * NULL driver cleanup function
 */
bool
null_cleanup (XqueryCtx *ctx)
{
    (void) ctx;
    return SUCCESS;
}

/**
 * NULL driver start serialize function
 */
bool null_startSerialize (XqueryCtx *ctx)
{
    (void) ctx;
    return SUCCESS;
}

/**
 * NULL driver end serialize function
 */
bool null_endSerialize (XqueryCtx *ctx)
{
    (void) ctx;
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
bool
null_handle_startDocument (XqueryCtx* ctx, oid pre)
{
    (void) ctx;
    (void) pre;
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
bool
null_handle_endDocument (XqueryCtx* ctx)
{
    (void)ctx;
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
bool
null_handle_startElement (XqueryCtx* ctx, str prefix, str name, oid pre)
{
    (void) ctx;
    (void) prefix;
    (void) name;
    (void) pre; /* the Pathfinder PRE number is not used by this fun */
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
bool
null_handle_endElement (XqueryCtx* ctx, str prefix, str name)
{
    (void) ctx;
    (void) prefix;
    (void) name;
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
bool
null_handle_characters (XqueryCtx* ctx, str chars)
{
    (void) ctx;
    (void) chars;
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
bool
null_handle_ignorableWhitespace (XqueryCtx* ctx, str chars)
{
    (void) ctx;
    (void) chars;
    return SUCCESS;
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
bool
null_handle_comment (XqueryCtx* ctx, str comm)
{
    (void) ctx;
    (void) comm;
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX
 * processingInstruction() event.
 */
bool
null_handle_processingInstruction (XqueryCtx* ctx, str target, str data)
{
    (void) ctx;
    (void) target;
    (void) data;
    return SUCCESS;
}

/**
 * handler to complete the startElement printing in xml mode: '>'
 */
bool
null_complete_startElement (XqueryCtx* ctx)
{
    (void) ctx;
    return SUCCESS;
}

/**
 * handler to complete the empty startElement printing in xml mode: '/>'
 */
bool
null_complete_startElementEmpty (XqueryCtx* ctx)
{
    (void) ctx;
    return SUCCESS;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
bool
null_handle_attribute (XqueryCtx* ctx, str prefix, str loc, str value)
{
    (void) ctx;
    (void) prefix;
    (void) loc;
    (void) value;
    return SUCCESS;
}

/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
bool
null_seqEmitBool (XqueryCtx* ctx, int bv)
{
    (void) ctx;
    (void) bv;
    return SUCCESS;
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
bool
null_seqEmitInt (XqueryCtx* ctx, lng iv)
{
    (void) ctx;
    (void) iv;
    return SUCCESS;
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
bool
null_seqEmitDbl (XqueryCtx* ctx, dbl dv)
{
    (void) ctx;
    (void) dv;
    return SUCCESS;
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
bool
null_seqEmitStr (XqueryCtx* ctx, str sv)
{
    (void) ctx;
    (void) sv;
    return SUCCESS;
}

/**
 * 'Start of item sequence' callback.
 */
bool
null_seqStart (XqueryCtx* ctx, int count)
{
    (void) ctx;
    (void) count;
    return SUCCESS;
}

/**
 * 'Start of item sequence completion' callback.
 * (Similar to the completeElement callback this callback is
 *  used to complete a start element '>')
 */
bool
null_complete_seqStart (XqueryCtx* ctx)
{
    (void) ctx;
    return SUCCESS;
}

/**
 * 'End of item sequence' callback.
 */
bool
null_seqEnd (XqueryCtx* ctx)
{
    (void) ctx;
    return SUCCESS;
}

/**
 * 'Start of item' callback.
 */
bool
null_seqItemStart (XqueryCtx* ctx, int kind)
{
    (void) ctx;
    (void) kind;
    return SUCCESS;
}

/**
 * 'End of item' callback.
 */
bool
null_seqItemEnd (XqueryCtx* ctx, int kind)
{
    (void) ctx;
    (void) kind;
    return SUCCESS;
}

/**
 * 'Item separator' callback.
 */
bool
null_seqItemSeparator (XqueryCtx* ctx, int kind1, int kind2)
{
    (void) ctx;
    (void) kind1;
    (void) kind2;
    return SUCCESS;
}

/**
 *
 * Definition of the structure containing the functions
 *
 */
struct serializeFunStruct nullSerializeFun = {
    "null",
    null_init,
    null_cleanup,

    null_startSerialize,
    null_endSerialize,

    null_handle_startDocument,
    null_handle_endDocument,
    null_handle_startElement,
    null_handle_endElement,
    null_handle_characters,
    null_handle_ignorableWhitespace,
    null_handle_comment,
    null_handle_processingInstruction,

    null_complete_startElement,
    null_complete_startElementEmpty,
    null_handle_attribute,

    null_seqEmitBool,
    null_seqEmitInt,
    null_seqEmitDbl,
    null_seqEmitStr,
    null_handle_attribute,
    null_handle_characters,

    null_seqStart,
    null_complete_seqStart,
    null_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    null_seqItemSeparator
};
