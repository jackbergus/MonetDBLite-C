@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'
@' $Id$
@'

@f pf_soap
@a Ying Zhang

@t MIL primitives to support SOAP RPC using HTTP connection

@* Introduction
This module provides new MIL primitives to support remote XQuery execution
using HTTP connection on top of MonetDB within the "Pathfinder" project.
@
@* Module Definition
@m
.MODULE pf_soap;

.USE pathfinder;
.USE pf_support;
.USE url;

@- HTTP server function(s)
@m
.COMMAND httpd_start(int port) : void = CMDhttpd_start;
"Start the HTTP server for SOAP RPC calls on the specified port."

@- HTTP client function(s)
@m
.COMMAND http_post(
        str location,
        str soap_module,
        str method,
        BAT[void, bat] ws,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[oid, bat] = CMDhttp_post;
"Create and send a SOAP RPC message to the specified destination"

.PRELUDE = pf_soap_prelude;
.EPILOGUE = pf_soap_epilogue;

.END pf_soap;

@mil
PROC soap_receiver_start(int port) : void {
    fork(httpd_start(port));
}
ADDHELP("soap_receiver_start", "zhang", "November 2005",
"DESCRIPTION:\n\
Start receiver for SOAP RPC calls on the specified port",
"pf_soap");

PROC soap_receiver_start() : void {
    soap_receiver_start( int(monet_environment.find("pf_httpd_port")) );
}
ADDHELP("soap_receiver_start", "zhang", "November 2005",
"DESCRIPTION:\n\
Start receiver for SOAP RPC calls on the default port 8080",
"pf_soap");

PROC send_soap_rpc(
        str local_name,
        str location,
        str soap_module,
        str method,
        BAT[void, bat] ws,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : oid {

    var soapres := http_post(location, soap_module, method, ws, 
            fun_vid,    fun_iter,   fun_item,   fun_kind,
            int_values, dbl_values, dec_values, str_values);

    var docBAT := bat(str,bat,WS_SIZE);
    var height := index_doc(soapres,docBAT);
    return add_docbat(ws, docBAT, local_name, "", height);
}
ADDHELP("send_soap_rpc", "zhang", "November 2005",
"DESCRIPTION:\n\
Send a SOAP RPC request via HTTP to the destination \"location\", save the reults in the WorkingSet and return the fragment-id of the new added document",
"pf_soap");

@h
#ifndef PF_SOAP_H
#define PF_SOAP_H

#include "pathfinder.h"

/* BAT related functions */
#include <gdk.h>
/* escape_url() */
#include <url.h>
/* stream functions */
#include <stream.h>
#include <time.h>

#ifdef _WIN32   /* Windows specific */
    #include <winsock.h>
    #define snprintf _snprintf
    #ifndef __MINGW32__
        #pragma comment(lib, "ws2_32")
    #endif
#else           /* UNIX specific */
    #include <sys/select.h>
    #include <sys/types.h>	/* used by socket */
    #include <sys/socket.h>
    #include <unistd.h>
    #include <netinet/in.h> /* hton and ntoh */
    #include <arpa/inet.h>  /* dotted IP addr to and from 32-bits int */
    #include <netdb.h>		/* convert domain names into IP addr */
    #include <errno.h>
    #include <ctype.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h> /* Functions to handle variable argument lists */

/* CMDshred2bats() and xquery_print_result_main() */
#include "pf_support.proto.h"
#include "shttpd.h"

#define MXQ_SIGNATURE "signature\01http://monetdb.cwi.nl/xquery/soap"
#define MXQ_TYPE "type\01http://monetdb.cwi.nl/xquery/soap"
#define MXQ_PARAM_TYPE "type"

#define TEXT        1
#define ELEMENT     0
#define MAXPARAMS   32
#define HTTP_PORT   8080
#define HTTPD_FUNC  "/soap_rpc"

/* Used by the http_post client */
#define MIN_RESPONSE_SIZE 19
#define MAX_BUF_SIZE 1024*1024 /* MUST be the same as 'IO_MAX' in shttpd.c */
#define MAX_POST_HEADER_SIZE 1024
#define NR_RETRIES 3 /* #retries to connect to the SOAP receiver */

#define str2buf(b, str)             \
    { b->pos += snprintf((b->buf + b->pos), (b->len - b->pos), str); }

#define value2buf(b, len, strptr, fun_item, off, i, v_type, v_cont, begin_tag, end_tag) \
    {                                                                                   \
    str2buf(b, begin_tag);                                                              \
    len = b->len - b->pos;                                                              \
    strptr = b->buf + b->pos;                                                           \
    i = *(int*)BUNtail(fun_item, BUNptr(fun_item, off));                                \
    b->pos += BATatoms[v_type].atomToStr(&strptr, &len, BUNptr(v_cont, i));             \
    str2buf(b, end_tag);                                                                \
    }

#define cleanup(obj, bit)           \
    if (obj) {                      \
        stream_close(obj);          \
        stream_destroy(obj);        \
        if (bit == 1) sock = -1;    \
    }

#define myfree(ary, i, max)         \
    if (ary) {                      \
        for(i = 0; i < max; i++)    \
            GDKfree(ary[i]);        \
        GDKfree(ary);               \
    }

/* To prevent start the HTTP server twice */
int soap_running = 0;

#endif /* PF_SOAP_H */

@c
#include "pf_soap.h"

/* Create a HTTP client socket.
 * Returns the socket if succeeded, -1 otherwise.
 */
static int setup_connection(str location, int port, int nr_retries) {
    int i, ret, sock;
    in_addr_t addr;
    struct sockaddr_in sockaddr;
    struct hostent *resolv = NULL;

    errno = 0;
    if (isdigit((int)location[0])) {
        if ((i = inet_addr(location)) < 0) {
            GDKerror("setup_connection: invalid IP address \"%s\": %s\n",
                     location, errno ? strerror(errno) : "");
            return -1;
        }
        addr = (in_addr_t) i;
    } else {
        if (!(resolv = gethostbyname(location))) {
            GDKerror("setup_connection: invalid location \"%s\": %s\n",
                     location, errno ? strerror(errno) : "");
            return -1;
        }
        addr = ((struct in_addr *)resolv->h_addr_list[0])->s_addr;
    }

    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port   = htons(port);
    sockaddr.sin_addr.s_addr = addr;
    memset(&(sockaddr.sin_zero), '\0', 8);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        GDKerror("setup_connection: failed to create socket\n");
        return -1;
    }

    ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    for (i = 0; i < nr_retries && ret < 0; i++) {
        sleep(1);
        ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    }
       
    if (ret < 0) {
        GDKerror("setup_connection: failed to setup connection\n");
        close(sock);
        return -1;
    }
    return sock;
}

/* Used by the SOAP receiver to send a SOAP Fault message to the SOAP
 * sender
 */
static void send_soap_err(stream *out, bit p_body, char* http_err, char *soapcodev, char *errstr){
    if (p_body) {
        stream_printf(out, "HTTP/1.1 %s\r\n"
                "Content-Type: application/soap+xml; charset=\"utf-8\"\r\n\r\n"
                "<?xml version='1.0' ?>\n"
                "<env:Envelope\n"
                "    xmlns:env=\"http://www.w3.org/2003/05/soap-envelope\">\n"
                "  <env:Body>\n",
                http_err);
    }

    stream_printf(out,
            "    <env:Fault>\n"
            "      <env:Code>\n"
            "        <env:Value>\n"
            "          %s\n"
            "        </env:Value>\n"
            "      </env:Code>\n"
            "      <env:Reason>\n"
            "        <env:Text xml:lang=\"en\">\n"
            "          %s\n"
            "        </env:Text>\n"
            "      </env:Reason>\n"
            "    </env:Fault>\n"
            "  </env:Body>\n"
            "</env:Envelope>\n",
            soapcodev, errstr);
}

/* Calculate the number of nodes which has the name "node_name", within
 * the range 'start_pre' and 'end_pre' (incl.). */
static int count_node(BAT *docBAT, char *node_name, int start_pre, int end_pre){
    static int first;   /* Since the values of these variables are always */
    static oid *prop;   /* the same, we use 'static' here to prevent the  */
    static char *kind;  /* values of these variables being retrieved at   */
    static BAT *qn_loc; /* every call to this function */

    int i, nr = 0;
    char *qname;

    assert(start_pre > 0);
   
    first  = BUNindex(docBAT, BUNfirst(docBAT));
    prop   = (oid*) BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+PRE_PROP))));
    kind   = (char*)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+PRE_KIND))));
    qn_loc = BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+QN_LOC)));

    for (i = start_pre; i <= end_pre; i++) {
        if (kind[i] == ELEMENT) {
            qname = BUNtail(qn_loc, BUNfnd(qn_loc, &(prop[i])));
            if (strcmp(qname, node_name) == 0)
                nr++;
        }
    }
    return nr;
}

/* Find the first node between 'start_pre' and 'end_pre' (incl.), which
 * kind is 'ELEMENT'.
 * Return the 'pre' value of this node.
 * Return 0 if such node can not be found. */
static oid get_elem_pre(BAT *docBAT, int start_pre, int end_pre){
    static int first;   /* values of 'first' and 'kind' are stable */
    static char *kind;
    int i;

    assert(start_pre > 0 && end_pre >= start_pre);
   
    first = BUNindex(docBAT, BUNfirst(docBAT));
    kind  = (char*)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+PRE_KIND))));

    for (i = start_pre; i <= end_pre; i++) {
        if (kind[i] == ELEMENT)
            return i;
    }
    return 0;
}

/* Given a node name, find the 'pre' value of the node given within the range
 * 'start_pre' and 'end_pre' (incl.).
 * Return 0 if such node can not be found. */
static oid get_node_pre(BAT *docBAT, char *node_name, int start_pre, int end_pre){
    static int first;   /* Since the values of these variables are always */
    static oid *prop;   /* the same, we use 'static' here to prevent the  */
    static char *kind;  /* values of these variables being retrieved at   */
    static BAT *qn_loc; /* every call to this function */

    int i;
    char *qname;

    assert(start_pre > 0 && end_pre >= start_pre);
   
    first  = BUNindex(docBAT, BUNfirst(docBAT));
    prop   = (oid*) BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+PRE_PROP))));
    kind   = (char*)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+PRE_KIND))));
    qn_loc = BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+QN_LOC)));

    for (i = start_pre; i <= end_pre; i++) {
        if (kind[i] == ELEMENT) {
            qname = BUNtail(qn_loc, BUNfnd(qn_loc, &(prop[i])));
            if (strcmp(qname, node_name) == 0)
                return i;
        }
    }
    return 0;
}

/* Find the value of the attribute 'attrname', which is owned by the
 * node with the given 'pre' value.
 * NB: DO NOT free the string returned by this function!!!
 */
static char* find_attribute(BAT *docBAT, char* attrname, oid pre){
    static size_t nattrs;
    static int first;
    static oid *attr_own, *attr_qn, *attr_prop;
    static BAT *qn_loc, *prop_val;

    oid qn = oid_nil, nid = oid_nil;
    size_t i;
    BUN p;

    first    = BUNindex(docBAT, BUNfirst(docBAT));
    qn_loc   = BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+QN_LOC))   );
    prop_val = BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+PROP_VAL)) );

    attr_own  = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+ATTR_OWN) )));
    attr_qn   = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+ATTR_QN)  )));
    attr_prop = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+ATTR_PROP))));

    /* Find 'attrname' in the tail of 'qn_loc' */
    p = BUNfnd(BATmirror(qn_loc), attrname);
    /* Get the position of 'attrname' in 'qn_loc' */
    if (p) qn = *(oid*) BUNhead(qn_loc, p);
    else return NULL;

    /* Find 'nid' of the 'pre' value */
    /* TODO: currently, pre == nid */
    nid = pre;
    
    /* try to find the attribute value */
    nattrs = BATcount(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+ATTR_PROP))));
    for (i = 0; i < nattrs; i++) {
        if (attr_own[i] > nid) return NULL;
        if (attr_own[i] == nid && attr_qn[i] == qn) {
                first = BUNindex(prop_val, BUNfirst(prop_val)) + attr_prop[i];
                return (char*) BUNtail(prop_val, BUNptr(prop_val, first));
        }
    }
    return NULL;
}

/* Given the pre value of a type node, return the name of the type node as a
 * string in the form "prefix:loc" */
static char* get_type(BAT *docBAT, oid tnode_pre){
    static int first;
    static BAT *qn_loc, *qn_prefix;
    static oid *pre_prop;

    char *prefix, *loc, *res;
    int l, p;
    
    first = BUNindex(docBAT, BUNfirst(docBAT));
    pre_prop = (oid*)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+PRE_PROP))));

    qn_prefix = BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+QN_PREFIX)));
    qn_loc    = BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,first+QN_LOC))   );

    first  = BUNindex(qn_prefix, BUNfirst(qn_prefix)) + tnode_pre;
    prefix = (char*) BUNtail(qn_prefix, BUNptr(qn_prefix, pre_prop[tnode_pre]));
    first  = BUNindex(qn_loc, BUNfirst(qn_loc)) + tnode_pre;
    loc    = (char*) BUNtail(qn_loc, BUNptr(qn_loc, pre_prop[tnode_pre]));

    l = strlen(loc);
    p = strlen(prefix);
    res = GDKmalloc(p + l + 2);
    strncpy(res, prefix, p);
    res[p]=':';
    strncpy((res + p + 1), loc, l);
    res[p+l+1] = '\0';
    return res;
}

static int handle_soap_request(struct shttpd_callback_arg *arg) {
    var_t *text = NULL;     /* typedef oid var_t */
    int i = 0, j = 0, k = 0, off = 0, sock = -1, retval = GDK_FAIL;
    stream *out = NULL;
    char *strptr = NULL, *kind = NULL, *text_base = NULL;
    char *msg = NULL, *module = NULL, *method = NULL;
    char errstr[1024];
    oid *prop = NULL;
    int *size = NULL;
    oid pre = 0, pnode_pre = 0, inode_pre = 0, tnode_pre = 0, vnode_pre = 0;
    BAT *docBAT = NULL;

    int iterc = 0, argc = 0;
    int **argcnt = NULL;    /* #items eash param/iter contains */
    str *argval = NULL;     /* Stores all actual values sequetially. */
    str *argtpe = NULL;     /* XQuery type of each argval */
    int argval_nr = 0;      /* #values arg_val currently contains */
    int argval_size;        /* max #items in "argval", doubled if necessary */

    
    char *level = NULL;
    int l, max_level;
    
    THRnew(MT_getpid(), "soap_handler");

    /* Create our own output stream for further data transfer. */
    sock = shttpd_get_socket(arg);
    if (!(out = socket_wastream(sock, "soap_response"))) {
        GDKerror("handle_soap_request: failed to create socket_wastream for socket %d", sock);
        close(sock);
        return GDK_FAIL;
    }

    /* Retrieve the whole received (SOAP RPC) message, and remove the first
     * line of the request message, so that the messgae we pass to
     * CMDshred2bats starts directly with the SOAP envelope. */
    msg = shttpd_get_msg(arg);
    strptr = msg + strlen("<?xml"); /* skip "<?xml" */
    if ((strstr(msg, "<?xml") != msg) ||
        (strptr = strchr(strptr, (int)'<')) == NULL) {
        send_soap_err(out, 1, "404 Bad Request", "env:Sender",
                "SOAP request: bad XML structure\n");
    }
/*
printf("\n=== DEBUG MSG: SOAP request RECEIVED ======\n%s"
       "=== END DEBUG MSG: SOAP request RECEIVED ===\n\n", strptr);
*/
    if ((CMDshred2bats(&docBAT, "", strptr, "")  == GDK_FAIL)) {
        send_soap_err(out, 1, "404 Bad Request", "env:Sender",
                "SOAP request: bad XML structure, could not shred\n");
        goto FINISH_HANDLE_SOAP_REQUEST;
    }

    off   = BUNindex(docBAT,BUNfirst(docBAT));
    size  = (int *) BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,off+PRE_SIZE))));
    level = (char *)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,off+PRE_LEVEL))));
    prop  = (oid *) BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,off+PRE_PROP))));
    kind  = (char *)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,off+PRE_KIND))));
    text  = (var_t*)BUNfirst(BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT,off+PROP_TEXT))));
    text_base = BBP_cache(*(bat*)BUNtail(docBAT,BUNptr(docBAT, off+PROP_TEXT)))->theap->base;

    /* HACK */
    max_level = level[0];
    for(l = 0; level[l]; l++)
        if(level[l] > max_level) max_level = level[l];
    max_level++;
    /* END HACK */

    /* these are temporary vars, for debugging */
    BAT *pre_size, *pre_level, *pre_prop, *pre_kind;
    pre_size = BBP_cache(*(bat*)BUNtail(docBAT, BUNptr(docBAT, off+PRE_SIZE)));
    pre_level = BBP_cache(*(bat*)BUNtail(docBAT, BUNptr(docBAT, off+PRE_LEVEL)));
    pre_prop = BBP_cache(*(bat*)BUNtail(docBAT, BUNptr(docBAT, off+PRE_PROP)));
    pre_kind = BBP_cache(*(bat*)BUNtail(docBAT, BUNptr(docBAT, off+PRE_KIND)));

    (void)pre_size;
    (void)pre_level;
    (void)pre_prop;
    (void)pre_kind;
    /* END: these are temporary vars, for debugging */
    
    /* There are at least two nodes before "SoapRpcRequest", namely
     * "Envelope" and "Body" (a "Header" node is optional). There are at
     * least two nodes after "SoapRpcRequest", namely "iter" and
     * "param". */
    if (!(pre = get_node_pre(docBAT, "SoapRpcRequest", 2, (size[0] - 2)))) {
        send_soap_err(out, 1, "404 Bad Request", "env:Sender",
                "SOAP request must have a \"SoapRpcRequest\" tag\n");
        goto FINISH_HANDLE_SOAP_REQUEST;
    }
    if ((module = find_attribute(docBAT, "module", pre)) == NULL) {
        send_soap_err(out, 1, "404 Bad Request", "env:Sender",
            "SOAP request: \"SoapRpcRquest\" tag does not have a \"module\" attribute.\n");
        goto FINISH_HANDLE_SOAP_REQUEST;
    }
    if ((method = find_attribute(docBAT, "method", pre)) == NULL) {
        send_soap_err(out, 1, "404 Bad Request", "env:Sender",
            "SOAP request: \"SoapRpcRquest\" tag does not have a \"method\" attribute.\n");
        goto FINISH_HANDLE_SOAP_REQUEST;
    }

    /* Calculate the number of iterations */
    iterc = count_node(docBAT, "iter", (pre+1), size[0]);
    if (iterc == 0) {
        snprintf(errstr, 1024, "SOAP request [%s:%s]: should have at "
                "least one <iter> tag.\n", module, method);
        send_soap_err(out, 1, "404 Bad Request", "env:Sender", errstr);
        goto FINISH_HANDLE_SOAP_REQUEST;
    }
    /* Calculate the number of parameters */
    /* FIXME: we now just assume each iteration contains the same number
     *        of parameters, but this is not checked! */
    argc = count_node(docBAT, "param", (pre + 2), size[0]) / iterc;

    argcnt = GDKmalloc(iterc * sizeof(int *));
    for (i = 0; i < iterc; i++) {
        argcnt[i] = GDKmalloc(argc * sizeof(int));
    }
    argval_size = iterc * MAXPARAMS;
    argval = GDKmalloc(argval_size * sizeof(char *));
    argtpe = GDKmalloc(argval_size * sizeof(char *));
   
    /* Fill the arrays 'argcnt', 'argval', 'argtpe' */
    inode_pre = pre;
    int maxsize = size[0];
    for (i = 0; i < iterc; i++) {
        /* inode_pre = get_node_pre(docBAT, "iter", (inode_pre + 1), size[0]); */
        inode_pre = get_node_pre(docBAT, "iter", (inode_pre + 1), maxsize); 

        pnode_pre = inode_pre;
        for (j = 0; j < argc; j++) {
            /* pnode_pre = get_node_pre(docBAT, "param", (pnode_pre + 1), (inode_pre + size[inode_pre])); */
            pnode_pre = get_node_pre(docBAT, "param", (pnode_pre + 1), maxsize);
       
            tnode_pre = pnode_pre + 1; argcnt[i][j] = 0; k = 1;
            while(tnode_pre < (pnode_pre + size[pnode_pre]) && 
                    (tnode_pre = get_elem_pre(docBAT, tnode_pre, (pnode_pre + size[pnode_pre]))) > 0){
                if (!(size[tnode_pre] > 0)) {
                    snprintf(errstr, 1024, "SOAP request [%s:%s]: "
                            "iteration[%d]->parameter[%d]->value[%d] does not contain value\n",
                            module, method, (i + 1), (j + 1), k);
                    send_soap_err(out, 1, "404 Bad Request", "env:Sender", errstr);
                    goto FINISH_HANDLE_SOAP_REQUEST;
                }

                if (argval_nr == argval_size) {
                    snprintf(errstr, 1024, 
                            "SOAP request [%s:%s]: too many parameters, "
                            "maximum number of parameters is %d.\n",
                            module, method, MAXPARAMS);
                    send_soap_err(out, 1, "404 Bad Request", "env:Sender", errstr);
                    goto FINISH_HANDLE_SOAP_REQUEST;
                }

                if ((argtpe[argval_nr] = get_type(docBAT, tnode_pre)) == NULL) {
                    snprintf(errstr, 1024, "SOAP request [%s:%s]: "
                            "iteration[%d]->parameter[%d]->value[%d] does not have a type tag\n",
                            module, method, (i + 1), (j + 1), k);
                    send_soap_err(out, 1, "404 Bad Request", "env:Sender", errstr);
                    goto FINISH_HANDLE_SOAP_REQUEST;
                }

                vnode_pre = tnode_pre + 1;
                if (strcmp(argtpe[argval_nr], "xs:anyNode") == 0) {
                    vnode_pre = get_elem_pre(docBAT, vnode_pre, (tnode_pre + size[tnode_pre]));
                    argval[argval_nr] = GDKmalloc(32);
                    snprintf(argval[argval_nr], 32, OIDFMT, vnode_pre);
                    
                    /* HACK */
                    /* try to make the tnode a DOCUMENT node */
                    /*
                    kind[tnode_pre] = kind[0];
                    level[tnode_pre] = level[0];
                    prop[tnode_pre] = prop[0];
                    */

                    /*
                    max_level = level[vnode_pre];
                    for(l = vnode_pre; l <= (int)(vnode_pre + size[vnode_pre]); l++) {
                        level[l] -= max_level;
                    }
                    */
                    for(l = 0; l < (int)vnode_pre; l++) size[l] = 0;
                    /* END HACK */
                    
                    tnode_pre += (size[tnode_pre] + 1);
                } else {
                    if (kind[vnode_pre] != TEXT) {
                        snprintf(errstr, 1024, "SOAP request [%s:%s]: "
                                "iteration[%d]->parameter[%d]->value[\"%d\"] "
                                "of type[\"%s\"] is expected to have a simple value.\n",
                                module, method, (i + 1), (j + 1), k, argtpe[argval_nr]);
                        send_soap_err(out, 1, "404 Bad Request", "env:Sender", errstr);
                        goto FINISH_HANDLE_SOAP_REQUEST;
                    }
                    argval[argval_nr] = GDKstrdup(text_base + text[prop[vnode_pre]]);
                    tnode_pre++;
                }
                argcnt[i][j]++;
                argval_nr++;
                k++;
            } /* end WHILE 'tnode_pre' */
        } /* end FOR 'argc' */
    } /* end FOR 'i < iterc' */

    /* write out our response */
    if (stream_printf(out,
                "HTTP/1.1 200 OK\r\n"
                "Content-Type: application/soap+xml; charset=\"utf-8\"\r\n\r\n"
                "<?xml version='1.0' ?>\n"
                "<env:Envelope\n"
                "    xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n"
                "    xmlns:env=\"http://www.w3.org/2003/05/soap-envelope\">\n"
                "<env:Header />\n"
                "<env:Body>\n"
                "<SoapRpcResults \n"
                "    module=\"%s\"\n"
                "    method=\"%s\">\n",
                module, method) >= 0)
    {
        argc += 1000; /* debug */
        char *err = xquery_method(out, module, method, argc, iterc, argcnt, argtpe, argval, docBAT);
        argc %= 1000;

        if (err) {
            snprintf(errstr, 1024, "[%s:%s]: %s", module, method, err);
            send_soap_err(out, 0, "", "env:Sender", errstr);
            goto FINISH_HANDLE_SOAP_REQUEST;
        }
        stream_printf(out, "</SoapRpcResults>\n</env:Body>\n</env:Envelope>\n");
    }
   
    retval = GDK_SUCCEED;
    goto FINISH_HANDLE_SOAP_REQUEST;

FINISH_HANDLE_SOAP_REQUEST:
    cleanup(out,0);
    myfree(argcnt, i, iterc);
    myfree(argtpe, i, argval_nr)
    if (argval) GDKfree(argval);
    return retval;
}

int CMDhttp_post(BAT **res,
                 str location,
                 str module,
                 str method,
                 BAT* ws,
                 BAT* fun_vid,
                 BAT* fun_iter,
                 BAT* fun_item,
                 BAT* fun_kind,
                 BAT* int_values,
                 BAT* dbl_values,
                 BAT* dec_values,
                 BAT* str_values) {

    int i, a, len, ret, sock = -1, port = HTTP_PORT, retval = GDK_FAIL;
    int type = 0; /* param type in C */
    buffer *b = NULL;
    str strptr = NULL;
    stream *in = NULL, *out = NULL, *bs = NULL, *bak = GDKout;
    BAT *docBAT = NULL; /* Hold the temp BATs after the SOAP response has been shredded: */
    BAT *node_item = NULL, *node_kind = NULL; /* BATs hold item|kind of a node parameter */
    BUN p_vid, p_iter, p_item, p_kind; /* Pointers to the current BUNs of the BATs. */
    str str_val = NULL;

    int argc = 0, argc_base = 0, my_argc = 0;
    int iterc = 0, iter_base = 0, my_iter = 0;
    int itemc = 0, arg_offset = 0;
    int **argcnt = NULL;    /* #items eash iter/param contains */
    int argval_nr = 0;      /* #values arg_val currently contains */
    int argval_size = 0;    /* max #items in "argval" */

    if ((strptr = strchr(location, (int)':')) != NULL) {
        strptr[0] = '\0'; strptr++;
        port = atoi(strptr);
    }
    if ((sock = setup_connection(location, port, NR_RETRIES)) < 0) {
        GDKerror("CMDhttp_post: could not setup connection with"
                "%s:%d\n", location, port);
        goto FINISH_HTTP_POST;
    }
    if (!(out = socket_wastream(sock, "http_send"))) {
        GDKerror("CMDhttp_post: failed to create socket_wastream\n");
        goto FINISH_HTTP_POST;
    }
    if (!(in = socket_rastream(sock, "http_receive"))) {
        GDKerror("CMDhttp_post: failed to create socket_rastream\n");
        goto FINISH_HTTP_POST;
    }

    /* Create the SOAP request message */
    b = buffer_create(MAX_BUF_SIZE);
    if (!b || b->len == 0) {
        GDKerror("CMDhttp_post: not enough memory\n");
        goto FINISH_HTTP_POST;
    }

    b->pos = snprintf(b->buf, b->len,
            "<?xml version='1.0' ?>\n"
            "<env:Envelope\n"
            "    xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n"
            "    xmlns:env=\"http://www.w3.org/2003/05/soap-envelope\">\n"
            "<env:Header />\n"
            "<env:Body>\n"
            "<SoapRpcRequest\n"
            "    module=\"%s\"\n"
            "    method=\"%s\">\n",
            module, method);

    /* Find the number of parameters and iterations. */
    argc  = *(int*)BUNtail(fun_vid, BUNprev(fun_vid, BUNlast(fun_vid)) ) - *(int*)BUNtail(fun_vid,BUNfirst(fun_vid)) + 1;
    iterc = *(int*)BUNtail(fun_iter,BUNprev(fun_iter,BUNlast(fun_iter)));

    argcnt = GDKmalloc(iterc * sizeof(int *));
    for (i = 0; i < iterc; i++) {
        /* FIXME: validate malloc result */
        argcnt[i] = GDKmalloc(argc * sizeof(int));
        for (a = 0; a < argc; a++) {
            argcnt[i][a] = 0;
        }
    }
    argval_size = iterc * MAXPARAMS;

    /* Calculate the number of items contained by every parameter of
     * every iteration. */
    i = a = 0; /* i: iter counter; a: arg counter */
    iter_base = *(int*) BUNtail(fun_iter, BUNfirst(fun_iter));
    argc_base = *(int*) BUNtail(fun_vid, BUNfirst(fun_vid));
    for (p_vid  = BUNfirst(fun_vid),  p_iter = BUNfirst(fun_iter),
         p_item = BUNfirst(fun_item), p_kind = BUNfirst(fun_kind);

         p_vid  < BUNlast(fun_vid)  && p_iter < BUNlast(fun_iter) &&
         p_item < BUNlast(fun_item) && p_kind < BUNlast(fun_kind);

         p_vid  = BUNnext(fun_vid, p_vid),
         p_iter = BUNnext(fun_iter, p_iter),
         p_item = BUNnext(fun_item, p_item),
         p_kind = BUNnext(fun_kind, p_kind)) {

        if (argval_nr == argval_size) {
            GDKerror("CMDhttp_post: too many parameters.\n");
            goto FINISH_HTTP_POST;
        }

        i = *(int*) BUNtail(fun_iter, p_iter);
        a = *(int*) BUNtail(fun_vid, p_vid);
        argcnt[i - iter_base][a - argc_base]++;
        argval_nr++;
    }
    argval_size = argval_nr; /* actual number of argval-s */
    argval_nr = 0;

    for (my_iter = 0; my_iter < iterc; my_iter++) {
        /* Enlarge the buffer is it is filled more than 80%.
         * FIXME: is this really necessary? Or should we just return an
         * error?
         */
        if (b->pos > (b->len * 0.8)) {
            b->len *= 2;
            b->buf = realloc(b->buf, b->len);
        }

        str2buf(b, "<iter>\n");

        for (my_argc = 0; my_argc < argc; my_argc++) {
            str2buf(b, "<param>\n");

            arg_offset = 0;
            /* add the 'argcnt' of all arg-s before 'me': */
            for (a = 0; a < my_argc; a++) {
                for (i = 0; i < iterc; i++) {
                    arg_offset += argcnt[i][a];
                }
            }
            /* add the 'argcnt' of iter-s before 'me': */
            for (i = 0; i < my_iter; i++) {
                arg_offset += argcnt[i][my_argc];
            }
            /* now 'arg_offset' contains the index of the values and the
             * types of MY iter and My argc in argval and argtpe */

            for (itemc = 0; itemc < argcnt[my_iter][my_argc]; itemc++) {
                /* index into fun_item|fun_kind */
                a = arg_offset + itemc;
                type = *(int*)BUNtail(fun_kind, BUNptr(fun_kind, a));
                if (type > WS_SIZE) {
                    str2buf(b, "<xs:anyNode>\n");

                    node_item = BUNins(BATnew(TYPE_void, TYPE_oid, 1),
                            BUNhead(fun_item, BUNptr(fun_item, a)),
                            BUNtail(fun_item, BUNptr(fun_item, a)) );
                    node_kind = BUNins(BATnew(TYPE_void, TYPE_int, 1),
                            BUNhead(fun_kind, BUNptr(fun_kind, a)),
                            BUNtail(fun_kind, BUNptr(fun_kind, a)) );
                    if (!(bs = buffer_wastream(b, "shred_node_param"))) {
                        GDKerror("CMDhttp_post: failed to create buffer_wastream"
                                 " to shred node parameter\n");
                        goto FINISH_HTTP_POST;
                    }
                    THRsetdata(0, bs);
                    xquery_print_result_main("xml-noheader-noroot", ws,
                            node_item, node_kind, int_values,
                            dbl_values, dec_values, str_values);
                    THRsetdata(0, bak);

                    str2buf(b, "</xs:anyNode>\n");
                } else if (type == BOOL) {
                    value2buf(b, len, strptr, fun_item, a, i, TYPE_bit, int_values, "<xs:bool>", "</xs:bool>\n");
                } else if (type == INT) {
                    value2buf(b, len, strptr, fun_item, a, i, TYPE_int, int_values, "<xs:integer>", "</xs:integer>\n");
                } else if (type == DEC) {
                    value2buf(b, len, strptr, fun_item, a, i, TYPE_dbl, dbl_values, "<xs:decimal>", "</xs:decimal>\n");
                } else if (type == DBL) {
                    value2buf(b, len, strptr, fun_item, a, i, TYPE_dbl, dbl_values, "<xs:double>", "</xs:double>\n");
                } else if (type == STR || type == U_A) {
                    i = *(int*)BUNtail(fun_item, BUNptr(fun_item, a));
                    str_val = BUNtail(str_values, BUNptr(str_values, i));
                    b->pos += snprintf((b->buf + b->pos), (b->len - b->pos),
                            "<xs:string>\"%s\"</xs:string>\n", str_val);
                } else {
                    GDKerror("CMDhttp_post: iter%d/param%d/item%d  has invalid type %d\n",
                            my_iter, my_argc, i);
                    goto FINISH_HTTP_POST;
                }
            }
            str2buf(b, "</param>\n");
        }
        str2buf(b, "</iter>\n");
    }

    str2buf(b, "</SoapRpcRequest>\n</env:Body>\n</env:Envelope>\n");
    b->buf[b->pos] = 0;
/*
printf("\n=== DEBUG MSG: SOAP request to send: (msglen = %ld) ===\n%s"
       "=== END DEBUG MSG: SOAP request to send ===============\n\n",
        b->pos, b->buf);
*/
    if (stream_printf(out,
            "POST %s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Accept: text/html, text/xml, application/soap+xml\r\n"
            "Accept-Language: en-uk en-us\r\n"
            "Content-Type: text/html; charset=\"utf-8\"\r\n"
            "Content-Length: %d\r\n\r\n"
            "%s",
            HTTPD_FUNC, location, b->pos, b->buf) < (int)b->pos) {
        GDKerror("CMDhttp_post: failed to send SOAP RPC request.");
        goto FINISH_HTTP_POST;
    }


    /*** Receive all response data ***/
    b->pos = b->buf[0] = 0;
    do{
        ret = stream_read(in, (b->buf + b->pos), 1, (b->len - b->pos));
        b->pos += ret;
        if (b->pos > (b->len * 0.8)) {
            b->len *= 2;
            b->buf = realloc(b->buf, b->len);
        }
    } while (ret > 0);
    b->buf[b->pos] = 0;

    if (b->pos < MIN_RESPONSE_SIZE || !strstr((b->buf + b->pos - 16), "</env:Envelope>")) {	
        GDKerror("CMDhttp_post: failed to get response: %s\n",
                errno?strerror(errno):"no errno available");
        if (b->pos < MIN_RESPONSE_SIZE)
            GDKerror("#bytes received: %ld\n", b->pos);
        else if (!strstr((b->buf + b->pos - 16), "</env:Envelope>"))
            GDKerror("cannot find \"</env:Envelope>\" in buffer");

        GDKerror("\nDump of received data:\n%s\n", b->buf);
        goto FINISH_HTTP_POST;
    }
/*
printf("\n=== DEBUG MSG: received SOAP response message ======\n%s"
       "=== END DEBUG MSG: received SOAP response message ===\n\n", b->buf);
*/
    b->len = b->pos;
    b->buf = realloc(b->buf, b->len); /* release unused memory */
    strptr = strchr(b->buf, (int)' ') + 1; /* the HTTP return code */
    if (strptr[0] != '2' || strptr[1] != '0' || strptr[2] != '0' ) {
        /* Find the end of the first HTTP header line
         * and print the HTTP error code + message */
        i = 0;
        while (strptr[i] != '\r') i++;
        strptr[i] = '\0';
        GDKerror("CMDhttp_post: %s\n\n", b->buf);
        goto FINISH_HTTP_POST;
    } else if (strstr(strptr, "<env:Fault")) {
        /* Print the SOAP Fault Envelope */
        /* TODO: maybe it is better to shred the SOAP fault message
         *       and let the calling XQuery method handle it. */
        strptr = strstr((strptr + i + 1), "<env:");
        GDKerror("%s\n", strptr);
        goto FINISH_HTTP_POST;
    }

    /* Retrieve the response SOAP Envelope */
    strptr = strstr(strptr, "<env:Envelope");

    if (CMDshred2bats(&docBAT, "", strptr, "")  == GDK_FAIL) {
        GDKerror("CMDhttp_post: invalid SOAP RPC response received\n");
        goto FINISH_HTTP_POST;
    }

    *res = docBAT;
    retval = GDK_SUCCEED;
    goto FINISH_HTTP_POST;

FINISH_HTTP_POST:
    cleanup(in, 1);
    cleanup(out, 1);
    cleanup(bs, 0);
    myfree(argcnt, i, iterc);
    if (sock > 0) close(sock);
    if (b) {
        if (b->len > 0) buffer_destroy(b);
        else            free(b);
    }
    return retval;
}

int CMDhttpd_start(int* port) {
    int sock;
       
    if (soap_running) {
        GDKerror("CMDhttpd_start: soap receiver already running\n");
        return GDK_FAIL;
    }
    soap_running = 1;

    /* Initialize with specific config file, pass NULL to use default values */
    shttpd_init(NULL);

    /* Register call back function */
    shttpd_register_url(HTTPD_FUNC, &handle_soap_request, NULL);

    /* Open listening socket */
    sock = shttpd_open_port(*port);

    /* Serve connections infinitely until someone kills us */
    for (;soap_running;) {
        shttpd_poll(sock, 200);
    }
    return GDK_SUCCEED;
}

bat* pf_soap_prelude() {
    /* Nothing to do here. */
    return NULL;
}

void pf_soap_epilogue() {
    /* Shut down the HTTP server. */
    shttpd_fini();

    /* stop SOAP */
    soap_running = 0;
}

/* vim:set shiftwidth=4 expandtab: */
