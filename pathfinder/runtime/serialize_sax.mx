@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2006 University of Konstanz.  All Rights Reserved.
@'

@f serialize_sax
@a Jan Flokstra
@t serialize_sax

@c
/*******************************************
 * serialize_sax.c : XML serialization functions
 * The sax serialization function definitions are in this file.
 * They are called by the driver software in serialize.c
 *
 */

#include <gdk.h>

#include "pathfinder.h"
#include "pf_support.proto.h"
#include "serialize.h"

#define SAXOPHONE 1

static int emit_SAX_header() {
    stream_printf(GDKout,"#-------------------------#\n");
    stream_printf(GDKout,"# h     SAXtape           #\n");
    stream_printf(GDKout,"# str   str               #\n");
    stream_printf(GDKout,"#-------------------------#\n");
    return 1;
}

static int emit_SAX_footer() {
    return 1;
}

static int emit_SAX_event(char* eventName, char* val, int escaped) {
    if ( val ) {
        if ( escaped ) {
            stream_printf(GDKout,"[\"%s\",\t\"",eventName);
            if ( !emit_escaped(val, escaped-1, 0/*ALL*/) )
                return 0;
            stream_printf(GDKout,"\"]\n");
        } else {
            stream_printf(GDKout,"[\"%s\",\t\"%s\"]\n",eventName,val);
        }
    } else
        stream_printf(GDKout,"[\"%s\",\tnil]\n",eventName);
    return 1;
}

/**
 * Default driver initialization function
 */
static int sax_init(XqueryCtx* ctx, char* args) {
    (void) ctx;
    (void) args;
    ctx->driverWs = NULL; /* driverWs not used */
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static int sax_handle_startDocument(XqueryCtx* ctx) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit_SAX_header() )
                return 0;
        } else
            stream_printf(GDKout,"<S\n");
    } else if (ctx->mapiMode) { /* xml mode (mapi) */
        stream_printf(GDKout,"=<?xml version=\"1.0\" encoding=\"utf-8\"?>\n=");
    } else if (ctx->printMode) { /* SQL-ish mapi */
        stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n");
    } else { /* xml mode */
        stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static int sax_handle_endDocument(XqueryCtx* ctx) {
    if (ctx->saxMode ) {
        if ( SAXOPHONE ) {
            if ( !emit_SAX_footer() )
                return 0;
        } else
            stream_printf(GDKout,"<E\n");
    } else { /* xmlMode */
        stream_printf(GDKout,"\n");
    }
    return 1;
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequence of these events will be ended
 * by a handle_attributeEnd() call.
 */
static int sax_handle_attribute(XqueryCtx* ctx, str uri, str prefix, str loc, str value, int top) {
    (void)uri;
    if ( 1 && !checkNsChange(ctx,uri,prefix,top) )
        return 0;
    if ( SAXOPHONE ) {
        if ( loc && *loc) {
            if (!emit_SAX_event(" attribute",loc,0) )
                return 0;
            if ( prefix && *prefix )
                if ( !emit_SAX_event(" attribute prefix",prefix,0) )
                    return 0;
        } else if (prefix && *prefix) {
            /* default namespace */
            if (!emit_SAX_event(" attribute",prefix,0) )
                return 0;
        }
        if ( !emit_SAX_event(" attribute value",value,0) )
            return 0;
    } else {
        stream_printf(GDKout,"<A %s=\"%s\"\n",loc,value);
    }
    return 1;
}

/**
 * Output generation handler. This one of my own invented event indicating
 * there will be no more attribute events for this node.
 */
static int sax_handle_attributeEnd(XqueryCtx* ctx, int emptyNode) {
    (void)ctx;
    (void)emptyNode;
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static int sax_handle_startElement(XqueryCtx* ctx, str ns, str name, oid pre) {
    (void)ctx;
    (void)pre; /* the Pathfinder PRE number is not used by this fun */
    if ( SAXOPHONE ) {
        if ( !emit_SAX_event("startElement",NULL,0) )
            return 0;
        if ( ns && *ns )
            if ( !emit_SAX_event(" prefix",ns,0) )
                return 0;
        if ( !emit_SAX_event(" localname",name,0) )
            return 0;
    } else {
        stream_printf(GDKout,"<s %s\n",name);
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static int sax_handle_endElement(XqueryCtx* ctx, str ns, str name, int emptyNode) {
    (void)ctx;
    (void)emptyNode;
    if ( SAXOPHONE ) {
        if ( !emit_SAX_event("endElement",NULL,0) )
            return 0;
        if ( ns && *ns )
            if ( !emit_SAX_event(" prefix",ns,0) )
                return 0;
        if ( !emit_SAX_event(" localname",name,0) )
            return 0;
    } else {
        stream_printf(GDKout,"<e %s\n",name);
    }
    return 1;
}

/**
 * Output generation handler. One on my own again. This one should handle a
 * reference. Don't know wat to to about it now.
 */
static int sax_handle_reference(XqueryCtx* ctx, str name) {
    (void)ctx;
    (void)name;
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static int sax_handle_characters(XqueryCtx* ctx, str ch, str top) {
    (void)ctx;
    (void)top;
    if ( SAXOPHONE ) {
        if (!emit_SAX_event("characters",NULL,0))
            return 0;
        if (!emit_SAX_event(" pcdata",ch,1))
            return 0;
    } else {
        stream_printf(GDKout,"%s\n",ch); /* ESCAPE !! */
    }
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static int sax_handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
    return sax_handle_characters(ctx,ch,0); /* dispatch */
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
static int sax_handle_comment(XqueryCtx* ctx, str comm) {
    /* incomplete */
    (void)ctx;
    (void)comm;
    return 1;
}

/**
 * Output generation handler. Handles equivalent of * SAX
 * processingInstruction() event.
 */
static int sax_handle_processingInstruction(XqueryCtx* ctx, str target, str data) {
    /* incomplete */
    (void)ctx;
    (void)target;
    (void)data;
    return 1;
}

/*
 *
 * Second the sequence emitting functions are defined
 *
 */

/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static int sax_seqStart(XqueryCtx* ctx, BAT* item) {
    (void)item;
    if ( !ctx->norootMode ) {
        ctx->driverFun->handle_startElement(ctx, NULL, ctx->restag, oid_nil);
        ctx->nAttrOnLine = 0;
    }
    return 1;
}

static int sax_seqDmAttrStart(XqueryCtx* ctx) {
    (void)ctx;
    return 1;
}

static int sax_seqDmAttrEnd(XqueryCtx* ctx) {
    (void)ctx;
    return 1;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static int  sax_seqEnd(XqueryCtx* ctx) {
    if (!ctx->norootMode) {
        ctx->driverFun->handle_endElement(ctx, NULL, ctx->restag, 0 /* not empty*/);
    }
    return 1;
}


/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
static int  sax_seqEmitBool(XqueryCtx* ctx, int bv, int lastVal) {
    char *bool_str = (char*)(bv ? "true" : "false");

    (void)lastVal;
    return ctx->driverFun->handle_characters(ctx,bool_str,0);
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
static int  sax_seqEmitInt(XqueryCtx* ctx, lng iv, int lastVal) {
    char buff[32];

    (void)lastVal;
    sprintf(buff,"%lld",iv);
    return ctx->driverFun->handle_characters(ctx,buff,0);
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
static int  sax_seqEmitDbl(XqueryCtx* ctx, dbl dv, int lastVal) {
    (void)lastVal;
    char buff[32];

    sprintf(buff,"%f",dv);
    return ctx->driverFun->handle_characters(ctx,buff,0);
}

static int  sax_seqElementStart(XqueryCtx* ctx, int cnt) {
    (void)ctx;
    (void)cnt;
    return 1;
}

static int  sax_seqElementEnd(XqueryCtx* ctx, int cnt) {
    (void)ctx;
    (void)cnt;
    return 1;
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
static int  sax_seqEmitStr(XqueryCtx* ctx, str sv, int lastVal) {
    (void)lastVal;
    return ctx->driverFun->handle_characters(ctx,sv,"text");
}


/**
 *
 * Definition of the structure containing the functions
 */

struct serializeFunStruct saxSerializeFun = {
	"sax",
	sax_init,
	sax_handle_startDocument,
	sax_handle_endDocument,
	sax_handle_attribute,
	sax_handle_attributeEnd,
	sax_handle_startElement,
	sax_handle_endElement,
	sax_handle_characters,
	sax_handle_ignorableWhitespace,
	sax_handle_comment,
	sax_handle_processingInstruction,
	/* */
	sax_seqStart,
	sax_seqDmAttrStart,
	sax_seqDmAttrEnd,
	sax_seqElementStart,
	sax_seqElementEnd,
	sax_seqEnd,
	sax_seqEmitBool,
	sax_seqEmitInt,
	sax_seqEmitDbl,
	sax_seqEmitStr
};

/* vim:set shiftwidth=4 expandtab: */
