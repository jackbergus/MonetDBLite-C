@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2006 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'

@f serialize_sax
@a Jan Flokstra
@a Jan Rittinger
@t serialize_sax

@c
/*******************************************
 * serialize_sax.c : XML serialization functions
 * The sax serialization function definitions are in this file.
 * They are called by the driver software in serialize.c
 *
 */

#include "serialize.h"
#include "serialize_null.h"

#define SAXOPHONE 1

/**
 * The character translation section responsible for the special
 * character recognition and XML entity characters.  It consists of a
 * small main table 'isspecial_tab' containing the flags for every
 * possible character.
 *
 * v=0: no special char
 * v=1: special char, should be presented as octal char in output
 * v>1: special char, string repr of char is isspecial_val[v]
 */

static unsigned char  isspecial_tab[UCHAR_MAX+1] = { 0 }; /* the main table */
static char*          isspecial_val[32]; /* the values of the special chars */

static void
sax_init_isspecial() {
    int i;
    for(i=0; i<32; i++) isspecial_tab[i] = 1; /* means write as octal */

    isspecial_tab[(int)(unsigned char)'\377'] = 1; /* means write as octal */
    isspecial_tab[(int)'\t'] = 2;
    isspecial_tab[(int)'\n'] = 3;
    isspecial_tab[(int)'\r'] = 3; /* map \r on \n */
    isspecial_tab[(int)'\\'] = 4;
    isspecial_tab[(int)'\"'] = 5;
    isspecial_tab[(int)'\''] = 6;
    isspecial_tab[(int)'&']  = 7;
    isspecial_tab[(int)'<']  = 8;
    isspecial_tab[(int)'>']  = 9;

    isspecial_val[0] = NULL; /* not used */
    isspecial_val[1] = NULL; /* not used, 1 = write as octal */
    isspecial_val[2] = "\\t";
    isspecial_val[3] = "\\n";
    isspecial_val[4] = "\\\\";
    isspecial_val[5] = "&quot;";
    isspecial_val[6] = "&apos;";
    isspecial_val[7] = "&amp;";
    isspecial_val[8] = "&lt;";
    isspecial_val[9] = "&gt;";
}

/*
 * This function is responsible for the presentation of special characters
 * and XML entity characters in the result.
 */
static void
sax_emit_escaped (XqueryCtx *ctx, char* src)
{
    /* Emit a string with all special character escaped. Inspired by
     * function strToStr() in gdk_atoms.mx
     */
    int start = 0, end;
    unsigned char isspecial_ch;

    for(end = 0; src[end]; end++) {
        if ( (isspecial_ch = isspecial_tab[(int)(unsigned char)src[end]]) ) {
            stream_write (ctx->out, &src[start], end - start, 1);
            start = end + 1;

            if ( isspecial_ch == 1 ) {
                stream_printf(ctx->out,"\\%03o",(unsigned char)src[end]);
            } else {
                char *emit_val = isspecial_val[(int)isspecial_ch];
                stream_write (ctx->out, emit_val, strlen (emit_val), 1);
            }
        }
    }
    if ( start < end )
        stream_write (ctx->out, &src[start], end - start, 1);
}

static bool
emit_SAX_header (XqueryCtx *ctx)
{
    char *s;

    s = "#-------------------------#\n"; stream_write (ctx->out, s, strlen(s), 1);
    s = "# h     SAXtape           #\n"; stream_write (ctx->out, s, strlen(s), 1);
    s = "# str   str               #\n"; stream_write (ctx->out, s, strlen(s), 1);
    s = "#-------------------------#\n"; stream_write (ctx->out, s, strlen(s), 1);

    return SUCCESS;
}

static bool
emit_SAX_footer ()
{
    return SUCCESS;
}

static bool
emit_SAX_event (XqueryCtx *ctx, char* eventName, char* val, int escaped)
{
    if ( val ) {
        if ( escaped ) {
            /* stream_printf(ctx->out,"[\"%s\",\t\"",eventName); */
            stream_write (ctx->out, "[\"", 2, 1);
            stream_write (ctx->out, eventName, strlen (eventName), 1);
            stream_write (ctx->out, "\",\t\"", 4, 1);

            sax_emit_escaped(ctx, val);
            stream_write (ctx->out, "\"]\n", 3, 1);
        } else {
            /* stream_printf(ctx->out,"[\"%s\",\t\"%s\"]\n",eventName,val); */
            stream_write (ctx->out, "[\"", 2, 1);
            stream_write (ctx->out, eventName, strlen (eventName), 1);
            stream_write (ctx->out, "\",\t\"", 4, 1);
            stream_write (ctx->out, val, strlen (val), 1);
            stream_write (ctx->out, "\"]\n", 3, 1);
        }
    } else
        /* stream_printf(ctx->out,"[\"%s\",\tnil]\n",eventName); */
        stream_write (ctx->out, "[\"", 2, 1);
        stream_write (ctx->out, eventName, strlen (eventName), 1);
        stream_write (ctx->out, "\",\t\"nil]\n", 9, 1);

    return SUCCESS;
}

/**
 * Default driver initialization function
 */
static bool
sax_init (XqueryCtx* ctx, char* args, char *restag)
{
    (void) args;
    ctx->driverWs = (void *) restag; /* store result tag */
    sax_init_isspecial();

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
static bool
sax_handle_startDocument (XqueryCtx* ctx)
{
    if ( SAXOPHONE )
        return emit_SAX_header(ctx);
    else
        /* stream_printf(ctx->out,"<S\n"); */
        stream_write (ctx->out, "<S\n", 3, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
static bool
sax_handle_endDocument (XqueryCtx* ctx)
{
    if ( SAXOPHONE )
        return emit_SAX_footer();
    else
        /* stream_printf(ctx->out,"<E\n"); */
        stream_write (ctx->out, "<E\n", 3, 1);

    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
static bool
sax_handle_startElement (XqueryCtx* ctx,
                                     str prefix, str name, oid pre)
{
    (void)pre; /* the Pathfinder PRE number is not used by this fun */

    if ( SAXOPHONE ) {
        if ( !emit_SAX_event(ctx, "startElement",NULL,0) )
            return PROBLEM;
        if ( prefix && *prefix )
            if ( !emit_SAX_event(ctx, " prefix",prefix,0) )
                return PROBLEM;
        if ( !emit_SAX_event(ctx, " localname",name,0) )
            return PROBLEM;
    } else {
        /* stream_printf(ctx->out,"<s %s\n",name); */
        stream_write (ctx->out, "<s ", 3, 1);
        stream_write (ctx->out, name, strlen (name), 1);
        stream_write (ctx->out, "\n", 1, 1);
    }
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
static bool
sax_handle_endElement (XqueryCtx* ctx, str prefix, str name)
{
    if ( SAXOPHONE ) {
        if ( !emit_SAX_event(ctx, "endElement",NULL,0) )
            return PROBLEM;
        if ( prefix && *prefix )
            if ( !emit_SAX_event(ctx, " prefix",prefix,0) )
                return PROBLEM;
        if ( !emit_SAX_event(ctx, " localname",name,0) )
            return PROBLEM;
    } else {
        /* stream_printf(ctx->out,"<e %s\n",name); */
        stream_write (ctx->out, "<e ", 3, 1);
        stream_write (ctx->out, name, strlen (name), 1);
        stream_write (ctx->out, "\n", 1, 1);
    }
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
static bool
sax_handle_characters (XqueryCtx* ctx, str chars)
{
    if ( SAXOPHONE ) {
        if (!emit_SAX_event(ctx, "characters",NULL,0))
            return PROBLEM;
        if (!emit_SAX_event(ctx, " pcdata",chars,1))
            return PROBLEM;
    } else {
        /* stream_printf(ctx->out,"%s\n",chars); / * ESCAPE !! * / */
        sax_emit_escaped(ctx, chars);
        stream_write (ctx->out, "\n", 1, 1);
    }
    return SUCCESS;
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
static bool
sax_handle_ignorableWhitespace(XqueryCtx* ctx, str chars)
{
    return sax_handle_characters (ctx, chars); /* dispatch */
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by Pathfinder.
 */
static bool
sax_handle_comment (XqueryCtx* ctx, str comm)
{
    (void)ctx;
    (void)comm;

    return PROBLEM; /* incomplete */
}

/**
 * Output generation handler. Handles equivalent of * SAX
 * processingInstruction() event.
 */
static bool
sax_handle_processingInstruction (XqueryCtx* ctx,
                                              str target, str data)
{
    (void)ctx;
    (void)target;
    (void)data;

    return PROBLEM; /* incomplete */
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. 
 */
static bool
sax_handle_attribute (XqueryCtx* ctx,
                                  str prefix, str loc, str value)
{
    if ( SAXOPHONE ) {
        if ( loc && *loc) {
            if (!emit_SAX_event(ctx, " attribute",loc,0) )
                return PROBLEM;
            if ( prefix && *prefix )
                if ( !emit_SAX_event(ctx, " attribute prefix",prefix,0) )
                    return PROBLEM;
        } else
            return PROBLEM;

        if ( !emit_SAX_event(ctx, " attribute value",value,0) )
            return PROBLEM;
    } else {
        /* stream_printf(ctx->out,"<A %s=\"%s\"\n",loc,value); */
        stream_write (ctx->out, "<A ", 3, 1);
        stream_write (ctx->out, loc, strlen (loc), 1);
        stream_write (ctx->out, "=\"", 2, 1);
        stream_write (ctx->out, value, strlen (value), 1);
        stream_write (ctx->out, "\"\n", 2, 1);
    }
    return SUCCESS;
}

/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
static bool
sax_seqEmitBool (XqueryCtx* ctx, int bv)
{
    char *bool_str = (char*)(bv ? "true" : "false");

    return sax_handle_characters (ctx, bool_str);
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
static bool
sax_seqEmitInt(XqueryCtx* ctx, lng iv)
{
    char buff[32];
    sprintf(buff,"%lld",iv);

    return sax_handle_characters (ctx, buff);
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
static bool
sax_seqEmitDbl (XqueryCtx* ctx, dbl dv)
{
    char buff[32];
    sprintf(buff,"%f",dv);

    return sax_handle_characters (ctx, buff);
}


/**
 * Handle the start() of an XQUERY/Pathfinder result sequence.
 */
static bool
sax_seqStart (XqueryCtx* ctx, int count)
{
    (void)count;

    if ( !(ctx->modes & MODE_NO_ROOT) )
        sax_handle_startElement (ctx, NULL, (char *) ctx->driverWs, oid_nil);

    return SUCCESS;
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
static bool
sax_seqEnd (XqueryCtx* ctx)
{
    if ( !(ctx->modes & MODE_NO_ROOT) )
        sax_handle_endElement (ctx, NULL, (char *) ctx->driverWs);

    return SUCCESS;
}

/**
 *
 * Definition of the structure containing the functions
 */
struct serializeFunStruct saxSerializeFun = {
    "sax",
    sax_init,
    null_cleanup,

    sax_handle_startDocument,
    sax_handle_endDocument,
    sax_handle_startElement,
    sax_handle_endElement,
    sax_handle_characters,
    sax_handle_ignorableWhitespace,
    sax_handle_comment,
    sax_handle_processingInstruction,

    null_complete_startElement,
    null_complete_startElementEmpty,
    sax_handle_attribute,

    sax_seqEmitBool,
    sax_seqEmitInt,
    sax_seqEmitDbl,
    sax_handle_characters,
    sax_handle_attribute,
    sax_handle_characters,

    sax_seqStart,
    null_complete_seqStart,
    sax_seqEnd,
    null_seqItemStart,
    null_seqItemEnd,
    null_seqItemSeparator
};

/* vim:set shiftwidth=4 expandtab: */
