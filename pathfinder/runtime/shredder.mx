@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2007 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$

@f shredder
@a Jan Flokstra
@a Peter Boncz
@a Niels Nes
@t shredder

@h
#ifndef SHREDDER_H
#define SHREDDER_H

#include "serialize.h" /* for struct serializeFunStruct & struct XqueryCtx */

/* for PFtijah */
pf_support_export int shred(BAT *docBAT, str location, str buffer, stream *s, lng percentage, struct serializeFunStruct *serFun, struct XqueryCtx *serCtx, lock *collLock);

/* MIL commands to shred XML from a {uri,string,stream}. */
pf_support_export int CMDshred_url(BAT *docBAT, str location, lng *percentage, lock* collLock, bit *verbose);
pf_support_export int CMDshred_str(BAT *docBAT, str buffer, lng *percentage, lock* collLock, bit *verbose);
pf_support_export int CMDshred_stream(BAT *docBAT, Stream *s, lng *percentage, lock* collLock, bit *verbose);

#endif /* SHREDDER_H */
@c
/* ====================================================================================
 * shredder.mx : xml document shredder for pathfinder
 *
 * Original code by Jan Flokstra. 
 * Incremental stream parser addition by Niels Nes.
 * Revised by Peter Boncz(code restructuring, attempt at documentation, multi-doc 
 *                         collections, garbage collection, error checking, atomicity). 
 * ==================================================================================== */

/* #define DEBUG */

#define PRINT_STAT 0

#include <pf_config.h>
#include <gdk.h>
#include <monet.h>

#include "pathfinder.h"
#include "pf_support.h"
#include "shredder.h"

/**
 * XML node kinds
 */
#define ELEMENT   0
#define PFTEXT    1
#define COMMENT   2
#define PI        3
#define DOCUMENT  4
#define COLLECTION 5

#include <strings.h>

/* SAX parser interface(libxml2) */
#include "libxml/parser.h"
#include "libxml/parserInternals.h"

char*
timer_str(lng elapsed, char* buf)
{
    char *str = buf;
    int print =(elapsed / 3600000000UL);
    if (print) {
        str += sprintf(str, "%03dh ", (int) (elapsed / 3600000000UL));
        elapsed %= 3600000000UL;
    }
    print |=(elapsed / 60000000UL);
    if (print) {
        str += sprintf(str, "%02dm ", (int) (elapsed / 60000000UL));
        elapsed %= 60000000UL;
    }
    print |=(elapsed / 1000000UL);
    if (print) {
        str += sprintf(str, "%02ds ", (int) (elapsed / 1000000UL));
        elapsed %= 1000000UL;
    }
    print |=(elapsed / 1000UL);
    if (print) {
        str += sprintf(str, "%03dms ", (int) (elapsed / 1000UL));
        elapsed %= 1000UL;
    }
    str += sprintf(str, "%03dus", (int) elapsed);
    return buf;
}

/* ====================================================================================
 * attribute DB to distinguish attrs that have ID/IDREF semantics(filled during DTD parse)
 * - attrDB_init()    initialize the attribute database
 * - attrDB_find()    find if an attribute is already registered in the database
 * - attrDB_insert()  register an attribute as an ID/IDREF attribute
 * - attrDB_check()   check if this attribute is an ID/IDREF attribute  
 * - attrDB_free()    free resources
 * ==================================================================================== */

/* #define ADB_DEBUG */
/* #define ADB_USE_NAMES */

#define ADB_STARTSIZE       256 

typedef struct specAttrStr {
    char*      ownerTag;
    char*      attrTag;
    int        type; /* XML_ATTRIBUTE_[ID|IDREF|IDREFS] */
} specAttrStr;

typedef struct idrefAttrDBStr {
    int doCheck;  /* boolean to signal if the attr db is in use */
    int n_specAttr;
    int max_specAttr;
    specAttrStr* specAttr;
} idrefAttrDBStr;

static void 
attrDB_init(idrefAttrDBStr* adb)
{
#ifdef ADB_DEBUG
    stream_printf(GDKout, "[ADB] initialize database\n");
#endif
    adb->n_specAttr = adb->max_specAttr = 0;
    adb->specAttr   = 0;
#ifdef ADB_USE_NAMES
    /* in this case even when no attributes are encountered the db is in use. */
    adb->doCheck    = 1;
#else
    adb->doCheck    = 0;
#endif
}

static specAttrStr* 
attrDB_find(idrefAttrDBStr *adb, 
           char *oTag, 
           char *aTag)
{
    int i;
    for(i=0; i<adb->n_specAttr; i++) {
        specAttrStr *sas = &adb->specAttr[i];
        if ((strcmp(oTag, sas->ownerTag) == 0) &&
               (strcmp(aTag, sas->attrTag) == 0)) {
#ifdef ADB_DEBUG
            /* stream_printf(GDKout, "[ADB] found(%s, %s, %d)\n", sas->ownerTag, sas->attrTag, sas->type); */
#endif
            return sas;
        };
    }
    return NULL;
}

static int 
attrDB_check(idrefAttrDBStr *adb, 
             char *oTag, 
             char *aTag)
{
    if (adb->doCheck) { /* check if db is in use */
        specAttrStr *sas;
        if ((sas = attrDB_find(adb, oTag, aTag)))
            return sas->type;
        else {
#ifdef ADB_USE_NAMES
            if ((strcmp(aTag, "id") == 0) ||(strcmp(aTag, "ID") == 0))
                return XML_ATTRIBUTE_ID;
            else if ((strcmp(aTag, "idref") == 0) ||(strcmp(aTag, "IDREF") == 0))
                return XML_ATTRIBUTE_IDREF;
            else if ((strcmp(aTag, "idrefs") == 0) ||(strcmp(aTag, "IDREFS") == 0))
                return XML_ATTRIBUTE_IDREFS;
#endif
        }
    }
    return 0;
}

static int 
attrDB_insert(idrefAttrDBStr *adb, 
              char *oTag, 
              char *aTag, 
              int type) 
{
    specAttrStr *sas = NULL;

    adb->doCheck = 1; /* signal database is in use */
    if (attrDB_find(adb, oTag, aTag)) {
        GDKerror("attrDB_insert: idrefAttrDB(%s, %s, %d) is duplicate.\n", oTag, aTag, type);
        return GDK_FAIL;
    }
    oTag = GDKstrdup(oTag);
    aTag = GDKstrdup(aTag);
    if (oTag == NULL || aTag == NULL) goto error;

    if (++adb->n_specAttr >= adb->max_specAttr) {
        int newsz =(adb->max_specAttr?(adb->max_specAttr*2):ADB_STARTSIZE);

        specAttrStr *newb =(specAttrStr*)GDKmalloc(newsz*sizeof(specAttrStr));
        if (newb == NULL) goto error;
        if (adb->specAttr) {
            memcpy(newb, adb->specAttr, adb->max_specAttr*sizeof(specAttrStr));
            GDKfree(adb->specAttr);
        }
        adb->specAttr     = newb;
        adb->max_specAttr = newsz;
    }
    sas = &adb->specAttr[adb->n_specAttr - 1];
    sas->type     = type;
    sas->ownerTag = GDKstrdup(oTag);
    sas->attrTag  = GDKstrdup(aTag);
#ifdef ADB_DEBUG
    stream_printf(GDKout, "[ADB] inserted(%s, %s, %d)\n", oTag, aTag, type);
#endif
    return GDK_SUCCEED;
error:
    if (oTag) GDKfree(oTag);
    if (aTag) GDKfree(aTag);
    GDKerror("attrDB_insert: memory failure.\n");
    return GDK_FAIL;
}

static void 
attrDB_free(idrefAttrDBStr *adb)
{
    int i;

    for(i=0; i<adb->n_specAttr; i++) {
        specAttrStr *sas = &adb->specAttr[i];
        GDKfree(sas->ownerTag);
        GDKfree(sas->attrTag);
    }
    if (adb->specAttr)
        GDKfree(adb->specAttr);
    adb->n_specAttr = adb->max_specAttr = 0;
    adb->specAttr   = 0;
    adb->doCheck    = 0;
#ifdef ADB_DEBUG
    stream_printf(GDKout, "[ADB] disposed database\n");
#endif
}

/* ====================================================================================
 * main shredder data structures(the shredCtx, containing the shredBATdefs)
 * ==================================================================================== */

/* define the number of BATs in the requuired result set */
#define SHRED_BATS (ATTR_PROP+1)

/* description of the static properties of a result BAT */
typedef struct shredBATdef {
    int     table;      /* subtable this bat belongs to */
    char    *name;      /* the name for the bat */
    int     headType;   /* type of left column */
    int     tailType;   /* type of right column */
    double  sizeFact;   /* expected size as a factor of #nodes */
    char    compress;   /* string tails should be kept unique? */
} shredBATdef;

/* values of the static properties of a result BAT */
static shredBATdef shredbatdef[SHRED_BATS] = {
 { MAP_PID,      "_map_pid",          TYPE_void, TYPE_void, 1.0/REMAP_PAGE_SIZE, 0}, 
 { PRE_SIZE,     "_rid_size",         TYPE_void, TYPE_int,  1.0, 0}, 
 { PRE_SIZE,     "_rid_level",        TYPE_void, TYPE_chr,  1.0, 0}, 
 { PRE_SIZE,     "_rid_prop",         TYPE_void, TYPE_oid,  1.0, 0}, 
 { PRE_SIZE,     "_rid_kind",         TYPE_void, TYPE_chr,  1.0, 0}, 
 { PRE_SIZE,     "_rid_nid",          TYPE_void, TYPE_void, 1.0, 0}, 
 { NID_RID,      "_nid_rid",          TYPE_void, TYPE_void, 1.0, 0}, 
 { FRAG_ROOT,    "_frag_root",        TYPE_oid,  TYPE_oid,  0.0, 0}, 
 { QN_HISTOGRAM, "_qn_histogram",     TYPE_void, TYPE_lng,  0.0, 1}, 
 { QN_HISTOGRAM, "_qn_prefix_uri_loc",TYPE_void, TYPE_str,  0.0, 1}, 
 { QN_HISTOGRAM, "_qn_uri_loc",       TYPE_void, TYPE_str,  0.0, 0},
 { QN_HISTOGRAM, "_qn_prefix",        TYPE_void, TYPE_str,  0.0, 0}, 
 { QN_HISTOGRAM, "_qn_uri",           TYPE_void, TYPE_str,  0.0, 0}, 
 { QN_HISTOGRAM, "_qn_loc",           TYPE_void, TYPE_str,  0.0, 0}, 
 { PROP_TEXT,    "_prop_text",        TYPE_void, TYPE_str,  0.3, 1}, 
 { PROP_COM,     "_prop_com",         TYPE_void, TYPE_str,  0.0, 1}, 
 { PROP_INS,     "_prop_ins",         TYPE_void, TYPE_str,  0.0, 0}, 
 { PROP_TGT,     "_prop_tgt",         TYPE_void, TYPE_str,  0.0, 0}, 
 { PROP_VAL,     "_prop_val",         TYPE_void, TYPE_str,  0.1, 1}, 
 { ID_NID,       "_id_nid",           TYPE_str,  TYPE_oid,  0.0, 0}, 
 { IDREF_NID,    "_idref_nid",        TYPE_str,  TYPE_oid,  0.0, 0}, 
 { ATTR_OWN,     "_attr_own",         TYPE_void, TYPE_oid,  0.3, 0}, 
 { ATTR_OWN,     "_attr_qn",          TYPE_void, TYPE_oid,  0.3, 0}, 
 { ATTR_OWN,     "_attr_prop",        TYPE_void, TYPE_oid,  0.3, 0}
};

/* description of the dynamic properties of a result BAT */
typedef struct shredBAT {
    shredBATdef     *def; /* pointer to static properties */
    oid             dupl; /* the number of duplicate BUNins so far */
    size_t          size; /* current maximum size of the BAT */
    BAT             *bat; /* the physical BAT */
    size_t     abortSize; /* size previous to shredding */ 
    size_t      heapSize; /* size of string tail heap(->free) */
    void     *heapBackup; /* image of the internal str-heap hash-table */
    /* */
    union { /* cast to perform direct indexex insert in [void, any] BATs */
        void *voidCAST; /* the basecast */
        int  *intCAST;  /* cast for [void, int] BAT */
        chr  *chrCAST;  /* cast for [void, chr] BAT */
        oid  *oidCAST;  /* cast for [void, oid] BAT */
    } cast;
} shredBAT;


/**
 * control flow in the shred_* SAX callback functions
 */
#define BAILOUT(C)      { xmlStopParser(C->xmlCtx); C->err=1; return; }

#define PUSH(SC, n)((SC)->lifo[(SC)->sp++] =(n))
#define POP(SC)   ((SC)->lifo[--(SC)->sp])
#define TOP(SC)   ((SC)->lifo[(SC)->sp - 1])

/**
 * Node element of the XMD document interpretation stack
 */
typedef struct node_t node_t;
struct node_t {
    oid      pre;                /**< preorder rank */
    oid      nid;                /**< stable nid */
    int      level;              /**< tree level of parent(0 if root, -1 if document node) */
    oid      prop;               /**< property ID */
    chr      kind;               /**< node kind */
};

/* the computing context environmentf the shredding process */
typedef struct shredCtxStruct {
    char     *location;          /* xml document location */
    /* pre-level-depth administration */
    oid      nnode_base;         /* preorder rank at start of shred */
    oid      nnode_pre;          /* next preorder rank to assign */
    oid      nnode_nid;          /* next NID to assign */
    oid      nnode_attr;         /* number of attributes counter */
    ssize_t  pre_nid;            /* difference between pre and nid at start */
    int      level;              /* current level */
    int      depth;              /* current max depth */
    /* the xml node stack */
    node_t   *lifo;              /* the stack */
    int      sp;                 /* the stackpointer */
    /* buffer administration */
    int      content;            /* content ptr in char buff */
    char     *content_buf;       /* character buffer */
    /* */
    size_t   fileSize;           /* size of the input file */
    size_t   estSize;            /* extimated number of pre nodes */
    shredBAT dstBAT[SHRED_BATS]; /* all the result BATs */
    size_t   pageFree;           /* number of tuples per page to leave empty */

    /* attributes for shred into collection */
    int      incremental;         /* boolean: incremental shred? */
    int      updatable;           /* boolean: is nid-rid-pre the identity mapping? */
    char     *val_prefix;         /* temporary string buffer, includes val(at the end) */
    char     *val;                /* temporary PFSHRED_BUFLEN-byte string workspace */
    
    /* the database containing the ID|IDREF|IDREFS attributes */
    idrefAttrDBStr idrefAttrDB;        

    int      err;                /* error during shred */
    void*    xmlCtx;             /* SAX2 context pointer */

    /* The next two variables are used to immediately serialize
     * the shredded xml stuff. Can be used for on the fly indexing of 
     * the serialized data.
     */
    struct serializeFunStruct *serFun; /* the functions */
    struct XqueryCtx *serCtx; /* the runtime data */

     MT_Lock *coll_lock;
     MT_Sema *extend_sema;
} shredCtxStruct;

/* some string buffer sizes */
#define PFSHRED_STRLEN_MAX (1 << 23)
#define PFSHRED_BUFLEN     (1 << 10)
#define XML_TAG_MAX        PFSHRED_STRLEN_MAX

/* ====================================================================================
 * shredder low-level routines that add data to bats, while parsing
 * - shredBAT_newsize()    compute a suitable new bat size
 * - shredBAT_extend()     low-level way of increasing the logical size of a bat
 * - shredBAT_setcount()   make more room in a BAT(using BATextend)
 * - shredBAT_append_str() append into a BAT[void,str], possibly with compression(double-elim) 
 * ==================================================================================== */
 
static void 
shredBAT_setcount(shredBAT *sb, 
                  oid n)
{
    BAT *b = sb->bat;
    b->batBuns->free = n*BUNsize(b);
    BATsetcount(b, n);
    b->tsorted = 0;
}


static size_t 
shredBAT_newsize(shredBAT *sb, size_t newsize)
{
    newsize = MAX(sb->size, newsize + MAX(BATTINY, newsize/4));
    if (sb->def->table == PRE_SIZE && (newsize & REMAP_PAGE_MASK)) { 
        /* align rid bats on the page-size */
        newsize += REMAP_PAGE_SIZE - (newsize & REMAP_PAGE_MASK);
    }

    /* first check if the number of BUN's < INT_MAX. If this was the case
     * and the previous time INT_MAX was returned this means the BAT cannot
     * grow any longer.
     */
    if (newsize > INT_MAX) {
        newsize = INT_MAX;
        if (sb->size == INT_MAX) {
            GDKerror("shredBAT_newsize: %s cannot be extended beyond %d (INT_MAX)\n", sb->def->name, INT_MAX);
            return 0;
        }
    }
    return newsize;
}

static int 
shredBAT_extend(shredBAT *sb, 
                size_t newsize)
{
    shredBAT_setcount(sb, sb->size);
    sb->size = newsize;
    if (sb->bat->ttype == TYPE_void) {
        return GDK_SUCCEED;
    }
    if (newsize+newsize > REMAP_PAGE_MAXSIZE) { /* try to use mmap() */
        BATmmap(sb->bat, STORE_MMAP, STORE_MMAP, STORE_MMAP);
    }
    if (!(sb->bat = BATextend(sb->bat, newsize))) {
        GDKerror("shredBAT_extend: BATextend[\"%s\"](%d to %d) fails\n", sb->def->name, sb->size, newsize);
        return GDK_FAIL;
    }
    sb->cast.voidCAST =(void*)BUNfirst(sb->bat);
    return GDK_SUCCEED;
}


static INLINE oid 
shredBAT_append_str(shredCtxStruct *shredCtx, 
                    int idx, 
                    str v)
{
    shredBAT *sb = & shredCtx->dstBAT[idx];

    if (sb->def->compress) {
        BAT *mb = BBP_cache(-(sb->bat->batCacheid));
        BUN bun;
        HASHfnd_str(bun, mb, v);
        if (bun) {
            oid fo = *(oid*)BUNtail(mb, bun);
            sb->dupl++;
            return fo;
        }
    }
#ifdef DEBUG
    stream_printf(GDKout, "APPEND-STR[%s](%s)\n", sb->def->name, v);
#endif
    if (sb->def->compress && BATcount(sb->bat) > 4 * sb->bat->thash->mask) {
        HASHdestroy(sb->bat); /* keeps hash performance in check */
        BAThash(BATmirror(sb->bat), 2*BATcount(sb->bat));
    }

    if (!BUNappend(sb->bat,(ptr)v, TRUE)) {
        GDKerror("shredBAT_append_str: APPEND-STR[%s](%s), BUNappend fails\n", sb->def->name, v);
        return oid_nil;
    }
    return BATcount(sb->bat)-1;
}

/* ====================================================================================
 * shredder helper functions: emitting nodes
 * - emit_tuple()  inserts a tuple in the RID bats
 * - emit_node()   emit a node (calls emit_tuple)
 * - emit_string() emit a text node (calls emit_node)
 * ==================================================================================== */

static INLINE int
emit_tuple(shredCtxStruct* shredCtx, 
           oid pre, 
           int size, 
           int level, 
           oid prop, 
           chr kind, 
           oid nid)
{
    if (size >= GDK_int_max) {
        GDKerror("emit_tuple: node.size >= GDK_int_max\n");
        return GDK_FAIL;
    }
    /* if (level > GDK_chr_max) does not work, too small -> 128 */
    if (level > XML_DEPTH_MAX) {
        GDKerror("emit_tuple: node.level(%d) >= XML_DEPTH_MAX(%d)\n", level, XML_DEPTH_MAX);
        return GDK_FAIL;
    }
    if (shredCtx->coll_lock) { 
        /* yield the lock every so many nodes to queries that want to start and need the masters */
#ifdef _POSIX_PRIORITY_SCHEDULING
        if ((shredCtx->nnode_pre&1023) == 0) {
            MT_lock_unset(shredCtx->coll_lock, "shredder_yield"); 
            sched_yield();
            MT_lock_set(shredCtx->coll_lock, "shredder_yield"); 
        }
#else
        if ((shredCtx->nnode_pre&16383) == 0) {
            MT_lock_unset(shredCtx->coll_lock, "shredder_yield"); 
            MT_sleep_ms(1); 
            MT_lock_set(shredCtx->coll_lock, "shredder_yield"); 
        }
#endif
    }

    /* make sure the rid_* and nid_* bats have enough room */
    if (pre >= shredCtx->dstBAT[PRE_SIZE].size) {
        size_t newsize = shredBAT_newsize(&shredCtx->dstBAT[PRE_SIZE], pre);
        int err = 0;
        MT_sema_down(shredCtx->extend_sema, "shredder_extend"); 
        err = 
            !(newsize &&
              shredBAT_extend(&shredCtx->dstBAT[PRE_SIZE],  newsize) &&
              shredBAT_extend(&shredCtx->dstBAT[PRE_LEVEL], newsize) &&
              shredBAT_extend(&shredCtx->dstBAT[PRE_PROP],  newsize) &&
              shredBAT_extend(&shredCtx->dstBAT[PRE_KIND],  newsize) &&
              (shredCtx->updatable == 0 || shredBAT_extend(&shredCtx->dstBAT[PRE_NID], newsize)));
        MT_sema_up(shredCtx->extend_sema, "shredder_extend"); 
        if (err) return GDK_FAIL;
    }
    /* insert the new RID tuple */
    if (shredCtx->updatable) {
        if (nid != oid_nil) {
            if (nid >= shredCtx->dstBAT[NID_RID].size) {
                size_t newsize = shredBAT_newsize(&shredCtx->dstBAT[NID_RID], nid);
                if (newsize == 0 || !shredBAT_extend(&shredCtx->dstBAT[NID_RID], newsize)) {
                    return GDK_FAIL;
                }
            }
            shredCtx->dstBAT[NID_RID].cast.oidCAST[nid] = pre;
        }
        shredCtx->dstBAT[PRE_NID].cast.oidCAST[pre] = nid;
    }
    shredCtx->dstBAT[PRE_SIZE].cast.intCAST[pre] = size;
    shredCtx->dstBAT[PRE_LEVEL].cast.chrCAST[pre] = (chr) level;
    shredCtx->dstBAT[PRE_PROP].cast.oidCAST[pre] = prop;
    shredCtx->dstBAT[PRE_KIND].cast.chrCAST[pre] = kind;
    return GDK_SUCCEED;
}

static int 
createHole(shredCtxStruct *shredCtx)
{
    int cnt = REMAP_PAGE_SIZE -(shredCtx->nnode_pre & REMAP_PAGE_MASK) ;

#ifdef DEBUG
    stream_printf(GDKout, "CREATEHOLE: pre=%d\n", shredCtx->nnode_pre);
#endif
    while(cnt--) { 
       int sizefill = cnt |(1<<31);
#ifdef DEBUG
       stream_printf(GDKout, "SHRHOLE: FILL HOLE[%d, rest=%d]\n", shredCtx->nnode_pre, cnt);
#endif
       if (!emit_tuple(shredCtx, shredCtx->nnode_pre, sizefill, chr_nil, oid_nil, chr_nil, oid_nil))
           return GDK_FAIL;
       shredCtx->nnode_pre++;
    }
    return GDK_SUCCEED;
}

#define _NEXT_PRE_IMP(P) if ((P->nnode_pre++ == GDK_oid_max  || P->nnode_nid++ == GDK_oid_max) ||\
                             (P->pageFree && (P->nnode_pre&REMAP_PAGE_MASK) == ((oid)P->pageFree) && !createHole(P)))\
                        {   GDKerror("shredder: failed inserting RID tuple " OIDFMT " \n", (P->nnode_pre-1)); 
#ifdef DEBUG
#define _NEXT_PRE_IF(P) { stream_printf(GDKout, "NEXT_PRE=" OIDFMT "\n", P->nnode_pre); _NEXT_PRE_IMP(P)
#else 
#define _NEXT_PRE_IF(P) { _NEXT_PRE_IMP(P) 
#endif

#define NEXT_PRE_FAIL(P)    _NEXT_PRE_IF(P) return GDK_FAIL; }} 
#define NEXT_PRE_BAILOUT(P) _NEXT_PRE_IF(P) BAILOUT(P); }} 


/**
 * enter new XML node into pre|size|level|prop|kind relation
 */
static int
emit_node(shredCtxStruct *shredCtx, 
          node_t *node)
{
    int nodeSize = shredCtx->nnode_pre-node->pre-1;
    if (nodeSize > GDK_int_max) {
            GDKerror("emitNode: size(%d) >= GDK_int_max(%d)\n", nodeSize, GDK_int_max);
            return GDK_FAIL;
    }
    return emit_tuple(shredCtx, node->pre, nodeSize, node->level, node->prop, node->kind, node->nid);
}

/**
 * write buffered text content(if any) to prop|text relation
 */
static int 
emit_string(shredCtxStruct *shredCtx, char *s)
{
    node_t node;

    /* fill the node */
    node.pre   = shredCtx->nnode_pre;
    node.nid   = shredCtx->nnode_nid;
    NEXT_PRE_FAIL(shredCtx);
    node.level = shredCtx->level;
    node.kind  = PFTEXT;
    if ((node.prop=shredBAT_append_str(shredCtx, PROP_TEXT, s)) == oid_nil)
        return GDK_FAIL;

    /* enter text node into pre|size|level|prop|kind relation */
    if (!emit_node(shredCtx, &node))
        return GDK_FAIL;
    return GDK_SUCCEED;
}

/* ====================================================================================
 * misc shredder helper functions
 * - handle_xml_chars()   buffered string reader
 * - handle_pfx_uri_loc() administer double-eliminated use of Q-Names 
 * - handle_idref()       register the definition of ID tags and their IDREF references
 * - handle_ext_subset()  handle a DTD (external subset), needed to identify ID/IDREF attrs
 * ==================================================================================== */

static int 
handle_xml_chars(shredCtxStruct *shredCtx)
{
    /* is there any buffered text content? */
    if (shredCtx->content) {
        shredCtx->content_buf[shredCtx->content] = 0; /* properly terminate string content_buf */

        if (!emit_string(shredCtx, shredCtx->content_buf))
            return GDK_FAIL;
        if (shredCtx->serFun) {
                shredCtx->serFun->handle_characters(shredCtx->serCtx,(str)shredCtx->content_buf);
        }
    }
    shredCtx->content = 0;
    return GDK_SUCCEED;
}

static oid 
handle_pfx_uri_loc(shredCtxStruct *shredCtx, 
                   char *a_pfx, 
                   char *a_uri, 
                   char *a_tag)
{
    char *key = shredCtx->val;
    char *cur = key;
    char *end = key + PFSHRED_BUFLEN-3;
    char *src, *uri;
    BAT *histo = shredCtx->dstBAT[QN_HISTOGRAM].bat;
    lng cnt = 1;

    if (a_pfx == NULL) a_pfx = "";
    if (a_uri == NULL) a_uri = "";
    if (a_tag == NULL) a_tag = "";

    /* concatenate pfx:uri:loc */
    for(src=a_pfx; *src && cur < end; src++,cur++) *cur = *src;
    *cur++ =(char) ':';
    uri = cur;
    for(src=a_uri; *src && cur < end; src++,cur++) *cur = *src;
    *cur++ =(char) ':';
    for(src=a_tag; *src && cur < end; src++,cur++) *cur = *src;
    *cur++ =  0;

    oid lim = BATcount(shredCtx->dstBAT[QN_PREFIX_URI_LOC].bat); 
    oid res = shredBAT_append_str(shredCtx, QN_PREFIX_URI_LOC, key);
    if (res == lim  &&
        res == shredBAT_append_str(shredCtx, QN_URI_LOC, uri) &&
        res == shredBAT_append_str(shredCtx, QN_PREFIX, a_pfx) &&
        res == shredBAT_append_str(shredCtx, QN_URI, a_uri) &&
        res == shredBAT_append_str(shredCtx, QN_LOC, a_tag))
    {
        return BUNappend(histo, &cnt, TRUE)?res:oid_nil;
    } else if (res != oid_nil) {
        BUN p = BUNlast(histo) - BUNsize(histo);
        cnt = 1 + *(lng*) BUNtloc(histo,p);
        return BUNinplace(histo, p, NULL, &cnt, TRUE)?res:oid_nil;
    }
    return oid_nil;
}

#define ISSPACE(x)(((x) == ' ') |((x) == '\t') |((x) == '\n'))

static int 
handle_idref(shredCtxStruct *shredCtx, 
             char  *ownerTag, 
             oid   pre, 
             str   attrTag, 
             str   attrVal, 
             int   attrType)
{
#ifdef ADB_DEBUG
    stream_printf(GDKout, "handle_idref(own=%s, pre=%d, pfxloc=%s, v=\"%s\") = %d\n", ownerTag, pre, attrTag, attrVal, attrType);
#endif
    shredBAT *sb = &shredCtx->dstBAT[(attrType == XML_ATTRIBUTE_ID) ? ID_NID : IDREF_NID];
    char *src = attrVal;

    while(*src) {
        char *end, *dst = shredCtx->val; /* points into shredCtx->val_prefix that already contains '<rootnid>_' prefix */

        while(*src && ISSPACE(*src)) src++; /* skip spaces */

        /* copy '<ID>' until space or EOS */
        for(end = src+PFSHRED_BUFLEN; *src && !ISSPACE(*src); src++) 
                if (src < end) *dst++ = *src; /* truncate too long id's */
        *dst = 0;
        if (src >= end) {
            stream_printf(GDKout, "!WARNING: handle_idref(own=%s, pre=%d, pfxloc=%s, v=\"%s\") TRUNCATED!\n", ownerTag, pre, attrTag, shredCtx->val);
        }
        if (attrType == XML_ATTRIBUTE_ID) {
            src = dst; /* hack: makes it exit the loop */
        }
        if (!*shredCtx->val) continue; /* ignore IDs that are the empty string */

        /* now the preallocated string buffer shredCtx->val_prefix contains '<rootnid>_<ID>' */
        if (attrType == XML_ATTRIBUTE_ID) {
            /* we must ignore duplicate IDs(see W3C XPath functions and operators spec) */
            BUN bun;
            HASHfnd_str(bun, sb->bat, shredCtx->val_prefix);
            if (bun) {
                sb->dupl++;
                continue;
            }
            if (BATcount(sb->bat) > 4 * sb->bat->hhash->mask) {
                HASHdestroy(sb->bat); /* keeps hash performance in check */
                BAThash(BATmirror(sb->bat), 2*BATcount(sb->bat));
            }
        }
        if (!BUNins(sb->bat, shredCtx->val_prefix, &pre, TRUE)) {
            GDKerror("handle_idref: append() for handle_idref(own=%s, pre=" OIDFMT ", pfxloc=%s, v=\"%s\") = %d FAILED\n", 
                     ownerTag, pre, attrTag, shredCtx->val_prefix, attrType);
            return GDK_FAIL;
        }
        sb->size++;
    }
    return GDK_SUCCEED;
}

static int 
handle_ext_subset(shredCtxStruct *shredCtx, 
                  xmlDtdPtr dtd)
{
    struct _xmlNode *p = dtd->children;

    while(p) {
        if (p->type == XML_ATTRIBUTE_DECL) {
            xmlAttributePtr ap =(xmlAttributePtr)p;

            switch(ap->atype) {
                case XML_ATTRIBUTE_ID:
                case XML_ATTRIBUTE_IDREF:
                case XML_ATTRIBUTE_IDREFS:
                    if (!attrDB_insert(&shredCtx->idrefAttrDB,(char*)ap->elem,(char*)ap->name, ap->atype)) {
                        return GDK_FAIL;
                    }
                    break;
                default:
                    break; /* ignore */
            }
        }
        p = p->next;
    }
    return GDK_SUCCEED;
}


/* ====================================================================================
 * SAX2 callback functions 
 * - shred_start_document()
 * - shred_end_document()
 * - shred_start_element()
 * - shred_end_element()
 * - shred_characters()
 * - shred_cdata()
 * - shred_pi()
 * - shred_comment()
 * - shred_attribute_def()
 * - shred_external_subset()
 * - shred_error()
 * ==================================================================================== */

static void 
shred_start_document(void *xmlCtx)
{
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;
#ifdef DEBUG
    stream_printf(GDKout, "start_document()\n");
#endif
    /* initialize some pre-post plane parameters. The nnode_pre and nnode_attr
     * parameters are initizalized in the shredder_create() initialization 
     * function.
     */
    shredCtx->level      = 0;
    shredCtx->depth      = 0;
    shredCtx->content    = 0;

    /* push document node */
    PUSH(shredCtx,((node_t) { 
                .pre   = shredCtx->nnode_pre, 
                .nid   = shredCtx->nnode_nid, 
                .level = -1, 
                .prop  = oid_nil, 
                .kind  = DOCUMENT
                }));
    NEXT_PRE_BAILOUT(shredCtx);

    if (shredCtx->serFun) {
#ifdef DEBUG
        stream_printf(GDKout, "CALL %s:start_document()\n", shredCtx->serFun->name);
#endif
            shredCtx->serFun->init(shredCtx->serCtx, "", NULL, NULL);
            shredCtx->serFun->handle_startDocument(shredCtx->serCtx);
    }
}

static void 
shred_end_document(void *xmlCtx)
{
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;

    /* pop document node and enter into pre|size|level|prop|kind relation */
    if (!emit_node(shredCtx, &POP(shredCtx))) {
        BAILOUT(shredCtx);
    }
    if (shredCtx->serFun)
            shredCtx->serFun->handle_endDocument(shredCtx->serCtx);
#ifdef DEBUG
    stream_printf(GDKout, "end_document()\n");
#endif
}



/**
 * SAX callback, invoked whenever `<t ...>' is seen
 */
static void 
shred_start_element(void *xmlCtx,
                    const xmlChar *e_loc, 
                    const xmlChar *e_pfx, 
                    const xmlChar *e_uri, 
                    int n_namespaces, 
                    const xmlChar **namespaces, 
                    int n_atts, 
                    int n_defaulted, 
                    const xmlChar **atts)
{
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;
    node_t node;
    oid qn_id, val_id;

   (void)n_defaulted;
   (void)n_namespaces; 
   (void)namespaces; 

    if (!handle_xml_chars(shredCtx)) {
        BAILOUT(shredCtx);
    }
    /*(1) assign preorder rank(document order), size, level, and kind */
    node.pre   = shredCtx->nnode_pre;
    node.nid   = shredCtx->nnode_nid;
    NEXT_PRE_BAILOUT(shredCtx);
    node.level = shredCtx->level;
    node.kind  = ELEMENT;

    /* descend one level */
    if (shredCtx->level++ >= XML_DEPTH_MAX) {
        GDKerror("shred_start_element: max document nesting exceeded: %d > MAX == %d\n", shredCtx->level, XML_DEPTH_MAX);
        BAILOUT(shredCtx);
    }

    /* keep track of document depth */
    if (shredCtx->level > shredCtx->depth)
        shredCtx->depth = shredCtx->level;

#ifdef DEBUG
    stream_printf(GDKout, " start_element(");
    if (e_uri) stream_printf(GDKout, "uri=%s, ", e_uri);
    if (e_pfx) stream_printf(GDKout, "pfx=%s, ", e_pfx);
    stream_printf(GDKout, "lev=%d", node.level);
    stream_printf(GDKout, "loc=%s", e_loc);
    stream_printf(GDKout, ")\n");
#endif
    if ((node.prop = handle_pfx_uri_loc(shredCtx, (char*) e_pfx, (char*) e_uri, (char*) e_loc)) == oid_nil) {
        BAILOUT(shredCtx);
    }
    if (shredCtx->serFun) {
        /* INCOMPLETE, should handle ns better here(uri+pfx) */
            shredCtx->serFun->handle_startElement(shredCtx->serCtx,(str)e_pfx,(str)e_loc,(oid)node.pre);
    }

    /* push node onto node stack: size to be determined later */
    PUSH(shredCtx, node);

    /*(2) process the elements attribute(s) */
    int i;
    for(i=0;i<(5*n_atts); i+=5) {
        const xmlChar *a_tag = atts[i];
        const xmlChar *a_pfx = atts[i+1];
        const xmlChar *a_uri = atts[i+2];
        const xmlChar *a_val = atts[i+3];
        const xmlChar *a_end = atts[i+4];

        xmlChar qiChar = *a_end; /* remember char value */
        *(xmlChar*)a_end = 0; /* UGLY HACK: ignore const modifier */
#ifdef DEBUG
        stream_printf(GDKout, "  attr(");
        if (a_uri) stream_printf(GDKout, "uri=%s, ", a_uri);
        if (a_pfx) stream_printf(GDKout, "pfx=%s, ", a_pfx);
        stream_printf(GDKout, "tag=%s", a_tag);
        stream_printf(GDKout, ", val=\"%s\"", a_val);
        stream_printf(GDKout, ")\n");
#endif
        if (!a_pfx && a_uri) { 
          a_uri = NULL; /* attribute without prefix cannot have a namespace */
        }

        /* INCOMPLETE, this value stuff should be done properly by libxml2, but how? */
        val_id = shredBAT_append_str(shredCtx, PROP_VAL,(char*)a_val);
        qn_id  = handle_pfx_uri_loc(shredCtx, (char*) a_pfx, (char*) a_uri, (char*) a_tag);
        oid ownerPre = node.nid;

        /* insert attribute tuple */
        oid nattr = shredCtx->nnode_attr++; 
        if (qn_id == oid_nil || val_id == oid_nil || nattr == GDK_oid_max) {
            GDKerror("shredder: failed inserting RID tuple " OIDFMT " \n", nattr); 
            BAILOUT(shredCtx);
        }
        if (nattr >= shredCtx->dstBAT[ATTR_OWN].size) {
            size_t newsize = shredBAT_newsize(&shredCtx->dstBAT[ATTR_OWN], nattr);
            if (!(newsize &&
                  shredBAT_extend(&shredCtx->dstBAT[ATTR_OWN],  newsize) &&
                  shredBAT_extend(&shredCtx->dstBAT[ATTR_QN],   newsize) &&
                  shredBAT_extend(&shredCtx->dstBAT[ATTR_PROP], newsize)))
            {
                BAILOUT(shredCtx);
            }
        }
        shredCtx->dstBAT[ATTR_OWN].cast.oidCAST[nattr] = ownerPre;
        shredCtx->dstBAT[ATTR_QN].cast.oidCAST[nattr] = qn_id;
        shredCtx->dstBAT[ATTR_PROP].cast.oidCAST[nattr] = val_id;

        int attrType;
        if ((attrType = attrDB_check(&shredCtx->idrefAttrDB,(char*)e_loc,(char*)a_tag))) {
            if (!handle_idref(shredCtx,(char*)e_loc, node.pre,(char*)a_tag,(char*)a_val, attrType)) {
                BAILOUT(shredCtx);
            }
        }
        *(xmlChar*)a_end = qiChar;              /* restore the quote */
        /* process next attribute */
        if (shredCtx->serFun) {
            shredCtx->serFun->handle_attribute(shredCtx->serCtx,(str)a_pfx,(str)a_tag,(str)a_val);
        }
    }
    if (shredCtx->serFun) {
        /* INCOMPLETE, should handle this emptyNode better */
        shredCtx->serFun->complete_startElement(shredCtx->serCtx);
    }
}


/** 
 * SAX callback invoked whenever `</t>' is seen
 */
static void 
shred_end_element(
        void *xmlCtx,
        const xmlChar *localname,
        const xmlChar *prefix, 
        const xmlChar *URI) 
{
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;
    node_t node;

   (void) prefix;
   (void) URI;
    if (!handle_xml_chars(shredCtx)) {
        BAILOUT(shredCtx);
    }

    node = POP(shredCtx);

    /* ascend up one level */
    shredCtx->level--;

    /* enter element node into pre|size|level|prop|kind relation */
    if (!emit_node(shredCtx, &node)) {
        BAILOUT(shredCtx);
    }
    if (shredCtx->serFun) {
        /* INCOMPLETE: check here for empty tag */
            shredCtx->serFun->handle_endElement(shredCtx->serCtx,(str)"",(str)localname);
    }
#ifdef DEBUG
    stream_printf(GDKout, " end_element(%s)\n", localname);
#endif
}

/**
 * SAX callback invoked whenever text node content is seen, 
 * simply buffer the content here
 */
static void 
shred_characters(void *xmlCtx,
                 const xmlChar *cs, 
                 int n)
{
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;
    int l = MIN(PFSHRED_STRLEN_MAX -(int) shredCtx->content, n);

    memcpy(&(shredCtx->content_buf[shredCtx->content]), cs, l);
    shredCtx->content += l;

    if (l < n)
        stream_printf(GDKout, "!WARNING: shred_characters truncated text node > %d characters(starts with `%.16s...')\n", 
               (int) PFSHRED_STRLEN_MAX, cs);
}

/**
 * SAX callback invoked whenever `<![CDATA[...]]>' is seen
 */
static void 
shred_cdata(void *xmlCtx,
            const xmlChar *cdata, 
            int n)
{
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;
    shred_characters(shredCtx, cdata, n);
}

/** 
 * SAX callback invoked whenever `<?target ins?>' is seen
 */
static void 
shred_pi(void *xmlCtx,
         const xmlChar *tgt, 
         const xmlChar *ins)
{
    /*
     * incomplete, do not compress tgt ins properties yet. 
     */
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;
    node_t node;

    if (!handle_xml_chars(shredCtx)) {
        BAILOUT(shredCtx);
    }

    node.pre   = shredCtx->nnode_pre;
    node.nid   = shredCtx->nnode_nid;
    NEXT_PRE_BAILOUT(shredCtx);
    node.level = shredCtx->level;
    node.kind  = PI;
    node.prop = shredBAT_append_str(shredCtx, PROP_TGT,(char*)tgt);
    if (node.prop != shredBAT_append_str(shredCtx, PROP_INS,(char*)ins)) {
        GDKerror("shred_pi: tgt-ins sync error\n");
        BAILOUT(shredCtx);
    }

    /* enter p-i node into pre|size|level|prop|kind relation */
    if (!emit_node(shredCtx, &node)) {
        BAILOUT(shredCtx);
    }
    if (shredCtx->serFun)
            shredCtx->serFun->handle_processingInstruction(shredCtx->serCtx,(str)tgt,(str)ins);
}

static void 
shred_comment(void* xmlCtx,
              const xmlChar *c)
{
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;
    node_t node;

    if (!handle_xml_chars(shredCtx)) {
        BAILOUT(shredCtx);
    }

    node.pre   = shredCtx->nnode_pre;
    node.nid   = shredCtx->nnode_nid;
    NEXT_PRE_BAILOUT(shredCtx);
    node.level = shredCtx->level;
    node.kind  = COMMENT;
    node.prop = shredBAT_append_str(shredCtx, PROP_COM,(char*)c);

    /* enter comment node into pre|size|level|prop|kind relation */
    if (!emit_node(shredCtx, &node)) {
        BAILOUT(shredCtx);
    }
    if (shredCtx->serFun)
            shredCtx->serFun->handle_comment(shredCtx->serCtx,(str)c);
}

static void 
shred_error(void *ctx, 
            const char *msg, ...) 
{
    /* IMPORTANT this function may be called multiple times for one error
     * message so it is not possible to use GDKerror() here.
     * Instead, we "mis-use" the ctx pointer to remember whether a newline
     * has occured in the error message, and thus be able to prefix each
     *(line of an) error message with GDKERROR("!Error: "), which is
     * required to properly get the error message through the MAPI
     * protocol...
     */
    va_list args;
    int *print_error_newline =(int*)ctx;
    int len = 0;
    char buf[PFSHRED_BUFLEN];

    if (*print_error_newline) {
        len += snprintf(buf+len, PFSHRED_BUFLEN-len-1, GDKERROR);
    }

    va_start(args, msg);
    len += vsnprintf(buf+len, PFSHRED_BUFLEN-len-1, msg, args);
    va_end(args);

    *print_error_newline =(strchr(buf,(int)'\n') != NULL);
    stream_printf(GDKerr, "%s", buf);
}

/** 
 * The shred_attribute_defAttributeDef() handles the DTD attribute definition callbacks
 * in the from the header of the XML file. This is used for the ID/IDREF
 * handeling of the shredder.
 */
static void 
shred_attribute_def(void *xmlCtx,
                    const xmlChar *elem, 
                    const xmlChar *fullname, 
                    int type, 
                    int def, 
                    const xmlChar *defaultValue, 
                    xmlEnumerationPtr tree) 
{
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;
   (void)def; /* XML_ATTRIBUTE_(NONE|REQUIRED:IMPLIED) */
   (void)*defaultValue;
   (void)tree;

    switch(type) {
        case XML_ATTRIBUTE_ID:
        case XML_ATTRIBUTE_IDREF:
        case XML_ATTRIBUTE_IDREFS:
            if (!attrDB_insert(&shredCtx->idrefAttrDB,(char*)elem,(char*)fullname, type)) {
                BAILOUT(shredCtx);
            }
            break;
    }
}

static void 
shred_external_subset(void *xmlCtx,
                      const xmlChar *name, 
                      const xmlChar *ExternalID, 
                      const xmlChar *SystemID)
{
    shredCtxStruct *shredCtx = (shredCtxStruct*) xmlCtx;
   (void)name;
#ifdef ADB_DEBUG
    stream_printf(GDKout, "shred_external_subset(ctx, %s, %s, %s)\n", name, ExternalID, SystemID);
#endif
    if (ExternalID || SystemID) {
        /* INCOMPLETE, this part only works with absolute filenames or
         * files located in the current working directory! A bit more
         * inteligence could be applied here.
         */
        xmlDtdPtr dtd;

        if ((dtd=xmlParseDTD(ExternalID, SystemID))) {
            if (!handle_ext_subset(shredCtx, dtd))
                stream_printf(GDKout, "!WARNING: xmlParseDTD(\"%s\") failed, skipping ID/IDREF information.\n", SystemID);
            xmlFreeDtd(dtd);
        } else {
            GDKerror("shred_external_subset: WARNING: xmlParseDTD(\"%s\") FAILED, NO ID/IDREF QUERIES\n", SystemID);
            GDKerror("shred_external_subset: NOTE   : maybe using absolute filenames works, sorry!\n");
            BAILOUT(shredCtx);
        }
    }
}

/* ====================================================================================
 * the shredder and its data structures
 * - shredder_create()     create all data structures
 * - shredder_parse()      invoke the libxml2 SAX2 parser
 * - shredder_stats()      print some statistics (off by default)
 * - shredder_finalize()   finish the bats in case of a succesful parse
 * - shredder_free()       provides *atomic* cleanup
 * ==================================================================================== */

/**
 * SAX callback table.
 */
xmlSAXHandler shredder = {
    .startDocument         = shred_start_document
  , .endDocument           = shred_end_document
  , .startElement          = 0
  , .endElement            = 0
  , .characters            = shred_characters
  , .processingInstruction = shred_pi
  , .comment               = shred_comment
  , .error                 = 0
  , .cdataBlock            = shred_cdata
  , .internalSubset        = 0
  , .isStandalone          = 0
  , .hasInternalSubset     = 0
  , .hasExternalSubset     = 0
  , .resolveEntity         = 0
  , .getEntity             = 0
  , .entityDecl            = 0
  , .notationDecl          = 0
  , .attributeDecl         = shred_attribute_def
  , .elementDecl           = 0
  , .unparsedEntityDecl    = 0
  , .setDocumentLocator    = 0
  , .reference             = 0
  , .ignorableWhitespace   = 0
  , .warning               = 0
  , .fatalError            = 0
  , .getParameterEntity    = 0
  , .externalSubset        = shred_external_subset 
  , .startElementNs        = shred_start_element
  , .endElementNs          = shred_end_element
  , .initialized           = XML_SAX2_MAGIC /* set this to zero for SAX1 */
};

#ifndef XML_PARSE_NOXINCNODE
#define XML_PARSE_NOXINCNODE 0
#endif

/**
 * Main shredder driver handling the libxml2 and buffer stuff
 */
static int 
shredder_parse(shredCtxStruct *shredCtx, 
               char *location, 
               char *buffer,
               stream *s)
{
    int print_error_newline = TRUE;
    int wellFormed = 0;
    char buf[BUFSIZ];
    xmlParserCtxtPtr xmlCtx = NULL;

    /* reset libxml2 error handling */
    xmlSetGenericErrorFunc((void*)&print_error_newline, shred_error);

    /* parse XML input(receive SAX events) */
    if (s) {
        xmlCtx = xmlCreatePushParserCtxt(&shredder, shredCtx, buf, 0, "shredder");
    } else if (buffer) {
        xmlCtx = xmlCreateMemoryParserCtxt(buffer, shredCtx->fileSize);
    } else {
        xmlCtx = xmlCreateURLParserCtxt(location, XML_PARSE_XINCLUDE|XML_PARSE_NOXINCNODE);
    } 
    if (!xmlCtx) {
        GDKerror("shredder_parse: libxml2 could not initialize a parser.\n");
        return GDK_FAIL;
    }
    xmlCtx->sax      = &shredder;
    xmlCtx->userData = shredCtx; /* set the SHREDCTX() value */
    shredCtx->xmlCtx = xmlCtx; /* point back */
    xmlSwitchEncoding(xmlCtx, XML_CHAR_ENCODING_UTF8);
    if (s) { 
        while(1) {
            ssize_t len = stream_read(s, buf, 1, sizeof(buf));
            if (len < 0) {
                stream_printf(GDKout, "!WARNING: shredder_parse: read() returned " SSZFMT " -> bailing out\n", len);
                shredCtx->err = 1;
                break;
            }
            if (len <= 0) {
                xmlParseChunk(xmlCtx, buf, 0, 1);
                break;
            } else {
                buf[len] = '\0';
                xmlParseChunk(xmlCtx, buf, len, 0);
            }
        }
    } else {
       (void) xmlParseDocument(xmlCtx);
    } 
    wellFormed = xmlCtx->wellFormed;
    xmlCtx->sax = NULL; /* avoid double free() */
    xmlCtx->userData = NULL; /* avoid double free() */
    xmlFreeParserCtxt(xmlCtx);

    /* Check if something has gone wrong during shred */
    if (shredCtx->err) {
        return GDK_FAIL;
    }
    if (!wellFormed) {
        GDKerror("shredder_parse: XML input not well-formed.\n");
        return GDK_FAIL;
    }
    return GDK_SUCCEED;
}



static shredCtxStruct*
shredder_free(shredCtxStruct *shredCtx, 
              int status) /* -1 abort, 0 cleanup, 1 commit */
{
    int i;
    for(i=0; i<SHRED_BATS; i++) {
        shredBAT *sb = &shredCtx->dstBAT[i];
        if (sb->bat) {
            if (status == 1) { /* succeed */
                sb->bat->batDirty = 1;
            } else if (status == -1) { /* abort */
                if (sb->bat->ttype == TYPE_str) {
                     /* restore the heap to the state before shredding */
                    sb->bat->theap->free = sb->heapSize; 
                    if (sb->heapBackup) {
                        /* restore internal hash table to pre-state */
                        memcpy(sb->bat->theap->base, sb->heapBackup, GDK_STRHASHTABLE*sizeof(var_t));
                    } else {
                        /* zap internal hash table. is not critical */
                        memset(sb->bat->theap->base, 0, GDK_STRHASHTABLE*sizeof(var_t));
                    }
                }
                shredBAT_setcount(&shredCtx->dstBAT[i], sb->abortSize);
            }
            BBPunfix(sb->bat->batCacheid);
        }
        if (sb->heapBackup) GDKfree(sb->heapBackup);
    }
    if (shredCtx->lifo) {
        GDKfree(shredCtx->lifo);
    }
    if (shredCtx->content_buf) {
        GDKfree(shredCtx->content_buf);
    }
    if (shredCtx->val_prefix) {
        GDKfree(shredCtx->val_prefix);
    }
    attrDB_free(&shredCtx->idrefAttrDB);
    GDKfree(shredCtx);
    return NULL;
}

static shredCtxStruct*
shredder_create(char *location, 
                size_t fileSize, 
                size_t pageFree, 
                struct serializeFunStruct *serFun, 
                struct XqueryCtx *serCtx, 
                BAT *docBAT,
                MT_Lock *coll_lock,
                int verbose) 
{
    if (BATcount(docBAT) && BATcount(docBAT) != SHRED_BATS) {
        GDKerror("shredder_create: docBAT should be empty or have exactly %d buns.\n", SHRED_BATS);
        return NULL;
    }

    /* allocate parsing context */
    shredCtxStruct *shredCtx =(shredCtxStruct*)GDKmalloc(sizeof(shredCtxStruct));
    if (shredCtx == NULL) return NULL;

    /* fill it */
    int i = 4;
    memset(shredCtx, 0, sizeof(shredCtxStruct)); 
    shredCtx->location  = location;
    shredCtx->fileSize  = fileSize;
    shredCtx->estSize   = (size_t) MIN(MAX(BATTINY, fileSize/20), INT_MAX);
    shredCtx->serFun    = serFun;
    shredCtx->serCtx    = serCtx;
    shredCtx->coll_lock = coll_lock;
    {
    /* avoid "dereferencing type-punned pointer will break strict-aliasing rules" with gcc >= 4.1 */
    /* (void) CMDpflock_get((ptr*) &(shredCtx->extend_sema), &i); */
    ptr s = (ptr)shredCtx->extend_sema;
    (void) CMDpflock_get(&s, &i);
    shredCtx->extend_sema = s;
    }
    shredCtx->incremental = (BATcount(docBAT) > 0);

    /* init the idref attribute database */
    attrDB_init(&shredCtx->idrefAttrDB);

    int xx = BUNsize(docBAT);
    BUN p = BUNfirst(docBAT);
    for(i=0; i<SHRED_BATS; i++, p+=xx) {
        shredBAT *sb = &shredCtx->dstBAT[i];
        sb->def = &shredbatdef[i];
        sb->dupl = 0;
        sb->size = 0;

        if (shredCtx->incremental) {
            /* be very picky with the BATs in docBAT: check, check and check  */
            str name = strchr(BUNhead(docBAT,p), '_');
            if (strcmp(name, shredbatdef[i].name)) {
                GDKerror("shredder_create: name suffix of %s does not match %s\n", name, shredbatdef[i].name);
                return shredder_free(shredCtx, 0);
            }
            /* get and pin the bats in docBAT  */
            bat bid = *(bat*) BUNtloc(docBAT,p);
            sb->bat = BATdescriptor(bid);
            if (sb->bat == NULL) { 
                GDKerror("shredder_create: docBAT (batid %d) contains illegal bat.\n", bid);
                return shredder_free(shredCtx, 0);
            }
            if (sb->bat->htype != shredbatdef[i].headType || 
                ATOMtype(sb->bat->ttype) != ATOMtype(shredbatdef[i].tailType)) 
            {
                GDKerror("shredder_create: %s[%s,%s] (batid %d) should have types [%s,%s].\n", 
                    sb->def->name, ATOMname(sb->bat->htype), ATOMname(sb->bat->htype), sb->bat->batCacheid,
                                   ATOMname(shredbatdef[i].headType), ATOMname(shredbatdef[i].tailType));
                return shredder_free(shredCtx, 0);
            }
            if (shredbatdef[i].headType == TYPE_void && sb->bat->ttype && BUNsize(sb->bat) != ATOMsize(sb->bat->ttype)) { 
                GDKerror("shredder_create: %s[void,%s] (batid %d) is not really void (i.e. a view on %d).\n", 
                    sb->def->name, ATOMname(sb->bat->htype), sb->bat->batCacheid, sb->bat->batParentid);
                return shredder_free(shredCtx, 0);
            }
            if ((shredbatdef[i].headType == TYPE_void && sb->bat->hseqbase) ||
                (BATcount(sb->bat) != BATcount(shredCtx->dstBAT[sb->def->table].bat))) 
            {
                GDKerror("shredder_create: %s (batid %d) is not aligned with %s (batid %d).\n",
                    sb->def->name,  sb->bat->batCacheid,
                    shredCtx->dstBAT[sb->def->table].def->name,  
                    shredCtx->dstBAT[sb->def->table].bat->batCacheid);
                return shredder_free(shredCtx, 0);
            }
            if (!sb->def->compress) {
                HASHremove(sb->bat); /* we don't maintain accelerators other than those explicity needed for compress */
            }
            sb->size = ((sb->bat->batBuns->base + sb->bat->batBuns->size) - BUNfirst(sb->bat))/BUNsize(sb->bat);

            /* record information on the current size. To be used in case of aborts (shred errors) */ 
            sb->abortSize = BATcount(sb->bat);
            if (sb->def->tailType == TYPE_str) {
                sb->heapSize = sb->bat->theap->free;
                if (GDK_ELIMDOUBLES(sb->bat->theap)) {
                    sb->heapBackup = GDKmalloc(GDK_STRHASHTABLE*sizeof(var_t));
                    if (!sb->heapBackup) {
                        GDKerror("shredder_create: malloc failure\n");
                        return shredder_free(shredCtx,0);
                    } 
                    memcpy(sb->heapBackup, sb->bat->theap->base, GDK_STRHASHTABLE*sizeof(var_t));
                }
            }
        } else {
            /* new empty collection */
            int ht = sb->def->headType;
            int tt = sb->def->tailType;

            /* The MAP_PID, PRE_NID and NID_RID are generated as a [void, void] BATs in the read-only case. 
             * When holes are generated however they get 'real' content and should be [void, oid].
             */
            if ((i == PRE_NID || i == NID_RID || i == MAP_PID) && pageFree) {
                tt = TYPE_oid;
            }
            sb->bat = BATnew(ht, tt, BATTINY);
            if (tt == TYPE_void) BATseqbase(BATmirror(sb->bat), 0);
            BATseqbase(sb->bat, 0);
        }
        if (!sb->bat) {
            GDKerror("shredder_create: BATnew(%d) for %s fails, disk full?\n", sb->size, sb->def->name);
            return shredder_free(shredCtx,0);
        }

        /* estimate the tab_size (i.e. the size of the leader) if not yet done */
        oid tab_size = shredCtx->dstBAT[sb->def->table].size;
        if (tab_size == 0) {
            tab_size = BATcount(sb->bat) + (sb->def->sizeFact * shredCtx->estSize);
        }
        /* make sure the bat is at least as big as its leader (that is later used to check overflow) */
        oid cur_size = ((sb->bat->batBuns->base + sb->bat->batBuns->size) - BUNfirst(sb->bat))/BUNsize(sb->bat);
        if (cur_size < tab_size) {
            sb->size = BATcount(sb->bat);
            if (!shredBAT_extend(sb, tab_size)) return shredder_free(shredCtx, 0);
        }
        sb->cast.voidCAST =(void*)BUNfirst(sb->bat);
    }
    BAT* map_pid = shredCtx->dstBAT[MAP_PID].bat;
    shredCtx->updatable = (map_pid->ttype == TYPE_oid);
    if (shredCtx->updatable) {
        if (shredCtx->dstBAT[PRE_NID].bat->ttype == TYPE_void || shredCtx->dstBAT[NID_RID].bat->ttype == TYPE_void) {
            GDKerror("shredder_create: updatable collection should have materialized NID-RID mappings\n");
            return shredder_free(shredCtx,0);
        }
    } else {
        if (shredCtx->dstBAT[PRE_NID].bat->ttype == TYPE_oid || shredCtx->dstBAT[NID_RID].bat->ttype == TYPE_oid) {
            GDKerror("shredder_create: read-only collection cannot have materialized NID-RID mappings\n");
            return shredder_free(shredCtx,0);
        }
        if (verbose && pageFree) {
            stream_printf(GDKout, "!WARNING: cannot make a read-only collection writable (set pageFree to 0).\n");
            pageFree = 0;
        }
    }
    /* convert pageFree into the per-page offset after which the generated tuples are NIL */
    if (pageFree) {
        pageFree = REMAP_PAGE_SIZE - (REMAP_PAGE_SIZE*pageFree)/100; 
    }
    shredCtx->pageFree = pageFree;
    if (verbose && pageFree) {
        stream_printf(GDKout, "# shredding with holes: pagesize=%d, #fillsize=%d\n", REMAP_PAGE_SIZE, pageFree);
    }

    if (!shredCtx->incremental) {
        /* first shred into new collection */
        map_pid->hseqbase = 0;
        if (shredCtx->updatable) {
            /* initially map_pid is dense, though it is updatable and may not stay so later */
            map_pid->tsorted = GDK_SORTED;
            map_pid->tdense = 1;
            BATkey(BATmirror(map_pid), 1);
        }
        /* super root=0, first document node=1 */  
        if (!emit_node(shredCtx, &((node_t) { .pre   = 0, 
                                              .nid   = 0, 
                                              .level = -2, 
                                              .prop  = oid_nil, 
                                              .kind  = COLLECTION })))
        {
            GDKerror("shredder_create: writing super root fails!\n");
            return shredder_free(shredCtx,-shredCtx->updatable);
        }
        shredCtx->nnode_pre = 1; 
        shredCtx->nnode_nid = 1; 
    } else {
        /* incremental shred into existing collection */
        shredCtx->nnode_attr = BATcount(shredCtx->dstBAT[ATTR_OWN].bat); /* attribute value property ID */
        shredCtx->nnode_pre  = BATcount(shredCtx->dstBAT[PRE_SIZE].bat);  /* next rid = first available pre */
        shredCtx->nnode_base = shredCtx->nnode_pre; 

        /* NOTE: in incremental shreds, we append after the highest rid - we no not use space in unused pages. 
         * Problem with unused pages is that they may be on the free_page list, and can be given out to 
         * update queries without getting the shred-lock, concurrently with a shred (so that not all updates will 
         * be blocked by a shred). This policy also ensures initial physical adjancency in newly shredded documents.
         */
        oid pre_min = 1;
        if (shredCtx->updatable) {
            /* go back over unused nodes inside the last strech of *used* pages */ 
            size_t  off = BUNindex(map_pid, BUNfirst(map_pid));
            ssize_t pos = BATcount(map_pid);
            while(pos-- > 0) {
                BUN p = BUNptr(map_pid, off+pos); 
                if (*(oid*) BUNtloc(map_pid, p) == oid_nil) { /* nil = unused */
                    pre_min = (1+pos) << REMAP_PAGE_BITS;
                    break;
                }
            }
        } 
        if (shredCtx->nnode_pre <= pre_min) {
            shredCtx->nnode_pre = pre_min;
        } 
        while(shredCtx->nnode_pre > pre_min && 
              shredCtx->dstBAT[PRE_KIND].cast.chrCAST[shredCtx->nnode_pre-1] == chr_nil)
        {
            shredCtx->nnode_pre--; /* walk back over unused space */
        }
        shredCtx->nnode_nid = BATcount(shredCtx->dstBAT[NID_RID].bat);
    }
    shredCtx->pre_nid = shredCtx->nnode_pre - shredCtx->nnode_nid;

    /* log start of fragment */
    oid zero = 0; /* 0 is an impossible doc_id; the right docid is substoituted here later */
    if (BUNins(shredCtx->dstBAT[FRAG_ROOT].bat, &zero, &shredCtx->nnode_nid, TRUE) == NULL) {
        GDKerror("shredder_create: saving frag_root fails!\n");
        return shredder_free(shredCtx,-shredCtx->updatable);
    }

    /* To comply with XQuery semantics in multi-doc collections, the ID/IDREF identifiers 
     * must be specific to each document in a collection. Our solution is to prefix
     * the ids by the document root NID (as a string, and followed by a '_').
     *
     * The shredCtx->val_prefix is a pre-allocated string during shredding that holds a buffer 
     * starting with this prefix ("nid_"). After it, there are PFSHRED_BUFLEN free bytes 
     *(aka, shredCtx->val, that is shredCtx->val points *into* shredCtx->val_prefix).
     */
    char buf[32], *src=buf;
    sprintf(buf, OIDFMT "@0_", shredCtx->nnode_nid); /* added "@0" saves one cast from oid to str in MIL */
    shredCtx->val = shredCtx->val_prefix = (char*) GDKmalloc(1+strlen(buf)+PFSHRED_BUFLEN);
    shredCtx->lifo =                    (node_t *) GDKmalloc((XML_DEPTH_MAX+1) * sizeof(node_t));
    shredCtx->content_buf =                (char*) GDKmalloc(PFSHRED_STRLEN_MAX);
    if (shredCtx->val_prefix == NULL || shredCtx->content_buf == NULL || shredCtx->lifo == NULL) {
        return shredder_free(shredCtx,-shredCtx->updatable);
    }
    while(*src) *(shredCtx->val)++ = *src++; 
    *(shredCtx->val) = 0;

    return shredCtx;
}


static void 
shredder_stats(shredCtxStruct *shredCtx)
{
    int i;

    stream_printf(GDKout, "############\n");
    stream_printf(GDKout, "# STATISTICS of shredding \"%s\":\n", shredCtx->location);
    for(i=0; i<SHRED_BATS; i++) {
        shredBAT *sb = &shredCtx->dstBAT[i];
        size_t cnt = BATcount(sb->bat);

        stream_printf(GDKout, "# [%9s, ", sb->def->name);
        stream_printf(GDKout, "cnt=%d", cnt);
        if (sb->def->compress) {
            stream_printf(GDKout, ", dupl=%d(=%.f%%) ", sb->dupl,((sb->dupl+cnt)?100.0*(float)(cnt)/(float)(sb->dupl+cnt):100.0));
        }
        if (i == PRE_SIZE)
            stream_printf(GDKout, ", eg. the number of document nodes");
        if (i == QN_PREFIX)
            stream_printf(GDKout, ", eg. the number of distinct tags");
        if (i == ATTR_OWN)
            stream_printf(GDKout, ", eg. the number of attributes");
        stream_printf(GDKout, "]\n");
    }
}


static int
shredder_finalize(shredCtxStruct *shredCtx, BAT *docBAT)
{
    oid i, p = 1 + ((shredCtx->nnode_pre-1) >> REMAP_PAGE_BITS);
    BAT *map_pid =shredCtx->dstBAT[MAP_PID].bat;

    /* adapt super node size */
    shredCtx->dstBAT[PRE_SIZE].cast.intCAST[0] = (int)(shredCtx->nnode_pre-1);

    /* fill the MAP_PID bat with an identity mapping */
    if (map_pid->ttype == TYPE_void) {
        shredBAT_setcount(&shredCtx->dstBAT[MAP_PID], p);
    } else {
        for(i=BATcount(map_pid); i< p; i++) {
            if (BUNfastins(map_pid, &i, &i) == NULL) { 
                GDKerror("shredder_finalize: could not append to MAP_PID!\n");
                return GDK_FAIL;
            }
        }
    }
    /* set the bats to their final size */
    size_t newsize = shredCtx->nnode_pre;
    if (shredCtx->updatable && newsize > REMAP_PAGE_SIZE) {
        /* we fill out memory mapped (big) rid_* bats to the next page boundary, as this speeds up remap */
        int delsize = (1<<31) + REMAP_PAGE_SIZE - (1+(newsize & REMAP_PAGE_MASK));
        while(newsize & REMAP_PAGE_MASK) {
            shredCtx->dstBAT[PRE_SIZE].cast.intCAST[newsize] = delsize;
            shredCtx->dstBAT[PRE_LEVEL].cast.chrCAST[newsize] = chr_nil;
            shredCtx->dstBAT[PRE_PROP].cast.oidCAST[newsize] = oid_nil;
            shredCtx->dstBAT[PRE_KIND].cast.chrCAST[newsize] = chr_nil;
            shredCtx->dstBAT[PRE_NID].cast.oidCAST[newsize] = oid_nil;
            newsize++;
            delsize++; /* it is negated by |(1<<31), so -- becomes ++ */
        }
    }
    for(i=PRE_SIZE; i<=PRE_NID; i++) {
        shredBAT_setcount(&shredCtx->dstBAT[i], newsize);
    }
    assert((shredCtx->updatable && shredCtx->nnode_nid <= newsize) || (!shredCtx->updatable && shredCtx->nnode_nid == newsize));
    shredBAT_setcount(&shredCtx->dstBAT[NID_RID], shredCtx->nnode_nid);
    for(i=ATTR_OWN; i<=ATTR_PROP; i++) {
        shredBAT_setcount(&shredCtx->dstBAT[i], shredCtx->nnode_attr);
    }

    /* fill result bat-of-bats */
    if (!shredCtx->incremental) {
        for(i=0; i<SHRED_BATS; i++) {
            shredBAT *sb = &shredCtx->dstBAT[i];
            if (sb->def->headType == TYPE_void && !BAThdense(sb->bat))
                stream_printf(GDKout, "!WARNING: BAT[%s] not dense\n", sb->def->name);
            sb->bat = BATsetaccess(sb->bat, BAT_READ);
            if (!BUNins(docBAT, sb->def->name, &sb->bat->batCacheid, TRUE)) {
                GDKerror("shredder_finalize: copy2result fails\n");
                return GDK_FAIL;
            }
        }
    }
    return GDK_SUCCEED; 
}


/* ====================================================================================
 * the implemented MIL commands:
 * - shred()           the routine that implements all
 * - CMDshred_url()    MIL command that shreds from a url
 * - CMDshred_str()    MIL command that shreds from a string
 * - CMDshred_stream() MIL command that shreds from a stream
 * ==================================================================================== */

#define DEFAULT_ESTIMATE        1048576

/* simplistic check whether location is an URL:
   protocols consist of more than one letter, so we consider location
   a URL if it starts with at least two letters, followed by a
   colon. */
static int 
isURL(char *location)
{
    int i = 0;
    while(*location &&(('a' <= *location && *location <= 'z') ||
                        ('A' <= *location && *location <= 'Z'))) {
        location++;
        i++;
    }
    return i > 1 && *location == ':';
}

/* all routines share this common implementation */
int
shred(BAT *docBAT, 
      str location, 
      str buffer, 
      stream *s,
      lng percentage, 
      struct serializeFunStruct *serFun, 
      struct XqueryCtx *serCtx, 
      lock *collLock)
{
    MT_Lock *coll_lock = (MT_Lock*) ((collLock && *collLock != ptr_nil)?*collLock:NULL);
    int verbose = (collLock == NULL);
    int res = GDK_FAIL;

    /* timing */
    lng start, stop;

    /* start timer */
    start = GDKusec();


    /* compute amount of free nodes per block from a percentage(opt string param) */
    size_t pageFree = percentage;
    if (percentage < 0 || percentage > 99) {
        GDKerror("shred: free-space percentage should be from range [0,99].\n");
        return GDK_FAIL;
    }

    size_t estimatedSize = DEFAULT_ESTIMATE;
    if (location) {
        struct stat statbuf;
        if (!isURL(location)) {
            if (stat(location, &statbuf) < 0 || (statbuf.st_mode & S_IFDIR)) {
                GDKerror("shred: cannot stat `%s': %s\n", location, strerror(errno));
                return GDK_FAIL;
            } 
            estimatedSize = statbuf.st_size;
        } 
    } else if (buffer) {
        if (*buffer == chr_nil) buffer++; /* treat str(nil) as "" */
        estimatedSize = strlen(buffer);
        location = "<input buffer>";
    } else {
        location = "<input stream>";
    }

    if (coll_lock) {
        MT_lock_set(coll_lock, "shredder_start"); 
    }

    /* shred it */
    shredCtxStruct* shredCtx = shredder_create(location, estimatedSize, pageFree, serFun, serCtx, docBAT, coll_lock, verbose);
    if (shredCtx) {
        if (shredder_parse(shredCtx, location, buffer, s)) {
            res = shredder_finalize(shredCtx, docBAT);
            if (verbose && res && !s && !buffer) {
                char buf1[80], buf2[80];
                stop = GDKusec();
                stream_printf(GDKout, "# Elapsed time = %s [%s/node]\n", 
                     timer_str(abs(stop - start), buf1), 
                     timer_str(abs(stop - start) / (shredCtx->nnode_pre - shredCtx->nnode_base), buf2));

                if (PRINT_STAT) shredder_stats(shredCtx);
            }
        }
        shredder_free(shredCtx, res?1:-shredCtx->updatable);
    }
    if (coll_lock) {
        MT_lock_unset(coll_lock, "shredder_end"); 
    }
    return res;
}

int
CMDshred_url(BAT *docBAT, 
             str location, 
             lng *percentage,
             lock *collLock,
             bit *verbose)
{
    assert(percentage);
    return shred(docBAT, location, NULL, NULL, *percentage, NULL, NULL, (*verbose==TRUE)?NULL:collLock);
}

int
CMDshred_str(BAT *docBAT, 
             str buffer, 
             lng *percentage,
             lock *collLock,
             bit *verbose)
{
    assert(percentage);
    return shred(docBAT, NULL, buffer, NULL, *percentage, NULL, NULL, (*verbose==TRUE)?NULL:collLock);
}

int
CMDshred_stream(BAT *docBAT, 
                Stream *fp,
                lng *percentage,
                lock *collLock,
                bit *verbose)
{
    stream *s = (stream*) ((fp && *(ptr*) fp != ptr_nil)?*fp:NULL);
    assert(percentage);
    return shred(docBAT, NULL, NULL, s, *percentage, NULL, NULL, (*verbose==TRUE)?NULL:collLock);
}
@c
/* vim:set shiftwidth=4 expandtab: */
