@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2007 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$

@f prec_foll
@a Peter Boncz, Jenni Zhang 
@t prec_foll

@c

/*******************************************
* prec_foll.c : axis step operators for preceding and following axis
*
*/
#include "pf_config.h"
#include <gdk.h>

/**
 * This file contains the axis step algoritms for following and
 * preceding axis.
 * 
 * Both algorithms work similiar to the staircase-join approach:
 * 
 * - evaluation is done during a single sequential scan of the
 *   size table and the context set
 *   (we now use size rather than level to enable skipping)
 * - context set pruning is performed on-the-fly
 * 
 * Unlike the staircasejoins for ancestor and desecendant steps
 * we have to take care about the limitations of document fragments.
 * Nodes on the following axis of x, are all nodes with
 * pre(v) > pre(x) + size(x),
 * but only that nodes qualify, that belong to the same document fragment
 * as x itself.
 */

/* FOLLOWING STEP */
int
PFfollowing_void(BAT **result, BAT *pre_size, BAT *ctx, BAT *doc_pre, int *upperbound)
{
@= init
    char *name = "PF_@1_void";
    BUN p, q;
    int xx;

    /* the context set */
    oid *ctx_cur = (oid*) BUNhead(ctx, BUNfirst(ctx)); 
    oid *ctx_end = (oid*) BUNhead(ctx, BUNlast(ctx));
    int ctx_nxt = BUNsize(ctx)/sizeof(oid);

    /* result bat allocation. for result size use upperbound parameter */
    BAT *res = BATnew(TYPE_oid, TYPE_void, *upperbound);
    oid *res_cur = (oid*) BUNhead(res, BUNfirst(res)); 

    int *size = ((int*) BUNfirst(pre_size)) - pre_size->hseqbase;

    ALGODEBUG
        THRprintf(GDKout, "%s: node set of %u buns, context set of %u buns\n",
                          name, BATcount(pre_size), BATcount(ctx));

    /* --------------------------- special cases --------------------------- */
    if (!(BAThordered(ctx) & 1))
    {
        GDKerror("%s: context must be ordered on head.\n", name);
        return GDK_FAIL;
    }
    if (BATcount(ctx) == 0 || BATcount(pre_size) == 0)
    {
        *result = BATnew(TYPE_oid, TYPE_void, 0);
        return GDK_SUCCEED;
    }
    if (res == NULL) 
    { 
        GDKerror("%s: could not allocate a result BAT of size %d.\n", name, *upperbound);
        return GDK_FAIL;
    }
@c
    @:init(following)@

    BATloopFast(doc_pre, p, q, xx) {
        oid cur_following = INT_MAX;
        oid boundary = *(oid*) BUNtail(doc_pre,p);
        boundary += size[boundary] + 1;

        /* within the fragment (boundary), go over all context nodes */
        while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
            /* new following is the first following node of the current context node */
            oid new_following = *ctx_cur + size[*ctx_cur] + 1;

            if (new_following < cur_following) {
                cur_following = new_following; /* keep setting cur_following back */
            }
            /* if we overtake the cur_following, we cannot set it back anymore: generate results */
            if (cur_following < *ctx_cur) break;
            ctx_cur += ctx_nxt;
        }
        while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
            ctx_cur += ctx_nxt; /* advance ctx pointer after breaking out early */
        }
        /* now, everything until the end of the fragment is a following node */
        while(cur_following < boundary) {
            int sz = size[cur_following];
            if (sz >= 0) {
                *res_cur++ = cur_following++;
            } else { 
                /* this node has been deleted! skip the hole */
                cur_following += 1 + (sz & ~(1<<31)); 
            }
        }
    }
@= end
    /* mark the end point of the BUNs section in the BUNheap */
    res->batBuns->free = ((BUN)res_cur) - res->batBuns->base;
    BATsetcount(res, (res->batBuns->free+Bunbase(res)-BUNfirst(res))/BUNsize(res));

    res->batDirty = TRUE;
    res->hsorted = GDK_SORTED;
    BATkey(res,TRUE);
    BATseqbase(BATmirror(res), oid_nil);
    *result = res;

    return GDK_SUCCEED;
@c
    @:end@
}


/* PRECEDING STEP */
int
PFpreceding_void(BAT **result, BAT *pre_size, BAT *ctx, BAT *doc_pre, int *upperbound)
{
    @:init(preceding)@

    BATloopFast(doc_pre, p, q, xx) {
        oid cur_preceding = *(oid*) BUNtail(doc_pre,p); /* first node of the fragment */
        oid boundary = cur_preceding + size[cur_preceding] + 1; /* first of next fragment */
        oid *ctx_start = ctx_cur;

        /* within the fragment (boundary), go over all context nodes; and remember the last one */
        while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
            ctx_cur += ctx_nxt;
        }
       
        if (ctx_start < ctx_cur) {
            oid ctx_last = ctx_cur[-ctx_nxt]; /* the last context node in this fragment */  

            /* cur_preceding is before ctx_last, so it contains its preceding *and* ancestor nodes */
            while(cur_preceding < ctx_last) {
                oid new_preceding = cur_preceding + 1 + size[cur_preceding];
                if (new_preceding > ctx_last) {
                    cur_preceding++; /* skip ancestor */
                } else {
                    /* cur_preceding and its descendants are not ancestors, so they must be preceding 
                     * but: beware of holes!
                     */
                    while(cur_preceding < new_preceding) {
                        while(cur_preceding < new_preceding && size[cur_preceding] >= 0) {    
                            *res_cur++ = cur_preceding++;
                        }
                        if (cur_preceding < new_preceding) {
                            /* we hit a deleted node: skip hole */
                            cur_preceding = 1 + (size[cur_preceding] & ~(1<<31)); 
                        }
                    }
                }
            } 
        }
    }
    @:end@
}
@c
/* vim:set shiftwidth=4 expandtab: */
