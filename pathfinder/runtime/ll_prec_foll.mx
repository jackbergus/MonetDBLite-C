@/
Copyright Notice:
-----------------

The contents of this file are subject to the Pathfinder Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License.  You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
the License for the specific language governing rights and limitations
under the License.

The Original Code is the Pathfinder system.

The Original Code has initially been developed by the Database &
Information Systems Group at the University of Konstanz, Germany and
the Database Group at the Technische Universitaet Muenchen, Germany.
It is now maintained by the Database Systems Group at the Eberhard
Karls Universitaet Tuebingen, Germany.  Portions created by the
University of Konstanz, the Technische Universitaet Muenchen, and the
Universitaet Tuebingen are Copyright (C) 2000-2005 University of
Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
2008-2011 Eberhard Karls Universitaet Tuebingen, respectively.  All
Rights Reserved.
@
@' $Id$

@f ll_prec_foll
@a Stefan Manegold, Peter Boncz, Jennie Zhang 
@t ll_prec_foll

@c

/*******************************************
* ll_prec_foll.c : axis step operators for loop-lifted preceding and following axis
*
*/
#include "pf_config.h"
#include <gdk.h>

/**
 * This file contains the axis step algoritms for following and
 * preceding axis.
 * 
 * Both algorithms work similiar to the staircase-join approach:
 * 
 * - evaluation is done during a single sequential scan of the
 *   size table and the context set
 *   (we now use size rather than level to enable skipping)
 * - context set pruning is performed on-the-fly
 * 
 * Unlike the staircasejoins for ancestor and desecendant steps
 * we have to take care about the limitations of document fragments.
 * Nodes on the following axis of x, are all nodes with
 * pre(v) > pre(x) + size(x),
 * but only that nodes qualify, that belong to the same document fragment
 * as x itself.
 */

/* check, if result buffer is big enough; otherwise extend it */
#define PFll_check_BAT_capacity(b,grow,res_scur,res_hcur,res_tcur) \
{\
        BUN _oldcap = BATcapacity(b);\
        BUN _reqcap = BATcount(b) + grow;\
        unsigned short _bunsize = Hsize(b) + Tsize(b);\
        if (_oldcap < _reqcap) {\
            BUN _newcap = MAX(_reqcap, BATgrows(b));\
            if (BATextend((b), _newcap) == NULL) {\
                GDKerror("%s: BATextend of BAT '%s' (#%d) failed "\
                         "for " BUNFMT " buns (" SZFMT " bytes).\n",\
                         __func__, BATgetId(b), (b)->batCacheid,\
                         _newcap, (size_t) _newcap * _bunsize);\
                BBPreclaim(b);\
                return GDK_FAIL;\
            }\
            _newcap = BATcapacity(b);\
            if (_newcap < _reqcap) {\
                GDKerror("%s: BATextend of BAT '%s' (#%d) failed: "\
                         "required " BUNFMT " buns (" SZFMT " bytes), "\
                         "got only " BUNFMT " buns (" SZFMT " bytes).\n",\
                         __func__, BATgetId(b), (b)->batCacheid,\
                         _reqcap, (size_t) _reqcap * _bunsize,\
                         _newcap, (size_t) _newcap * _bunsize);\
                BBPreclaim(b);\
                return GDK_FAIL;\
            }\
            res_scur = (oid*) Hloc(res, BUNfirst(res));\
            res_hcur = (oid*) Hloc(res, BUNlast(res));\
            res_tcur = (oid*) Tloc(res, BUNlast(res));\
        }\
}

/* FOLLOWING STEP */
int
PFll_following(BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *doc_pre, BAT *pre_size, BAT *pre_kind, chr *_kind_test)
{
    @:init(following)@

@= init
    BATiter iter_bati = bat_iterator(iter_bat), ctx_bati = bat_iterator(ctx_bat);
    BATiter doc_prei = bat_iterator(doc_pre);
    char *name = "PFll_@1";
    BUN p = 0, q = 0;
    int *size = 0;
    chr *kind = 0, kind_test = *_kind_test;

    BUN res_size = 0, grow = 0;
    BAT *res = 0;
    oid *iter_cur = 0, *iter_end = 0, *ctx_cur = 0, *ctx_end = 0;
    oid *res_scur = 0, *res_hcur = 0, *res_tcur = 0;
    bit one_ctx = 0;
    oid min_iter = 0, max_iter = 0, num_iter = 0, ctx_max = 0;

    /* --------------------------- checks ---------------------------------- */

    BATcheck(iter_bat, name);
    BATcheck(ctx_bat, name);
    BATcheck(doc_pre, name);
    BATcheck(pre_size, name);
    BATcheck(pre_kind, name);

    iter_cur = (oid*) BUNtail(iter_bati, BUNfirst(iter_bat)); 
    iter_end = (oid*) BUNtail(iter_bati, BUNlast(iter_bat));

    ctx_cur = (oid*) BUNtail(ctx_bati, BUNfirst(ctx_bat)); 
    ctx_end = (oid*) BUNtail(ctx_bati, BUNlast(ctx_bat));
    ctx_max = *(ctx_end - 1);
    one_ctx = *ctx_cur == ctx_max;

    ALGODEBUG
        THRprintf(GDKout, "%s: |iter_bat|="SZFMT", |ctx_bat|="SZFMT", |doc_pre|="SZFMT", |pre_size|="SZFMT", |pre_kind|="SZFMT", kind_test=%d, one_ctx=%d\n",
                          name, BATcount(iter_bat), BATcount(ctx_bat), BATcount(doc_pre), BATcount(pre_size), BATcount(pre_kind), (int)kind_test, (int)one_ctx);

    if (!(BAThdense(iter_bat) && BAThdense(ctx_bat)))
    {
        GDKerror("%s: both iter_bat and ctx_bat must have a dense head.\n", name);
        return GDK_FAIL;
    }
    if ((iter_bat->hseqbase != ctx_bat->hseqbase) || (BATcount(iter_bat) != BATcount(ctx_bat)))
    {
        GDKerror("%s: iter_bat and ctx_bat must be head-aligned, i.e., have equal head seqbases and length.\n", name);
        return GDK_FAIL;
    }
    if (!(BATtordered(ctx_bat) & 1))
    {
        GDKerror("%s: ctx_bat must be ordered on tail.\n", name);
        return GDK_FAIL;
    }
    if (ctx_bat->ttype == TYPE_void)
    {
        GDKerror("%s: ctx_bat cannot have a void tail.\n", name);
        return GDK_FAIL;
    }
    if (iter_bat->ttype == TYPE_void)
    {
        GDKerror("%s: iter_bat cannot have a void tail.\n", name);
        return GDK_FAIL;
    }
    if (one_ctx && !(BATtordered(iter_bat) & 1))
    {
        GDKerror("%s: iter_bat must be ordered on tail.\n", name);
        return GDK_FAIL;
    }
    if (!(BATtordered(doc_pre) & 1))
    {
        GDKerror("%s: doc_pre must be ordered on tail.\n", name);
        return GDK_FAIL;
    }

    if (!BAThdense(pre_size))
    {
        GDKerror("%s: head of pre_size must be dense.\n", name);
        return GDK_FAIL;
    }
    if (pre_size->ttype != TYPE_int)
    {
        GDKerror("%s: tail of pre_size must be type INT.\n", name);
        return GDK_FAIL;
    }
    if (pre_size->htype != TYPE_void)
    {
        GDKerror("%s: head (oid) of pre_size must NOT be materialized.\n", name);
        return GDK_FAIL;
    }
    if (*ctx_cur < pre_size->hseqbase || ctx_max >= pre_size->hseqbase + BATcount(pre_size))
    {
        GDKerror("%s: context nodes exceed collection range.\n", name);
        return GDK_FAIL;
    }
    size = ((int*) Tloc(pre_size, BUNfirst(pre_size))) - (int)pre_size->hseqbase;

    if (kind_test != chr_nil) {
        if (!BAThdense(pre_kind))
        {
            GDKerror("%s: head of pre_kind must be dense.\n", name);
            return GDK_FAIL;
        }
        if ((pre_size->hseqbase != pre_kind->hseqbase) || (BATcount(pre_size) != BATcount(pre_kind)))
        {
            GDKerror("%s: pre_size and pre_kind must be head-aligned, i.e., have equal head seqbases and length.\n", name);
            return GDK_FAIL;
        }
        if (pre_kind->ttype != TYPE_chr)
        {
            GDKerror("%s: tail of pre_kind must be type CHR.\n", name);
            return GDK_FAIL;
        }
        if (pre_kind->htype != TYPE_void)
        {
            GDKerror("%s: head (oid) of pre_kind must NOT be materialized.\n", name);
            return GDK_FAIL;
        }
        kind = ((chr*) Tloc(pre_kind, BUNfirst(pre_kind))) - (int)pre_kind->hseqbase;
    }

    /* --------------------------- empty result ---------------------------- */

    if (BATcount(ctx_bat) == 0 || BATcount(pre_size) == 0 || BATcount(doc_pre) == 0)
    {
        res = BATnew(TYPE_oid, TYPE_void, 0);
        BATkey (res, TRUE);
        res->hsorted = GDK_SORTED;
        res->hdense = TRUE;
        BATseqbase (res, (oid)0); /* does not really matter */
        BATkey (BATmirror(res), TRUE);
        res->tsorted = TRUE;
        res->tdense = TRUE;
        BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        BATset(res, TRUE);
        *result = res;
        return GDK_SUCCEED;
    }

    /* --------------------------- analyze iters --------------------------- */

    if (BATtordered(iter_bat) & 1)
    {
        min_iter = *iter_cur;
        max_iter = *(iter_end - 1);
    } else {
        oid *cur_iter = iter_cur;
        min_iter = GDK_oid_max;
        max_iter = GDK_oid_min;
        for (; cur_iter < iter_end; cur_iter++) {
            oid iter = *cur_iter;
            if (iter < min_iter) min_iter = iter;
            if (iter > max_iter) max_iter = iter;
        }
    }
    assert(min_iter <= max_iter);
    num_iter = (max_iter - min_iter) + 1;

    ALGODEBUG
        THRprintf(GDKout, "%s: min_iter="OIDFMT", max_iter="OIDFMT", num_iter="OIDFMT"\n",
                          name, min_iter, max_iter, num_iter);

    /* --- result bat allocation. for result size use res_size parameter --- */

    res_size = num_iter * ((BATcount(pre_size) / 2) / BATcount(doc_pre));
    res = BATnew(TYPE_oid, TYPE_oid, res_size);
    if (res == NULL) 
    { 
        GDKerror("%s: could not allocate a result BAT of size "BUNFMT".\n", name, res_size);
        return GDK_FAIL;
    }
    res_scur = res_hcur = (oid*) Hloc(res, BUNlast(res)); 
    res_tcur =            (oid*) Tloc(res, BUNlast(res)); 
@
@c
    /* ------------------------- actual algorithm -------------------------- */

    if (kind_test != chr_nil) {
        @:ll_foll(if (kind[cur_following] == kind_test))@
    } else {
        @:ll_foll()@
    }
    
@= ll_foll
    if (one_ctx) {
        /* 1 ctx, 1/n iter */
        p = SORTfndlast(doc_pre, ctx_cur);
        if (p > BUNfirst(doc_pre)) {
            oid boundary = *(oid*) BUNtail(doc_prei, p - 1);
            oid cur_following = *ctx_cur + size[*ctx_cur] + 1;

            /* now, everything until the end of the fragment is a following node */
            boundary += size[boundary] + 1;
            if (cur_following < boundary) {
                /* check, if result buffer is big enough; otherwise extend it */
                grow = num_iter * (boundary - cur_following);
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                if (num_iter == 1) {
                    ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, 1 iter\n", name);
                    while(cur_following < boundary) {
                        int sz = size[cur_following];
                        if (sz >= 0) {
                            @1 {
                                *res_hcur++ = min_iter;
                                *res_tcur++ = cur_following;
                            }
                            cur_following++;
                        } else { 
                            /* this node has been deleted! skip the hole */
                            cur_following += 1 + (sz & ~(1U<<31)); 
                        }
                    }
                } else {
                    /* num_iter > 1 */
                    if (iter_bat->tkey) {
                        ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, n iter (key)\n", name);
                        while(cur_following < boundary) {
                            int sz = size[cur_following];
                            if (sz >= 0) {
                                @1 {
                                    oid *cur_iter = iter_cur;
                                    for (; cur_iter < iter_end; cur_iter++) {
                                        *res_hcur++ = *cur_iter;
                                        *res_tcur++ = cur_following;
                                    }
                                }
                                cur_following++;
                            } else { 
                                /* this node has been deleted! skip the hole */
                                cur_following += 1 + (sz & ~(1U<<31)); 
                            }
                        }
                    } else {
                        /* !iter_bat->tkey */
                        ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, n iter\n", name);
                        while(cur_following < boundary) {
                            int sz = size[cur_following];
                            if (sz >= 0) {
                                @1 {
                                    oid *cur_iter = iter_cur;
                                    oid prev_iter = oid_nil;
                                    for (; cur_iter < iter_end; cur_iter++) {
                                        if (*cur_iter != prev_iter) {
                                            *res_hcur++ = *cur_iter;
                                            *res_tcur++ = cur_following;
                                            prev_iter = *cur_iter;
                                        }
                                    }
                                }
                                cur_following++;
                            } else { 
                                /* this node has been deleted! skip the hole */
                                cur_following += 1 + (sz & ~(1U<<31)); 
                            }
                        }
                    }
                }
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
    } else
    if (num_iter == 1) {
        /* n ctx, 1 iter */
        ALGODEBUG THRprintf(GDKout, "%s: n ctx, 1 iter\n", name);
        BATloop(doc_pre, p, q) {
            oid boundary = *(oid*) BUNtail(doc_prei,p);
            oid cur_following = boundary += size[boundary] + 1;

            /* within the fragment (boundary), go over all context nodes */
            while(ctx_cur < ctx_end && *ctx_cur < cur_following /*<= boundary*/) { 
                /* new following is the first following node of the current context node */
                oid new_following = *ctx_cur + size[*ctx_cur] + 1;

                if (new_following < cur_following) {
                    cur_following = new_following; /* keep setting cur_following back */
                }
                ctx_cur++;
            }
            while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
                ctx_cur++; /* advance ctx pointer after breaking out early */
            }
            if (cur_following < boundary) {
                /* now, everything until the end of the fragment is a following node */
                /* check, if result buffer is big enough; otherwise extend it */
                grow = boundary - cur_following;
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                while(cur_following < boundary) {
                    int sz = size[cur_following];
                    if (sz >= 0) {
                        @1 {
                            *res_hcur++ = min_iter;
                            *res_tcur++ = cur_following;
                        }
                        cur_following++;
                    } else { 
                        /* this node has been deleted! skip the hole */
                        cur_following += 1 + (sz & ~(1U<<31)); 
                    }
                }
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
    } else
    {
        /* n ctx, n iter */
        ALGODEBUG THRprintf(GDKout, "%s: n ctx, n iter\n", name);
        oid *min_following = (oid*) GDKmalloc(num_iter * sizeof(oid));
        if (min_following == NULL) 
        { 
            GDKerror("%s: could not allocate a stack of size "SZFMT".\n", name, (size_t)num_iter * sizeof(oid));
            BBPreclaim(res);
            return GDK_FAIL;
        }
        BATloop(doc_pre, p, q) {
            oid iter = 0, fst_iter = num_iter, lst_iter = 0;
            oid boundary = *(oid*) BUNtail(doc_prei,p);
            oid cur_following = boundary += size[boundary] + 1;
            for (; iter < num_iter; iter++) {
                min_following[iter] = cur_following;
            }

            /* within the fragment (boundary), go over all context nodes */
            while(ctx_cur < ctx_end && *ctx_cur < /*cur_following <=*/ boundary) { 
                /* new following is the first following node of the current context node */
                oid new_following = *ctx_cur + size[*ctx_cur] + 1;
                oid prev_ctx = *ctx_cur;

                if (new_following < cur_following) {
                    cur_following = new_following; /* keep setting cur_following back */
                }
                
                while(ctx_cur < ctx_end && *ctx_cur == prev_ctx) {
                    iter = *iter_cur - min_iter;
                    if (new_following < min_following[iter]) {
                        min_following[iter] = new_following;
                        if (iter < fst_iter) fst_iter = iter;
                        if (iter > lst_iter) lst_iter = iter;
                    }
                    ctx_cur++;
                    iter_cur++;
                }
            }
@(
            while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
                ctx_cur++; /* advance ctx pointer after breaking out early */
                iter_cur++;
            }
@)
            if (cur_following < boundary && fst_iter <= lst_iter) {
                /* now, everything until the end of the fragment is a following node */
                /* check, if result buffer is big enough; otherwise extend it */
                grow = ((lst_iter - fst_iter) + 1) * (boundary - cur_following);
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                while(cur_following < boundary) {
                    int sz = size[cur_following];
                    if (sz >= 0) {
                        @1 {
                            for (iter = fst_iter; iter <= lst_iter; iter++) {
                                if (min_following[iter] <= cur_following) {
                                    *res_hcur++ = iter + min_iter;
                                    *res_tcur++ = cur_following;
                                }
                            }
                        }
                        cur_following++;
                    } else { 
                        /* this node has been deleted! skip the hole */
                        cur_following += 1 + (sz & ~(1U<<31)); 
                    }
                }
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
        GDKfree(min_following);
    }
@
@c
    @:end@

@= end
    /* -------------------- set result properties ---------------------- */
{
    bit trivial  = (BATcount(res) < 2);
    /* actually zero_or_one_item... */
    bit one_item = trivial || (*(oid*)Tloc(res, BUNfirst(res)) == *(oid*)Tloc(res, BUNlast(res) - 1));
    bit one_iter = (num_iter == 1);

    res->batDirty = TRUE;
    res->hdense = (trivial||(res->htype==TYPE_void)); /* might be TRUE in some more cases... */
    if (res->hdense) {
        if (BATcount(res) == 0) {
            BATseqbase (res, (oid)0); /* does not really matter */
        } else {
            BATseqbase (res, *(oid*)Hloc(res, BUNfirst(res)));
        }
    }
    res->hsorted = ((one_iter||one_item) ? GDK_SORTED : 0); /* might be TRUE in some more cases... */
    BATkey(res,(res->hdense||one_item)); /* might be TRUE in some more cases... */
    res->tdense = (trivial||(res->ttype==TYPE_void)); /* might be TRUE in some more cases... */
    if (res->tdense) {
        if (BATcount(res) == 0) {
            BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        } else {
            BATseqbase (BATmirror(res), *(oid*)Tloc(res, BUNfirst(res)));
        }
    }
    res->tsorted = GDK_SORTED;
    BATkey(BATmirror(res),(res->tdense||one_iter)); /* might be TRUE in some more cases... */
    BATset(res, TRUE);
}
    *result = res;

    return GDK_SUCCEED;
@
@c
}


/* PRECEDING STEP */
int
PFll_preceding(BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *doc_pre, BAT *pre_size, BAT *pre_kind, chr *_kind_test)
{
    @:init(preceding)@

    /* ------------------------- actual algorithm -------------------------- */

    if (kind_test != chr_nil) {
        @:ll_prec(if (kind[cur_preceding] == kind_test))@
    } else {
        @:ll_prec()@
    }
    
@= ll_prec
    if (one_ctx) {
        /* 1 ctx, 1/n iter */
        p = SORTfndlast(doc_pre, ctx_cur);
        if (p > BUNfirst(doc_pre)) {
            oid cur_preceding = *(oid*) BUNtail(doc_prei, p - 1);
            oid boundary = *ctx_cur;

            /* now, everything between the beginning of the fragment (cur_preceding) and
             * the context node (boundary) is preceding --- unless it's hole or ancestor */
            if (cur_preceding < boundary) {
                /* check, if result buffer is big enough; otherwise extend it */
                grow = num_iter * (boundary - cur_preceding);
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                if (num_iter == 1) {
                    ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, 1 iter\n", name);
                    while(cur_preceding < boundary) {
                        int sz = size[cur_preceding];
                        oid new_preceding = cur_preceding + 1 + (sz & ~(1U<<31));
                        if (sz < 0) {
                            cur_preceding = new_preceding; /* skip hole */
                        } else
                        if (new_preceding > boundary) {
                            cur_preceding++; /* skip ancestor */
                        } else {
                            @1 {
                                *res_hcur++ = min_iter;
                                *res_tcur++ = cur_preceding;
                            }
                            cur_preceding++;
                        }
                    } 
                } else {
                    /* num_iter > 1 */
                    if (iter_bat->tkey) {
                        ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, n iter (key)\n", name);
                        while(cur_preceding < boundary) {
                            int sz = size[cur_preceding];
                            oid new_preceding = cur_preceding + 1 + (sz & ~(1U<<31));
                            if (sz < 0) {
                                cur_preceding = new_preceding; /* skip hole */
                            } else
                            if (new_preceding > boundary) {
                                cur_preceding++; /* skip ancestor */
                            } else {
                                @1 {
                                    oid *cur_iter = iter_cur;
                                    for (; cur_iter < iter_end; cur_iter++) {
                                        *res_hcur++ = *cur_iter;
                                        *res_tcur++ = cur_preceding;
                                    }
                                }
                                cur_preceding++;
                            }
                        } 
                    } else {
                        /* !iter_bat->tkey */
                        ALGODEBUG THRprintf(GDKout, "%s: 1 ctx, n iter\n", name);
                        while(cur_preceding < boundary) {
                            int sz = size[cur_preceding];
                            oid new_preceding = cur_preceding + 1 + (sz & ~(1U<<31));
                            if (sz < 0) {
                                cur_preceding = new_preceding; /* skip hole */
                            } else
                            if (new_preceding > boundary) {
                                cur_preceding++; /* skip ancestor */
                            } else {
                                @1 {
                                    oid *cur_iter = iter_cur;
                                    oid prev_iter = oid_nil;
                                    for (; cur_iter < iter_end; cur_iter++) {
                                        if (*cur_iter != prev_iter) {
                                            *res_hcur++ = *cur_iter;
                                            *res_tcur++ = cur_preceding;
                                        }
                                    }
                                }
                                cur_preceding++;
                            }
                        } 
                    }
                }
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
    } else
    if (num_iter == 1) {
        /* n ctx, 1 iter */
        ALGODEBUG THRprintf(GDKout, "%s: n ctx, 1 iter\n", name);
        BATloop(doc_pre, p, q) {
            oid *ctx_fst = ctx_cur;
            oid cur_preceding = *(oid*) BUNtail(doc_prei,p); /* first node of the fragment */
            oid boundary = cur_preceding + size[cur_preceding] + 1; /* first of next fragment */

            /* within the fragment (boundary), go over all context nodes; and remember the last one */
            while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
                ctx_cur++;
            }
            if (ctx_fst < ctx_cur) {
                boundary = ctx_cur[-1]; /* the last context node in this fragment */
            } else {
                boundary = 0;
            }
            
            /* now, everything between the beginning of the fragment (cur_preceding) and
             * the context node (boundary) is preceding --- unless it's hole or ancestor */
            if (cur_preceding < boundary) {
                /* check, if result buffer is big enough; otherwise extend it */
                grow = boundary - cur_preceding;
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                while(cur_preceding < boundary) {
                    int sz = size[cur_preceding];
                    oid new_preceding = cur_preceding + 1 + (sz & ~(1U<<31));
                    if (sz < 0) {
                        cur_preceding = new_preceding; /* skip hole */
                    } else
                    if (new_preceding > boundary) {
                        cur_preceding++; /* skip ancestor */
                    } else {
                        @1 {
                            *res_hcur++ = min_iter;
                            *res_tcur++ = cur_preceding;
                        }
                        cur_preceding++;
                    }
                } 
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
    } else
    {
        /* n ctx, n iter */
        ALGODEBUG THRprintf(GDKout, "%s: n ctx, n iter\n", name);
        oid *max_preceding = (oid*) GDKmalloc(num_iter * sizeof(oid));
        if (max_preceding == NULL) 
        { 
            GDKerror("%s: could not allocate a stack of size "SZFMT".\n", name, (size_t)num_iter * sizeof(oid));
            BBPreclaim(res);
            return GDK_FAIL;
        }
        BATloop(doc_pre, p, q) {
            oid iter = 0, fst_iter = num_iter, lst_iter = 0;
            oid cur_preceding = *(oid*) BUNtail(doc_prei,p); /* first node of the fragment */
            oid boundary = cur_preceding + size[cur_preceding] + 1; /* first of next fragment */
            memset(max_preceding, 0, num_iter * sizeof(oid));

            /* within the fragment (boundary), go over all context nodes; and remember the last one per iter */
            while(ctx_cur < ctx_end && *ctx_cur < boundary) { 
                iter = *iter_cur - min_iter;
                max_preceding[iter] = *ctx_cur;
                if (iter < fst_iter) fst_iter = iter;
                if (iter > lst_iter) lst_iter = iter;
                ctx_cur++;
                iter_cur++;
            }
            boundary = max_preceding[iter]; /* the last context node in this fragment */
            
            if (cur_preceding < boundary && fst_iter <= lst_iter) {
                /* now, everything between the beginning of the fragment (cur_preceding) and
                 * the context node (boundary) is preceding --- unless it's hole or ancestor */
                /* check, if result buffer is big enough; otherwise extend it */
                grow = ((lst_iter - fst_iter) + 1) * (boundary - cur_preceding);
                PFll_check_BAT_capacity(res, grow, res_scur, res_hcur, res_tcur);
                while(cur_preceding < boundary) {
                    int sz = size[cur_preceding];
                    oid new_preceding = cur_preceding + 1 + (sz & ~(1U<<31));
                    if (sz < 0) {
                        cur_preceding = new_preceding; /* skip hole */
                    } else
                    if (new_preceding > boundary) {
                        cur_preceding++; /* skip "global" ancestor */
                    } else {
                        @1 {
                            for (iter = fst_iter; iter <= lst_iter; iter++) {
                                if (new_preceding <= max_preceding[iter]) {
                                    /* not "local" ancestor => preceding! */
                                    *res_hcur++ = iter + min_iter;
                                    *res_tcur++ = cur_preceding;
                                }
                            }
                        }
                        cur_preceding++;
                    }
                } 
                /* mark the end point of the BUNs section in the BUNheap */
                BATsetcount(res, res_hcur - res_scur);
            }
        }
        GDKfree(max_preceding);
    }
@
@c
    @:end@
}

/* vim:set shiftwidth=4 expandtab: */
