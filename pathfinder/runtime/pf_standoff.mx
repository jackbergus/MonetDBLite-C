@/
Copyright Notice:
-----------------

The contents of this file are subject to the Pathfinder Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License.  You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
the License for the specific language governing rights and limitations
under the License.

The Original Code is the Pathfinder system.

The Original Code has initially been developed by the Database &
Information Systems Group at the University of Konstanz, Germany and
the Database Group at the Technische Universitaet Muenchen, Germany.
It is now maintained by the Database Systems Group at the Eberhard
Karls Universitaet Tuebingen, Germany.  Portions created by the
University of Konstanz, the Technische Universitaet Muenchen, and the
Universitaet Tuebingen are Copyright (C) 2000-2005 University of
Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
2008-2011 Eberhard Karls Universitaet Tuebingen, respectively.  All
Rights Reserved.
@
@f pf_standoff
@a Wouter Alink
@a Peter Boncz
@v 0.1
@t MIL primitives to support the StandOff Axis Steps in XQuery

@* Introduction
@T
This module provides MIL primitives to support the StandOff
Axis Steps on top of MonetDB within the "Pathfinder" project.
This module is loaded when standoff-axis steps are enabled on
the server-side or when 'pf' is provided the option '-b' or the
equivalent long option '--enable-standoff'. In order to enable
the StandOff Axis steps on the server side you need to add
\texttt{standoff=enabled} to the \texttt{--set} option list.
The default is \texttt{standoff=disabled}.

note: runtime support for the StandOff axis steps was added in the
0.12 release.

@- Select Narrow / Select Wide
@T
The SN, SW, RN, RW joins are region joins based on the work by Forbes J.
Burkowski (1992) ``Retrieval Activities in a Database Consisting of
Heterogeneous Collections of Structured Text''

There are two major changes to Burkowski's original ideas: (1.) this
implementation turns around the arguments, and (2.) it handles (partly)
overlapping regions by including them in the SW (the results of SW and SN do
not have to be disjunct) and the result of SN is a subset of SW.

When Burkowski defines \texttt{<chapter> SW \{"Feynman","virtual particle"\}}, this could
be queried as:
\begin{verbatim}
  select_wide_join({"Feynman","virtual particle"},<chapter>)
\end{verbatim}
which will return all the chapter which contain either "Feynman" or "virtual
particle". The AND-expression, as in: \texttt{<chapter> SW \{"Feynman"\} SW
\{"virtual particle"\} }
could be written as:
\begin{verbatim}
 select_wide_join({"Feynman"},
        select_wide_join({"virtual particle"}, <chapter>))
\end{verbatim}

The reason for the swap in parameters is that the selection mechanisms are
going to be used as "steps" in XPath, which are not "selection" but
"navigation" operations.

Some more examples: the \texttt{reject\_wide\_join(\{"Feynman","virtual
particle"\}, <chapter>) } would return all the chapters which do not
contain (nor partly contain) either "Feynman" or "virtual particle"
and the \texttt{ reject\_narrow\_join(<chapter>,\{"Feynman","virtual
particle"\}) } would return all the instances of "Feynman" and "virtual
particle" which are not inside a chapter-region.

\emph{Note:} The "reject-narrow" and "reject-wide" axes steps have been 
removed. They can be easily expressed in terms of the other two axes steps 
("select-narrow" and "select-wide").
The 'reject-narrow' and 'reject-wide' axes can be rewritten as follows.

\begin{verbatim}
 "{context}/reject-narrow::{name}"

can be expressed as 
 
\begin{verbatim}
 "((for $i in {context} return $i/root()//{name}/select-narrow::{name})
    except {context}/select-narrow::{name})
\end{verbatim}

similarly:

\begin{verbatim}
 "{context}/reject-wide::{name}"
\end{verbatim}

can be expressed as 

\begin{verbatim}
 "((for $i in {context} return $i/root()//{name}/select-narrow::{name})
    except {context}/select-wide::{name})
\end{verbatim}

@
@* Module Definition
@m
.MODULE pf_standoff;

@+ StandOff Joins
@T
The input for the joins are the current context:
\begin{verbatim}
 BAT(<void>, <int>region start), BAT(<void>, <int>region end)
\end{verbatim}
and the destination context, which have to be indicated by:
\begin{verbatim}
 BAT(<void>, <int>region start), BAT(<void>, <int>region end)
\end{verbatim}
The result is a list to the items in the destination context that match:
 (<void>, <oid>)

\emph{NOTE}: currently only 'int'- and 'lng'-type regions are implemented, but
these joins could as well be implemented on floats, dates, and other data-types
without much effort.

@- non loop-lifted StandOff joins
@= standoff_join_sigs
   .COMMAND @1_@2_join_sort(BAT[oid, @3], BAT[oid,@3], BAT[oid,@3], BAT[oid,@3]) :
	BAT[void,oid] = CMD@1_@2_join_sort_@3; "@1 @2 join (on @3s), using inputs sorted on start"
@
@m
# declaration StandOff joins (int)
@:standoff_join_sigs(select,narrow,int)@
@:standoff_join_sigs(select,wide,int)@

# declaration StandOff joins (lng)
@:standoff_join_sigs(select,narrow,lng)@
@:standoff_join_sigs(select,wide,lng)@

# interaction with the underlying data
.COMMAND blob(BAT[void,lng], BAT[void,lng], str) :
	BAT[void,str] = CMDfetch_standoff_data_lng; "fetch data from region (start,end) blob (file)"
.COMMAND blob(BAT[void,int], BAT[void,int], str) :
	BAT[void,str] = CMDfetch_standoff_data_int; "fetch data from region (start,end) blob (file)"
@

@- Loop-Lifted StandOff joins
@T
This variant of the StandOff joins uses loop-lifting to do the join for
multiple inputs in a single pass. The input are the input regions (with there
iteration value, sorted on "start"):
\begin{verbatim}
  BAT(<oid>iter,<int>start)
  BAT(<oid>iter,<int>end)
\end{verbatim}
and the destination regions:
\begin{verbatim}
  BAT(<void>id, <int>start)
  BAT(<void>id, <int>end)
\end{verbatim}
The result will be a bat ([oid]iter,[oid]id), where 'iter' is the
corresponding bucket and 'id' the region-id of the destination regions.

\emph{NOTE}: only the iter in the input bat (<oid>iter,<int>start) is checked. the 'iter'-column in
the bat (iter,end) is optional (can be void as well) as it is not used.

\emph{NOTE}: the seqbase of the id-columns is currently supposed to be 0@0.

\emph{NOTE}: the loop-lifted standoff joins (SN, SW, RN, RW) have not been tested
thoroughly. The result is ordered on tail (the region identifier) and NOT on
head (iter). (any additional testcases are welcome)

@-TODO:
@T
\emph{KNOWN ISSUE}: currently the iter needs to be of type OID (and may NOT be VOID)

@m
# declaration StandOff joins (loop lifted, int)
@:ll_standoff_join_sigs(select,narrow,int)@
@:ll_standoff_join_sigs(select,wide,int)@

# declaration StandOff joins (loop lifted, lng)
@:ll_standoff_join_sigs(select,narrow,lng)@
@:ll_standoff_join_sigs(select,wide,lng)@

@= ll_standoff_join_sigs
   .COMMAND ll_@1_@2_join_sort(BAT[oid, @3], BAT[oid,@3], BAT[oid,@3], BAT[oid,@3]) :
        BAT[oid,oid] = CMDll_@1_@2_join_sort_@3; "loop lifted @1 @2 join (on @3s), using inputs sorted on start"
@

@- StandOff Axis Steps

@mil
module(alarm);
module(aggrX3);
module(malalgebra);
module(mmath);
module(xtables);


# FIXME/TODO: the attribute-names should be set by a 'declare option' statement inside
# an XQuery expression
var region_namespace := monet_environment.find("standoff_ns");
var region_start_attr_tag := monet_environment.find("standoff_start");
var region_end_attr_tag := monet_environment.find("standoff_end");

# Wouter:
@:ll_standoff_mil(select,narrow)@
@:ll_standoff_mil(select,wide)@
@:standoff_mil(select,narrow)@
@:standoff_mil(select,wide)@
@

@m
.END pf_standoff;
@

@h
#ifndef __PF_STANDOFF_H__
#define __PF_STANDOFF_H__

#include "pf_standoff.proto.h"
#include <monet.h>
#include <monet_interpreter.h>
#include <monettime.h>
#include <lock.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <gdk.h>
#include <limits.h>

#define MAX_int INT_MAX
#define MAX_lng LLONG_MAX
#define MIN_int INT_MIN
#define MIN_lng LLONG_MIN

#endif
@

@= select_outside
            /* skip nodes which are not contained */
@
@= select_inside
            /* insert nodes which are contained */
            index = iter_start - iter_s;
            BUNappend(bn, (ptr)(&index), FALSE);
@
@= narrow
        if (outer_iter_start_next < outer_last_start)
          outer_start_next = *(outer_iter_start_next);
        else
          outer_start_next = MAX_@2;

        /* loop through the not strictly contained region */
        while(iter_start < last_start && *iter_start < *outer_iter_start) {
            @:@1_outside@
            iter_start++; iter_end++;
        }

        /* loop through the strictly contained regions */
        while(iter_start < last_start && *iter_start < outer_start_next) {
            if (*iter_end <= *outer_iter_end) {
              @:@1_inside@
            } else {
              @:@1_outside@
            }
            iter_start++; iter_end++;
        }
@
@= wide
        /* loop through the not even contained regions */
        while(iter_start < last_start && *iter_end < *outer_iter_start) {
            @:@1_outside@
            iter_start++; iter_end++;
        }

        /* loop through the partly contained regions */
        while(iter_start < last_start && *iter_start <= *outer_iter_end) {
            if (*iter_end >= *outer_iter_start) {
              @:@1_inside@
            } else {
              @:@1_outside@
            }
            iter_start++; iter_end++;
        }
@

@= region_jump_decl_narrow
    @1 outer_start_next;
@
@= region_jump_decl_wide
@

@= standoff_join_impl
int
CMD@1_@2_join_sort_@3(BAT **result, BAT *source_start, BAT *source_end, BAT *region_start, BAT *region_end) {

    @4 *iter_s, *iter_start, *iter_end, *last_start,
        *outer_iter_start, *outer_iter_end, *outer_last_start,
        *outer_iter_start_next, *outer_iter_end_next;

    @:region_jump_decl_@2(@4)@
    oid index;
    BAT * bn = NULL;

    *result=NULL;

    if (!(ALIGNrelated(source_start,source_end)&1)) {
        GDKerror("@1_@2_join_sort_@3: source BATs not related.\n");
        return(GDK_FAIL);
    }
    if (!(BATtordered(source_start)&1)) {
        GDKerror("@1_@2_join_sort_@3: source BAT not sorted (on start).\n");
        return(GDK_FAIL);
    }
    if (!(ALIGNrelated(region_start,region_end)&1)) {
        GDKerror("@1_@2_join_sort_@3: region BATs not related.\n");
        return(GDK_FAIL);
    }
    if (!(BATtordered(region_start)&1)) {
        GDKerror("@1_@2_join_sort_@3: region BAT not sorted (on start).\n");
        return(GDK_FAIL);
    }

    if ((bn = BATnew(TYPE_void, TYPE_oid, BATcount(region_start))) == NULL) {
        GDKerror("@1_@2_join_sort_@3: could not allocate memory for result BAT.\n");
        return(GDK_FAIL);
    }

    iter_s = iter_start = (@4 *) Tloc(region_start, BUNfirst(region_start));
    iter_end = (@4 *) Tloc(region_end, BUNfirst(region_end));
    last_start = (@4 *) Tloc(region_start, BUNlast(region_start));
    outer_iter_start = (@4 *) Tloc(source_start, BUNfirst(source_start));
    outer_iter_end = (@4 *) Tloc(source_end, BUNfirst(source_end));
    outer_last_start = (@4 *) Tloc(source_start, BUNlast(source_start));

    while (outer_iter_start < outer_last_start) {
        outer_iter_start_next = outer_iter_start+1; outer_iter_end_next = outer_iter_end+1;

        /* skip overlapping region in the source  */
        while(outer_iter_start_next < outer_last_start
                && *(outer_iter_end_next) <= *(outer_iter_end)) {
            outer_iter_start_next++; outer_iter_end_next++;
        }

        @:@2(@1,@3)@

        outer_iter_start=outer_iter_start_next; outer_iter_end=outer_iter_end_next;
    }
    *result=bn;
    return(GDK_SUCCEED);
}
@
@= ll_select_outside
            /* skip nodes which are not contained */
@
@= ll_select_inside
            /* insert nodes which are contained */
            index = iter_start - iter_s;
            BUNins(bn, (ptr)(&(heap[i].iter)), (ptr)(&index), FALSE);
@
@= ll_narrow
        /* loop through the not strictly contained region */
        /* nearest_start contains first upcoming starting point on heap
           heap contains a single element (or more if more regions start on
           same place) */
        while(@:more_target_regions@ && *iter_start < nearest_start) {
            for (i=0;i<heap_size;i++) {
              @:ll_@1_outside@
            }
            iter_start++; iter_end++;
        }

        /* loop through the strictly contained regions */
        while(@:more_target_regions@ && *iter_start < nearest_next_start) {
            /* if there is a item that should be removed from the heap,
               we need to remove (it/them) */
            if (*iter_start > nearest_end) {
              nearest_end = MAX_@2;
              while ((heap_size > 0) && (heap[heap_size-1].end < *iter_start))
                  heap_size--;
              if (heap_size > 0)
                  nearest_end = heap[heap_size-1].end;
            }

            /* FIXME: we now know that the heap is sorted on END, so we can
               remove the if-statement here */
            for (i=0;i<heap_size;i++) {
              if (*iter_end <= heap[i].end) {
                @:ll_@1_inside@
              } else {
                @:ll_@1_outside@
              }
            }
            iter_start++; iter_end++;
        }
        /* by now, we should be ready to push a new item on the heap
           we processed as much as possible without this new item... */
@
@= ll_wide
        /* loop through the not even contained regions */
        /* nearest_start contains first upcoming starting point on heap
           heap should contain a single element (with outer_iter_start as nearest_start)
           if not, this step will automatically be skipped as iter_end will be more than
           nearest_start */
        while(@:more_target_regions@ && *iter_end < nearest_start) {
            for (i=0;i<heap_size;i++) {
              @:ll_@1_outside@
            }
            iter_start++; iter_end++;
        }

        /* loop through the partly contained regions
           now there are some elements on the heap that want our attention */
        while(@:more_target_regions@ && *iter_end < nearest_next_start) {
            /* if we think there is at least one region that could be popped... */
            if (*iter_start > nearest_end ) {
              nearest_end = MAX_@2;
              while ((heap_size > 0) && (heap[heap_size-1].end < *iter_start))
                  heap_size--;
              if (heap_size > 0)
                  nearest_end = heap[heap_size-1].end;
            }
            for (i=0;i < heap_size;i++) {
              if (*iter_end >= heap[i].start) {
                @:ll_@1_inside@
              } else {
                @:ll_@1_outside@
              }
            }
            iter_start++; iter_end++;
        }
        /* by now, we should be ready to push a new item on the heap
           we processed as much as possible without this new item... */
@

@= more_target_regions
 (iter_start < last_start)
@

@= ll_standoff_join_impl
/* 4 aug 2005
   loop lifted standoff join implementation */
int
CMDll_@1_@2_join_sort_@3(BAT **result, BAT *source_start, BAT *source_end, BAT *region_start, BAT *region_end) {

    @4 *iter_s, *iter_start, *iter_end, *last_start,
        *outer_iter_start, *outer_iter_end, *outer_last_start,
        *outer_iter_start_next, *outer_iter_end_next,
        nearest_end = MIN_@3, nearest_next_start = MAX_@3, nearest_start = MAX_@3;

    heap_@3 *heap;
    int max_heap_size = 1024;
    int heap_size = 0, i;
    oid index;
    oid *outer_iter_iter, *outer_iter_iter_next;
    BAT * bn = NULL;

    *result=NULL;

    if (BATcount(source_start) != BATcount(source_end)) {
        GDKerror("ll_@1_@2_join_sort_@3: source BATs not related size(start) = %d != size(end) = %d.\n",
                (int) BATcount(source_start),(int)BATcount(source_end));
        return(GDK_FAIL);
    }
    if (!(BATtordered(source_start)&1)) {
        GDKerror("ll_@1_@2_join_sort_@3: source BAT not sorted (on start).\n");
        return(GDK_FAIL);
    }
    if (!(ALIGNrelated(region_start,region_end)&1)) {
        GDKerror("ll_@1_@2_join_sort_@3: region BATs not related.\n");
        return(GDK_FAIL);
    }
    if (!(BATtordered(region_start)&1)) {
        GDKerror("ll_@1_@2_join_sort_@3: region BAT not sorted (on start).\n");
        return(GDK_FAIL);
    }
    //TODO: in case the iter-table is void-nil, do something special... (should be easy)
    if (source_start->htype == TYPE_void && source_start->hseqbase == oid_nil) {
        GDKerror("ll_@1_@2_join_sort_@3: iter-list is of type NIL instead of [V]OID.\n");
        return(GDK_FAIL);
    }

    // the number of iters is also the maximum depth of the heap
    // (however, in most cases the heap will be very shallow,
    // only overlapping nodes will share the heap)
    // we could allocate a lot less space:
    // probably log(|iter|) would be more than enough in most cases
    // counting iters is probably expensive, for now we only reserve for a fixed amount..
    if ((heap = (heap_@3 *)GDKmalloc(sizeof(heap_@3) * max_heap_size)) == NULL) {
        GDKerror("ll_@1_@2_join_sort_@3: could not allocate memory for heap.\n");
        return(GDK_FAIL);
    }
    // the size of the bat is maybe not correct (could be more, could be less)

    if ((bn = BATnew(TYPE_oid, TYPE_oid, BATcount(region_start))) == NULL) {
        GDKerror("ll_@1_@2_join_sort_@3: could not allocate memory for result BAT.\n");
        GDKfree(heap);
        return(GDK_FAIL);
    }

    iter_s = iter_start = (@4 *) Tloc(region_start, BUNfirst(region_start));
    iter_end = (@4 *) Tloc(region_end, BUNfirst(region_end));
    last_start = (@4 *) Tloc(region_start, BUNlast(region_start));
    outer_iter_iter = (oid *) Hloc(source_start, BUNfirst(source_start));
    outer_iter_start = (@4 *) Tloc(source_start, BUNfirst(source_start));
    outer_iter_end = (@4 *) Tloc(source_end, BUNfirst(source_end));
    outer_last_start = (@4 *) Tloc(source_start, BUNlast(source_start));

    /* todo: do we have to check for var-sized bats? */

    heap_size = replace_in_heap_@3(heap,heap_size,
            *outer_iter_iter,
            *outer_iter_start,
            *outer_iter_end);

    while (@:more_target_regions@) {
        outer_iter_start_next = outer_iter_start+1;
        outer_iter_end_next = outer_iter_end+1;
        outer_iter_iter_next = outer_iter_iter+1;

        /* skip (completely) overlapping regions (in same iter) in the source
           this is NOT an optimization, it is neccessary to capture all the regions */
        while (outer_iter_start_next < outer_last_start) {
            i=0;
            while (i < heap_size && heap[i].iter != *(outer_iter_iter_next)) i++;
            /* only skip region if there already is a region with the same iter
               and the region is contained in the current region on the heap. */
            if (i < heap_size && heap[i].end > *(outer_iter_end_next)) {
                /* skip region */
                outer_iter_start_next++;
                outer_iter_end_next++;
                outer_iter_iter_next++;
            } else {
                /* otherwise we've got a candidate */
                goto endofskipping;
            }
        }
endofskipping:
        if (outer_iter_start_next < outer_last_start)
            nearest_next_start = *(outer_iter_start_next);
        else
            nearest_next_start = MAX_@3;
        if (outer_iter_start < outer_last_start)
            nearest_start = *(outer_iter_start);
        else
            nearest_start = MAX_@3;

        // todo: an optimization would be to add all the regions with same start-pos at once
        //       if heap[next_iter].start = next_start --> add to heap
        // if (nearest_start == nearest_next_start) -> skip inner loop (next part)

        @:ll_@2(@1,@3)@

        outer_iter_start=outer_iter_start_next;
        outer_iter_end=outer_iter_end_next;
        outer_iter_iter=outer_iter_iter_next;

        if (outer_iter_start < outer_last_start) {
            heap_size = replace_in_heap_@3(heap,heap_size,
                    *outer_iter_iter,
                    *outer_iter_start,
                    *outer_iter_end);
            if (heap_size >= max_heap_size) {
                GDKerror("ll_@1_@2_join_sort_@3: "
                            "too many (>=%d) overlapping input intervals for standoff steps to work well.\n",
                            (int)max_heap_size );
                GDKfree(heap);
                BBPreclaim(bn);
                return GDK_FAIL;
            }
            if (*outer_iter_end < nearest_end)
                nearest_end=*outer_iter_end;
        }
    }
    GDKfree(heap); /* it might be possible there are still items left on the heap,
                       but we are out of target-regions, so they starve... */
    *result=bn;
    return(GDK_SUCCEED);
}
@


@= ll_standoff
@:ll_standoff_join_impl(select,narrow,@1,@2)@
@:ll_standoff_join_impl(select,wide,@1,@2)@
@

@= standoff
@:standoff_join_impl(select,narrow,@1,@2)@
@:standoff_join_impl(select,wide,@1,@2)@
@

@= heap_procs
typedef struct heap_@1 {
    @2 end,start;
    oid iter;
} heap_@1;

/* iters are unique within the heap */
int remove_iter_from_heap_@1(heap_@1 heap[], int size, oid iter) {
    int i;
    for (i=0;i < size && heap[i].iter != iter; i++);
    for (;   i < size-1;i++) {
      heap[i].end = heap[i+1].end;
      heap[i].start = heap[i+1].start;
      heap[i].iter = heap[i+1].iter;
    }
    return i;
}

/* assume the heap is sorted on 'end'
   we need to do two things:
    - if the same iter is already in the heap, remove it.
    - put the new values in the heap
*/
int replace_in_heap_@1(heap_@1 heap[], int size, oid iter, @2 start, @2 end) {
    size = remove_iter_from_heap_@1(heap, size, iter);
    /* now we are sure there is no heap-item with our iter anymore */
    /* lets bubble to new location for item */
    int i;
    for (i=size;(i > 0) && (heap[i-1].end < end); i--) {
        heap[i].end = heap[i-1].end;
        heap[i].start = heap[i-1].start;
        heap[i].iter = heap[i-1].iter;

    }
    heap[i].iter = iter;
    heap[i].end = end;
    heap[i].start = start;
    /* return the new heapsize */
    return size+1;
}

@

@= ffb
int
CMDfetch_standoff_data_@1(BAT ** result, BAT * region_start, BAT * region_end, char * blobname) {
    // fetches strings from the blob for the regions (start, end) found in two [oid, @1] bats
    // regions should be sorted by start
    // non-loop-lifted
    // result is BAT[VOID,STR]
    @2 *iter_start, *iter_end, *start_next;
    @2 count, blob_pos, *last_iter_start, next_stop, min_end;
    int c =0;
    int heap_size, i, j;
    struct { @2 start, end; } heap[1024]; // probably a to high estimation, but to be sure...
    char buf[4098], temp[4096];

    FILE *blob;
    // open blob
    if ((blob = fopen(blobname,"rb")) == NULL) {
        GDKerror("could not open Stand-Off data file (the BLOB)\n");
        return(GDK_FAIL);
    }
    min_end = MAX_@1;
    *result = BATnew(TYPE_void, TYPE_str, BATcount(region_start));

    // initialize vars
    iter_start =  (@2 *) Tloc(region_start, BUNfirst(region_start));
    iter_end =  (@2 *) Tloc(region_end, BUNfirst(region_end));
    start_next = iter_start + 1;
    last_iter_start =  (@2 *) Tloc(region_start, BUNlast(region_start));
    count = 0;
    blob_pos =0;
    heap_size = 0;
    while (iter_start < last_iter_start) {
        start_next = iter_start + 1;
        //  fast-forward if heap is empty
        if (heap_size==0) {
		fseek(blob,*iter_start,SEEK_SET);
		blob_pos=*iter_start;
	}
        //   push new region on heap
	if ((*iter_end - *iter_start) / 4096 > 0) {
            GDKerror("BLOB: Cannot handle regions larger than 4096 bytes\n");
            return(GDK_FAIL);
        }
        heap[heap_size].start=*iter_start;
        heap[heap_size].end=*iter_end;
	heap_size++;

        // also allocate the memory for the string.
        if (heap_size == 1023) {
            GDKerror("fetch_standoff_data: too many (>= 1024) overlapping intervals for standoff steps to work well.\n");
            fclose(blob);
            return(GDK_FAIL);
        }

        //   start fetching till either: end of region or start of new region (whichever comes first)
        min_end = MAX_@1;
        for (i=0;i<heap_size;i++)
            if (heap[i].end < min_end)
               min_end=heap[i].end;
        if (start_next == last_iter_start || *start_next > min_end)
		next_stop = min_end;
	else
		next_stop = *start_next;

        while (blob_pos < next_stop) {
            c = fgetc(blob);
            if (c == EOF) break;
            // if (c <= 9) c = ' '; // get rid of system-chars
            buf[blob_pos % 4096] = (char) c;
            blob_pos++;
        }

        // remove all heap-items with end == blob_pos (or if EndOfFile, end all items on heap)
        // there could have been an item ending, otherwise a new one
        // will start
        if ((blob_pos == min_end) || (c == EOF))
            for (i=0;i<heap_size;i++)
                if ((heap[i].end == min_end) || (c == EOF)) {
                    if ((heap[i].start % 4096) < (blob_pos % 4096)) {
                      // we have to return (start..end)
                      buf[blob_pos % 4096] = '\0'; // zero-terminate string
                      BUNappend(*result, (ptr)(buf + (heap[i].start % 4096)), FALSE);
                    } else {
                      // we have to concatenate the two parts (start..4095) + (0...end)
                      for (j=0; j < blob_pos - heap[i].start; j++)
                        temp[j] = buf[(heap[i].start + j) % 4096];
                      temp[j]='\0'; // zero-terminate string
                      BUNappend(*result, (ptr)temp, FALSE);
                    }
                    heap_size--; // pop from heap
                    heap[i].start = heap[heap_size].start;
                    heap[i].end = heap[heap_size].end;
                }
        // move to next item
        iter_start++; iter_end++; start_next++; count++;
    }
    // return result
    fclose(blob);
    return(GDK_SUCCEED);
}
@

@mil

######### START OF NEW CODE #######################
### line 809 of pf_support.mx


#############################################
# MIL WRAPPER for AXIS STEPS
#

@:standoff_wrap(select_narrow)@
@:standoff_wrap(select_wide)@

### line 847 of pf_support.mx

@= chk_order
    if ( and(order,1) = @2 ) {
       	@3 := @3.chk_order(); # just in case...
        if ( not(ordered(reverse(@3))) ) {
            ERROR("@1: tail of @3 must be sorted!");
        }
    }
@

### line 868 of pf_support.mx
@= standoff_wrap
PROC @1 (BAT[oid,oid] iter, BAT[oid,oid] item, oid cont, BAT[void,bat] ws, int order, BAT[void,oid] cands, chr kind_test) : BAT[void,bat]
{
    var result := nil;
    var one_iter := FALSE;
    var one_item := FALSE;
    var min_iter := oid_nil;
    var max_iter := oid_nil;
    
    # check consistency
    if ( isnil(seqbase(iter)) or isnil(seqbase(item)) ) {
       	ERROR("@1(0): heads of iter & item/ctx must not be NIL!");
    }
    if ( (count(iter) != count(item)) or (seqbase(iter) != seqbase(item)) ) {
       	ERROR("@1(1): heads of iter & item/ctx must be aligned (count(iter)="+str(count(iter))+", count(item)="+str(count(item))+", seqbase(iter)="+str(seqbase(iter))+", seqbase(item)="+str(seqbase(item))+") !");
    }
    @:chk_order(@1(3),0,iter)@
    @:chk_order(@1(4),1,item)@
    cands := cands.chk_order(); # just in case...


    # trivial cases
    ## the trivial case with PRE_SIZE does not apply (at least,
    ## we do not want to use the PRE_SIZE bat)
    if ( (count(item) = 0) or (count(cands) = 0)) {
       	result := new(void,bat,2).seqbase(0@0)
       	          .append(bat(void,oid,0).seqbase(0@0).access(BAT_READ))
       	          .append(bat(void,oid,0).seqbase(0@0).access(BAT_READ))
       	          .access(BAT_READ);
       	return result;
    }

    ## Special cases don't work for select-narrow, select-wide
    ## perhaps other special cases apply


    # get access to a region index or create it on-the-fly (private or shared)
    var coll_shortlock := reverse(ws.fetch(CONT_RUNTIME).fetch(cont)).fetch(RT_LOCK_FREELIST);
    if (cont != WS) {
        lock_set(coll_shortlock);
        var err := CATCH(__regionindex_get(ws, cont)); # try to use a shared index
        lock_unset(coll_shortlock);
        if (not(isnil(err))) ERROR(err);
    }
    if (ttype(ws.fetch(REGION_PRE).fetch(cont)) = oid) {
        regionindex_extract(ws, cont, "lng"); # do the indexing work outside the lock
        if (cont != WS) {
            lock_set(coll_shortlock);
            CATCH(__regionindex_set(ws, cont)); # try to share the index
            lock_unset(coll_shortlock);
        }
    }
    var region_pre   := ws.fetch(REGION_PRE).fetch(cont);
    var region_start := ws.fetch(REGION_START).fetch(cont);
    var region_end   := ws.fetch(REGION_END).fetch(cont);

    # pre-sort input
    if ( and(order,1) = 0 ) {
        var ord := item.tsort();
        ord := ord.CTrefine(iter).mark(0@0).reverse();
        iter := ord.leftfetchjoin(iter);
        item := ord.leftfetchjoin(item);
        iter := iter.chk_order();
        item := item.chk_order();
    }

    # the actual location step
    if ( isnil(result) ) {
       	## - we don't need the min_iter, max_iter, one_iter, one_item...
       	## but we DO need region_pre, _start, _end
        ## - only the PRE-values in the cands-bat are needed
       	var res := ll_standoff_@1 (cands.reverse().project(nil).reverse(), iter, item, region_pre, region_start, region_end);
    	result := new(void,bat,2).seqbase(0@0)
       	          .append(res.mark(0@0).reverse())
       	          .append(res.reverse().mark(0@0).reverse())
       	          .access(BAT_READ);
    }

    # post-sort output
    if ( (and(order,2) = 2) and not(ordered(reverse(result.fetch(1)))) ) {
       	iter := result.fetch(0);
       	item := result.fetch(1);
       	var ord := item.tsort();
       	    ord := ord.CTrefine(iter).mark(0@0).reverse();
       	result := new(void,bat,2).seqbase(0@0)
       	          .append(ord.leftfetchjoin(iter).chk_order())
       	          .append(ord.leftfetchjoin(item).chk_order())
       	          .access(BAT_READ);
    }

    # post-sort output
    if ( (and(order,2) = 0) and not(ordered(reverse(result.fetch(0)))) ) {
       	iter := result.fetch(0);
    	item := result.fetch(1);
       	var ord := iter.tsort();
            ord := ord.CTrefine(item).mark(0@0).reverse();
        result := new(void,bat,2).seqbase(0@0)
                  .append(ord.leftfetchjoin(iter).chk_order())
       	             .append(ord.leftfetchjoin(item).chk_order())
       	          .access(BAT_READ);
    }
    return result;
}
ADDHELP("@1", "tsheyar,vzzzbx", "Sep 2006",
"PARAMETERS:\n\
BAT[void,oid] iter (grouping relation)\n\
BAT[void,oid] item (context set)\n\
oid cont (the current container of the ws)\n\
BAT[void,bat] ws (working set)\n\
int order (input & output order properties:\n\
           bit 0: input is sorted on iter(0) or item(1)\n\
           bit 1: output must be sorted on iter(0) or item(1))\n\
BAT[void,oid] cands (sorted list of result candidate OIDs in the tail)\n\
DESCRIPTION:\n\
returns all nodes on the @1 axis of the item-nodes duplicate free for each group.\n\
NOTE: this code is copied from pf_support (and was then modified)",
"pf_standoff");
@
### line 993 of pf_support.mx
@

## the standoff_step doesn't seem to be used. (therefore omitted)

### line 1073 of pf_support.mx

@mil
@:loop_lifted_standoffjoin_wrap1(select_narrow)@
@:loop_lifted_standoffjoin_wrap1(select_wide)@
@

### line 1106 of pf_support.mx

#==================================================================
# expansions of the loop lifted standoffjoin
# kind argument
@= kind_args
, chr kind
@
@= kind_params
, kind
@
# tagname argument
@= ns_args
, str ns
@
@= ns_params
, ns
@
@= loc_args
, str loc
@
@= loc_params
, loc
@
@= tgt_args
, str tgt
@
@= tgt_params
, tgt
@
@= nsloc_args
, str ns, str loc
@
@= nsloc_params
, ns, loc
@
@= params2
, cands, kind_test
@= postfilter
if (postfilter) {
    var pre_cont := ws.fetch(PRE_CONT).fetch(contID);
    var pre_kind := ws.fetch(PRE_KIND).fetch(contID);
    var pre_prop := ws.fetch(PRE_PROP).fetch(contID);
    if (is_constant(pre_cont)) {
        # determine a sel [qnid,qnid] of qualifying nslocs (i.e. prop IDs)
        var sel := ws.fetch(@1).fetch(bat2constant(pre_cont)).ord_uselect(@2);

        # first join on prop, getting some false hits for non ELEMENT nodes
        tmp_res := result_part_item.leftfetchjoin(pre_prop).leftjoin(sel).hmark(0@0);

        # remove false hits
        tmp_res := tmp_res.leftfetchjoin(result_part_item).leftfetchjoin(pre_kind).ord_uselect(@3).hmark(0@0).leftfetchjoin(tmp_res);
    } else {
        # the cont value refers back to multiple different containers (XPath step in transient doc container)

        # first select the element nodes
        var X := result_part_item.leftfetchjoin(pre_kind).ord_uselect(@3).hmark(0@0);

        # fetch cont and prop values
        tmp_res := X.leftfetchjoin(result_part_item);
        var X_cont  := tmp_res.leftfetchjoin(pre_cont);
        var X_prop  := tmp_res.leftfetchjoin(pre_prop);

        # get qnames using mposjoin from the source containers
        var X_nsloc := mposjoin(X_prop, X_cont, ws.fetch(@1));

        # final select
        tmp_res := X_nsloc.ord_uselect(@2).hmark(0@0).leftfetchjoin(X);
    }
    @:mapping_code@
}
@= mapping_code
    result_part_iter := tmp_res.leftfetchjoin(result_part_iter);
    result_part_item := tmp_res.leftfetchjoin(result_part_item);
    tmp_res := nil;
@= nsloc_post
      { var nsloc := ns + NS_ACCEL_SEP + loc; @:postfilter(QN_URI_LOC,nsloc,ELEMENT)@ }
@= loc_post
    @:postfilter(QN_LOC,loc,ELEMENT)@
@= ns_post
    @:postfilter(QN_URI,ns,ELEMENT)@
@= target_post
    @:postfilter(PROP_TGT,tgt,PI)@
@= kind_post
    if (postfilter) {
        var pre_kind := ws.fetch(PRE_KIND).find(contID);
        tmp_res := result_part_item.leftfetchjoin(pre_kind).ord_uselect(@1).hmark(0@0);
        @:mapping_code@
    }
@= no_pre
    cands := ws.fetch(PRE_SIZE).fetch(contID).mirror(); # no selection: cands is everything
@= kind_pre
      { cands := ws.fetch(PRE_KIND).fetch(contID).mirror(); kind_test := kind; }
@= nsloc_pre
      { var nsloc := ns + NS_ACCEL_SEP + loc; @:prefilter(nsloc,QN_URI_LOC)@ }
@= loc_pre
      { @:prefilter(loc,QN_LOC)@ }
@= ns_pre
      { @:prefilter(ns,QN_URI)@ }
@= prefilter
    cands := ws.fetch(PRE_SIZE).fetch(contID).mirror();
    var pre_cont := ws.fetch(PRE_CONT).fetch(contID);
    if (is_constant(pre_cont)) {
        var qn_sel := ws.fetch(@2).fetch(bat2constant(pre_cont)).ord_uselect(@1);
        if (isnil(CATCH(cands := ws_lookup(ws, contID, qn_sel.mirror())))) {
                    var map_pid  := ws.fetch(MAP_PID).fetch(contID);
                    var nid_rid  := ws.fetch(NID_RID).fetch(contID);
                    cands := cands.leftfetchjoin(nid_rid).[swizzle](map_pid); # free in readonly case
                    cands.reverse().chk_order(); # TODO: can we avoid a scan here?
                    cands := cands.tsort(); # ouch! but should be a view in the readonly case
                    postfilter := false; # we have a true candidate list
        }
        ## NOTE: in case of standoff, we are not allowed to filter out
        ## pre's before or after the ctx-set of pre's
    } # else we use postfilter (after SCJ)
    cands := cands.tmark(0@0);
@
### line 1233 of pf_support.mx
# expanding the standoffjoin for the different tests

## replaced standoffjoin with standoffjoin
@= loop_lifted_standoffjoin_wrap1
@:loop_lifted_standoffjoin_wrap_pre(@1)@
@
@= loop_lifted_standoffjoin_wrap_pre
@:loop_lifted_standoffjoin_step2(@1,,,,,                                                               @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@,,                   @:params2@,@:kind_pre(kind)@)@
@:loop_lifted_standoffjoin_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@,     @:params2@,@:nsloc_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@,        @:params2@,@:ns_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@,       @:params2@,@:loc_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@,    @:params2@,@:no_pre@)@
@
@= loop_lifted_standoffjoin_wrap_post
@:loop_lifted_standoffjoin_step2(@1,,,,,                                                               @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@, @:kind_post(kind)@,@:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@,     @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@,        @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@,       @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@,    @:params2@,@:no_pre@)@
@
@= loop_lifted_standoffjoin_step1
@:loop_lifted_standoffjoin_step2(@1,,,,,,                                                               )@
@:loop_lifted_standoffjoin_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@, @:kind_post(kind)@,,)@
@:loop_lifted_standoffjoin_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@     ,,)@
@:loop_lifted_standoffjoin_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@        ,,)@
@:loop_lifted_standoffjoin_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@       ,,)@
@:loop_lifted_standoffjoin_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@    ,,)@
@
#==================================================================
# actual definition of the standoffjoin proc
@= loop_lifted_standoffjoin_per_cont
	result_part_iter := result_part_iter.chk_order();
	result_part_item := result_part_item.chk_order();
        result_part_cont := nil;

	# pre-test
	@4
    var result := @1 (result_part_iter, result_part_item, contID, ws, order @3);
	result_part_iter := result.fetch(0);
	result_part_item := result.fetch(1);
    result_part_cont := constant2bat(contID);
	cands := nil;

	# post-test
	@2
@
@= loop_lifted_standoffjoin_step2
PROC loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] cont, bat[void, bat] ws @3) : bat[void,bat]
{
     return loop_lifted_@1_step@2 (iter, item, cont, ws, 0 @4);
}
PROC loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] cont, bat[void, bat] ws, int order @3) : bat[void,bat]
{
    # handle empty results correctly
    if (iter.count() = 0) {
	var empty := bat(void,oid,0).seqbase(0@0).access(BAT_READ);
	return bat(void,bat,3).seqbase(0@0)
			    .append(empty)
			    .append(empty)
			    .append(empty)
			    .access(BAT_READ);
    }

    var result;
    var result_iter;
    var result_item;
    var result_cont;
    var tmp_res;
    var cands;
    var kind_test := chr_nil;
    var postfilter := true;

    var uniqueCont := cont.tunique().sort();
    var contID := uniqueCont.reverse().fetch(0);
    if (uniqueCont.count() = 1) {
        var result_part_cont := oid_nil;
        var result_part_iter := iter;
        var result_part_item := item;

        @:loop_lifted_standoffjoin_per_cont(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_cont := result_part_cont;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_cont := nil;
    } else {
        var result_part_cont := cont.ord_uselect(contID).hmark(0@0);
        var result_part_iter := result_part_cont.leftfetchjoin(iter);
        var result_part_item := result_part_cont.leftfetchjoin(item);

        @:loop_lifted_standoffjoin_per_cont(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_cont := result_part_cont;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_cont := nil;

    	var res_mu;
		uniqueCont.slice(1,uniqueCont.count() - 1)@batloop () {
	    	contID := $h;
            result_part_cont := cont.ord_uselect(contID).hmark(0@0);
            result_part_iter := result_part_cont.leftfetchjoin(iter);
            result_part_item := result_part_cont.leftfetchjoin(item);

            @:loop_lifted_standoffjoin_per_cont(@1,@5,@6,@7)@

            if ( and(order,2) = 2 )
	    	{
	        	res_mu := merged_union(result_item, result_part_item,
	             		   result_iter, result_part_iter,
	             		   result_cont, result_part_cont);
                result_part_iter := nil;
                result_part_item := nil;
                result_part_cont := nil;
                result_item := res_mu.fetch(0);
                result_iter := res_mu.fetch(1);
                result_cont := res_mu.fetch(2);
                res_mu := nil;
	    	}
	    	else
	    	{
	        	res_mu := merged_union(result_iter, result_part_iter,
	             		   result_item, result_part_item,
	             		   result_cont, result_part_cont);
                 result_part_iter := nil;
                 result_part_item := nil;
                 result_part_cont := nil;
                 result_iter := res_mu.fetch(0);
                 result_item := res_mu.fetch(1);
                 result_cont := res_mu.fetch(2);
                 res_mu := nil;
	    	}
        }
    }

    result_iter.access(BAT_READ);
    result_item.access(BAT_READ);
    result_cont.access(BAT_READ);
    var result_standoffjoin := bat(void,bat,3).seqbase(0@0);
    result_standoffjoin.append(result_iter);
    result_standoffjoin.append(result_item);
    result_standoffjoin.append(result_cont);

    return result_standoffjoin.access(BAT_READ);
}
@
### line 1384 of pf_support.mx

@= ll_standoff_mil
################################################
# Loop Lifted version of the @1-@2 StandOff Step
# invoked by ll_standoff_step (returns PRE's)
PROC ll_standoff_@1_@2(BAT[void,oid] cands,
                       BAT[oid,oid] iter,
                       BAT[oid,oid] ctx,
                       BAT[oid,oid] region_pre,
                       BAT[oid,any] region_start,
                       BAT[oid,any] region_end
                       ) : BAT[oid,oid]
{
  # prepare all the regions
  var max_iter := iter.max();
  var source_region := ctx.join(region_pre.reverse()).reverse();
  var region_iter := source_region.leftjoin(iter);
  source_region := source_region.mirror().leftjoin(region_start).sort().project(nil).reverse();
  var source_iter := source_region.leftjoin(region_iter).tmark(0@0);

  #  try to get a iter_start...
  var source_start := source_region.leftjoin(region_start).tmark(0@0);
  var iter_start := source_iter.[oid]().reverse().leftjoin(source_start).reverse().[oid]().reverse();
  var source_end := source_region.leftjoin(region_end).tmark(0@0);

  var sel_region := cands.reverse().mirror().leftjoin(region_pre.reverse()).reverse().mirror();
  var sel_region2 := sel_region.leftjoin(region_start).sort().hmark(0@0);
  var sel_start := sel_region2.leftjoin(region_start);
  var sel_end := sel_region2.leftjoin(region_end);

  # do the join
  # FIXME: Wouter: as of version 0.12 document-containers can hold multiple documents
  # we actually should do a batloop here (iterate over all documents in a document-container)
  # and per-document we should find the proper context-nodes and candidates

  # another option would be to modify the ll_@1_@2_join_sort
  var result := ll_@1_@2_join_sort(iter_start, source_end,
                                   sel_start, sel_end);

  # and convert the regions back to PRE's
  result := result.leftjoin(sel_region2);
  result := result.leftjoin(region_pre);

  # must have [iter,pre] order. First sort on iter (in-place, with order()).
  result.chk_order().access(BAT_WRITE).order().access(BAT_READ);

  # get positions in [iter,pre] order with CTrefine, and fetch positionally
  return result.fetch(CTrefine(result.hmark(0@0), result.tmark(0@0)));
}
@
@= standoff_mil
# actual step (non-loop-lifted)
PROC standoff_@1_@2(BAT[void,oid] cands,
                    BAT[oid,void] ctx,
                    BAT[oid,oid] region_pre,
                    BAT[oid,any] region_start,
                    BAT[oid,any] region_end
                    ) : BAT[void,oid]
{
  # prepare all the regions
  var source_region := ctx.reverse().join(region_pre.reverse()).reverse().mirror();
  source_region := source_region.leftjoin(region_start).sort().reverse();
  var source_start := source_region.leftjoin(region_start).tmark(0@0);
  var source_end := source_region.leftjoin(region_end).tmark(0@0);

  # sel_region = region_region?
  var sel_region := cands.reverse().mirror().leftjoin(region_pre.reverse()).reverse().mirror();
  # sel_region2 is translation-table sel-region
  var sel_region2 := sel_region.leftjoin(region_start).sort().hmark(0@0);
  var sel_start := sel_region2.leftjoin(region_start);
  var sel_end := sel_region2.leftjoin(region_end);

  # do the join
  # FIXME: Wouter: as of version 0.14 document-containers can hold multiple documents
  # we actually should do a batloop here (iterate over all documents in a document-container)
  var result := @1_@2_join_sort(source_start, source_end,
                                sel_start, sel_end);

  # and convert the regions back to PRE's
  result := result.leftjoin(sel_region2);
  result := result.leftjoin(region_pre).reverse().mark(0@0).sort();
  return result;
}
@

### line 1385 of pf_support.mx
######### END OF NEW CODE #######################

@mil
# if the index is available, use it
PROC __regionindex_get(BAT[void,bat] ws, oid cont) : void
{
    # get things out of runtime, protected by the coll_shortlock
    var runtime := ws.fetch(CONT_RUNTIME).fetch(cont);
    ws.fetch(REGION_PRE).replace(cont,   runtime.fetch(RT_REGION_PRE));
    ws.fetch(REGION_START).replace(cont, runtime.fetch(RT_REGION_START));
    ws.fetch(REGION_END).replace(cont,   runtime.fetch(RT_REGION_END));
}

# set the index to what we just extracted (if allowed)
PROC __regionindex_set(BAT[void,bat] ws, oid cont) : void
{
    var runtime := ws.fetch(CONT_RUNTIME).fetch(cont);

    # We check whether the index has not been updated yet by another transaction
    # by checking whether the value we put in RT_REGION_WSID is still the same
    # unique value we put in it when the document was opened. 
    # Hacky implemented by comparing a mangled ws-id with the RT_REGION_WSID entry
    # This mangling gets the 32 highest bits of the ws_id (originally a newoid(1))
    # and sets the first bit such that the number is odd. That way it can never
    # be confused with a lock (= memory address = even).
    if (lng(reverse(runtime).fetch(RT_REGION_WSID)) = or(1LL, (ws_id(ws) >> 32))) {
        # ok, share the computed region index such that other transactions can profit from it
        var region_pre := ws.fetch(REGION_PRE).fetch(cont);
        var region_start := ws.fetch(REGION_START).fetch(cont);
        var region_end := ws.fetch(REGION_END).fetch(cont);
        runtime.replace(RT_REGION_PRE_LOCK,   region_pre);
        runtime.replace(RT_REGION_START_LOCK, region_start);
        runtime.replace(RT_REGION_END_LOCK,   region_end);

        # memory leak debugging: give index bats a reconizable name
        var prefix := runtime.bbpname() + "_" + str(lng(ws.fetch(CONT_COLL).fetch(cont)));
        region_pre.bbpname(prefix + "region_pre"); 
        region_start.bbpname(prefix + "region_start"); 
        region_end.bbpname(prefix + "region_end"); 
    }
}

# build the index, put it in the working set (for private use)
PROC regionindex_extract(BAT[void,bat] ws, oid cont, str tpe) : void
{
        
    var region_pre, region_start, region_end;
    var XIRAF_nodes := ws.fetch(QN_LOC).fetch(cont).reverse()
                         .leftjoin(ws.fetch(QN_PREFIX).fetch(cont).ord_uselect(region_namespace).mirror());

    var start_qn := nil, end_qn := nil;
    if (isnil(CATCH({ start_qn := XIRAF_nodes.find(region_start_attr_tag);
                        end_qn := XIRAF_nodes.find(region_end_attr_tag); })) and (cont != WS)) 
    {
        var nid_rid  := ws.fetch(NID_RID).fetch(cont);
        var map_pid  := ws.fetch(MAP_PID).fetch(cont);
        var prp_val  := ws.fetch(PROP_VAL).fetch(cont);
        var attr_qn  := ws.fetch(ATTR_QN).fetch(cont);
        var attr_own := ws.fetch(ATTR_OWN).fetch(cont);
        var attr_prp := ws.fetch(ATTR_PROP).fetch(cont);

        # get all start attributes, then their numerical value, sort it, and then get the PRE's
        var attr_attr := attr_qn.ord_uselect(start_qn).mirror();
        var attr_prop := attr_attr.leftjoin(attr_prp);
        var val_start := [*tpe](attr_prop.leftjoin(prp_val)).reverse().sort();
        var start_nid := val_start.leftjoin(attr_own);

        # now we have a table with a PRE column and a start (numerical) column in the right order
        var left_pre := start_nid.tmark(0@0).leftfetchjoin(nid_rid).[swizzle](map_pid);
        var left_start := start_nid.hmark(0@0);

        # go get the PRE numbers that have an end attribute
        var right_attr := attr_qn.ord_uselect(end_qn).hmark(0@0);
        var right_pre := right_attr.leftjoin(attr_own).leftfetchjoin(nid_rid).[swizzle](map_pid);
        var right_end := [*tpe](right_attr.leftjoin(attr_prp).leftjoin(prp_val));

        # the region table is the intersection between start and end
        var left_right := left_pre.leftjoin(right_pre.reverse());
        var region_left := left_right.hmark(0@0);
        var region_right := left_right.tmark(0@0);

        region_pre := region_left.leftjoin(left_pre);
        region_start := region_left.leftjoin(left_start);
        region_end := region_right.leftjoin(right_end);
    } else {
        # if there are either no start or end nodes, the result is empty
        region_pre := bat(void,oid).seqbase(0@0);
        region_start := bat(void,monet_atomtbl.find(tpe)).seqbase(0@0);
        region_end := bat(void,monet_atomtbl.find(tpe)).seqbase(0@0);
    }
    # put the final result in the working set
    ws.fetch(REGION_PRE).replace(cont, region_pre);
    ws.fetch(REGION_START).replace(cont, region_start);
    ws.fetch(REGION_END).replace(cont, region_end);
}
ADDHELP("regionindex_extract", "wouter", "Oct 2005",
"PARAMETERS:\n\
BAT[str,BAT] an active ws (Working Set)\n\
oid coll_oid (index in the active working set)\n\
str tpe (type of region-values (int or lng))\n\
DESCRIPTION:\n\
adds three BATs to the working set REGION_PRE, REGION_START, and REGION_END and fills them.",
"pf_standoff");

    # FIXME: create a separate address range for each document in the container
    #        now standoff steps match nodes from different documents withing the same collection
    #        this semantics may actually be useful to XIRAF applications!

    # how-to: this region extract is used for the StandOff steps
    # if your regions are stored in different attributes than "start" and "end",
    # than modify the variables region_namespace, region_start_attr_tag, and
    # region_end_attr_tag

    # TODO: FIXME : the following code does not work, but should assign
    #               the largest possible region to the document-node
    #      if (=(tpe,"lng")) {
    #        region_pre := bat(void,oid).seqbase(0@0).append(0@0)
    #                                   .insert(region_left.leftjoin(left_pre));
    #        region_start := bat(void,lng).seqbase(0@0).append(getLNG_MIN())
    #                                     .insert(region_left.leftjoin(left_start));
    #        region_end := bat(void,lng).seqbase(0@0).append(getLNG_MAX())
    #                                   .insert(region_right.leftjoin(right_end));
    #     } else {
    #       region_pre := bat(void,oid).seqbase(0@0).append(0@0)
    #                                  .insert(region_left.leftjoin(left_pre));
    #       region_start := bat(void,INT).seqbase(0@0).append(getINT_MIN())
    #                                    .insert(region_left.leftjoin(left_start));
    #       region_end := bat(void,INT).seqbase(0@0).append(getINT_MAX())
    #                                  .insert(region_right.leftjoin(right_end));
    #     }
@

@c
#include "monetdb_config.h"
#include "pf_standoff.h"

/* simple heap operations for the loop-lifted StandOff join */
@:heap_procs(int,int)@
@:heap_procs(lng,long long)@

/* StandOff joins */
@:standoff(lng,long long)@
@:standoff(int,int)@

@:ll_standoff(lng,long long)@
@:ll_standoff(int,int)@

@- not implemented yet
@c
@:ffb(int, int)@
@:ffb(lng, long long)@

/* vim:set shiftwidth=4 expandtab: */
