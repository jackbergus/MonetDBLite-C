@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2006 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.

@f pf_standoff
@a Wouter Alink
@a Peter Boncz
@v 0.1
@t MIL primitives to support the StandOff Axis Steps in XQuery 

@* Introduction
@T
This module provides MIL primitives to support the StandOff
Axis Steps on top of MonetDB within the "Pathfinder" project.
This module is loaded when standoff-axis steps are enabled on
the server-side or when 'pf' is provided the option '-b' or the
equivalent long option '--enable-standoff'. In order to enable 
the StandOff Axis steps on the server side you need to add 
\texttt{standoff=enabled} to the \texttt{--set} option list. 
The default is \texttt{standoff=disabled}.

note: runtime support for the StandOff axis steps was added in the
0.12 release.

@- Select Narrow / Select Wide / Reject Narrow / Reject Wide
@T
The SN, SW, RN, RW joins are region joins based on the work by Forbes J. 
Burkowski (1992) ``Retrieval Activities in a Database Consisting of 
Heterogeneous Collections of Structured Text''

There are two major changes to Burkowski's original ideas: (1.) this 
implementation turns around the arguments, and (2.) it handles (partly) 
overlapping regions by including them in the SW (the results of SW and SN do 
not have to be disjunct) and the result of SN is a subset of SW.

When Burkowski defines \texttt{<chapter> SW \{"Feynman","virtual particle"\}}, this could 
be queried as:
\begin{verbatim}
  select_wide_join({"Feynman","virtual particle"},<chapter>)
\end{verbatim}
which will return all the chapter which contain either "Feynman" or "virtual 
particle". The AND-expression, as in: \texttt{<chapter> SW \{"Feynman"\} SW 
\{"virtual particle"\} }
could be written as:
\begin{verbatim}
 select_wide_join({"Feynman"},
        select_wide_join({"virtual particle"}, <chapter>))
\end{verbatim}

The reason for the swap in parameters is that the selection mechanisms are 
going to be used as "steps" in XPath, which are not "selection" but 
"navigation" operations.

Some more examples: the \texttt{reject\_wide\_join(\{"Feynman","virtual 
particle"\}, <chapter>) } would return all the chapters which do not 
contain (nor partly contain) either "Feynman" or "virtual particle"
and the \texttt{ reject\_narrow\_join(<chapter>,\{"Feynman","virtual 
particle"\}) } would return all the instances of "Feynman" and "virtual 
particle" which are not inside a chapter-region.

@
@* Module Definition 
@m
.MODULE pf_standoff;

@+ StandOff Joins
@T
The input for the joins are the current context: 
\begin{verbatim}
 BAT(<void>, <int>region start), BAT(<void>, <int>region end) 
\end{verbatim}
and the destination context, which have to be indicated by:
\begin{verbatim}
 BAT(<void>, <int>region start), BAT(<void>, <int>region end)
\end{verbatim}
The result is a list to the items in the destination context that match:
 (<void>, <oid>)

\emph{NOTE}: currently only 'int'- and 'lng'-type regions are implemented, but 
these joins could as well be implemented on floats, dates, and other data-types 
without much effort.

@- non loop-lifted StandOff joins
@= standoff_join_sigs
   .COMMAND @1_@2_join_sort(BAT[oid, @3], BAT[oid,@3], BAT[oid,@3], BAT[oid,@3]) :
	BAT[void,oid] = CMD@1_@2_join_sort_@3; "@1 @2 join (on @3s), using inputs sorted on start"
@
@m
# declaration StandOff joins (int)
@:standoff_join_sigs(select,narrow,int)@
@:standoff_join_sigs(select,wide,int)@
@:standoff_join_sigs(reject,narrow,int)@
@:standoff_join_sigs(reject,wide,int)@

# declaration StandOff joins (lng)
@:standoff_join_sigs(select,narrow,lng)@
@:standoff_join_sigs(select,wide,lng)@
@:standoff_join_sigs(reject,narrow,lng)@
@:standoff_join_sigs(reject,wide,lng)@
   
# interaction with the underlying data
.COMMAND blob(BAT[void,lng], BAT[void,lng], str) : 
	BAT[void,str] = CMDfetch_standoff_data_lng; "fetch data from region (start,end) blob (file)"
.COMMAND blob(BAT[void,int], BAT[void,int], str) : 
	BAT[void,str] = CMDfetch_standoff_data_int; "fetch data from region (start,end) blob (file)"
@

@- Loop-Lifted StandOff joins
@T
This variant of the StandOff joins uses loop-lifting to do the join for
multiple inputs in a single pass. The input are the input regions (with there
iteration value, sorted on "start"): 
\begin{verbatim}
  BAT(<oid>iter,<int>start)
  BAT(<oid>iter,<int>end)
\end{verbatim}
and the destination regions: 
\begin{verbatim}
  BAT(<void>id, <int>start) 
  BAT(<void>id, <int>end)
\end{verbatim}
The result will be a bat ([oid]iter,[oid]id), where 'iter' is the 
corresponding bucket and 'id' the region-id of the destination regions. 

\emph{NOTE}: only the iter in the input bat (<oid>iter,<int>start) is checked. the 'iter'-column in 
the bat (iter,end) is optional (can be void as well) as it is not used.

\emph{NOTE}: the seqbase of the id-columns is currently supposed to be 0@0.

\emph{NOTE}: the loop-lifted standoff joins (SN, SW, RN, RW) have not been tested 
thoroughly. The result is ordered on tail (the region identifier) and NOT on 
head (iter). (any additional testcases are welcome)
 
@-TODO: 
@T
\emph{KNOWN ISSUE}: currently the iter needs to be of type OID (and may NOT be VOID)

\emph{KNOWN ISSUE}: the loop-lifted REJECT standoff joins do NOT work
workaround: use the non-loop-lifted StandOff join or take the 
loop-lifted-"select"-join and calculate per iter the inverse of the result.

@m
# declaration StandOff joins (loop lifted, int)
@:ll_standoff_join_sigs(select,narrow,int)@
@:ll_standoff_join_sigs(select,wide,int)@
@:ll_standoff_join_sigs(reject,narrow,int)@
@:ll_standoff_join_sigs(reject,wide,int)@

# declaration StandOff joins (loop lifted, lng)
@:ll_standoff_join_sigs(select,narrow,lng)@
@:ll_standoff_join_sigs(select,wide,lng)@
@:ll_standoff_join_sigs(reject,narrow,lng)@
@:ll_standoff_join_sigs(reject,wide,lng)@

@= ll_standoff_join_sigs
   .COMMAND ll_@1_@2_join_sort(BAT[oid, @3], BAT[oid,@3], BAT[oid,@3], BAT[oid,@3]) :
	BAT[oid,oid] = CMDll_@1_@2_join_sort_@3; "loop lifted @1 @2 join (on @3s), using inputs sorted on start"
@

@- StandOff Axis Steps

@mil
module(alarm);
module(aggrX3);
module(malalgebra);
module(mmath);
module(xtables);


# FIXME/TODO: the attribute-names should be set by a 'declare option' statement inside
# an XQuery expression
var region_namespace := "";
var region_start_attr_tag := "start";
var region_end_attr_tag := "end";

# Wouter: 
@:ll_standoff_mil(select,narrow)@
@:ll_standoff_mil(select,wide)@
@:ll_standoff_mil(reject,narrow)@
@:ll_standoff_mil(reject,wide)@
@:standoff_mil(select,narrow)@
@:standoff_mil(select,wide)@
@:standoff_mil(reject,narrow)@
@:standoff_mil(reject,wide)@
@

@m
.END pf_standoff;
@

@h
#ifndef __PF_STANDOFF_H__
#define __PF_STANDOFF_H__

#include "pf_standoff.proto.h"
#include <monet.h>
#include <monet_interpreter.h>
#include <monettime.h>
#include <lock.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <gdk.h>
#include <limits.h>

#define MAX_int INT_MAX
#define MAX_lng LLONG_MAX
#define MIN_int INT_MIN
#define MIN_lng LLONG_MIN

#endif 
@

@= select_outside
            /* skip nodes which are not contained */
@
@= reject_outside
            /* insert nodes which are not contained */
            index = BUNindex(region_start,iter_start);
            BUNappend(bn, (ptr)(&index), FALSE);
@
@= select_inside
            /* insert nodes which are contained */
            index = BUNindex(region_start,iter_start);
            BUNappend(bn, (ptr)(&index), FALSE);
@
@= reject_inside
            /* skip nodes which are contained */
@
@= narrow
        if (outer_iter_start_next < outer_last_start) 
          outer_start_next = *(outer_iter_start_next);
        else 
          outer_start_next = MAX_@2;

        /* loop through the not strictly contained region */ 
        while(iter_start < last_start && *iter_start < *outer_iter_start) { 
            @:@1_outside@
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the strictly contained regions */
        while(iter_start < last_start && *iter_start < outer_start_next) {
            if (*iter_end <= *outer_iter_end) {
              @:@1_inside@
            } else {
              @:@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre; 
        }
@
@= wide
        /* loop through the not even contained regions */
        while(iter_start < last_start && *iter_end < *outer_iter_start) { 
            @:@1_outside@
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the partly contained regions */
        while(iter_start < last_start && *iter_start <= *outer_iter_end) {
            if (*iter_end >= *outer_iter_start) {
              @:@1_inside@
            } else { 
              @:@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre; 
        }
@

@= region_jump_decl_narrow
    @1 outer_start_next;
@
@= region_jump_decl_wide
@

@= standoff_join_impl
int 
CMD@1_@2_join_sort_@3(BAT **result, BAT *source_start, BAT *source_end, BAT *region_start, BAT *region_end) {   

    @4 *iter_start, *iter_end, *last_start, 
        *outer_iter_start, *outer_iter_end, *outer_last_start, 
        *outer_iter_start_next, *outer_iter_end_next;

    @:region_jump_decl_@2(@4)@
        oid index;
    int Sss,Sse,Srs,Sre;
    BAT * bn = NULL;

    *result=NULL;

    if (!(ALIGNrelated(source_start,source_end)&1)) {
        GDKerror("@1_@2_join_sort_@3: source BATs not related.\n"); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(source_start)&1)) { 
        GDKerror("@1_@2_join_sort_@3: source BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }
    if (!(ALIGNrelated(region_start,region_end)&1)) {
        GDKerror("@1_@2_join_sort_@3: region BATs not related.\n"); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(region_start)&1)) { 
        GDKerror("@1_@2_join_sort_@3: region BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }

    if ((bn = BATnew(TYPE_void, TYPE_oid, BATcount(region_start))) == NULL) {
        GDKerror("@1_@2_join_sort_@3: could not allocate memory for result BAT.\n"); 
        return(GDK_FAIL);
    }

    iter_start = (@4 *) BUNtail(region_start, BUNfirst(region_start));
    iter_end = (@4 *) BUNtail(region_end, BUNfirst(region_end));
    last_start = (@4 *) BUNtail(region_start, BUNlast(region_start));
    outer_iter_start = (@4 *) BUNtail(source_start, BUNfirst(source_start));
    outer_iter_end = (@4 *) BUNtail(source_end, BUNfirst(source_end));
    outer_last_start = (@4 *) BUNtail(source_start, BUNlast(source_start));

    /* todo: what if size is not a multiple of sizeof(@4)  (BUNsize(...) % sizeof(@4) != 0) */
    Srs = BUNsize(region_start) / sizeof(@4);
    Sre = BUNsize(region_end) / sizeof(@4);
    Sss = BUNsize(source_start) / sizeof(@4);
    Sse = BUNsize(source_end) / sizeof(@4);

    while (outer_iter_start < outer_last_start) {
        outer_iter_start_next = outer_iter_start+Sss; outer_iter_end_next = outer_iter_end+Sse;

        /* skip overlapping region in the source  */
        while(outer_iter_start_next < outer_last_start
                && *(outer_iter_end_next) <= *(outer_iter_end)) {
            outer_iter_start_next+=Sss; outer_iter_end_next+=Sse;
        }

        @:@2(@1,@3)@

        outer_iter_start=outer_iter_start_next; outer_iter_end=outer_iter_end_next;
    }
    *result=bn;
    return(GDK_SUCCEED);
}
@
@= ll_select_outside
            /* skip nodes which are not contained */
@
@= ll_reject_outside
            /* insert nodes which are not contained */
            // FIXME: we need to include the iters not on the heap...
            index = BUNindex(region_start,iter_start) - BUNindex(region_start, BUNfirst(region_start));
            BUNins(bn, (ptr)(&(heap[i].iter)), (ptr)(&index), FALSE);
@
@= ll_select_inside
            /* insert nodes which are contained */
            index = BUNindex(region_start,iter_start) - BUNindex(region_start, BUNfirst(region_start)); 
            BUNins(bn, (ptr)(&(heap[i].iter)), (ptr)(&index), FALSE);
@
@= ll_reject_inside
            /* skip nodes which are contained */
@
@= ll_narrow
        /* loop through the not strictly contained region */ 
        /* nearest_start contains first upcoming starting point on heap
           heap contains a single element (or more if more regions start on 
           same place) */
        while(@:more_target_regions@ && *iter_start < nearest_start) { 
            for (i=0;i<heap_size;i++) {
              @:ll_@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the strictly contained regions */
        while(@:more_target_regions@ && *iter_start < nearest_next_start) {
            /* if there is a item that should be removed from the heap,
               we need to remove (it/them) */
            if (*iter_start > nearest_end) {
              nearest_end = MAX_@2;
              while ((heap_size > 0) && (heap[heap_size-1].end < *iter_start))
                  heap_size--;
              if (heap_size > 0) 
                  nearest_end = heap[heap_size-1].end;
            }

            /* FIXME: we now know that the heap is sorted on END, so we can 
               remove the if-statement here */
            for (i=0;i<heap_size;i++) {
              if (*iter_end <= heap[i].end) {
                @:ll_@1_inside@
              } else {
                @:ll_@1_outside@
              }
            }
            iter_start+=Srs; iter_end+=Sre; 
        }
        /* by now, we should be ready to push a new item on the heap 
           we processed as much as possible without this new item... */
@
@= ll_wide
        /* loop through the not even contained regions */
        /* nearest_start contains first upcoming starting point on heap
           heap should contain a single element (with outer_iter_start as nearest_start)
           if not, this step will automatically be skipped as iter_end will be more than 
           nearest_start */
        while(@:more_target_regions@ && *iter_end < nearest_start) {
            for (i=0;i<heap_size;i++) {
              @:ll_@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the partly contained regions 
           now there are some elements on the heap that want our attention */
        while(@:more_target_regions@ && *iter_end < nearest_next_start) {
            /* if we think there is at least one region that could be popped... */
            if (*iter_start > nearest_end ) {
              nearest_end = MAX_@2;
              while ((heap_size > 0) && (heap[heap_size-1].end < *iter_start))
                  heap_size--;
              if (heap_size > 0) 
                  nearest_end = heap[heap_size-1].end;
            }
            for (i=0;i < heap_size;i++) {
              if (*iter_end >= heap[i].start) {
                @:ll_@1_inside@
              } else { 
                @:ll_@1_outside@
              }
            }
            iter_start+=Srs; iter_end+=Sre; 
        }
        /* by now, we should be ready to push a new item on the heap 
           we processed as much as possible without this new item... */
@

@= more_target_regions
 (iter_start < last_start)
@

@= ll_standoff_join_impl
/* 4 aug 2005
   loop lifted standoff join implementation */
int 
CMDll_@1_@2_join_sort_@3(BAT **result, BAT *source_start, BAT *source_end, BAT *region_start, BAT *region_end) {

    @4 *iter_start, *iter_end, *last_start, 
        *outer_iter_start, *outer_iter_end, *outer_last_start, 
        *outer_iter_start_next, *outer_iter_end_next, 
        nearest_end = MIN_@3, nearest_next_start = MAX_@3, nearest_start = MAX_@3; 

    heap_@3 *heap;
    int max_heap_size = 1024;
    int heap_size = 0, i;
    oid index;
    oid *outer_iter_iter, *outer_iter_iter_next;
    int Sss,Sse,Srs,Sre, Ssi;
    BAT * bn = NULL;

    *result=NULL;

    // KNOWN ISSUE: the reject-part does not work (it needs to know which iters there are beforehand)
    // it also has to add the regions to all the iters that are currently not on the heap

    if (BATcount(source_start) != BATcount(source_end)) {
        GDKerror("ll_@1_@2_join_sort_@3: source BATs not related size(start) = %d != size(end) = %d.\n",
                (int) BATcount(source_start),(int)BATcount(source_end)); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(source_start)&1)) { 
        GDKerror("ll_@1_@2_join_sort_@3: source BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }
    if (!(ALIGNrelated(region_start,region_end)&1)) {
        GDKerror("ll_@1_@2_join_sort_@3: region BATs not related.\n"); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(region_start)&1)) { 
        GDKerror("ll_@1_@2_join_sort_@3: region BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }
    //TODO: in case the iter-table is void-nil, do something special... (should be easy)
    if (source_start->htype == TYPE_void && source_start->hseqbase == oid_nil) { 
        GDKerror("ll_@1_@2_join_sort_@3: iter-list is of type NIL instead of [V]OID.\n"); 
        return(GDK_FAIL);
    }

    // the number of iters is also the maximum depth of the heap 
    // (however, in most cases the heap will be very shallow,
    // only overlapping nodes will share the heap)
    // we could allocate a lot less space:
    // probably log(|iter|) would be more than enough in most cases
    // counting iters is probably expensive, for now we only reserve for a fixed amount.. 
    if ((heap = (heap_@3 *)GDKmalloc(sizeof(heap_@3) * max_heap_size)) == NULL) {
        GDKerror("ll_@1_@2_join_sort_@3: could not allocate memory for heap.\n"); 
        return(GDK_FAIL);
    }
    // the size of the bat is maybe not correct (could be more, could be less)
    
    if ((bn = BATnew(TYPE_oid, TYPE_oid, BATcount(region_start))) == NULL) {
        GDKerror("ll_@1_@2_join_sort_@3: could not allocate memory for result BAT.\n"); 
        GDKfree(heap);
        return(GDK_FAIL);
    }

    iter_start = (@4 *) BUNtail(region_start, BUNfirst(region_start));
    iter_end = (@4 *) BUNtail(region_end, BUNfirst(region_end));
    last_start = (@4 *) BUNtail(region_start, BUNlast(region_start));
    outer_iter_iter = (oid *) BUNhead(source_start, BUNfirst(source_start));
    outer_iter_start = (@4 *) BUNtail(source_start, BUNfirst(source_start));
    outer_iter_end = (@4 *) BUNtail(source_end, BUNfirst(source_end));
    outer_last_start = (@4 *) BUNtail(source_start, BUNlast(source_start));

    /* todo: do we have to check for var-sized bats? */
    /* todo: what if size is not a multiple of sizeof(@4)  (BUNsize(...) % sizeof(@4) != 0) */
    Srs = BUNsize(region_start) / sizeof(@4);
    Sre = BUNsize(region_end) / sizeof(@4);
    Sss = BUNsize(source_start) / sizeof(@4);
    Sse = BUNsize(source_end) / sizeof(@4);
    Ssi = BUNsize(source_start) / sizeof(oid);

    heap_size = replace_in_heap_@3(heap,heap_size,
            *outer_iter_iter,
            *outer_iter_start,
            *outer_iter_end);

    while (@:more_target_regions@) {
        outer_iter_start_next = outer_iter_start+Sss; 
        outer_iter_end_next = outer_iter_end+Sse;
        outer_iter_iter_next = outer_iter_iter+Ssi;

        /* skip (completely) overlapping regions (in same iter) in the source  
           this is NOT an optimization, it is neccessary to capture all the regions */
        while (outer_iter_start_next < outer_last_start) { 
            i=0;
            while (i < heap_size && heap[i].iter != *(outer_iter_iter_next)) i++;
            /* only skip region if there already is a region with the same iter 
               and the region is contained in the current region on the heap. */
            if (i < heap_size && heap[i].end > *(outer_iter_end_next)) {
                /* skip region */
                outer_iter_start_next+=Sss; 
                outer_iter_end_next+=Sse;
                outer_iter_iter_next+=Ssi;
            } else {
                /* otherwise we've got a candidate */
                goto endofskipping; 
            }
        }
endofskipping:
        if (outer_iter_start_next < outer_last_start) 
            nearest_next_start = *(outer_iter_start_next);
        else                                          
            nearest_next_start = MAX_@3;
        if (outer_iter_start < outer_last_start) 
            nearest_start = *(outer_iter_start);
        else 
            nearest_start = MAX_@3;

        // todo: an optimization would be to add all the regions with same start-pos at once
        //       if heap[next_iter].start = next_start --> add to heap
        // if (nearest_start == nearest_next_start) -> skip inner loop (next part)

        @:ll_@2(@1,@3)@

        outer_iter_start=outer_iter_start_next; 
        outer_iter_end=outer_iter_end_next;
        outer_iter_iter=outer_iter_iter_next; 

        if (outer_iter_start < outer_last_start) {
            heap_size = replace_in_heap_@3(heap,heap_size,
                    *outer_iter_iter,
                    *outer_iter_start,
                    *outer_iter_end);
            if (heap_size >= max_heap_size) {
                GDKerror("ll_@1_@2_join_sort_@3: "
                            "too many (>=%d) overlapping input intervals for standoff steps to work well.\n", 
                            (int)max_heap_size );
                GDKfree(heap); 
                BBPreclaim(bn);
                return GDK_FAIL;
            }
            if (*outer_iter_end < nearest_end)  
                nearest_end=*outer_iter_end;
        }
    }
    GDKfree(heap); /* it might be possible there are still items left on the heap, 
                       but we are out of target-regions, so they starve... */
    *result=bn;
    return(GDK_SUCCEED);
}
@


@= ll_standoff
@:ll_standoff_join_impl(select,narrow,@1,@2)@
@:ll_standoff_join_impl(select,wide,@1,@2)@
@:ll_standoff_join_impl(reject,narrow,@1,@2)@
@:ll_standoff_join_impl(reject,wide,@1,@2)@
@

@= standoff
@:standoff_join_impl(select,narrow,@1,@2)@
@:standoff_join_impl(select,wide,@1,@2)@
@:standoff_join_impl(reject,narrow,@1,@2)@
@:standoff_join_impl(reject,wide,@1,@2)@
@

@= heap_procs
typedef struct heap_@1 {
    @2 end,start;
    oid iter;
} heap_@1;

/* iters are unique within the heap */
int remove_iter_from_heap_@1(heap_@1 heap[], int size, oid iter) {
    int i;
    for (i=0;i < size && heap[i].iter != iter; i++);
    for (;   i < size-1;i++) {
      heap[i].end = heap[i+1].end;
      heap[i].start = heap[i+1].start;
      heap[i].iter = heap[i+1].iter;
    } 
    return i;
}

/* assume the heap is sorted on 'end'
   we need to do two things:
    - if the same iter is already in the heap, remove it.
    - put the new values in the heap 
*/
int replace_in_heap_@1(heap_@1 heap[], int size, oid iter, @2 start, @2 end) {
    size = remove_iter_from_heap_@1(heap, size, iter);
    /* now we are sure there is no heap-item with our iter anymore */      
    /* lets bubble to new location for item */
    int i;
    for (i=size;(i > 0) && (heap[i-1].end < end); i--) {
        heap[i].end = heap[i-1].end; 
        heap[i].start = heap[i-1].start; 
        heap[i].iter = heap[i-1].iter; 
        
    }
    heap[i].iter = iter;
    heap[i].end = end;
    heap[i].start = start;
    /* return the new heapsize */
    return size+1;
}

@

@= ffb
int 
CMDfetch_standoff_data_@1(BAT ** result, BAT * region_start, BAT * region_end, char * blobname) {
    // fetches strings from the blob for the regions (start, end) found in two [oid, @1] bats
    // regions should be sorted by start
    // non-loop-lifted
    // result is BAT[VOID,STR]
    @2 *iter_start, *iter_end, start_inc, end_inc, *start_next;
    @2 count, blob_pos, *last_iter_start, next_stop, min_end;
    int c =0;
    int heap_size, i, j;
    struct { @2 start, end; } heap[1024]; // probably a to high estimation, but to be sure...
    char buf[4098], temp[4096];

    FILE *blob;
    // open blob
    if ((blob = fopen(blobname,"rb")) == NULL) {
        GDKerror("could not open Stand-Off data file (the BLOB)\n");
        return(GDK_FAIL);
    }
    min_end = MAX_@1; 
    *result = BATnew(TYPE_void, TYPE_str, BATcount(region_start)); 

    // initialize vars
    iter_start =  (@2 *) BUNtail(region_start, BUNfirst(region_start));
    start_inc = BUNsize(region_start) / sizeof(@2); 
    iter_end =  (@2 *) BUNtail(region_end, BUNfirst(region_end));
    end_inc = BUNsize(region_end) / sizeof(@2);
    start_next = iter_start + start_inc;
    last_iter_start =  (@2 *) BUNtail(region_start, BUNlast(region_start));
    count = 0;   
    blob_pos =0;   
    heap_size = 0;
    while (iter_start < last_iter_start) {
        start_next = iter_start + start_inc;
        //  fast-forward if heap is empty
        if (heap_size==0) { 
		fseek(blob,*iter_start,SEEK_SET); 
		blob_pos=*iter_start; 
	}
        //   push new region on heap
	if ((*iter_end - *iter_start) / 4096 > 0) {
            GDKerror("BLOB: Cannot handle regions larger than 4096 bytes\n");
            return(GDK_FAIL);
        }
        heap[heap_size].start=*iter_start;
        heap[heap_size].end=*iter_end;
	heap_size++;
        
        // also allocate the memory for the string. 
        if (heap_size == 1023) {
            GDKerror("fetch_standoff_data: too many (>= 1024) overlapping intervals for standoff steps to work well.\n");
            fclose(blob);
            return(GDK_FAIL);
        }

        //   start fetching till either: end of region or start of new region (whichever comes first)
        min_end = MAX_@1; 
        for (i=0;i<heap_size;i++)  
            if (heap[i].end < min_end) 
               min_end=heap[i].end; 
        if (start_next == last_iter_start || *start_next > min_end) 
		next_stop = min_end; 
	else 
		next_stop = *start_next;
        
        while (blob_pos < next_stop) {
            c = fgetc(blob);
            if (c == EOF) break;
            // if (c <= 9) c = ' '; // get rid of system-chars
            buf[blob_pos % 4096] = (char) c;
            blob_pos++;
        }
	
        // remove all heap-items with end == blob_pos (or if EndOfFile, end all items on heap)
        // there could have been an item ending, otherwise a new one 
        // will start
        if ((blob_pos == min_end) || (c == EOF)) 
            for (i=0;i<heap_size;i++) 
                if ((heap[i].end == min_end) || (c == EOF)) { 
                    if ((heap[i].start % 4096) < (blob_pos % 4096)) {
                      // we have to return (start..end)
                      buf[blob_pos % 4096] = '\0'; // zero-terminate string
                      BUNappend(*result, (ptr)(buf + (heap[i].start % 4096)), FALSE);
                    } else {
                      // we have to concatenate the two parts (start..4095) + (0...end)
                      for (j=0; j < blob_pos - heap[i].start; j++) 
                        temp[j] = buf[(heap[i].start + j) % 4096];
                      temp[j]='\0'; // zero-terminate string
                      BUNappend(*result, (ptr)temp, FALSE);
                    }
                    heap_size--; // pop from heap
                    heap[i].start = heap[heap_size].start; 
                    heap[i].end = heap[heap_size].end; 
                }
        // move to next item
        iter_start+=start_inc; iter_end+=end_inc; start_next+=start_inc; count++;
    }
    // return result
    fclose(blob);
    return(GDK_SUCCEED);
}
@

@= standoff_step
PROC @1(BAT[oid,oid] iter, BAT[oid,oid] ctx, oid cont, BAT[oid,bat] ws, int order, bat[void,oid] cands) : BAT[oid,oid]
{
    # TODO: "order" is not (yet?) used, here.

    # Wouter: here we need to figure out whether our index is still up-to-date    
    # regarding the possible updates that have taken place
    # for now, lets just try to extract them...
    ws := region_extract(ws,cont,"lng");

    # Wouter: new in 0.12: there can be multiple documents in a document-container
    # so we need the PRE_SIZE-bat to determine the document-boundaries
    
    var pre_size := ws.fetch(PRE_SIZE).find(cont);
    var pre_level := ws.fetch(PRE_LEVEL).find(cont);

    # FIXME: the select-operation can be done more efficiently using the PRE_SIZE-bat
    var void_DOCnodes := pre_level.ord_uselect(chr(-1)).hmark(nil);

    var region_pre := ws.fetch(REGION_PRE).find(cont);
    var region_start := ws.fetch(REGION_START).find(cont);
    var region_end := ws.fetch(REGION_END).find(cont);
    
    var heights := ws.fetch(HEIGHT).fetch(cont);

    var unq := {count}(iter.reverse(), iter.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

   # instead of the unq@batloop, we could do loop-lifting instead...
   # use: ll_select_narrow_join_sort(...) (in sjoin.mx)
   # we do need to prepare the regions and the iters... (should not be a problem...)
    var loop_lifted := @4;
    if (loop_lifted) 
    { 
      result := ll_@3(void_DOCnodes, region_pre, region_start, region_end, cands, iter, ctx); 
    } 
    if (not(loop_lifted)) 
    {  
      unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().project(nil);
	ctx_slice := ctx_slice.chk_order(); # have to check because step expects it sorted
        result.insert(@3
                              (pre_size, region_pre, region_start, region_end,
                               cands,
                               ctx_slice)
	              .project($h).reverse());
        offset := offset + $t;
      }
    }
  return result.access(BAT_READ);
}
ADDHELP("@1", "wouter", "Oct 2005",
"PARAMETERS:\n\
BAT[oid,any] iter (grouping relation)\n\
BAT[oid,any] ctx (context set)\n\
oid cont (the current container of the ws)\n\
BAT[oid,bat] ws (working set)\n\
BAT[void,oid] cands (candidate set)\n\
DESCRIPTION:\n\
returns all nodes on the @2 axis of the ctx-nodes duplicate free for each group.",
"pf_standoff");
@

@= ll_standoff_mil
################################################
# Loop Lifted version of the @1-@2 StandOff Step 
# invoked by standoff_step (returns PRE's)
PROC ll_standoff_@1_@2(BAT[void,oid] void_DOCnodes,
                             BAT[oid,oid] region_pre, 
                             BAT[oid,any] region_start,
                             BAT[oid,any] region_end,
                             BAT[void,oid] cands,
                             BAT[oid,oid] iter,
                             BAT[oid,oid] ctx) : BAT[oid,oid]
{
  # prepare all the regions
  var max_iter := iter.max();
  var source_region := ctx.join(region_pre.reverse()).reverse();
  var region_iter := source_region.leftjoin(iter); 
  source_region := source_region.mirror().leftjoin(region_start).sort().project(nil).reverse();
  var source_iter := source_region.leftjoin(region_iter).tmark(0@0);
  
  #  try to get a iter_start...
  var source_start := source_region.leftjoin(region_start).tmark(0@0); 
  var iter_start := source_iter.[oid]().reverse().leftjoin(source_start).reverse().[oid]().reverse();
  var source_end := source_region.leftjoin(region_end).tmark(0@0);     

  var sel_region := cands.reverse().mirror().leftjoin(region_pre.reverse()).reverse().mirror();
  var sel_region2 := sel_region.leftjoin(region_start).sort().hmark(0@0);
  var sel_start := sel_region2.leftjoin(region_start); 
  var sel_end := sel_region2.leftjoin(region_end);     

  # do the join
  # FIXME: Wouter: as of version 0.12 document-containers can hold multiple documents
  # we actually should do a batloop here (iterate over all documents in a document-container)
  # and per-document we should find the proper context-nodes and candidates

  # another option would be to modify the ll_@1_@2_join_sort
  var result := ll_@1_@2_join_sort(iter_start, source_end, 
                                   sel_start, sel_end);
  
  # and convert the regions back to PRE's
  result := result.leftjoin(sel_region2);
  result := result.leftjoin(region_pre);

  # must have [iter,pre] order. First sort on iter (in-place, with order()).
  result.chk_order().access(BAT_WRITE).order().access(BAT_READ);

  # get positions in [iter,pre] order with CTrefine, and fetch positionally
  return result.fetch(CTrefine(result.hmark(0@0), result.tmark(0@0)));
}
@
@= standoff_mil
# actual step (non-loop-lifted)
PROC standoff_@1_@2(BAT[void,oid] void_DOCnodes,
                             BAT[oid,oid] region_pre, 
                             BAT[oid,any] region_start,
                             BAT[oid,any] region_end,
                             BAT[void,oid] cands,
                             BAT[oid,void] ctx) : BAT[void,oid]
{
  # prepare all the regions
  var source_region := ctx.reverse().join(region_pre.reverse()).reverse().mirror();
  source_region := source_region.leftjoin(region_start).sort().reverse();
  var source_start := source_region.leftjoin(region_start).tmark(0@0); 
  var source_end := source_region.leftjoin(region_end).tmark(0@0);     

  # sel_region = region_region?
  var sel_region := cands.reverse().mirror().leftjoin(region_pre.reverse()).reverse().mirror();
  # sel_region2 is translation-table sel-region
  var sel_region2 := sel_region.leftjoin(region_start).sort().hmark(0@0);
  var sel_start := sel_region2.leftjoin(region_start); 
  var sel_end := sel_region2.leftjoin(region_end);     

  # do the join
  # FIXME: Wouter: as of version 0.12 document-containers can hold multiple documents
  # we actually should do a batloop here (iterate over all documents in a document-container)
  var result := @1_@2_join_sort(source_start, source_end, 
                                sel_start, sel_end);
  
  # and convert the regions back to PRE's
  result := result.leftjoin(sel_region2);
  result := result.leftjoin(region_pre).reverse().mark(0@0).sort();
  return result;
}
@
@= no_pre
	cands := ws.fetch(PRE_SIZE).fetch(theFrag).project().reverse();
	cands := cands.chk_order();
@
@= kind_pre
	cands := ws.fetch(KIND_PRE + int(@1)).fetch(theFrag);
	cands := cands.chk_order();
@
@= ns_pre
	@:ns_loc_pre(qn,ns,QN,URI,ELEMENT)@
@
@= loc_pre
	@:ns_loc_pre(qn,loc,QN,LOC,ELEMENT)@
@
@= target_pre
	@:ns_loc_pre(prop,tgt,PROP,TGT,1)@ 
@( FIXME: '1' is used instead of PI because we skip the other kinds @)
@
@= nsloc_pre
 {
	var pre_cont := ws.fetch(PRE_CONT).fetch(theFrag);
	if (is_constant(pre_cont)) {
		var cont := pre_cont.fetch(0);
		pre_cont := nil;
		var qn_nsloc := ws.fetch(QN_LOC_URI).fetch(cont);
		    qn_nsloc := qn_nsloc.ord_uselect(loc+str('\1')+ns);
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		if (count(qn_nsloc) = 1) {
			cands := pre_prop.ord_uselect(qn_nsloc.reverse().fetch(0)).reverse();
                        if ( not(ordered(reverse(cands))) ) {
                                printf("= nsloc_pre(1): cands not ordered on tail.\n");
                        }
		} else {
			cands := pre_prop.leftjoin(qn_nsloc).sort().reverse();
		}
		pre_prop := nil;
		qn_nsloc := nil;
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		    pre_cont := pre_prop.mirror().leftfetchjoin(pre_cont);
		var X_pre    := pre_prop.hmark(0@0);
		var X_prop   := pre_prop.tmark(0@0);
		    pre_prop := nil;
		var X_cont   := pre_cont.tmark(0@0);
		    pre_cont := nil;
		var X_nsloc  := mposjoin(X_prop, X_cont, ws.fetch(QN_LOC_URI));
		    X_prop   := nil;
		    X_cont   := nil;
		var _X       := X_nsloc.ord_uselect(loc+str('\1')+ns).reverse();
		    X_nsloc  := nil;
		cands := _X.leftfetchjoin(X_pre); #.reverse().sort().reverse()
                if ( not(ordered(reverse(cands))) ) {
                        printf("= nsloc_pre(3): cands not ordered on tail.\n");
                }
	}
	cands := cands.chk_order();
        if ( not(ordered(reverse(cands))) ) {
                printf("= nsloc_pre(4): cands not ordered on tail.\n");
        }
 }
@
# expansions of the loop lifted scj
# kind argument
@= kind_args
, chr kind
@
@= kind_params
, kind
@
# tagname argument
@= ns_args
, str ns
@
@= ns_params
, ns
@
@= loc_args
, str loc
@
@= loc_params
, loc
@
@= tgt_args
, str tgt
@
@= tgt_params
, tgt
@
@= nsloc_args
, str ns, str loc
@
@= nsloc_params
, ns, loc
@
@= ns_loc_pre
 {
	var pre_cont := ws.fetch(PRE_CONT).fetch(theFrag);
	if (is_constant(pre_cont)) {
		var cont := pre_cont.fetch(0);
		pre_cont := nil;
		var @1_@2 := ws.fetch(@3_@4).fetch(cont);
		    @1_@2 := @1_@2.ord_uselect(@2);
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		if (count(@1_@2) = 1) {
			cands := pre_prop.ord_uselect(@1_@2.reverse().fetch(0)).reverse();
                        if ( not(ordered(reverse(cands))) ) {
                                printf("= ns_loc_pre(1): cands not ordered on tail.\n");
                        }
		} else {
			cands := pre_prop.leftjoin(@1_@2).sort().reverse();
		}
		pre_prop := nil;
		@1_@2 := nil;
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		    pre_cont := pre_prop.mirror().leftfetchjoin(pre_cont);
		var X_pre    := pre_prop.hmark(0@0);
		var X_prop   := pre_prop.tmark(0@0);
		    pre_prop := nil;
		var X_cont   := pre_cont.tmark(0@0);
		    pre_cont := nil;
		var X_@2     := mposjoin(X_prop, X_cont, ws.fetch(@3_@4));
		    X_prop   := nil;
		    X_cont   := nil;
		var _X       := X_@2.ord_uselect(@2).reverse();
		    X_@2     := nil;
		cands := _X.leftfetchjoin(X_pre); #.reverse().sort().reverse()
                if ( not(ordered(reverse(cands))) ) {
                        printf("= ns_loc_pre(3): cands not ordered on tail.\n");
                }
	}
	cands := cands.chk_order();
        if ( not(ordered(reverse(cands))) ) {
                printf("= ns_loc_pre(4): cands not ordered on tail.\n");
        }

 }
@

@= loop_lifted_scj_step_standoff2
proc loop_lifted_@1_step@2 (bat[oid, oid] iter, bat[oid, oid] item, bat[void, oid] cont, bat[oid, bat] ws @3 ) : bat[oid,bat]
{
    var result := loop_lifted_@1_step@2 (iter, item, cont, ws, 0 @4);
    return result;
}
proc loop_lifted_@1_step@2 (bat[oid, oid] iter, bat[oid, oid] item, bat[void, oid] cont, bat[oid, bat] ws, int order @3 ) : bat[oid,bat]
{
    # handle empty results correctly
    if (iter.count() = 0) {
	var empty := bat(void,oid,0).seqbase(0@0).access(BAT_READ);
	return bat(void,bat,3).seqbase(0@0)
			    .append(empty)
			    .append(empty)
			    .append(empty)
			    .access(BAT_READ);
    }
    var result;
    var result_iter;
    var result_item;
    var result_cont;
    var tmp_res;
    var cands;

    var uniqueFrag := cont.tunique().sort();
    var theFrag := uniqueFrag.reverse().fetch(0);
    if (uniqueFrag.count() = 1) {
        var result_part_cont := nil;
        var result_part_iter := iter;
        var result_part_item := item;

        @:loop_lifted_scj_per_cont(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_cont := result_part_cont;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_cont := nil;
    } else {
        var result_part_cont := cont.ord_uselect(theFrag).hmark(0@0);
        var result_part_iter := result_part_cont.leftfetchjoin(iter);
        var result_part_item := result_part_cont.leftfetchjoin(item);

        @:loop_lifted_scj_per_cont(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_cont := result_part_cont;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_cont := nil;

        var res_mu;
	uniqueFrag.slice(1,uniqueFrag.count() - 1)@batloop () {
	    theFrag := $h;
            result_part_cont := cont.ord_uselect(theFrag).hmark(0@0);
            result_part_iter := result_part_cont.leftfetchjoin(iter);
            result_part_item := result_part_cont.leftfetchjoin(item);

            @:loop_lifted_scj_per_cont(@1,@5,@6,@7)@

            res_mu := merged_union(result_iter, result_part_iter,
				   result_item, result_part_item,
				   result_cont, result_part_cont);
            result_part_iter := nil;
            result_part_item := nil;
            result_part_cont := nil;
            result_iter := res_mu.fetch(0);
            result_item := res_mu.fetch(1);
            result_cont := res_mu.fetch(2);
            res_mu := nil;
        }
    }
    
    result_iter.access(BAT_READ);
    result_item.access(BAT_READ);
    result_cont.access(BAT_READ);
    var result_scj := bat(void,bat,3).seqbase(0@0);
    result_scj.append(result_iter);
    result_scj.append(result_item);
    result_scj.append(result_cont);

    return result_scj.access(BAT_READ);
}
@
@= loop_lifted_scj_per_cont
	result_part_iter := result_part_iter.chk_order();
	result_part_item := result_part_item.chk_order();
        result_part_cont := nil;

	# pre-test
	@4
        var result := @1 (result_part_iter, result_part_item, theFrag, ws, order, cands);

	result_part_iter := result.hmark(0@0);
	result_part_item := result.tmark(0@0);
        result_part_cont := constant2bat(theFrag);
	cands := nil;

	# post-test
        # wouter: there is no post-test for any standoff step, but lets leave this 
        # for compatibility with the regular steps
	@2
@

@= loop_lifted_scj_step_standoff1
@:loop_lifted_scj_step_standoff2(@1,,,,,                                             cands,@:no_pre@)@
@:loop_lifted_scj_step_standoff2(@1,_with_kind_test,@:kind_args@, @:kind_params@, ,cands,@:kind_pre(kind)@)@
@:loop_lifted_scj_step_standoff2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   ,cands,@:ns_pre@)@
@:loop_lifted_scj_step_standoff2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  ,cands,@:loc_pre@)@
@:loop_lifted_scj_step_standoff2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  ,cands,@:target_pre@)@
@:loop_lifted_scj_step_standoff2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,,cands,@:nsloc_pre@)@
@

@mil
#############################################
# MIL WRAPPER for AXIS STEPS 
#
# In order to simplify the invocation of the axis steps functions, this
# interface provides...
# 

# Wouter: added standoff
#one of the ?_pre steps probably does some filtering (all nodes before the #1 node in source are removed from cands)
# this should not be done in case of StandOff (bug is illustrated in Video-example)
# i assume it is the :shrink_code!!
@:loop_lifted_scj_step_standoff1(select_narrow)@
@:loop_lifted_scj_step_standoff1(select_wide)@
@:loop_lifted_scj_step_standoff1(reject_narrow)@
@:loop_lifted_scj_step_standoff1(reject_wide)@

# Wouter: added standoff steps 
# last argument tells whether to use the loop-lifted version
@:standoff_step(select_narrow,select-narrow,standoff_select_narrow, true)@
@:standoff_step(select_wide,select-wide,standoff_select_wide,       true)@
@:standoff_step(reject_narrow,reject-narrow,standoff_reject_narrow, true)@
@:standoff_step(reject_wide,reject-wide,standoff_reject_wide,       true)@


PROC region_extract(BAT[oid, BAT] my_ws, oid i, str tpe) : bat[oid,BAT] {
  # how-to: this region extract is used for the StandOff steps
  # if your regions are stored in different attributes than "start" and "end",
  # than modify the variables below

  # my_ws.access(BAT_WRITE);
  var XIRAF_nodes := my_ws.fetch(QN_LOC).fetch(i).reverse().leftjoin(
                        my_ws.fetch(QN_PREFIX).fetch(i).ord_uselect(region_namespace).mirror());

  var region_pre, region_start, region_end;
  var start_qn := nil, end_qn := nil;
  if (isnil(CATCH({ start_qn := XIRAF_nodes.find(region_start_attr_tag);
                    end_qn := XIRAF_nodes.find(region_end_attr_tag); }))) {
      # get all start attributes, then their numerical value, sort it, and then get the PRE's
      var attr_attr := my_ws.fetch(ATTR_QN).find(i).ord_uselect(start_qn).mirror();
      var attr_prop := attr_attr.leftjoin(my_ws.fetch(ATTR_PROP).find(i));
      var val_start := [*tpe](attr_prop.leftjoin(my_ws.fetch(PROP_VAL).find(i))).reverse().sort();
      # Wouter?: ATTR_OWN now points to PREs? (i.o. PRE?s)
      var start_pre := val_start.leftjoin(my_ws.fetch(ATTR_OWN).find(i));

      # now we have a table with a PRE column and a start (numerical) column in the right order
      var left_pre := start_pre.tmark(0@0);
      var left_start := start_pre.hmark(0@0);

      # go get the PRE numbers that have an end attribute
      var right_attr := my_ws.fetch(ATTR_QN).find(i).ord_uselect(end_qn).hmark(0@0);
      var right_pre := right_attr.leftjoin(my_ws.fetch(ATTR_OWN).find(i));
      var right_end := [*tpe](right_attr.leftjoin(my_ws.fetch(ATTR_PROP).find(i)).leftjoin(my_ws.fetch(PROP_VAL).find(i)));

      # the region table is the intersection between start and end
      var left_right := left_pre.leftjoin(right_pre.reverse());
      var region_left := left_right.hmark(0@0);
      var region_right := left_right.tmark(0@0);

## TODO: FIXME : the following code does not work, but should assign
##               the largest possible region to the document-node
#      if (=(tpe,"lng")) {
#        region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                   .insert(region_left.leftjoin(left_pre));
#        region_start := bat(void,lng).seqbase(0@0).append(getLNG_MIN())
#                                     .insert(region_left.leftjoin(left_start));
#        region_end := bat(void,lng).seqbase(0@0).append(getLNG_MAX())
#                                   .insert(region_right.leftjoin(right_end));
#     } else {
#       region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                  .insert(region_left.leftjoin(left_pre));
#       region_start := bat(void,INT).seqbase(0@0).append(getINT_MIN())
#                                    .insert(region_left.leftjoin(left_start));
#       region_end := bat(void,INT).seqbase(0@0).append(getINT_MAX())
#                                  .insert(region_right.leftjoin(right_end));
#     }
      region_pre := region_left.leftjoin(left_pre);
      region_start := region_left.leftjoin(left_start);
      region_end := region_right.leftjoin(right_end);
  } else {
      # if there are either no start or end nodes, the result is empty
      region_pre := bat(void,oid);
      region_start := bat(void,monet_atomtbl.find(tpe));
      region_end := bat(void,monet_atomtbl.find(tpe));
  }
  if (not(exist(my_ws.fetch(REGION_PRE), i))) {
    my_ws.fetch(REGION_PRE).access(BAT_WRITE).insert(i,region_pre);
    my_ws.fetch(REGION_START).access(BAT_WRITE).insert(i,region_start);
    my_ws.fetch(REGION_END).access(BAT_WRITE).insert(i,region_end);
  }
  return my_ws;
}
ADDHELP("region_extract", "wouter", "Oct 2005",
"PARAMETERS:\n\
BAT[str,BAT] an active ws (Working Set)\n\
oid i (index in the active working set)\n\
str tpe (type of region-values (int or lng))\n\
DESCRIPTION:\n\
adds three BATs to the working set REGION_PRE, REGION_START, and REGION_END and fills them.",
"pf_standoff");


# Wouter: the PROC below is obsolete, region extraction is now done at query-time, and
# not at shredding-time 
PROC region_extract(BAT[str, BAT] my_ws, str tpe) : bat[str,BAT] {
    # how-to: this region extract is used for the StandOff steps
    # if your regions are stored in different attributes than "start" and "end",
    # than modify the variables below
    #printf("extracting regions from %s:%s and %s:%s\n", 
    #       region_namespace,region_start_attr_tag,
    #       region_namespace,region_end_attr_tag);

    my_ws.access(BAT_WRITE);
    var XIRAF_nodes := my_ws.find("qn_loc").reverse().leftjoin(
                          my_ws.find("qn_prefix").ord_uselect(region_namespace).mirror());

    var region_pre, region_start, region_end;
    var start_qn := nil, end_qn := nil;
    if (isnil(CATCH({ start_qn := XIRAF_nodes.find(region_start_attr_tag);
                      end_qn := XIRAF_nodes.find(region_end_attr_tag); }))) {
        # get all start attributes, then their numerical value, sort it, and then get the pre's
        var attr_attr := my_ws.find("attr_qn").ord_uselect(start_qn).mirror();
        var attr_prop := attr_attr.leftjoin(my_ws.find("attr_prop"));
        var val_start := [*tpe](attr_prop.leftjoin(my_ws.find("prop_val"))).reverse().sort();
        var start_pre := val_start.leftjoin(my_ws.find("attr_own"));

        # now we have a table with a pre column and a start (numerical) column in the right order
        var left_pre := start_pre.tmark(0@0);
        var left_start := start_pre.hmark(0@0);

        # go get the pre numbers that have an end attribute
        var right_attr := my_ws.find("attr_qn").ord_uselect(end_qn).hmark(0@0);
        var right_pre := right_attr.leftjoin(my_ws.find("attr_own"));
        var right_end := [*tpe](right_attr.leftjoin(my_ws.find("attr_prop")).leftjoin(my_ws.find("prop_val")));

        # the region table is the intersection between start and end
        var left_right := left_pre.leftjoin(right_pre.reverse());
        var region_left := left_right.hmark(0@0);
        var region_right := left_right.tmark(0@0);

## TODO: FIXME : the following code does not work, but should assign
##               the largest possible region to the document-node
#       if (=(tpe,"lng")) {
#        region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                   .insert(region_left.leftjoin(left_pre));
#        region_start := bat(void,lng).seqbase(0@0).append(getLNG_MIN())
#                                     .insert(region_left.leftjoin(left_start));
#        region_end := bat(void,lng).seqbase(0@0).append(getLNG_MAX())
#                                   .insert(region_right.leftjoin(right_end));
#       } else {
#        region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                  .insert(region_left.leftjoin(left_pre));
#        region_start := bat(void,INT).seqbase(0@0).append(getINT_MIN())
#                                    .insert(region_left.leftjoin(left_start));
#        region_end := bat(void,INT).seqbase(0@0).append(getINT_MAX())
#                                  .insert(region_right.leftjoin(right_end));
#       }
        region_pre := region_left.leftjoin(left_pre);
        region_start := region_left.leftjoin(left_start);
        region_end := region_right.leftjoin(right_end);
    } else {
        # if there are either no start or end nodes, the result is empty
        region_pre := bat(void,oid);
        region_start := bat(void,monet_atomtbl.find(tpe));
        region_end := bat(void,monet_atomtbl.find(tpe));
    }
    printf("# extracted %d regions\n",region_pre.count());
    my_ws.insert("_region_pre",region_pre);
    my_ws.insert("_region_start",region_start);
    my_ws.insert("_region_end",region_end);
    return my_ws;
}
ADDHELP("region_extract", "wouter", "Oct 2005",
"PARAMETERS:\n\
BAT[str,BAT] ws (Working Set)\n\
str tpe (type of region-values (int or lng))\n\
DESCRIPTION:\n\
adds three BATs to the working set REGION_PRE, REGION_START, and REGION_END and fills them.",
"pf_standoff");
@

@c
#include "pf_standoff.h"

/* simple heap operations for the loop-lifted StandOff join */
@:heap_procs(int,int)@
@:heap_procs(lng,long long)@

/* StandOff joins */
@:standoff(lng,long long)@
@:standoff(int,int)@

@:ll_standoff(lng,long long)@
@:ll_standoff(int,int)@

@- not implemented yet
@c
@:ffb(int, int)@
@:ffb(lng, long long)@

/* vim:set shiftwidth=4 expandtab: */
