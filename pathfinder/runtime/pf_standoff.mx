@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2006 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.

@f pf_standoff
@a Wouter Alink
@a Peter Boncz
@v 0.1
@t MIL primitives to support the StandOff Axis Steps in XQuery

@* Introduction
@T
This module provides MIL primitives to support the StandOff
Axis Steps on top of MonetDB within the "Pathfinder" project.
This module is loaded when standoff-axis steps are enabled on
the server-side or when 'pf' is provided the option '-b' or the
equivalent long option '--enable-standoff'. In order to enable
the StandOff Axis steps on the server side you need to add
\texttt{standoff=enabled} to the \texttt{--set} option list.
The default is \texttt{standoff=disabled}.

note: runtime support for the StandOff axis steps was added in the
0.12 release.

@- Select Narrow / Select Wide / Reject Narrow / Reject Wide
@T
The SN, SW, RN, RW joins are region joins based on the work by Forbes J.
Burkowski (1992) ``Retrieval Activities in a Database Consisting of
Heterogeneous Collections of Structured Text''

There are two major changes to Burkowski's original ideas: (1.) this
implementation turns around the arguments, and (2.) it handles (partly)
overlapping regions by including them in the SW (the results of SW and SN do
not have to be disjunct) and the result of SN is a subset of SW.

When Burkowski defines \texttt{<chapter> SW \{"Feynman","virtual particle"\}}, this could
be queried as:
\begin{verbatim}
  select_wide_join({"Feynman","virtual particle"},<chapter>)
\end{verbatim}
which will return all the chapter which contain either "Feynman" or "virtual
particle". The AND-expression, as in: \texttt{<chapter> SW \{"Feynman"\} SW
\{"virtual particle"\} }
could be written as:
\begin{verbatim}
 select_wide_join({"Feynman"},
        select_wide_join({"virtual particle"}, <chapter>))
\end{verbatim}

The reason for the swap in parameters is that the selection mechanisms are
going to be used as "steps" in XPath, which are not "selection" but
"navigation" operations.

Some more examples: the \texttt{reject\_wide\_join(\{"Feynman","virtual
particle"\}, <chapter>) } would return all the chapters which do not
contain (nor partly contain) either "Feynman" or "virtual particle"
and the \texttt{ reject\_narrow\_join(<chapter>,\{"Feynman","virtual
particle"\}) } would return all the instances of "Feynman" and "virtual
particle" which are not inside a chapter-region.

@
@* Module Definition
@m
.MODULE pf_standoff;

@+ StandOff Joins
@T
The input for the joins are the current context:
\begin{verbatim}
 BAT(<void>, <int>region start), BAT(<void>, <int>region end)
\end{verbatim}
and the destination context, which have to be indicated by:
\begin{verbatim}
 BAT(<void>, <int>region start), BAT(<void>, <int>region end)
\end{verbatim}
The result is a list to the items in the destination context that match:
 (<void>, <oid>)

\emph{NOTE}: currently only 'int'- and 'lng'-type regions are implemented, but
these joins could as well be implemented on floats, dates, and other data-types
without much effort.

@- non loop-lifted StandOff joins
@= standoff_join_sigs
   .COMMAND @1_@2_join_sort(BAT[oid, @3], BAT[oid,@3], BAT[oid,@3], BAT[oid,@3]) :
	BAT[void,oid] = CMD@1_@2_join_sort_@3; "@1 @2 join (on @3s), using inputs sorted on start"
@
@m
# declaration StandOff joins (int)
@:standoff_join_sigs(select,narrow,int)@
@:standoff_join_sigs(select,wide,int)@
@:standoff_join_sigs(reject,narrow,int)@
@:standoff_join_sigs(reject,wide,int)@

# declaration StandOff joins (lng)
@:standoff_join_sigs(select,narrow,lng)@
@:standoff_join_sigs(select,wide,lng)@
@:standoff_join_sigs(reject,narrow,lng)@
@:standoff_join_sigs(reject,wide,lng)@

# interaction with the underlying data
.COMMAND blob(BAT[void,lng], BAT[void,lng], str) :
	BAT[void,str] = CMDfetch_standoff_data_lng; "fetch data from region (start,end) blob (file)"
.COMMAND blob(BAT[void,int], BAT[void,int], str) :
	BAT[void,str] = CMDfetch_standoff_data_int; "fetch data from region (start,end) blob (file)"
@

@- Loop-Lifted StandOff joins
@T
This variant of the StandOff joins uses loop-lifting to do the join for
multiple inputs in a single pass. The input are the input regions (with there
iteration value, sorted on "start"):
\begin{verbatim}
  BAT(<oid>iter,<int>start)
  BAT(<oid>iter,<int>end)
\end{verbatim}
and the destination regions:
\begin{verbatim}
  BAT(<void>id, <int>start)
  BAT(<void>id, <int>end)
\end{verbatim}
The result will be a bat ([oid]iter,[oid]id), where 'iter' is the
corresponding bucket and 'id' the region-id of the destination regions.

\emph{NOTE}: only the iter in the input bat (<oid>iter,<int>start) is checked. the 'iter'-column in
the bat (iter,end) is optional (can be void as well) as it is not used.

\emph{NOTE}: the seqbase of the id-columns is currently supposed to be 0@0.

\emph{NOTE}: the loop-lifted standoff joins (SN, SW, RN, RW) have not been tested
thoroughly. The result is ordered on tail (the region identifier) and NOT on
head (iter). (any additional testcases are welcome)

@-TODO:
@T
\emph{KNOWN ISSUE}: currently the iter needs to be of type OID (and may NOT be VOID)

\emph{KNOWN ISSUE}: the loop-lifted REJECT standoff joins do NOT work
workaround: use the non-loop-lifted StandOff join or take the
loop-lifted-"select"-join and calculate per iter the inverse of the result.

@m
# declaration StandOff joins (loop lifted, int)
@:ll_standoff_join_sigs(select,narrow,int)@
@:ll_standoff_join_sigs(select,wide,int)@
@:ll_standoff_join_sigs(reject,narrow,int)@
@:ll_standoff_join_sigs(reject,wide,int)@

# declaration StandOff joins (loop lifted, lng)
@:ll_standoff_join_sigs(select,narrow,lng)@
@:ll_standoff_join_sigs(select,wide,lng)@
@:ll_standoff_join_sigs(reject,narrow,lng)@
@:ll_standoff_join_sigs(reject,wide,lng)@

@= ll_standoff_join_sigs
   .COMMAND ll_@1_@2_join_sort(BAT[oid, @3], BAT[oid,@3], BAT[oid,@3], BAT[oid,@3]) :
        BAT[oid,oid] = CMDll_@1_@2_join_sort_@3; "loop lifted @1 @2 join (on @3s), using inputs sorted on start"
@

@- StandOff Axis Steps

@mil
module(alarm);
module(aggrX3);
module(malalgebra);
module(mmath);
module(xtables);


# FIXME/TODO: the attribute-names should be set by a 'declare option' statement inside
# an XQuery expression
var region_namespace := "";
var region_start_attr_tag := "start";
var region_end_attr_tag := "end";

# Wouter:
@:ll_standoff_mil(select,narrow)@
@:ll_standoff_mil(select,wide)@
## the loop-lifted reject steps don't work, and probably never will...
#:ll_standoff_mil(reject,narrow)##
#:ll_standoff_mil(reject,wide)##
@:standoff_mil(select,narrow)@
@:standoff_mil(select,wide)@
@:standoff_mil(reject,narrow)@
@:standoff_mil(reject,wide)@
@

@m
.END pf_standoff;
@

@h
#ifndef __PF_STANDOFF_H__
#define __PF_STANDOFF_H__

#include "pf_standoff.proto.h"
#include <monet.h>
#include <monet_interpreter.h>
#include <monettime.h>
#include <lock.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <gdk.h>
#include <limits.h>

#define MAX_int INT_MAX
#define MAX_lng LLONG_MAX
#define MIN_int INT_MIN
#define MIN_lng LLONG_MIN

#endif
@

@= select_outside
            /* skip nodes which are not contained */
@
@= reject_outside
            /* insert nodes which are not contained */
            index = BUNindex(region_start,iter_start);
            BUNappend(bn, (ptr)(&index), FALSE);
@
@= select_inside
            /* insert nodes which are contained */
            index = BUNindex(region_start,iter_start);
            BUNappend(bn, (ptr)(&index), FALSE);
@
@= reject_inside
            /* skip nodes which are contained */
@
@= narrow
        if (outer_iter_start_next < outer_last_start)
          outer_start_next = *(outer_iter_start_next);
        else
          outer_start_next = MAX_@2;

        /* loop through the not strictly contained region */
        while(iter_start < last_start && *iter_start < *outer_iter_start) {
            @:@1_outside@
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the strictly contained regions */
        while(iter_start < last_start && *iter_start < outer_start_next) {
            if (*iter_end <= *outer_iter_end) {
              @:@1_inside@
            } else {
              @:@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre;
        }
@
@= wide
        /* loop through the not even contained regions */
        while(iter_start < last_start && *iter_end < *outer_iter_start) {
            @:@1_outside@
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the partly contained regions */
        while(iter_start < last_start && *iter_start <= *outer_iter_end) {
            if (*iter_end >= *outer_iter_start) {
              @:@1_inside@
            } else {
              @:@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre;
        }
@

@= region_jump_decl_narrow
    @1 outer_start_next;
@
@= region_jump_decl_wide
@

@= standoff_join_impl
int
CMD@1_@2_join_sort_@3(BAT **result, BAT *source_start, BAT *source_end, BAT *region_start, BAT *region_end) {

    @4 *iter_start, *iter_end, *last_start,
        *outer_iter_start, *outer_iter_end, *outer_last_start,
        *outer_iter_start_next, *outer_iter_end_next;

    @:region_jump_decl_@2(@4)@
        oid index;
    int Sss,Sse,Srs,Sre;
    BAT * bn = NULL;

    *result=NULL;

    if (!(ALIGNrelated(source_start,source_end)&1)) {
        GDKerror("@1_@2_join_sort_@3: source BATs not related.\n");
        return(GDK_FAIL);
    }
    if (!(BATtordered(source_start)&1)) {
        GDKerror("@1_@2_join_sort_@3: source BAT not sorted (on start).\n");
        return(GDK_FAIL);
    }
    if (!(ALIGNrelated(region_start,region_end)&1)) {
        GDKerror("@1_@2_join_sort_@3: region BATs not related.\n");
        return(GDK_FAIL);
    }
    if (!(BATtordered(region_start)&1)) {
        GDKerror("@1_@2_join_sort_@3: region BAT not sorted (on start).\n");
        return(GDK_FAIL);
    }

    if ((bn = BATnew(TYPE_void, TYPE_oid, BATcount(region_start))) == NULL) {
        GDKerror("@1_@2_join_sort_@3: could not allocate memory for result BAT.\n");
        return(GDK_FAIL);
    }

    iter_start = (@4 *) BUNtail(region_start, BUNfirst(region_start));
    iter_end = (@4 *) BUNtail(region_end, BUNfirst(region_end));
    last_start = (@4 *) BUNtail(region_start, BUNlast(region_start));
    outer_iter_start = (@4 *) BUNtail(source_start, BUNfirst(source_start));
    outer_iter_end = (@4 *) BUNtail(source_end, BUNfirst(source_end));
    outer_last_start = (@4 *) BUNtail(source_start, BUNlast(source_start));

    /* todo: what if size is not a multiple of sizeof(@4)  (BUNsize(...) % sizeof(@4) != 0) */
    Srs = BUNsize(region_start) / sizeof(@4);
    Sre = BUNsize(region_end) / sizeof(@4);
    Sss = BUNsize(source_start) / sizeof(@4);
    Sse = BUNsize(source_end) / sizeof(@4);

    while (outer_iter_start < outer_last_start) {
        outer_iter_start_next = outer_iter_start+Sss; outer_iter_end_next = outer_iter_end+Sse;

        /* skip overlapping region in the source  */
        while(outer_iter_start_next < outer_last_start
                && *(outer_iter_end_next) <= *(outer_iter_end)) {
            outer_iter_start_next+=Sss; outer_iter_end_next+=Sse;
        }

        @:@2(@1,@3)@

        outer_iter_start=outer_iter_start_next; outer_iter_end=outer_iter_end_next;
    }
    *result=bn;
    return(GDK_SUCCEED);
}
@
@= ll_select_outside
            /* skip nodes which are not contained */
@
@= ll_reject_outside
            /* insert nodes which are not contained */
            // FIXME: we need to include the iters not on the heap...
            index = BUNindex(region_start,iter_start) - BUNindex(region_start, BUNfirst(region_start));
            BUNins(bn, (ptr)(&(heap[i].iter)), (ptr)(&index), FALSE);
@
@= ll_select_inside
            /* insert nodes which are contained */
            index = BUNindex(region_start,iter_start) - BUNindex(region_start, BUNfirst(region_start));
            BUNins(bn, (ptr)(&(heap[i].iter)), (ptr)(&index), FALSE);
@
@= ll_reject_inside
            /* skip nodes which are contained */
@
@= ll_narrow
        /* loop through the not strictly contained region */
        /* nearest_start contains first upcoming starting point on heap
           heap contains a single element (or more if more regions start on
           same place) */
        while(@:more_target_regions@ && *iter_start < nearest_start) {
            for (i=0;i<heap_size;i++) {
              @:ll_@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the strictly contained regions */
        while(@:more_target_regions@ && *iter_start < nearest_next_start) {
            /* if there is a item that should be removed from the heap,
               we need to remove (it/them) */
            if (*iter_start > nearest_end) {
              nearest_end = MAX_@2;
              while ((heap_size > 0) && (heap[heap_size-1].end < *iter_start))
                  heap_size--;
              if (heap_size > 0)
                  nearest_end = heap[heap_size-1].end;
            }

            /* FIXME: we now know that the heap is sorted on END, so we can
               remove the if-statement here */
            for (i=0;i<heap_size;i++) {
              if (*iter_end <= heap[i].end) {
                @:ll_@1_inside@
              } else {
                @:ll_@1_outside@
              }
            }
            iter_start+=Srs; iter_end+=Sre;
        }
        /* by now, we should be ready to push a new item on the heap
           we processed as much as possible without this new item... */
@
@= ll_wide
        /* loop through the not even contained regions */
        /* nearest_start contains first upcoming starting point on heap
           heap should contain a single element (with outer_iter_start as nearest_start)
           if not, this step will automatically be skipped as iter_end will be more than
           nearest_start */
        while(@:more_target_regions@ && *iter_end < nearest_start) {
            for (i=0;i<heap_size;i++) {
              @:ll_@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the partly contained regions
           now there are some elements on the heap that want our attention */
        while(@:more_target_regions@ && *iter_end < nearest_next_start) {
            /* if we think there is at least one region that could be popped... */
            if (*iter_start > nearest_end ) {
              nearest_end = MAX_@2;
              while ((heap_size > 0) && (heap[heap_size-1].end < *iter_start))
                  heap_size--;
              if (heap_size > 0)
                  nearest_end = heap[heap_size-1].end;
            }
            for (i=0;i < heap_size;i++) {
              if (*iter_end >= heap[i].start) {
                @:ll_@1_inside@
              } else {
                @:ll_@1_outside@
              }
            }
            iter_start+=Srs; iter_end+=Sre;
        }
        /* by now, we should be ready to push a new item on the heap
           we processed as much as possible without this new item... */
@

@= more_target_regions
 (iter_start < last_start)
@

@= ll_standoff_join_impl
/* 4 aug 2005
   loop lifted standoff join implementation */
int
CMDll_@1_@2_join_sort_@3(BAT **result, BAT *source_start, BAT *source_end, BAT *region_start, BAT *region_end) {

    @4 *iter_start, *iter_end, *last_start,
        *outer_iter_start, *outer_iter_end, *outer_last_start,
        *outer_iter_start_next, *outer_iter_end_next,
        nearest_end = MIN_@3, nearest_next_start = MAX_@3, nearest_start = MAX_@3;

    heap_@3 *heap;
    int max_heap_size = 1024;
    int heap_size = 0, i;
    oid index;
    oid *outer_iter_iter, *outer_iter_iter_next;
    int Sss,Sse,Srs,Sre, Ssi;
    BAT * bn = NULL;

    *result=NULL;

    // KNOWN ISSUE: the reject-part does not work (it needs to know which iters there are beforehand)
    // it also has to add the regions to all the iters that are currently not on the heap

    if (BATcount(source_start) != BATcount(source_end)) {
        GDKerror("ll_@1_@2_join_sort_@3: source BATs not related size(start) = %d != size(end) = %d.\n",
                (int) BATcount(source_start),(int)BATcount(source_end));
        return(GDK_FAIL);
    }
    if (!(BATtordered(source_start)&1)) {
        GDKerror("ll_@1_@2_join_sort_@3: source BAT not sorted (on start).\n");
        return(GDK_FAIL);
    }
    if (!(ALIGNrelated(region_start,region_end)&1)) {
        GDKerror("ll_@1_@2_join_sort_@3: region BATs not related.\n");
        return(GDK_FAIL);
    }
    if (!(BATtordered(region_start)&1)) {
        GDKerror("ll_@1_@2_join_sort_@3: region BAT not sorted (on start).\n");
        return(GDK_FAIL);
    }
    //TODO: in case the iter-table is void-nil, do something special... (should be easy)
    if (source_start->htype == TYPE_void && source_start->hseqbase == oid_nil) {
        GDKerror("ll_@1_@2_join_sort_@3: iter-list is of type NIL instead of [V]OID.\n");
        return(GDK_FAIL);
    }

    // the number of iters is also the maximum depth of the heap
    // (however, in most cases the heap will be very shallow,
    // only overlapping nodes will share the heap)
    // we could allocate a lot less space:
    // probably log(|iter|) would be more than enough in most cases
    // counting iters is probably expensive, for now we only reserve for a fixed amount..
    if ((heap = (heap_@3 *)GDKmalloc(sizeof(heap_@3) * max_heap_size)) == NULL) {
        GDKerror("ll_@1_@2_join_sort_@3: could not allocate memory for heap.\n");
        return(GDK_FAIL);
    }
    // the size of the bat is maybe not correct (could be more, could be less)

    if ((bn = BATnew(TYPE_oid, TYPE_oid, BATcount(region_start))) == NULL) {
        GDKerror("ll_@1_@2_join_sort_@3: could not allocate memory for result BAT.\n");
        GDKfree(heap);
        return(GDK_FAIL);
    }

    iter_start = (@4 *) BUNtail(region_start, BUNfirst(region_start));
    iter_end = (@4 *) BUNtail(region_end, BUNfirst(region_end));
    last_start = (@4 *) BUNtail(region_start, BUNlast(region_start));
    outer_iter_iter = (oid *) BUNhead(source_start, BUNfirst(source_start));
    outer_iter_start = (@4 *) BUNtail(source_start, BUNfirst(source_start));
    outer_iter_end = (@4 *) BUNtail(source_end, BUNfirst(source_end));
    outer_last_start = (@4 *) BUNtail(source_start, BUNlast(source_start));

    /* todo: do we have to check for var-sized bats? */
    /* todo: what if size is not a multiple of sizeof(@4)  (BUNsize(...) % sizeof(@4) != 0) */
    Srs = BUNsize(region_start) / sizeof(@4);
    Sre = BUNsize(region_end) / sizeof(@4);
    Sss = BUNsize(source_start) / sizeof(@4);
    Sse = BUNsize(source_end) / sizeof(@4);
    Ssi = BUNsize(source_start) / sizeof(oid);

    heap_size = replace_in_heap_@3(heap,heap_size,
            *outer_iter_iter,
            *outer_iter_start,
            *outer_iter_end);

    while (@:more_target_regions@) {
        outer_iter_start_next = outer_iter_start+Sss;
        outer_iter_end_next = outer_iter_end+Sse;
        outer_iter_iter_next = outer_iter_iter+Ssi;

        /* skip (completely) overlapping regions (in same iter) in the source
           this is NOT an optimization, it is neccessary to capture all the regions */
        while (outer_iter_start_next < outer_last_start) {
            i=0;
            while (i < heap_size && heap[i].iter != *(outer_iter_iter_next)) i++;
            /* only skip region if there already is a region with the same iter
               and the region is contained in the current region on the heap. */
            if (i < heap_size && heap[i].end > *(outer_iter_end_next)) {
                /* skip region */
                outer_iter_start_next+=Sss;
                outer_iter_end_next+=Sse;
                outer_iter_iter_next+=Ssi;
            } else {
                /* otherwise we've got a candidate */
                goto endofskipping;
            }
        }
endofskipping:
        if (outer_iter_start_next < outer_last_start)
            nearest_next_start = *(outer_iter_start_next);
        else
            nearest_next_start = MAX_@3;
        if (outer_iter_start < outer_last_start)
            nearest_start = *(outer_iter_start);
        else
            nearest_start = MAX_@3;

        // todo: an optimization would be to add all the regions with same start-pos at once
        //       if heap[next_iter].start = next_start --> add to heap
        // if (nearest_start == nearest_next_start) -> skip inner loop (next part)

        @:ll_@2(@1,@3)@

        outer_iter_start=outer_iter_start_next;
        outer_iter_end=outer_iter_end_next;
        outer_iter_iter=outer_iter_iter_next;

        if (outer_iter_start < outer_last_start) {
            heap_size = replace_in_heap_@3(heap,heap_size,
                    *outer_iter_iter,
                    *outer_iter_start,
                    *outer_iter_end);
            if (heap_size >= max_heap_size) {
                GDKerror("ll_@1_@2_join_sort_@3: "
                            "too many (>=%d) overlapping input intervals for standoff steps to work well.\n",
                            (int)max_heap_size );
                GDKfree(heap);
                BBPreclaim(bn);
                return GDK_FAIL;
            }
            if (*outer_iter_end < nearest_end)
                nearest_end=*outer_iter_end;
        }
    }
    GDKfree(heap); /* it might be possible there are still items left on the heap,
                       but we are out of target-regions, so they starve... */
    *result=bn;
    return(GDK_SUCCEED);
}
@


@= ll_standoff
@:ll_standoff_join_impl(select,narrow,@1,@2)@
@:ll_standoff_join_impl(select,wide,@1,@2)@
@:ll_standoff_join_impl(reject,narrow,@1,@2)@
@:ll_standoff_join_impl(reject,wide,@1,@2)@
@

@= standoff
@:standoff_join_impl(select,narrow,@1,@2)@
@:standoff_join_impl(select,wide,@1,@2)@
@:standoff_join_impl(reject,narrow,@1,@2)@
@:standoff_join_impl(reject,wide,@1,@2)@
@

@= heap_procs
typedef struct heap_@1 {
    @2 end,start;
    oid iter;
} heap_@1;

/* iters are unique within the heap */
int remove_iter_from_heap_@1(heap_@1 heap[], int size, oid iter) {
    int i;
    for (i=0;i < size && heap[i].iter != iter; i++);
    for (;   i < size-1;i++) {
      heap[i].end = heap[i+1].end;
      heap[i].start = heap[i+1].start;
      heap[i].iter = heap[i+1].iter;
    }
    return i;
}

/* assume the heap is sorted on 'end'
   we need to do two things:
    - if the same iter is already in the heap, remove it.
    - put the new values in the heap
*/
int replace_in_heap_@1(heap_@1 heap[], int size, oid iter, @2 start, @2 end) {
    size = remove_iter_from_heap_@1(heap, size, iter);
    /* now we are sure there is no heap-item with our iter anymore */
    /* lets bubble to new location for item */
    int i;
    for (i=size;(i > 0) && (heap[i-1].end < end); i--) {
        heap[i].end = heap[i-1].end;
        heap[i].start = heap[i-1].start;
        heap[i].iter = heap[i-1].iter;

    }
    heap[i].iter = iter;
    heap[i].end = end;
    heap[i].start = start;
    /* return the new heapsize */
    return size+1;
}

@

@= ffb
int
CMDfetch_standoff_data_@1(BAT ** result, BAT * region_start, BAT * region_end, char * blobname) {
    // fetches strings from the blob for the regions (start, end) found in two [oid, @1] bats
    // regions should be sorted by start
    // non-loop-lifted
    // result is BAT[VOID,STR]
    @2 *iter_start, *iter_end, start_inc, end_inc, *start_next;
    @2 count, blob_pos, *last_iter_start, next_stop, min_end;
    int c =0;
    int heap_size, i, j;
    struct { @2 start, end; } heap[1024]; // probably a to high estimation, but to be sure...
    char buf[4098], temp[4096];

    FILE *blob;
    // open blob
    if ((blob = fopen(blobname,"rb")) == NULL) {
        GDKerror("could not open Stand-Off data file (the BLOB)\n");
        return(GDK_FAIL);
    }
    min_end = MAX_@1;
    *result = BATnew(TYPE_void, TYPE_str, BATcount(region_start));

    // initialize vars
    iter_start =  (@2 *) BUNtail(region_start, BUNfirst(region_start));
    start_inc = BUNsize(region_start) / sizeof(@2);
    iter_end =  (@2 *) BUNtail(region_end, BUNfirst(region_end));
    end_inc = BUNsize(region_end) / sizeof(@2);
    start_next = iter_start + start_inc;
    last_iter_start =  (@2 *) BUNtail(region_start, BUNlast(region_start));
    count = 0;
    blob_pos =0;
    heap_size = 0;
    while (iter_start < last_iter_start) {
        start_next = iter_start + start_inc;
        //  fast-forward if heap is empty
        if (heap_size==0) {
		fseek(blob,*iter_start,SEEK_SET);
		blob_pos=*iter_start;
	}
        //   push new region on heap
	if ((*iter_end - *iter_start) / 4096 > 0) {
            GDKerror("BLOB: Cannot handle regions larger than 4096 bytes\n");
            return(GDK_FAIL);
        }
        heap[heap_size].start=*iter_start;
        heap[heap_size].end=*iter_end;
	heap_size++;

        // also allocate the memory for the string.
        if (heap_size == 1023) {
            GDKerror("fetch_standoff_data: too many (>= 1024) overlapping intervals for standoff steps to work well.\n");
            fclose(blob);
            return(GDK_FAIL);
        }

        //   start fetching till either: end of region or start of new region (whichever comes first)
        min_end = MAX_@1;
        for (i=0;i<heap_size;i++)
            if (heap[i].end < min_end)
               min_end=heap[i].end;
        if (start_next == last_iter_start || *start_next > min_end)
		next_stop = min_end;
	else
		next_stop = *start_next;

        while (blob_pos < next_stop) {
            c = fgetc(blob);
            if (c == EOF) break;
            // if (c <= 9) c = ' '; // get rid of system-chars
            buf[blob_pos % 4096] = (char) c;
            blob_pos++;
        }

        // remove all heap-items with end == blob_pos (or if EndOfFile, end all items on heap)
        // there could have been an item ending, otherwise a new one
        // will start
        if ((blob_pos == min_end) || (c == EOF))
            for (i=0;i<heap_size;i++)
                if ((heap[i].end == min_end) || (c == EOF)) {
                    if ((heap[i].start % 4096) < (blob_pos % 4096)) {
                      // we have to return (start..end)
                      buf[blob_pos % 4096] = '\0'; // zero-terminate string
                      BUNappend(*result, (ptr)(buf + (heap[i].start % 4096)), FALSE);
                    } else {
                      // we have to concatenate the two parts (start..4095) + (0...end)
                      for (j=0; j < blob_pos - heap[i].start; j++)
                        temp[j] = buf[(heap[i].start + j) % 4096];
                      temp[j]='\0'; // zero-terminate string
                      BUNappend(*result, (ptr)temp, FALSE);
                    }
                    heap_size--; // pop from heap
                    heap[i].start = heap[heap_size].start;
                    heap[i].end = heap[heap_size].end;
                }
        // move to next item
        iter_start+=start_inc; iter_end+=end_inc; start_next+=start_inc; count++;
    }
    // return result
    fclose(blob);
    return(GDK_SUCCEED);
}
@

@mil

######### START OF NEW CODE #######################
### line 809 of pf_support.mx

# lets leave the reject-steps out for now
# those can be implemented as not(select-narrow) and not(select-wide)


#############################################
# MIL WRAPPER for AXIS STEPS
#

@:standoff_wrap(select_narrow)@
@:standoff_wrap(select_wide)@

### line 847 of pf_support.mx

@= chk_order
    if ( and(order,1) = @2 ) {
       	@3 := @3.chk_order(); # just in case...
        if ( not(ordered(reverse(@3))) ) {
            ERROR("@1: tail of @3 must be sorted!");
        }
    }
@

### line 868 of pf_support.mx
@= standoff_wrap
PROC @1 (BAT[oid,oid] iter, BAT[oid,oid] item, oid cont, BAT[void,bat] ws, int order, BAT[void,oid] cands, chr kind_test) : BAT[void,bat]
{
    var result := nil;
    var one_iter := FALSE;
    var one_item := FALSE;
    var min_iter := oid_nil;
    var max_iter := oid_nil;
    
    # check consistency
    if ( isnil(seqbase(iter)) or isnil(seqbase(item)) ) {
       	ERROR("@1(0): heads of iter & item/ctx must not be NIL!");
    }
    if ( (count(iter) != count(item)) or (seqbase(iter) != seqbase(item)) ) {
       	ERROR("@1(1): heads of iter & item/ctx must be aligned (count(iter)="+str(count(iter))+", count(item)="+str(count(item))+", seqbase(iter)="+str(seqbase(iter))+", seqbase(item)="+str(seqbase(item))+") !");
    }
    @:chk_order(@1(3),0,iter)@
    @:chk_order(@1(4),1,item)@
    cands := cands.chk_order(); # just in case...


    # trivial cases
    ## the trivial case with PRE_SIZE does not apply (at least,
    ## we do not want to use the PRE_SIZE bat)
    if ( (count(item) = 0) or (count(cands) = 0)) {
       	result := new(void,bat,2).seqbase(0@0)
       	          .append(bat(void,oid,0).seqbase(0@0).access(BAT_READ))
       	          .append(bat(void,oid,0).seqbase(0@0).access(BAT_READ))
       	          .access(BAT_READ);
       	return result;
    }

    ## Special cases don't work for select-narrow, select-wide
    ## perhaps other special cases apply

### line 930 of pf_support.mx

    ## FIXME: should we do fetch_region_index here?, because it could be
    ## done much earlier. (we know it this index is needed when parsing 
    ## the query)
    var index := fetch_region_index(ws, cont);
    ## FIXME: perhaps do some error-checking here
    var region_pre := index.fetch(0@0); # REGION_PRE);
    var region_start := index.fetch(1@0); # REGION_START);
    var region_end := index.fetch(2@0); # REGION_END);

    # pre-sort input
    if ( and(order,1) = 0 ) {
        var ord := item.tsort();
        ord := ord.CTrefine(iter).mark(0@0).reverse();
        iter := ord.leftfetchjoin(iter);
        item := ord.leftfetchjoin(item);
        iter := iter.chk_order();
        item := item.chk_order();
    }

    # the actual location step
    if ( isnil(result) ) {
       	## - we don't need the min_iter, max_iter, one_iter, one_item...
       	## but we DO need region_pre, _start, _end
        ## - only the PRE-values in the cands-bat are needed
       	var res := ll_standoff_@1 (cands.reverse().project(nil).reverse(), iter, item, region_pre, region_start, region_end);
    	result := new(void,bat,2).seqbase(0@0)
       	          .append(res.mark(0@0).reverse())
       	          .append(res.reverse().mark(0@0).reverse())
       	          .access(BAT_READ);
    }

    # post-sort output
    if ( (and(order,2) = 2) and not(ordered(reverse(result.fetch(1)))) ) {
       	iter := result.fetch(0);
       	item := result.fetch(1);
       	var ord := item.tsort();
       	    ord := ord.CTrefine(iter).mark(0@0).reverse();
       	result := new(void,bat,2).seqbase(0@0)
       	          .append(ord.leftfetchjoin(iter).chk_order())
       	          .append(ord.leftfetchjoin(item).chk_order())
       	          .access(BAT_READ);
    }

    # post-sort output
    if ( (and(order,2) = 0) and not(ordered(reverse(result.fetch(0)))) ) {
       	iter := result.fetch(0);
    	item := result.fetch(1);
       	var ord := iter.tsort();
            ord := ord.CTrefine(item).mark(0@0).reverse();
        result := new(void,bat,2).seqbase(0@0)
                  .append(ord.leftfetchjoin(iter).chk_order())
       	             .append(ord.leftfetchjoin(item).chk_order())
       	          .access(BAT_READ);
    }
    return result;
}
ADDHELP("@1", "tsheyar,vzzzbx", "Sep 2006",
"PARAMETERS:\n\
BAT[void,oid] iter (grouping relation)\n\
BAT[void,oid] item (context set)\n\
oid cont (the current container of the ws)\n\
BAT[void,bat] ws (working set)\n\
int order (input & output order properties:\n\
           bit 0: input is sorted on iter(0) or item(1)\n\
           bit 1: output must be sorted on iter(0) or item(1))\n\
BAT[void,oid] cands (sorted list of result candidate OIDs in the tail)\n\
DESCRIPTION:\n\
returns all nodes on the @1 axis of the item-nodes duplicate free for each group.\n\
NOTE: this code is copied from pf_support (and was then modified)",
"pf_standoff");
@
### line 993 of pf_support.mx
@

## the standoff_step doesn't seem to be used. (therefore omitted)

### line 1073 of pf_support.mx

@mil
@:loop_lifted_standoffjoin_wrap1(select_narrow)@
@:loop_lifted_standoffjoin_wrap1(select_wide)@
@

### line 1106 of pf_support.mx

#==================================================================
# expansions of the loop lifted standoffjoin
# kind argument
@= kind_args
, chr kind
@
@= kind_params
, kind
@
# tagname argument
@= ns_args
, str ns
@
@= ns_params
, ns
@
@= loc_args
, str loc
@
@= loc_params
, loc
@
@= tgt_args
, str tgt
@
@= tgt_params
, tgt
@
@= nsloc_args
, str ns, str loc
@
@= nsloc_params
, ns, loc
@
@= params2
, cands, kind_test
@= postfilter
if (postfilter) {
    var pre_cont := ws.fetch(PRE_CONT).fetch(contID);
    var pre_kind := ws.fetch(PRE_KIND).fetch(contID);
    var pre_prop := ws.fetch(PRE_PROP).fetch(contID);
    if (is_constant(pre_cont)) {
        # determine a sel [qnid,qnid] of qualifying nslocs (i.e. prop IDs)
        var sel := ws.fetch(@1).fetch(bat2constant(pre_cont)).ord_uselect(@2);

        # first join on prop, getting some false hits for non ELEMENT nodes
        tmp_res := result_part_item.leftfetchjoin(pre_prop).leftjoin(sel).hmark(0@0);

        # remove false hits
        tmp_res := tmp_res.leftfetchjoin(result_part_item).leftfetchjoin(pre_kind).ord_uselect(@3).hmark(0@0).leftfetchjoin(tmp_res);
    } else {
        # the cont value refers back to multiple different containers (XPath step in transient doc container)

        # first select the element nodes
        var X := result_part_item.leftfetchjoin(pre_kind).ord_uselect(@3).hmark(0@0);

        # fetch cont and prop values
        tmp_res := X.leftfetchjoin(result_part_item);
        var X_cont  := tmp_res.leftfetchjoin(pre_cont);
        var X_prop  := tmp_res.leftfetchjoin(pre_prop);

        # get qnames using mposjoin from the source containers
        var X_nsloc := mposjoin(X_prop, X_cont, ws.fetch(@1));

        # final select
        tmp_res := X_nsloc.ord_uselect(@2).hmark(0@0).leftfetchjoin(X);
    }
    @:mapping_code@
}
@= mapping_code
    result_part_iter := tmp_res.leftfetchjoin(result_part_iter);
    result_part_item := tmp_res.leftfetchjoin(result_part_item);
    tmp_res := nil;
@= nsloc_post
      { var nsloc := ns + ":" + loc; @:postfilter(QN_URI_LOC,nsloc,ELEMENT)@ }
@= loc_post
    @:postfilter(QN_LOC,loc,ELEMENT)@
@= ns_post
    @:postfilter(QN_URI,ns,ELEMENT)@
@= target_post
    @:postfilter(PROP_TGT,tgt,PI)@
@= kind_post
    if (postfilter) {
        var pre_kind := ws.fetch(PRE_KIND).find(contID);
        tmp_res := result_part_item.leftfetchjoin(pre_kind).ord_uselect(@1).hmark(0@0);
        @:mapping_code@
    }
@= no_pre
    cands := ws.fetch(PRE_SIZE).fetch(contID).mirror(); # no selection: cands is everything
@= kind_pre
      { cands := ws.fetch(PRE_KIND).fetch(contID).mirror(); kind_test := kind; }
@= nsloc_pre
      { var nsloc := ns + ":" + loc; @:prefilter(nsloc,QN_URI_LOC)@ }
@= loc_pre
      { @:prefilter(loc,QN_LOC)@ }
@= ns_pre
      { @:prefilter(ns,QN_URI)@ }
@= prefilter
    cands := ws.fetch(PRE_SIZE).fetch(contID).mirror();
    var pre_cont := ws.fetch(PRE_CONT).fetch(contID);
    if (is_constant(pre_cont)) {
        var qn_sel := ws.fetch(@2).fetch(bat2constant(pre_cont)).ord_uselect(@1);
        if (isnil(CATCH(cands := ws_lookup(ws, contID, qn_sel.mirror())))) {
                    var map_pid  := ws.fetch(MAP_PID).fetch(contID);
                    var nid_rid  := ws.fetch(NID_RID).fetch(contID);
                    cands := cands.leftfetchjoin(nid_rid).[swizzle](map_pid); # free in readonly case
                    cands.reverse().chk_order(); # TODO: can we avoid a scan here?
                    cands := cands.tsort(); # ouch! but should be a view in the readonly case
                    postfilter := false; # we have a true candidate list
        }
        ## NOTE: in case of standoff, we are not allowed to filter out
        ## pre's before or after the ctx-set of pre's
    } # else we use postfilter (after SCJ)
    cands := cands.tmark(0@0);
@
### line 1233 of pf_support.mx
# expanding the standoffjoin for the different tests

## replaced standoffjoin with standoffjoin
@= loop_lifted_standoffjoin_wrap1
@:loop_lifted_standoffjoin_wrap_pre(@1)@
@
@= loop_lifted_standoffjoin_wrap_pre
@:loop_lifted_standoffjoin_step2(@1,,,,,                                                               @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@,,                   @:params2@,@:kind_pre(kind)@)@
@:loop_lifted_standoffjoin_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@,     @:params2@,@:nsloc_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@,        @:params2@,@:ns_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@,       @:params2@,@:loc_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@,    @:params2@,@:no_pre@)@
@
@= loop_lifted_standoffjoin_wrap_post
@:loop_lifted_standoffjoin_step2(@1,,,,,                                                               @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@, @:kind_post(kind)@,@:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@,     @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@,        @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@,       @:params2@,@:no_pre@)@
@:loop_lifted_standoffjoin_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@,    @:params2@,@:no_pre@)@
@
@= loop_lifted_standoffjoin_step1
@:loop_lifted_standoffjoin_step2(@1,,,,,,                                                               )@
@:loop_lifted_standoffjoin_step2(@1,_with_kind_test,  @:kind_args@, @:kind_params@, @:kind_post(kind)@,,)@
@:loop_lifted_standoffjoin_step2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,@:nsloc_post@     ,,)@
@:loop_lifted_standoffjoin_step2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   @:ns_post@        ,,)@
@:loop_lifted_standoffjoin_step2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  @:loc_post@       ,,)@
@:loop_lifted_standoffjoin_step2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  @:target_post@    ,,)@
@
#==================================================================
# actual definition of the standoffjoin proc
@= loop_lifted_standoffjoin_per_cont
	result_part_iter := result_part_iter.chk_order();
	result_part_item := result_part_item.chk_order();
        result_part_cont := nil;

	# pre-test
	@4
    var result := @1 (result_part_iter, result_part_item, contID, ws, order @3);
	result_part_iter := result.fetch(0);
	result_part_item := result.fetch(1);
    result_part_cont := constant2bat(contID);
	cands := nil;

	# post-test
	@2
@
@= loop_lifted_standoffjoin_step2
PROC loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] cont, bat[void, bat] ws @3) : bat[void,bat]
{
     return loop_lifted_@1_step@2 (iter, item, cont, ws, 0 @4);
}
PROC loop_lifted_@1_step@2 (bat[void, oid] iter, bat[void, oid] item, bat[void, oid] cont, bat[void, bat] ws, int order @3) : bat[void,bat]
{
    # handle empty results correctly
    if (iter.count() = 0) {
	var empty := bat(void,oid,0).seqbase(0@0).access(BAT_READ);
	return bat(void,bat,3).seqbase(0@0)
			    .append(empty)
			    .append(empty)
			    .append(empty)
			    .access(BAT_READ);
    }

    var result;
    var result_iter;
    var result_item;
    var result_cont;
    var tmp_res;
    var cands;
    var kind_test := chr_nil;
    var postfilter := true;

    var uniqueCont := cont.tunique().sort();
    var contID := uniqueCont.reverse().fetch(0);
    if (uniqueCont.count() = 1) {
        var result_part_cont := oid_nil;
        var result_part_iter := iter;
        var result_part_item := item;

        @:loop_lifted_standoffjoin_per_cont(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_cont := result_part_cont;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_cont := nil;
    } else {
        var result_part_cont := cont.ord_uselect(contID).hmark(0@0);
        var result_part_iter := result_part_cont.leftfetchjoin(iter);
        var result_part_item := result_part_cont.leftfetchjoin(item);

        @:loop_lifted_standoffjoin_per_cont(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_cont := result_part_cont;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_cont := nil;

    	var res_mu;
		uniqueCont.slice(1,uniqueCont.count() - 1)@batloop () {
	    	contID := $h;
            result_part_cont := cont.ord_uselect(contID).hmark(0@0);
            result_part_iter := result_part_cont.leftfetchjoin(iter);
            result_part_item := result_part_cont.leftfetchjoin(item);

            @:loop_lifted_standoffjoin_per_cont(@1,@5,@6,@7)@

            if ( and(order,2) = 2 )
	    	{
	        	res_mu := merged_union(result_item, result_part_item,
	             		   result_iter, result_part_iter,
	             		   result_cont, result_part_cont);
                result_part_iter := nil;
                result_part_item := nil;
                result_part_cont := nil;
                result_item := res_mu.fetch(0);
                result_iter := res_mu.fetch(1);
                result_cont := res_mu.fetch(2);
                res_mu := nil;
	    	}
	    	else
	    	{
	        	res_mu := merged_union(result_iter, result_part_iter,
	             		   result_item, result_part_item,
	             		   result_cont, result_part_cont);
                 result_part_iter := nil;
                 result_part_item := nil;
                 result_part_cont := nil;
                 result_iter := res_mu.fetch(0);
                 result_item := res_mu.fetch(1);
                 result_cont := res_mu.fetch(2);
                 res_mu := nil;
	    	}
        }
    }

    result_iter.access(BAT_READ);
    result_item.access(BAT_READ);
    result_cont.access(BAT_READ);
    var result_standoffjoin := bat(void,bat,3).seqbase(0@0);
    result_standoffjoin.append(result_iter);
    result_standoffjoin.append(result_item);
    result_standoffjoin.append(result_cont);

    return result_standoffjoin.access(BAT_READ);
}
@
### line 1384 of pf_support.mx

@= ll_standoff_mil
################################################
# Loop Lifted version of the @1-@2 StandOff Step
# invoked by ll_standoff_step (returns PRE's)
PROC ll_standoff_@1_@2(BAT[void,oid] cands,
                       BAT[oid,oid] iter,
                       BAT[oid,oid] ctx,
                       BAT[oid,oid] region_pre,
                       BAT[oid,any] region_start,
                       BAT[oid,any] region_end
                       ) : BAT[oid,oid]
{
  # prepare all the regions
  var max_iter := iter.max();
  var source_region := ctx.join(region_pre.reverse()).reverse();
  var region_iter := source_region.leftjoin(iter);
  source_region := source_region.mirror().leftjoin(region_start).sort().project(nil).reverse();
  var source_iter := source_region.leftjoin(region_iter).tmark(0@0);

  #  try to get a iter_start...
  var source_start := source_region.leftjoin(region_start).tmark(0@0);
  var iter_start := source_iter.[oid]().reverse().leftjoin(source_start).reverse().[oid]().reverse();
  var source_end := source_region.leftjoin(region_end).tmark(0@0);

  var sel_region := cands.reverse().mirror().leftjoin(region_pre.reverse()).reverse().mirror();
  var sel_region2 := sel_region.leftjoin(region_start).sort().hmark(0@0);
  var sel_start := sel_region2.leftjoin(region_start);
  var sel_end := sel_region2.leftjoin(region_end);

  # do the join
  # FIXME: Wouter: as of version 0.12 document-containers can hold multiple documents
  # we actually should do a batloop here (iterate over all documents in a document-container)
  # and per-document we should find the proper context-nodes and candidates

  # another option would be to modify the ll_@1_@2_join_sort
  var result := ll_@1_@2_join_sort(iter_start, source_end,
                                   sel_start, sel_end);

  # and convert the regions back to PRE's
  result := result.leftjoin(sel_region2);
  result := result.leftjoin(region_pre);

  # must have [iter,pre] order. First sort on iter (in-place, with order()).
  result.chk_order().access(BAT_WRITE).order().access(BAT_READ);

  # get positions in [iter,pre] order with CTrefine, and fetch positionally
  return result.fetch(CTrefine(result.hmark(0@0), result.tmark(0@0)));
}
@
@= standoff_mil
# actual step (non-loop-lifted)
PROC standoff_@1_@2(BAT[void,oid] cands,
                    BAT[oid,void] ctx,
                    BAT[oid,oid] region_pre,
                    BAT[oid,any] region_start,
                    BAT[oid,any] region_end
                    ) : BAT[void,oid]
{
  # prepare all the regions
  var source_region := ctx.reverse().join(region_pre.reverse()).reverse().mirror();
  source_region := source_region.leftjoin(region_start).sort().reverse();
  var source_start := source_region.leftjoin(region_start).tmark(0@0);
  var source_end := source_region.leftjoin(region_end).tmark(0@0);

  # sel_region = region_region?
  var sel_region := cands.reverse().mirror().leftjoin(region_pre.reverse()).reverse().mirror();
  # sel_region2 is translation-table sel-region
  var sel_region2 := sel_region.leftjoin(region_start).sort().hmark(0@0);
  var sel_start := sel_region2.leftjoin(region_start);
  var sel_end := sel_region2.leftjoin(region_end);

  # do the join
  # FIXME: Wouter: as of version 0.14 document-containers can hold multiple documents
  # we actually should do a batloop here (iterate over all documents in a document-container)
  var result := @1_@2_join_sort(source_start, source_end,
                                sel_start, sel_end);

  # and convert the regions back to PRE's
  result := result.leftjoin(sel_region2);
  result := result.leftjoin(region_pre).reverse().mark(0@0).sort();
  return result;
}
@

### line 1385 of pf_support.mx
######### END OF NEW CODE #######################

@mil

# fetch_region_index checks the state of the volatile bats RT_REGION_PRE, RT_REGION_START
# and RT_REGION_END in a collection. If they do not exist, they should be created,
# If they are not up to date for the given collection, then they should be 
# recreated (using region_extract) based on the current bats in the working set.
PROC fetch_region_index(
                BAT[void,bat] ws, 
                oid coll_oid) : BAT[void,bat]
{
    var err, coll_lock, index, runtime := empty_runtime;

    # check whether lock is set...
    if (coll_oid != TEMP_DOC) {
         var runtime := ws.fetch(CONT_RUNTIME).fetch(coll_oid);
         err := CATCH(coll_lock := reverse(runtime).fetch(RT_LOCK_FREELIST));
         if (not(isnil(err))) ERROR(err);
         lock_set(coll_lock); # never lock a collection inside the short lock
    }

    err := CATCH(index := __fetch_region_index(ws, runtime, coll_oid));
    if (coll_oid != TEMP_DOC) {
        lock_unset(coll_lock); # release lock acquired for updatable bats
    }
    if (not(isnil(err))) {
        ERROR(err);
    }
    return index;
}

PROC __fetch_region_index(
                BAT[void,BAT] ws,
                BAT[lock,BAT] runtime,
                oid coll_oid
        ) : BAT[void,BAT]
{
    # check if runtime-region-index-bats exist
    if (or(=(coll_oid, TEMP_DOC), 
           not(runtime.exist(RT_REGION_PRE_LOCK)))
       ) {
        # do build index
        __region_extract(ws, runtime, coll_oid, "lng");
    }
    if (=(runtime.find(RT_REGION_PRE_LOCK), empty_bat)) {
        # do build index
        __region_extract(ws, runtime, coll_oid, "lng");
    }

    # 0@0 = REGION_PRE, 1@0 = REGION_START, 2@0 = REGION_END
    var result := bat(void,bat).seqbase(0@0); 
    result.append(runtime.find(RT_REGION_PRE_LOCK));
    result.append(runtime.find(RT_REGION_START_LOCK));
    result.append(runtime.find(RT_REGION_END_LOCK));
    return result;
}


# create indices per collection...
# only add them afterwards to the collection...
# the collection lock is there... we are free to read the bats...
# ??? (euhm, do we need the lock, for extracting regions???)
PROC __region_extract(BAT[oid, BAT] ws, BAT[lock,BAT] runtime, oid coll_oid, str tpe) : void {

  # FIXME: create a separate address range for each document in the container

  # how-to: this region extract is used for the StandOff steps
  # if your regions are stored in different attributes than "start" and "end",
  # than modify the variables region_namespace, region_start_attr_tag, and
  # region_end_attr_tag


  var XIRAF_nodes := ws.fetch(QN_LOC).fetch(coll_oid).reverse().leftjoin(
                        ws.fetch(QN_PREFIX).fetch(coll_oid).ord_uselect(region_namespace).mirror());

  var region_pre, region_start, region_end;
  var start_qn := nil, end_qn := nil;
  if (isnil(CATCH({ start_qn := XIRAF_nodes.find(region_start_attr_tag);
                    end_qn := XIRAF_nodes.find(region_end_attr_tag); }))) {
      # get all start attributes, then their numerical value, sort it, and then get the PRE's
      var attr_attr := ws.fetch(ATTR_QN).find(coll_oid).ord_uselect(start_qn).mirror();
      var attr_prop := attr_attr.leftjoin(ws.fetch(ATTR_PROP).find(coll_oid));
      var val_start := [*tpe](attr_prop.leftjoin(ws.fetch(PROP_VAL).find(coll_oid))).reverse().sort();
      # Wouter?: ATTR_OWN now points to PREs? (coll_oid.o. PRE?s)
      var start_pre := val_start.leftjoin(ws.fetch(ATTR_OWN).find(coll_oid));

      # now we have a table with a PRE column and a start (numerical) column in the right order
      var left_pre := start_pre.tmark(0@0);
      var left_start := start_pre.hmark(0@0);

      # go get the PRE numbers that have an end attribute
      var right_attr := ws.fetch(ATTR_QN).find(coll_oid).ord_uselect(end_qn).hmark(0@0);
      var right_pre := right_attr.leftjoin(ws.fetch(ATTR_OWN).find(coll_oid));
      var right_end := [*tpe](right_attr.leftjoin(ws.fetch(ATTR_PROP).find(coll_oid)).leftjoin(ws.fetch(PROP_VAL).find(coll_oid)));

      # the region table is the intersection between start and end
      var left_right := left_pre.leftjoin(right_pre.reverse());
      var region_left := left_right.hmark(0@0);
      var region_right := left_right.tmark(0@0);

## TODO: FIXME : the following code does not work, but should assign
##               the largest possible region to the document-node
#      if (=(tpe,"lng")) {
#        region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                   .insert(region_left.leftjoin(left_pre));
#        region_start := bat(void,lng).seqbase(0@0).append(getLNG_MIN())
#                                     .insert(region_left.leftjoin(left_start));
#        region_end := bat(void,lng).seqbase(0@0).append(getLNG_MAX())
#                                   .insert(region_right.leftjoin(right_end));
#     } else {
#       region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                  .insert(region_left.leftjoin(left_pre));
#       region_start := bat(void,INT).seqbase(0@0).append(getINT_MIN())
#                                    .insert(region_left.leftjoin(left_start));
#       region_end := bat(void,INT).seqbase(0@0).append(getINT_MAX())
#                                  .insert(region_right.leftjoin(right_end));
#     }

      region_pre := region_left.leftjoin(left_pre);
      region_start := region_left.leftjoin(left_start);
      region_end := region_right.leftjoin(right_end);
  } else {
      # if there are either no start or end nodes, the result is empty
      region_pre := bat(void,oid).seqbase(0@0);
      region_start := bat(void,monet_atomtbl.find(tpe)).seqbase(0@0);
      region_end := bat(void,monet_atomtbl.find(tpe)).seqbase(0@0);
  }
    if (runtime.exist(RT_REGION_PRE_LOCK)) {
        runtime.replace(RT_REGION_PRE_LOCK,region_pre);
        runtime.replace(RT_REGION_START_LOCK,region_start);
        runtime.replace(RT_REGION_END_LOCK,region_end);
    } else {
        runtime.insert(RT_REGION_PRE_LOCK,region_pre);
        runtime.insert(RT_REGION_START_LOCK,region_start);
        runtime.insert(RT_REGION_END_LOCK,region_end);
    }
}
ADDHELP("__region_extract", "wouter", "Oct 2005",
"PARAMETERS:\n\
BAT[str,BAT] an active ws (Working Set)\n\
oid coll_oid (index in the active working set)\n\
str tpe (type of region-values (int or lng))\n\
DESCRIPTION:\n\
adds three BATs to the working set REGION_PRE, REGION_START, and REGION_END and fills them.",
"pf_standoff");
@

@c
#include "pf_config.h"
#include "pf_standoff.h"

/* simple heap operations for the loop-lifted StandOff join */
@:heap_procs(int,int)@
@:heap_procs(lng,long long)@

/* StandOff joins */
@:standoff(lng,long long)@
@:standoff(int,int)@

@:ll_standoff(lng,long long)@
@:ll_standoff(int,int)@

@- not implemented yet
@c
@:ffb(int, int)@
@:ffb(lng, long long)@

/* vim:set shiftwidth=4 expandtab: */
