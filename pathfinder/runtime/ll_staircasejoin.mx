@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2008 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$

@f ll_staircasejoin
@a Stefan Manegold
@a Jan Rittinger
@t loop-lifted staircasejoin

@c

/**********************************************
* ll_staircasejoin.c : staircase join operators
*
*/

#include "pf_config.h"
#include <gdk.h>
#include "shredder.h" /* for XML_DEPTH_MAX */

#if 0
#define prefetch_loc(addr) \
/* Parameters */
const int PF_SOFTWARE_PREFETCH = 128;

/* software prefetching is not used currently */
  __asm__ __volatile__ ("prefetchnta %0" \
                        : \
                        : \
                        "m" (*(((char*)(size_t)(((unsigned int)(size_t)(addr))&~0x7f)))))
                            /* StM: extended casting to pacify 64-bit compilers */
#else
#define prefetch_loc(addr)
#endif

/* At some places, we are not sure, whether temporary intermediate results
 * (e.g., generated by BATmark or BATsort) are new BATs or just views;
 * hence, we use this wrapper to release the BATs/views properly.
 */
#define BBP_unfix_reclaim(b) \
{\
    if (BBP_refs((b)->batCacheid) > 1) {\
        /*printf("# %s, %s, %d, BBPunfix(%d=%s)\n",__FILE__, __func__, __LINE__,(b)->batCacheid,BATgetId(b));*/\
        BBPunfix((b)->batCacheid);\
    } else {\
        /*printf("# %s, %s, %d, BBPreclaim(%d=%s)\n",__FILE__, __func__, __LINE__,(b)->batCacheid,BATgetId(b));*/\
        BBPreclaim((b));\
    }\
}


/*******************************************************************/

/* DESCENDANT STEP */
@:ll_proto(descendant)@
@:ll_head(descendant,FALSE)@
    self = FALSE;
    res_size = BATcount(iter_bat);	/* FIXME: estimate size! */
@:ll_main(descendant, (size[pre] & (1U<<31)))@

/* DESCENDANT-OR-SELF STEP */
@:ll_head(descendant_or_self,FALSE)@
    self = TRUE;
    res_size = BATcount(iter_bat);	/* FIXME: estimate size! */
@:ll_main(descendant, (size[pre] & (1U<<31)))@

/* CHILD STEP */
@:ll_proto(child)@
@:ll_head(child,TRUE)@
    res_size = BATcount(iter_bat);	/* FIXME: estimate size! */
@:ll_main(child, FALSE)@

/* Templates / Wrappers */

@= ll_proto
static int
ll_@1 (	BAT **res, BAT *iter_bat, BAT *ctx_bat, BAT *end_ctx, BAT *cand_bat, int *size,
	oid min_iter, oid max_iter, bit no_iter_order, bit self, chr* kind, chr kind_test);
@
@= ll_head
int
PFll_@1 (BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *end_ctx, BAT *pre_size, BAT *cand_bat,
	 bit *_one_iter, bit *_one_ctx,
	 oid *_min_iter, oid *_max_iter, bit *_no_iter_order, chr *_kind_test)
{
    /* --------------------------- declarations ---------------------------- */

    char *name = "PFll_@1";
    bit one_iter = *_one_iter;
    bit one_ctx  = *_one_ctx;
    oid min_iter = *_min_iter;
    oid max_iter = *_max_iter;
    bit no_iter_order = *_no_iter_order;
    bit self = FALSE;
    bit child_step = @2;
    chr *kind = NULL, kind_test = *_kind_test;
    BAT *res = NULL;
    BAT *del = NULL;
    BUN res_size = 0;
    int *size;

    /* --------------------------- checks ---------------------------------- */

    BATcheck(iter_bat, name);
    BATcheck(ctx_bat, name);
    BATcheck(end_ctx, name);
    BATcheck(pre_size, name);
    BATcheck(cand_bat, name);

    if (!(BAThdense(iter_bat) && BAThdense(ctx_bat)))
    {
        GDKerror("%s: both iter_bat and ctx_bat must have a dense head.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if ((iter_bat->hseqbase != ctx_bat->hseqbase) || (BATcount(iter_bat) != BATcount(ctx_bat)))
    {
        GDKerror("%s: iter_bat and ctx_bat must be head-aligned, i.e., have equal head seqbases and length.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (!(BATtordered(ctx_bat) & 1))
    {
        GDKerror("%s: ctx_bat must be ordered on tail.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (one_ctx && !(BATtordered(iter_bat) & 1))
    {
        GDKerror("%s: iter_bat must be ordered on tail.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (BATcount(end_ctx) == 0) {
        end_ctx = NULL; /* empty; not used. */
    } else {
        if (!child_step) {
            GDKerror("%s: end_ctx must be empty.\n", name);
            @:ll_return(GDK_FAIL)@
        } else 
        if ((end_ctx->hseqbase != ctx_bat->hseqbase) || (BATcount(end_ctx) != BATcount(ctx_bat)))
        {
            GDKerror("%s: end_ctx must be head-aligned with iter_bat & ctx_bat, i.e., have equal head seqbases and length.\n", name);
            @:ll_return(GDK_FAIL)@
        }
    }

    if (!BAThdense(pre_size))
    {
        GDKerror("%s: head of pre_size must be dense.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (pre_size->ttype != TYPE_int)
    {
        GDKerror("%s: tail of pre_size must be type INT.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (pre_size->htype != TYPE_void)
    {
        GDKerror("%s: head (oid) of pre_size must NOT be materialized.\n", name);
        @:ll_return(GDK_FAIL)@
    }

    if (kind_test != chr_nil) {
        if (cand_bat->ttype != TYPE_chr ||                       /* it contains kinds */
            BATcount(cand_bat) != BATcount(pre_size) ||    /* is the entire pre table */
            cand_bat->htype != TYPE_void) /* and a real void bat (i.e. chr array) */
        {
            GDKerror("%s: cand_bat with kind test must be a real kind bat.\n", name);
            @:ll_return(GDK_FAIL)@
        }
        kind = (chr*) Tloc(cand_bat,BUNfirst(cand_bat));
        cand_bat = NULL;
    } else if (BATcount(cand_bat) == BATcount(pre_size)) {
        cand_bat = NULL; /* HACK: no selection */
    } else if (!(BATtordered(cand_bat) & 1)) {
        GDKerror("%s: cand_bat must be ordered on tail.\n", name);
        @:ll_return(GDK_FAIL)@
    } else if (cand_bat->ttype == TYPE_void) {
        /* rare case: an oid candidate-list that is void-dense.  materialize it */ 
        del = BATnew(TYPE_void, TYPE_oid, BATcount(cand_bat));
        if (del == NULL || (cand_bat->tseqbase != oid_nil && BATins(del, cand_bat, FALSE) == NULL)) 
            @:ll_return(GDK_FAIL)@
        cand_bat = del;
    }
    size = ((int*) Tloc(pre_size, BUNfirst(pre_size))) - (int)pre_size->hseqbase;

    /* --------------------------- empty result ---------------------------- */

    if (BATcount(iter_bat) == 0 || BATcount(pre_size) == 0 || (cand_bat && BATcount(cand_bat) == 0))
    {
        res = BATnew(TYPE_oid, TYPE_void, 0);
        BATkey (res, TRUE);
        res->hsorted = GDK_SORTED;
        res->hdense = TRUE;
        BATseqbase (res, (oid)0); /* does not really matter */
        BATkey (BATmirror(res), TRUE);
        res->tsorted = TRUE;
        res->tdense = TRUE;
        BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        BATset(res, TRUE);
        *result = res;
        @:ll_return(GDK_SUCCEED)@
    }
@

@= ll_main
    /* ---------------------------- main part ----------------------------- */
    /* 
     * @1: step name
     */
    
    if ( one_ctx && !child_step ) {

        /* ------------------------ trivial cases ------------------------- */
        BATiter ctx_bati = bat_iterator(ctx_bat);
        BATiter iter_bati = bat_iterator(iter_bat);
        oid fst_ctx = *(oid*)BUNtail(ctx_bati, BUNfirst(ctx_bat));
        oid lst_ctx = 0;
        oid *sdst = 0, *hdst = 0, *tdst = 0;
        BUN max_size = 0;

        assert((size[fst_ctx] & (1U<<31)) == 0);
        max_size = res_size = (BUN)(size[fst_ctx] + (int)self);
        if ( cand_bat ) {
            if ( BATcount(cand_bat) < res_size ) {
                res_size = BATcount(cand_bat);
            }
        }
        res_size *= BATcount(iter_bat);
        res = BATnew(TYPE_oid, TYPE_oid, res_size);
        if (res == NULL) 
        { 
            GDKerror("%s: could not allocate a result BAT[oid,void] of size " BUNFMT ".\n", name, res_size);
            @:ll_return(GDK_FAIL)@
        }
        res_size /= BATcount(iter_bat);
        fst_ctx = fst_ctx + (oid)(1 - (int)self);
        lst_ctx = fst_ctx + (oid)max_size;
        sdst = hdst = (oid*)Hloc(res, BUNlast(res));
        tdst =        (oid*)Tloc(res, BUNlast(res));
        if ( cand_bat ) {
            oid *cand = 0;
            oid *fst_cand = (oid*)Tloc(cand_bat, SORTfndfirst_oid(cand_bat, &fst_ctx));
            oid *lst_cand = (oid*)Tloc(cand_bat, BUNlast(cand_bat));
                
            if ( one_iter ) {
                oid iter = *(oid*)BUNtail(iter_bati, BUNfirst(iter_bat));

                for (cand = fst_cand ; cand < lst_cand && *cand < lst_ctx; cand++) {
                    *hdst++ = iter;
                    *tdst++ = *cand;
                }
            } else 
            {   /* multiple iters */
                BUN iter = 0;
                BUN fst_iter = BUNfirst(iter_bat);
                BUN lst_iter = BUNlast(iter_bat);
                    
                for (cand = fst_cand ; cand < lst_cand && *cand < lst_ctx; cand++) {
                    for (iter = fst_iter ; iter < lst_iter; iter++) {
                        *hdst++ = *(oid*)BUNtail(iter_bati,iter);
                        *tdst++ = *cand;
                    }
                }
            }
        } else 
        {   /* !cands */ 
            oid pre = 0;
            
            if ( one_iter ) {
                oid iter = *(oid*)BUNtail(iter_bati, BUNfirst(iter_bat));

                for (pre = fst_ctx ; pre < lst_ctx ; pre++ ) {
                    if ((kind && kind[pre] != kind_test) || @2) continue; 
                    *hdst++ = iter;
                    *tdst++ = pre;
                }
            } else 
            {   /* multiple iters */
                BUN iter = 0;
                BUN fst_iter = BUNfirst(iter_bat);
                BUN lst_iter = BUNlast(iter_bat);
                
                for (pre = fst_ctx ; pre < lst_ctx ; pre++ ) {
                    if ((kind && kind[pre] != kind_test) || @2) continue; 
                    for (iter = fst_iter ; iter < lst_iter; iter ++) {
                        *hdst++ = *(oid*)BUNtail(iter_bati,iter);
                        *tdst++ = pre;
                    }
                }
            }
        }
        BATsetcount(res, hdst-sdst);
    } else
    /* ( !one_ctx || child_step ) */ {

        /* ------------------------ general cases ------------------------- */

        /* --- result bat allocation. for result size use res_size parameter --- */
        res = BATnew(TYPE_oid, TYPE_oid, res_size);
        if (res == NULL) 
        { 
            GDKerror("%s: could not allocate a result BAT[oid,oid] of size " BUNFMT ".\n", name, res_size);
            @:ll_return(GDK_FAIL)@
        }

        if (ll_@1(&res, iter_bat, ctx_bat, end_ctx, cand_bat, size, 
                  min_iter, max_iter, no_iter_order, self, kind, kind_test) == GDK_FAIL )
        {
            @:ll_return(GDK_FAIL)@
        }
    }

    /* -------------------- set result properties ---------------------- */
{
    BATiter resi = bat_iterator(res);
    bit trivial  = BATcount(res) < 2;
    /* actually zero_or_one_item... */
    bit one_item = trivial || (*(oid*)BUNtail(resi, BUNfirst(res)) == *(oid*)BUNtail(resi, BUNlast(res) - 1));

    res->batDirty = TRUE;
    res->hdense = (trivial||(res->htype==TYPE_void)); /* might be TRUE in some more cases... */
    if (res->hdense) {
        if (BATcount(res) == 0) {
            BATseqbase (res, (oid)0); /* does not really matter */
        } else {
            BATseqbase (res, *(oid*)BUNhead(resi, BUNfirst(res)));
        }
    }
    res->hsorted = ((one_iter||one_item) ? GDK_SORTED : 0); /* might be TRUE in some more cases... */
    BATkey(res,(res->hdense||one_item)); /* might be TRUE in some more cases... */
    res->tdense = (trivial||(res->ttype==TYPE_void)); /* might be TRUE in some more cases... */
    if (res->tdense) {
        if (BATcount(res) == 0) {
            BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        } else {
            BATseqbase (BATmirror(res), *(oid*)BUNtail(resi, BUNfirst(res)));
        }
    }
    res->tsorted = GDK_SORTED;
    BATkey(BATmirror(res),(res->tdense||one_iter)); /* might be TRUE in some more cases... */
    BATset(res, TRUE);
}
    res->H->nonil = 0;
    res->T->nonil = 0;
    *result = res;

    @:ll_return(GDK_SUCCEED)@
}
@

@= ll_return
{   if (del) BBPreclaim(del);
    if (res && (@1 == GDK_FAIL))
        BBP_unfix_reclaim(res);
    return @1; }
@c

/* ============================== Tools =================================== */

#define PFll_check_BAT_capacity(b,grow) \
{\
        BUN _oldcap = BATcapacity(b);\
        BUN _reqcap = BATcount(b) + grow;\
        unsigned short _bunsize = Hsize(b) + Tsize(b);\
        if (_oldcap < _reqcap) {\
            BUN _newcap = MAX(_reqcap, BATgrows(b));\
            if (BATextend((b), _newcap) == NULL) {\
                GDKerror("%s: BATextend of BAT '%s' (#%d) failed "\
                         "for " BUNFMT " buns (" BUNFMT " bytes).\n",\
                         __func__, BATgetId(b), (b)->batCacheid,\
                         _newcap, _newcap * _bunsize);\
                goto bunins_failed;\
            }\
            _newcap = BATcapacity(b);\
            if (_newcap < _reqcap) {\
                GDKerror("%s: BATextend of BAT '%s' (#%d) failed: "\
                         "required " BUNFMT " buns (" BUNFMT " bytes), "\
                         "got only " BUNFMT " buns (" BUNFMT " bytes).\n",\
                         __func__, BATgetId(b), (b)->batCacheid,\
                         _reqcap, _reqcap * _bunsize,\
                         _newcap, _newcap * _bunsize);\
                goto bunins_failed;\
            }\
        }\
}

/* ============================== Step implementations ==================== */

/* ------------------------------ Child ----------------------------------- */

typedef struct stack_item_C si_C;

struct stack_item_C {
    oid eocs;           /* end of ctx scope (pre + size) */
    oid next_child;     /* preorder rank of the next child node */
    BUN first;          /* first iter row of the actual ctx node */
    BUN last;           /* last iter row of the actual ctx node */
};

static int
ll_child ( BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *end_ctx, BAT *cand_bat, int* size,
             oid min_iter, oid max_iter, bit no_iter_order, bit self, chr *kind, chr kind_test)
{
    BATiter ctx_bati = bat_iterator(ctx_bat), end_ctxi = bat_iterator(end_ctx);
    BATiter iter_bati = bat_iterator(iter_bat);
    BAT *res = *result;
    si_C *stack = 0;
    int stack_top = 0;
    oid pre = 0, ctx = 0, cur_ctx = 0;
    BUN cur_idx = 0, iter_idx = 0;
    BUN ctx_bun = 0, ctx_last = 0;
    oid *cand_cur = (oid*)(cand_bat?Tloc(cand_bat,BUNfirst(cand_bat)):NULL);
    oid *cand_lst = (oid*)(cand_bat?Tloc(cand_bat,BUNlast(cand_bat)-1):NULL);

    /* not used, here; keep compilers happy */
    (void)min_iter;
    (void)max_iter;
    (void)no_iter_order;
    (void)self;

    /* stack for context set nodes will never grow over height of doc. tree */
    stack = (si_C*)GDKmalloc(sizeof(si_C) * (XML_DEPTH_MAX + 1));
    if (stack == NULL) {
        GDKerror("ll_child: could not allocate stack of size %d.\n", sizeof(si_C) * (XML_DEPTH_MAX + 1));
        return GDK_FAIL;
    }
    stack_top = 0;

    iter_idx = BUNfirst(iter_bat);
    assert(!end_ctx || iter_idx == BUNfirst(end_ctx));

    ctx_bun = BUNfirst(ctx_bat);
    ctx_last = BUNlast(ctx_bat);

@= getnextctx
    iter_idx++;
    ctx_bun++;
@
@= pushctx
    si_C new_stack_item;
    new_stack_item.eocs = ctx + size[ctx];
    new_stack_item.next_child = ctx + 1;
    new_stack_item.first = iter_idx;
    new_stack_item.last = iter_idx;
    stack[stack_top++] = new_stack_item;
    cur_ctx = ctx;
@
@= popctx
    stack_top--;
@
@c
    if (iter_bat->tkey || ctx_bat->tkey) {
        /* avoid spending effort on duplicate avoidance
         * in case we're sure there are no duplicates
         */
        @:outer_loop_child(,@:no_duplicates_body@)@
    } else {
        @:outer_loop_child(@:skip_duplicates_head@,@:skip_duplicates_body@)@
    }
@
@= outer_loop_child
    /* iterate over all context nodes - evaluation is only done
       starting from the ctx (on the top of the stack) until
       the next ctx node (or the end of the stack top
       ctx node scope) is reached */
    while (ctx_bun < ctx_last && cand_cur <= cand_lst) {
        ctx = *(oid*)BUNtail(ctx_bati,ctx_bun);
        /* if the stack is empty the next ctx node
           has to be pushed on the stack 
           and the next ctx node is called*/
        if (!stack_top) {
            @:pushctx@
            @:getnextctx@
        }
        /* only a new iter has to be added
           to the list of active iters */
        else if (cur_ctx == ctx) {
            stack[stack_top-1].last = iter_idx;
            @:getnextctx@
        }
        /* evaluates the ctx node on top of the stack
           until a descendant is reached. The descendant is then
           pushed on the stack and is the new active ctx */
        else if (stack[stack_top-1].eocs >= ctx) {
            @:inner_loop_child(ctx,@1,@2)@
            stack[stack_top-1].next_child = pre;
            @:pushctx@
            @:getnextctx@
        }
        /* evaluates the ctx node on top of the stack
           until the end of its scope is reached. Then the
           node is popped and the next cycle is called with
           the same ctx node to first activate older nodes
           on the stack */
        else {
            @:inner_loop_child(stack[stack_top-1].eocs,@1,@2)@
            @:popctx@
        }
    }
    /* need to process the ctx nodes, which are still on the stack 
       - only need to evaluate the inner loop and pop, because 
         there are no more new ctx nodes */
    while (stack_top) {
        @:inner_loop_child(stack[stack_top-1].eocs,@1,@2)@
        @:popctx@
    }
@
@= inner_loop_child
    pre = stack[stack_top-1].next_child;
    /* iterates over all childs until the next limit is reached
       (either descendant ctx node or end of scope) and prunes
       all subtree which can't hold any matches */
    if (cand_bat) {
        if (cand_cur <= cand_lst) {
            oid *fst_pre = cand_cur;
            oid lst_pre = MIN(@1, *cand_lst);

            for (; pre <= @1 && pre < *fst_pre; pre += (size[pre]&GDK_int_max) + 1) { 
            }
            for (;              pre <= lst_pre; pre += (size[pre]&GDK_int_max) + 1)
              if ((size[pre] & (1U<<31)) == 0) {

                /* poor man's binary search / exploiting forward scan */
                while (fst_pre+1048576 <= cand_lst && *(oid*) (fst_pre+1048576) < pre)
                    fst_pre += 1048576; /* this avoids mmapped I/O */
                while (fst_pre+32768 <= cand_lst && *(oid*) (fst_pre+32768) < pre)
                    fst_pre += 32768;
                while (fst_pre+1024 <= cand_lst && *(oid*) (fst_pre+1024) < pre)
                    fst_pre += 1024;
                while (fst_pre+32 <= cand_lst && *(oid*) (fst_pre+32) < pre)
                    fst_pre += 32;
                while (fst_pre <= cand_lst && *(oid*)fst_pre < pre)
                    fst_pre ++;
                if (fst_pre <= cand_lst && *(oid*)fst_pre == pre) {
                        @:inner_loop_child_body(@2,@3)@
                        fst_pre ++;
                }
            }
            cand_cur = fst_pre;
        }
        for (; pre <= @1; pre += (size[pre]&GDK_int_max) + 1) {
        }
    } else if (kind) {
        for (; pre <= @1; pre += (size[pre]&GDK_int_max) + 1) {
            if ((size[pre] & (1U<<31)) == 0 && kind[pre] == kind_test) {
                @:inner_loop_child_body(@2,@3)@
            }
        }
    } else {
        for (; pre <= @1; pre += (size[pre]&GDK_int_max) + 1) {
            if ((size[pre] & (1U<<31)) == 0) {
                @:inner_loop_child_body(@2,@3)@
            }
        }
    }
@
@= skip_duplicates_head
        oid prev_iter = oid_nil;
@
@= skip_duplicates_body
            oid next_iter = *(oid*)BUNtail(iter_bati,cur_idx);
            if (next_iter != prev_iter) {
                /* (Even) if the same context node (item)
                 * occurs multiple times per iter,
                 * we must not produce duplicate results;
                 * let's hope, the iters are ordered per item (context node).
                 * ToDo:
                 * Can we do this more efficiently, e.g.,
                 * by upfront ensuring that [iter,item] ([iter,ctx])
                 * is a set, i.e., duplicate free??
                 */
                *hdst++ = next_iter;
                *tdst++ = pre;
                prev_iter = next_iter;
            }
@
@= no_duplicates_body
            oid next_iter = *(oid*)BUNtail(iter_bati,cur_idx);
            *hdst++ = next_iter;
            *tdst++ = pre;
@
@= inner_loop_child_body
        @1
        BUN grow = (stack[stack_top-1].last - stack[stack_top-1].first) + 1;
        oid *sdst, *hdst, *tdst;

        /* check, if result buffer is big enough; otherwise extend it */
        PFll_check_BAT_capacity(res, grow);
        /* creates a row for every iter, whose ctx node produced
           a match */
        sdst = (oid*)Hloc(res, BUNfirst(res));
        hdst = (oid*)Hloc(res, BUNlast(res));
        tdst = (oid*)Tloc(res, BUNlast(res));
        if (end_ctx) {
            for (cur_idx = stack[stack_top-1].first;
                 cur_idx <= stack[stack_top-1].last;
                 cur_idx++) {
                if (pre < *(oid*)BUNtail(end_ctxi,cur_idx)) {
                    @2
                }
            }
        } else {
            for (cur_idx = stack[stack_top-1].first;
                 cur_idx <= stack[stack_top-1].last;
                 cur_idx++) {
                @2
            }
        }
        BATsetcount(res, hdst-sdst);
@
@c

    GDKfree(stack);
    *result = res;    
    return GDK_SUCCEED;
bunins_failed:
    GDKfree(stack);
    GDKerror("ll_child: bunins failed.\n");
    *result = res;    
    return GDK_FAIL;
}


/* ------------------------------ Descendant ------------------------------ */

typedef struct stack_item_D si_D;

struct stack_item_D {
    oid iter_idx;       /* index of iter */
    oid eocs;           /* end of ctx scope (pre + size) */
};

#define OST unsigned long long		/* type for "onstack" bitvector: "lng" or "chr" */

#define onstack_set(b)	 onstack[(b)>>OST_shift] |=   ((OST)1)<<((b)&OST_mask) 
#define onstack_clr(b)	 onstack[(b)>>OST_shift] &= ~(((OST)1)<<((b)&OST_mask))
#define onstack_get(b)	(onstack[(b)>>OST_shift] &   (((OST)1)<<((b)&OST_mask)))

static int
ll_descendant ( BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *end_ctx, BAT *cand_bat, int* size,
                oid min_iter, oid max_iter, bit no_iter_order, bit self, chr* kind, chr kind_test)
{
    BATiter ctx_bati = bat_iterator(ctx_bat), iter_bati = bat_iterator(iter_bat);
    BAT *res = *result;
    si_D *stack = 0;
    OST *onstack = 0;
    oid *iters_on_stack = 0;
    int stack_size = 0, onstack_size = 0, iters_on_stack_size = 0, j = 0;
    int stack_top = 0;
    oid pre = 0, ctx = 0, iter_idx = 0, cnd = 0, lst_cnd = GDK_oid_max;
    BUN iter_bun = 0, ctx_bun = 0, ctx_last = 0;
    oid *cnd_ptr = 0, *cnd_lst = 0;
    oid num_iters = (max_iter - min_iter) + 1, i;
    int OST_bytes = sizeof(OST);
    int OST_bits  = OST_bytes * 8;
    int OST_mask  = OST_bits - 1;
    int OST_shift = 0;

    /* not used, here; keep compilers happy */
    (void)end_ctx;
    
    if (cand_bat) {
        cnd_ptr = (oid*)Tloc(cand_bat, BUNfirst(cand_bat));
        cnd     = *cnd_ptr;
        cnd_lst = (oid*)Tloc(cand_bat, BUNlast(cand_bat) - 1);
        lst_cnd = *cnd_lst;
    }

    for (i=OST_mask; i; i>>=1) OST_shift++;

    /* stack for context set nodes will never grow over number of iters */
    stack_size = sizeof(si_D) * num_iters;
    stack = (si_D*)GDKmalloc(stack_size);
    if (stack == NULL) {
        GDKerror("ll_descendant: could not allocate stack of size %d.\n", stack_size);
        @:ll_fail_descendant@
    }
    stack_top = 0;

    /* bitvector to maintain which iters are currently on the stack */
    onstack_size = OST_bytes * ((num_iters >> OST_shift) + 1);
    onstack = (OST*)GDKmalloc(onstack_size);
    if (onstack == NULL) {
        GDKerror("ll_descendant: could not allocate bitvector of size %d.\n", onstack_size);
        @:ll_fail_descendant@
    }
    memset(onstack, 0, onstack_size);

    /* sorted list of all iters that are currently on the stack */
    iters_on_stack_size = sizeof(oid) * num_iters;
    iters_on_stack = (oid*)GDKmalloc(iters_on_stack_size);
    if (iters_on_stack == NULL) {
        GDKerror("ll_descendant: could not allocate bitvector of size %d.\n", iters_on_stack_size);
        @:ll_fail_descendant@
    }
    memset(iters_on_stack, 0, iters_on_stack_size);

    iter_bun = BUNfirst(iter_bat);
    ctx_bun = BUNfirst(ctx_bat);
    ctx_last = BUNlast(ctx_bat);
    ctx = *(oid*)BUNtail(ctx_bati,ctx_bun);
    iter_idx = *(oid*)BUNtail(iter_bati,iter_bun) - min_iter;

@= sort_iters_on_stack
    for (j = 0 ; j < stack_top ; j++) {
        iters_on_stack[j] = stack[j].iter_idx + min_iter;
    }
    if (!no_iter_order && stack_top > 1) {
        qsort((void *) iters_on_stack, stack_top, sizeof(oid),
#if SIZEOF_SIZE_T == SIZEOF_INT
              (int (*)(const void *, const void *)) intCmp
#else
              (int (*)(const void *, const void *)) lngCmp
#endif
        );
    }
@
@= skip_cands_before_pre
        if (cand_bat) {
            if (pre <= lst_cnd) {
                if (cnd_ptr) {
                    /* poor man's binary search / exploiting forward scan */
                    while (cnd_ptr+1048576 <= cnd_lst && *(cnd_ptr+1048576) < pre)
                        cnd_ptr += 1048576; /* this avoids mmapped I/O */
                    while (cnd_ptr+32768 <= cnd_lst && *(cnd_ptr+32768) < pre)
                        cnd_ptr += 32768;
                    while (cnd_ptr+1024 <= cnd_lst && *(cnd_ptr+1024) < pre)
                        cnd_ptr += 1024;
                    while (cnd_ptr+32 <= cnd_lst && *(cnd_ptr+32) < pre)
                        cnd_ptr += 32;
                    while (*cnd_ptr < pre)
                        cnd_ptr++;
                    cnd = *cnd_ptr;
                } else {
                    if (cnd < pre) {
                        cnd = pre;
                    }
                }
            } else {
                cnd = GDK_oid_max;
            }
        } else {
            cnd = pre;
        }
@c

    /* iterate over all context nodes - evaluation is only done
       starting from the ctx (on the top of the stack) until
       the next ctx node (or the end of the stack top
       ctx node scope) is reached */
    while (ctx_bun < ctx_last && cnd <= lst_cnd) {
        oid cur_ctx = ctx;
        /* scan over all iters for the current ctx node;
           only a new (non-active) iters have to be added
           to the list of active iters */
        pre = ctx;
        @:skip_cands_before_pre@
        while (ctx_bun < ctx_last) {
            ctx = *(oid*)BUNtail(ctx_bati,ctx_bun);
            iter_idx = *(oid*)BUNtail(iter_bati,iter_bun) - min_iter;
            if (ctx != cur_ctx)
                    break;
            if (!onstack_get(iter_idx)) {
                si_D new_stack_item;
                new_stack_item.iter_idx = iter_idx;
                new_stack_item.eocs = ctx + size[ctx];
                stack[stack_top++] = new_stack_item;
                onstack_set(iter_idx);
                if (self) {
                    if (pre == cnd && ((kind == NULL) || (kind[pre] == kind_test))) {
                        oid iter = min_iter + iter_idx;
                        bunfastins(res, &iter, &pre);
                    }
                }
            }
            iter_bun++;
            ctx_bun++;
        }
        @:sort_iters_on_stack@
        pre++;
        if (ctx_bun < ctx_last) {
            if (ctx <= stack[stack_top-1].eocs) {
                /* find all results between the current ctx node
                   and the next (descendant) ctx node */
                @:inner_loop_descendant(ctx)@
                /* proceed with descendant ctx node */
            } else {
                /* successively finish all active scopes
                   that do not contain the next ctx node */
                while (stack_top && stack[stack_top-1].eocs <= ctx) {
                    @:finish_scope_descendant@
                }
                if (ctx <= stack[stack_top-1].eocs) {
                    @:inner_loop_descendant(ctx)@
                }
            }
        }
    }
    /* need to process the ctx nodes, which are still on the stack 
       - only need to evaluate the inner loop and pop, because 
         there are no more new ctx nodes */
    while (stack_top) {
        @:finish_scope_descendant@
    }

@= finish_scope_descendant
    oid eocs = stack[stack_top-1].eocs;
    /* find all results in the current scope */
    @:inner_loop_descendant(eocs)@
    /* back to enclosing scope: remove all iters that are done */
    while (stack_top && stack[stack_top-1].eocs <= eocs) {
        stack_top--;
        onstack_clr(stack[stack_top].iter_idx);
    }
    @:sort_iters_on_stack@
@
@= inner_loop_descendant
{
    BUN grow = 0;
    oid *sdst = NULL, *hdst, *tdst;

    @:skip_cands_before_pre@
    if (cnd <= @1) {
        grow = (BUN)stack_top * ((@1 - cnd) + 1);

        /* check, if result buffer is big enough; otherwise extend it */
        PFll_check_BAT_capacity(res, grow);
        
        /* iterate over all descendants until the next limit is reached
           (either descendant ctx node or end of scope)
           and insert their pre value into the results */
        sdst = (oid*)Hloc(res, BUNfirst(res));
        hdst = (oid*)Hloc(res, BUNlast(res));
        tdst = (oid*)Tloc(res, BUNlast(res));
        if (cand_bat) {
            oid *cur_pre = 0;
            oid lst_ctx = @1;
            oid *fst_pre = cnd_ptr;
            oid *lst_pre = (oid*)Tloc(cand_bat, BUNlast(cand_bat));
                            
            for (cur_pre = fst_pre ; cur_pre < lst_pre && *cur_pre <= lst_ctx; cur_pre++) {
                for (j = 0 ; j < stack_top ; j++ ) {
                    *hdst++ = iters_on_stack[j];
                    *tdst++ = *cur_pre;
                }
            }
        } else {
            for ( ; pre <= @1 ; pre++ ) {
                if ((kind && kind[pre] != kind_test) || (size[pre] & (1U<<31))) continue; 
                for (j = 0 ; j < stack_top ; j++ ) {
                    *hdst++ = iters_on_stack[j];
                    *tdst++ = pre;
                }
            }
        }
        BATsetcount(res, hdst-sdst);
    }
    
    pre = @1 + 1;
}
@
@c

    GDKfree(stack);
    for ( i=0; i<num_iters; i++ ) {
        if (onstack_get(i)) {
            GDKwarning("ll_descendant: iter %d still on stack !??\n", i + min_iter);
        }
    }
    GDKfree(onstack);
    GDKfree(iters_on_stack);
    
    *result = res;    
    return GDK_SUCCEED;
bunins_failed:
    GDKerror("ll_descendant: bunins failed.\n");
    @:ll_fail_descendant@
}

@= ll_fail_descendant
    if (stack) GDKfree(stack);
    if (onstack) GDKfree(onstack);
    if (iters_on_stack) GDKfree(iters_on_stack);
    *result = res;    
    return GDK_FAIL;
@

@c
/* vim:set shiftwidth=4 expandtab: */
