@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2007 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$

@f ll_staircasejoin
@a Stefan Manegold
@a Jan Rittinger
@t loop-lifted staircasejoin

@c

/**********************************************
* ll_staircasejoin.c : staircase join operators
*
*/

#include "pf_config.h"
#include <gdk.h>
#include "pathfinder.h"

#if 0
#define prefetch_loc(addr) \
/* Parameters */
const int PF_SOFTWARE_PREFETCH = 128;

/* software prefetching is not used currently */
  __asm__ __volatile__ ("prefetchnta %0" \
                        : \
                        : \
                        "m" (*(((char*)(size_t)(((unsigned int)(size_t)(addr))&~0x7f)))))
                            /* StM: extended casting to pacify 64-bit compilers */
#else
#define prefetch_loc(addr)
#endif

/* At some places, we are not sure, whether temporary intermediate results
 * (e.g., generated by BATmark or BATsort) are new BATs or just views;
 * hence, we use this wrapper to release the BATs/views properly.
 */
#define BBP_unfix_reclaim(b) \
{\
    if (BBP_refs((b)->batCacheid) > 1) {\
        /*printf("# %s, %s, %d, BBPunfix(%d=%s)\n",__FILE__, __func__, __LINE__,(b)->batCacheid,BATgetId(b));*/\
        BBPunfix((b)->batCacheid);\
    } else {\
        /*printf("# %s, %s, %d, BBPreclaim(%d=%s)\n",__FILE__, __func__, __LINE__,(b)->batCacheid,BATgetId(b));*/\
        BBPreclaim((b));\
    }\
}


/*******************************************************************/

/* DESCENDANT STEP */
@:ll_proto(descendant)@
@:ll_head(descendant)@
    self = FALSE;
    res_size = BATcount(iter_bat);	/* FIXME: estimate size! */
@:ll_main(descendant, (size[pre] & (1<<31)))@

/* DESCENDANT-OR-SELF STEP */
@:ll_head(descendant_or_self)@
    self = TRUE;
    res_size = BATcount(iter_bat);	/* FIXME: estimate size! */
@:ll_main(descendant, (size[pre] & (1<<31)))@

/* CHILD STEP */
@:ll_proto(child)@
@:ll_head(child)@
    trivial_cases = FALSE;
    res_size = BATcount(iter_bat);	/* FIXME: estimate size! */
@:ll_main(child, FALSE)@

/* Templates / Wrappers */

@= ll_proto
static int
ll_@1 (	BAT **res, BAT *iter_bat, BAT *ctx_bat, BAT *cand_bat, int *size,
	oid min_iter, oid max_iter, bit no_iter_order, bit self, chr* kind, chr kind_test);
@
@= ll_head
int
PFll_@1 (BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *pre_size, BAT *cand_bat,
	 bit *_one_iter, bit *_one_ctx,
	 oid *_min_iter, oid *_max_iter, bit *_no_iter_order, chr *_kind_test)
{
    /* --------------------------- declarations ---------------------------- */

    char *name = "PFll_@1";
    bit one_iter = *_one_iter;
    bit one_ctx  = *_one_ctx;
    oid min_iter = *_min_iter;
    oid max_iter = *_max_iter;
    bit no_iter_order = *_no_iter_order;
    bit self = FALSE;
    bit trivial_cases = TRUE;
    chr *kind = NULL, kind_test = *_kind_test;
    BAT *res = NULL;
    BAT *del = NULL;
    size_t res_size = 0;
    int *size;

    /* --------------------------- checks ---------------------------------- */

    BATcheck(iter_bat, name);
    BATcheck(ctx_bat, name);
    BATcheck(pre_size, name);
    BATcheck(cand_bat, name);

    if (!(BAThdense(iter_bat) && BAThdense(ctx_bat)))
    {
        GDKerror("%s: both iter_bat and ctx_bat must have a dense head.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if ((iter_bat->hseqbase != ctx_bat->hseqbase) || (BATcount(iter_bat) != BATcount(ctx_bat)))
    {
        GDKerror("%s: iter_bat and ctx_bat must be head-aligned, i.e., have equal head seqbases and length.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (!(BATtordered(ctx_bat) & 1))
    {
        GDKerror("%s: ctx_bat must be ordered on tail.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (one_ctx && !(BATtordered(iter_bat) & 1))
    {
        GDKerror("%s: iter_bat must be ordered on tail.\n", name);
        @:ll_return(GDK_FAIL)@
    }

    if (!BAThdense(pre_size))
    {
        GDKerror("%s: head of pre_size must be dense.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (pre_size->ttype != TYPE_int)
    {
        GDKerror("%s: tail of pre_size must be type INT.\n", name);
        @:ll_return(GDK_FAIL)@
    }
    if (BUNsize(pre_size) != sizeof(int))
    {
        GDKerror("%s: head (oid) of pre_size must NOT be materialized.\n", name);
        @:ll_return(GDK_FAIL)@
    }

    if (kind_test != chr_nil) {
        if ((cand_bat->ttype != TYPE_chr) ||                       /* it contains kinds */
            (BATcount(cand_bat) != BATcount(pre_size)) ||    /* is the entire pre table */
            (BUNsize(cand_bat) != sizeof(chr))) /* and a real void bat (i.e. chr array) */
        {
            GDKerror("%s: cand_bat with kind test must be a real kind bat.\n", name);
            @:ll_return(GDK_FAIL)@
        }
        kind = (chr*) BUNfirst(cand_bat);
        cand_bat = NULL;
    } else if (BATcount(cand_bat) == BATcount(pre_size)) {
        cand_bat = NULL; /* HACK: no selection */
    } else if (!(BATtordered(cand_bat) & 1)) {
        GDKerror("%s: cand_bat must be ordered on tail.\n", name);
        @:ll_return(GDK_FAIL)@
    } else if (cand_bat->ttype == TYPE_void) {
        /* rare case: an oid candidate-list that is void-dense.  materialize it */ 
        del = BATnew(TYPE_void, TYPE_oid, BATcount(cand_bat));
        if (del == NULL || (cand_bat->tseqbase != oid_nil && BATins(del, cand_bat, FALSE) == NULL)) 
            @:ll_return(GDK_FAIL)@
        cand_bat = del;
    }
    size = ((int*) BUNtloc(pre_size, BUNfirst(pre_size))) - (int)pre_size->hseqbase;

    /* --------------------------- empty result ---------------------------- */

    if (BATcount(iter_bat) == 0 || BATcount(pre_size) == 0 || (cand_bat && BATcount(cand_bat) == 0))
    {
        res = BATnew(TYPE_oid, TYPE_void, 0);
        BATkey (res, TRUE);
        res->hsorted = GDK_SORTED;
        res->hdense = TRUE;
        BATseqbase (res, (oid)0); /* does not really matter */
        BATkey (BATmirror(res), TRUE);
        res->tsorted = TRUE;
        res->tdense = TRUE;
        BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        BATset(res, TRUE);
        *result = res;
        @:ll_return(GDK_SUCCEED)@
    }
@

@= ll_main
    /* ---------------------------- main part ----------------------------- */
    /* 
     * @1: step name
     */
    
    if ( trivial_cases && one_ctx ) {

        /* ------------------------ trivial cases ------------------------- */

        oid fst_ctx = *(oid*)BUNtail(ctx_bat, BUNfirst(ctx_bat));
        oid lst_ctx = 0;
        BUN dst = 0;
        size_t max_size = 0;
        int bs_res = 0;

        assert((size[fst_ctx] & (1<<31)) == 0);
        max_size = res_size = (size_t)(size[fst_ctx] + (int)self);
        if ( cand_bat ) {
            if ( BATcount(cand_bat) < res_size ) {
                res_size = BATcount(cand_bat);
            }
        }
        res_size *= BATcount(iter_bat);
        res = BATnew(TYPE_oid, TYPE_oid, res_size);
        if (res == NULL) 
        { 
            GDKerror("%s: could not allocate a result BAT[oid,void] of size " SZFMT ".\n", name, res_size);
            @:ll_return(GDK_FAIL)@
        }
        res_size /= BATcount(iter_bat);
        fst_ctx = fst_ctx + (oid)(1 - (int)self);
        lst_ctx = fst_ctx + (oid)max_size;
        dst = BUNlast(res);
        assert(!res->hloc);
        bs_res = BUNsize(res);
        if ( cand_bat ) {
            BUN cand = 0;
            int bs_cand_bat = BUNsize(cand_bat);
            BUN fst_cand = BUNtloc(cand_bat, SORTfndfirst_oid(cand_bat, &fst_ctx));
            BUN lst_cand = BUNtloc(cand_bat, BUNlast(cand_bat));
                
            if ( one_iter ) {
                oid iter = *(oid*)BUNtail(iter_bat, BUNfirst(iter_bat));

                for (cand = fst_cand ; cand < lst_cand && *(oid*)cand < lst_ctx; cand += bs_cand_bat ) {
                    *(oid*)dst              = iter;
                    *(oid*)(dst+SIZEOF_OID) = *(oid*)cand;
                    dst += bs_res;
                }
            } else 
            {   /* multiple iters */
                BUN iter = 0;
                int bs_iter_bat = BUNsize(iter_bat);
                BUN fst_iter = BUNfirst(iter_bat);
                BUN lst_iter = BUNlast(iter_bat);
                    
                for (cand = fst_cand ; cand < lst_cand && *(oid*)cand < lst_ctx; cand += bs_cand_bat ) {
                    for (iter = fst_iter ; iter < lst_iter; iter += bs_iter_bat ) {
                        *(oid*)dst              = *(oid*)BUNtail(iter_bat,iter);
                        *(oid*)(dst+SIZEOF_OID) = *(oid*)cand;
                        dst += bs_res;
                    }
                }
            }
        } else 
        {   /* !cands */ 
            oid pre = 0;
            
            if ( one_iter ) {
                oid iter = *(oid*)BUNtail(iter_bat, BUNfirst(iter_bat));

                for (pre = fst_ctx ; pre < lst_ctx ; pre++ ) {
                    if ((kind && kind[pre] != kind_test) || @2) continue; 
                    *(oid*)dst              = iter;
                    *(oid*)(dst+SIZEOF_OID) = pre;
                    dst += bs_res;
                }
            } else 
            {   /* multiple iters */
                BUN iter = 0;
                int bs_iter_bat = BUNsize(iter_bat);
                BUN fst_iter = BUNfirst(iter_bat);
                BUN lst_iter = BUNlast(iter_bat);
                
                for (pre = fst_ctx ; pre < lst_ctx ; pre++ ) {
                    if ((kind && kind[pre] != kind_test) || @2) continue; 
                    for (iter = fst_iter ; iter < lst_iter; iter += bs_iter_bat ) {
                        *(oid*)dst              = *(oid*)BUNtail(iter_bat,iter);
                        *(oid*)(dst+SIZEOF_OID) = pre;
                        dst += bs_res;
                    }
                }
            }
        }
        res->batBuns->free = dst - res->batBuns->base;
        BATsetcount(res, (res->batBuns->free+Bunbase(res)-BUNfirst(res))/BUNsize(res));
    } else
    /* !(trivial_cases && one_ctx) */ {

        /* ------------------------ general cases ------------------------- */

        /* --- result bat allocation. for result size use res_size parameter --- */
        res = BATnew(TYPE_oid, TYPE_oid, res_size);
        if (res == NULL) 
        { 
            GDKerror("%s: could not allocate a result BAT[oid,oid] of size " SZFMT ".\n", name, res_size);
            @:ll_return(GDK_FAIL)@
        }

        if (ll_@1(&res, iter_bat, ctx_bat, cand_bat, size, 
                  min_iter, max_iter, no_iter_order, self, kind, kind_test) == GDK_FAIL )
        {
            @:ll_return(GDK_FAIL)@
        }
    }

    /* -------------------- set result properties ---------------------- */
{
    bit trivial  = (BATcount(res) < 2);
    oid fst_item = *(oid*)BUNtail(res, BUNfirst(res));
    oid lst_item = *(oid*)BUNtail(res, BUNlast(res) - BUNsize(res));
    bit one_item = (fst_item == lst_item);

    res->batDirty = TRUE;
    res->hdense = (trivial||(res->htype==TYPE_void)); /* might be TRUE in some more cases... */
    if (res->hdense) {
        if (BATcount(res) == 0) {
            BATseqbase (res, (oid)0); /* does not really matter */
        } else {
            BATseqbase (res, *(oid*)BUNhead(res, BUNfirst(res)));
        }
    }
    res->hsorted = ((one_iter||one_item) ? GDK_SORTED : 0); /* might be TRUE in some more cases... */
    BATkey(res,(res->hdense||one_item)); /* might be TRUE in some more cases... */
    res->tdense = (trivial||(res->ttype==TYPE_void)); /* might be TRUE in some more cases... */
    if (res->tdense) {
        if (BATcount(res) == 0) {
            BATseqbase (BATmirror(res), (oid)0); /* does not really matter */
        } else {
            BATseqbase (BATmirror(res), *(oid*)BUNtail(res, BUNfirst(res)));
        }
    }
    res->tsorted = GDK_SORTED;
    BATkey(BATmirror(res),(res->tdense||one_iter)); /* might be TRUE in some more cases... */
    BATset(res, TRUE);
}
    *result = res;

    @:ll_return(GDK_SUCCEED)@
}
@

@= ll_return
{   if (del) BBPreclaim(del);
    if (res && (@1 == GDK_FAIL))
        BBP_unfix_reclaim(res);
    return @1; }
@c

/* ============================== Tools =================================== */

#define PFll_check_BAT_capacity(b,grow) \
{\
        size_t _oldcap = BATbuncount(b);\
        size_t _reqcap = BATcount(b) + grow;\
        size_t _bunsize = BUNsize(b);\
        if (_oldcap < _reqcap) {\
            size_t _newcap = MAX(_reqcap, BATgrows(b));\
            if (BATextend((b), _newcap) == NULL) {\
                GDKerror("%s: BATextend of BAT '%s' (#%d) failed "\
                         "for " SZFMT " buns (" SZFMT " bytes).\n",\
                         __func__, BATgetId(b), (b)->batCacheid,\
                         _newcap, _newcap * _bunsize);\
                goto bunins_failed;\
            }\
            _newcap = BATbuncount(b);\
            if (_newcap < _reqcap) {\
                GDKerror("%s: BATextend of BAT '%s' (#%d) failed: "\
                         "required " SZFMT " buns (" SZFMT " bytes), "\
                         "got only " SZFMT " buns (" SZFMT " bytes).\n",\
                         __func__, BATgetId(b), (b)->batCacheid,\
                         _reqcap, _reqcap * _bunsize,\
                         _newcap, _newcap * _bunsize);\
                goto bunins_failed;\
            }\
        }\
}

/* ============================== Step implementations ==================== */

/* ------------------------------ Child ----------------------------------- */

typedef struct stack_item_C si_C;

struct stack_item_C {
    oid eocs;           /* end of ctx scope (pre + size) */
    oid next_child;     /* preorder rank of the next child node */
    BUN first;          /* first iter row of the actual ctx node */
    BUN last;           /* last iter row of the actual ctx node */
};

static int
ll_child ( BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *cand_bat, int* size,
             oid min_iter, oid max_iter, bit no_iter_order, bit self, chr *kind, chr kind_test)
{
    BAT *res = *result;
    si_C *stack = 0;
    int stack_top = 0, ctx_bunsize = 0, iter_bunsize = 0;
    oid pre = 0, ctx = 0, cur_ctx = 0;
    BUN cur_bun = 0, iter_bun = 0, ctx_bun = 0, ctx_last = 0;
    BUN cand_cur = cand_bat?BUNtloc(cand_bat,BUNfirst(cand_bat)):NULL;
    BUN cand_lst = cand_bat?BUNtloc(cand_bat,BUNlast(cand_bat)-BUNsize(cand_bat)):NULL;

    /* not used, here; keep compilers happy */
    (void)min_iter;
    (void)max_iter;
    (void)no_iter_order;
    (void)self;

    /* stack for context set nodes will never grow over height of doc. tree */
    stack = (si_C*)GDKmalloc(sizeof(si_C) * (XML_DEPTH_MAX + 1));
    if (stack == NULL) {
        GDKerror("ll_child: could not allocate stack of size %d.\n", sizeof(si_C) * (XML_DEPTH_MAX + 1));
        return GDK_FAIL;
    }
    stack_top = 0;


    iter_bunsize = BUNsize(iter_bat);
    ctx_bunsize = BUNsize(ctx_bat);

    iter_bun = BUNfirst(iter_bat);
    ctx_bun = BUNfirst(ctx_bat);
    ctx_last = BUNlast(ctx_bat);
    ctx = *(oid*)BUNtail(ctx_bat,ctx_bun);

@= getnextctx
    iter_bun += iter_bunsize;
    ctx_bun += ctx_bunsize;
    ctx = *(oid*)BUNtail(ctx_bat,ctx_bun);
@
@= pushctx
    si_C new_stack_item;
    new_stack_item.eocs = ctx + size[ctx];
    new_stack_item.next_child = ctx + 1;
    new_stack_item.first = iter_bun;
    new_stack_item.last = iter_bun;
    stack[stack_top++] = new_stack_item;
    cur_ctx = ctx;
@
@= popctx
    stack_top--;
@
@c

    /* iterate over all context nodes - evaluation is only done
       starting from the ctx (on the top of the stack) until
       the next ctx node (or the end of the stack top
       ctx node scope) is reached */
    while (ctx_bun < ctx_last && cand_cur <= cand_lst) {
        /* if the stack is empty the next ctx node
           has to be pushed on the stack 
           and the next ctx node is called*/
        if (!stack_top) {
            @:pushctx@
            @:getnextctx@
        }
        /* only a new iter has to be added
           to the list of active iters */
        else if (cur_ctx == ctx) {
            stack[stack_top-1].last = iter_bun;
            @:getnextctx@
        }
        /* evaluates the ctx node on top of the stack
           until a descendant is reached. The descendant is then
           pushed on the stack and is the new active ctx */
        else if (stack[stack_top-1].eocs >= ctx) {
            @:inner_loop_child(ctx)@
            stack[stack_top-1].next_child = pre;
            @:pushctx@
            @:getnextctx@
        }
        /* evaluates the ctx node on top of the stack
           until the end of its scope is reached. Then the
           node is popped and the next cycle is called with
           the same ctx node to first activate older nodes
           on the stack */
        else {
            @:inner_loop_child(stack[stack_top-1].eocs)@
            @:popctx@
        }
    }
    /* need to process the ctx nodes, which are still on the stack 
       - only need to evaluate the inner loop and pop, because 
         there are no more new ctx nodes */
    while (stack_top) {
        @:inner_loop_child(stack[stack_top-1].eocs)@
        @:popctx@
    }

@= inner_loop_child
    pre = stack[stack_top-1].next_child;
    /* iterates over all childs until the next limit is reached
       (either descendant ctx node or end of scope) and prunes
       all subtree which can't hold any matches */
    if (cand_bat) {
        if (cand_cur <= cand_lst) {
            BUN fst_pre = cand_cur;
            oid lst_pre = MIN(@1, *(oid*)cand_lst);

            for (; pre <= @1 && pre <  *(oid*)fst_pre; pre += (size[pre]&GDK_int_max) + 1) { 
            }
            for (;              pre <=        lst_pre; pre += (size[pre]&GDK_int_max) + 1)
              if ((size[pre] & (1<<31)) == 0) {

                /* poor man's binary search / exploiting forward scan */
                while (fst_pre+1048576 <= cand_lst && *(oid*) (fst_pre+1048576) < pre)
                    fst_pre += 1048576; /* this avoids mmapped I/O */
                while (fst_pre+32768 <= cand_lst && *(oid*) (fst_pre+32768) < pre)
                    fst_pre += 32768;
                while (fst_pre+1024 <= cand_lst && *(oid*) (fst_pre+1024) < pre)
                    fst_pre += 1024;
                while (fst_pre+32 <= cand_lst && *(oid*) (fst_pre+32) < pre)
                    fst_pre += 32;
                while (fst_pre <= cand_lst && *(oid*)fst_pre < pre)
                    fst_pre += BUNsize(cand_bat);
                if (fst_pre <= cand_lst && *(oid*)fst_pre == pre) {
                        @:inner_loop_child_body@
                        fst_pre += BUNsize(cand_bat);
                }
            }
            cand_cur = fst_pre;
        }
        for (; pre <= @1; pre += (size[pre]&GDK_int_max) + 1) {
        }
    } else if (kind) {
        for (; pre <= @1; pre += (size[pre]&GDK_int_max) + 1) {
            if ((size[pre] & (1<<31)) == 0 && kind[pre] == kind_test) {
                @:inner_loop_child_body@
            }
        }
    } else {
        for (; pre <= @1; pre += (size[pre]&GDK_int_max) + 1) {
            if ((size[pre] & (1<<31)) == 0) {
                @:inner_loop_child_body@
            }
        }
    }
@
@= inner_loop_child_body
        size_t grow = ((stack[stack_top-1].last - stack[stack_top-1].first) / iter_bunsize) + 1;
        BUN dst = NULL;
        int bunsize = BUNsize(res);

        /* check, if result buffer is big enough; otherwise extend it */
        PFll_check_BAT_capacity(res, grow);
        /* creates a row for every iter, whose ctx node produced
           a match */
        dst = BUNlast(res);
        assert(!res->hloc);
        for (cur_bun = stack[stack_top-1].first;
             cur_bun <= stack[stack_top-1].last;
             cur_bun += iter_bunsize) {
            *(oid*)dst              = *(oid*)BUNtail(iter_bat,cur_bun);
            *(oid*)(dst+SIZEOF_OID) = pre;
            dst += bunsize;
        }
        res->batBuns->free = dst - res->batBuns->base;
        BATsetcount(res, (res->batBuns->free+Bunbase(res)-BUNfirst(res))/bunsize);
@
@c

    GDKfree(stack);
    *result = res;    
    return GDK_SUCCEED;
bunins_failed:
    GDKfree(stack);
    GDKerror("ll_child: bunins failed.\n");
    *result = res;    
    return GDK_FAIL;
}


/* ------------------------------ Descendant ------------------------------ */

typedef struct stack_item_D si_D;

struct stack_item_D {
    oid iter_idx;       /* index of iter */
    oid eocs;           /* end of ctx scope (pre + size) */
};

#define OST unsigned long long		/* type for "onstack" bitvector: "lng" or "chr" */

#define onstack_set(b)	 onstack[(b)>>OST_shift] |=   ((OST)1)<<((b)&OST_mask) 
#define onstack_clr(b)	 onstack[(b)>>OST_shift] &= ~(((OST)1)<<((b)&OST_mask))
#define onstack_get(b)	(onstack[(b)>>OST_shift] &   (((OST)1)<<((b)&OST_mask)))

static int
ll_descendant ( BAT **result, BAT *iter_bat, BAT *ctx_bat, BAT *cand_bat, int* size,
                oid min_iter, oid max_iter, bit no_iter_order, bit self, chr* kind, chr kind_test)
{
    BAT *res = *result;
    int bs_res = BUNsize(res);
    si_D *stack = 0;
    OST *onstack = 0;
    oid *iters_on_stack = 0;
    int stack_size = 0, onstack_size = 0, iters_on_stack_size = 0, j = 0;
    int stack_top = 0, ctx_bunsize = 0, iter_bunsize = 0, bs_cnd = 0;
    oid pre = 0, ctx = 0, iter_idx = 0, cnd = 0, lst_cnd = GDK_oid_max;
    BUN iter_bun = 0, ctx_bun = 0, ctx_last = 0, cnd_bun = 0;
    oid num_iters = (max_iter - min_iter) + 1, i;
    int OST_bytes = sizeof(OST);
    int OST_bits  = OST_bytes * 8;
    int OST_mask  = OST_bits - 1;
    int OST_shift = 0;
    
    if (cand_bat) {
        bs_cnd  = BUNsize(cand_bat);
        cnd_bun = BUNtloc(cand_bat, BUNfirst(cand_bat));
        cnd     = *(oid*)cnd_bun;
        lst_cnd = *(oid*)BUNtloc(cand_bat, BUNlast(cand_bat) - bs_cnd);
    }

    for (i=OST_mask; i; i>>=1) OST_shift++;

    /* stack for context set nodes will never grow over number of iters */
    stack_size = sizeof(si_D) * num_iters;
    stack = (si_D*)GDKmalloc(stack_size);
    if (stack == NULL) {
        GDKerror("ll_descendant: could not allocate stack of size %d.\n", stack_size);
        @:ll_fail_descendant@
    }
    stack_top = 0;

    /* bitvector to maintain which iters are currently on the stack */
    onstack_size = OST_bytes * ((num_iters >> OST_shift) + 1);
    onstack = (OST*)GDKmalloc(onstack_size);
    if (onstack == NULL) {
        GDKerror("ll_descendant: could not allocate bitvector of size %d.\n", onstack_size);
        @:ll_fail_descendant@
    }
    memset(onstack, 0, onstack_size);

    /* sorted list of all iters that are currently on the stack */
    iters_on_stack_size = sizeof(oid) * num_iters;
    iters_on_stack = (oid*)GDKmalloc(iters_on_stack_size);
    if (iters_on_stack == NULL) {
        GDKerror("ll_descendant: could not allocate bitvector of size %d.\n", iters_on_stack_size);
        @:ll_fail_descendant@
    }
    memset(iters_on_stack, 0, iters_on_stack_size);

    iter_bunsize = BUNsize(iter_bat);
    ctx_bunsize = BUNsize(ctx_bat);

    iter_bun = BUNfirst(iter_bat);
    ctx_bun = BUNfirst(ctx_bat);
    ctx_last = BUNlast(ctx_bat);
    ctx = *(oid*)BUNtail(ctx_bat,ctx_bun);
    iter_idx = *(oid*)BUNtail(iter_bat,iter_bun) - min_iter;

@= getnextctx_D
    iter_bun += iter_bunsize;
    ctx_bun += ctx_bunsize;
    ctx = *(oid*)BUNtail(ctx_bat,ctx_bun);
    iter_idx = *(oid*)BUNtail(iter_bat,iter_bun) - min_iter;
@
@= pushctx_D
    if (!onstack_get(iter_idx)) {
        si_D new_stack_item;
        new_stack_item.iter_idx = iter_idx;
        new_stack_item.eocs = ctx + size[ctx];
        stack[stack_top++] = new_stack_item;
        onstack_set(iter_idx);
        if (self) {
            if (pre == cnd && ((kind == NULL) || (kind[pre] == kind_test))) {
                oid iter = min_iter + iter_idx;
                bunfastins(res, &iter, &pre);
            }
        }
    }
@
@= popctx_D
    stack_top--;
    onstack_clr(stack[stack_top].iter_idx);
@
@= sort_iters_on_stack
    for (j = 0 ; j < stack_top ; j++) {
        iters_on_stack[j] = stack[j].iter_idx + min_iter;
    }
    if (!no_iter_order && stack_top > 1) {
        qsort((void *) iters_on_stack, stack_top, sizeof(oid),
#if SIZEOF_SIZE_T == SIZEOF_INT
              (int (*)(const void *, const void *)) intCmp
#else
              (int (*)(const void *, const void *)) lngCmp
#endif
        );
    }
@
@= skip_cands_before_pre
        if (cand_bat) {
            if (pre <= lst_cnd) {
                if (cnd_bun) {
                    while (cnd < pre) {
                        cnd_bun += bs_cnd;
                        cnd = *(oid*)cnd_bun;
                    }
                } else {
                    if (cnd < pre) {
                        cnd = pre;
                    }
                }
            } else {
                cnd = GDK_oid_max;
            }
        } else {
            cnd = pre;
        }
@c

    /* iterate over all context nodes - evaluation is only done
       starting from the ctx (on the top of the stack) until
       the next ctx node (or the end of the stack top
       ctx node scope) is reached */
    while (ctx_bun < ctx_last && cnd <= lst_cnd) {
        oid cur_ctx = ctx;
        /* scan over all iters for the current ctx node;
           only a new (non-active) iters have to be added
           to the list of active iters */
        pre = ctx;
        @:skip_cands_before_pre@
        while (ctx_bun < ctx_last && ctx == cur_ctx) {
            @:pushctx_D@
            @:getnextctx_D@
        }
        @:sort_iters_on_stack@
        pre++;
        if (ctx_bun < ctx_last) {
            if (ctx <= stack[stack_top-1].eocs) {
                /* find all results between the current ctx node
                   and the next (descendant) ctx node */
                @:inner_loop_descendant(ctx)@
                /* proceed with descendant ctx node */
            } else {
                /* successively finish all active scopes
                   that do not contain the next ctx node */
                while (stack_top && stack[stack_top-1].eocs <= ctx) {
                    @:finish_scope_descendant@
                }
                if (ctx <= stack[stack_top-1].eocs) {
                    @:inner_loop_descendant(ctx)@
                }
            }
        }
    }
    /* need to process the ctx nodes, which are still on the stack 
       - only need to evaluate the inner loop and pop, because 
         there are no more new ctx nodes */
    while (stack_top) {
        @:finish_scope_descendant@
    }

@= finish_scope_descendant
    oid eocs = stack[stack_top-1].eocs;
    /* find all results in the current scope */
    @:inner_loop_descendant(eocs)@
    /* back to enclosing scope: remove all iters that are done */
    while (stack_top && stack[stack_top-1].eocs <= eocs) {
        @:popctx_D@
    }
    @:sort_iters_on_stack@
@
@= inner_loop_descendant
{
    size_t grow = 0;
    BUN dst = NULL;

    @:skip_cands_before_pre@
    if (cnd <= @1) {
        grow = (size_t)stack_top * ((@1 - cnd) + 1);

        /* check, if result buffer is big enough; otherwise extend it */
        PFll_check_BAT_capacity(res, grow);
        
        /* iterate over all descendants until the next limit is reached
           (either descendant ctx node or end of scope)
           and insert their pre value into the results */
        dst = BUNlast(res);
        assert(!res->hloc);
        if (cand_bat) {
            BUN cur_pre = 0;
            oid lst_ctx = @1;
            BUN fst_pre = cnd_bun;
            BUN lst_pre = BUNtloc(cand_bat, BUNlast(cand_bat));
                            
            for (cur_pre = fst_pre ; cur_pre < lst_pre && *(oid*)cur_pre <= lst_ctx; cur_pre += bs_cnd ) {
                for (j = 0 ; j < stack_top ; j++ ) {
                    *(oid*)dst              = iters_on_stack[j];
                    *(oid*)(dst+SIZEOF_OID) = *(oid*)cur_pre;
                    dst += bs_res;
                }
            }
        } else {
            for ( ; pre <= @1 ; pre++ ) {
                if ((kind && kind[pre] != kind_test) || (size[pre] & (1<<31))) continue; 
                for (j = 0 ; j < stack_top ; j++ ) {
                    *(oid*)dst              = iters_on_stack[j];
                    *(oid*)(dst+SIZEOF_OID) = pre;
                    dst += bs_res;
                }
            }
        }
        res->batBuns->free = dst - res->batBuns->base;
        BATsetcount(res, (res->batBuns->free+Bunbase(res)-BUNfirst(res))/bs_res);
    }
    
    pre = @1 + 1;
}
@
@c

    GDKfree(stack);
    for ( i=0; i<num_iters; i++ ) {
        if (onstack_get(i)) {
            GDKwarning("ll_descendant: iter %d still on stack !??\n", i + min_iter);
        }
    }
    GDKfree(onstack);
    GDKfree(iters_on_stack);
    
    *result = res;    
    return GDK_SUCCEED;
bunins_failed:
    GDKerror("ll_descendant: bunins failed.\n");
    @:ll_fail_descendant@
}

@= ll_fail_descendant
    if (stack) GDKfree(stack);
    if (onstack) GDKfree(onstack);
    if (iters_on_stack) GDKfree(iters_on_stack);
    *result = res;    
    return GDK_FAIL;
@

@c
/* vim:set shiftwidth=4 expandtab: */
