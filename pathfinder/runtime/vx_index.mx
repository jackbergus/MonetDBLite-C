@/
Copyright Notice:
-----------------

The contents of this file are subject to the Pathfinder Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License.  You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
the License for the specific language governing rights and limitations
under the License.

The Original Code is the Pathfinder system.

The Original Code has initially been developed by the Database &
Information Systems Group at the University of Konstanz, Germany and
the Database Group at the Technische Universitaet Muenchen, Germany.
It is now maintained by the Database Systems Group at the Eberhard
Karls Universitaet Tuebingen, Germany.  Portions created by the
University of Konstanz, the Technische Universitaet Muenchen, and the
Universitaet Tuebingen are Copyright (C) 2000-2005 University of
Konstanz, (C) 2005-2008 Technische Universitaet Muenchen, and (C)
2008-2011 Eberhard Karls Universitaet Tuebingen, respectively.  All
Rights Reserved.
@
@f vx_index
@a Lefteris Sidirourgos, Peter Boncz
@t Single-pass XML Value Index Construction and Update

@* XML value index support
We construct two updatable XML value indices, one supporting equi-lookup
queries for string values, and one supporting range queries on double values,
(aka numerics). Both indeces are build over the data associated to each element
node. We do not support in for the time being attribute values, or
attribute/element tags.

@+ Text Hash Functions
@- Hash function H()
@- Combine function C()

@c
#include "monetdb_config.h"
#include <gdk.h>
#include "shredder.h"   /* for XML_DEPTH_MAX */
#include "ll_upwards.h" /* SKIPHOLES, speculate_skip, PF_SIBLING_PROBES */

#define XQH_UNSGN(v)  ((unsigned int) v)
#define XQH_MASK5(c)  ((c) & 31)
#define XQH_MASK7(c)  ((c) & 127)
#define XQH_MASK27(c) ((c) & (~31))
#define XQH_SHFT_l(v,o) (v << (o))
#define XQH_SHFT_r(v,o) (XQH_UNSGN(v) >> (27-o))
#define XQH_CLC_SHFT(v,o) ((v << o) | (XQH_MASK27(XQH_UNSGN(v) >> (27-o))))

/* hash function H */
static INLINE int XQH_H(str v) {
    int c;
    int h_val = 0, ofs = 0;

    for (; *v != '\0'; v++){
        c = XQH_MASK7(*v);
        /* circular_XOR operation */
        h_val ^= XQH_SHFT_l(c,ofs);
        if (ofs > 20) {
            h_val ^= XQH_SHFT_r(c,ofs);
        }
        /* update offset *//* or if ofs>21 then ofs-=22 else ofs+=5 */
        ofs = ofs+5;
        if (ofs > 26) {
            ofs -= 27;
        }
    }
    h_val <<= 5;
    return (h_val |= ofs);
}

/* wrapper for mil command xquery_hash */
int CMD_XQH_H(int *res, str v) {
    *res = XQH_H(v);
    return GDK_SUCCEED;
}

/* wrapper for mil command [xquery_hash] */
int CMD_XQH_H_bat(BAT **res, BAT* b) {
    size_t i = 0, cnt = BATcount(b);
    BAT *bn = *res = BATnew(TYPE_void, TYPE_int, cnt);
    char *base = (char*) b->T->vheap->base;
    if (bn) {
        var_t *src = (var_t*) Tloc(b, BUNfirst(b));
        int *dst = (int*) Tloc(bn, BUNfirst(bn));
        for(i=0; i<cnt; i++)
            dst[i] =  XQH_H(base + VarHeapVal(src, i, b->T->width));

        ALIGNsetH(bn, b);
        BATsetcount(bn, cnt);
        bn->tsorted = 0;
        return GDK_SUCCEED;
    }
    return GDK_FAIL;
}

/* Combine function C */
static INLINE int XQH_C(int l, int r) {
    int h_comb = 0;
    int ofs = 0;

    h_comb |= XQH_MASK27(l);  /* copy the left operand */
    /* XOR the right operand after applying a circular shift */
    h_comb ^= XQH_CLC_SHFT(XQH_MASK27(r),XQH_MASK5(l));
    ofs = XQH_MASK5(l)+XQH_MASK5(r);
    if (ofs > 26) {
        ofs -= 27;
    }
    h_comb |= ofs;            /* combine offsets       */

    return h_comb;
}

/* wrapper for mil command xquery_combine */
int CMD_XQH_C(int *res, int *l, int *r) {
    *res = XQH_C(*l, *r);
    return GDK_SUCCEED;
}

/* wrapper for mil command [xquery_combine] */
int CMD_XQH_C_bat(BAT **res, BAT *l, BAT *r) {
    if (ALIGNsynced(l, r)) {
        size_t i = 0, cnt = BATcount(l);
        BAT *bn = *res = BATnew(TYPE_void, TYPE_int, cnt);
        int *lval;
        int *rval;
        int *dst;

        if (bn == NULL) return GDK_FAIL;

        lval = (int*) Tloc(bn, BUNfirst(l));
        rval = (int*) Tloc(bn, BUNfirst(r));
        dst  = (int*) Tloc(bn, BUNfirst(bn));

        for(i=0; i<cnt; i++)
            dst[i] = XQH_C(lval[i], rval[i]);

        ALIGNsetH(bn, l);
        BATsetcount(bn, cnt);
        bn->tsorted = 0;
        return GDK_SUCCEED;
    }
    GDKerror("xquery_combine: (%s,%s): not synced on head.\n",
            BATgetId(l), BATgetId(r));
    return GDK_FAIL;
}

/* debug function for the xquery string hash index */
int CMD_XQH_STR(str *res, int *val) {
    char *p = *res = (char*) GDKmalloc(128);
    int v = *val;
    int i;
    if (p == NULL) return GDK_FAIL;

    /* print c-array */
    for (i = 31; i >= 5; i--) {
        *p++ = '1' - !(v & (1 << i));
    }
    *p++ = '-';

    /* print offset */
    for (i = 4; i >= 0; i--) {
        *p++ = '1' - !(v & (1 << i));
    }

    *p = 0;
    return GDK_SUCCEED;
}

@+ XML Double Type Functions
@- Double Finite State Machine (DFSM)
@- State Transition Table (STT)

@= consume_digits
    /* consume all digits */
    for (; (*@1 != '\0') && isdigit(*@1); @1++);

@= consume_spaces
    /* consume all white spaces */
    for (; (*@1 != '\0') && isspace(*@1); @1++);

@c
/* all possible states of a bbl value, not including -/+ INF */
enum dblstates
{ rej, digit, dot, s5, s6, s7, s8, s9, s10, e, s1, s2, s3, s4,
  minus = 14, /* minus    + (digit, dot, s5, s6, s7, s8, s9, s10) */
  plus  = 23, /* plus     + (digit, dot, s5, s6, s7, s8, s9, s10) */
  ws    = 32, /* ws       + (digit, dot, s5, s6, s7, s8, s9, s10) */
  s11   = 41, /* wsplus   + (digit, dot, s5, s6, s7, s8, s9, s10) */
  s12   = 50, /* wsminus  + (digit, dot, s5, s6, s7, s8, s9, s10) */
  unseen= 59
};  /* 60 states in total */

/* state transition table */
static unsigned char STT[60][59] = {
/* rej */
{rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* digit */
{rej, digit, dot, s3, s4, s5, s6, s1, s2, s3, s4, s5, s6, s2, s3, s4, s5, s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* dot */
{rej, s1, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s1 */
{rej, s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s2 */
{rej, s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s3 */
{rej, s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, e, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s4 */
{rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, e, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s5 */
{rej, s1, rej, s3, s4, s5, s6, rej, rej, rej, rej, rej, rej, s2, s3, s4, s5, s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s6 */
{rej, s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s4, s5, rej, rej, rej, rej, rej, rej, rej, s3, s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s7 */
{rej, s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s8 */
{rej, s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s9 */
{rej, s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s10 */
{rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* e */
{rej, s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s9, s10, rej, rej, rej, rej, rej, rej, rej, s8, s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s1 */
{rej, s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s2 */
{rej, s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s3 */
{rej, s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, e, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s4 */
{rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, e, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* minus */
{rej, s2, s3, rej, rej, rej, rej, s4, minus, minus + digit, minus + dot, minus + s5, minus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* minus + digit */
{rej, s2, s3, minus + digit, minus + dot, minus + s5, minus + s6, s4, minus, minus + digit, minus + dot, minus + s5, minus + s6, minus, minus + digit, minus + dot, minus + s5, minus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, minus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* minus + dot */
{rej, s4, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* minus + s5 */
{rej, s4, rej, minus + digit, minus + dot, minus + s5, minus + s6, rej, rej, rej, rej, rej, rej, minus, minus + digit, minus + dot, minus + s5, minus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, minus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* minus + s6 */
{rej, minus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, minus + dot, minus + s5, rej, rej, rej, rej, rej, rej, rej, minus + digit, minus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* minus + s7 */
{rej, minus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* minus + s8 */
{rej, minus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* minus + s9 */
{rej, minus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, minus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* minus + s10 */
{rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, minus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* plus */
{rej, minus + s8, minus + s9, rej, rej, rej, rej, minus + s10, plus, plus + digit, plus + dot, plus + s5, plus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* plus + digit */
{rej, minus + s8, minus + s9, plus + digit, plus + dot, plus + s5, plus + s6, minus + s10, plus, plus + digit, plus + dot, plus + s5, plus + s6, plus, plus + digit, plus + dot, plus + s5, plus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, plus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* plus + dot */
{rej, minus + s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* plus + s5 */
{rej, minus + s10, rej, plus + digit, plus + dot, plus + s5, plus + s6, rej, rej, rej, rej, rej, rej, plus, plus + digit, plus + dot, plus + s5, plus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, plus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* plus + s6 */
{rej, plus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, plus + dot, plus + s5, rej, rej, rej, rej, rej, rej, rej, plus + digit, plus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* plus + s7 */
{rej, plus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* plus + s8 */
{rej, plus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* plus + s9 */
{rej, plus + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, plus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* plus + s10 */
{rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, plus + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* ws */
{rej, plus + s8, plus + s9, rej, rej, rej, rej, plus + s10, ws, ws + digit, ws + dot, ws + s5, ws + s6, rej, rej, rej, rej, rej, s11 + s7, s11 + s8, s11 + s9, s11 + s10, s12, s12 + digit, s12 + dot, s12 + s5, s12 + s6, ws + s7, ws + s8, ws + s9, ws + s10, s11, s11 + digit, s11 + dot, s11 + s5, s11 + s6, plus + s7, plus + s8, plus + s9, plus + s10, ws, ws + digit, ws + dot, ws + s5, ws + s6, ws + s7, ws + s8, ws + s9, ws + s10, s11, s11 + digit, s11 + dot, s11 + s5, s11 + s6, s11 + s7, s11 + s8, s11 + s9, s11 + s10, s12},
/* ws + digit */
{rej, plus + s8, plus + s9, ws + digit, ws + dot, ws + s5, ws + s6, plus + s10, ws, ws + digit, ws + dot, ws + s5, ws + s6, ws, ws + digit, ws + dot, ws + s5, ws + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, ws + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* ws + dot */
{rej, plus + s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* ws + s5 */
{rej, plus + s10, rej, ws + digit, ws + dot, ws + s5, ws + s6, rej, rej, rej, rej, rej, rej, ws, ws + digit, ws + dot, ws + s5, ws + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, ws + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* ws + s6 */
{rej, ws + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, ws + dot, ws + s5, rej, rej, rej, rej, rej, rej, rej, ws + digit, ws + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* ws + s7 */
{rej, ws + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* ws + s8 */
{rej, ws + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* ws + s9 */
{rej, ws + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, ws + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* ws + s10 */
{rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, ws + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s11 */
{rej, ws + s8, ws + s9, rej, rej, rej, rej, ws + s10, s11, s11 + digit, s11 + dot, s11 + s5, s11 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s11 + digit */
{rej, ws + s8, ws + s9, s11 + digit, s11 + dot, s11 + s5, s11 + s6, ws + s10, s11, s11 + digit, s11 + dot, s11 + s5, s11 + s6, s11, s11 + digit, s11 + dot, s11 + s5, s11 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s11 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s11 + dot */
{rej, ws + s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s11 + s5 */
{rej, ws + s10, rej, s11 + digit, s11 + dot, s11 + s5, s11 + s6, rej, rej, rej, rej, rej, rej, s11, s11 + digit, s11 + dot, s11 + s5, s11 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s11 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s11 + s6 */
{rej, s11 + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s11 + dot, s11 + s5, rej, rej, rej, rej, rej, rej, rej, s11 + digit, s11 + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s11 + s7 */
{rej, s11 + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s11 + s8 */
{rej, s11 + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s11 + s9 */
{rej, s11 + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s11 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s11 + s10 */
{rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s11 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s12 */
{rej, s11 + s8, s11 + s9, rej, rej, rej, rej, s11 + s10, s12, s12 + digit, s12 + dot, s12 + s5, s12 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s12 + digit */
{rej, s11 + s8, s11 + s9, s12 + digit, s12 + dot, s12 + s5, s12 + s6, s11 + s10, s12, s12 + digit, s12 + dot, s12 + s5, s12 + s6, s12, s12 + digit, s12 + dot, s12 + s5, s12 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s12 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s12 + dot */
{rej, s11 + s10, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s12 + s5 */
{rej, s11 + s10, rej, s12 + digit, s12 + dot, s12 + s5, s12 + s6, rej, rej, rej, rej, rej, rej, s12, s12 + digit, s12 + dot, s12 + s5, s12 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s12 + s6, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* s12 + s6 */
{rej, s12 + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, s12 + dot, s12 + s5, rej, rej, rej, rej, rej, rej, rej, s12 + digit, s12 + s5, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej, rej},
/* unseen */
{rej, digit, dot, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, e, s1, s2, s3, s4, minus, minus + digit, minus + dot, minus + s5, minus + s6, minus + s7, minus + s8, minus + s9, minus + s10, plus, plus + digit, plus + dot, plus + s5, plus + s6, plus + s7, plus + s8, plus + s9, plus + s10, ws, ws + digit, ws + dot, ws + s5, ws + s6, ws + s7, ws + s8, ws + s9, ws + s10, s11, s11 + digit, s11 + dot, s11 + s5, s11 + s6, s11 + s7, s11 + s8, s11 + s9, s11 + s10, s12, s12 + digit, s12 + dot, s12 + s5, s12 + s6}
};

/* Returns the state that str v resolves to. We do not use a big while loop.
 * Instead, for efficiency we only allow sequential flow of the states. This
 * is possible because of the acyclic nature of the FSM (there is no
 * state that sends you back to a previous state). The depth of the if
 * statements go until 4 in worst case. As a result this function never
 * reaches the end.
 */
static INLINE unsigned char dbl_fsm(str v) {
    unsigned char state = rej;
    unsigned char lead  = 0;

    /*decide the entry point in the FSM */
    if (isspace(*v)) {
        state = ws;
    } else if (isdigit(*v)) {
        state = digit;
    } else if ((*v == 'e') || (*v == 'E')) {
        state = e;
    } else if (*v == '.') {
        state = dot;
    } else if (*v == '+') {
        state = plus;
    } else if (*v == '-') {
        state = minus;
    } else {
        return state; /* not valid, return imediatly with rej */
    }

    /* Deal with states e, s1, s2, s3, s4.
     * State e cannot have any leading whitespaces,
     * so we dont deal with spaces yet */
    if (state == e) {
        /* consume character */
        v++;
        if (*v == '\0') {
            return state;
        } else if (*v == '+') {
            state = s1;
        } else if (*v == '-') {
            state = s2;
        } else if (isdigit(*v)) {
            state = s3;
        } else {
            return rej;
        }

        /* state here is s1, s2, or s3 */
        /* consume one more char */
        v++;
        if (*v == '\0') {
            return state;
        } else if ((state == s3) && isspace(*v)) { /* only s3 can have space */
            state = s4;
        } else if (isdigit(*v)) {
            state = s3;
        } else {
            return rej;
        }

        /* state here is s3 or s4 */
        if (state == s3) {
            @:consume_digits(v)@
            if (*v == '\0') {
                return state;
            } else if (isspace(*v)) {
                state = s4;
            } else  {
                return rej;
            }
        }

        /* state here is s4 */
        assert (state == s4);
        @:consume_spaces(v)@
        if (*v == '\0') {
            return state;
        } else {
            return rej;
        }
    }

    if ((state == minus) || (state == plus)) {
        /* consume one char */
        v++;
        if (*v == '\0') {
            return state;
        } else if (isdigit(*v)) {
            lead = state; /* remember lead state */
            state = digit;
        } else {
            return rej;
        }
    }

    if (state == ws) {
        /* consume all leading white spaces */
        @:consume_spaces(v)@
        if (*v == '\0') {
            return state;
        } else if (isdigit(*v)) {
            lead = state;
            state = digit;
        } else if (*v == '+') {
            state = s11;
        } else if (*v == '-') {
            state = s12;
        } else {
            return rej;
        }

        /* deal with states s11 and s12 */
        if ((state == s11) || (state == s12)) {
            /* consume one character */
            v++;
            if (*v == '\0') {
                return state;
            } else if (isdigit(*v)) {
                lead = state;
                state = digit;
            } else {
                return rej;
            }
        }

        assert ((state == digit) && (lead != 0));
    }

    if (state == digit) {
        @:consume_digits(v)@
        if (*v == '\0') {
            return state+lead; /* from now on return state + lead */
        } else if (*v == '.') {
            state = dot;
        } else if (isspace(*v)) {
            state = s10;
        } else if ((*v == 'e') || (*v == 'E')) {
            state = s6;
        } else {
            return rej;
        }
    }

    if (state == dot) {
        /* consume one more character */
        v++;
        if (*v == '\0') {
            return state+lead;
        } else if (isdigit(*v)) {
            state = s5;
            /* state s5 can be resolved here */
            @:consume_digits(v)@
            if (*v == '\0') {
                return state+lead;
            } else if (isspace(*v)) {
                state = s10;
            } else if ((*v == 'e') || (*v == 'E')) {
                state = s6;
            } else {
                return rej;
            }
        } else {
            return rej;
        }
    }

    if (state == s6) {
        /* consume one more character */
        v++;
        if (*v == '\0') {
            return state+lead;
        } else if (*v == '+') {
            state = s7;
        } else if (*v == '-') {
            state = s8;
        } else if (isdigit(*v)) {
            state = s9;
        } else {
            return rej;
        }
    }

    if ((state == s7) || (state == s8)) {
        /* consume one more character */
        v++;
        if (*v == '\0') {
            return state+lead;
        } else if (isdigit(*v)) {
            state = s9;
        } else {
            return rej;
        }
    }

    if (state == s9) {
        @:consume_digits(v)@
        if (*v == '\0') {
            return state+lead;
        } else if (isspace(*v)) {
            state = s10;
        } else {
            return rej;
        }
    }

    if (state == s10) {
        @:consume_spaces(v)@
        if (*v == '\0') {
            return state+lead;
        } else {
            return rej;
        }
    }

    assert ("FSM should never reach this state of chaos");
    return state+lead;
}

/* wrapper for mil command xquery_dbl */
int CMD_XQ_DBLFSM(int *res, str v) {
    *res = dbl_fsm(v);
    return GDK_SUCCEED;
}

@+ XML Value Index Construction

The construction is based an a bottom-up traversal of the XML tree...
input context nodes
text node := h function
intermediate node := c function
updates

@- Equi-lookup on text

The index is based on the hash function XQH_H and the combine function XQH_C.
It is stored in two BATs, namely pre_hash[void, int] and hash_nid[int, oid]
(shorted ion head).

    pre_hash is used during index creation and index update for fast accessing
    the hash value of an (intermediate) node. The head is alligned with the nid
    column of the PRE table.

    hash_nid is used during query time to retrieve a candidate set of XML nodes
    which hash values are equall with the hash value of the query text. The BAT
    is sorted in hash value for fast lookup and retrieval. For read-only
    documents we could drop the hash_nid BAt and relly on the hash table
    created by Monet during query time. However, this is not true for updatable
    documents, and moreover the storage overhead of either approaches is the
    same.

          pre_hash                 hash_nid
          +-----+------------+     +------------+-----+
          |     | hash value |     | hash value | nid |
          |void |    int     |     |    int     | oid |
          +-----+------------+     +------------+-----+

@- Range queries on double values

The index is based on the Finite State Machine that accepts the language that
describes XML double type and a state transition table. It is stored in three
bats, nid_state, value_nid, nid_lexical. All BATs are shorted on head.

        nid_state         value_nid               nid_lexical
       +-----+--------+  +--------------+-----+  +-----+---------------+
       | nid | state  |  | double value | nid |  | nid | lexical value |
       | oid |  byte  |  |     dbl      | oid |  | oid |      str      |
       +-----+--------+  +--------------+-----+  +-----+---------------+

@= found_create_string
/* during creation of the index we expect the context nodes
 * to be only of kind TEXT. This is not true during updates,
 * since there might *not* be a text node (deleted).
 */
pre_hsh[pre] = XQH_H(text_base + VarHeapVal(pre_text, pre_prop[pre], text_width));
cur++;

@= found_update_string
if (pre_kind[pre] == TEXT) {
    pre_hsh[pre] = XQH_H(text_base + VarHeapVal(pre_text, pre_prop[pre], text_width));
    cur++;
} else {
    /* deal with non-text nodes */
}

@= found_create_dbl
/* during creation of the index we expect the context nodes
 * to be only of kind TEXT. This is not true during updates,
 * since there might *not* be a text node (deleted).
 */
pre_state[pre] = dbl_fsm(text_base + VarHeapVal(pre_text, pre_prop[pre], text_width));
cur++;

@= found_update_dbl
if (pre_kind[pre] == TEXT) {
    pre_state[pre] = dbl_fsm(text_base + VarHeapVal(pre_text, pre_prop[pre], text_width));
    cur++;
} else {
    /* deal with non-text nodes */
}

@= desc_create_string

@= desc_create_dbl

@= desc_update_string
pre_hsh[pre] = 0;

@= desc_update_dbl
pre_state[pre] = unseen;

@= pop_create_string
/* pop the stack */
pop = stack[--depth];
/* combine the popped hash value with the pre hash value */
pre_hsh[pop] = XQH_C(pre_hsh[pop], pre_hsh[pre]);
pre = pop;

@= pop_create_dbl
/* pop the stack */
pop = stack[--depth];
/* combine the popped hash value with the pre hash value */
pre_state[pop] = STT[pre_state[pop]][pre_state[pre]];
pre = pop;

@= pop_update_string
pop = stack[--depth];
pre = pop+1;
SKIPHOLES(pre, pre_size);
pre_hsh[pop] = XQH_C(pre_hsh[pop], pre_hsh[pre]);
while (pre < (pop + pre_size[pop] + 1)) {
    pre = pre + pre_size[pre] + 1;
    SKIPHOLES(pre, pre_size);
    pre_hsh[pop] = XQH_C(pre_hsh[pop], pre_hsh[pre]);
}
pre = pop;

@= pop_update_dbl
pop = stack[--depth];
pre = pop+1;
SKIPHOLES(pre, pre_size);
pre_state[pop] = STT[pre_state[pop]][pre_state[pre]];
while (pre < (pop + pre_size[pop] + 1)) {
    pre = pre + pre_size[pre] + 1;
    SKIPHOLES(pre, pre_size);
    pre_state[pop] = STT[pre_state[pop]][pre_state[pre]];
}
pre = pop;

@= empty_stack_update_string
while (depth > 0) {
    pop = stack[--depth];
    pre = pop+1;
    SKIPHOLES(pre, pre_size);
    pre_hsh[pop] = XQH_C(pre_hsh[pop], pre_hsh[pre]);
    while (pre < (pop + pre_size[pop] + 1)) {
        pre = pre + pre_size[pre] + 1;
        SKIPHOLES(pre, pre_size);
        pre_hsh[pop] = XQH_C(pre_hsh[pop], pre_hsh[pre]);
    }
    pre = pop;
}

@= empty_stack_update_dbl
while (depth > 0) {
    pop = stack[--depth];
    pre = pop+1;
    SKIPHOLES(pre, pre_size);
    pre_state[pop] = STT[pre_state[pop]][pre_state[pre]];
    while (pre < (pop + pre_size[pop] + 1)) {
        pre = pre + pre_size[pre] + 1;
        SKIPHOLES(pre, pre_size);
        pre_state[pop] = STT[pre_state[pop]][pre_state[pre]];
    }
    pre = pop;
}

@= father_create_string
pre_hsh[stack[depth-1]] = XQH_C(pre_hsh[stack[depth-1]], pre_hsh[pre]);

@= father_create_dbl
pre_state[stack[depth-1]] = STT[pre_state[stack[depth-1]]][pre_state[pre]];

@= father_update_string

@= father_update_dbl

@= empty_stack_create_string
while (depth > 0) { /* still nodes in the stack */
    pop = stack[--depth];
    pre_hsh[pop] = XQH_C(pre_hsh[pop], pre_hsh[pre]);
    pre = pop;
}

@= empty_stack_create_dbl
while (depth > 0) { /* still nodes in the stack */
    pop = stack[--depth];
    pre_state[pop] = STT[pre_state[pop]][pre_state[pre]];
    pre = pop;
}

@= decleration_create_string
unsigned int* pre_hsh,            /* - pre_hsh column           */

@= decleration_create_dbl
unsigned char* pre_state,         /* - pre_state column         */

@= decleration_update_string
unsigned int* pre_hsh,            /* - updated pre_hsh column   */

@= decleration_update_dbl
unsigned char* pre_state,         /* - updated pre_state column */

@= init_create_string
/* initialize all hash values to 0 for correct hash combination */
for (cur = 0; cur < limit; cur++) pre_hsh[cur] = 0;
cur = 0;

@= init_create_dbl
/* initialize all states to unseen for correct STT resolution */
for (cur = 0; cur < limit; cur++) pre_state[cur] = unseen;
cur = 0;

@= init_update_string
/* nothing to init in updates */

@= init_update_dbl
/* nothing to init in updates */

@= index_
static int
index_@1_@2(                        /* OUTPUT:                     */
        @:decleration_@1_@2()@
                                          /* DOCUMENT:                   */
        oid* pre_prop,                    /* - pre_prop column           */
        void* pre_text,                   /* - fixed-size offsets of the
                                               pre_text string column    */
        char* text_base,                  /* - base pointer of the
                                               pre_text string heap      */
        unsigned short text_width,        /* - width of pre_text column  */
        unsigned int* pre_size,           /* - pre_size column           */
        unsigned char* pre_level,         /* - pre_level column          */
        unsigned char* pre_kind,          /* - pre_kind column           */
        oid limit,                        /* - valid range of pre ids in
                                               the document              */
                                          /* INPUT: */
        oid* context, oid context_size)   /* - the context array and its size */
{
    oid buf[XML_DEPTH_MAX+1], *stack=buf; /* STACK CONTAINS pre NUMBERS */
    oid root = 1; /* 0=collection node, 1=root of first fragment */
    oid pre = root;
    oid cur = 0;
    oid pop = 0;
    int depth = 0;
    (void) pre_level;
    (void) pre_kind;

    *stack++ = oid_nil; /* bogus parent, filtered out later */

    /* initialize all hash values to 0 for correct hash combination */
    @:init_@1_@2()@

    /* if the collection node is passed in, skip it */
    while(cur < context_size && context[cur] == 0) cur++;

    /* we perform a forwards scan with skipping, that carries out an *optimal*
     * depth-first DOM tree traversal (where we visit nodes only if needed)
     */
    while(cur < context_size) { /* while still context nodes active */

        if (context[cur] == pre) {
            @:found_@1_@2()@

        } else if (context[cur] <= pre + pre_size[pre]) {

            /* next context node is in the descendants: go find it */
            stack[depth++] = pre;
            @:desc_@1_@2()@
            pre = pre+1;
            SKIPHOLES(pre, pre_size);
            if (depth == XML_DEPTH_MAX || pre > limit) break; /* SANITY */

        } else if (depth == 0 ||
                context[cur] <= stack[depth-1] + pre_size[stack[depth-1]]) {
            /* in the branch that is on the stack, but in some sibling
               that we need to find */


            /* first update father node */
            @:father_@1_@2()@

            oid off = pre;
            int budget = PF_SIBLING_PROBES;
            int cnt = 0;

            while(pre + pre_size[pre] < context[cur]) {
                /* skip from sibling to sibling */
                pre = pre + pre_size[pre] + 1;
                SKIPHOLES(pre, pre_size);
                if (pre > limit) break; /* SANITY */
                if (++cnt == budget) {
                    oid old = pre;
                    pre = speculate_skip(pre, context[cur], pre-off,
                            budget, pre_size, pre_level);
                    if (pre == old) {
                        /* skip failed: wait longer next time */
                        budget += budget;
                    }
                    off = pre; cnt = 0;
                }
            }
            if (depth == 0)
                root = pre;
        } else {
            @:pop_@1_@2()@
        }
    }

    @:empty_stack_@1_@2()@

    return (cur == context_size);
}

@= create_string_bat
res_bat = BATnew(TYPE_void, TYPE_int, limit);

@= create_dbl_bat
res_bat = BATnew(TYPE_void, TYPE_bte, limit);

@= create_string_cast
unsigned int*

@= create_dbl_cast
unsigned char*

@= CMD_vx_create
int
CMD_vx_create_@1(          /* RESULT:   */
        BAT **ret,      /* - [void,int] bat, res column                    */
                        /* INPUT:    */
        BAT *ctx_bat,   /* - [void,oid] bat, context nodes, assuming all
                             are of kind TEXT for create                   */
                        /* DOCUMENT: */
        BAT *prop_text, /* - [void,str] bat, doc representation with holes */
        BAT *prop_bat,  /* - [void,oid] bat, doc representation with holes */
        BAT *size_bat,  /* - [void,int] bat, doc representation with holes */
        BAT *level_bat, /* - [void,chr] bat, doc representation with holes */
        BAT *kind_bat)  /* - [void,chr] bat, doc representation with holes */
{
    int status = GDK_FAIL;
    BAT *res_bat = NULL;
    oid limit = BATcount(size_bat);
    unsigned int *pre_size = (unsigned int*)
            Tloc(size_bat, BUNfirst(size_bat));
    unsigned char *pre_level = (unsigned char*)
            Tloc(level_bat, BUNfirst(level_bat));
    unsigned char *pre_kind = (unsigned char*)
            Tloc(kind_bat, BUNfirst(kind_bat));
    oid *context = (oid *) Tloc(ctx_bat, BUNfirst(ctx_bat));
    oid *pre_prop = (oid *) Tloc(prop_bat, BUNfirst(prop_bat));

    /* some error checks */
    if (!(BATtordered(ctx_bat) & 1))
    {
        GDKerror("vx_create: context bat must be ordered on tail.\n");
        return status;
    }
    if (prop_text->hseqbase || !BAThdense(prop_text)) {
        GDKerror("vx_create: illegal prop text bat passed in.\n");
        return status;
    }
    if (prop_bat->hseqbase || !BAThdense(prop_bat)) {
        GDKerror("vx_create: illegal prop bat passed in.\n");
        return status;
    }
    if (size_bat->hseqbase || !BAThdense(size_bat)) {
        GDKerror("vx_create: illegal size bat passed in.\n");
        return status;
    }
    if (level_bat->hseqbase || !BAThdense(level_bat)) {
        GDKerror("vx_create: illegal level bat passed in.\n");
        return status;
    }
    if (kind_bat->hseqbase || !BAThdense(kind_bat)) {
        GDKerror("vx_create: illegal kind bat passed in.\n");
        return status;
    }

    //res_bat = BATnew(TYPE_void, TYPE_int, limit);
    @:create_@1_bat@
    if (res_bat) {
        if (index_create_@1(
                    (@:create_@1_cast()@) Tloc(res_bat, BUNfirst(res_bat)),
                    pre_prop,
                    (var_t*) Tloc(prop_text, BUNfirst(prop_text)),
                    (char*) prop_text->T->vheap->base,
                    prop_text->T->width,
                    pre_size, pre_level, pre_kind, limit,
                    context, BATcount(ctx_bat))) {
            status = GDK_SUCCEED;
        } else {
            GDKerror("vx_creat: failed.\n");
        }
    } else {
        GDKerror("vx_create: could not allocate memory for result bat.\n");
    }

    if (status == GDK_SUCCEED) {
        BATsetcount(res_bat, limit);
        BATseqbase(res_bat, 0);
        res_bat->tsorted = 0;
        *ret = res_bat;
    } else if (res_bat) {
        BBPreclaim(res_bat);
    }
    return status;
}

@= vx_update_def_string
unsigned int *pre_vx = (unsigned int*)
        Tloc(vx_bat, BUNfirst(vx_bat));

@= vx_update_def_dbl
unsigned char *pre_vx = (unsigned char*)
        Tloc(vx_bat, BUNfirst(vx_bat));

@= CMD_vx_update
int
CMD_vx_update_@1(          /* RESULT:   */
        BAT **ret,      /* - [void,int] bat, res column                   */
                        /* INPUT:    */
        BAT *ctx_bat,   /* - [void,oid] bat, context nodes, assuming all
                             are of kind TEXT for create                   */
        BAT *vx_bat,    /* - [void, int/byte] pre_hsh or pre_state         */
                        /* DOCUMENT: */
        BAT *prop_text, /* - [void,str] bat, doc representation with holes */
        BAT *prop_bat,  /* - [void,oid] bat, doc representation with holes */
        BAT *size_bat,  /* - [void,int] bat, doc representation with holes */
        BAT *level_bat, /* - [void,chr] bat, doc representation with holes */
        BAT *kind_bat)  /* - [void,chr] bat, doc representation with holes */
{
    int status = GDK_FAIL;
    oid limit = BATcount(size_bat);
    unsigned int *pre_size = (unsigned int*)
            Tloc(size_bat, BUNfirst(size_bat));
    unsigned char *pre_level = (unsigned char*)
            Tloc(level_bat, BUNfirst(level_bat));
    unsigned char *pre_kind = (unsigned char*)
            Tloc(kind_bat, BUNfirst(kind_bat));
    @:vx_update_def_@1()@
    oid *context = (oid *) Tloc(ctx_bat, BUNfirst(ctx_bat));
    oid *pre_prop = (oid *) Tloc(prop_bat, BUNfirst(prop_bat));

    /* some error checks */
    if (!(BATtordered(ctx_bat) & 1))
    {
        GDKerror("vx_create: context bat must be ordered on tail.\n");
        return status;
    }
    if (prop_text->hseqbase || !BAThdense(prop_text)) {
        GDKerror("vx_create: illegal prop text bat passed in.\n");
        return status;
    }
    if (prop_bat->hseqbase || !BAThdense(prop_bat)) {
        GDKerror("vx_create: illegal prop bat passed in.\n");
        return status;
    }
    if (size_bat->hseqbase || !BAThdense(size_bat)) {
        GDKerror("vx_create: illegal size bat passed in.\n");
        return status;
    }
    if (level_bat->hseqbase || !BAThdense(level_bat)) {
        GDKerror("vx_create: illegal level bat passed in.\n");
        return status;
    }
    if (kind_bat->hseqbase || !BAThdense(kind_bat)) {
        GDKerror("vx_create: illegal kind bat passed in.\n");
        return status;
    }
    if (vx_bat->hseqbase || !BAThdense(vx_bat)) {
        GDKerror("vx_create: illegal vx bat passed in.\n");
        return status;
    }

    if (index_update_@1(
                pre_vx,
                pre_prop,
                (var_t*) Tloc(prop_text, BUNfirst(prop_text)),
                (char*) prop_text->T->vheap->base,
                prop_text->T->width,
                pre_size, pre_level, pre_kind, limit,
                context, BATcount(ctx_bat))) {
        status = GDK_SUCCEED;
    } else {
        GDKerror("vx_creat: failed.\n");
    }

    if (status == GDK_SUCCEED) {
        *ret = vx_bat;
    }

    return status;
}

@c
@:index_(create,string)@
@:index_(update,string)@
@:index_(create,dbl)@
@:index_(update,dbl)@
@:CMD_vx_create(string)@
@:CMD_vx_create(dbl)@
@:CMD_vx_update(string)@
@:CMD_vx_update(dbl)@
