@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2008 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@f vx_index
@a Lefteris Sidirourgos, Peter Boncz
@t Single-pass XML Value Index Construction and Update

@* XML value index support
We construct two updatable XML value indices, one supporting equi-lookup
queries for string values, and one supporting range queries on double values,
(aka numerics). Both indeces are build over the data associated to each element
node. We do not support in for the time being attribute values, or
attribute/element tags.

@+ Text Hash Functions
@- Hash function H()
@- Combine function C()

@c
#include "pf_config.h"
#include <gdk.h>
#include "shredder.h"   /* for XML_DEPTH_MAX */
#include "ll_upwards.h" /* SKIPHOLES, speculate_skip, PF_SIBLING_PROBES */

#define XQH_UNSGN(v)  ((unsigned int) v)
#define XQH_MASK5(c)  ((c) & 31)
#define XQH_MASK7(c)  ((c) & 127)
#define XQH_MASK27(c) ((c) & (~31))
#define XQH_SHFT_l(v,o) (v << (o+5))
#define XQH_SHFT_r(v,o) ((XQH_UNSGN(v) >> (7 - ((o+7)%27))) << 5)
#define XQH_CLC_SHFT(v,o) ((v << o) | (XQH_MASK27(XQH_UNSGN(v) >> (27-o))))

/* hash function H */
static INLINE int XQH_H(str v) {
    int c;
    int h_val = 0, ofs = 0;

    for (; *v != '\0'; v++){
        c = XQH_MASK7(*v);
        /* circular_XOR operation */
        h_val ^= XQH_SHFT_l(c,ofs);
        if (ofs > 20) {
            h_val ^= XQH_SHFT_r(c,ofs);
        }
        /* update offset */
        ofs = (ofs+5) % 27;
    }
    return (h_val |= ofs);
}

/* wrapper for mil command xquery_hash */
int CMD_XQH_H(int *res, str v) {
    *res = XQH_H(v);
    return GDK_SUCCEED;
}

/* wrapper for mil command [xquery_hash] */
int CMD_XQH_H_bat(BAT **res, BAT* b) {
    size_t i = 0, cnt = BATcount(b);
    BAT *bn = *res = BATnew(TYPE_void, TYPE_int, cnt);
    char *base = (char*) b->T->vheap->base;
    if (bn) {
        var_t *src = (var_t*) Tloc(b, BUNfirst(b));
        int *dst = (int*) Tloc(bn, BUNfirst(bn));
        for(i=0; i<cnt; i++)
            dst[i] =  XQH_H(base + src[i]);

        ALIGNsetH(bn, b);
        BATsetcount(bn, cnt);
        bn->tsorted = 0;
        return GDK_SUCCEED;
    }
    return GDK_FAIL;
}

/* Combine function C */
static INLINE int XQH_C(int l, int r) {
    int h_comb = 0;

    h_comb |= XQH_MASK27(l);                       /* copy the left operand */
    /* XOR the right operand after applying a circular shift */
    h_comb ^= XQH_CLC_SHFT(XQH_MASK27(r),XQH_MASK5(l));
    h_comb |= (XQH_MASK5(l)+XQH_MASK5(r)) % 27;    /* combine offsets       */

    return h_comb;
}

/* wrapper for mil command xquery_combine */
int CMD_XQH_C(int *res, int *l, int *r) {
    *res = XQH_C(*l, *r);
    return GDK_SUCCEED;
}

/* wrapper for mil command [xquery_combine] */
int CMD_XQH_C_bat(BAT **res, BAT *l, BAT *r) {
    if (ALIGNsynced(l, r)) {
        size_t i = 0, cnt = BATcount(l);
        BAT *bn = *res = BATnew(TYPE_void, TYPE_int, cnt);
        int *lval = (int*) Tloc(bn, BUNfirst(l));
        int *rval = (int*) Tloc(bn, BUNfirst(r));
        int *dst  = (int*) Tloc(bn, BUNfirst(bn));
        if (bn == NULL) return GDK_FAIL;

        for(i=0; i<cnt; i++)
            dst[i] = XQH_C(lval[i], rval[i]);

        ALIGNsetH(bn, l);
        BATsetcount(bn, cnt);
        bn->tsorted = 0;
        return GDK_SUCCEED;
    }
    GDKerror("xquery_combine: (%s,%s): not synced on head.\n",
            BATgetId(l), BATgetId(r));
    return GDK_FAIL;
}

/* debug function for the xquery string hash index */
int CMD_XQH_STR(str *res, int *val) {
    char *p = *res = (char*) GDKmalloc(128);
    int v = *val;
    int i;
    if (p == NULL) return GDK_FAIL;

    /* print c-array */
    for (i = 31; i >= 5; i--) {
        *p++ = '1' - !(v & (1 << i));
    }
    *p++ = '-';

    /* print offset */
    for (i = 4; i >= 0; i--) {
        *p++ = '1' - !(v & (1 << i));
    }

    *p = 0;
    return GDK_SUCCEED;
}

@+ XML Double Type Functions
@- Double Finite State Machine (DFSM)
@- State Transition Table (STT)

@= consume_digits
    /* consume all digits */
    for (; (*@1 != '\0') && isdigit(*@1); @1++);

@= consume_spaces
    /* consume all white spaces */
    for (; (*@1 != '\0') && isspace(*@1); @1++);

@c
/* all possible states of a bbl value, not including -/+ INF */
enum dblstates
{ rej, e, dot, digit, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10,
  minus = 14, /* minus + (digit, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) */
  plus  = 26, /* plus  + (digit, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) */
  ws    = 38, /* ws  + (digit, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) */
  s11   = 50, /* wsplus  + (digit, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) */
  s12   = 62, /* wsminus  + (digit, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) */
};  /* 74 states in total */

/* Returns the state that str v resolves to. We do not use a big while loop.
 * Instead, for efficiency we only allow sequential flow of the states. This
 * is possible because of the acyclic nature of the FSM (there is no
 * state that sends you back to a previous state). The depth of the if
 * statements go until 4 in worst case. As a result this function never
 * reaches the end.
 */
static INLINE int dbl_fsm(str v) {
    int state = rej;
    int lead  = 0;

    /*decide the entry point in the FSM */
    if (isspace(*v)) {
        state = ws;
    } else if (isdigit(*v)) {
        state = digit;
    } else if ((*v == 'e') || (*v == 'E')) {
        state = e;
    } else if (*v == '.') {
        state = dot;
    } else if (*v == '+') {
        state = plus;
    } else if (*v == '-') {
        state = minus;
    } else {
        return state; /* not valid, return imediatly with rej */
    }

    /* Deal with states e, s1, s2, s3, s4.
     * State e cannot have any leading whitespaces,
     * so we dont deal with spaces yet */
    if (state == e) {
        /* consume character */
        v++;
        if (*v == '\0') {
            return state;
        } else if (*v == '+') {
            state = s1;
        } else if (*v == '-') {
            state = s2;
        } else if (isdigit(*v)) {
            state = s3;
        } else {
            return rej;
        }

        /* state here is s1, s2, or s3 */
        /* consume one more char */
        v++;
        if (*v == '\0') {
            return state;
        } else if ((state == s3) && isspace(*v)) { /* only s3 can have space */
            state = s4;
        } else if (isdigit(*v)) {
            state = s3;
        } else {
            return rej;
        }

        /* state here is s3 or s4 */
        if (state == s3) {
            @:consume_digits(v):@
            if (*v == '\0') {
                return state;
            } else if (isspace(*v)) {
                state = s4;
            } else  {
                return rej;
            }
        }

        /* state here is s4 */
        assert (state == s4);
        @:consume_spaces(v):@
        if (*v == '\0') {
            return state;
        } else {
            return rej;
        }
    }

    if ((state == minus) || (state == plus)) {
        /* consume one char */
        v++;
        if (*v == '\0') {
            return state;
        } else if (isdigit(*v)) {
            lead = state; /* remember lead state */
            state = digit;
        } else {
            return rej;
        }
    }

    if (state == ws) {
        /* consume all leading white spaces */
        @:consume_spaces(v):@
        if (*v == '\0') {
            return state;
        } else if (isdigit(*v)) {
            lead = state;
            state = digit;
        } else if (*v == '+') {
            state = s11;
        } else if (*v == '-') {
            state = s12;
        } else {
            return rej;
        }

        /* deal with states s11 and s12 */
        if ((state == s11) || (state == s12)) {
            /* consume one character */
            v++;
            if (*v == '\0') {
                return state;
            } else if (isdigit(*v)) {
                lead = state;
                state = digit;
            } else {
                return rej;
            }
        }

        assert ((state == digit) && (lead != 0));
    }

    if (state == digit) {
        @:consume_digits(v):@
        if (*v == '\0') {
            return state+lead; /* from now on return state + lead */
        } else if (*v == '.') {
            state = dot;
        } else if (isspace(*v)) {
            state = s10;
        } else if ((*v == 'e') || (*v == 'E')) {
            state = s6;
        } else {
            return rej;
        }
    }

    if (state == dot) {
        /* consume one more character */
        v++;
        if (*v == '\0') {
            return state+lead;
        } else if (isdigit(*v)) {
            state = s5;
            /* state s5 can be resolved here */
            @:consume_digits(v):@
            if (*v == '\0') {
                return state+lead;
            } else if (isspace(*v)) {
                state = s10;
            } else if ((*v == 'e') || (*v == 'E')) {
                state = s6;
            } else {
                return rej;
            }
        } else {
            return rej;
        }
    }

    if (state == s6) {
        /* consume one more character */
        v++;
        if (*v == '\0') {
            return state+lead;
        } else if (*v == '+') {
            state = s7;
        } else if (*v == '-') {
            state = s8;
        } else if (isdigit(*v)) {
            state = s9;
        } else {
            return rej;
        }
    }

    if ((state == s7) || (state == s8)) {
        /* consume one more character */
        v++;
        if (*v == '\0') {
            return state+lead;
        } else if (isdigit(*v)) {
            state = s9;
        } else {
            return rej;
        }
    }

    if (state == s9) {
        @:consume_digits(v):@
        if (*v == '\0') {
            return state+lead;
        } else if (isspace(*v)) {
            state = s10;
        } else {
            return rej;
        }
    }

    if (state == s10) {
        @:consume_spaces(v):@
        if (*v == '\0') {
            return state+lead;
        } else {
            return rej;
        }
    }

    assert ("FSM should never reach this state of chaos");
    return state+lead;
}

/* wrapper for mil command xquery_dbl */
int CMD_XQ_DBLFSM(int *res, str v) {
    *res = dbl_fsm(v);
    return GDK_SUCCEED;
}

@+ XML Value Index Construction

The construction is based an a bottom-up traversal of the XML tree...
input context nodes
text node := h function
intermediate node := c function
updates

@- Equi-lookup on text

The index is based on the hash function XQH_H and the combine function XQH_C.
It is stored in two BATs, namely pre_hash[void, int] and hash_nid[int, oid]
(shorted ion head).

    pre_hash is used during index creation and index update for fast accessing
    the hash value of an (intermediate) node. The head is alligned with the nid
    column of the PRE table.

    hash_nid is used during query time to retrieve a candidate set of XML nodes
    which hash values are equall with the hash value of the query text. The BAT
    is sorted in hash value for fast lookup and retrieval. For read-only
    documents we could drop the hash_nid BAt and relly on the hash table
    created by Monet during query time. However, this is not true for updatable
    documents, and moreover the storage overhead of either approaches is the
    same.

          pre_hash                 hash_nid
          +-----+------------+     +------------+-----+
          |     | hash value |     | hash value | nid |
          |void |    int     |     |    int     | oid |
          +-----+------------+     +------------+-----+

@- Range queries on double values

The index is based on the Finite State Machine that accepts the language that
describes XML double type and a state transition table. It is stored in three
bats, nid_state, value_nid, nid_lexical. All BATs are shorted on head.

        nid_state         value_nid               nid_lexical
       +-----+--------+  +--------------+-----+  +-----+---------------+
       | nid | state  |  | double value | nid |  | nid | lexical value |
       | oid |  byte  |  |     dbl      | oid |  | oid |      str      |
       +-----+--------+  +--------------+-----+  +-----+---------------+

@= found_create_string
/* during creation of the index we expect the context nodes
 * to be only of kind TEXT. This is not true during updates,
 * since there might *not* be a text node (deleted).
 */
if (pre_kind[pre] == TEXT) {
    pre_hsh[pre] = XQH_H(text_base + pre_text[pre_prop[pre]]);
    cur++;
} else {
    GDKerror("index_create_string: Context node is not of kind TEXT.\n");
    return 0;
}

@= pop_create_string
/* pop the stack */
pop = stack[--depth];
/* combine the popped hash value with the pre hash value */
pre_hsh[pop] = XQH_C(pre_hsh[pop], pre_hsh[pre]);
pre = pop;

@= empty_stack_create_string
while (depth > 0) { /* still nodes in the stack */
    pop = stack[--depth];
    pre_hsh[pop] = XQH_C(pre_hsh[pop], pre_hsh[pre]);
    pre = pop;
}

@= index_
static int
index_@1_@2(                        /* OUTPUT:                     */
        unsigned int* pre_hsh,            /* - pre_hsh column            */
                                          /* DOCUMENT:                   */
        oid* pre_prop,                    /* - pre_prop column           */
        var_t* pre_text,                  /* - fixed-size offsets of the
                                               pre_text string column    */
        char* text_base,                  /* - base pointer of the
                                               pre_text string heap      */
        unsigned int* pre_size,           /* - pre_size column           */
        unsigned char* pre_level,         /* - pre_level column          */
        unsigned char* pre_kind,          /* - pre_kind column           */
        oid limit,                        /* - valid range of pre ids in
                                               the document              */
                                          /* INPUT: */
        oid* context, oid context_size)   /* - the context array and its size */
{
    oid buf[XML_DEPTH_MAX+1], *stack=buf; /* STACK CONTAINS pre NUMBERS */
    oid root = 1; /* 0=collection node, 1=root of first fragment */
    oid pre = root;
    oid cur = 0;
    oid pop = 0;
    int depth = 0;
    (void) pre_level;

    *stack++ = oid_nil; /* bogus parent, filtered out later */

    /* initialize all hash values to 0 for correct hash combination */
    for (cur = 0; cur < limit; cur++) pre_hsh[cur] = 0;
    cur = 0;

    /* if the collection node is passed in, skip it */
    while(cur < context_size && context[cur] == 0) cur++;

    /* we perform a forwards scan with skipping, that carries out an *optimal*
     * depth-first DOM tree traversal (where we visit nodes only if needed)
     */
    while(cur < context_size) { /* while still context nodes active */

        if (context[cur] == pre) {
            @:found_@1_@2():@

        } else if (context[cur] <= pre + pre_size[pre]) {

            /* next context node is in the descendants: go find it */
            stack[depth++] = pre;
            pre = pre+1;
            SKIPHOLES(pre, pre_size);
            if (depth == XML_DEPTH_MAX || pre > limit) break; /* SANITY */

        } else if (depth == 0 ||
                context[cur] <= stack[depth-1] + pre_size[stack[depth-1]]) {
            /* in the branch that is on the stack, but in some sibling
               that we need to find */


            /* first update father node */
            pre_hsh[stack[depth-1]] = XQH_C(pre_hsh[stack[depth-1]],
                    pre_hsh[pre]);

            oid off = pre;
            int budget = PF_SIBLING_PROBES;
            int cnt = 0;

            while(pre + pre_size[pre] < context[cur]) {
                /* skip from sibling to sibling */
                pre = pre + pre_size[pre] + 1;
                SKIPHOLES(pre, pre_size);
                if (pre > limit) break; /* SANITY */
                if (++cnt == budget) {
                    oid old = pre;
                    pre = speculate_skip(pre, context[cur], pre-off,
                            budget, pre_size, pre_level);
                    if (pre == old) {
                        /* skip failed: wait longer next time */
                        budget += budget;
                    }
                    off = pre; cnt = 0;
                }
            }
            if (depth == 0)
                root = pre;
        } else {
            @:pop_@1_@2():@
        }
    }

    @:empty_stack_@1_@2():@

    return (cur == context_size);
}

@c
@:index_(create,string):@

int
CMD_vx_create(          /* RESULT:   */
        BAT **ret,      /* - [void,int] bat, hash column                   */
                        /* INPUT:    */
        BAT *ctx_bat,   /* - [void,oid] bat, context nodes, assuming all
                             are of kind TEXT for create                   */
                        /* DOCUMENT: */
        BAT *prop_text, /* - [void,str] bat, doc representation with holes */
        BAT *prop_bat,  /* - [void,oid] bat, doc representation with holes */
        BAT *size_bat,  /* - [void,int] bat, doc representation with holes */
        BAT *level_bat, /* - [void,chr] bat, doc representation with holes */
        BAT *kind_bat)  /* - [void,chr] bat, doc representation with holes */
{
    int status = GDK_FAIL;
    BAT *hash_bat = NULL;
    oid limit = BATcount(size_bat);
    unsigned int *pre_size = (unsigned int*)
            Tloc(size_bat, BUNfirst(size_bat));
    unsigned char *pre_level = (unsigned char*)
            Tloc(level_bat, BUNfirst(level_bat));
    unsigned char *pre_kind = (unsigned char*)
            Tloc(kind_bat, BUNfirst(kind_bat));
    oid *context = (oid *) Tloc(ctx_bat, BUNfirst(ctx_bat));
    oid *pre_prop = (oid *) Tloc(prop_bat, BUNfirst(prop_bat));

    /* some error checks */
    if (!(BATtordered(ctx_bat) & 1))
    {
        GDKerror("vx_create: context bat must be ordered on tail.\n");
        return status;
    }
    if (prop_text->hseqbase || !BAThdense(prop_text)) {
        GDKerror("vx_create: illegal prop text bat passed in.\n");
        return status;
    }
    if (prop_bat->hseqbase || !BAThdense(prop_bat)) {
        GDKerror("vx_create: illegal prop bat passed in.\n");
        return status;
    }
    if (size_bat->hseqbase || !BAThdense(size_bat)) {
        GDKerror("vx_create: illegal size bat passed in.\n");
        return status;
    }
    if (level_bat->hseqbase || !BAThdense(level_bat)) {
        GDKerror("vx_create: illegal level bat passed in.\n");
        return status;
    }
    if (kind_bat->hseqbase || !BAThdense(kind_bat)) {
        GDKerror("vx_create: illegal kind bat passed in.\n");
        return status;
    }

    hash_bat = BATnew(TYPE_void, TYPE_int, limit);
    if (hash_bat) {
        if (index_create_string(
                    (unsigned int*) Tloc(hash_bat, BUNfirst(hash_bat)),
                    pre_prop,
                    (var_t*) Tloc(prop_text, BUNfirst(prop_text)),
                    (char*) prop_text->T->vheap->base,
                    pre_size, pre_level, pre_kind, limit,
                    context, BATcount(ctx_bat))) {
            status = GDK_SUCCEED;
        } else {
            GDKerror("index_creation: failed.\n");
        }
    } else {
        GDKerror("vx_create: could not allocate memory for hash bat.\n");
    }

    if (status == GDK_SUCCEED) {
        BATsetcount(hash_bat, limit);
        BATseqbase(hash_bat, 0);
        hash_bat->tsorted = 0;
        *ret = hash_bat;
    } else if (hash_bat) {
        BBPreclaim(hash_bat);
    }
    return status;
}
