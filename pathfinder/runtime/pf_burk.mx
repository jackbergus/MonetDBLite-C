@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2006 University of Konstanz.  All Rights Reserved.

@f pf_burk
@a Wouter Alink
@v 0.1
@t MIL primitives to support the Burkowski Axis Steps in XQuery 

@* Introduction
@T
This module provides MIL primitives to support the Burkowski
Axis Steps on top of MonetDB within the "Pathfinder" project.
This module needs to be loaded in order to use the Burkowski Steps.

Actually there are 3 things to do in order to enable the Burkowski
steps:
\begin{itemize}
\item at compile time the Burkowski flag needs to be set by adding
\texttt{--enable-burk} as a \texttt{./configure} switch.
\item when all is compiled and Mserver is started it is needed to
allow Burkowski steps by adding \texttt{burkowski=enabled} to the 
\texttt{--set} option list. The default is \texttt{burkowski=disabled}.
\item and even when MonetDB is started, it is not possible to use
Burkowski without first loading this module (\emph{pf\_burk}) by
typing \texttt{module("pf\_burk")}.
\end{itemize}

@- Select Narrow / Select Wide / Reject Narrow / Reject Wide
@T
The SN, SW, RN, RW joins are region joins based on the work by Forbes J. 
Burkowski (1992) ``Retrieval Activities in a Database Consisting of 
Heterogeneous Collections of Structured Text''

There are two major changes to Burkowski's original ideas: (1.) this 
implementation turns around the arguments, and (2.) it handles (partly) 
overlapping regions by including them in the SW (the results of SW and SN do 
not have to be disjunct) and the result of SN is a subset of SW.

When Burkowski defines \texttt{<chapter> SW \{"Feynman","virtual particle"\}}, this could 
be queried as:
\begin{verbatim}
  select_wide_join({"Feynman","virtual particle"},<chapter>)
\end{verbatim}
which will return all the chapter which contain either "Feynman" or "virtual 
particle". The AND-expression, as in: \texttt{<chapter> SW \{"Feynman"\} SW 
\{"virtual particle"\} }
could be written as:
\begin{verbatim}
 select_wide_join({"Feynman"},
        select_wide_join({"virtual particle"}, <chapter>))
\end{verbatim}

The reason for the swap in parameters is that the selection mechanisms are 
going to be used as "steps" in XPath, which are not "selection" but 
"navigation" operations.

Some more examples: the \texttt{reject\_wide\_join(\{"Feynman","virtual 
particle"\}, <chapter>) } would return all the chapters which do not 
contain (nor partly contain) either "Feynman" or "virtual particle"
and the \texttt{ reject\_narrow\_join(<chapter>,\{"Feynman","virtual 
particle"\}) } would return all the instances of "Feynman" and "virtual 
particle" which are not inside a chapter-region.

@
@* Module Definition 
@m
.MODULE pf_burk;

@+ Burkowski Joins
@T
The input for the joins are the current context: 
\begin{verbatim}
 BAT(<void>, <int>region start), BAT(<void>, <int>region end) 
\end{verbatim}
and the destination context, which have to be indicated by:
\begin{verbatim}
 BAT(<void>, <int>region start), BAT(<void>, <int>region end)
\end{verbatim}
The result is a list to the items in the destination context that match:
 (<void>, <oid>)

\emph{NOTE}: currently only 'int'- and 'lng'-type regions are implemented, but 
these joins could as well be implemented on floats, dates, and other data-types 
without much effort.

@- non loop-lifted Burkowski joins
@= burkowski_join_sigs
   .COMMAND @1_@2_join_sort(BAT[oid, @3], BAT[oid,@3], BAT[oid,@3], BAT[oid,@3]) :
	BAT[void,oid] = CMD@1_@2_join_sort_@3; "@1 @2 join (on @3s), using inputs sorted on start"
@
@m
# declaration Burkowski joins (int)
@:burkowski_join_sigs(select,narrow,int)@
@:burkowski_join_sigs(select,wide,int)@
@:burkowski_join_sigs(reject,narrow,int)@
@:burkowski_join_sigs(reject,wide,int)@

# declaration Burkowski joins (lng)
@:burkowski_join_sigs(select,narrow,lng)@
@:burkowski_join_sigs(select,wide,lng)@
@:burkowski_join_sigs(reject,narrow,lng)@
@:burkowski_join_sigs(reject,wide,lng)@
   
# convenience
.COMMAND burk_enabled() : bit = CMD_burk_enabled; "returns the status of Burkowski"

# interaction with the underlying data
.COMMAND blob(BAT[void,lng], BAT[void,lng], str) : 
	BAT[void,str] = CMDfetch_standoff_data_lng; "fetch data from region (start,end) blob (file)"
.COMMAND blob(BAT[void,int], BAT[void,int], str) : 
	BAT[void,str] = CMDfetch_standoff_data_int; "fetch data from region (start,end) blob (file)"
@

@- Loop-Lifted Burkowski joins
@T
This variant of the Burkowski joins uses loop-lifting to do the join for
multiple inputs in a single pass. The input are the input regions (with there
iteration value, sorted on "start"): 
\begin{verbatim}
  BAT(<oid>iter,<int>start)
  BAT(<oid>iter,<int>end)
\end{verbatim}
and the destination regions: 
\begin{verbatim}
  BAT(<void>id, <int>start) 
  BAT(<void>id, <int>end)
\end{verbatim}
The result will be a bat ([oid]iter,[oid]id), where 'iter' is the 
corresponding bucket and 'id' the region-id of the destination regions. 

\emph{NOTE}: only the iter in the input bat (<oid>iter,<int>start) is checked. the 'iter'-column in 
the bat (iter,end) is optional (can be void as well) as it is not used.

\emph{NOTE}: the seqbase of the id-columns is currently supposed to be 0@0.

\emph{NOTE}: the loop-lifted burkowski joins (SN, SW, RN, RW) have not been tested 
thoroughly. The result is ordered on tail (the region identifier) and NOT on 
head (iter). (any additional testcases are welcome)
 
@-TODO: 
@T
\emph{KNOWN ISSUE}: currently the iter needs to be of type OID (and may NOT be VOID)

\emph{KNOWN ISSUE}: the loop-lifted REJECT burkowski joins do NOT work
workaround: use the non-loop-lifted Burkowski join or take the 
loop-lifted-"select"-join and calculate per iter the inverse of the result.

@m
# declaration Burkowski joins (loop lifted, int)
@:ll_burkowski_join_sigs(select,narrow,int)@
@:ll_burkowski_join_sigs(select,wide,int)@
@:ll_burkowski_join_sigs(reject,narrow,int)@
@:ll_burkowski_join_sigs(reject,wide,int)@

# declaration Burkowski joins (loop lifted, lng)
@:ll_burkowski_join_sigs(select,narrow,lng)@
@:ll_burkowski_join_sigs(select,wide,lng)@
@:ll_burkowski_join_sigs(reject,narrow,lng)@
@:ll_burkowski_join_sigs(reject,wide,lng)@

@= ll_burkowski_join_sigs
   .COMMAND ll_@1_@2_join_sort(BAT[oid, @3], BAT[oid,@3], BAT[oid,@3], BAT[oid,@3]) :
	BAT[oid,oid] = CMDll_@1_@2_join_sort_@3; "loop lifted @1 @2 join (on @3s), using inputs sorted on start"
@

@- Burkowski steps (Burkowski Steps)

@mil
module(alarm);
module(aggrX3);
module(malalgebra);
module(mmath);
module(xtables);

const BURKOWSKI := nil;
var region_namespace := "";
var region_start_attr_tag := "start";
var region_end_attr_tag := "end";

# Wouter: 
@:ll_burkowski(select,narrow)@
@:ll_burkowski(select,wide)@
@:ll_burkowski(reject,narrow)@
@:ll_burkowski(reject,wide)@
@:burkowski(select,narrow)@
@:burkowski(select,wide)@
@:burkowski(reject,narrow)@
@:burkowski(reject,wide)@
@

@+ Burkowski helpers

@m
.END pf_burk;
@

@h
#ifndef __PF_BURK_H__
#define __PF_BURK_H__

#include "pf_burk.proto.h"
#include <monet.h>
#include <monet_interpreter.h>
#include <monettime.h>
#include <lock.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <gdk.h>
#include <limits.h>

#define MAX_int INT_MAX
#define MAX_lng LLONG_MAX
#define MIN_int INT_MIN
#define MIN_lng LLONG_MIN

/* maximum size of stack for loop-lifted burkowski join */ 
#define abs_max_stack_size 65536

#endif 
@

@= select_outside
            /* skip nodes which are not contained */
@
@= reject_outside
            /* insert nodes which are not contained */
            index = BUNindex(region_start,iter_start);
            BUNappend(bn, (ptr)(&index), FALSE);
@
@= select_inside
            /* insert nodes which are contained */
            index = BUNindex(region_start,iter_start);
            BUNappend(bn, (ptr)(&index), FALSE);
@
@= reject_inside
            /* skip nodes which are contained */
@
@= narrow
        if (outer_iter_start_next < outer_last_start) 
          outer_start_next = *(outer_iter_start_next);
        else 
          outer_start_next = MAX_@2;

        /* loop through the not strictly contained region */ 
        while(iter_start < last_start && *iter_start < *outer_iter_start) { 
            @:@1_outside@
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the strictly contained regions */
        while(iter_start < last_start && *iter_start < outer_start_next) {
            if (*iter_end <= *outer_iter_end) {
              @:@1_inside@
            } else {
              @:@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre; 
        }
@
@= wide
        /* loop through the not even contained regions */
        while(iter_start < last_start && *iter_end < *outer_iter_start) { 
            @:@1_outside@
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the partly contained regions */
        while(iter_start < last_start && *iter_start <= *outer_iter_end) {
            if (*iter_end >= *outer_iter_start) {
              @:@1_inside@
            } else { 
              @:@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre; 
        }
@

@= region_jump_decl_narrow
    @1 outer_start_next;
@
@= region_jump_decl_wide
@

@= burkowski_join_impl
int 
CMD@1_@2_join_sort_@3(BAT **result, BAT *source_start, BAT *source_end, BAT *region_start, BAT *region_end) {   

    @4 *iter_start, *iter_end, *last_start, 
        *outer_iter_start, *outer_iter_end, *outer_last_start, 
        *outer_iter_start_next, *outer_iter_end_next;

    @:region_jump_decl_@2(@4)@
        oid index;
    int Sss,Sse,Srs,Sre;
    BAT * bn = NULL;

    *result=NULL;

    if (!(ALIGNrelated(source_start,source_end)&1)) {
        GDKerror("@1_@2_join_sort_@3: source BATs not related.\n"); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(source_start)&1)) { 
        GDKerror("@1_@2_join_sort_@3: source BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }
    if (!(ALIGNrelated(region_start,region_end)&1)) {
        GDKerror("@1_@2_join_sort_@3: region BATs not related.\n"); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(region_start)&1)) { 
        GDKerror("@1_@2_join_sort_@3: region BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }

    if ((bn = BATnew(TYPE_void, TYPE_oid, BATcount(region_start))) == NULL) {
        GDKerror("@1_@2_join_sort_@3: could not allocate memory for result BAT.\n"); 
        return(GDK_FAIL);
    }

    iter_start = (@4 *) BUNtail(region_start, BUNfirst(region_start));
    iter_end = (@4 *) BUNtail(region_end, BUNfirst(region_end));
    last_start = (@4 *) BUNtail(region_start, BUNlast(region_start));
    outer_iter_start = (@4 *) BUNtail(source_start, BUNfirst(source_start));
    outer_iter_end = (@4 *) BUNtail(source_end, BUNfirst(source_end));
    outer_last_start = (@4 *) BUNtail(source_start, BUNlast(source_start));

    /* todo: what if size is not a multiple of sizeof(@4)  (BUNsize(...) % sizeof(@4) != 0) */
    Srs = BUNsize(region_start) / sizeof(@4);
    Sre = BUNsize(region_end) / sizeof(@4);
    Sss = BUNsize(source_start) / sizeof(@4);
    Sse = BUNsize(source_end) / sizeof(@4);

    while (outer_iter_start < outer_last_start) {
        outer_iter_start_next = outer_iter_start+Sss; outer_iter_end_next = outer_iter_end+Sse;

        /* skip overlapping region in the source  */
        while(outer_iter_start_next < outer_last_start
                && *(outer_iter_end_next) <= *(outer_iter_end)) {
            outer_iter_start_next+=Sss; outer_iter_end_next+=Sse;
        }

        @:@2(@1,@3)@

        outer_iter_start=outer_iter_start_next; outer_iter_end=outer_iter_end_next;
    }
    *result=bn;
    return(GDK_SUCCEED);
}
@
@= ll_select_outside
            /* skip nodes which are not contained */
@
@= ll_reject_outside
            /* insert nodes which are not contained */
            // FIXME: we need to include the iters not on the stack...
            index = BUNindex(region_start,iter_start) - BUNindex(region_start, BUNfirst(region_start));
            BUNins(bn, (ptr)(&(stack[i].iter)), (ptr)(&index));
@
@= ll_select_inside
            /* insert nodes which are contained */
            index = BUNindex(region_start,iter_start) - BUNindex(region_start, BUNfirst(region_start)); 
            BUNins(bn, (ptr)(&(stack[i].iter)), (ptr)(&index));
@
@= ll_reject_inside
            /* skip nodes which are contained */
@
@= ll_narrow
        /* loop through the not strictly contained region */ 
        /* nearest_start contains first upcoming starting point on stack
           stack contains a single element (or more if more regions start on 
           same place) */
        while(@:more_target_regions@ && *iter_start < nearest_start) { 
            for (i=0;i<stack_size;i++) {
              @:ll_@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the strictly contained regions */
        while(@:more_target_regions@ && *iter_start < nearest_next_start) {
            /* if there is a item that should be removed from the stack,
               we need to remove (it/them) */
            if (*iter_start > nearest_end) {
              nearest_end = MAX_@2;
              for (i=0; i < stack_size;i++) {
                if (stack[i].end < *iter_start) {
                  /* we only need to remove the item, nearest_next_start will 
                     tell us when to fetch a new one */
                  stack_size = remove_from_stack_@2(stack,stack_size,i--);
                } else {
                  /* in the same loop we can efficiently calculate the next 
                     nearest end */
                  if (stack[i].end < nearest_end) 
                    nearest_end = stack[i].end;
                }
              }
            }

            for (i=0;i<stack_size;i++) {
              if (*iter_end <= stack[i].end) {
                @:ll_@1_inside@
              } else {
                @:ll_@1_outside@
              }
            }
            iter_start+=Srs; iter_end+=Sre; 
        }
        /* by now, we should be ready to push a new item on the stack 
           we processed as much as possible without this new item... */
@
@= ll_wide
        /* loop through the not even contained regions */
        /* nearest_start contains first upcoming starting point on stack
           stack should contain a single element (with outer_iter_start as nearest_start)
           if not, this step will automatically be skipped as iter_end will be more than 
           nearest_start */
        while(@:more_target_regions@ && *iter_end < nearest_start) {
            for (i=0;i<stack_size;i++) {
              @:ll_@1_outside@
            }
            iter_start+=Srs; iter_end+=Sre;
        }

        /* loop through the partly contained regions 
           now there are some elements on the stack that want our attention */
        while(@:more_target_regions@ && *iter_end < nearest_next_start) {
            /* if we think there is at least one region that could be popped... */
            if (*iter_start > nearest_end ) {
              nearest_end = MAX_@2;
              for (i=0;i<stack_size;i++) {
                /* is this one of them */
                if (*iter_start > stack[i].end) {
                  /* i-- to keep the for-loop happy */
                  stack_size = remove_from_stack_@2(stack, stack_size, i--);
                } else {
                  /* if not, let it compete in the nearest_end */
                  if (nearest_end > stack[i].end) nearest_end=stack[i].end;
                }
              }
            }
            for (i=0;i < stack_size;i++) {
              if (*iter_end >= stack[i].start) {
                @:ll_@1_inside@
              } else { 
                @:ll_@1_outside@
              }
            }
            iter_start+=Srs; iter_end+=Sre; 
        }
        /* by now, we should be ready to push a new item on the stack 
           we processed as much as possible without this new item... */
@

@= more_target_regions
 (iter_start < last_start)
@

@= ll_burkowski_join_impl
/* 4 aug 2005
   loop lifted burkowski join implementation */
int 
CMDll_@1_@2_join_sort_@3(BAT **result, BAT *source_start, BAT *source_end, BAT *region_start, BAT *region_end) {

    @4 *iter_start, *iter_end, *last_start, 
        *outer_iter_start, *outer_iter_end, *outer_last_start, 
        *outer_iter_start_next, *outer_iter_end_next, 
        nearest_end = MIN_@3, nearest_next_start = MAX_@3, nearest_start = MAX_@3; 

    BURKstack_@3 *stack;
    int max_stack_size = 16;
    int stack_size = 0, i;
    oid index;
    oid *outer_iter_iter, *outer_iter_iter_next;
    int Sss,Sse,Srs,Sre, Ssi;
    BAT * bn = NULL;

    *result=NULL;

    // KNOWN ISSUE: the reject-part does not work (it needs to know which iters there are beforehand)
    // it also has to add the regions to all the iters that are currently not on the stack

    if (BATcount(source_start) != BATcount(source_end)) {
        GDKerror("ll_@1_@2_join_sort_@3: source BATs not related size(start) = %d != size(end) = %d.\n",
                (int) BATcount(source_start),(int)BATcount(source_end)); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(source_start)&1)) { 
        GDKerror("ll_@1_@2_join_sort_@3: source BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }
    if (!(ALIGNrelated(region_start,region_end)&1)) {
        GDKerror("ll_@1_@2_join_sort_@3: region BATs not related.\n"); 
        return(GDK_FAIL);
    }
    if (!(BATtordered(region_start)&1)) { 
        GDKerror("ll_@1_@2_join_sort_@3: region BAT not sorted (on start).\n"); 
        return(GDK_FAIL);
    }
    //TODO: in case the iter-table is void, do something special... (should be easy)
    if (source_start->htype == TYPE_void) { 
        GDKerror("ll_@1_@2_join_sort_@3: iter-list is of type VOID instead of OID.\n"); 
        return(GDK_FAIL);
    }

    // the number of iters is also the maximum depth of the stack 
    // (however, in most cases the stack will be very shallow,
    // only overlapping nodes will share the stack)
    // we could allocate a lot less space:
    // probably log(|iter|) would be more than enough in most cases
    // counting iters is probably expensive, for now we only reserve for a fixed amount.. 
    if ((stack = (BURKstack_@3 *)GDKmalloc(sizeof(BURKstack_@3) * max_stack_size)) == NULL) {
        GDKerror("ll_@1_@2_join_sort_@3: could not allocate memory for stack.\n"); 
        return(GDK_FAIL);
    }
    // the size of the bat is maybe not correct (could be more, could be less)
    
    if ((bn = BATnew(TYPE_oid, TYPE_oid, BATcount(region_start))) == NULL) {
        GDKerror("ll_@1_@2_join_sort_@3: could not allocate memory for result BAT.\n"); 
        GDKfree(stack);
        return(GDK_FAIL);
    }

    iter_start = (@4 *) BUNtail(region_start, BUNfirst(region_start));
    iter_end = (@4 *) BUNtail(region_end, BUNfirst(region_end));
    last_start = (@4 *) BUNtail(region_start, BUNlast(region_start));
    outer_iter_iter = (oid *) BUNhead(source_start, BUNfirst(source_start));
    outer_iter_start = (@4 *) BUNtail(source_start, BUNfirst(source_start));
    outer_iter_end = (@4 *) BUNtail(source_end, BUNfirst(source_end));
    outer_last_start = (@4 *) BUNtail(source_start, BUNlast(source_start));

    /* todo: do we have to check for var-sized bats? */
    /* todo: what if size is not a multiple of sizeof(@4)  (BUNsize(...) % sizeof(@4) != 0) */
    Srs = BUNsize(region_start) / sizeof(@4);
    Sre = BUNsize(region_end) / sizeof(@4);
    Sss = BUNsize(source_start) / sizeof(@4);
    Sse = BUNsize(source_end) / sizeof(@4);
    Ssi = BUNsize(source_start) / sizeof(oid);

    stack_size = replace_in_stack_@3(stack,stack_size,
            *outer_iter_iter,
            *outer_iter_start,
            *outer_iter_end);

    while (@:more_target_regions@) {
        outer_iter_start_next = outer_iter_start+Sss; 
        outer_iter_end_next = outer_iter_end+Sse;
        outer_iter_iter_next = outer_iter_iter+Ssi;

        /* skip (completely) overlapping regions (in same iter) in the source  
           this is NOT an optimization, it is neccessary to capture all the regions */
        while (outer_iter_start_next < outer_last_start) { 
            i=0;
            while (i < stack_size && stack[i].iter != *(outer_iter_iter_next)) i++;
            /* only skip region if there already is a region with the same iter 
               and the region is contained in the current region on the stack. */
            if (i < stack_size && stack[i].end > *(outer_iter_end_next)) {
                /* skip region */
                outer_iter_start_next+=Sss; 
                outer_iter_end_next+=Sse;
                outer_iter_iter_next+=Ssi;
            } else {
                /* otherwise we've got a candidate */
                goto endofskipping; 
            }
        }
endofskipping:
        if (outer_iter_start_next < outer_last_start) 
            nearest_next_start = *(outer_iter_start_next);
        else                                          
            nearest_next_start = MAX_@3;
        if (outer_iter_start < outer_last_start) 
            nearest_start = *(outer_iter_start);
        else 
            nearest_start = MAX_@3;

        // todo: an optimization would be to add all the regions with same start-pos at once
        //       if stack[next_iter].start = next_start --> add to stack
        // if (nearest_start == nearest_next_start) -> skip inner loop (next part)

        @:ll_@2(@1,@3)@

        outer_iter_start=outer_iter_start_next; 
        outer_iter_end=outer_iter_end_next;
        outer_iter_iter=outer_iter_iter_next; 

        if (outer_iter_start < outer_last_start) {
            stack_size = replace_in_stack_@3(stack,stack_size,
                    *outer_iter_iter,
                    *outer_iter_start,
                    *outer_iter_end);
            if (stack_size >= max_stack_size) {
                if (max_stack_size < abs_max_stack_size) {
                    max_stack_size *= 2;
                    GDKwarning("ll_@1_@2_join_sort_@3: (stack overflow) "
                            "the stack capacity will be doubled and will hold %d items\n", 
                            (int)max_stack_size );
                    GDKfree(stack);
                    if ((stack = (BURKstack_@3 *)GDKmalloc(sizeof(BURKstack_@3) * 
                                    max_stack_size)) == NULL) {
                        GDKerror("ll_@1_@2_join_sort_@3: could not allocate memory for stack.\n"); 
                        BBPreclaim(bn);
                        return(GDK_FAIL);
                    }
                } else {
                    GDKerror("ll_@1_@2_join_sort_@3: (stack overflow) "
                            "Houston, please contact 911 (or increase "
                            "the max_stack_size = %d)\n", 
                            (int)max_stack_size );
                    GDKfree(stack);
                    BBPreclaim(bn);
                    return(GDK_FAIL);
                }
            }
            if (*outer_iter_end < nearest_end)  
                nearest_end=*outer_iter_end;
        }
    }
    GDKfree(stack); /* it might be possible there are still items left on the stack, 
                       but we are out of target-regions, so they starve... */
    *result=bn;
    return(GDK_SUCCEED);
}
@

@= ll_burk
@:ll_burkowski_join_impl(select,narrow,@1,@2)@
@:ll_burkowski_join_impl(select,wide,@1,@2)@
@:ll_burkowski_join_impl(reject,narrow,@1,@2)@
@:ll_burkowski_join_impl(reject,wide,@1,@2)@
@

@= burk
@:burkowski_join_impl(select,narrow,@1,@2)@
@:burkowski_join_impl(select,wide,@1,@2)@
@:burkowski_join_impl(reject,narrow,@1,@2)@
@:burkowski_join_impl(reject,wide,@1,@2)@
@

@= stack_procs
/* actually its more like a heap */
typedef struct BURKstack_@1 {
    @2 end,start;
    oid iter;
} BURKstack_@1;

/* returns the new stacksize */
int replace_in_stack_@1(BURKstack_@1 stack[], int size, oid iter, @2 start, @2 end) {
    int i=0;
    while (i < size && stack[i].iter != iter) i++;
    stack[i].start=start;
    stack[i].end=end;
    stack[i].iter=iter;
    if (i >= size) 
        return size+1;
    else
        return size;
}

/* returns the new stacksize */
int remove_from_stack_@1(BURKstack_@1 stack[], int size, int index) {
    int i = size-1;
    // stack doesn't need to be sorted 
    // (we can fill the gap with the one on top of the stack)
    stack[index].start = stack[i].start;
    stack[index].end = stack[i].end;
    stack[index].iter = stack[i].iter;
    return i;
}
@

@= ffb
int 
CMDfetch_standoff_data_@1(BAT ** result, BAT * region_start, BAT * region_end, char * blobname) {
    // fetches strings from the blob for the regions (start, end) found in two [oid, @1] bats
    // regions should be sorted by start
    // non-loop-lifted
    // result is BAT[VOID,STR]
    @2 *iter_start, *iter_end, start_inc, end_inc, *start_next;
    @2 count, blob_pos, *last_iter_start, next_stop, min_end;
    int c =0;
    int stack_size, i, j;
    struct { @2 start, end; } stack[256]; // probably a to high estimation, but to be sure...
    char buf[4098], temp[4096];

    FILE *blob;
    // open blob
    if ((blob = fopen(blobname,"rb")) == NULL) {
        GDKerror("could not open Stand-Off data file (the BLOB)\n");
        return(GDK_FAIL);
    }
    min_end = MAX_@1; 
    *result = BATnew(TYPE_void, TYPE_str, BATcount(region_start)); 

    // initialize vars
    iter_start =  (@2 *) BUNtail(region_start, BUNfirst(region_start));
    start_inc = BUNsize(region_start) / sizeof(@2); 
    iter_end =  (@2 *) BUNtail(region_end, BUNfirst(region_end));
    end_inc = BUNsize(region_end) / sizeof(@2);
    start_next = iter_start + start_inc;
    last_iter_start =  (@2 *) BUNtail(region_start, BUNlast(region_start));
    count = 0;   
    blob_pos =0;   
    stack_size = 0;
    while (iter_start < last_iter_start) {
        start_next = iter_start + start_inc;
        //  fast-forward if stack is empty
        if (stack_size==0) { 
		fseek(blob,*iter_start,SEEK_SET); 
		blob_pos=*iter_start; 
	}
        //   push new region on stack
	if ((*iter_end - *iter_start) / 4096 > 0) {
            GDKerror("BLOB: Cannot handle regions larger than 4096 bytes\n");
            return(GDK_FAIL);
        }
        stack[stack_size].start=*iter_start;
        stack[stack_size].end=*iter_end;
	stack_size++;
        
        // also allocate the memory for the string. 
        if (stack_size == 255) {
            GDKerror("Houston, please call 911, and please hurry up! (or increase "
                    "the stacksize in the ffb() function)\n");
            fclose(blob);
            return(GDK_FAIL);
        }

        //   start fetching till either: end of region or start of new region (whichever comes first)
        min_end = MAX_@1; 
        for (i=0;i<stack_size;i++)  
            if (stack[i].end < min_end) 
               min_end=stack[i].end; 
        if (start_next == last_iter_start || *start_next > min_end) 
		next_stop = min_end; 
	else 
		next_stop = *start_next;
        
        while (blob_pos < next_stop) {
            c = fgetc(blob);
            if (c == EOF) break;
            // if (c <= 9) c = ' '; // get rid of system-chars
            buf[blob_pos % 4096] = (char) c;
            blob_pos++;
        }
	
        // remove all stack-items with end == blob_pos (or if EndOfFile, end all items on stack)
        // there could have been an item ending, otherwise a new one 
        // will start
        if ((blob_pos == min_end) || (c == EOF)) 
            for (i=0;i<stack_size;i++) 
                if ((stack[i].end == min_end) || (c == EOF)) { 
                    if ((stack[i].start % 4096) < (blob_pos % 4096)) {
                      // we have to return (start..end)
                      buf[blob_pos % 4096] = '\0'; // zero-terminate string
                      BUNappend(*result, (ptr)(buf + (stack[i].start % 4096)), FALSE);
                    } else {
                      // we have to concatenate the two parts (start..4095) + (0...end)
                      for (j=0; j < blob_pos - stack[i].start; j++) 
                        temp[j] = buf[(stack[i].start + j) % 4096];
                      temp[j]='\0'; // zero-terminate string
                      BUNappend(*result, (ptr)temp, FALSE);
                    }
                    stack_size--; // pop from stack
                    stack[i].start = stack[stack_size].start; 
                    stack[i].end = stack[stack_size].end; 
                }
        // move to next item
        iter_start+=start_inc; iter_end+=end_inc; start_next+=start_inc; count++;
    }
    // return result
    fclose(blob);
    return(GDK_SUCCEED);
}
@

@= burk_step
PROC @1(BAT[oid,oid] iter, BAT[oid,oid] ctx, oid cont, BAT[oid,bat] ws, int order, bat[void,oid] cands) : BAT[oid,oid]
{
    # TODO: "order" is not (yet?) used, here.

    var pre_sizes := ws.fetch(PRE_SIZE).fetch(cont);
    
    # Wouter: code to do region-steps: SN, SW, RN, RW
    ws := region_extract(ws,cont,"lng");
    var region_pre := ws.fetch(REGION_PRE).find(cont);
    var region_start := ws.fetch(REGION_START).find(cont);
    var region_end := ws.fetch(REGION_END).find(cont);
    #region_pre.hot(); # doesn't seem to have any influence
    #region_start.hot();
    #region_end.hot();
    
    var heights := ws.fetch(HEIGHT).fetch(cont);

    var unq := {count}(iter.reverse(), iter.tunique());

    var result := bat(oid,oid);
    var offset := 0;
    var ctx_slice;

   # instead of the unq@batloop, we could do loop-lifting instead...
   # use: ll_select_narrow_join_sort(...) (in sjoin.mx)
   # we do need to prepare the regions and the iters... (should not be a problem...)
    var loop_lifted := @4;
    if (loop_lifted) 
    { 
      result := ll_@3(region_pre, region_start, region_end, cands, iter, ctx); 
      result := result.reverse().sort().reverse();
    } 
    if (not(loop_lifted)) 
    {  
      unq@batloop () {
	ctx_slice := ctx.slice(offset, offset + $t - 1).reverse().project(nil);
	ctx_slice := ctx_slice.chk_order(); # have to check because step expects it sorted
        result.insert(@3
                              (region_pre, region_start, region_end,
                               cands,
                               ctx_slice)
	              .project($h).reverse());
        offset := offset + $t;
      }
    }
  return result.access(BAT_READ);
}
ADDHELP("@1", "wouter", "Oct 2005",
"PARAMETERS:\n\
BAT[oid,any] iter (grouping relation)\n\
BAT[oid,any] ctx (context set)\n\
oid cont (the current container of the ws)\n\
BAT[oid,bat] ws (working set)\n\
BAT[void,oid] cands (candidate set)\n\
DESCRIPITON:\n\
returns all nodes on the @2 axis of the ctx-nodes duplicate free for each group.",
"pf_burk");
@

@= ll_burkowski
################################################
# Loop Lifted version of the @1-@2 Burkowski Step 
# invoked by burk_step
PROC ll_burkowski_@1_@2(BAT[oid,oid] region_pre, 
                             BAT[oid,any] region_start,
                             BAT[oid,any] region_end,
                             BAT[void,oid] cands,
                             BAT[oid,oid] iter,
                             BAT[oid,oid] ctx) : BAT[oid,oid]
{
  # prepare all the regions
  var max_iter := iter.max();
  var source_region := ctx.join(region_pre.reverse()).reverse();
  var region_iter := source_region.leftjoin(iter); 
  source_region := source_region.mirror().leftjoin(region_start).sort().project(nil).reverse();
  var source_iter := source_region.leftjoin(region_iter).reverse().mark(0@0).reverse();
  
  #  try to get a iter_start...
  var source_start := source_region.leftjoin(region_start).reverse().mark(0@0).reverse(); 
  var iter_start := source_iter.[oid]().reverse().leftjoin(source_start);
  var source_end := source_region.leftjoin(region_end).reverse().mark(0@0).reverse();     

  var sel_region := cands.reverse().mirror().leftjoin(region_pre.reverse()).reverse().mirror();
  var sel_region2 := sel_region.leftjoin(region_start).sort().mark(0@0).reverse();
  var sel_start := sel_region2.leftjoin(region_start); 
  var sel_end := sel_region2.leftjoin(region_end);     

  # do the join
  var result := ll_@1_@2_join_sort(iter_start, source_end, 
                                   sel_start, sel_end);
  
  # and convert the regions back to pre's
  result := result.leftjoin(sel_region2);
  result := result.leftjoin(region_pre);
  return result;
}
@
@= burkowski
# actual step (non-loop-lifted)
PROC burkowski_@1_@2(BAT[oid,oid] region_pre, 
                             BAT[oid,any] region_start,
                             BAT[oid,any] region_end,
                             BAT[void,oid] cands,
                             BAT[oid,void] ctx) : BAT[void,oid]
{
  # prepare all the regions
  var source_region := ctx.reverse().join(region_pre.reverse()).reverse().mirror();
  source_region := source_region.leftjoin(region_start).sort().reverse();
  var source_start := source_region.leftjoin(region_start).reverse().mark(0@0).reverse(); 
  var source_end := source_region.leftjoin(region_end).reverse().mark(0@0).reverse();     

  # sel_region = region_region?
  var sel_region := cands.reverse().mirror().leftjoin(region_pre.reverse()).reverse().mirror();
  # sel_region2 is translation-table sel-region
  var sel_region2 := sel_region.leftjoin(region_start).sort().mark(0@0).reverse();
  var sel_start := sel_region2.leftjoin(region_start); 
  var sel_end := sel_region2.leftjoin(region_end);     

  # do the join
  var result := @1_@2_join_sort(source_start, source_end, 
                                sel_start, sel_end);
  
  # and convert the regions back to pre's
  result := result.leftjoin(sel_region2);
  result := result.leftjoin(region_pre).reverse().mark(0@0).sort();
  return result;
}
@
@= no_pre
	cands := ws.fetch(PRE_SIZE).fetch(theFrag).project().reverse();
	cands := cands.chk_order();
@
@= kind_pre
	cands := ws.fetch(KIND_PRE + int(@1)).fetch(theFrag);
	cands := cands.chk_order();
@
@= ns_pre
	@:ns_loc_pre(qn,ns,QN,URI,ELEMENT)@
@
@= loc_pre
	@:ns_loc_pre(qn,loc,QN,LOC,ELEMENT)@
@
@= target_pre
	@:ns_loc_pre(prop,tgt,PROP,TGT,1)@ 
@( FIXME: '1' is used instead of PI because we skip the other kinds @)
@
@= nsloc_pre
 {
	var pre_cont := ws.fetch(PRE_CONT).fetch(theFrag);
	if (is_constant(pre_cont)) {
		var cont := pre_cont.fetch(0);
		pre_cont := nil;
		var qn_nsloc := ws.fetch(QN_LOC_URI).fetch(cont);
		    qn_nsloc := qn_nsloc.ord_uselect(loc+str('\1')+ns);
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		if (count(qn_nsloc) = 1) {
			cands := pre_prop.ord_uselect(qn_nsloc.reverse().fetch(0)).reverse();
                        if ( not(ordered(reverse(cands))) ) {
                                printf("= nsloc_pre(1): cands not ordered on tail.\n");
                        }
		} else {
			cands := pre_prop.leftjoin(qn_nsloc).sort().reverse();
		}
		pre_prop := nil;
		qn_nsloc := nil;
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(ELEMENT)).fetch(theFrag).reverse();
		    pre_cont := pre_prop.mirror().leftfetchjoin(pre_cont);
		var X_pre    := pre_prop.hmark(0@0);
		var X_prop   := pre_prop.tmark(0@0);
		    pre_prop := nil;
		var X_cont   := pre_cont.tmark(0@0);
		    pre_cont := nil;
		var X_nsloc  := mposjoin(X_prop, X_cont, ws.fetch(QN_LOC_URI));
		    X_prop   := nil;
		    X_cont   := nil;
		var _X       := X_nsloc.ord_uselect(loc+str('\1')+ns).reverse();
		    X_nsloc  := nil;
		cands := _X.leftfetchjoin(X_pre); #.reverse().sort().reverse()
                if ( not(ordered(reverse(cands))) ) {
                        printf("= nsloc_pre(3): cands not ordered on tail.\n");
                }
	}
	cands := cands.chk_order();
        if ( not(ordered(reverse(cands))) ) {
                printf("= nsloc_pre(4): cands not ordered on tail.\n");
        }
 }
@
# expansions of the loop lifted scj
# kind argument
@= kind_args
, chr kind
@
@= kind_params
, kind
@
# tagname argument
@= ns_args
, str ns
@
@= ns_params
, ns
@
@= loc_args
, str loc
@
@= loc_params
, loc
@
@= tgt_args
, str tgt
@
@= tgt_params
, tgt
@
@= nsloc_args
, str ns, str loc
@
@= nsloc_params
, ns, loc
@
@= ns_loc_pre
 {
	var pre_cont := ws.fetch(PRE_CONT).fetch(theFrag);
	if (is_constant(pre_cont)) {
		var cont := pre_cont.fetch(0);
		pre_cont := nil;
		var @1_@2 := ws.fetch(@3_@4).fetch(cont);
		    @1_@2 := @1_@2.ord_uselect(@2);
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		if (count(@1_@2) = 1) {
			cands := pre_prop.ord_uselect(@1_@2.reverse().fetch(0)).reverse();
                        if ( not(ordered(reverse(cands))) ) {
                                printf("= ns_loc_pre(1): cands not ordered on tail.\n");
                        }
		} else {
			cands := pre_prop.leftjoin(@1_@2).sort().reverse();
		}
		pre_prop := nil;
		@1_@2 := nil;
	} else {
		var pre_prop := ws.fetch(PROP_PRE + int(@5)).fetch(theFrag).reverse();
		    pre_cont := pre_prop.mirror().leftfetchjoin(pre_cont);
		var X_pre    := pre_prop.hmark(0@0);
		var X_prop   := pre_prop.tmark(0@0);
		    pre_prop := nil;
		var X_cont   := pre_cont.tmark(0@0);
		    pre_cont := nil;
		var X_@2     := mposjoin(X_prop, X_cont, ws.fetch(@3_@4));
		    X_prop   := nil;
		    X_cont   := nil;
		var _X       := X_@2.ord_uselect(@2).reverse();
		    X_@2     := nil;
		cands := _X.leftfetchjoin(X_pre); #.reverse().sort().reverse()
                if ( not(ordered(reverse(cands))) ) {
                        printf("= ns_loc_pre(3): cands not ordered on tail.\n");
                }
	}
	cands := cands.chk_order();
        if ( not(ordered(reverse(cands))) ) {
                printf("= ns_loc_pre(4): cands not ordered on tail.\n");
        }

 }
@

@= loop_lifted_scj_step_burk2
proc loop_lifted_@1_step@2 (bat[oid, oid] iter, bat[oid, oid] item, bat[void, oid] cont, bat[oid, bat] ws @3 ) : bat[oid,bat]
{
    var result := loop_lifted_@1_step@2 (iter, item, cont, ws, 0 @4);
    return result;
}
proc loop_lifted_@1_step@2 (bat[oid, oid] iter, bat[oid, oid] item, bat[void, oid] cont, bat[oid, bat] ws, int order @3 ) : bat[oid,bat]
{
    # handle empty results correctly
    if (iter.count() = 0) {
	var empty := bat(void,oid,0).seqbase(0@0).access(BAT_READ);
	return bat(void,bat,3).seqbase(0@0)
			    .append(empty)
			    .append(empty)
			    .append(empty)
			    .access(BAT_READ);
    }
    var result;
    var result_iter;
    var result_item;
    var result_cont;
    var tmp_res;
    var cands;

    var uniqueFrag := cont.tunique().sort();
    var theFrag := uniqueFrag.reverse().fetch(0);
    if (uniqueFrag.count() = 1) {
        var result_part_cont := nil;
        var result_part_iter := iter;
        var result_part_item := item;

        @:loop_lifted_scj_per_cont(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_cont := result_part_cont;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_cont := nil;
    } else {
        var result_part_cont := cont.ord_uselect(theFrag).mark(0@0).reverse();
        var result_part_iter := result_part_cont.leftfetchjoin(iter);
        var result_part_item := result_part_cont.leftfetchjoin(item);

        @:loop_lifted_scj_per_cont(@1,@5,@6,@7)@

        result_iter := result_part_iter;
        result_item := result_part_item;
        result_cont := result_part_cont;
        result_part_iter := nil;
        result_part_item := nil;
        result_part_cont := nil;

        var res_mu;
	uniqueFrag.slice(1,uniqueFrag.count() - 1)@batloop () {
	    theFrag := $h;
            result_part_cont := cont.ord_uselect(theFrag).mark(0@0).reverse();
            result_part_iter := result_part_cont.leftfetchjoin(iter);
            result_part_item := result_part_cont.leftfetchjoin(item);

            @:loop_lifted_scj_per_cont(@1,@5,@6,@7)@

            res_mu := merged_union(result_iter, result_part_iter,
				   result_item, result_part_item,
				   result_cont, result_part_cont);
            result_part_iter := nil;
            result_part_item := nil;
            result_part_cont := nil;
            result_iter := res_mu.fetch(0);
            result_item := res_mu.fetch(1);
            result_cont := res_mu.fetch(2);
            res_mu := nil;
        }
    }
    
    result_iter.access(BAT_READ);
    result_item.access(BAT_READ);
    result_cont.access(BAT_READ);
    var result_scj := bat(void,bat,3).seqbase(0@0);
    result_scj.append(result_iter);
    result_scj.append(result_item);
    result_scj.append(result_cont);

    return result_scj.access(BAT_READ);
}
@
@= loop_lifted_scj_per_cont
	result_part_iter := result_part_iter.chk_order();
	result_part_item := result_part_item.chk_order();
        result_part_cont := nil;

	# pre-test
	@4
        var result := @1 (result_part_iter, result_part_item, theFrag, ws, order, cands);

	result_part_iter := result.mark(0@0).reverse();
	result_part_item := result.reverse().mark(0@0).reverse();
        result_part_cont := constant2bat(theFrag);
	cands := nil;

	# post-test
        # wouter: there is no post-test for any burkowski step, but lets leave this 
        # for compatibility with the regular steps
	@2
@

@= loop_lifted_scj_step_burk1
@:loop_lifted_scj_step_burk2(@1,,,,,                                             cands,@:no_pre@)@
@:loop_lifted_scj_step_burk2(@1,_with_kind_test,@:kind_args@, @:kind_params@, ,cands,@:kind_pre(kind)@)@
@:loop_lifted_scj_step_burk2(@1,_with_ns_test,    @:ns_args@,   @:ns_params@,   ,cands,@:ns_pre@)@
@:loop_lifted_scj_step_burk2(@1,_with_loc_test,   @:loc_args@,  @:loc_params@,  ,cands,@:loc_pre@)@
@:loop_lifted_scj_step_burk2(@1,_with_target_test,@:tgt_args@,  @:tgt_params@,  ,cands,@:target_pre@)@
@:loop_lifted_scj_step_burk2(@1,_with_nsloc_test, @:nsloc_args@,@:nsloc_params@,,cands,@:nsloc_pre@)@
@

@mil
#############################################
# MIL WRAPPER for AXIS STEPS 
#
# In order to simplify the invocation of the axis steps functions, this
# interface provides...
# 

# Wouter: added burkowski
#one of the ?_pre steps probably does some filtering (all nodes before the #1 node in source are removed from cands)
# this should not be done in case of Burk (bug is illustrated in Video-example)
# i assume it is the :shrink_code!!
@:loop_lifted_scj_step_burk1(select_narrow)@
@:loop_lifted_scj_step_burk1(select_wide)@
@:loop_lifted_scj_step_burk1(reject_narrow)@
@:loop_lifted_scj_step_burk1(reject_wide)@

# Wouter: added burkowski steps 
# last argument tells whether to use the loop-lifted version
@:burk_step(select_narrow,select-narrow,burkowski_select_narrow, true)@
@:burk_step(select_wide,select-wide,burkowski_select_wide,       true)@
@:burk_step(reject_narrow,reject-narrow,burkowski_reject_narrow, true)@
@:burk_step(reject_wide,reject-wide,burkowski_reject_wide,       true)@


PROC region_extract(BAT[oid, BAT] my_ws, oid i, str tpe) : bat[oid,BAT] {
  # how-to: this region extract is used for the BURKOWSKI steps
  # if your regions are stored in different attributes than "start" and "end",
  # than modify the variables below

  # my_ws.access(BAT_WRITE);
  var XIRAF_nodes := my_ws.fetch(QN_LOC).fetch(i).reverse().leftjoin(
                        my_ws.fetch(QN_PREFIX).fetch(i).select(region_namespace).mirror());

  var region_pre, region_start, region_end;
  var start_qn := nil, end_qn := nil;
  if (isnil(CATCH({ start_qn := XIRAF_nodes.find(region_start_attr_tag);
                    end_qn := XIRAF_nodes.find(region_end_attr_tag); }))) {
      # get all start attributes, then their numerical value, sort it, and then get the pre's
      var attr_attr := my_ws.fetch(ATTR_QN).find(i).uselect(start_qn).mirror();
      var attr_prop := attr_attr.leftjoin(my_ws.fetch(ATTR_PROP).find(i));
      var val_start := [*tpe](attr_prop.leftjoin(my_ws.fetch(PROP_VAL).find(i))).reverse().sort();
      var start_pre := val_start.leftjoin(my_ws.fetch(ATTR_OWN).find(i));

      # now we have a table with a pre column and a start (numerical) column in the right order
      var left_pre := start_pre.reverse().mark(0@0).reverse();
      var left_start := start_pre.mark(0@0).reverse();

      # go get the pre numbers that have an end attribute
      var right_attr := my_ws.fetch(ATTR_QN).find(i).uselect(end_qn).mark(0@0).reverse();
      var right_pre := right_attr.leftjoin(my_ws.fetch(ATTR_OWN).find(i));
      var right_end := [*tpe](right_attr.leftjoin(my_ws.fetch(ATTR_PROP).find(i)).leftjoin(my_ws.fetch(PROP_VAL).find(i)));

      # the region table is the intersection between start and end
      var left_right := left_pre.leftjoin(right_pre.reverse());
      var region_left := left_right.mark(0@0).reverse();
      var region_right := left_right.reverse().mark(0@0).reverse();

## TODO: FIXME : the following code does not work, but should assign
##               the largest possible region to the document-node
#      if (=(tpe,"lng")) {
#        region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                   .insert(region_left.leftjoin(left_pre));
#        region_start := bat(void,lng).seqbase(0@0).append(getLNG_MIN())
#                                     .insert(region_left.leftjoin(left_start));
#        region_end := bat(void,lng).seqbase(0@0).append(getLNG_MAX())
#                                   .insert(region_right.leftjoin(right_end));
#     } else {
#       region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                  .insert(region_left.leftjoin(left_pre));
#       region_start := bat(void,INT).seqbase(0@0).append(getINT_MIN())
#                                    .insert(region_left.leftjoin(left_start));
#       region_end := bat(void,INT).seqbase(0@0).append(getINT_MAX())
#                                  .insert(region_right.leftjoin(right_end));
#     }
      region_pre := region_left.leftjoin(left_pre);
      region_start := region_left.leftjoin(left_start);
      region_end := region_right.leftjoin(right_end);
  } else {
      # if there are either no start or end nodes, the result is empty
      region_pre := bat(void,oid);
      region_start := bat(void,monet_atomtbl.find(tpe));
      region_end := bat(void,monet_atomtbl.find(tpe));
  }
  if (not(exist(my_ws.fetch(REGION_PRE), i))) {
    my_ws.fetch(REGION_PRE).access(BAT_WRITE).insert(i,region_pre);
    my_ws.fetch(REGION_START).access(BAT_WRITE).insert(i,region_start);
    my_ws.fetch(REGION_END).access(BAT_WRITE).insert(i,region_end);
  }
  return my_ws;
}
ADDHELP("region_extract", "wouter", "Oct 2005",
"PARAMETERS:\n\
BAT[str,BAT] an active ws (Working Set)\n\
oid i (index in the active working set)\n\
str tpe (type of region-values (int or lng))\n\
DESCRIPITON:\n\
adds three BATs to the working set REGION_PRE, REGION_START, and REGION_END and fills them.",
"pf_burk");

PROC region_extract(BAT[str, BAT] my_ws, str tpe) : bat[str,BAT] {
    # how-to: this region extract is used for the BURKOWSKI steps
    # if your regions are stored in different attributes than "start" and "end",
    # than modify the variables below
    #printf("extracting regions from %s:%s and %s:%s\n", 
    #       region_namespace,region_start_attr_tag,
    #       region_namespace,region_end_attr_tag);

    my_ws.access(BAT_WRITE);
    var XIRAF_nodes := my_ws.find("qn_loc").reverse().leftjoin(
                          my_ws.find("qn_prefix").select(region_namespace).mirror());

    var region_pre, region_start, region_end;
    var start_qn := nil, end_qn := nil;
    if (isnil(CATCH({ start_qn := XIRAF_nodes.find(region_start_attr_tag);
                      end_qn := XIRAF_nodes.find(region_end_attr_tag); }))) {
        # get all start attributes, then their numerical value, sort it, and then get the pre's
        var attr_attr := my_ws.find("attr_qn").uselect(start_qn).mirror();
        var attr_prop := attr_attr.leftjoin(my_ws.find("attr_prop"));
        var val_start := [*tpe](attr_prop.leftjoin(my_ws.find("prop_val"))).reverse().sort();
        var start_pre := val_start.leftjoin(my_ws.find("attr_own"));

        # now we have a table with a pre column and a start (numerical) column in the right order
        var left_pre := start_pre.reverse().mark(0@0).reverse();
        var left_start := start_pre.mark(0@0).reverse();

        # go get the pre numbers that have an end attribute
        var right_attr := my_ws.find("attr_qn").uselect(end_qn).mark(0@0).reverse();
        var right_pre := right_attr.leftjoin(my_ws.find("attr_own"));
        var right_end := [*tpe](right_attr.leftjoin(my_ws.find("attr_prop")).leftjoin(my_ws.find("prop_val")));

        # the region table is the intersection between start and end
        var left_right := left_pre.leftjoin(right_pre.reverse());
        var region_left := left_right.mark(0@0).reverse();
        var region_right := left_right.reverse().mark(0@0).reverse();

## TODO: FIXME : the following code does not work, but should assign
##               the largest possible region to the document-node
#       if (=(tpe,"lng")) {
#        region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                   .insert(region_left.leftjoin(left_pre));
#        region_start := bat(void,lng).seqbase(0@0).append(getLNG_MIN())
#                                     .insert(region_left.leftjoin(left_start));
#        region_end := bat(void,lng).seqbase(0@0).append(getLNG_MAX())
#                                   .insert(region_right.leftjoin(right_end));
#       } else {
#        region_pre := bat(void,oid).seqbase(0@0).append(0@0)
#                                  .insert(region_left.leftjoin(left_pre));
#        region_start := bat(void,INT).seqbase(0@0).append(getINT_MIN())
#                                    .insert(region_left.leftjoin(left_start));
#        region_end := bat(void,INT).seqbase(0@0).append(getINT_MAX())
#                                  .insert(region_right.leftjoin(right_end));
#       }
        region_pre := region_left.leftjoin(left_pre);
        region_start := region_left.leftjoin(left_start);
        region_end := region_right.leftjoin(right_end);
    } else {
        # if there are either no start or end nodes, the result is empty
        region_pre := bat(void,oid);
        region_start := bat(void,monet_atomtbl.find(tpe));
        region_end := bat(void,monet_atomtbl.find(tpe));
    }
    printf("# extracted %d regions\n",region_pre.count());
    my_ws.insert("_region_pre",region_pre);
    my_ws.insert("_region_start",region_start);
    my_ws.insert("_region_end",region_end);
    return my_ws;
}
ADDHELP("region_extract", "wouter", "Oct 2005",
"PARAMETERS:\n\
BAT[str,BAT] ws (Working Set)\n\
str tpe (type of region-values (int or lng))\n\
DESCRIPITON:\n\
adds three BATs to the working set REGION_PRE, REGION_START, and REGION_END and fills them.",
"pf_burk");
@

@c
#include "pf_burk.h"

int CMD_burk_enabled(bit * result) {
    if (GDKgetenv("burkowski") != NULL)
        (*result) = (bit) !strcmp(GDKgetenv("burkowski"),"enabled");
    else 
        (*result) = (bit) 0; /* appearantly false */
    return(GDK_SUCCEED);
}

/* simple stack operations for the loop-lifted burkowski join */
// TODO: test if a sorted stack could be exploited...
@:stack_procs(int,int)@
@:stack_procs(lng,long long)@

/* burkowski joins */
@:burk(lng,long long)@
@:burk(int,int)@

@:ll_burk(lng,long long)@
@:ll_burk(int,int)@

@- not implemented yet
@c
@:ffb(int, int)@
@:ffb(lng, long long)@

/* vim:set shiftwidth=4 expandtab: */
