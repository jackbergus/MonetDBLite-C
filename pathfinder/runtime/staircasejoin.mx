@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2006 University of Konstanz.  All Rights Reserved.
@'
@' $Id$

@f staircasejoin
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@t staircasejoin

@c

/*******************************************
* staircasejoin.c : staircase join operators
*
*/

#include <gdk.h>

#if 0
#define prefetch_loc(addr) \
/* Parameters */
const int PF_SOFTWARE_PREFETCH = 128;

/* software prefetching is not used currently */
  __asm__ __volatile__ ("prefetchnta %0" \
                        : \
                        : \
                        "m" (*(((char*)(size_t)(((unsigned int)(size_t)(addr))&~0x7f)))))
                            /* StM: extended casting to pacify 64-bit compilers */
#else
#define prefetch_loc(addr)
#endif

/*******************************************************************/

/* DESCENDANT STEP */
@:scj_head(_desc)@
    int max_post;
@:scj_specialcases@
@:scj_init@
    max_post = -1;
@:scj_desc(pre_cur++;)@
@:scj_end@

/* DESCENDANT-OR-SELF STEP */
@:scj_head(_descorself)@
    int max_post;
@:scj_specialcases@
@:scj_init@
    max_post = -1;
@:scj_desc()@
@:scj_end@

/* ANCESTOR STEP */
@:scj_head(_anc)@
    oid ctx_pre, post;
@:scj_specialcases@
@:scj_init@
    pre_cur = *(oid*)BUNhead(pre_size, BUNfirst(pre_size));
@:scj_anc(<)@
@:scj_end@

/* ANCESTOR-OR-SELF STEP */
@:scj_head(_ancorself)@
    oid ctx_pre, post;
@:scj_specialcases@
@:scj_init@
    pre_cur = *(oid*)BUNhead(pre_size, BUNfirst(pre_size));
@:scj_anc(<=)@
@:scj_end@


@= scj_head
int
PFscj@1_void(BAT **result, BAT *pre_size, BAT *ctx, int *height, int *upperbound)
{
    /* --------------------------- declaration ----------------------------- */

    char *name = "PFscj@1_void";
    BUN ctx_cur, ctx_last;
    oid pre_cur, *res_cur;
    int ctx_bunsize, *size;
    
    /* result bat allocation. for result size use upperbound parameter */
    BAT *res = BATnew(TYPE_oid, TYPE_void, *upperbound);

@= scj_specialcases
    /* --------------------------- special cases --------------------------- */
    if (!(BAThordered(ctx) & 1))
    {
        GDKerror("%s: context must be ordered on head.\n", name);
        return GDK_FAIL;
    }
    if (BATcount(ctx) == 0 || BATcount(pre_size) == 0)
    {
        *result = BATnew(TYPE_oid, TYPE_void, 0);
        return GDK_SUCCEED;
    }
    if (res == NULL) 
    { 
        GDKerror("%s: could not allocate a result BAT of size %d.\n", name, *upperbound);
        return GDK_FAIL;
    }

@= scj_init
    /* ----------------- initialization of table cursors ------------------- */

    res_cur = (oid*)BUNfirst(res);
    
    /* definition for "array-like" access on size values of given nodes */
    size = ((int*) BUNfirst(pre_size)) - pre_size->hseqbase;

    ALGODEBUG
        THRprintf(GDKout, "%s: node set of %u buns, context set of %u buns, height %u\n",
                          name, BATcount(pre_size), BATcount(ctx), *height);

@= scj_anc
    /* ---------------------------- main part ----------------------------- 
     * - the outer loop traverses all context nodes
     * - the inner loop writes ancestors to the result but skips preceding nodes
     *   and their descendants
     */

    BATloopFast (ctx, ctx_cur, ctx_last, ctx_bunsize)
    {
        ctx_pre = *(oid*)BUNhead(ctx, ctx_cur);
        post = pre_cur + (size[pre_cur]&GDK_int_max);
        
        while (pre_cur @1 ctx_pre)
        {
            if (post >= ctx_pre) {
                if (!(size[pre_cur]&(1<<31)))
                    *res_cur++ = pre_cur;
                pre_cur++;
            }
            else   
                /* skip preceding node and its descendants */
                pre_cur = post + 1;
            post = pre_cur + (size[pre_cur]&GDK_int_max);
        }
    }

@= scj_desc
    /* ---------------------------- main part ----------------------------- 
     * - the outer loop traverses all context nodes
     * - the inner loop writes all descendants to result 
     */

    BATloopFast (ctx, ctx_cur, ctx_last, ctx_bunsize)
    {
        pre_cur = *(oid*)BUNhead(ctx, ctx_cur);
        
        /* on-the-fly pruning of the context set */
        if ((int)pre_cur > max_post)
        {
            max_post = (size[pre_cur]&GDK_int_max) + pre_cur;
            @1
            while ((int)pre_cur <= max_post) {
                if (!(size[pre_cur]&(1<<31)))
                    *res_cur++ = pre_cur;
                pre_cur++;
            }
        }
    }

@= scj_end
    /* ---------------------------- end of main part --------------------------
     * tidy up and propagate result properties
     */

    /* mark the end point of the BUNs section in the BUNheap 
     */
    res->batBuns->free = ((BUN)res_cur) - res->batBuns->base;
    BATsetcount(res, (res->batBuns->free+Bunbase(res)-BUNfirst(res))/BUNsize(res));

    res->batDirty = TRUE;
    res->hsorted = GDK_SORTED;
    BATkey(res,TRUE);
    BATseqbase(BATmirror(res), oid_nil);
    *result = res;

    return GDK_SUCCEED;
}

@c
/* vim:set shiftwidth=4 expandtab: */
