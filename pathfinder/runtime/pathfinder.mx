@' pathfinder.mx
@'
@' XQuery runtime environment
@'
@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'
@' $Id$
@'

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@a Jan Flokstra
@a Jens Teubner
@a Stefan Manegold
@a Peter Boncz 

@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

.USE streams;

.BUILTIN xquery_server(Stream in, Stream out) : void = CMDxquery_server;
 "read xquery from stream, and print on a stream."

.BUILTIN xquery(mode str, xquery str, is_url bit) : str = CMDxquery;
 "xquery execution. parameters: mode, query, is_url (optional)
 usage:  var result := xquery(\"xml\", \"1+1\", false); printf(result);
 or:  printf(xquery(\"xml\", \"1+1\"));"

.COMMAND xquery_start_query_cache(lng maxsize) : ptr = CMDxquery_start_query_cache;
 "handle to pass to mapi_listen to let it use the query plan cache (also flushes the cache when called).
  if nonzero, the parameter is a per-connection size limit to the plan cache in bytes"

.PRELUDE = xquery_prelude;
.EPILOGUE = xquery_epilogue;

.END pathfinder;
@mil
module(mapi);       # remote client access
module(monettime); 

PROC pfstart(bit open, lng sz) : void {
    mapi_listen(int(monet_environment.find("xquery_port")), 5, "xquery_server", open, xquery_start_query_cache(sz)).fork();
}
ADDHELP("pfstart", "boncz", "April 2005",
"PARAMETERS:\n\
bit whether the listener should listen to outside requests \
(default false: only local connections).\n\
DESCRIPTION:\n\
start the xquery server.",
"pathfinder");

PROC pfstart() : void {
    pfstart(false, 0LL);
}

PROC xquery_server_start(bit global) : void {
    fork(mapi_listen(
                int(monet_environment.find("xquery_port")),
                5,
                "xquery_server",
                global
                )
        );
}

PROC xquery_server_start() : void {
    xquery_server_start(false);
}

#############################################
# User-level document management functions:
#
# - shred_doc
# - delete_doc
# - delete_all_docs
#
# Each imported XML-document is stored as a collection of persistent BATs 
# whose name starts with the name of the BAT and ends with the document ID. 
# The execution of an XQuery is not performed on the persistent BATs, but on 
# the transient 'working set', a global document collection represented
# by the ws-BAT.
#
# Each collection contains the following BATs:
# - pre_size    : BAT[oid,int]  pre-value of node / and its descendant size,
# - pre_level   : BAT[oid,chr]  pre-value of node / and its level,
# - pre_prop    : BAT[oid,oid]  pre-value of node / and property ID,
# - pre_kind    : BAT[oid,chr]  pre-value of node / and node kind,
#
# - qn_ns        : BAT[oid,str]  property ID / and name space (elements and attributes),
# - qn_loc       : BAT[oid,str]  property ID / and local name (elements and attributes),
# - prop_text    : BAT[oid,str]  property ID / and text,
# - prop_com     : BAT[oid,str]  property ID / and comment,
# - prop_ins     : BAT[oid,str]  property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  property ID / and processing instruction target,
#
# - attr_own  : BAT[oid,oid]  attribute ID / pre-value of owner
# - attr_qn   : BAT[oid,oid]  attribute ID / and qname/property ID
# - attr_prop : BAT[oid,oid]  attribute ID / value ID
#
# - prop_val  : BAT[oid,str]  value ID / value of attribute nodes
#
# Global information on persistent stored documents:
# - doc_name      : BAT[oid,str]        document ID / document name
# - doc_height    : BAT[oid,int]        document ID / height of document
# - doc_size      : BAT[oid,lng]        document ID / size in bytes
# - doc_timestamp : BAT[oid,timestamp]  document ID / end-of-cache-time (nil if none)
# - uri_lifetime  : BAT[str,lng]        URI prefix  / time-to-live (seconds), nil if not to be cached 
# 
# Information on documents/fragments in the working set:
# - PRE_FRAG   : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each pre value (copied in element construction)
# - ATTR_FRAG  : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each attr value (copied in element/attribute 
#                construction)
# - DOC_LOADED : BAT[void,str] fragment ID / name of document 
#                (starts with 1@0 because WS is first 'loaded' document
# - FRAG       : BAT[void,oid] 0@0 / oid of the newest added fragment
# - WS_FRAG    : BAT[void,oid] enumeration / root-pre values of
#                generated element fragments
# - HEIGTH     : BAT[void,int] enumeration of the fragments / maximal
#                depth of the fragment (starts with 0@0 - WS)

module(pf_support); 

# get a handle to the global lock
var pf_lock := pflock(); 

# note that these variables may not be shared by parallel MIL clients
var doc_query; # bat[oid,int] active working-sets (queries) that use a particular document 
var doc_sema;  # bat[oid,sema] used by delete_doc to wait until all doc users have gone

# initialize doc_query and doc_sema (use BBP as global mechanism to discover initialization)
lock_set(pf_lock);
if (not(isnil(CATCH(bat("doc_name").count())))) {
    # create doc_name table in case it does not exist
    new(oid,str).persists(true).bbpname("doc_name");
    new(oid,str).persists(true).bbpname("doc_location");
    new(oid,timestamp).persists(true).bbpname("doc_timestamp");
    new(oid,int).persists(true).bbpname("doc_height");
    new(oid,lng).persists(true).bbpname("doc_size");
    new(str,lng).persists(true).bbpname("uri_lifetime");
}
if (isnil(CATCH(bat("doc_query").count()))) {
    doc_query := bat("doc_query"); 
    doc_sema := bat("doc_sema"); 
} else {
    (doc_query := new(oid,int)).bbpname("doc_query"); 
    (doc_sema := new(oid,monet_atomtbl.find("sema"))).bbpname("doc_sema"); 
}
lock_unset(pf_lock);

# DEFINITION of constants concerning the data model
const PRE_BASE := 0@0;
const ELEMENT := chr(0);
const TEXT := chr(1);
const COMMENT := chr(2);
const PI := chr(3);
const DOCUMENT := chr(4);
const WS := 0@0;

@- ws definition

This macro is used for the MIL const defs, the C const defs,
but also in the MIL procs for creating, filling and destroying
a working set.

We define a table with the column name, its number,
the type of data (typically again a bat), and if
so the head and tail type of that bat.

actually the field 'tpe' is taken to be bat *always*, 
EXCEPT when (child-T == void)

('tpe' = void means it is a view; without persistent name)

        name       number  tpe  col[H,T]    col-seqbase 
        ========   ======  ===  ==========  ===========
@= ws
@:@1_ws(PRE_SIZE,       0, bat, void,  int, PRE_BASE)@
@:@1_ws(PRE_LEVEL,      1, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_PROP,       2, bat, void,  oid, PRE_BASE)@
@:@1_ws(PRE_KIND,       3, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_FRAG,       4, void,void,  oid, PRE_BASE)@
@:@1_ws(QN_URI,         5, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_PREFIX,      6, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_LOC,         7, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TEXT,      8, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_COM,       9, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_INS,      10, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TGT,      11, bat, void,  str, PRE_BASE)@
@:@1_ws(ID_PRE,        12, bat,  str,  oid, nil)@
@:@1_ws(IDREF_PRE,     13, bat,  str,  oid, nil)@
@:@1_ws(ATTR_OWN,      14, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_QN,       15, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_PROP,     16, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_FRAG,     17, void,void,  oid, PRE_BASE)@
@:@1_ws(PROP_VAL,      18, bat, void,  str, PRE_BASE)@
@:@1_ws(DOC_LOADED,    19, str, void, void, nil)@
@:@1_ws(FRAG,          20, oid, void, void, nil)@
@:@1_ws(WS_FRAG,       21, oid, void, void, nil)@
@:@1_ws(HEIGHT,        22, int, void, void, nil)@
@:@1_ws(QN_PREFIX_URI, 23, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_LOC_URI,    24, bat, void,  str, PRE_BASE)@
@:@1_ws(KIND_PRE_0,    25, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_1,    26, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_2,    27, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_3,    28, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_4,    29, bat, void,  oid, nil)@
@:@1_ws(PROP_PRE_0,    30, bat,  oid,  oid, nil)@
@:@1_ws(PROP_PRE_3,    31, bat,  oid,  oid, nil)@

@-
BEWARE: WS_SIZE (below) should *always* be the size of ws (above)

@= decl
@:@1_decl_ws(WS_SIZE, 32)@
@:@1_decl_ws(QNAME,    2)@
@:@1_decl_ws(BOOL,     3)@
@:@1_decl_ws(INT,      4)@
@:@1_decl_ws(DEC,      5)@
@:@1_decl_ws(DBL,      6)@
@:@1_decl_ws(STR,      7)@
@:@1_decl_ws(U_A,      8)@
@:@1_decl_ws(ATOMIC,  31)@
@:@1_decl_ws(NODE,    32)@
@:@1_decl_ws(ELEM,    33)@
@:@1_decl_ws(ATTR,    34)@

@= mil_decl_ws
const @1 := @2;
@mil
@:ws(mil_decl)@
@:decl(mil)@

const KIND_PRE := KIND_PRE_0;
const PROP_PRE := PROP_PRE_0;

# ATOMIC is not a type but all atomic types
# can be retrieved with 'select(int(nil),ATOMIC)'

# NODE is not a type but all node types
# can be retrieved with 'select(NODE,int(nil))'

@= create_ws
    ws_nme.insert(nil,toLower("@1"));
    ws_oid.insert(nil,oid(@1));
    ws_tpe.insert(nil,@3);
    ws_htp.insert(nil,@4);
    ws_ttp.insert(nil,@5);
    ws_seq.insert(nil,@6);
@mil
# the ws_* bats contain a recipe for creating a new ws
var ws_nme := bat(void,str,WS_SIZE); 
var ws_oid := bat(void,oid,WS_SIZE); 
var ws_tpe := bat(void,int,WS_SIZE); 
var ws_htp := bat(void,int,WS_SIZE); 
var ws_ttp := bat(void,int,WS_SIZE); 
var ws_seq := bat(void,oid,WS_SIZE); 
@:ws(create)@
ws_nme.access(BAT_READ).seqbase(0@0);
ws_oid.access(BAT_READ).seqbase(0@0);
ws_tpe.access(BAT_READ).seqbase(0@0);
ws_htp.access(BAT_READ).seqbase(0@0);
ws_ttp.access(BAT_READ).seqbase(0@0);
ws_seq.access(BAT_READ).seqbase(0@0);

PROC ws_bat(int tpe, int htp, int ttp, oid seq) : BAT[void,any]
{
    if (ttp != void) { # a bat of bats (persistent or view)
        var b := bat(htp,ttp);
        if (not(isnil(seq))) b.seqbase(seq); 
        return bat(void,bat).seqbase(PRE_BASE).insert(nil, b);
    } 
    return bat(void,tpe).seqbase(PRE_BASE); # a constant bat
}

PROC create_ws () : BAT[void,bat]
{
    var ws := [ws_bat](ws_tpe, ws_htp, ws_ttp, ws_seq);

    # fill the constant bats with initial values
    ws.fetch(DOC_LOADED).seqbase(1@0);
    ws.fetch(FRAG).seqbase(0@0).insert(0@0,nil);
    ws.fetch(HEIGHT).seqbase(0@0).insert(nil,0);
    return ws.access(BAT_READ);
}

PROC destroy_ws_locked(BAT[void,bat] ws) : void
{
    doc_query.select(int(ws))@batloop() {
        var doc_oid := $h;
        doc_query.delete(doc_oid, int(ws));
        if (not(doc_query.exist(doc_oid))) {
            if (doc_sema.exist(doc_oid)) {
                sema_up(doc_sema.find(doc_oid));
            }
        }
    }
    # determine whether a cache flush is desired (only count cached bats, those with a timestamp)
    var cursize := sum(bat("doc_timestamp").select(timestamp(nil),timestamp(nil)).mirror().join(bat("doc_size")));
    var maxsize := (1024LL * 1024LL) * lng(monet_environment.find("xquery_cacheMB"));

    if (cursize > maxsize) {
        delete_all_docs_locked(true);
    }
}

PROC destroy_ws(BAT[void,bat] ws) : void
{
    var err;

    if (type(doc_query) != bat) { return; }

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(destroy_ws_locked(ws));
    lock_unset(pf_lock);

    if (not(isnil(err))) { ERROR(err); }
}

PROC shred_doc_locked(BAT[str,bat] docBAT, str location, str name, timestamp ts, int ws, int height) : void 
{
    # get a new persistent doc id
    var doc_oid := 0@0;
    if (bat("doc_name").count() > 0) 
        doc_oid := oid(int(bat("doc_name").reverse().max()) + 1); 

    # rename all new bats with the doc id as suffix
    [rename](docBAT, [+](mirror(docBAT), str(int(doc_oid))));
    var totsize := sum([batsize](docBAT));

    # add to meta table
    bat("doc_name").insert(doc_oid, name);
    bat("doc_location").insert(doc_oid, location);
    bat("doc_timestamp").insert(doc_oid, ts);
    bat("doc_height").insert(doc_oid, height);
    bat("doc_size").insert(doc_oid, totsize);

    [persists](docBAT, true);

    # add the meta table to the commit set 
    #docBAT.insert(str(nil),bat("doc_name"));
    #docBAT.insert(str(nil),bat("doc_location"));
    #docBAT.insert(str(nil),bat("doc_timestamp"));
    #docBAT.insert(str(nil),bat("doc_height"));
    #docBAT.insert(str(nil),bat("doc_size"));
    #if (not(subcommit(docBAT))) 
    if (not(commit())) ERROR("shred_doc(%s) : commit failed\n");

    if (not(isnil(ws))) {
        pin_doc(doc_oid, ws);
    }
}

PROC construct_docBAT(BAT[oid,bat]resbat, str name, bit doCommit, str opt, timestamp ts, int ws) : BAT[str, bat]
{
    var err, exists := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(exists := bat("doc_name").texist(name));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
    else if (exists) ERROR("shred_doc(%s): already exists in database!\n", name);

    # shred it unlocked
    var docBAT := new(str,bat,WS_SIZE); # contains all new bats
    var us := usec();

    # insert all bats from resBAT in docBAT
    var ins := ws_tpe.ord_uselect(bat).mirror().ord_select(nil,oid(-(DOC_LOADED,1))).mirror();
    [insert](const docBAT, ins.leftfetchjoin(ws_nme), ins.leftfetchjoin(ws_oid).leftjoin(shredRES));

    # these are simple concatenations (to accelerate combPRINT_WS_SZined lookup)
    docBAT.insert("qn_prefix_uri", docBAT.find("qn_prefix").[+](str('\1')).[+](docBAT.find("qn_uri")));
    docBAT.insert("qn_loc_uri",    docBAT.find("qn_loc").[+](str('\1')).[+](docBAT.find("qn_uri")));

    # create our indices
    var knd := ELEMENT;
    while ( knd <= DOCUMENT ) {
        docBAT.insert("kind_pre" + "_" + str(chr(48 + knd)),
                      docBAT.find("pre_kind").ord_uselect(knd).reverse().chk_order());
        knd :+= chr(1);
    }

    var knd_pre_bat := docBAT.find("kind_pre" + "_" + str(chr(48 + ELEMENT))).reverse().mirror();
    var prop_pre_bat := knd_pre_bat.leftfetchjoin(docBAT.find("pre_prop")).reverse().chk_order();
    if (not(ordered(prop_pre_bat))) {
        var _prop := prop_pre_bat.hmark(0@0);
        var _pre  := prop_pre_bat.tmark(0@0);
        var ord := _prop.tsort();
            ord := ord.CTrefine(_pre).mark(nil);
        prop_pre_bat := prop_pre_bat.fetch(ord);
        prop_pre_bat := prop_pre_bat.chk_order();
    }
    docBAT.insert("prop_pre" + "_" + str(chr(48 + ELEMENT)), prop_pre_bat);

    knd_pre_bat := docBAT.find("kind_pre" + "_" + str(chr(48 + PI))).reverse().mirror();
    prop_pre_bat := knd_pre_bat.leftfetchjoin(docBAT.find("pre_prop")).reverse().chk_order();
    if (not(ordered(prop_pre_bat))) {
        var _prop := prop_pre_bat.hmark(0@0);
        var _pre  := prop_pre_bat.tmark(0@0);
        var ord := _prop.tsort();
            ord := ord.CTrefine(_pre).mark(nil);
        prop_pre_bat := prop_pre_bat.fetch(ord);
        prop_pre_bat := prop_pre_bat.chk_order();
    }
    docBAT.insert("prop_pre" + "_" + str(chr(48 + PI)), prop_pre_bat);

    height := shredRES.fetch(PRE_LEVEL).max().int() + 1;

    docBAT := docBAT.access(BAT_READ);
    if (doCommit) {
        [mmap](docBAT, [ifthenelse]([<]([count](docBAT), 65536), STORE_MEM, STORE_MMAP));
        [save](docBAT);

        # add doc to the database locked
        lock_set(pf_lock);
        err := CATCH(shred_doc_locked(docBAT, location, name, ts, ws, height));
        lock_unset(pf_lock);

        if (not(isnil(err))) ERROR(err);
    }
    return docBAT;
}

# HACK: overwrite 'height'
PROC shred_doc_impl(str location, str name, bit doCommit, str opt, timestamp ts, int ws) : BAT[str,bat]
{
    var shredRES := shred2bats(location,"",opt);
    return construct_docBAT(shredRES, name, doCommit, opt, ts, ws);
}

PROC shred_doc_base(str location, str name, bit doCommit, str opt) : BAT[str,bat]
{
    var height, us := usec();
    var docBAT := shred_doc_impl(location, name, doCommit, opt, timestamp(nil), int(nil));
    # save all persistent BATs and print timings
    us := usec() - us;
    var ms := us/1000;
    if ( doCommit ) {
        printf("# Shredded XML doc(\"%s\"), total time after commit=%lld.%03llds\n", name, /(ms,1000),%(ms,1000));
    } else {
        printf("# Shredded XML doc(\"%s\") uncommitted, total time =%lld.%03llds\n", name, /(ms,1000),%(ms,1000));
    }
    return docBAT;
}

PROC shred_doc(str location, str name) : void
{
    shred_doc_base(location, name, true, "");
}
ADDHELP("shred_doc", "flokstra", "Dec 2004",
"PARAMETERS:\n\
- str URI containing the xml document to be shredded)\n\
- str document name ('alias') in database\n\
DESCRIPTION:\n\
Shred xml document to the internal Pathfinder format, (analog to import_doc()).",
"pathfinder");

PROC delete_doc_locked(oid doc_oid) : bit
{
    var docBAT := new(void,str,WS_SIZE);

    if (doc_sema.exist(doc_oid)) {
        # somebody else is deleting the same doc!
        while(doc_sema.exist(doc_oid)) {
            lock_unset(pf_lock);
            sleep(1);
            lock_set(pf_lock);
        }
        return; # now he is done
    }
    # we will delete it
    while (doc_query.exist(doc_oid)) {
        var sem := sema_create(0);
        doc_sema.insert(doc_oid, sem);

        lock_unset(pf_lock);
        sema_down(sem); # wait for the users to go away 
        lock_set(pf_lock);

        sema_destroy(sem);
        doc_sema.delete(doc_oid, sem);
    }

    # docBAT becomes [name,bat]
    docBAT := [bat]([+](ws_tpe.uselect(bat).mirror().join(ws_nme), str(int(doc_oid))).reverse().mirror());

    # rename the bats so even in case of failure they don't bother us directly anymore
    [rename](docBAT, [+]([+]("rm_", mirror(docBAT)), +("_" , str(lng(current_timestamp()))))).access(BAT_WRITE);

    # remove them from the repository
    [persists](docBAT, false);

    bat("doc_name").delete(doc_oid);
    bat("doc_location").delete(doc_oid);
    bat("doc_timestamp").delete(doc_oid);
    bat("doc_height").delete(doc_oid);
    bat("doc_size").delete(doc_oid);

    # also commit the meta bats
    #docBAT.insert(str(nil), bat("doc_name"));
    #docBAT.insert(str(nil), bat("doc_location"));
    #docBAT.insert(str(nil), bat("doc_timestamp"));
    #docBAT.insert(str(nil), bat("doc_height"));
    #docBAT.insert(str(nil), bat("doc_size"));
    #return subcommit(docBAT);
    return commit();
}

PROC delete_doc(str name) : void
{
    var err, exists := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(exists := bat("doc_name").texist(name));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
    else if (not(exists)) ERROR("delete_doc(%s): document not found in database!\n", name);

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_doc_locked(bat("doc_name").reverse().find(name)));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
}
ADDHELP("delete_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
str document name\n\
DESCRIPTION:\n\
delete the persistent BATS that store the document.",
"pathfinder");

PROC delete_all_docs_locked(bit cachedOnly) : void
{
    bat("doc_timestamp").copy()@batloop() {
        if (or(cachedOnly, not(isnil($t))))
            delete_doc_locked($h);
    }
}

PROC delete_all_docs(bit cachedOnly) : void
{
    var err, b := bat(timestamp,str);

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_all_docs_locked(cachedOnly));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
}
ADDHELP("delete_all_docs", "tsheyar", "July 2004",
"DESCRIPTION:\n\
deletes all persistent document BATs that store xml documents.",
"pathfinder");


PROC pin_doc(oid doc_oid, int ws) : void 
{
    # pin the document on this working set (must hold lock!)
    doc_query.insert(doc_oid, int(ws));
}

# HACK: this proc overwrites variables 'lifetime' and 'ts'
PROC add_doc_locked(str name, int ws) : oid
{
    var doc_oid := nil;
    var filename := name;
    var lim := timestamp(nil);

    # check if the document already existed
    if (bat("doc_name").texist(name)) {
        doc_oid := bat("doc_name").reverse().find(name);
    } else if (bat("doc_location").texist(name)) {
        # existed as cached location (URI): must check timestamp
        var doc_oid := bat("doc_location").reverse().find(name);
    }

    # do some first analysis on the URI
    if (not(isnil(doc_oid))) { 
        filename := bat("doc_location").find(doc_oid);
        lim := bat("doc_timestamp").find(doc_oid);
    }

    if (startsWith(filename, "file://") or startsWith(filename, "FILE://")) {
        filename := string(filename, 7);
    } else {
        idx := search(filename, "://");
    }
    if (idx >= 0) {
        # add uri-dependent lifetime
        var uri_lifetime := bat("uri_lifetime");
        var b := [startsWith](filename, mirror(uri_lifetime)).uselect(true);
        if (b.count() > 0) {
            var matchlen := [length](mirror(b));
            lifetime := *(1000LL, uri_lifetime.find(matchlen.reverse().find(matchlen.max())));
        } else {
            lifetime := lng(nil); # doc will *not* be cached 
        }
    } else {
        # a file: get lastmodification time
        var tts;
        var err := CATCH(tts := lastmod_time(filename));
        if (isnil(err)) {
            ts := tts; # timestamp was read succesfully
        } else if (not(isnil(lim))) {
            ts := add(lim, 1LL); # file-error on cached file: force remove
        }
    }

    if (isnil(doc_oid)) {
        return nil; # document not in database
    } else if (and(not(isnil(lim)), >(ts,lim))) { # if so, check if it still valid
        # remove outdated document from the cache
        delete_doc_locked(doc_oid); 
        return nil;
    }
    pin_doc(doc_oid, ws); # make sure nobody can delete it
    return doc_oid;
}

PROC add_docbat(BAT[void,bat] ws, BAT[str,bat] docBAT, str name, str docid, int height) : oid
{
    # add it to the working set
    var frag := ws.fetch(DOC_LOADED).uselect(name);

    if (frag.count() = 0) {
        ws.fetch(DOC_LOADED).insert(nil,name);
        frag := oid(ws.fetch(DOC_LOADED).count());

        # use the ws_* bats to add all bats to the working set in a multiplex
        var src := ws_tpe.ord_uselect(bat).mirror().leftfetchjoin(ws_nme);
        var dst := src.mirror().leftfetchjoin(ws);
        if (docid != "") 
            # if docid != "", it holds the str(id) of the persistent doc
            src := [bat]([+](src, docid));
        else
            # if not, the temporary document has been shredded into docBAT
            src := src.leftjoin(docBAT);
        [insert](dst, nil, src);

        # create views
        ws.fetch(PRE_FRAG).insert(nil,constant2bat(frag));
        ws.fetch(ATTR_FRAG).insert(nil,constant2bat(frag));

        # adapt constants
        ws.fetch(FRAG).replace(0@0,frag);

        if (isnil(height))
          height := ws.fetch(PRE_LEVEL).max().int() + 1;
        ws.fetch(HEIGHT).insert(nil,height);
     } else { 
        ws.fetch(FRAG).replace(0@0,frag.reverse().fetch(0)); 
     }
     return frag;
}

var time_shred := 0; # dummy declarartion to avoid errors when timing is not activated in the script

# HACK: this proc overwrites variable 'time_shred' 
PROC add_doc(BAT[void,bat] ws, str name) : BAT[void,bat]
{
    var ts := current_timestamp();
    var lifetime := 0LL;
    var idx := -1;
    var doc_oid;
    var err, height;
    var t := time();

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(doc_oid := add_doc_locked(name, int(ws)));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);

    var docBAT, docid := "", doCommit := true;

    if (isnil(doc_oid)) {
        ts := add(ts, lifetime);
        if (isnil(ts)) doCommit := false;
        docBAT := shred_doc_impl(name, name, doCommit, "", ts, int(ws));
        # overwrites 'height'
        time_shred :+=  time() - t;
    } else {
        docBAT := new(str,bat);
    }
    if (doCommit) { 
        docid := str(int(bat("doc_name").reverse().find(name)));
        height := bat("doc_height").find(oid(int(docid)));
    }
    add_docbat(ws, docBAT, name, docid, height);  
    return ws;
}


@- xml document cache
When fn:doc() is used with a previously unseen URI, it is shredded on the fly and placed into 
the xml document cache (see text below). A number of procs are provided to monitor
and control the behavior of the cache.
@mil
const xmlcache_help := 
"The XML document cache keeps indexed copies of documents that where recently\n\
used in the fn:doc(URI) xquery function.\n\
\n\
The size of the cache is controlled using the 'xquery_cacheMB' setting in\n\
the 'MonetDB.conf' file.\n\
\n\
For file URIs, the cache looks at the last-modification-time of the file on disk\n\
to guarantee that the cached document is still up-to-date for answering queries from.\n\
\n\
For other URIs, *lifetime rules* determine how long documents can stay in the cache.\n\
Each lifetime rule consists of a URI prefix and the registered seconds of lifetime.\n\
\n\
The rule with longest prefix that matches an URI counts. Specifying a lifetime\n\
of 'int(nil)' seconds means that the URI will *not* be cached at all.\n\
This is also the default if no prefix matches an URI.\n\
\n\
The name of a cached document is the same as its location (URI). For explicitly\n\
shredded documents (with 'shred_doc(location,name)'), the name is an 'alias' and\n\
may differ from the URI. Explicitly shredded documents fall outside the XML document\n\
cache; documents are only removed at explicit user request (with 'delete_doc(name)').";

PROC xmlcache_add_rule(str uri, any lifetime) : void {
    xmlcache_add_rule(uri, lng(lifetime)); 
}
PROC xmlcache_add_rule(str uri, lng lifetime) : void {
    lock_set(pf_lock);
    var err := CATCH({ bat("uri_lifetime").delete(uri); bat("uri_lifetime").insert(uri, lifetime); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_add_rule", "boncz", "May 2005",
"DESCRIPTION:\nadd a new URI lifetime rule.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_del_rule(str uri) : void {
    lock_set(pf_lock);
    var err := CATCH({ bat("uri_lifetime").delete(uri);});
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_del_rule", "boncz", "May 2005",
"DESCRIPTION:\ndeletes an existing URI lifetime rule.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_print_rules() : void {
    lock_set(pf_lock);
    var err := CATCH({  table(bat("uri_lifetime").hmark(0@0).col_name("URI-prefix"), bat("uri_lifetime").tmark(0@0).col_name("liftime-secs")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_print_rules", "boncz", "May 2005",
"DESCRIPTION:\nshows all URI lifetime rules.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_print() : void {
    lock_set(pf_lock);
    var err := CATCH({  table(bat("doc_name").col_name("alias"), bat("doc_location").col_name("URI"), bat("doc_size").col_name("size"), bat("doc_timestamp").select(timestamp(nil),timestamp(nil)).col_name("valid-thru")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_print", "boncz", "May 2005",
        "DESCRIPTION:\nshows the actual content of the XML document cache.\n\n" + xmlcache_help,  "pathfinder");

PROC xmldb_print() : void {
    lock_set(pf_lock);
    var err := CATCH({  table(mirror(bat("doc_timestamp").uselect(timestamp(nil))).join(bat("doc_name")).col_name("alias"), bat("doc_location").col_name("URI"), bat("doc_size").col_name("size")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmldb_print", "boncz", "May 2005",
"DESCRIPTION:\nshows the actual content of the persistent XML document database (not the XML document cache).\n\nThis consists of all documents explicitly shredded with shred_doc(URI, alias).",  "pathfinder");

@= c_decl_ws
#define @1 @2
@h
#ifndef PATHFINDER_H
#define PATHFINDER_H

#include <monettime.h>
#include <lock.h>
#include <monet.h>
#include <monet_context.h>
#include <monet_interpreter.h>
#include <streams.h>
#include <mapi.h>
#include <sys.h>
#include <pathfinder.proto.h>

#define is_fake_project(b) (((b)->htype==TYPE_void) && (BATcount(b)==1) && ((b)->hseqbase==oid_nil))

@:ws(c_decl)@
@:decl(c)@

#define XTRACT_KIND(X)  (X & 63)
#define XTRACT_FRAG(X)  (X >> 6)

/* xquery_method : execute a loop-lifted xquery function
 *
 * argc          = #params
 * itercnt       = #iterations
 * argcnt[iter]  = #items per param 
 * argtpe[]      = xquery type of each parameter (as string, e.g. 'xs:integer')
 * argval[]      = str representation of item (e.g. '42')
 *
 * docBAT   = optional shredded document table, that is added to working set
 *            params of type xs:anyNode are represented as int pre-numbers.
 *
 * we return an error string, or NULL iff everything went A-OK  
 */
char*
xquery_method(stream *out, 
              char* module, 
              char *method, 
              int argc, 
              int itercnt, 
              int** argcnt, 
              str* argtpe, 
              str* argval, 
              BAT* docBAT);

#endif
@c
#include "pathfinder.h"

#define XQUERY_BUFSIZE 16364

/* the xquery builtin type hierarchy */
typedef struct {
    int parent;
    int monet_tpe;
    int kind;
    char* name;
} xquery_type;

#define DOCBAT (ELEM | (1<<6))
#define XQUERY_TYPES 15

xquery_type xquery_types[XQUERY_TYPES+1] =
{ {  5, TYPE_bit, BOOL,   "xs:bool"  },  
  {  2, TYPE_lng, INT,    "xs:integer" },
  {  4, TYPE_dbl, DEC,    "xs:decimal" },
  {  4, TYPE_dbl, DBL,    "xs:float" },
  {  5, TYPE_dbl, DBL,    "xs:double" },
  {  7, TYPE_str, STR,    "xs:string" },
  {  8, TYPE_str, STR,    "xs:untypedAtomic" },
  {  8, TYPE_str, STR,    "xdt:anyAtomicType" },
  {  9, TYPE_str, STR,    "xs:anySimpleType" },
  { 14, TYPE_str, STR,    "xs:anyType" },
  { 14, TYPE_str, STR,    "xdt:untypedAny" },
  { 13, TYPE_oid, DOCBAT, "xs:anyElement" },
  { 13, TYPE_oid, DOCBAT, "xs:anyAttribute" },
  { 14, TYPE_oid, DOCBAT, "xs:anyNode" },
  { 15, TYPE_oid, DOCBAT, "xs:anyItem" },
  {  0, TYPE_oid, DOCBAT, "illegal type" } };

/*
 * return xquery type number, given a type string
 */
static int
xquery_typenr(char* tpe) 
{
    int i;
    for(i=0; i<XQUERY_TYPES; i++) 
        if (strcmp(tpe, xquery_types[i].name) == 0) break;
    return i;
}

/*
 * find the common ancestor of two xquery types
 */
static int
xquery_type_common_ancestor(int t1, int t2) 
{
    if (t1 < 0 || t1 >= XQUERY_TYPES) return t2;
    if (t2 < 0 || t2 >= XQUERY_TYPES) return t1;
    while(t1 != t2) {
        if (t1 < t2) t1 = xquery_types[t1].parent;  
        else         t2 = xquery_types[t2].parent;  
    }
    return t1;
} 

/* representation of a xquery function signature */
typedef struct {
    int argc;                     /* number of params */
    unsigned int zero;            /* bit-mask that indicates whether param (bit) i can be the empty sequence */
    unsigned int multiple;        /* bit-mask that indicates whether param (bit) i can be a sequence */
    unsigned char tpe[MAXPARAMS]; /* xquery type number (point into above xquery_types table) */
    char name[1];                 /* method name */
} xquery_sig;


/* xquery functions */
typedef struct _xquery_function {
    struct _xquery_function *next;
    oid vid;                      /* vid of first param */
    lng size;                     /* byte size of prepared tree */
    xquery_sig *sig;              /* method signature */
    char* mil;                    /* generated MIL */
    char  proc[1];                /* MIL procname */
} xquery_function;


/* xquery modules */
typedef struct _xquery_module {
    struct _xquery_module *next;
    char* prologue;               /* MIL procs defined in this module */
    char* epilogue;               /* MIL procs undefs for this module */
    xquery_function *functions;   /* functions declared in this module */
    char url[1];                  /* module url */
} xquery_module;

/* global list of known modules and their function declarations */
xquery_module *xquery_compiled_modules = NULL;


/* cached functions */
typedef struct _xquery_prepared_function {
    struct _xquery_prepared_function *next;
    xquery_function *def;         /* function definition */
    YYSTREE lt;                   /* cached MIL tree */
    unsigned int lru;             /* least recently used stamp */
} xquery_prepared_function;

unsigned int xquery_lru = 0;

/* loaded modules */
typedef struct _xquery_loaded_module {
    struct _xquery_loaded_module *next;
    xquery_module* def;           /* module definition */
    char* ns;                     /* namespace under which the module was loaded */
    int nslen;
} xquery_loaded_module;


/* cached MIL client + Xquery specific context */
typedef struct {
    int inuse; 

    /* xquery_clients[stk].stk == stk; MIL client is monet_clients[stk] */
    Cntxt stk; /* stack to execute module prologues and non-cacheable queries in */  

    /* MIL child context of ctx->stk; it is marked as a reusable stack frame so variable records are kept */
    Cntxt repeat_stk; /* stk to execute the prepated function trees in  for fast reuse */ 

    /* last MIL variable that should be cleared after execution */ 
    Variable lastvar; 

    /* value parsing buffer reuse */
    int vallen;
    ptr val;

    /* query buffer reuse */
    size_t buflen;
    char *buf;
        
    /* error stream (normally fderr=GDKerr=GDKout) */
    stream *fderr;

    /* live BAT handles (note we gave them a memory refcount in BBP) */
    BAT *proc_vid, *var_usage;
    BAT *dbl_values, *int_values, *str_values;
    BAT *fun_vid000, *fun_iter000, *fun_item000, *fun_kind000, *loop000;

    /* pointers into MIL variable records (to set values) */
    int *docBAT; 
    int *time_compile; 
    char **genType;

    /* counts used to remove query (non-module) procs and stacks after execution */
    size_t var_usage_size; 
    size_t proc_vid_size;

    /* size of the cached procs */
    size_t cachesize;

    xquery_prepared_function* prepared_functions;
    xquery_loaded_module *loaded_modules; 
} xquery_client;

/* xquery context cache corresponds slot-by-slot with monet_clients */
xquery_client xquery_clients[MAXCLIENTS + 1];

size_t xquery_client_bytes = 64<<20; /* 64MB of procs should be enough for anyone */

MT_Lock pf_compiler_lock;
MT_Lock pf_module_lock;
MT_Lock pf_cache_lock;

#include "compile_interface.h"

/*
 * =================== MIL execution ================================
 *
 * int     
 * xquery_tree_exec(xquery_client *ctx, YYSTREE t, int repeat) { 
 * - execute parsed MIL tree
 *
 * YYSTREE 
 * xquery_mil2tree(xquery_client *ctx, char* buf) { 
 * - parse MIL buffer into a tree
 *
 * int
 * xquery_mil_exec(xquery_client *ctx, char* buf, int debug) { 
 * - execute MIL buffer (parse & execute)
 *
 * int
 * xquery_compile_exec(xquery_client *ctx, char *mode, char* xquery, int is_url, 
 *                     char** prologue, char** query, char** epilogue) 
 * - translate xquery to MIL and execute
 *
 * all int-returning functions return error(0)/ok(1)
 */

/*
 * execute parsed MIL tree, return error(-1)/ok(0)
 */
static int 
xquery_tree_exec(xquery_client *ctx, 
                 YYSTREE t, 
                 int repeat) 
{ 
    ValRecord res;
    int ret = interpret(repeat?ctx->repeat_stk:ctx->stk, t, &res);
    if (ret == -TOK_RETURN) {
        /* ignore return value here */
        VALclear(&res);
        ret = 1;
    } else if (ret >= 0) {
        ret = 1;
    } else {
        ret = 0;
    }
    CLEANUP(t);
    return ret;
}

/*
 * parse MIL buffer into a tree
 */
static YYSTREE 
xquery_mil2tree(xquery_client *ctx, 
                char* buf) 
{ 
    Client c = monet_clients + ctx->stk;
    YYSTREE ret = NULL, treebak = c->tree;
    char* bufbak = c->input;
    int listing_bak = c->listing;
    c->listing = 0;
    c->input = buf;
    c->tree = NULL;
    if (parseClient(c, FALSE))
        ret = c->tree;
    c->tree = treebak;
    c->input = bufbak;
    c->listing = listing_bak;
    return ret;
}

/*
 * execute MIL buffer (parse & execute), return error(-1)/ok(0)
 */
static int 
xquery_mil_exec(xquery_client *ctx,  
                char* buf, 
                int debug) 
{
    int ret = 0;
    YYSTREE t;

    if (debug)
        stream_write(ctx->fderr, buf, strlen(buf), 1);

    t = xquery_mil2tree(ctx, buf); 
    if (t) {
        ret = xquery_tree_exec(ctx, t, 0);
        Myyfree(t);
    }
    return ret;
}

/*
 * translate xquery to MIL and execute, return error(-1)/ok(0)
 * We collect the MIL scripts in three sections (prologue,query,epilogue).
 * The query may be NULL, in which case we mean that it should be ignored. 
 */
#define PFURLCACHE(fcn, query, cache) {\
    char *url = query;\
    query = PFurlcache(url, cache);\
    if (query == NULL) {\
        err = (char*) alloca(strlen(url)+80);\
        sprintf(err, "%s(%s): could not retrieve query\n", fcn, url);\
}    }
static int
xquery_compile_exec(xquery_client *ctx, 
                    char *mode,  
                    char* xquery, 
                    int is_url, 
                    char** prologue, 
                    char** query, 
                    char** epilogue)
{
    int is_mil = 0, len=0, ret = 0, debug = strstr(mode,"debug") != NULL;
    char *mapi = strstr(mode, "mapi")?"=":"";
    char *err = NULL;

    MT_set_lock(pf_compiler_lock, "xquery_compile_exec");
    if (is_url) {
        int l = strlen(xquery);
        is_mil = (l > 4 && xquery[l-4] == '.' && xquery[l-3] == 'm' && xquery[l-2] == 'i' && xquery[l-1] == 'l');
        PFURLCACHE("xquery_compile_exec", xquery, !is_mil);
    }
    if (err == NULL) {
        char *del = NULL;
        if (is_mil && query == NULL) {
            *prologue = xquery; *epilogue = NULL;
        } else {
            err = PFcompile_MonetDB(xquery, mode, prologue, &del, epilogue);
        }
        if (err == NULL || (prologue && *prologue) || (del && *del)) {
            ret = 1; /* no errors, or some MIL script came out still */
        }
        if (query) {
            *query = del;
        } else if (del) {
            free(del); /* we are ignoring the query part apparently */
        }
    }
    if (err) {
        len = strlen(err);
        if (*mapi) {
            /* put ! before error lines */
            char *p = err, *q = err;
            while (*p) {
                if (*p++ == '\n')
                    len++;
            }
            err = (char*) alloca(len+3);
            *err = '!'; 
            for (p = err + 1; *q; q++) {
                *p++ = *q;
                if (*q == '\n')
                    *p++ = '!'; 
            }
            /* guard against errors that do not terminate in a newline */
            if (q > err && q[-1] != '\n')
                *p++ = '\n';
            else if (p[-1] == '!')
                p--;
            *p = 0;
            len = p - err;
        }
    }
    MT_unset_lock(pf_compiler_lock, "xquery_compile_exec");
    
    /* write errors and debug info on client stream */
    if (err && *err) stream_write(ctx->fderr, err, len, 1);

    /* execute the three MIL sections */
    if (ret && *prologue && **prologue)
        ret = xquery_mil_exec(ctx, *prologue, debug);

    if (ret && query) {
        if (*query && **query)
            ret = xquery_mil_exec(ctx, *query, debug);

        if (ret && *epilogue && **epilogue)
            ret = xquery_mil_exec(ctx, *epilogue, 0);
    }
    return ret;
}

/*
 * =================== function admin ================================
 *
 * xquery_sig*
 * xquery_sig_init(char *proc)
 * - infer the xquery function signature from the mangled MIL procname (return NULL on error)
 *
 * int
 * xquery_sig_match(xquery_sig *sig, int argc, int* mincnt, int* maxcnt, int *argtpe)
 * - check whether sig can match the actual parameters (return true/false)
 *
 * xquery_function* 
 * xquery_resolve(xquery_client *ctx, char *ns, char *method, int argc, int *mincnt, int* maxcnt, int* argtpe)
 * - resolve a method call in the current xquery context (return NULL if not resolved)
 *
 * char*
 * xquery_function_call(xquery_client *ctx, int msec, char* mode, char *ns, char *method, 
 *                      int argc, int itercnt, int** argcnt, char** argtpe, char** argval, BAT *docBAT)
 * - call a function ns:method(). try to use the function cache (ie re-use a cached MIL tree).
 *   otherwise generate MIL yourself, interpret it (and cache it). Returns error string (NULL if ok).
 */

/*
 * infer the xquery function signature from the mangled MIl procname (return NULL on error)
 */
static xquery_sig* 
xquery_sig_init(char *proc) 
{
    char *cur = (char*) alloca(strlen(proc)); 
    xquery_sig* sig;
    int len = 0;

    proc = strchr(proc, '_'); /* skip fnXXXXXXXX_' */
    if (proc == NULL) return NULL;
    strcpy(cur, ++proc);
    sig = (xquery_sig*) GDKmalloc(sizeof(xquery_sig)+strlen(proc)); 
    if (sig == NULL) return NULL;

    sig->argc = sig->zero = sig->multiple = 0;

    /* get method name */
    while(cur[0]) {
        if (cur[0] == '_' && cur[1] == '_') {
            cur++; /* unescape '_' */
        } else if (cur[0] == '_' && (cur[1] == '4' || cur[1] == '5') && cur[2] == '_') {
            sig->name[len++] = (cur[1] == '4')?'-':'.'; cur += 3; continue;
        } else if (cur[0] == '_') {
            break; /* unescaped '_' => end of function name */
        }
        sig->name[len++] = *cur++;
    }
    sig->name[len] = 0;
    while(*cur++ == '_') {
        char *tpe = cur;
                
        /* parse namespace part */
        for(len=0; cur[0]; cur++) {
            if (cur[0] == '_' && cur[1] == '_') {
                tpe[len++] = '_';
                cur++; /* unescape '_' */
            } else if (cur[0] != '_') {
                tpe[len++] = cur[0];
            } else {
                tpe[len++] = ':';
                cur++; break;
            }
        }
        /* parse type part */
        for(; cur[0]; cur++) {
            if (cur[0] == '_' && cur[1] == '_') {
                tpe[len++] = '_';
                cur++; /* unescape '_' */
            } else if (cur[0] != '_') {
                tpe[len++] = cur[0];
            } else {
                break;
            }
        }
        if (cur[-1] == '0') {
            sig->zero |= 1<<sig->argc; 
        } else if (cur[-1]  == '2') {
            sig->zero |= 1<<sig->argc; 
            sig->multiple |= 1<<sig->argc; 
        } else if (cur[-1]  == '3') {
            sig->multiple |= 1<<sig->argc; 
        }
        cur[-1] = 0;
        if ((sig->tpe[sig->argc++] = xquery_typenr(tpe)) >= XQUERY_TYPES) {
            /* unknown type: don't cache this function */
            GDKfree(sig);
            return NULL;
        }
    }
    return sig;
}


/*
 * check whether sig can match the actual parameters (return true/false)
 */
static int
xquery_sig_match(xquery_sig *sig, int argc, int* mincnt, int* maxcnt, int *argtpe) 
{
    int i, tpe[MAXPARAMS];
    for(i=0; i < argc; i++) {
        if (mincnt[i] == 0 && !(sig->zero & (1<<i))) return 0; 
        if (maxcnt[i] > 1 && !(sig->multiple & (1<<i))) return 0; 
        tpe[i] = argtpe[i];
        while(sig->tpe[i] != tpe[i]) {
            if (tpe[i] >= XQUERY_TYPES) return 0;
            tpe[i] = xquery_types[tpe[i]].parent;
        }
    }
    for(i=0; i< argc; i++) {
        argtpe[i] = tpe[i];
    }
    return 1;
}

/*
 * resolve a method call in the current xquery context (return NULL if nonresolved)
 */
static xquery_function*
xquery_resolve(xquery_client *ctx, char *ns, char *method, int argc, int *mincnt, int* maxcnt, int* argtpe) 
{
    xquery_loaded_module *mod = ctx->loaded_modules;
    int nslen = strlen(ns);

    /* look up ns and method */
    while(mod) {
        if (mod->nslen == nslen && strncmp(mod->ns, ns, nslen) == 0) {
            xquery_function *fun = mod->def->functions;
            while(fun) {
                if (argc == fun->sig->argc && strcmp(method, fun->sig->name) == 0) {
                    if (xquery_sig_match(fun->sig, argc, mincnt, maxcnt, argtpe)) return fun;
                }
                fun = fun->next;
            }
        }
        mod = mod->next;
    }
    return NULL;
}


@= seqbase
    BATseqbase(ctx->@1, @2);
    if (debug) m += snprintf(mil+m, XQUERY_BUFSIZE-l, "@1.seqbase(" @3 ");\n");
@= bunins
    if (BUNins(ctx->@1, @2, @3) == NULL) return "xquery_method: allocation error while inserting in @1";
    if (debug) m += snprintf(mil+m, XQUERY_BUFSIZE-l, "@1.insert(nil," @5 @6 ");\n", @4 @3);
@c
/*
 * call a function ns:method(). try to use the function cache (ie re-use a cached MIL tree).
 * otherwise generate MIL yourself, interpret it (and cache it). Returns error string (NULL if ok).
 */
static char xquery_function_error[80] = "xquery_method: error during execution.\n";
static char* 
xquery_function_call(xquery_client *ctx, 
                     int msec, 
                     char *mode, 
                     char *ns, 
                     char *method, 
                     int argc, 
                     int itercnt, 
                     int** argcnt, 
                     char** argtpe, 
                     char** argval, 
                     BAT *docBAT) 
{
    xquery_prepared_function *prepfun = ctx->prepared_functions;
    xquery_function *fun;
    int i, j, k, l, m=0, tpe[MAXPARAMS], mincnt[MAXPARAMS], maxcnt[MAXPARAMS];
    int debug = (strstr(mode,"debug") != NULL);
    char mil[XQUERY_BUFSIZE], *src, *cur = mil, *end = mil + XQUERY_BUFSIZE-1;

    /* determine minimum and maximum sequence of the parameters, and the common ancestor type of each sequence  */
    for(l=i=0; i<argc; i++) {
        mincnt[i] = maxcnt[i] = argcnt[0][i];
        tpe[i] = -1;
        for(j=0; j<itercnt; j++) {
            if (argcnt[j][i] > maxcnt[i]) maxcnt[i] = argcnt[j][i];
            if (argcnt[j][i] < mincnt[i]) mincnt[i] = argcnt[j][i];
            for(k=0; k<argcnt[j][i]; k++,l++) {
                int t = xquery_typenr(argtpe[l]);
                if (t >= XQUERY_TYPES) 
                    return (char*) -1; /* can't make a quick function resolution if unknown types are involved */
                tpe[i] = xquery_type_common_ancestor(tpe[i],t);
            }
        }
    }
    /* try to resolve the parameters */
    fun = xquery_resolve(ctx, ns, method, argc, mincnt, maxcnt, tpe);
    if (fun == NULL)
        return (char*) -1; /* no such udf. but it may be a built-in, actually */

    /* create a prepared function record for this MIL client */
    while(prepfun && prepfun->def != fun) prepfun = prepfun->next;
    if (prepfun == NULL) {
        prepfun = (xquery_prepared_function*) GDKmalloc(sizeof(xquery_prepared_function));
        if (prepfun == NULL)
            return "xquery_function_call: allocation failed.\n";
        prepfun->def = fun;
        prepfun->lt = NULL;
        prepfun->next = ctx->prepared_functions;
        ctx->prepared_functions = prepfun;
    }
        
    /* generate small MIL query that calls the function PROC */
    if (fun->mil == NULL) {
        MT_set_lock(pf_cache_lock, "xquery_function_call");
        if (fun->mil == NULL) {
            /* create working set */
            int ret;
  
            src = (char*) PFstartMIL();
            while(*src && cur < end) *cur++ = *src++;

            if (docBAT) {
                /* add shredded soap message to the working set */
                src = (char*) PFdocbatMIL();
                while(*src && cur < end) *cur++ = *src++;
            }

            /* call UDF */
            ret = snprintf(cur, XQUERY_BUFSIZE-(cur-mil), 
                           PFudfMIL(), 
                           fun->proc, 0, 0, 0,0, 0, 0, 0, 0, fun->sig->name, fun->sig->name, 0, 0, 0, 0);
            if (ret > 0) cur += ret;

            /* destroy working set */
            ret = snprintf(cur, XQUERY_BUFSIZE-(cur-mil), PFstopMIL());
            if (ret > 0) cur += ret;

            /* done! execute the script */
            *cur = 0;
            if (cur >= end) {
                return "xquery_function_call: generated MIL query exceeds buffer size.\n";
            }
            fun->mil = GDKstrdup(mil);
        }
        MT_unset_lock(pf_cache_lock, "xquery_function_call");
    }

    /* if no MIL tree is available, create it now */
    if (prepfun->lt == NULL) {
        prepfun->lt = xquery_mil2tree(ctx, fun->mil);
        if (prepfun->lt == NULL) {
            GDKfree(prepfun);
            return "xquery_function_call: error during parsing .\n";
        }
    }

    /* put the actual parameters into the fun_* bats (and *_values containers) */
    @:seqbase(fun_vid000, oid_nil, "nil")@
    @:seqbase(fun_iter000, oid_nil, "nil")@
    @:seqbase(fun_kind000, oid_nil, "nil")@
    @:seqbase(fun_item000, oid_nil, "nil")@
    @:seqbase(loop000, oid_nil, "nil")@

    for(l=i=0; i<argc; i++) {
        for(j=0; j<itercnt; j++) {
            oid nil = oid_nil, vid = i + fun->vid, iter = j+1;
            if (i == 0 && j > 0) {
                @:bunins(loop000, &nil, &iter, (size_t) *(oid*), SZFMT, "@0")@
            }
            for(k=0; k<argcnt[j][i]; k++,l++) {
                int t = xquery_typenr(argtpe[l]);
                char c = xquery_types[t].name[3];

                if (ATOMfromstr(xquery_types[t].monet_tpe, &ctx->val, &ctx->vallen, argval[l]) <= 0)
                    return "xquery_function_call: illegal parameter value.\n";

                @:bunins(fun_vid000, &nil, &vid, (size_t) *(oid*), SZFMT, "@0")@
                @:bunins(fun_iter000, &nil, &iter, (size_t) *(oid*), SZFMT, "@0")@
                @:bunins(fun_kind000, &nil, &xquery_types[t].kind, *(int*), "%d")@
                if (c == 'i') { /* xs:integer */
                    oid item = BATcount(ctx->int_values);
                    @:bunins(int_values, &nil, ctx->val, *(lng*), LLFMT, "LL")@
                    @:bunins(fun_item000, &nil, &item, (size_t) *(oid*), SZFMT, "@0")@
                } else if (c == 'd') { /* xs:double or xs:decimal */
                    oid item = BATcount(ctx->dbl_values);
                    @:bunins(dbl_values, &nil, ctx->val, *(dbl*), "%g")@
                    @:bunins(fun_item000, &nil, &item , (size_t) *(oid*), SZFMT, "@0")@
                } else if (c == 's') { /* xs:string */
                    oid item = BATcount(ctx->str_values);
                    @:bunins(str_values, &nil, ctx->val, (str), "\"%s\"")@
                    @:bunins(fun_item000, &nil, &item, (size_t) *(oid*), SZFMT, "@0")@
                } else if (docBAT == NULL) { 
                    return "xquery_function_call: node parameter without docBAT.\n";
                } else {
                    @:bunins(fun_item000, &nil, ctx->val, (size_t) *(oid*), SZFMT, "@0")@
                }
            }
        }
    }
    @:seqbase(loop000, 0, "0@0")@
    @:seqbase(fun_vid000, 0, "0@0")@
    @:seqbase(fun_iter000, 0, "0@0")@
    @:seqbase(fun_kind000, 0, "0@0")@
    @:seqbase(fun_item000, 0, "0@0")@

    /* for debugging purposes, we simulate a full MIL on the log; even if parts are cached */
    if (debug) { 
        /* MIL corresponding to BUNins calls we made from C */
        stream_write(ctx->fderr, mil, strlen(mil), 1);
        /* MIL corresponding to UDF call sequence (even if we already have it cached) */
        stream_write(ctx->fderr, fun->mil, strlen(fun->mil), 1);
    }

    /* set the MIL docBAT and getType variables to the actual values */
    ctx->docBAT[0] = docBAT?docBAT->batCacheid:0;
    if (*(ctx->genType) == NULL || strcmp(*(ctx->genType), mode)) { 
        if (*(ctx->genType)) GDKfree(*(ctx->genType));
        *(ctx->genType) = GDKstrdup(mode);
    }

    *(ctx->time_compile) = GDKms() - msec;

    /* Done preparing the query. Time to (re-)execute the MIL tree */
    prepfun->lru = xquery_lru++;
    if (xquery_tree_exec(ctx, prepfun->lt, 1)) {
        size_t dummy;
        if (fun->size == 0)
            fun->size = Myysize(prepfun->lt, &dummy);

        /* keep the prepared function cache within a certain size */
        ctx->cachesize += fun->size;
        while (ctx->cachesize > xquery_client_bytes) {
             xquery_prepared_function *kill=NULL,*cur;
             unsigned int lru = xquery_lru;
             for(cur=ctx->prepared_functions; cur; cur=cur->next)
                 if (cur->lt && cur->lru < lru) { kill = cur; lru = cur->lru; }
             if (kill) {
                 Myyfree(kill->lt);
                 kill->lt = NULL;
                 ctx->cachesize -= kill->def->size; 
             }
        }
        return NULL;
    }
    return xquery_function_error;
}


/*
 * =================== module admin ================================
 *
 * void
 * xquery_module_free(xquery_module *mod)
 * - free module structure 
 *
 * xquery_module* 
 * xquery_module_compile(xquery_client *ctx, char* mode, char *url)
 * - get an xquery module, compile it and cache it (return NULL on error)
 *
 * char*
 * xquery_module_load(xquery_client *ctx, char* mode, char *ns, char *url)
 * - check whether we already loaded the module, or if we already 
 *   have it cached. If not, fetch&compile. Returns error string or NULL if ok.
 */

/* 
 * free module structure 
 */
static void 
xquery_module_free(xquery_module *mod) 
{
    xquery_function *fun = mod->functions;
    while(fun) {
        xquery_function *del = fun;
        fun = fun->next;
        if (del->mil) GDKfree(del->mil);
        GDKfree(del);
    }
    if (mod->epilogue) free(mod->epilogue);
    if (mod->prologue) free(mod->prologue);
    GDKfree(mod);
}

/*
 * get an xquery module, compile it and cache it (return NULL on error)
 */
xquery_module*
xquery_module_compile(xquery_client *ctx, 
                      char* mode, 
                      char *url) 
{
    xquery_module *mod = GDKmalloc(sizeof(xquery_module)+strlen(url));
    BAT *b = ctx->proc_vid;
    int xx = BUNsize(b);
    int cnt = BUNindex(b, BUNlast(b));
    BUN p, q;

    if (mod == NULL) return NULL;
    memset(mod, 0, sizeof(xquery_module));
    strcpy(mod->url, url);
    if (!xquery_compile_exec(ctx, mode, url, 1, &mod->prologue, NULL, &mod->epilogue)) {
        xquery_module_free(mod);
        return NULL;
    } 
    for(p = BUNptr(b,cnt), q = BUNlast(b); p < q; p += xx) {
        char *proc = (char*) BUNhead(b,p);
        xquery_function *fun = (xquery_function*) GDKmalloc(sizeof(xquery_function)+strlen(proc));
        if (fun == NULL) {
            xquery_module_free(mod);
            return NULL;
        }
        strcpy(fun->proc, proc);
        fun->vid = *(lng*) BUNtail(b,p);
        fun->sig = xquery_sig_init(fun->proc);
        fun->mil = NULL;
        fun->size = 0;
        if (fun->sig == NULL) {
            GDKfree(fun);
        } else {
            fun->next = mod->functions;
            mod->functions = fun;
        }
    }
    mod->next = xquery_compiled_modules;
    xquery_compiled_modules = mod;
    return mod;
}

/*
 * check whether we already loaded the module, or if we already have it cached. 
 * If not, fetch&compile. Returns error string or NULL if ok.
 */
static char* 
xquery_module_load(xquery_client *ctx, 
                   char* mode, 
                   char *ns, 
                   char *url) 
{
    xquery_loaded_module *mod, *prev = NULL;
    int nslen = strlen(ns);

    /* check whether it was already loaded in this query */
    for(mod = ctx->loaded_modules; mod; prev = mod, mod = mod->next) {
        if (strcmp(mod->def->url, url) == 0) {
            if (mod->nslen == 0) {
                if (prev) prev->next = mod->next;
                else ctx->loaded_modules = NULL;
                break; /* put module at front of list */
            } else if (mod->nslen == nslen && strncmp(mod->ns, ns, nslen)) {
                return "xquery_module_load: module already loaded under different namespace.\n";
            }
            return NULL;
        }
    }
    if (mod == NULL) {
        mod = (xquery_loaded_module*) GDKmalloc(sizeof(xquery_loaded_module));
        if (mod == NULL) 
            return "xquery_module_load: could not allocate.\n";

        MT_set_lock(pf_module_lock, "xquery_module_load");
        for(mod->def = xquery_compiled_modules; mod->def; mod->def = mod->def->next) 
            if (strcmp(mod->def->url, url) == 0) break;
        if (mod->def == NULL)
            mod->def = xquery_module_compile(ctx, mode, url);
        MT_unset_lock(pf_module_lock, "xquery_module_load");

        if (mod->def == NULL) {
            GDKfree(mod);
            return "xquery_module_load: could not load module.\n";
        }
        ctx->var_usage_size = BATcount(ctx->var_usage);
        ctx->proc_vid_size = BATcount(ctx->proc_vid);
    } else if (strstr(mode,"debug") != NULL) {
        stream_write(ctx->fderr, mod->def->prologue, strlen(mod->def->prologue), 1);
    }
    mod->ns = ns;
    mod->nslen = nslen;
    mod->next = ctx->loaded_modules;
    ctx->loaded_modules = mod;
    return NULL;
}


/*
 * =================== client session management ================================
 *
 * xquery_client *
 * xquery_client_alloc(stream *fdin, stream *fdout);
 * - allocate a new xquery client, returns client cntxt (0 on error)
 *
 * char*
 * xquery_client_init(xquery_client *ctx);
 * - initialize a new xquery cache context, returns error string (NULL if ok)
 *
 * void
 * xquery_client_free(xquery_client *ctx, int closeclient);
 * - free a xquery cache context (forever)
 *
 * void
 * xquery_client_end(xquery_client *ctx, int forever);
 * - end of xquery execution (if forever=0, struct stays alive for reuse). 
 *
 * void
 * xquery_client_flushall() 
 * - wait for all queries to finish; free all clients; clear PF url cache
 */

static int xquery_caching = 0;

/* 
 * allocate a new xquery client, returns client cntxt (0 on error)
 */
static xquery_client* 
xquery_client_alloc(stream *fdin, 
                    stream *fdout) 
{
    xquery_client *ctx = NULL;
    int i;

    MT_set_lock(pf_cache_lock, "xquery_client_alloc");
    if (fdin) xquery_caching = 1;
    for(i=1; i<=MAXCLIENTS; i++) {
        if (xquery_clients[i].inuse == 0 && xquery_clients[i].buflen) {
            break; /* initialized & unused */
        }
    }
    if (i > MAXCLIENTS && fdin == NULL) {
        /* hack: if fdin == NULL, allocate a MIL client yourself! This is used by query_method() */
        Client client = initClient("soap", GDKgetenv("monet_prompt"), FALSE);
        if (client) {
            TBL_initclient(client, monet_clients);
            i = client - monet_clients;
        }
    }
    if (i <= MAXCLIENTS) { /* suceeded to allocate a client */
        ctx = xquery_clients + i;
        ctx->inuse = 1;
        monet_clients[i].fdin = fdin;
        monet_clients[i].fdout = fdout;
    }
    MT_unset_lock(pf_cache_lock, "xquery_client_alloc");
    return ctx;
}

@= find_bat
{   Variable v = VARfind(&ctx->stk, "@1");
    ctx->@1 =  NULL;
    if (v && v->binding.vtype == TYPE_bat)
        ctx->@1 = BATdescriptor(v->binding.val.bval);
    if (ctx->@1 == NULL) return "xquery_client_init: failed to lookup @1 variable.\n"; }
@c
/*
 * initialize a new xquery cache context, returns error string (NULL if ok)
 */ 
static char* 
xquery_client_init(xquery_client *ctx) 
{ 
    Variable v;

    ctx->fderr = GDKerr;

    if (ctx->buflen == 0) {
        if (!xquery_mil_exec(ctx, (char*) PFinitMIL(), 0))
            return "xquery_client_init: failed to execute init script.\n"; 

        ctx->lastvar = monet_cntxt[ctx->stk].var;

        if (!xquery_mil_exec(ctx, (char*) PFvarMIL(), 0))
            return "xquery_client_init: failed to execute variable declarations.\n"; 

        v = VARfind(&ctx->stk, "docBAT");
        if (v == NULL) 
            return "xquery_client_init: failed to lookup docBAT variable.\n"; 
        ctx->docBAT = &v->binding.val.ival; 

        v = VARfind(&ctx->stk, "genType");
        if (v == NULL) 
            return "xquery_client_init: failed to lookup genType variable.\n"; 
        ctx->genType = &v->binding.val.sval; 

        v = VARfind(&ctx->stk, "time_compile");
        if (v == NULL) 
            return "xquery_client_init: failed to lookup time_compile variable.\n"; 
        ctx->time_compile = &v->binding.val.ival; 

        @:find_bat(proc_vid)@
        @:find_bat(var_usage)@
        @:find_bat(dbl_values)@
        @:find_bat(int_values)@
        @:find_bat(str_values)@
        @:find_bat(fun_vid000)@
        @:find_bat(fun_iter000)@
        @:find_bat(fun_item000)@
        @:find_bat(fun_kind000)@
        @:find_bat(loop000)@

        ctx->var_usage_size = BATcount(ctx->var_usage);
        ctx->proc_vid_size = BATcount(ctx->proc_vid);
        ctx->cachesize = 0;
        ctx->loaded_modules = NULL;
        ctx->prepared_functions = NULL;
        ctx->buflen = XQUERY_BUFSIZE;
        ctx->buf = GDKmalloc(ctx->buflen+1);
        ctx->val = GDKmalloc(ctx->vallen = 128);
        if (ctx->val == NULL || ctx->buf == NULL) {
            if (ctx->buf) GDKfree(ctx->buf);
            if (ctx->val) GDKfree(ctx->val);
            ctx->buflen = 0;
            return "xquery_client_init: failed to allocate.\n";
        }
        ctx->repeat_stk = CNTXTnew(ctx->stk);
        CNTXTuse(ctx->repeat_stk);
        monet_cntxt[ctx->repeat_stk].reuse = TRUE;
    } 
    return NULL;
}


@= unfix
    if (ctx->@1) BBPunfix(ctx->@1->batCacheid);
    ctx->@1 = NULL;
@c
/* 
 * free a xquery cache context (forever).
 */
static void 
xquery_client_free(xquery_client *ctx, 
                   int closeclient) 
{
    xquery_prepared_function *fun= ctx->prepared_functions; 
    xquery_loaded_module *mod= ctx->loaded_modules; 

    while(mod) {
        xquery_loaded_module *del = mod;
        mod = mod->next;
        /* free all modules */
        if (del->def->epilogue && !xquery_mil_exec(ctx, del->def->epilogue, 0))
            fprintf(stderr, "xquery_server: client %d error dropping %s\n", ctx->stk, del->def->url);
        GDKfree(mod);
    }
    while(fun) {
        xquery_prepared_function *del = fun;
        fun = fun->next;
        if (del->lt) Myyfree(del->lt);
        GDKfree(del);
    }
    ctx->loaded_modules = NULL;
    ctx->prepared_functions = NULL;
    ctx->docBAT = NULL;

    /* free the query buffer */
    if (ctx->buf) GDKfree(ctx->buf);
    ctx->buf = NULL;
    ctx->buflen = 0;

    /* free the value buffer */
    if (ctx->val) GDKfree(ctx->val);
    ctx->val = NULL;
    ctx->vallen = 0;
    
    /* unfix the BAT handles */
    @:unfix(int_values)@
    @:unfix(dbl_values)@
    @:unfix(str_values)@
    @:unfix(fun_vid000)@
    @:unfix(fun_iter000)@
    @:unfix(fun_item000)@
    @:unfix(fun_kind000)@
    @:unfix(loop000)@

    /* close the MIL client session */
    monet_cntxt[ctx->repeat_stk].reuse = FALSE;
    CNTXTclear(ctx->repeat_stk);
    CNTXTfree1(ctx->repeat_stk);
    CNTXTdelete(ctx->repeat_stk);
    if (closeclient)
        closeClient(monet_clients + ctx->stk, 0);
    ctx->inuse = 0;
}

/* 
 * end of xquery execution (struct stays alive for reuse).
 */
static void 
xquery_client_end(xquery_client *ctx, 
                  int forever) 
{
    oid nil = oid_nil, zero = 0, one = 1;
    Variable v;

    /* undo any inserts by the query into the var_usage bats */
    size_t delta_var_usage = BATcount(ctx->var_usage) - ctx->var_usage_size;
    size_t delta_proc_vid = BATcount(ctx->proc_vid) - ctx->proc_vid_size;
    BATsetcount(ctx->var_usage, ctx->var_usage_size);
    ctx->var_usage->batBuns->free -= delta_var_usage*BUNsize(ctx->var_usage);
    BATsetcount(ctx->proc_vid, ctx->proc_vid_size);
    ctx->proc_vid->batBuns->free -= delta_proc_vid*BUNsize(ctx->proc_vid);

    /* empty all bats (static varibales) */
    BATclear(ctx->loop000);
    BUNins(ctx->loop000, &zero, &one);

    BATclear(ctx->fun_vid000);
    BATclear(ctx->fun_iter000);
    BATclear(ctx->fun_kind000);
    BATclear(ctx->fun_item000);
    BATclear(ctx->dbl_values);
    BATclear(ctx->int_values);
    BATclear(ctx->str_values);
    BUNins(ctx->str_values, &nil, str_nil);

    /* nil-assign all other variables */
    for(v=monet_cntxt[ctx->stk].var; v != ctx->lastvar; v = v->next) {
        ATOMunfix(v->binding.vtype, VALptr(&v->binding));
        VALclear(&v->binding);
    }
    monet_clients[ctx->stk].fdin = NULL; 
    monet_clients[ctx->stk].fdout = NULL; 

    MT_set_lock(pf_cache_lock, "xquery_client_end");
    if (forever) {
        xquery_client_free(ctx, 1);
    } else {
        /* only deactivate the loaded modules */
        xquery_loaded_module *mod= ctx->loaded_modules; 
        while(mod) {
            mod->nslen = 0;
            mod->ns = NULL; 
            mod = mod->next;
        }
        ctx->inuse = 0;
    }
    MT_unset_lock(pf_cache_lock, "xquery_client_end");
}


/*
 * wait for all queries to finish; free all clients; clear PF url cache
 */
static void
xquery_client_flushall() 
{
    int i, wait = 100;
    while(wait) {
        MT_set_lock(pf_cache_lock, "xquery_client_flushall");
        for(i=1; i<=MAXCLIENTS; i++) {
            if (xquery_clients[i].inuse) break;
        }
        if (i > MAXCLIENTS) {
            /* ok, no xquery clients are active */
            xquery_module *mod = xquery_compiled_modules;
            for(i=1; i<=MAXCLIENTS; i++) {
                if (xquery_clients[i].buflen)
                    xquery_client_free(xquery_clients+i, 1);
            }
            while(mod) {
                xquery_module *del = mod;
                mod = mod->next;
                xquery_module_free(del);
            }
            xquery_compiled_modules = NULL;
            PFurlcache_flush();
            wait = 0;
        }
        MT_unset_lock(pf_cache_lock, "xquery_client_flushall");
        MT_sleep_ms(wait);
    }
    xquery_caching = 0;
}


/*
 * ========== parse xquery to identify 'import module's and function calls ==========
 *
 * char*
 * xquery_parse_ident(char* p) 
 * - parse an identifier; accept any UTF-8 characters in it (is that correct?)
 *
 * char*
 * xquery_parse_comment(char* p)
 * - parse an xquery (: .. :)  comment. Note it may be nested.
 *
 * char*
 * xquery_parse_space(char* p)
 * - parse xquery space, which may include comments 
 *
 * char*
 * xquery_parse_string(char* p, char *buf, int len)
 * - parse an XML datamodel string. Deliver an unescaped version as a result 
 *
 * char*
 * xquery_parse_numeric(char* p, char **tpe)
 * - parse an XML datamodel numeric, and determine its minimal type (xs:integer, xs:decimal or xs:double) 
 *
 * all above functions return the new pointer in the xquery after parsing.
 *
 * char*
 * xquery_prepare(xquery_client *ctx, int msec, char* mode, char* xquery)
 * - parse xquery; chop off module imports, and recognize single method calls. These are re-executed
 *   from a cached MIL tree. Otherwise use pathfinder to compile. Returns error string (NULL if ok).
 */

/* 
 * parse an identifier; accept any UTF-8 characters in it (is that correct?)
 */
static inline char* 
xquery_parse_ident(char* p) 
{
    if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || *(unsigned char*) p >= 128) {
        p++;
        while((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*(unsigned char*) p >= 128) ||
              (*p == '_') || (*p == '.') || (*p == '-') || (*p >= '0' && *p <= '9')) p++;
    }
    return p;
}

/* 
 * parse an xquery (: .. :)  comment. Note it may be nested.
 */
static inline char* 
xquery_parse_comment(char* p) 
{
    int nesting;
    for(nesting=1; *p; p++) {
        if (p[0] == ':' && p[1] == ')' && --nesting == 0) return p+2;
        if (p[0] == '(' && *(++p) == ':') nesting++;
    }
    return p;
}

/* 
 * parse xquery space, which may include comments 
 */
#define ISSPACE(c) ((c) == ' ' || (c) == '\t' || (c) == 10 || (c) == 13) 
static inline char* 
xquery_parse_space(char* p) 
{
    while(*p) {
        while(ISSPACE(*p)) p++;
        if (p[0] != '(' || p[1] != ':') break; 
        p = xquery_parse_comment(p+2);
    }
    return p;
}

/* 
 * parse an XML datamodel string. Deliver an unescaped version as a result 
 */
static inline char* 
xquery_parse_string(char* p, 
                    char *buf, 
                    int len) 
{
    char *q = buf, *r = buf+len-1;
    int sep1 = *p++;
    int sep2 = (sep1=='"')?'\'':'"';
    int escape = 0;
    while(*p) {
        if (escape) {
            if (p[0] == sep2) escape = 0;
            if (q < r) *q++ = *p; p++;
        } else {
            if (p[0] == sep1) {
                p++; break;
            } else if (p[0] == sep2) {
                if (p[1] == sep1 && p[2] == sep1 && p[3] == sep2) {
                    if (q < r) *q++ = sep1; p += 4;
                } else {
                    if (q < r) *q++ = *p; p++;
                    escape = 1;
                }
            } else if (p[0] == '&') {
                if (p[1] == '#' && p[2] == 'x') {
                    unsigned long v = 0; 
                    for(p+=3; *p; p++) {
                        if (*p >= '0' && *p <= '9') {
                            v = (v << 4) + (*p - '0');
                        } else if (*p >= 'a' && *p <= 'f') {
                            v = (v << 4) + (*p - 'a');
                        } else if (*p >= 'A' && *p <= 'F') {
                            v = (v << 4) + (*p - 'A');
                        } else {
                            break;
                        }
                    }
                    if (q < r) *q++ = (char) v;
                } else if (p[1] == '#') {
                    unsigned long v = 0; 
                    for(p+=2; *p; p++) {
                        if (*p >= '0' && *p <= '9') {
                            v = (v * 10) + (*p - '0');
                        } else {
                            break;
                        }
                    }
                    if (q < r) *q++ = (char) v;
                } else if (p[1] == 'l' && p[2] == 't' && p[3] == ';') {
                    if (q < r) *q++ = '<'; p += 4;
                } else if (p[1] == 'g' && p[2] == 't' && p[3] == ';') {
                    if (q < r) *q++ = '<'; p += 4;
                } else if (p[1] == 'a' && p[2] == 'm' && p[3] == 'p' && p[4] == ';') {
                    if (q < r) *q++ = '&'; p += 5;
                } else if (p[1] == 'q' && p[2] == 'u' && p[3] == 'o' && p[4] == 't' && p[5] == ';') {
                    if (q < r) *q++ = '"'; p += 6;
                } else if (p[1] == 'a' && p[2] == 'p' && p[3] == 'o' && p[4] == 's' && p[5] == ';') {
                    if (q < r) *q++ = '\''; p += 6;
                }
            } else {
                if (q < r) *q++ = *p; p++;
            }
        }
    }
    *q = 0;
    return p;
}

/* 
 * parse an XML datamodel numeric, and determine its minimal type (xs:integer, xs:decimal or xs:double) 
 */
static inline char* 
xquery_parse_numeric(char* p, 
                     char **tpe) 
{
    *tpe = "xs:integer";
    if (p[0] == '-' || p[0] == '+') p++;
    while(p[0] >= '0' && p[0] <= '9') p++;
    if (p[0] == '.' && (p[1] >= '0' && p[1] <= '9')) {
        p++;
        while(p[0] >= '0' && p[0] <= '9') p++;
        *tpe = "xs:decimal";
    }
    if (p[0] == 'e' || p[0] == 'E') {
        char *q = p+1;
        if (q[0] == '-' || q[0] == '+') q++;
        if (q[0] >= '0' && q[0] <= '9') {
           while(q[0] >= '0' && q[0] <= '9') q++;
           p = q;
           *tpe = "xs:double";
        }
    }
    return p;
}

/* 
 * parse xquery; chop off module imports, and recognize single method calls. These are re-executed
 * from a cached MIL tree. Otherwise use pathfinder to compile. Returns error string (NULL if ok).
 */
static char*
xquery_prepare(xquery_client *ctx, 
               int msec, 
               char* mode, 
               char* query) 
{
    int nsbuf = 0, loaded_modules = 0;
    char *ns = (char*)&nsbuf, *nsend = ns, *locend, *loc = NULL, *p = query;
    char val[256], url1[256], url2[256];
    char *err = NULL;

    if (strstr(mode,"debug") != NULL) {
        /* for debugging purposes, we simulate a full MIL on the log; even if parts are cached */
        char *prologue = (char*) PFinitMIL();
        stream_write(ctx->fderr, prologue, strlen(prologue), 1);
        prologue = (char*) PFvarMIL();
        stream_write(ctx->fderr, prologue, strlen(prologue), 1);
    }
    while(*p && err == NULL) {
        p = xquery_parse_space(p);
        if (strncmp(p, "import", 6) || !ISSPACE(p[6])) {
            break;
        } else {
            /* e.g. import module namespace xmark = "/cygwin/tmp/" at "/cygwin/tmp/mod1.xq"; */ 
            p = xquery_parse_space(p+6);
            if (strncmp(p, "module", 6) == 0 && ISSPACE(p[6])) {
                p = xquery_parse_space(p+6);
                if (strncmp(p, "namespace", 9) == 0 && ISSPACE(p[9])) {
                    ns = xquery_parse_space(p+9);
                    nsend = xquery_parse_ident(ns);
                    p = xquery_parse_space(nsend);
                    if (*p == '=') {
                        p = xquery_parse_space(p+1);
                    } else {
                        err = "xquery_prepare: expecting '=' after namespace declaration";
                    }
                }
                p = xquery_parse_string(p, url1, 256);
                p = xquery_parse_space(p);
                if (err == NULL && *p == 'a' && *(++p) == 't' && ISSPACE(p[1])) do {
                    loc = xquery_parse_space(p+1);
                    locend = xquery_parse_string(loc, url2, 256);
                    if (strlen(url1) > strlen(url2) || strncmp(url1, url2, strlen(url1))) {
                        err = "xquery_prepare: module namespace does not match import statement.\n";
                    } else { 
                        char bak = *nsend;
                        p = xquery_parse_space(locend);
                        /* cut off module import from the query, and load it here (to have it cached later) */
                        *nsend = 0; 
                        err = xquery_module_load(ctx, mode, ns, url2);
                        *nsend = bak; 
                    }
                } while (*p == ',' && err == NULL);
            }
            if (*p != ';') {
                err = "xquery_prepare: missing ';' after module import.\n";
            } else {
                loaded_modules++;
                p++;
            }
        }
    }
    if (loaded_modules == 0) {
       err = (char*) -1; /* query not recognized as a function call */
    } else if (err == NULL) {
        /* detect queries that consist of a single method call only */
        nsend = ns = (char*) &nsbuf; 
        loc = p; 
        locend = xquery_parse_ident(loc);
        p = xquery_parse_space(locend);
        if (*p == ':') {
            ns = loc; nsend = locend; 
            loc = ++p; 
            locend = xquery_parse_ident(p);
            p = xquery_parse_space(locend);
        }
        if (*p != '(' || ((locend-loc) == 2 && loc[0] == 'i' && loc[1] == 'f')) {
            err = (char*) -1; /* query not recognized as a function call */
        } else {
            int cnt[MAXPARAMS];
            char* tpe[MAXPARAMS];
            char* param[MAXPARAMS];
            int argc = 0;
    
            /* e.g. ns:function(1,2,3) */
            p = xquery_parse_space(p+1);
            if (*p == ')') {
               p++;
            } else do {
                param[argc] = p;
                tpe[argc] = "xs:string";
                cnt[argc] = 1;
                if (*param[argc] == '"' || *param[argc] == '\'') {
                    p = xquery_parse_string(param[argc], val, 256);
                    if (p <= param[argc]) {
                        err = "xquery_prepare: could not parse string literal.\n";
                        break;
                    }
                } else if (*p == '-' || *p == '+' || *p == '.' || (*p >= '0' && *p <= '9')) {
                    p = xquery_parse_numeric(param[argc], tpe+argc);
                    if (p <= param[argc]) {
                        err = "xquery_prepare: could not parse numeric literal.\n";
                        break;
                    }
                } else {
                    /* complex parameter */
                    err = (char*) -1; /* query not recognized as a simple function call */
                    break;
                }
                if (++argc >= MAXPARAMS) {
                    err = "xquery_prepare: too many parameters.\n";
                    break;
                }
                p = xquery_parse_space(p);
                if (*p == ')') {
                    p++; 
                    break;
                } else if (*p != ',') {
                    err = "xquery_prepare: expecting a ',' between function parameters.\n";
                    break;
                }
                p = xquery_parse_space(p+1);
            } while(*p);
    
            if (err == NULL) {    
                p = xquery_parse_space(p);
                if (*p == '/') {
                    err = (char*) -1;
                } else if (*p) {
                    err = "xquery_prepare: unexpected characters after ';'.\n";
                } else {
                    /* all set: make the call */
                    int* cnt_ptr = cnt;    
                    char nsbak = *nsend, locbak = *locend;
                    *nsend = 0; *locend = 0;
                    err = xquery_function_call(ctx, msec, mode, ns, loc, argc, 1, &cnt_ptr, tpe, param, NULL);
                    *nsend = nsbak; *locend = locbak;
                }
            }
        }
    }
    if (err == xquery_function_error) {
        err = (char*) -1; /* execution error in xquery_function_call */
    } else if (err == (char*) -1) {
        char *sec1 = NULL;
        char *sec2 = NULL;
        char *sec3 = NULL;
        err = NULL;
        /* compile and execute the query (minus module imports) */
        if (!xquery_compile_exec(ctx, mode, query, 0, &sec1, &sec2, &sec3)) 
                err = NULL; /* in case of execution err, it stays -1 */
        if (sec1) free(sec1);
        if (sec2) free(sec2);
        if (sec3) free(sec3);
    } 
    return err;
}

/*
 * =================== exported functions ================================
 *
 * see MIL module definition (top of file)
 */

@= builtin_operand
{
    int _k = interpret(stk, arg(lt, @1), res);
    if (_k < 0) {
        return _k;
    }
    @3 = VALconvert(@2, res);
    if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
        return handle_paramerror(res,@1,res->vtype,@2);
    }
}
@c
/*
 * read xquery from input stream; execute and print on output stream 
 */  
#define XQUERY_CHALLENGE "::mserver_xquery:4\n"
static int
xquery_server_end(xquery_client *ctx, 
                  Thread t, 
                  char *err) 
{
    Client c = monet_clients + ctx->stk;
    if (err) 
        fprintf(stderr, "xquery_server: client %d %s\n", ctx->stk, err);
    monetSetChannel(t, GDKin, GDKout);
    if (c->fdin) {
        stream_close(c->fdin);
        stream_destroy(c->fdin);
        c->fdin = GDKin;
    }
    if (c->fdout) {
        stream_close(c->fdout);
        stream_destroy(c->fdout);
        c->fdout = GDKout;
    }
    xquery_client_end(ctx, !xquery_caching);
    return err?GDK_FAIL:GDK_SUCCEED;
}

int
CMDxquery_server(Cntxt stk, 
                 YYSTREE lt, 
                 ValPtr res)
{
    stream **In, **Out;
    stream *in = NULL, *out = NULL;
    size_t curlen = 0;
    Thread XQthread = THRget(THRgettid());
    xquery_client *ctx = xquery_clients + stk;
    char *xquery,  buf[100], *p=buf, *err = (char*) -1;
    int i, msec;

    if (lt->cnt != 2)
        return handle_argerror(res, lt->cnt, 2);

    /* this is a BUILTIN because we must obtain the client context (and
     * thus the streams) */
    @:builtin_operand(0,TYPE_Stream,In)@
    in = *In;
    @:builtin_operand(1,TYPE_Stream,Out)@
    out = *Out;

    /* send challenge */
    snprintf(buf, 100, "%2u%s", (unsigned int)strlen(XQUERY_CHALLENGE), XQUERY_CHALLENGE);
    if (stream_write(out, buf, strlen(buf), 1) < 0) 
        return(xquery_server_end(ctx, XQthread, "could not send challenge"));

    /* get user name (ignored later), and mapiclient mode */
    if (stream_read(in, p, 1, 1) < 0)
        return(xquery_server_end(ctx, XQthread, "could not read response1"));
    for (i = 0; i < BUFSIZ && *p != '\n'; i++) {
        p++;
        if (stream_read(in, p, 1, 1) < 0)
            return(xquery_server_end(ctx, XQthread, "could not read response2"));
    }
    *p = 0;

    /* check for blocked mode */
    if (strncmp(buf + i - 8, ":blocked", 8) == 0) {
        in = block_stream(stream_rstream(in));
        out = block_stream(stream_wstream(out));
    }
    monetSetChannel(XQthread, in, out);
    /* use the MAPI protocol to read as much xquery buffer as possible */
    if (stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) < 0)
        return(xquery_server_end(ctx, XQthread, "could not write prompt"));
    if (stream_flush(out))
        return(xquery_server_end(ctx, XQthread, "could not flush prompt"));

    err = xquery_client_init(ctx);
    if (err) return (xquery_server_end(ctx, XQthread, err));
    for (p = ctx->buf; p; ) {
        ssize_t n = stream_read(in, p + curlen, 1, ctx->buflen - curlen);
        if (n < 0)
            return(xquery_server_end(ctx, XQthread, NULL));
        if (n == 0)
            break;

        curlen += n;
        if (curlen == ctx->buflen) {
            p = GDKrealloc(ctx->buf, ctx->buflen + 1025);
            if (p) {
                ctx->buflen += 1024;
                ctx->buf = p;
            }
        }
    }
    msec = GDKms();

    /* execute query */
    if (p) {
        p[curlen] = 0;        /* terminate (we know there is space) */

        /* first line of the query is the mode */ 
        for (xquery = p; *xquery; xquery++) {
            if (*xquery == '\n') {
                *xquery++ = 0;
                break;
            }
        }
        err = xquery_prepare(ctx, msec, p, xquery);
        if (err && err != (char*) -1) {
            /* report errors back to client */
            stream_write(ctx->fderr, err, strlen(err), 1);
        }
    }
    if (strstr(p, "debug")) {
        /* memory debugging */
        xquery_prepared_function *fun = ctx->prepared_functions;
        BAT *b = NULL;
        view_client_size(&b, &stk);
        if (b) {
           while(fun) {
               BUNins(b, fun->def->proc, &fun->def->size);
               fun = fun->next;
            } 
            BATprintf(GDKstdout, b);
            BBPreclaim(b);
        } 
    }

    /* end of session */
    stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1);
    stream_flush(out);
    return(xquery_server_end(ctx, XQthread, NULL));
}

/*
 * mapi_listen may call this routine to get a recycled MIL client session from the xquery query cache
 */
Client
CMDxquery_client_alloc(stream *fdin, 
                       stream *fdout) 
{
    xquery_client *ctx = xquery_client_alloc(fdin,fdout);
    if (ctx) {
        Client c = monet_clients + ctx->stk;
        if (MAPIinitClient(c, "xquery_server", fdin, fdout) < 0) {
            xquery_client_end(ctx, 0);
        } else {
            return c;
        }
    }
    return NULL; 
}

/*
 * flush the cache and return a magic pointer. It must be passed to mapi_listen to enable caching.
 */
int
CMDxquery_start_query_cache(ptr *res, lng *maxsize) 
{
    xquery_client_flushall();
    if (*maxsize > 0) xquery_client_bytes = *maxsize;
    *res = (ptr) CMDxquery_client_alloc;
    return GDK_SUCCEED;
}

/*
 * execute xquery and return the result in a string.
 */
int
CMDxquery(Cntxt stk, 
          YYSTREE lt, 
          ValPtr res)
{
    int msec = GDKms();
    char *mode = "xml", *xquery = NULL, *err = NULL;
    bit no=0, *is_url=&no;
    Client c = NULL;
    xquery_client *ctx;

    /* this is a BUILTIN because we must obtain the client context (and
     * thus the streams) */
    if (lt->cnt > 4)
        return handle_argerror(res, lt->cnt, 3);
    if (lt->cnt == 1) {
        @:builtin_operand(0,TYPE_str,xquery)@
    } else {
        @:builtin_operand(0,TYPE_str,mode)@
        @:builtin_operand(1,TYPE_str,xquery)@
    }
    if (lt->cnt == 3) {
        @:builtin_operand(2,TYPE_bit,is_url)@
    }
    CNTXTclient(stk, &c);
    ctx = xquery_clients + c->stk;
    MT_set_lock(pf_cache_lock, "CMDxquery");
    err = xquery_client_init(ctx);
    MT_unset_lock(pf_cache_lock, "CMDxquery");

    if (err == NULL && *is_url == TRUE) { 
        MT_set_lock(pf_compiler_lock, "CMDxquery");
        PFURLCACHE("CMDxquery", xquery, 1);
        MT_unset_lock(pf_compiler_lock, "CMDxquery");
    }

    if (err == NULL) {
        buffer *b = buffer_create(XQUERY_BUFSIZE);
        if (b) {
            stream *s = buffer_wastream(b, "CMDxquery");
            if (s) {
                /* run the query, but collect all output in a buffer */
                stream *bak = GDKout;
                THRsetdata(0,s);
                err = xquery_prepare(ctx, msec, mode, xquery);
                if (err == NULL) {
                    res->val.sval = GDKmalloc(b->pos+1);
                    if (res->val.sval) {
                        memcpy(res->val.sval, b->buf, b->pos);
                        res->val.sval[b->pos] = 0;
                        res->vtype = TYPE_str;
                    } else {
                        err = "CMDxquery: failed to allocate buffer";
                    }
                }
                THRsetdata(0,bak);
                stream_close(s);
            } else {
                err = "CMDxquery: failed to create stream";
            }
            buffer_destroy(b);
            stream_destroy(s);
        } else {
            err = "CMDxquery: failed to allocate streambuffer";
        }
    }
    MT_set_lock(pf_cache_lock, "CMDxquery");
    xquery_client_free(ctx, 0);
    MT_unset_lock(pf_cache_lock, "CMDxquery");
    if (err) {
        res->vtype = TYPE_void;
        if (err != (char*) -1) GDKerror(err);
        return GDK_FAIL;
    } 
    return GDK_SUCCEED;
}


/*
 * call a method in a temporary xquery client context
 */  
char*
xquery_method(stream *out, 
              char* module, 
              char *method, 
              int argc, 
              int itercnt, 
              int** argcnt, 
              str* argtpe, 
              str* argval, 
              BAT* docBAT)
{
    int msec = GDKms();
    xquery_client *ctx = xquery_client_alloc(NULL, out);
    char *err = NULL, *ns = "fn", * mode = "xml-noroot";

    if (ctx == NULL) 
        return "xquery_method: out of client slots.\n";

    err = xquery_client_init(ctx);

    if (argc > 1000) {
        /* hack: pass argc+1000 and you get debug output */
        stream *s = open_wstream("soap.mil");
        char *prologue = (char*) PFinitMIL();
        if (s) {
            ctx->fderr = s;
            mode = "xml-noroot-debug";
        }
        stream_write(ctx->fderr, prologue, strlen(prologue), 1);
        argc = argc % 1000;
    }

    if (err == NULL && module)
        err = xquery_module_load(ctx, "xml-noroot", ns="soap", module); 

    if (err == NULL) { 
        err = xquery_function_call(ctx, msec, mode, ns, method, argc, itercnt, argcnt, argtpe, argval, docBAT);
        if (err == (char*) -1) err = "xquery_method: function could not be resolved.\n";
    }

    if (ctx->fderr != GDKerr) {
        stream_close(ctx->fderr);
        stream_destroy(ctx->fderr);
    }
    xquery_client_end(ctx, 0);
    return err;
}

/*
 * module initialization
 */
bat *
xquery_prelude()
{
    int i;
    pf_compiler_lock = MT_create_lock();
    pf_module_lock = MT_create_lock();
    pf_cache_lock = MT_create_lock();

    memset(xquery_clients, 0, sizeof(xquery_client)*(MAXCLIENTS+1));
    for(i=1; i<=MAXCLIENTS; i++)        
        xquery_clients[i].stk = i;
   
    xquery_compiled_modules = NULL;
    return NULL;
}

/*
 * module cleanup
 */
void
xquery_epilogue()
{
    xquery_client_flushall();
    MT_destroy_lock(pf_compiler_lock);
    MT_destroy_lock(pf_cache_lock);
}
/* vim:set shiftwidth=4 expandtab: */
