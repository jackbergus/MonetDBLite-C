@' pathfinder.mx
@'
@' Monet runtime support for the Pathfinder XQuery compiler
@'
@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Initial Developer of the Original Code is the Database &
@' Information Systems Group at the University of Konstanz, Germany.
@' Portions created by the University of Konstanz are Copyright (C)
@' 2000-2005 University of Konstanz.  All Rights Reserved.
@'
@' $Id$
@'

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@a Jan Flokstra
@a Jens Teubner
@a Stefan Manegold
@a Peter Boncz 

@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

.USE pf_support;
.USE streams;

.BUILTIN xquery_server(Stream in, Stream out) : void = CMDxquery_server;
 "read xquery from stream, and print on a stream."

.BUILTIN xquery(mode str, xquery str, is_url bit) : str = CMDxquery;
 "xquery execution. parameters: mode, query, is_url (optional)
 usage:  var result := xquery(\"xml\", \"1+1\", false); printf(result);
 or:  printf(xquery(\"xml\", \"1+1\"));"

.COMMAND xquery_start_query_cache() : ptr = CMDxquery_start_query_cache;
 "handle to pass to mapi_listen to let it use the query plan cache (also flushes the cache when called)."

.PRELUDE = xquery_prelude;
.EPILOGUE = xquery_epilogue;

.END pathfinder;
@mil
module(mapi);

PROC pfstart(bit open) : void {
    mapi_listen(int(monet_environment.find("xquery_port")), 5, "xquery_server", open, xquery_start_query_cache()).fork();
}
ADDHELP("pfstart", "boncz", "April 2005",
"PARAMETERS:\n\
bit whether the listener should listen to outside requests \
(default false: only local connections).\n\
DESCRIPTION:\n\
start the xquery server.",
"pathfinder");

PROC pfstart() : void {
    pfstart(false);
}
ADDHELP("pfstart", "boncz", "April 2005",
"DESCRIPTION:\n\
start the xquery server.",
"pathfinder");

PROC xquery_server_start(bit global) : void {
    fork(mapi_listen(
                int(monet_environment.find("xquery_port")),
                5,
                "xquery_server",
                global
                )
        );
}

PROC xquery_server_start() : void {
    xquery_server_start(false);
}

#############################################
# User-level document management functions:
#
# - shred_doc
# - delete_doc
# - delete_all_docs
#
# Each imported XML-document is stored as a collection of persistent BATs 
# whose name starts with the name of the BAT and ends with the document ID. 
# The execution of an XQuery is not performed on the persistent BATs, but on 
# the transient 'working set', a global document collection represented
# by the ws-BAT.
#
# Each collection contains the following BATs:
# - pre_size    : BAT[oid,int]  pre-value of node / and its descendant size,
# - pre_level   : BAT[oid,chr]  pre-value of node / and its level,
# - pre_prop    : BAT[oid,oid]  pre-value of node / and property ID,
# - pre_kind    : BAT[oid,chr]  pre-value of node / and node kind,
#
# - qn_ns        : BAT[oid,str]  property ID / and name space (elements and attributes),
# - qn_loc       : BAT[oid,str]  property ID / and local name (elements and attributes),
# - prop_text    : BAT[oid,str]  property ID / and text,
# - prop_com     : BAT[oid,str]  property ID / and comment,
# - prop_ins     : BAT[oid,str]  property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  property ID / and processing instruction target,
#
# - attr_own  : BAT[oid,oid]  attribute ID / pre-value of owner
# - attr_qn   : BAT[oid,oid]  attribute ID / and qname/property ID
# - attr_prop : BAT[oid,oid]  attribute ID / value ID
#
# - prop_val  : BAT[oid,str]  value ID / value of attribute nodes
#
# Global information on persistent stored documents:
# - doc_name      : BAT[oid,str]        document ID / document name
# - doc_height    : BAT[oid,int]        document ID / height of document
# - doc_size      : BAT[oid,lng]        document ID / size in bytes
# - doc_timestamp : BAT[oid,timestamp]  document ID / end-of-cache-time (nil if none)
# - uri_lifetime  : BAT[str,lng]        URI prefix  / time-to-live (seconds), nil if not to be cached 
# 
# Information on documents/fragments in the working set:
# - PRE_FRAG   : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each pre value (copied in element construction)
# - ATTR_FRAG  : BAT[void,BAT[void,oid]] list of bats with fragments
#                oids for each attr value (copied in element/attribute 
#                construction)
# - DOC_LOADED : BAT[void,str] fragment ID / name of document 
#                (starts with 1@0 because WS is first 'loaded' document
# - FRAG       : BAT[void,oid] 0@0 / oid of the newest added fragment
# - WS_FRAG    : BAT[void,oid] enumeration / root-pre values of
#                generated element fragments
# - HEIGTH     : BAT[void,int] enumeration of the fragments / maximal
#                depth of the fragment (starts with 0@0 - WS)

# get a handle to the global lock
var pf_lock := pflock();

# DEFINITION of constants concerning the data model
const PRE_BASE := 0@0;
const ELEMENT := chr(0);
const TEXT := chr(1);
const COMMENT := chr(2);
const PI := chr(3);
const DOCUMENT := chr(4);
const WS := 0@0;

@- ws definition

This macro is used for the MIL const defs, the C const defs,
but also in the MIL procs for creating, filling and destroying
a working set.

We define a table with the column name, its number,
the type of data (typically again a bat), and if
so the head and tail type of that bat.

actually the field 'tpe' is taken to be bat *always*, 
EXCEPT when (child-T == void)

('tpe' = void means it is a view; without persistent name)

        name       number  tpe  col[H,T]    col-seqbase 
        ========   ======  ===  ==========  ===========
@= ws
@:@1_ws(PRE_SIZE,       0, bat, void,  int, PRE_BASE)@
@:@1_ws(PRE_LEVEL,      1, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_PROP,       2, bat, void,  oid, PRE_BASE)@
@:@1_ws(PRE_KIND,       3, bat, void,  chr, PRE_BASE)@
@:@1_ws(PRE_FRAG,       4, void,void,  oid, PRE_BASE)@
@:@1_ws(QN_URI,         5, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_PREFIX,      6, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_LOC,         7, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TEXT,      8, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_COM,       9, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_INS,      10, bat, void,  str, PRE_BASE)@
@:@1_ws(PROP_TGT,      11, bat, void,  str, PRE_BASE)@
@:@1_ws(ID_PRE,        12, bat,  str,  oid, nil)@
@:@1_ws(IDREF_PRE,     13, bat,  str,  oid, nil)@
@:@1_ws(ATTR_OWN,      14, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_QN,       15, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_PROP,     16, bat, void,  oid, PRE_BASE)@
@:@1_ws(ATTR_FRAG,     17, void,void,  oid, PRE_BASE)@
@:@1_ws(PROP_VAL,      18, bat, void,  str, PRE_BASE)@
@:@1_ws(DOC_LOADED,    19, str, void, void, nil)@
@:@1_ws(FRAG,          20, oid, void, void, nil)@
@:@1_ws(WS_FRAG,       21, oid, void, void, nil)@
@:@1_ws(HEIGHT,        22, int, void, void, nil)@
@:@1_ws(QN_PREFIX_URI, 23, bat, void,  str, PRE_BASE)@
@:@1_ws(QN_LOC_URI,    24, bat, void,  str, PRE_BASE)@
@:@1_ws(KIND_PRE_0,    25, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_1,    26, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_2,    27, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_3,    28, bat, void,  oid, nil)@
@:@1_ws(KIND_PRE_4,    29, bat, void,  oid, nil)@
@:@1_ws(PROP_PRE_0,    30, bat,  oid,  oid, nil)@
@:@1_ws(PROP_PRE_3,    31, bat,  oid,  oid, nil)@

@-
BEWARE: WS_SIZE (below) should *always* be the size of ws (above)

@= decl
@:@1_decl_ws(WS_SIZE, 32)@
@:@1_decl_ws(QNAME,    2)@
@:@1_decl_ws(BOOL,     3)@
@:@1_decl_ws(INT,      4)@
@:@1_decl_ws(DEC,      5)@
@:@1_decl_ws(DBL,      6)@
@:@1_decl_ws(STR,      7)@
@:@1_decl_ws(U_A,      8)@
@:@1_decl_ws(ATOMIC,  31)@
@:@1_decl_ws(NODE,    32)@
@:@1_decl_ws(ELEM,    33)@
@:@1_decl_ws(ATTR,    34)@

@= mil_decl_ws
const @1 := @2;
@mil
@:ws(mil_decl)@
@:decl(mil)@

const KIND_PRE := KIND_PRE_0;
const PROP_PRE := PROP_PRE_0;

# ATOMIC is not a type but all atomic types
# can be retrieved with 'select(int(nil),ATOMIC)'

# NODE is not a type but all node types
# can be retrieved with 'select(NODE,int(nil))'


var doc_query; # bat[oid,int] active working-sets (queries) that use a particular document 
var doc_sema;  # bat[oid,sema] used by delete_doc to wait until all doc users have gone

PROC doc_init() : void
{
    # check if anythimg is initialized at all
    if (type(doc_query) != bat) {
        if (not(isnil(CATCH(bat("doc_name").count())))) {
            # create doc_name table in case it does not exist
            new(oid,str).persists(true).bbpname("doc_name");
            new(oid,str).persists(true).bbpname("doc_location");
            new(oid,timestamp).persists(true).bbpname("doc_timestamp");
            new(oid,int).persists(true).bbpname("doc_height");
            new(oid,lng).persists(true).bbpname("doc_size");
            new(str,lng).persists(true).bbpname("uri_lifetime");
        }
        if (isnil(CATCH(bat("doc_query").count()))) {
            doc_query := bat("doc_query"); 
            doc_sema := bat("doc_sema"); 
        } else {
            (doc_query := new(oid,int)).bbpname("doc_query"); 
            (doc_sema := new(oid,sema)).bbpname("doc_sema"); 
        }
    }
}

PROC doc_check(str name) : bit
{
    doc_init();
    return bat("doc_name").reverse().exist(name);
}

PROC create_ws () : BAT[void,bat]
{
    var ws := bat(void,bat,WS_SIZE).seqbase(PRE_BASE);

    # use our ws macro to instatiate a working set with the proper types
@= create_ws
    if (@5 != void) { # a bat of bats (persistent or view)
        var b := bat(@4,@5);
        if (not(isnil(@6))) b.seqbase(@6); 
        ws.insert(nil, bat(void,bat).seqbase(PRE_BASE).insert(nil, b));
    } else {
        ws.insert(nil, bat(void,@3).seqbase(PRE_BASE)); # a constant bat
    }
@mil
    @:ws(create)@

    # fill the constant bats with initial values
    ws.fetch(DOC_LOADED).seqbase(1@0);
    ws.fetch(FRAG).seqbase(0@0).insert(0@0,nil);
    ws.fetch(HEIGHT).seqbase(0@0).insert(nil,0);
    return ws.access(BAT_READ);
}

ADDHELP("create_ws", "tsheyar", "July 2004",
"DESCRIPITON:\n\
creates a new working set and gives back the reference",
"pathfinder");

##################################################
## PROCs required by the algebraic translation ###
##################################################

PROC doc_tbl (BAT[void, BAT] ws, BAT[void, str] item) : BAT[void,BAT]
{
    # consider each document only once
    var docs := item.tuniqueALT ().mark (0@0).reverse ();

    # throw out documents we already have in the working set
    docs := docs.reverse ()
                .kdiff (ws.fetch (DOC_LOADED).reverse ())
                .mark (0@0)
                .reverse ();

    # load all remaining documents into the working set
    docs@batloop () {
        ws := add_doc (ws, $t);
    }

    # The working set now contains all documents we need.

    # pick the according frag value for each document requested
    var ret_frag := item.leftjoin (ws.fetch (DOC_LOADED).reverse ())
                        .reverse ()
                        .mark (0@0)
                        .reverse ();

    # pre values will all be zero
    var ret_item := ret_frag.project (0@0);

    # return result as a BAT of BATs
    return new (void, BAT).insert (nil, ws)
                          .insert (nil, ret_item)
                          .insert (nil, ret_frag)
                          .seqbase (0@0);
}

ADDHELP("doc_tbl", "teubner", "Aug 2005",
                "PARAMETERS:\n\
ws    current working set; will be modified\n\
item  list of documents to add to the working set\n\
DESCRIPTION:\n\
Implementation of the algebra operator `doc_tbl' that\n\
loads persistent documents into the working set.\n\
Input is a list of document names. Output is a BAT of\n\
BATs with the components\n\
(a) the modified working set,\n\
(b) an `item' column with the pre values of the\n\
document roots, and\n\
(c) a `frag' column that encodes document\n\
container (within the working set) according to our\n\
working set representation.",
                "pathfinder");

# primitive for supporting highly specific XQuery functionality
PROC merge_adjacent_text_nodes (BAT[void,oid] iter,
                                BAT[void,oid] pre,
                                BAT[void,oid] pfrag,
                                BAT[void,BAT] ws) : BAT[void,oid]
{
    var map := pre.ord_uselect(nil,nil).mark(0@0).reverse();
    iter := map.leftfetchjoin(iter);
    pre := map.leftfetchjoin(pre);
    pfrag := map.leftfetchjoin(pfrag);

    var kind := mposjoin (pre, pfrag, ws.fetch(PRE_KIND));
    var text := kind.[=](TEXT);
    var text_sel := text.select(true).mark(0@0).reverse();
    var text_pre := text_sel.leftfetchjoin(pre)
                            .reverse().mark(0@0).reverse();
    var text_frag := text_sel.leftfetchjoin(pfrag)
                             .reverse().mark(0@0).reverse();

    var text_prop := mposjoin (mposjoin (text_pre, text_frag, ws.fetch(PRE_PROP)),
                               mposjoin (text_pre, text_frag, ws.fetch(PRE_FRAG)),
                               ws.fetch(PROP_TEXT));
    text_pre := nil;
    text_frag := nil;

    var pre_prop := pre.mirror()
                       .outerjoin(text_prop.reverse()
                                           .leftfetchjoin(text_sel)
                                           .reverse());
    var pre_enum := [oid](text);
    var res_size := (iter.tunique().count() 
                  + text.count() + 1)
                  - text_sel.count();

    var res_strs := combine_text_string (iter.chk_order(),
                                         pre_enum,
                                         pre_prop,
                                         res_size);
    iter := nil;
    pre_enum := nil;
    pre_prop := nil;
    res_size := nil;
    var res_texts := text_constr (res_strs.reverse().mark(0@0).reverse(), ws);
    ws := res_texts.fetch(0);
    var textnodes := res_texts.fetch(1);
    res_texts := nil;
    
    text_pre := pre.mirror()
                   .outerjoin(res_strs.mark(0@0)
                                      .leftfetchjoin(textnodes));
    text_frag := pre.mirror()
                    .outerjoin(res_strs.project(WS));
    res_strs := nil;
    textnodes := nil;
    pre := map.reverse()
              .leftfetchjoin([ifthenelse](text,text_pre,pre));
    pfrag := map.reverse()
                .leftfetchjoin([ifthenelse](text,text_frag,pfrag));

    # return result as a BAT of BATs
    return new (void, BAT).insert (nil, ws)
                          .insert (nil, pre)
                          .insert (nil, pfrag)
                          .seqbase (0@0);
}
ADDHELP("merge_adjacent_text_nodes", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,str] iter : prefix of qname\n\
BAT[void,str] pre  : URI of the qname\n\
BAT[void,str] frag : local part of the qname\n\
BAT[void,BAT] ws   : working set that stores the qname\n\
DESCRIPTION:\n\
merge_adjacent_text_nodes takes an iter|pre|frag schema and\n\
combines within each iteration all adjacent text nodes.\n\
(Note that the order is given by the input order.)\n\
New textnodes are added into the working set ws and the result is\n\
a bat of bats (ws, modified_pres, modified_frags). The heads of the\n\
pre and frag are aligned to the input relations.",
        "pathfinder");
                                
# add_qnames changes the working set as side effect
# without a 'prefix\1uri\1local' index this could be quite expensive
#
# it basically does:
# [ifthenelse]([isnil](local),local.project(nil),[add_qname](prefix,uri,local,local.project(ws)));
PROC add_qnames (BAT[void,str] prefix,
                 BAT[void,str] uri,
                 BAT[void,str] local,
                 BAT[void,BAT] ws) : BAT[void,oid]
{
    # lookup already stored qnames
    var prefix_uri := prefix.[+](str('\1')).[+](uri);
    var propIDs := ws.fetch(QN_PREFIX_URI)
                     .fetch(WS)
                     .leftjoin(prefix_uri.reverse()).mirror();
    var prop_str := propIDs.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    propIDs := prop_str.leftjoin(local.reverse());

    # add missing qnames, that are not the ``nil'' string, to the storage
    var missing := local.select(str(nil),str(nil)).kdiff(propIDs.reverse()).mark(0@0).reverse();
    var seqb := oid (ws.fetch(QN_LOC).fetch(WS).count() +
                     int (ws.fetch(QN_LOC).fetch(WS).seqbase()));
    var new_names := missing.leftfetchjoin(prefix).[+](str('\1')).[+](
                     missing.leftfetchjoin(uri).[+](str('\1')).[+](
                     missing.leftfetchjoin(local)));
        # only search unique values
        new_names := new_names.kunique();
        # create new key with references to the original ones
        new_names := new_names.mark(seqb).reverse().leftfetchjoin(missing);

    var new_prefix := new_names.leftfetchjoin(prefix);
    var new_uri := new_names.leftfetchjoin(uri);
    var new_local := new_names.leftfetchjoin(local);
    ws.fetch(QN_URI).fetch(WS).insert(new_uri);
    ws.fetch(QN_PREFIX).fetch(WS).insert(new_prefix);
    ws.fetch(QN_LOC).fetch(WS).insert(new_local);
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(new_prefix.[+](str('\1')).[+](new_uri));
    ws.fetch(QN_LOC_URI).fetch(WS).insert(new_local.[+](str('\1')).[+](new_uri));

    # lookup IDs of the qnames
    var ns := ws.fetch(QN_PREFIX_URI)
                .fetch(WS)
                .leftjoin(prefix_uri.reverse());
    var loc := ws.fetch(QN_LOC).fetch(WS)
                 .leftjoin(local.reverse());
    propIDs := ns.intersect(loc);
    # add missing nil values again
    return local.mirror()
                .outerjoin(propIDs.reverse())
                # the result head is aligned with the heads from the input
                .reverse().mark(seqbase(local)).reverse();
}
ADDHELP("add_qnames", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,str] prefix : prefix of qname\n\
BAT[void,str] uri    : URI of the qname\n\
BAT[void,str] local  : local part of the qname\n\
BAT[void,BAT] ws     : working set that stores the qname\n\
DESCRIPTION:\n\
add_qnames adds qnames consisting of the three strings prefix,\n\
uri, and local to the working set (ws). The return value is the\n\
identifier that corresponds to the qname in the qname container\n\
of the transient nodes.\n\
NOTE: the working set 'ws' is changed as side effect!",
        "pathfinder");

# add_qname changes the working set as side effect
PROC add_qname (str prefix, str uri, str local, BAT[void,BAT] ws) : oid
{
    var propID := ws.fetch(QN_PREFIX_URI)
                    .fetch(WS)
                    .ord_uselect(prefix + str('\1') + uri).mirror();
    var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    propID := prop_str.ord_uselect(local);
    prop_str := nil;
    var itemID;
    if (propID.count() = 0)
    {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID, uri);
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID, prefix);
        ws.fetch(QN_LOC).fetch(WS).insert(itemID, local);
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID, prefix + str('\1') + uri);
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID, local + str('\1') + uri);
    } else { 
        itemID := propID.reverse().fetch(0);
    }
    return itemID;
}
ADDHELP("add_qname", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
str           prefix : prefix of qname\n\
str           uri    : URI of the qname\n\
str           local  : local part of the qname\n\
BAT[void,BAT] ws     : working set that stores the qname\n\
DESCRIPTION:\n\
add_qname adds a qname consisting of the three strings prefix,\n\
uri, and local to the working set ws. The return value is the\n\
identifier that corresponds to the qname in the qname container\n\
of the transient nodes.\n\
NOTE: the working set 'ws' is changed as side effect!",
        "pathfinder");

PROC text_constr (BAT[void, str] item, BAT[void, BAT] ws) : BAT[void,BAT]
{
    # find all strings that are not already in the working set ...
    var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
    var unq_str := item.tunique().mark(0@0).reverse();
    var str_unq := unq_str.reverse().kdiff(ws_prop_text.reverse());
    unq_str := nil;
    # ... and add them to the PROP_TEXT container
    var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
    unq_str := str_unq.mark(seqb).reverse();
    str_unq := nil;
    ws_prop_text := ws_prop_text.insert(unq_str);
    unq_str := nil;

    # get the property values of the strings;
    # we invest in sorting ws_prop_text &  X_strings/item on the TYPE_str 
    # join columns as the mergejoin proved to be faster and more robust with
    # large BATs than a hashjoin
    var ws_text_prop := ws_prop_text.reverse().sort();
    var X_item := item.mark(0@0);
    var X_strings := item.reverse().mark(0@0).sort().reverse();
    var X_prop := X_strings.leftjoin(ws_text_prop);
    X_strings := nil;
    ws_text_prop := nil;
    var newProp := X_item.leftjoin(X_prop);
    X_item := nil;
    X_prop := nil;

    # add new text nodes to the working set
    var seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS)) +
                    int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
    var newPre_prop := newProp.reverse().mark(seqb).reverse();
    newProp := nil;
    ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
    ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
    ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
    ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
    ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));

    { # add index entries for optimized scj
        var kind_pre_ := newPre_prop.mark(nil).reverse().chk_order();
        ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
    }
    newPre_prop := nil;
    item := item.mark(seqb);
    seqb := nil;

    # return result as a BAT of BATs
    var res := new (void, BAT).insert (nil, ws)
                              .insert (nil, item)
                              .insert (nil, item.project(WS))
                              .seqbase (0@0);

    { # adding new fragments to the WS_FRAG bat
        var seqb := ws.fetch(WS_FRAG).count();
        seqb := oid(seqb);
        var new_pres := item.reverse().mark(seqb).reverse();
        seqb := nil;
        ws.fetch(WS_FRAG).insert(new_pres);
        new_pres := nil;
        ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
    }

    return res;
}
ADDHELP("text_constr", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,str] item : content of the text nodes\n\
BAT[void,BAT] ws   : working set that stores the document representations\n\
DESCRIPTION:\n\
text_constr is a generic text constructor that creates for each\n\
item a new textnode. These textnodes are added to the working\n\
set ws. Output is a BAT of BATs with the following components:\n\
(a) the modified working set,\n\
(b) the pre values of the textnodes, and\n\
(c) the frag values of the textnodes",
        "pathfinder");

PROC attr_constr (BAT[void, oid] qn, BAT[void, str] item, BAT[void, BAT] ws) : BAT[void,BAT]
{
    # find all strings that are not already in the working set ...
    var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
    var unq_str := item.tunique().mark(0@0).reverse();
    var str_unq := unq_str.reverse().kdiff(ws_prop_val.reverse());
    unq_str := nil;
    # ... and add them to the PROP_VAL container
    var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
    unq_str := str_unq.mark(seqb).reverse();
    str_unq := nil;
    ws_prop_val := ws_prop_val.insert(unq_str);
    unq_str := nil;

    # get the property values of the strings;
    # we invest in sorting ws_prop_val &  X_strings/item on the TYPE_str 
    # join columns as the mergejoin proved to be faster and more robust with
    # large BATs than a hashjoin
    var ws_val_prop := ws_prop_val.reverse().sort();
    var X_item := item.mark(0@0);
    var X_strings := item.reverse().mark(0@0).sort().reverse();
    var X_prop := X_strings.leftjoin(ws_val_prop);
    X_strings := nil;
    ws_val_prop := nil;
    var newProp := X_item.leftjoin(X_prop);
    X_item := nil;
    X_prop := nil;

    # add new text nodes to the working set
    var seqb := oid(count(ws.fetch(ATTR_OWN).fetch(WS)) +
                    int(ws.fetch(ATTR_OWN).fetch(WS).seqbase()));
    var newAttr_prop := newProp.reverse().mark(seqb).reverse();
    newProp := nil;
    ws.fetch(ATTR_PROP).fetch(WS).insert(newAttr_prop);
    ws.fetch(ATTR_OWN).fetch(WS).insert(newAttr_prop.mark(nil));
    ws.fetch(ATTR_QN).fetch(WS).insert(qn.reverse().mark(seqb).reverse());
    ws.fetch(ATTR_FRAG).fetch(WS).insert(newAttr_prop.project(WS));

    newAttr_prop := nil;
    item := item.mark(seqb);
    seqb := nil;

    # return result as a BAT of BATs
    var res := new (void, BAT).insert (nil, ws)
                              .insert (nil, item)
                              .insert (nil, item.project(WS))
                              .seqbase (0@0);

    return res;
}
ADDHELP("attr_constr", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,oid] qn   : names of the attributes\n\
BAT[void,str] item : values of the attributes\n\
BAT[void,BAT] ws   : working set that stores the document representations\n\
DESCRIPTION:\n\
attr_constr is a generic attribute constructor that creates for\n\
each aligned qn|item pair a new attribute. These attributes are\n\
added to the working set ws. Output is a BAT of BATs with the\n\
following components:\n\
(a) the modified working set,\n\
(b) the attribute ids, and\n\
(c) the frag values of the attributes",
        "pathfinder");

PROC elem_constr_empty (BAT[void, oid] qn, BAT[void, BAT] ws) : BAT[void,BAT]
{
    # add new element nodes to the working set
    var seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS)) +
                    int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
    var newPre_prop := qn.reverse().mark(seqb).reverse();
    ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
    ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
    ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
    ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(ELEMENT));
    ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));

    { # add index entries for optimized scj
        var kind_pre_ := newPre_prop.mark(nil).reverse().chk_order();
        ws.fetch(KIND_PRE + int(ELEMENT)).fetch(WS).insert(kind_pre_);
    }
    newPre_prop := nil;
    qn := qn.mark(seqb);
    seqb := nil;

    # return result as a BAT of BATs
    var res := new (void, BAT).insert (nil, ws)
                              .insert (nil, qn)
                              .insert (nil, qn.project(WS))
                              .seqbase (0@0);

    { # adding new fragments to the WS_FRAG bat
        var seqb := ws.fetch(WS_FRAG).count();
        seqb := oid(seqb);
        var new_pres := qn.reverse().mark(seqb).reverse();
        seqb := nil;
        ws.fetch(WS_FRAG).insert(new_pres);
        new_pres := nil;
        ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
    }

    return res;
}
ADDHELP("elem_constr_empty", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void,oid] qn   : names of the elements\n\
BAT[void,BAT] ws   : working set that stores the document representations\n\
DESCRIPTION:\n\
elem_constr_empty is a generic element constructor for empty\n\
elements that creates for each qname qn a new element. These\n\
elements are added to the working set ws. Output is a BAT of\n\
BATs with the following components:\n\
(a) the modified working set,\n\
(b) the pre values, and\n\
(c) the frag values of the elements",
        "pathfinder");

PROC elem_constr (BAT[void, oid] qn_iter,
                  BAT[void, oid] qn_item,
                  BAT[void, oid] iter,
                  BAT[oid, oid] pre,
                  BAT[oid, oid] pfrag,
                  BAT[void, oid] attr,
                  BAT[void, oid] afrag,
                  BAT[void, BAT] ws) : BAT[void,BAT]
{
    var root_iter;
    var root_size;
    var root_prop;
    var root_kind;
    var root_frag;
    var root_level;
    # attr
        var root_pre;
        var root_pre_frag;
        
    # throw out nil values and generate iter|item|frag representation
    # for attributes
    var selected := pre.select(nil,nil);
    var piter := selected.mark(0@0).reverse()
                         .leftfetchjoin(iter)
                         # make it void
                         .reverse().mark(0@0).reverse();
    pre := selected.reverse().mark(0@0).reverse();
    pfrag := pfrag.select(nil,nil).reverse().mark(0@0).reverse();
    selected := nil;

    # throw out nil values and generate iter|item|frag representation
    # for attributes
    selected := attr.select(nil,nil);
    var aiter := selected.mark(0@0).reverse()
                         .leftfetchjoin(iter)
                         # make it void
                         .reverse().mark(0@0).reverse();
    attr := selected.reverse().mark(0@0).reverse();
    afrag := afrag.select(nil,nil).reverse().mark(0@0).reverse();
    selected := nil;

    if (pre.count() != 0) {

        # use head to avoid elimination of duplicates
        # (this is additionally used in the content level determination
        var iter_unq := piter.mirror();
        # get all subtree copies
        var res_scj := loop_lifted_descendant_or_self_step 
                           (iter_unq, pre, pfrag, ws, 0);
        iter_unq := nil;

        # variables for the result of the scj 
        var res_iter := res_scj.fetch(0);
        var res_item := res_scj.fetch(1);
        # !be aware that res_frag is only a fake_project!
        var res_frag := res_scj.fetch(2);
        # !avoid being res_iter a fake_project!
        res_iter := de_NO_project (res_iter, res_item);
        res_scj := nil;
            
        # create content_iter as sorting argument for the merged union
        var content_iter := res_iter.leftfetchjoin(piter).chk_order();
        # create subtree copies for all bats
        var content_size := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
        var content_prop := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
        var content_kind := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
        var content_frag := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
        var content_level := mposjoin(res_item, res_frag, ws.fetch(PRE_LEVEL));
        # change the level of the subtree copies
        content_level := content_level.[+](chr(1));
        var contentRoot_level := mposjoin(pre, pfrag, ws.fetch(PRE_LEVEL));
        # map Root_level to the result of the scj 
        #using the faked iteration values
        contentRoot_level := res_iter.leftfetchjoin(contentRoot_level);
        content_level := content_level.[-](contentRoot_level);
        content_level := content_level.reverse().mark(0@0).reverse();
        contentRoot_level := nil;
            
        # attr
            # content_pre is needed for attribute subtree copies
            var content_pre := res_item;
            # as well as content_pre_frag
            var content_pre_frag := res_frag;
            
        # get the maximum level of the new constructed nodes
        # and set the maximum of the working set
        {
            var height := int(content_level.max()) + 1;
            ws.fetch(HEIGHT).replace(WS, 
                                     max(ws.fetch(HEIGHT).fetch(WS),
                                         height));
            height := nil;
        }
            
        root_iter := qn_iter.chk_order();
        # calculate the sizes for the root nodes
        root_size := {count}(content_iter.reverse(), qn_iter.reverse())
                             .reverse().mark(seqbase(qn_iter)).reverse();
        root_prop := qn_item;
        root_kind := fake_project(ELEMENT);
        root_frag := fake_project(WS);
        root_level := fake_project(chr(0));

        # attr
            # root_pre is a dummy needed for merge union with content_pre 
            root_pre := fake_project(oid(nil));
            # as well as root_frag_pre
            root_pre_frag := fake_project(oid(nil));

        # merge union root and nodes
        {
        var merged_result := merged_union (
                                 root_iter, content_iter,
                                 root_size, content_size,
                                 root_level, content_level,
                                 root_kind, content_kind,
                                 root_prop, content_prop,
                                 root_frag, content_frag,
        # attr
                                 root_pre, content_pre,
                                 root_pre_frag, content_pre_frag);
        root_iter := nil;
        content_iter := nil;
        content_size := nil;
        content_level := nil;
        content_kind := nil;
        content_prop := nil;
        content_frag := nil;
        # attr
            content_pre := nil;
            content_pre_frag := nil;
        root_size := merged_result.fetch(1);
        root_level := merged_result.fetch(2);
        root_kind := merged_result.fetch(3);
        root_prop := merged_result.fetch(4);
        root_frag := merged_result.fetch(5);
        # attr
            root_pre := merged_result.fetch(6);
            root_pre_frag := merged_result.fetch(7);

        merged_result := nil;

        # printing output for debugging purposes
            # print("merged (root & content)");
            # print(root_size, [int](root_level), [int](root_kind), root_prop);
        }

    } else { # end of ``if (pre.count() != 0)''

        root_size := qn_iter.project(0);
        root_prop := qn_item; # !the seqbase of qn_item is later modified
        root_kind := qn_iter.project(ELEMENT);
        root_frag := qn_iter.project(WS);
        root_level := qn_iter.project(chr(0));
        # attr
            root_pre := qn_iter.project(oid(nil));
            root_pre_frag := qn_iter.project(oid(nil));

    }  # end of else in ``if (pre.count() != 0)''
        
    # set the offset for the new created trees
    {
        var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))
                        + int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
        root_size := root_size.seqbase(seqb);
        root_prop := root_prop.seqbase(seqb);
        root_kind := root_kind.seqbase(seqb);
        root_frag := root_frag.seqbase(seqb);
        root_level := root_level.seqbase(seqb);
        # attr
            # get the new pre values
            root_pre := root_pre.seqbase(seqb);
            root_pre_frag := root_pre_frag.seqbase(seqb);
        seqb := nil;
    }

    # insert the new trees into the working set
    ws.fetch(PRE_SIZE).fetch(WS).insert(root_size);
    ws.fetch(PRE_KIND).fetch(WS).insert(root_kind);
    ws.fetch(PRE_PROP).fetch(WS).insert(root_prop);
    ws.fetch(PRE_FRAG).fetch(WS).insert(root_frag);
    ws.fetch(PRE_LEVEL).fetch(WS).insert(root_level);

    # update indexes
    {
      var knd := ELEMENT;
      while ( knd <= DOCUMENT ) {
        var kind_root := root_kind.ord_uselect(knd).reverse().chk_order();
        ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind_root);
        if (knd = ELEMENT) {
          var prop_root := kind_root.reverse().mirror()
                                    .leftfetchjoin(root_prop)
                                    .reverse().chk_order();
          ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop_root);
        }
        if (knd = PI) {
          var prop_root := kind_root.reverse().mirror()
                                    .leftfetchjoin(root_prop)
                                    .reverse().chk_order();
          ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop_root);
        }
        knd :+= chr(1);
      }
    }

    # save the new roots for creation of the intermediate result
    var roots := root_level.ord_uselect(chr(0));
    # (note that all operations are order preserving and ``mark''
    # aligns the key with the qn_iter input 
    roots := roots.mark(0@0).reverse();

    # resetting the temporary variables
    root_size := nil;
    root_prop := nil;
    root_kind := nil;
    root_frag := nil;
    root_level := nil;
        
    # adding the new constructed roots to the WS_FRAG bat of the
    # working set, that a following (preceding) step can check
    # the fragment boundaries
    {
        var seqb := oid(count(ws.fetch(WS_FRAG)));
        var new_pre_values := roots.reverse().mark(seqb).reverse();
        seqb := nil;
        ws.fetch(WS_FRAG).insert(new_pre_values);
        new_pre_values := nil;
    }

    # ----------------------------------
    # ----- ATTRIBUTE TRANSLATION ------
    # ----------------------------------
    # 1. step: add subtree copies of attributes
    if (pre.count() != 0) { # but only if there are any subtree nodes
        # lookup the affected attributes using the old pre values
        var preNew_attr := mvaljoin(root_pre, 
                                    root_pre_frag,
                                    ws.fetch(ATTR_OWN));
        # lookup the first free attr value
        var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
        # split up result of mvaljoin and mark them with the correct seqbase
        var attrNew_preNew := preNew_attr.mark(seqb).reverse();
        var attrNew_attrOld := preNew_attr.reverse().mark(seqb).reverse();
        preNew_attr := nil;
        var attrNew_pre_frag := attrNew_preNew.leftfetchjoin(root_pre_frag);
        # help MIL to keep head void
        attrNew_pre_frag := attrNew_pre_frag.reverse().mark(seqb).reverse();
        seqb := nil;

        # get the values of the QN/OID offsets for the reference to the
        # string values
        var attrNew_qn := mposjoin(attrNew_attrOld,
                                   attrNew_pre_frag,
                                   ws.fetch(ATTR_QN));
        var attrNew_prop := mposjoin(attrNew_attrOld,
                                     attrNew_pre_frag,
                                     ws.fetch(ATTR_PROP));
        # get fragment where values are stored (not where attribute is stored)
        var attrNew_frag := mposjoin(attrNew_attrOld,
                                     attrNew_pre_frag,
                                     ws.fetch(ATTR_FRAG));
        attrNew_attrOld := nil;
        attrNew_pre_frag := nil;

        ws.fetch(ATTR_QN).fetch(WS).insert(attrNew_qn);
        ws.fetch(ATTR_PROP).fetch(WS).insert(attrNew_prop);
        ws.fetch(ATTR_OWN).fetch(WS).insert(attrNew_preNew);
        ws.fetch(ATTR_FRAG).fetch(WS).insert(attrNew_frag);
        attrNew_qn := nil;
        attrNew_prop := nil;
        attrNew_preNew := nil;
        attrNew_frag := nil;
    }

    # 2. step: add attribute binding for new elements
    if (attr.count() != 0) { # but only if there are any top level attributes
        
        # use iter, qn and frag to find unique combinations
        var attr_qn := mposjoin(attr, afrag, ws.fetch(ATTR_QN));
        var attr_frag := mposjoin(attr, afrag, ws.fetch(ATTR_FRAG));
        var sorting := aiter.reverse().sort().reverse();
        sorting := sorting.CTrefine(mposjoin(attr_qn,
                                             attr_frag,
                                             ws.fetch(QN_LOC_URI)));
        var unq_attrs := sorting.tunique();
        sorting := nil;
        # test uniqueness
        if (unq_attrs.count() != aiter.count())
        {
           if (qn_item.count() > 0) {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.",
                      qn_item.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS))
                             .fetch(0));
           } else {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
        }
        unq_attrs := nil;

        var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
        attr_qn := attr_qn.seqbase(seqb);
        var attr_own := aiter.leftjoin(qn_iter.reverse())
                             .leftfetchjoin(roots)
                             .reverse().mark(seqb).reverse();
        var attr_prop := mposjoin(attr, afrag, ws.fetch(ATTR_PROP));
        attr_prop := attr_prop.seqbase(seqb);
        attr_frag := attr_frag.seqbase(seqb);
        seqb := nil;

        ws.fetch(ATTR_QN).fetch(WS).insert(attr_qn);
        ws.fetch(ATTR_PROP).fetch(WS).insert(attr_prop);
        ws.fetch(ATTR_OWN).fetch(WS).insert(attr_own);
        ws.fetch(ATTR_FRAG).fetch(WS).insert(attr_frag);
        attr_qn := nil;
        attr_prop := nil;
        attr_own := nil;
        attr_frag := nil;
    }

    # create result as a BAT of BATs
    var res := new (void, BAT).insert (nil, ws)
                              .insert (nil, roots)
                              .insert (nil, roots.project(WS))
                              .seqbase (0@0);
    roots := nil;

    return res;
}
ADDHELP("elem_constr", "tsheyar", "Oct 2005",
        "PARAMETERS:\n\
BAT[void, oid] qn_iter : iteration values of the qnames\n\
BAT[void, oid] qn_item : names of the elements\n\
BAT[void, oid] iter    : iteration values of the content\n\
BAT[oid, oid] pre      : pre values of the content (heads aligned with head of iter)\n\
BAT[oid, oid] pfrag    : node frag values of the content (heads aligned with head of iter)\n\
BAT[void, oid] attr    : attribute ids of the content (heads aligned with head of iter)\n\
BAT[void, oid] afrag   : attribute fragments of the content (heads aligned with head of iter)\n\
BAT[void, BAT] ws      : working set that stores the document representations\n\
DESCRIPTION:\n\
elem_constr is a full featured element constructor that requires\n\
qn|iter pairs for the name part and iteration, attribute, and node\n\
information for the content. These elements are added to the working\n\
set ws. Output is a BAT of BATs with the following components:\n\
(a) the modified working set,\n\
(b) the pre values, and\n\
(c) the frag values of the elements",
        "pathfinder");


PROC destroy_ws_locked(BAT[void,bat] ws) : void
{
    doc_query.select(int(ws))@batloop() {
        var doc_oid := $h;
        doc_query.delete(doc_oid, int(ws));
        if (not(doc_query.exist(doc_oid))) {
            if (doc_sema.exist(doc_oid)) {
                sema_up(doc_sema.find(doc_oid));
            }
        }
    }
    # determine whether a cache flush is desired (only count cached bats, those with a timestamp)
    var cursize := sum(bat("doc_timestamp").select(timestamp(nil),timestamp(nil)).mirror().join(bat("doc_size")));
    var maxsize := (1024LL * 1024LL) * lng(monet_environment.find("xquery_cacheMB"));

    if (cursize > maxsize) {
        delete_all_docs_locked(true);
    }
}

PROC destroy_ws(BAT[void,bat] ws) : void
{
    var err;

    if (type(doc_query) != bat) { return; }

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(destroy_ws_locked(ws));
    lock_unset(pf_lock);

    if (not(isnil(err))) { ERROR(err); }
}

PROC shred_doc_locked(BAT[str,bat] docBAT, str location, str name, timestamp ts, int ws, int height) : void 
{
    # get a new persistent doc id
    var doc_oid := 0@0;
    if (bat("doc_name").count() > 0) 
        doc_oid := oid(int(bat("doc_name").reverse().max()) + 1); 

    # rename all new bats with the doc id as suffix
    [rename](docBAT, [+](mirror(docBAT), str(int(doc_oid))));
    var totsize := sum([batsize](docBAT));

    # add to meta table
    bat("doc_name").insert(doc_oid, name);
    bat("doc_location").insert(doc_oid, location);
    bat("doc_timestamp").insert(doc_oid, ts);
    bat("doc_height").insert(doc_oid, height);
    bat("doc_size").insert(doc_oid, totsize);

    [persists](docBAT, true);

    # add the meta table to the commit set 
    #docBAT.insert(str(nil),bat("doc_name"));
    #docBAT.insert(str(nil),bat("doc_location"));
    #docBAT.insert(str(nil),bat("doc_timestamp"));
    #docBAT.insert(str(nil),bat("doc_height"));
    #docBAT.insert(str(nil),bat("doc_size"));
    #if (not(subcommit(docBAT))) 
    if (not(commit())) ERROR("shred_doc(%s) : commit failed\n");

    if (not(isnil(ws))) {
        pin_doc(doc_oid, ws);
    }
}

# HACK: overwrite 'height'
PROC shred_doc_impl(str location, str name, bit doCommit, str opt, timestamp ts, int ws) : BAT[void,bat]
{
    var err, exists := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(exists := doc_check(name));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
    else if (exists) ERROR("shred_doc(%s): already exists in database!\n", name);

    # shred it unlocked
    var docBAT := new(str,bat,WS_SIZE); # contains all new bats
    var us := usec();
    var shredRES := shred2bats(location,opt);

    # use the ws macro to get the the basic working set (excluding views, constants and indices)
@= shred_doc_ws
    if (and(=(@3, bat), <(@1, DOC_LOADED)))
        docBAT.insert(toLower("@1"), shredRES.fetch(@1));
@mil
    @:ws(shred_doc)@

    # these are simple concatenations (to accelerate combPRINT_WS_SZined lookup)
    docBAT.insert("qn_prefix_uri", docBAT.find("qn_prefix").[+](str('\1')).[+](docBAT.find("qn_uri")));
    docBAT.insert("qn_loc_uri",    docBAT.find("qn_loc").[+](str('\1')).[+](docBAT.find("qn_uri")));

    # create our indices
    var knd := ELEMENT;
    while ( knd <= DOCUMENT ) {
        docBAT.insert("kind_pre" + "_" + str(chr(48 + knd)),
                      docBAT.find("pre_kind").ord_uselect(knd).reverse().chk_order());
        knd :+= chr(1);
    }

    var knd_pre_bat := docBAT.find("kind_pre" + "_" + str(chr(48 + ELEMENT))).reverse().mirror();
    var prop_pre_bat := knd_pre_bat.leftfetchjoin(docBAT.find("pre_prop")).reverse().chk_order();
    if (not(ordered(prop_pre_bat))) {
        var _prop := prop_pre_bat.mark(0@0).reverse();
        var _pre  := prop_pre_bat.reverse().mark(0@0).reverse();
        var ord := _prop.reverse().sort().reverse();
            ord := ord.CTrefine(_pre).mark(nil);
        prop_pre_bat := prop_pre_bat.fetch(ord);
        prop_pre_bat := prop_pre_bat.chk_order();
    }
    docBAT.insert("prop_pre" + "_" + str(chr(48 + ELEMENT)), prop_pre_bat);

    knd_pre_bat := docBAT.find("kind_pre" + "_" + str(chr(48 + PI))).reverse().mirror();
    prop_pre_bat := knd_pre_bat.leftfetchjoin(docBAT.find("pre_prop")).reverse().chk_order();
    if (not(ordered(prop_pre_bat))) {
        var _prop := prop_pre_bat.mark(0@0).reverse();
        var _pre  := prop_pre_bat.reverse().mark(0@0).reverse();
        var ord := _prop.reverse().sort().reverse();
            ord := ord.CTrefine(_pre).mark(nil);
        prop_pre_bat := prop_pre_bat.fetch(ord);
        prop_pre_bat := prop_pre_bat.chk_order();
    }
    docBAT.insert("prop_pre" + "_" + str(chr(48 + PI)), prop_pre_bat);

    height := shredRES.fetch(PRE_LEVEL).max().int() + 1;

    docBAT := docBAT.access(BAT_READ);
    if (doCommit) {
        [mmap](docBAT, [ifthenelse]([<]([count](docBAT), 65536), STORE_MEM, STORE_MMAP));
        [save](docBAT);

        # add doc to the database locked
        lock_set(pf_lock);
        err := CATCH(shred_doc_locked(docBAT, location, name, ts, ws, height));
        lock_unset(pf_lock);

        if (not(isnil(err))) ERROR(err);
    }
    return docBAT;
}

PROC shred_doc_base(str location, str name, bit doCommit, str opt) : BAT[void,bat]
{
    var height, us := usec();
    var docBAT := shred_doc_impl(location, name, doCommit, opt, timestamp(nil), int(nil));
    # save all persistent BATs and print timings
    us := usec() - us;
    var ms := us/1000;
    if ( doCommit ) {
        printf("# Shredded XML doc(\"%s\"), total time after commit=%lld.%03llds\n", name, ms/1000,ms%1000);
    } else {
        printf("# Shredded XML doc(\"%s\") uncommitted, total time =%lld.%03llds\n", name, ms/1000,ms%1000);
    }
    return docBAT;
}

PROC shred_doc(str location, str name) : void
{
    shred_doc_base(location, name, true, "");
}
ADDHELP("shred_doc", "flokstra", "Dec 2004",
"PARAMETERS:\n\
- str URI containing the xml document to be shredded)\n\
- str document name ('alias') in database\n\
DESCRIPTION:\n\
Shred xml document to the internal Pathfinder format, (analog to import_doc()).",
"pathfinder");

PROC delete_doc_locked(oid doc_oid) : bit
{
    var docBAT := new(void,str,WS_SIZE);

    if (doc_sema.exist(doc_oid)) {
        # somebody else is deleting the same doc!
        while(doc_sema.exist(doc_oid)) {
            lock_unset(pf_lock);
            sleep(1);
            lock_set(pf_lock);
        }
        return; # now he is done
    }
    # we will delete it
    while (doc_query.exist(doc_oid)) {
        var sem := sema_create(0);
        doc_sema.insert(doc_oid, sem);

        lock_unset(pf_lock);
        sema_down(sem); # wait for the users to go away 
        lock_set(pf_lock);

        sema_destroy(sem);
        doc_sema.delete(doc_oid, sem);
    }

    # use the ws macro to get the names of all non-(view or constant) bats
@= getlower_ws
    if (@3 = bat)
        docBAT.insert(nil, toLower("@1"));
@mil
    @:ws(getlower)@
    docBAT := docBAT.access(BAT_READ);

    # docBAT becomes [name,bat]
    docBAT := [bat]([+](docBAT, str(int(doc_oid))).reverse().mirror());

    # rename the bats so even in case of failure they don't bother us directly anymore
    [rename](docBAT, [+]([+]("rm_", mirror(docBAT)), +("_" , str(lng(current_timestamp()))))).access(BAT_WRITE);

    # remove them from the repository
    [persists](docBAT, false);

    bat("doc_name").delete(doc_oid);
    bat("doc_location").delete(doc_oid);
    bat("doc_timestamp").delete(doc_oid);
    bat("doc_height").delete(doc_oid);
    bat("doc_size").delete(doc_oid);

    # also commit the meta bats
    #docBAT.insert(str(nil), bat("doc_name"));
    #docBAT.insert(str(nil), bat("doc_location"));
    #docBAT.insert(str(nil), bat("doc_timestamp"));
    #docBAT.insert(str(nil), bat("doc_height"));
    #docBAT.insert(str(nil), bat("doc_size"));
    #return subcommit(docBAT);
    return commit();
}

PROC delete_doc(str name) : void
{
    var err, exists := false;

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(exists := doc_check(name));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
    else if (not(exists)) ERROR("delete_doc(%s): document not found in database!\n", name);

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_doc_locked(bat("doc_name").reverse().find(name)));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
}
ADDHELP("delete_doc", "tsheyar", "July 2004",
"PARAMETERS:\n\
str document name\n\
DESCRIPTION:\n\
delete the persistent BATS that store the document.",
"pathfinder");

PROC delete_all_docs_locked(bit cachedOnly) : void
{
    doc_init();
    bat("doc_timestamp").copy()@batloop() {
        if (or(cachedOnly, not(isnil($t))))
            delete_doc_locked($h);
    }
}

PROC delete_all_docs(bit cachedOnly) : void
{
    var err, b := bat(timestamp,str);

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(delete_all_docs_locked(cachedOnly));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);
}
ADDHELP("delete_all_docs", "tsheyar", "July 2004",
"DESCRIPTION:\n\
deletes all persistent document BATs that store xml documents.",
"pathfinder");


PROC pin_doc(oid doc_oid, int ws) : void 
{
    # pin the document on this working set (must hold lock!)
    doc_query.insert(doc_oid, int(ws));
}

# HACK: this proc overwrites variables 'lifetime' and 'ts'
PROC add_doc_locked(str name, int ws) : oid
{
    var doc_oid := nil;
    var filename := name;
    var lim := timestamp(nil);

    # check if the document already existed
    if (doc_check(name)) {
        doc_oid := bat("doc_name").reverse().find(name);
    } else if (bat("doc_location").reverse().exist(name)) {
        # existed as cached location (URI): must check timestamp
        var doc_oid := bat("doc_location").reverse().find(name);
    }

    # do some first analysis on the URI
    if (not(isnil(doc_oid))) { 
        filename := bat("doc_location").find(doc_oid);
        lim := bat("doc_timestamp").find(doc_oid);
    }

    if (startsWith(filename, "file://") or startsWith(filename, "FILE://")) {
        filename := string(filename, 7);
    } else {
        idx := search(filename, "://");
    }
    if (idx >= 0) {
        # add uri-dependent lifetime
        var uri_lifetime := bat("uri_lifetime");
        var b := [startsWith](filename, mirror(uri_lifetime)).uselect(true);
        if (b.count() > 0) {
            var matchlen := [length](mirror(b));
            lifetime := *(1000LL, uri_lifetime.find(matchlen.reverse().find(matchlen.max())));
        } else {
            lifetime := lng(nil); # doc will *not* be cached 
        }
    } else {
        # a file: get lastmodification time
        var tts;
        var err := CATCH(tts := lastmod_time(filename));
        if (isnil(err)) {
            ts := tts; # timestamp was read succesfully
        } else if (not(isnil(lim))) {
            ts := add(lim, 1LL); # file-error on cached file: force remove
        }
    }

    if (isnil(doc_oid)) {
        return nil; # document not in database
    } else if (and(not(isnil(lim)), >(ts,lim))) { # if so, check if it still valid
        # remove outdated document from the cache
        delete_doc_locked(doc_oid); 
        return nil;
    }
    pin_doc(doc_oid, ws); # make sure nobody can delete it
    return doc_oid;
}

# if docid != "", it holds the str(id) of the persistent doc
# if not, the temporary document is in tmp_doc (by name without id)
PROC lookup_bat(BAT[str,bat] tmp_doc, str name, str docid) : bat[any,any]
{
    if (docid != "") return bat(name + docid);
    return tmp_doc.find(name);
}

PROC add_docbat(BAT[void,bat] ws, BAT[str,bat] docBAT, str name, str docid, int height) : oid
{
    # add it to the working set
    var frag := ws.fetch(DOC_LOADED).uselect(name);

    if (frag.count() = 0) {
        ws.fetch(DOC_LOADED).insert(nil,name);
        frag := oid(ws.fetch(DOC_LOADED).count());

        # use the ws macro to instantiate all non-(view or constant) bats
@= add_doc_bat_ws
        if (@3 = bat)
            ws.fetch(@1).insert(nil,docBAT.lookup_bat(toLower("@1"), docid));
@mil
        @:ws(add_doc_bat)@

        # create views
        ws.fetch(PRE_FRAG).insert(nil,fake_project(frag));
        ws.fetch(ATTR_FRAG).insert(nil,fake_project(frag));

        # adapt constants
        ws.fetch(FRAG).replace(0@0,frag);

        if (isnil(height))
          height := ws.fetch(PRE_LEVEL).max().int() + 1;
        ws.fetch(HEIGHT).insert(nil,height);
     } else { 
        ws.fetch(FRAG).replace(0@0,frag.reverse().fetch(0)); 
     }
     return frag;
}

var time_shred := 0; # dummy declarartion to avoid errors when timing is not activated in the script

# HACK: this proc overwrites variable 'time_shred' 
PROC add_doc(BAT[void,bat] ws, str name) : BAT[void,bat]
{
    var ts := current_timestamp();
    var lifetime := 0LL;
    var idx := -1;
    var doc_oid;
    var err, height;
    var t := time();

    # always make sure not to cause errors while holding the lock
    lock_set(pf_lock);
    err := CATCH(doc_oid := add_doc_locked(name, int(ws)));
    lock_unset(pf_lock);

    if (not(isnil(err))) ERROR(err);

    var docBAT, docid := "", doCommit := true;

    if (isnil(doc_oid)) {
        ts := add(ts, lifetime);
        if (isnil(ts)) doCommit := false;
        docBAT := shred_doc_impl(name, name, doCommit, "", ts, int(ws));
        # overwrites 'height'
        time_shred :+=  time() - t;
    } else {
        docBAT := new(str,bat);
    }
    if (doCommit) { 
        docid := str(int(bat("doc_name").reverse().find(name)));
        height := bat("doc_height").find(oid(int(docid)));
    }
    add_docbat(ws, docBAT, name, docid, height);  
    return ws;
}


@- xml document cache
When fn:doc() is used with a previously unseen URI, it is shredded on the fly and placed into 
the xml document cache (see text below). A number of procs are provided to monitor
and control the behavior of the cache.
@mil
const xmlcache_help := 
"The XML document cache keeps indexed copies of documents that where recently\n\
used in the fn:doc(URI) xquery function.\n\
\n\
The size of the cache is controlled using the 'xquery_cacheMB' setting in\n\
the 'MonetDB.conf' file.\n\
\n\
For file URIs, the cache looks at the last-modification-time of the file on disk\n\
to guarantee that the cached document is still up-to-date for answering queries from.\n\
\n\
For other URIs, *lifetime rules* determine how long documents can stay in the cache.\n\
Each lifetime rule consists of a URI prefix and the registered seconds of lifetime.\n\
\n\
The rule with longest prefix that matches an URI counts. Specifying a lifetime\n\
of 'int(nil)' seconds means that the URI will *not* be cached at all.\n\
This is also the default if no prefix matches an URI.\n\
\n\
The name of a cached document is the same as its location (URI). For explicitly\n\
shredded documents (with 'shred_doc(location,name)'), the name is an 'alias' and\n\
may differ from the URI. Explicitly shredded documents fall outside the XML document\n\
cache; documents are only removed at explicit user request (with 'delete_doc(name)').";

PROC xmlcache_add_rule(str uri, any lifetime) : void {
    xmlcache_add_rule(uri, lng(lifetime)); 
}
PROC xmlcache_add_rule(str uri, lng lifetime) : void {
    lock_set(pf_lock);
    var err := CATCH({ doc_init(); bat("uri_lifetime").delete(uri); bat("uri_lifetime").insert(uri, lifetime); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_add_rule", "boncz", "May 2005",
"DESCRIPTION:\nadd a new URI lifetime rule.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_del_rule(str uri) : void {
    lock_set(pf_lock);
    var err := CATCH({doc_init(); bat("uri_lifetime").delete(uri);});
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_del_rule", "boncz", "May 2005",
"DESCRIPTION:\ndeletes an existing URI lifetime rule.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_print_rules() : void {
    lock_set(pf_lock);
    var err := CATCH({ doc_init(); table(bat("uri_lifetime").mark(0@0).reverse().col_name("URI-prefix"), bat("uri_lifetime").reverse().mark(0@0).reverse().col_name("liftime-secs")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_print_rules", "boncz", "May 2005",
"DESCRIPTION:\nshows all URI lifetime rules.\n\n" + xmlcache_help,  "pathfinder");

PROC xmlcache_print() : void {
    lock_set(pf_lock);
    var err := CATCH({ doc_init(); table(bat("doc_name").col_name("alias"), bat("doc_location").col_name("URI"), bat("doc_size").col_name("size"), bat("doc_timestamp").select(timestamp(nil),timestamp(nil)).col_name("valid-thru")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmlcache_print", "boncz", "May 2005",
        "DESCRIPTION:\nshows the actual content of the XML document cache.\n\n" + xmlcache_help,  "pathfinder");

PROC xmldb_print() : void {
    lock_set(pf_lock);
    var err := CATCH({ doc_init(); table(mirror(bat("doc_timestamp").uselect(timestamp(nil))).join(bat("doc_name")).col_name("alias"), bat("doc_location").col_name("URI"), bat("doc_size").col_name("size")); });
    lock_unset(pf_lock);
    if (not(isnil(err))) ERROR(err);
}
ADDHELP("xmldb_print", "boncz", "May 2005",
"DESCRIPTION:\nshows the actual content of the persistent XML document database (not the XML document cache).\n\nThis consists of all documents explicitly shredded with shred_doc(URI, alias).",  "pathfinder");


@= c_decl_ws
#define @1 @2
@h
#ifndef PATHFINDER_H
#define PATHFINDER_H

#include <monettime.h>
#include <lock.h>
#include <monet.h>
#include <monet_context.h>
#include <monet_interpreter.h>
#include <streams.h>
#include <mapi.h>
#include <pathfinder.proto.h>

@:ws(c_decl)@
@:decl(c)@

#define XTRACT_KIND(X)  (X & 63)
#define XTRACT_FRAG(X)  (X >> 6)

/*
 * execute a XQuery function 'method(..params..)'
 *
 * out     = stream where XML output should be printed on
 * module  = url of module where 'method' is declared
 * method  = xquery function name
 * 
 * argc     = #params
 * argcnt[] = #items per param
 * argtpe[] = xquery type of item (as string, e.g. 'xs:integer')
 * argval[] = str representation of item (e.g. '42') 
 *
 * docBAT   = optional shredded document table, that is added to working set
 *            paramas of type xs:anyNode may refer to pre-oids from this table.
 *
 * we return an error string, or NULL iff everything went A-OK
 */
pathfinder_export char* 
xquery_method(stream *out, char* module, char *method, int argc, int* argcnt, char** argtpe, char** argval, BAT* docBAT);


#endif
@c
#include "pathfinder.h"

#define XQUERY_BUFSIZE 16364

/* the xquery builtin type hierarchy */
typedef struct {
    int parent;
    int monet_tpe;
    int kind;
    char* name;
} xquery_type;

#define DOCBAT (ELEM | (1<<6))
#define XQUERY_TYPES 15

xquery_type xquery_types[XQUERY_TYPES+1] =
{ {  5, TYPE_bit, BOOL,   "xs:bool"  },  
  {  2, TYPE_int, INT,    "xs:integer" },
  {  4, TYPE_dbl, DEC,    "xs:decimal" },
  {  4, TYPE_dbl, DBL,    "xs:float" },
  {  5, TYPE_dbl, DBL,    "xs:double" },
  {  7, TYPE_str, STR,    "xs:string" },
  {  8, TYPE_str, STR,    "xs:untypedAtomic" },
  {  8, TYPE_str, STR,    "xdt:anyAtomicType" },
  {  9, TYPE_str, STR,    "xs:anySimpleType" },
  { 14, TYPE_str, STR,    "xs:anyType" },
  { 14, TYPE_str, STR,    "xdt:untypedAny" },
  { 13, TYPE_oid, DOCBAT, "xs:anyElement" },
  { 13, TYPE_oid, DOCBAT, "xs:anyAttribute" },
  { 14, TYPE_oid, DOCBAT, "xs:anyNode" },
  { 15, TYPE_oid, DOCBAT, "xs:anyItem" },
  {  0, TYPE_oid, DOCBAT, "illegal type" } };

/*
 * return xquery type number, given a type string
 */
static int
xquery_typenr(char* tpe) 
{
    int i;
    for(i=0; i<XQUERY_TYPES; i++) 
        if (strcmp(tpe, xquery_types[i].name) == 0) break;
    return i;
}


/* representation of a xquery function signature */
typedef struct {
    int argc;                     /* number of params */
    unsigned int zero;            /* bit-mask that indicates whether param (bit) i can be the empty sequence */
    unsigned int multiple;        /* bit-mask that indicates whether param (bit) i can be a sequence */
    unsigned char tpe[MAXPARAMS]; /* xquery type number (point into above xquery_types table) */
    char name[1];                 /* method name */
} xquery_sig;


/* xquery functions */
typedef struct _xquery_function {
    struct _xquery_function *next;
    oid vid;                      /* vid of first param */
    xquery_sig *sig;              /* method signature */
    char  proc[1];                /* MIL procname */
} xquery_function;


/* xquery modules */
typedef struct _xquery_module {
    struct _xquery_module *next;
    char* prologue;               /* MIL procs defined in this module */
    char* epilogue;               /* MIL procs undefs for this module */
    xquery_function *functions;   /* functions declared in this module */
    char url[1];                  /* module url */
} xquery_module;

/* global list keeps of known modules and their function declarations */
xquery_module *xquery_compiled_modules = NULL;


/* cached functions */
typedef struct _xquery_prepared_function {
    struct _xquery_prepared_function *next;
    xquery_function *def;         /* function definition */
    YYSTREE lt;                   /* cached MIL tree */
} xquery_prepared_function;


/* loaded modules */
typedef struct _xquery_loaded_module {
    struct _xquery_loaded_module *next;
    xquery_module* def;           /* module definition */
    char* ns;                     /* namespace under which the module was loaded */
} xquery_loaded_module;


/* cached MIL client + Xquery specific context */
typedef struct {
    int inuse;
    Cntxt stk;
    int *time_compile;
    char **genType;

    /* query buffer */
    size_t buflen;
    char *buf;
        
    /* value parsing buffer reuse */
    int vallen;
    ptr val;

    /* live BAT handles (note we gave them a memory refcount in BBP) */
    size_t var_usage_size;
    BAT *proc_vid, *var_usage;
    BAT *dbl_values, *int_values, *str_values;
    BAT *fun_vid000, *fun_iter000, *fun_item000, *fun_kind000;
    int *docBAT;

    xquery_prepared_function* prepared_functions;
    xquery_loaded_module *loaded_modules; 
} xquery_client;

/* xquery context cache corresponds slot-by-slot with monet_clients */
xquery_client xquery_clients[MAXCLIENTS + 1];

MT_Lock pf_compiler_lock;
MT_Lock pf_cache_lock;

#include "compile_interface.h"

/*
 * =================== MIL execution ================================
 *
 * int     xquery_interpret(Cntxt stk, YYSTREE t) { 
 *         * execute parsed MIL tree
 *
 * YYSTREE xquery_parse_mil(Cntxt stk, char* buf) { 
 *         * parse MIL buffer into a tree
 *
 * int     xquery_exec_mil(Cntxt stk, char* buf) { 
 *         * execute MIL buffer (parse & execute)
 *
 * void    xquery_header(int debug, char *prologue, char *query, char *epilogue, char *err, char* mapi) 
 *         * print xquery client response header (including any errors)
 *
 * int     xquery_exec(Cntxt stk, int debug, char *prologue, char *query, char *epilogue, char* mapi)
 *         * execute all MIL sections of a compiled query 
 *
 * int     xquery_compile_exec(Cntxt stk, char *mode, char* xquery, int is_url, 
 *                             char** prologue, char** query, char** epilogue) 
 *         * translate xquery to MIL and execute
 *
 * all int-returning functions return error(0)/ok(1)
 */

/*
 * execute parsed MIL tree, return error(-1)/ok(0)
 */
static int 
xquery_interpret(Cntxt stk, YYSTREE t) 
{ 
    ValRecord res;
    int ret = interpret(stk, t, &res);
    if (ret == -TOK_RETURN) {
        /* ignore return value here */
        VALclear(&res);
        ret = 1;
    } else if (ret >= 0) {
        ret = 1;
    } else {
        ret = 0;
    }
    CLEANUP(t);
    return ret;
}

/*
 * parse MIL buffer into a tree
 */
static YYSTREE 
xquery_parse_mil(Cntxt stk, char* buf) 
{ 
    Client c = monet_clients + stk;
    YYSTREE ret = NULL, treebak = c->tree;
    char* bufbak = c->input;
    c->input = buf;
    c->tree = NULL;
    if (parseClient(c, FALSE))
        ret = c->tree;
    c->tree = treebak;
    c->input = bufbak;
    return ret;
}

/*
 * execute MIL buffer (parse & execute), return error(-1)/ok(0)
 */
static int 
xquery_exec_mil(Cntxt stk, char* buf) 
{
    YYSTREE t = xquery_parse_mil(stk, buf); 
    int ret = 0;
    if (t) {
        ret = xquery_interpret(stk, t);
        Myyfree(t);
    }
    return ret;
}

/*
 * print xquery client response header (including any errors), return error(-1)/ok(0)
 */
static void 
xquery_header(int debug, char *prologue, char *query, char *epilogue, char *err, char* mapi) 
{
    if (debug) {
        stream_printf(GDKout,
                "%s#mil#########################################################\n",
                mapi);
        if (prologue && *prologue) stream_write(GDKout, prologue, strlen(prologue), 1);
        else stream_printf(GDKout, "%s#no prologue\n", mapi);
        if (query && *query) stream_write(GDKout, query, strlen(query), 1);
        else stream_printf(GDKout, "%s#no query\n", mapi);
        if (epilogue && *epilogue) stream_write(GDKout, epilogue, strlen(epilogue), 1);
        else stream_printf(GDKout, "%s#no epilogue\n", mapi);
    }
    if (err) {
        if (debug) {
            stream_printf(GDKout, "%s#err#########################################################\n", mapi);
        }
        stream_write(GDKout, err, strlen(err), 1);
    }
}


/*
 * execute all MIL sections of a compiled query, return error(-1)/ok(0)
 */
static int 
xquery_exec(Cntxt stk, int debug, char *prologue, char *query, char *epilogue, char* mapi) 
{
    int ret = 1;
    if (prologue && *prologue) {
        if (debug) {
            stream_printf(GDKout, "%s#exec prologue...############################################\n", mapi);
        }
        if (ret) ret = xquery_exec_mil(stk, prologue);
    }
    if (query) { 
        if (*query) {
            if (debug) {
                stream_printf(GDKout, "%s#exec query...###############################################\n", mapi);
            }
            if (ret) ret = xquery_exec_mil(stk, query);
        }
        if (epilogue && *epilogue) {
            if (debug) {
                stream_printf(GDKout, "%s#exec epilogue...############################################\n", mapi);
            }
            if (ret) ret = xquery_exec_mil(stk, epilogue);
        }
    }
    if (debug) {
        if (ret >= 0) {
            stream_printf(GDKout, "%s#ok##########################################################\n", mapi);
        } else {
            stream_printf(GDKout, "%s#execution failed############################################\n", mapi);
        }
    }
    return ret;
}

/*
 * translate xquery to MIL and execute, return error(-1)/ok(0)
 * We collect the MIL scripts in three sections (prologue,query,epilogue).
 * The query may be NULL, in which case we mean that it should be ignored. 
 */
#define PFURLCACHE(fcn, query) {\
    char *url = query;\
    query = PFurlcache(url);\
    if (query == NULL) {\
        err = (char*) alloca(strlen(url)+80);\
        sprintf(err, "%s(%s): could not retrieve query\n", fcn, url);\
}    }
static int
xquery_compile_exec(Cntxt stk, char *mode, char* xquery, int is_url, char** prologue, char** query, char** epilogue)
{
    int ret = 0, debug = strstr(mode,"debug") != NULL;
    char *mapi = strstr(mode, "mapi")?"=":"";
    char *err = NULL;

    if (debug) {
        stream_printf(GDKout,
                "%s#xquery######################################################\n",
                mapi);
        stream_write(GDKout, xquery, strlen(xquery), 1);
    }
    MT_set_lock(pf_compiler_lock, "xquery_compile_exec");
    if (is_url) {
        PFURLCACHE("xquery_compile_exec", xquery);
    }
    if (err == NULL) {
        char *del = NULL;
        err = PFcompile_MonetDB(xquery, mode, prologue, &del, epilogue);
        if (err == NULL || (prologue && *prologue) || (del && *del) || (epilogue && *epilogue)) {
            ret = 1;
        }
        if (query) {
            *query = del;
        } else if (del) {
            free(del); /* we are ignoring the query part apparently */
        }
    }
    if (err) {
        int len = strlen(err);
        if (*mapi) {
            /* put ! before error lines */
            char *p = err, *q = err;
            while (*p) {
                if (*p++ == '\n')
                    len++;
            }
            err = (char*) alloca(len+3);
            *err = '!'; 
            for (p = err + 1; *q; q++) {
                *p++ = *q;
                if (*q == '\n')
                    *p++ = '!'; 
            }
            /* guard against errors that do not terminate in a newline */
            if (q > err && q[-1] != '\n')
                *p++ = '\n';
            else if (p[-1] == '!')
                p--;
            *p = 0;
            len = p - err;
        }
    }
    MT_unset_lock(pf_compiler_lock, "xquery_compile_exec");
    xquery_header(debug, *prologue, query?*query:NULL, *epilogue, err, mapi);
    return ret && xquery_exec(stk, debug, *prologue, query?*query:NULL, *epilogue, mapi);
}

/*
 * =================== function admin ================================
 *
 * xquery_sig*      xquery_sig_init(char *proc)
 *                  * infer the xquery function signature from the mangled MIl procname (return NULL on error)
 *
 * int              xquery_sig_match(xquery_sig *sig, int argc, int* argcnt, int *argtpe)
 *                  * check whether sig can match the actual parameters (return true/false)
 *
 * xquery_function* xquery_resolve(int stk, char *ns, char *method, int argc, int* argcnt, int* argtpe)
 *                  * resolve a method call in the current xquery context (return NULL if not resolved)
 *
 * char*            xquery_function_call(int stk, int msec, char* mode, char *ns, char *method, 
 *                                       int argc, int* argcnt, char** argtpe, char** argval, BAT *docBAT) {
 *                  * call a function ns:method(). try to use the function cache (ie re-use a cached MIL tree).
 *                    otherwise generate MIL yourself, interpret it (and cache it). Returns error string (NULL if ok).
 */

/*
 * infer the xquery function signature from the mangled MIl procname (return NULL on error)
 */
static xquery_sig* 
xquery_sig_init(char *proc) 
{
    xquery_sig* sig = (xquery_sig*) GDKmalloc(sizeof(xquery_sig)+strlen(proc)); 
    char *cur = (char*) alloca(strlen(proc)); 
    int len = 0;

    strcpy(cur, proc + 3); /* skip fn_ */
    if (sig == NULL) return NULL;
    sig->argc = sig->zero = sig->multiple = 0;

    /* get method name */
    while(cur[0]) {
        if (cur[0] == '_' && cur[1] == '_') {
            cur++; /* unescape '_' */
        } else if (cur[0] == '_') {
            break;
        }
        sig->name[len++] = *cur++;
    }
    sig->name[len] = 0;
    while(*cur++ == '_') {
        char *tpe = cur;
                
        /* parse namespace part */
        for(len=0; cur[0]; cur++) {
            if (cur[0] == '_' && cur[1] == '_') {
                tpe[len++] = '_';
                cur++; /* unescape '_' */
            } else if (cur[0] != '_') {
                tpe[len++] = cur[0];
            } else {
                tpe[len++] = ':';
                cur++; break;
            }
        }
        /* parse type part */
        for(; cur[0]; cur++) {
            if (cur[0] == '_' && cur[1] == '_') {
                tpe[len++] = '_';
                cur++; /* unescape '_' */
            } else if (cur[0] != '_') {
                tpe[len++] = cur[0];
            } else {
                break;
            }
        }
        if (cur[-1] == '0') {
            sig->zero |= 1<<sig->argc; 
        } else if (cur[-1]  == '2') {
            sig->zero |= 1<<sig->argc; 
            sig->multiple |= 1<<sig->argc; 
        } else if (cur[-1]  == '3') {
            sig->multiple |= 1<<sig->argc; 
        }
        cur[-1] = 0;
        if ((sig->tpe[sig->argc++] = xquery_typenr(tpe)) >= XQUERY_TYPES) {
            /* unknown type: don't cache this function */
            GDKfree(sig);
            return NULL;
        }
    }
    return sig;
}


/*
 * check whether sig can match the actual parameters (return true/false)
 */
static int
xquery_sig_match(xquery_sig *sig, int argc, int* argcnt, int *argtpe) 
{
    int i, tpe[MAXPARAMS];
    for(i=0; i< argc; i++) {
        if (argcnt[i] == 0 && !(sig->zero & (1<<i))) return 0; 
        if (argcnt[i] > 1 && !(sig->multiple & (1<<i))) return 0; 
        tpe[i] = argtpe[i];
        while(sig->tpe[i] != tpe[i]) {
            if (tpe[i] >= XQUERY_TYPES) return 0;
            tpe[i] = xquery_types[tpe[i]].parent;
        }
    }
    for(i=0; i< argc; i++) {
        argtpe[i] = tpe[i];
    }
    return 1;
}

/*
 * resolve a method call in the current xquery context (return NULL if nonresolved)
 */
static xquery_function*
xquery_resolve(int stk, char *ns, char *method, int argc, int* argcnt, int* argtpe) 
{
    xquery_client *ctx = xquery_clients + stk;
    xquery_loaded_module *mod = ctx->loaded_modules;

    /* look up ns and method */
    while(mod) {
        if (mod->ns && strcmp(mod->ns, ns) == 0) {
            xquery_function *fun = mod->def->functions;
            while(fun) {
                if (argc == fun->sig->argc && strcmp(method, fun->sig->name) == 0) {
                    if (xquery_sig_match(fun->sig, argc, argcnt, argtpe)) return fun;
                }
                fun = fun->next;
            }
        }
        mod = mod->next;
    }
    return NULL;
}


@= BUNins
    if (BUNins(ctx->@1, @2, @3) == NULL) return "xquery_method: allocation error while inserting in @1";
@c
/*
 * call a function ns:method(). try to use the function cache (ie re-use a cached MIL tree).
 * otherwise generate MIL yourself, interpret it (and cache it). Returns error string (NULL if ok).
 */
static char xquery_function_error[80] = "xquery_method: error during execution.\n";
static char* 
xquery_function_call(int stk, int msec, char *mode, char *ns, char *method, int argc, int* argcnt, char** argtpe, char** argval, BAT *docBAT) 
{
    xquery_client *ctx = xquery_clients + stk;
    xquery_prepared_function *prepfun = ctx->prepared_functions;
    xquery_function *fun;
    int i, j, k, tpe[MAXPARAMS];

    /* look up type numbers */
    for(k=i=0; i<argc; i++) {
        for(j=0; j<argcnt[i]; j++,k++) {
            tpe[k] = xquery_typenr(argtpe[k]);
            if (tpe[k] >= XQUERY_TYPES) 
                return (char*) -1; /* can't make a quick function resolution if unknown types are involved */
        }
    }
    fun = xquery_resolve(stk, ns, method, argc, argcnt, tpe);
    if (fun == NULL)
        return (char*) -1; /* no such udf. but it may be a built-in, actually */

    while(prepfun && prepfun->def != fun) prepfun = prepfun->next;

    /* put params into them */
    for(k=i=0; i<argc; i++) {
        for(j=0; j<argcnt[i]; j++,k++) {
            oid nil = oid_nil, one = 1, vid = i + fun->vid;
            char c = xquery_types[tpe[k]].name[3];

            if (ATOMfromstr(xquery_types[tpe[k]].monet_tpe, &ctx->val, &ctx->vallen, argval[k]) <= 0)
                return "xquery_function_call: illegal parameter value.\n";

            @:BUNins(fun_vid000, &nil, &vid)@
            @:BUNins(fun_iter000, &nil, &one)@
            @:BUNins(fun_kind000, &nil, &xquery_types[tpe[k]].kind)@
            if (c == 'i') { /* xs:integer */
                oid item = BATcount(ctx->int_values);
                @:BUNins(int_values, &nil, ctx->val)@
                @:BUNins(fun_item000, &nil, &item)@
            } else if (c == 'd') { /* xs:double or xs:decimal */
                oid item = BATcount(ctx->dbl_values);
                @:BUNins(dbl_values, &nil, ctx->val)@
                @:BUNins(fun_item000, &nil, &item)@
            } else if (c == 's') { /* xs:string */
                oid item = BATcount(ctx->str_values);
                @:BUNins(str_values, &nil, ctx->val)@
                @:BUNins(fun_item000, &nil, &item)@
            } else if (docBAT == NULL) { 
                return "xquery_function_call: node parameter without docBAT.\n";
            } else {
                @:BUNins(fun_item000, &nil, ctx->val)@
            }
        }
    }
    BATseqbase(ctx->fun_vid000, 0);
    BATseqbase(ctx->fun_iter000, 0);
    BATseqbase(ctx->fun_kind000, 0);
    BATseqbase(ctx->fun_item000, 0);
    ctx->docBAT[0] = docBAT?docBAT->batCacheid:0;
    if (*(ctx->genType) == NULL || strcmp(*(ctx->genType), mode)) { 
        if (*(ctx->genType)) GDKfree(*(ctx->genType));
        *(ctx->genType) = GDKstrdup(mode);
    }

    if (prepfun == NULL) {
        /* construct MIL query, if not in cache of stk */ 
        char mil[XQUERY_BUFSIZE], *src, *cur = mil, *end = mil + XQUERY_BUFSIZE-1;
        int ret;
  
        prepfun = (xquery_prepared_function*) GDKmalloc(sizeof(xquery_prepared_function));
        if (prepfun == NULL)
            return "xquery_function_call: allocation failed.\n";
        prepfun->def = fun;
        prepfun->lt = NULL;

        /* create working set */
        src = (char*) PFstartMIL();
        while(*src && cur < end) *cur++ = *src++;

        if (docBAT) {
            /* add shredded soap message to the working set */
            src = (char*) PFdocbatMIL();
            while(*src && cur < end) *cur++ = *src++;
        }

        /* call UDF */
        ret = snprintf(cur, XQUERY_BUFSIZE-(cur-mil), PFudfMIL(), fun->proc+3, 0,0,0,0, 0,0,0,0,fun->sig->name,fun->sig->name,0,0,0,0);
        if (ret > 0) cur += ret;

        /* destroy working set */
        ret = snprintf(cur, XQUERY_BUFSIZE-(cur-mil), PFstopMIL());
        if (ret > 0) cur += ret;

        /* done! execute the script */
        *cur = 0;
        if (cur >= end) {
            return "xquery_function_call: generated MIL query exceeds buffer size.\n";
        }
        prepfun->lt = xquery_parse_mil(stk, mil);
        if (prepfun->lt == NULL) {
            GDKfree(prepfun);
            return "xquery_function_call: error during parsing .\n";
        }
        prepfun->next = ctx->prepared_functions;
        ctx->prepared_functions = prepfun;
    }
    *(ctx->time_compile) = GDKms() - msec;
    /* re-execute tree */
    return xquery_interpret(ctx->stk, prepfun->lt)?NULL:xquery_function_error;
}


/*
 * =================== module admin ================================
 *
 * void           xquery_module_free(xquery_module *mod)
 *                * free module structure 
 *
 * xquery_module* xquery_module_compile(Cntxt stk, stk char* mode, char *url)
 *                * get an xquery module, compile it and cache it (return NULL on error)
 *
 * char*          xquery_module_load(Cntxt stk, char* mode, char *ns, char *url)
 *                * check whether we already loaded the module, or if we already 
 *                  have it cached. If not, fetch&compile. Returns error string or NULL if ok.
 */

/* 
 * free module structure 
 */
static void 
xquery_module_free(xquery_module *mod) 
{
    xquery_function *fun = mod->functions;
    while(fun) {
        xquery_function *del = fun;
        fun = fun->next;
        GDKfree(del);
    }
    if (mod->epilogue) free(mod->epilogue);
    if (mod->prologue) free(mod->prologue);
    GDKfree(mod);
}

/*
 * get an xquery module, compile it and cache it (return NULL on error)
 */
xquery_module*
xquery_module_compile(Cntxt stk, char* mode, char *url) 
{
    xquery_client *ctx = xquery_clients + stk; 
    xquery_module *mod = GDKmalloc(sizeof(xquery_module)+strlen(url));
    BAT *b = ctx->proc_vid;
    int xx = BUNsize(b);
    int cnt = BUNindex(b, BUNlast(b));
    BUN p, q;

    if (mod == NULL) return NULL;
    memset(mod, 0, sizeof(xquery_module));
    strcpy(mod->url, url);
    if (!xquery_compile_exec(stk, mode, url, 1, &mod->prologue, NULL, &mod->epilogue)) {
        xquery_module_free(mod);
        return NULL;
    } 
    for(p = BUNptr(b,cnt), q = BUNlast(b); p < q; p += xx) {
        char *proc = (char*) BUNhead(b,p);
        xquery_function *fun = (xquery_function*) GDKmalloc(sizeof(xquery_function)+strlen(proc));
        if (fun == NULL) {
            xquery_module_free(mod);
            return NULL;
        }
        strcpy(fun->proc, proc);
        fun->vid = *(lng*) BUNtail(b,p);
        fun->sig = xquery_sig_init(fun->proc);
        if (fun->sig == NULL) {
            GDKfree(fun);
        } else {
            fun->next = mod->functions;
            mod->functions = fun;
        }
    }
    mod->next = xquery_compiled_modules;
    xquery_compiled_modules = mod;
    return mod;
}

/*
 * check whether we already loaded the module, or if we already have it cached. 
 * If not, fetch&compile. Returns error string or NULL if ok.
 */
static char* 
xquery_module_load(Cntxt stk, char* mode, char *ns, char *url) 
{
    xquery_client *ctx = xquery_clients + stk; 
    xquery_loaded_module *mod, *prev = NULL;

    /* check whether it was already loaded in this query */
    for(mod = ctx->loaded_modules; mod; prev = mod, mod = mod->next) {
        if (strcmp(mod->def->url, url) == 0) {
            if (mod->ns == NULL) {
                if (prev) prev->next = mod->next;
                else ctx->loaded_modules = NULL;
                break; /* put module at front of list */
            } else if (strcmp(mod->ns, ns)) {
                return "xquery_module_load: module already loaded under different namespace.\n";
            }
            return NULL;
        }
    }
    if (mod == NULL) {
        mod = (xquery_loaded_module*) GDKmalloc(sizeof(xquery_loaded_module));
        if (mod == NULL) 
            return "xquery_module_load: could not allocate.\n";

        MT_set_lock(pf_cache_lock, "xquery_module_load");
        for(mod->def = xquery_compiled_modules; mod->def; mod->def = mod->def->next) 
            if (strcmp(mod->def->url, url) == 0) break;
        if (mod->def == NULL)
            mod->def = xquery_module_compile(stk, mode, url);
        MT_unset_lock(pf_cache_lock, "xquery_module_load");

        if (mod->def == NULL) {
            GDKfree(mod);
            return "xquery_module_load: could not load module.\n";
        }
        if (!xquery_exec_mil(stk, mod->def->prologue)) {
            GDKfree(mod);
            return "xquery_module_load: module execution error.\n";
        }
        ctx->var_usage_size = BATcount(ctx->var_usage);
    }
    mod->ns = GDKstrdup(ns);
    mod->next = ctx->loaded_modules;
    ctx->loaded_modules = mod;
    return NULL;
}


/*
 * =================== client session management ================================
 *
 * Cntxt  xquery_client_alloc(stream *fdin, stream *fdout);
 *        * allocate a new xquery client, returns client cntxt (0 on error)
 *
 * char*  xquery_client_init(Cntxt stk);
 *        * initialize a new xquery cache context, returns error string (NULL if ok)
 *
 * void   xquery_client_free(Cntxt stk, int closeclient);
 *        * free a xquery cache context (forever)
 *
 * void   xquery_client_end(Cntxt stk, int forever);
 *        * end of xquery execution (if forever=0, struct stays alive for reuse). 
 *
 * void   xquery_client_flushall() 
 *        * wait for all queries to finish; free all clients; clear PF url cache
 */

static int xquery_caching = 0;

/* 
 * allocate a new xquery client, returns client cntxt (0 on error)
 */
static Cntxt 
xquery_client_alloc(stream *fdin, stream *fdout) 
{
    Cntxt stk;

    MT_set_lock(pf_cache_lock, "xquery_client_alloc");
    if (fdin) xquery_caching = 1;
    for(stk=1; stk<=MAXCLIENTS; stk++) {
        if (xquery_clients[stk].inuse == 0 && xquery_clients[stk].buflen) {
            break; /* initialized & unused */
        }
    }
    if (stk > MAXCLIENTS) {
        if (fdin) {
            stk = 0; /* failed */
        } else {
            /* hack: if fdin == NULL, allocate a MIL client yourself! This is used by query_method() */
            Client client = initClient("soap", GDKgetenv("monet_prompt"), FALSE);
            if (client) {
                TBL_initclient(client, monet_clients);
                stk = client - monet_clients;
            }
        }
    }
    if (stk) {
        Client client = monet_clients + stk;
        client->fdin = fdin;
        client->fdout = fdout;
        xquery_clients[stk].inuse = 1;
    }
    MT_unset_lock(pf_cache_lock, "xquery_client_alloc");
    return stk;
}

@= find_bat
{   Variable v = VARfind(&stk, "@1");
    ctx->@1 =  NULL;
    if (v && v->binding.vtype == TYPE_bat)
        ctx->@1 = BATdescriptor(v->binding.val.bval);
    if (ctx->@1 == NULL) return "xquery_client_init: failed to lookup @1 variable.\n"; }
@c
/*
 * initialize a new xquery cache context, returns error string (NULL if ok)
 */ 
static char* 
xquery_client_init(Cntxt stk) 
{ 
    xquery_client *ctx = xquery_clients + stk;
    Variable v;

    if (ctx->buflen == 0) {
        if (!xquery_exec_mil(stk, (char*) PFinitMIL()))
            return "xquery_client_init: failed to execute init script.\n"; 

        v = VARfind(&stk, "docBAT");
        if (v == NULL) 
            return "xquery_client_init: failed to lookup docBAT variable.\n"; 
        ctx->docBAT = &v->binding.val.ival; 

        v = VARfind(&stk, "genType");
        if (v == NULL) 
            return "xquery_client_init: failed to lookup genType variable.\n"; 
        ctx->genType = &v->binding.val.sval; 

        v = VARfind(&stk, "time_compile");
        if (v == NULL) 
            return "xquery_client_init: failed to lookup time_compile variable.\n"; 
        ctx->time_compile = &v->binding.val.ival; 

        ctx->buflen = XQUERY_BUFSIZE;
        ctx->buf = GDKmalloc(ctx->buflen+1);
        ctx->val = GDKmalloc(ctx->vallen = 128);
        if (ctx->val == NULL || ctx->buf == NULL) {
            if (ctx->buf) GDKfree(ctx->buf);
            if (ctx->val) GDKfree(ctx->val);
            return "xquery_client_init: failed to allocate.\n";
        }
        ctx->loaded_modules = NULL;
        ctx->prepared_functions = NULL;

        @:find_bat(proc_vid)@
        @:find_bat(var_usage)@
        @:find_bat(dbl_values)@
        @:find_bat(int_values)@
        @:find_bat(str_values)@
        @:find_bat(fun_vid000)@
        @:find_bat(fun_iter000)@
        @:find_bat(fun_item000)@
        @:find_bat(fun_kind000)@
        ctx->var_usage_size = BATcount(ctx->var_usage);
        ctx->stk = CNTXTnew(stk);
        CNTXTuse(ctx->stk);
        monet_cntxt[ctx->stk].reuse = TRUE;
    } else {
        /* undo any inserts by the query into the var_usage bats */
        size_t delta = BATcount(ctx->var_usage) - ctx->var_usage_size;
        BATsetcount(ctx->var_usage, ctx->var_usage_size);
        ctx->var_usage->batBuns->free -= delta*BUNsize(ctx->var_usage);

        /* empty all bats */
        BATclear(ctx->fun_vid000);
        BATclear(ctx->fun_iter000);
        BATclear(ctx->fun_kind000);
        BATclear(ctx->fun_item000);
        BATseqbase(ctx->fun_vid000, oid_nil);
        BATseqbase(ctx->fun_iter000, oid_nil);
        BATseqbase(ctx->fun_kind000, oid_nil);
        BATseqbase(ctx->fun_item000, oid_nil);
        BATclear(ctx->dbl_values);
        BATclear(ctx->int_values);
        BATclear(ctx->str_values);
    }
    return NULL;
}


@= unfix
    if (ctx->@1) BBPunfix(ctx->@1->batCacheid);
    ctx->@1 = NULL;
@c
/* 
 * free a xquery cache context (forever).
 */
static void 
xquery_client_free(Cntxt stk, int closeclient) 
{
    xquery_client *ctx = xquery_clients + stk; 
    xquery_prepared_function *fun= ctx->prepared_functions; 
    xquery_loaded_module *mod= ctx->loaded_modules; 

    while(mod) {
        xquery_loaded_module *del = mod;
        mod = mod->next;
        /* free all modules */
        if (!xquery_exec_mil(stk, del->def->epilogue)) {
            fprintf(stderr, "xquery_server: client %d error dropping %s\n", stk, del->def->url);
        }
        GDKfree(mod);
    }
    while(fun) {
        xquery_prepared_function *del = fun;
        fun = fun->next;
        if (del->lt) Myyfree(del->lt);
        GDKfree(del);
    }
    ctx->loaded_modules = NULL;
    ctx->prepared_functions = NULL;
    ctx->docBAT = NULL;

    /* free the query buffer */
    if (ctx->buf) GDKfree(ctx->buf);
    ctx->buf = NULL;
    ctx->buflen = 0;

    /* free the value buffer */
    if (ctx->val) GDKfree(ctx->val);
    ctx->val = NULL;
    ctx->vallen = 0;
    
    /* unfix the BAT handles */
    @:unfix(int_values)@
    @:unfix(dbl_values)@
    @:unfix(str_values)@
    @:unfix(fun_vid000)@
    @:unfix(fun_iter000)@
    @:unfix(fun_item000)@
    @:unfix(fun_kind000)@

    /* close the MIL client session */
    monet_cntxt[ctx->stk].reuse = FALSE;
    CNTXTclear(ctx->stk);
    CNTXTfree1(ctx->stk);
    CNTXTdelete(ctx->stk);
    ctx->inuse = 0;
    if (closeclient)
        closeClient(monet_clients + stk, 0);
}

/* 
 * end of xquery execution (struct stays alive for reuse).
 */
static void 
xquery_client_end(Cntxt stk, int forever) 
{
    xquery_client *ctx = xquery_clients + stk; 

    MT_set_lock(pf_cache_lock, "xquery_client_end");
    if (forever) {
        xquery_client_free(stk, 1);
    } else {
        /* only deactivate the loaded modules */
        xquery_loaded_module *mod= ctx->loaded_modules; 
        while(mod) {
            if (mod->ns) {
                GDKfree(mod->ns);
                mod->ns = NULL; /* ns == NULL deactivates */
            }
            mod = mod->next;
        }
        ctx->inuse = 0;
    }
    MT_unset_lock(pf_cache_lock, "xquery_client_end");
}


/*
 * wait for all queries to finish; free all clients; clear PF url cache
 */
static void
xquery_client_flushall() 
{
    int stk, wait = 100;
    while(wait) {
        MT_set_lock(pf_cache_lock, "xquery_client_flushall");
        for(stk=1; stk<=MAXCLIENTS; stk++) {
            if (xquery_clients[stk].inuse) break;
        }
        if (stk > MAXCLIENTS) {
            /* ok, no xquery clients are active */
            xquery_module *mod = xquery_compiled_modules;
            for(stk=1; stk<=MAXCLIENTS; stk++) {
                if (xquery_clients[stk].buflen)
                    xquery_client_free(stk, 1);
            }
            while(mod) {
                xquery_module *del = mod;
                mod = mod->next;
                xquery_module_free(del);
            }
            xquery_compiled_modules = NULL;
            PFurlcache_flush();
            wait = 0;
        }
        MT_unset_lock(pf_cache_lock, "xquery_client_flushall");
        MT_sleep_ms(wait);
    }
    xquery_caching = 0;
}


/*
 * ========== parse xquery to identify 'import module's and function calls ==========
 *
 * char*   xquery_parse_ident(unsigned char* p) 
 *         * parse an identifier; accept any UTF-8 characters in it (is that correct?)
 *
 * char*   xquery_parse_comment(char* p)
 *         * parse an xquery (: .. :)  comment. Note it may be nested.
 *
 * char*   xquery_parse_space(char* p)
 *         * parse xquery space, which may include comments 
 *
 * char*   xquery_parse_string(char* p, char *buf, int len)
 *         * parse an XML datamodel string. Deliver an unescaped version as a result 
 *
 * char*   xquery_parse_numeric(char* p, char **tpe)
 *         * parse an XML datamodel numeric, and determine its minimal type (xs:integer, xs:decimal or xs:double) 
 *
 * all above functions return the new pointer in the xquery after parsing.
 *
 * char*   xquery_prepare(Cntxt stk, int msec, char* mode, char* xquery)
 *         * parse xquery; chop off module imports, and recognize single method calls. These are re-executed
 *           from a cached MIL tree. Otherwise use pathfinder to compile. Returns error string (NULL if ok).
 */

/* 
 * parse an identifier; accept any UTF-8 characters in it (is that correct?)
 */
static inline char* 
xquery_parse_ident(unsigned char* p) 
{
    while(*p == '_' || (*p >= 'a' && *p <= 'z') ||
                       (*p >= 'A' && *p <= 'Z') ||
                       (*p >= '0' && *p <= '9') || (*p >= 128)) p++;
    return (char*) p;
}

/* 
 * parse an xquery (: .. :)  comment. Note it may be nested.
 */
static inline char* 
xquery_parse_comment(char* p) 
{
    int nesting;
    for(nesting=1; *p; p++) {
        if (p[0] == ':' && p[1] == ')' && --nesting == 0) return p+2;
        if (p[0] == '(' && *(++p) == ':') nesting++;
    }
    return p;
}

/* 
 * parse xquery space, which may include comments 
 */
#define ISSPACE(c) ((c) == ' ' || (c) == '\t' || (c) == 10 || (c) == 13) 
static inline char* 
xquery_parse_space(char* p) 
{
    while(*p) {
        while(ISSPACE(*p)) p++;
        if (p[0] != '(' || p[1] != ':') break; 
        p = xquery_parse_comment(p+2);
    }
    return p;
}

/* 
 * parse an XML datamodel string. Deliver an unescaped version as a result 
 */
static inline char* 
xquery_parse_string(char* p, char *buf, int len) 
{
    char *q = buf, *r = buf+len-1;
    int sep1 = *p++;
    int sep2 = (sep1=='"')?'\'':'"';
    int escape = 0;
    while(*p) {
        if (escape) {
            if (p[0] == sep2) escape = 0;
            if (q < r) *q++ = *p; p++;
        } else {
            if (p[0] == sep1) {
                p++; break;
            } else if (p[0] == sep2) {
                if (p[1] == sep1 && p[2] == sep1 && p[3] == sep2) {
                    if (q < r) *q++ = sep1; p += 4;
                } else {
                    if (q < r) *q++ = *p; p++;
                    escape = 1;
                }
            } else if (p[0] == '&') {
                if (p[1] == '#' && p[2] == 'x') {
                    unsigned long v = 0; 
                    for(p+=3; *p; p++) {
                        if (*p >= '0' && *p <= '9') {
                            v = (v << 4) + (*p - '0');
                        } else if (*p >= 'a' && *p <= 'f') {
                            v = (v << 4) + (*p - 'a');
                        } else if (*p >= 'A' && *p <= 'F') {
                            v = (v << 4) + (*p - 'A');
                        } else {
                            break;
                        }
                    }
                    if (q < r) *q++ = (char) v;
                } else if (p[1] == '#') {
                    unsigned long v = 0; 
                    for(p+=2; *p; p++) {
                        if (*p >= '0' && *p <= '9') {
                            v = (v * 10) + (*p - '0');
                        } else {
                            break;
                        }
                    }
                    if (q < r) *q++ = (char) v;
                } else if (p[1] == 'l' && p[2] == 't' && p[3] == ';') {
                    if (q < r) *q++ = '<'; p += 4;
                } else if (p[1] == 'g' && p[2] == 't' && p[3] == ';') {
                    if (q < r) *q++ = '<'; p += 4;
                } else if (p[1] == 'a' && p[2] == 'm' && p[3] == 'p' && p[4] == ';') {
                    if (q < r) *q++ = '&'; p += 5;
                } else if (p[1] == 'q' && p[2] == 'u' && p[3] == 'o' && p[4] == 't' && p[5] == ';') {
                    if (q < r) *q++ = '"'; p += 6;
                } else if (p[1] == 'a' && p[2] == 'p' && p[3] == 'o' && p[4] == 's' && p[5] == ';') {
                    if (q < r) *q++ = '\''; p += 6;
                }
            } else {
                if (q < r) *q++ = *p; p++;
            }
        }
    }
    *q = 0;
    return p;
}

/* 
 * parse an XML datamodel numeric, and determine its minimal type (xs:integer, xs:decimal or xs:double) 
 */
static inline char* 
xquery_parse_numeric(char* p, char **tpe) {
    *tpe = "xs:integer";
    if (p[0] == '-' || p[0] == '+') p++;
    while(p[0] >= '0' && p[0] <= '9') p++;
    if (p[0] == '.' && (p[1] >= '0' && p[1] <= '9')) {
        p++;
        while(p[0] >= '0' && p[0] <= '9') p++;
        *tpe = "xs:decimal";
    }
    if (p[0] == 'e' || p[0] == 'E') {
        char *q = p+1;
        if (q[0] == '-' || q[0] == '+') q++;
        if (q[0] >= '0' && q[0] <= '9') {
           while(q[0] >= '0' && q[0] <= '9') q++;
           p = q;
           *tpe = "xs:double";
        }
    }
    return p;
}

/* 
 * parse xquery; chop off module imports, and recognize single method calls. These are re-executed
 * from a cached MIL tree. Otherwise use pathfinder to compile. Returns error string (NULL if ok).
 */
static char*
xquery_prepare(Cntxt stk, int msec, char* mode, char* query) 
{
    int nsbuf = 0, loaded_modules = 0;
    char *ns = (char*)&nsbuf, *nsend = ns, *locend, *loc = NULL, *p = query;
    char val[256], url1[256], url2[256];
    char *err = NULL;

    while(*p && err == NULL) {
        p = xquery_parse_space(p);
        if (strncmp(p, "import", 6) || !ISSPACE(p[6])) {
            break;
        } else {
            /* e.g. import module namespace xmark = "/cygwin/tmp/" at "/cygwin/tmp/mod1.xq"; */ 
            p = xquery_parse_space(p+6);
            if (strncmp(p, "module", 6) == 0 && ISSPACE(p[6])) {
                p = xquery_parse_space(p+6);
                if (strncmp(p, "namespace", 9) == 0 && ISSPACE(p[9])) {
                    ns = xquery_parse_space(p+9);
                    nsend = xquery_parse_ident((unsigned char*)ns);
                    p = xquery_parse_space(nsend);
                    if (*p == '=') {
                        p = xquery_parse_space(p+1);
                    } else {
                        err = "xquery_prepare: expecting '=' after namespace declaration";
                    }
                }
                p = xquery_parse_string(p, url1, 256);
                p = xquery_parse_space(p);
                if (err == NULL && *p == 'a' && *(++p) == 't' && ISSPACE(p[1])) do {
                    loc = xquery_parse_space(p+1);
                    locend = xquery_parse_string(loc, url2, 256);
                    if (strlen(url1) > strlen(url2) || strncmp(url1, url2, strlen(url1))) {
                        err = "xquery_prepare: module namespace does not match import statement.\n";
                    } else { 
                        char bak = *nsend;
                        p = xquery_parse_space(locend);
                        /* cut off module import from the query, and load it here (to have it cached later) */
                        *nsend = 0; 
                        err = xquery_module_load(stk, mode, ns, url2);
                        *nsend = bak; 
                    }
                } while (*p == ',' && err == NULL);
            }
            if (*p != ';') {
                err = "xquery_prepare: missing ';' after module import.\n";
            } else {
                loaded_modules++;
                p++;
            }
        }
    }
    if (loaded_modules == 0) {
       err = (char*) -1; /* query not recognized as a function call */
    } else if (err == NULL) {
        /* detect queries that consist of a single method call only */
        nsend = ns = (char*) &nsbuf; 
        loc = p; 
        locend = xquery_parse_ident((unsigned char*)loc);
        p = xquery_parse_space(locend);
        if (*p == ':') {
            ns = loc; nsend = locend; 
            loc = ++p; 
            locend = xquery_parse_ident((unsigned char*)p);
            p = xquery_parse_space(locend);
        }
        if (*p != '(' || ((locend-loc) == 2 && loc[0] == 'i' && loc[1] == 'f')) {
            err = (char*) -1; /* query not recognized as a function call */
        } else {
            int cnt[MAXPARAMS];
            char* tpe[MAXPARAMS];
            char* param[MAXPARAMS];
            int argc = 0;
    
            /* e.g. ns:function(1,2,3) */
            p = xquery_parse_space(p+1);
            if (*p == ')') {
               p++;
            } else do {
                param[argc] = p;
                tpe[argc] = "xs:string";
                cnt[argc] = 1;
                if (*param[argc] == '"' || *param[argc] == '\'') {
                    p = xquery_parse_string(param[argc], val, 256);
                    if (p <= param[argc]) {
                        err = "xquery_prepare: could not parse string literal.\n";
                        break;
                    }
                } else if (*p == '-' || *p == '+' || *p == '.' || (*p >= '0' && *p <= '9')) {
                    p = xquery_parse_numeric(param[argc], tpe+argc);
                    if (p <= param[argc]) {
                        err = "xquery_prepare: could not parse numeric literal.\n";
                        break;
                    }
                } else {
                    /* complex parameter */
                    err = (char*) -1; /* query not recognized as a simple function call */
                    break;
                }
                if (++argc >= MAXPARAMS) {
                    err = "xquery_prepare: too many parameters.\n";
                    break;
                }
                p = xquery_parse_space(p);
                if (*p == ')') {
                    p++; 
                    break;
                } else if (*p != ',') {
                    err = "xquery_prepare: expecting a ',' between function parameters.\n";
                    break;
                }
                p = xquery_parse_space(p+1);
            } while(*p);
    
            if (err == NULL) {    
                p = xquery_parse_space(p);
                if (*p == '/') {
                    err = (char*) -1;
                } else if (*p) {
                    err = "xquery_prepare: unexpected characters after ';'.\n";
                } else {
                    /* all set: make the call */
                    char nsbak = *nsend, locbak = *locend;
                    *nsend = 0; *locend = 0;
                    err = xquery_function_call(stk, msec, mode, ns, loc, argc, cnt, tpe, param, NULL);
                    *nsend = nsbak; *locend = locbak;
                }
            }
        }
    }
    if (err == (char*) -1) {
        char *sec1 = NULL;
        char *sec2 = NULL;
        char *sec3 = NULL;
        err = NULL;
        /* compile and execute the query (minus module imports) */
        if (!xquery_compile_exec(stk, mode, query, 0, &sec1, &sec2, &sec3)) 
                err = NULL; /* in case of execution err, it stays -1 */
        if (sec1) free(sec1);
        if (sec2) free(sec2);
        if (sec3) free(sec3);
    }  else if (err == xquery_function_error) {
        err = (char*) -1; /* execution error in xquery_function_call */
    }
    return err;
}

/*
 * =================== exported functions ================================
 *
 * see MIL module definition (top of file)
 */

@= builtin_operand
{
    int _k = interpret(stk, arg(lt, @1), res);
    if (_k < 0) {
        return _k;
    }
    @3 = VALconvert(@2, res);
    if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
        return handle_paramerror(res,@1,res->vtype,@2);
    }
}
@c
/*
 * read xquery from input stream; execute and print on output stream 
 */  
#define XQUERY_CHALLENGE "::mserver_xquery:4\n"
static int
xquery_server_end(Cntxt stk, Thread t, char *err) 
{
    Client c = monet_clients + stk;
    if (err) 
        fprintf(stderr, "xquery_server: client %d %s\n", stk, err);
    monetSetChannel(t, GDKin, GDKout);
    if (c->fdin) {
        stream_close(c->fdin);
        stream_destroy(c->fdin);
        c->fdin = GDKin;
    }
    if (c->fdout) {
        stream_close(c->fdout);
        stream_destroy(c->fdout);
        c->fdout = GDKout;
    }
    xquery_client_end(stk, !xquery_caching);
    return err?GDK_FAIL:GDK_SUCCEED;
}

int
CMDxquery_server(Cntxt stk, YYSTREE lt, ValPtr res)
{
    stream **In, **Out;
    stream *in = NULL, *out = NULL;
    size_t curlen = 0;
    Thread XQthread = THRget(THRgettid());
    xquery_client *ctx = xquery_clients + stk;
    char *xquery, *user, *buf, *err = (char*) -1;
    int i, msec;

    if (lt->cnt != 2)
        return handle_argerror(res, lt->cnt, 2);

    err = xquery_client_init(stk);
    if (err) return (xquery_server_end(stk, XQthread, err));
    buf = ctx->buf;

    /* this is a BUILTIN because we must obtain the client context (and
     * thus the streams) */
    @:builtin_operand(0,TYPE_Stream,In)@
    in = *In;
    @:builtin_operand(1,TYPE_Stream,Out)@
    out = *Out;

    /* send challenge */
    snprintf(buf, 100, "%2u%s", (unsigned int)strlen(XQUERY_CHALLENGE), XQUERY_CHALLENGE);
    if (stream_write(out, buf, strlen(buf), 1) < 0) 
        return(xquery_server_end(stk, XQthread, "could not send challenge"));

    /* get user name (ignored later), and mapiclient mode */
    memset(buf, 0, BUFSIZ);
    user = buf;
    if (stream_read(in, user, 1, 1) < 0)
        return(xquery_server_end(stk, XQthread, "could not read response1"));
    for (i = 0; i < BUFSIZ && *user != '\n'; i++) {
        user++;
        if (stream_read(in, user, 1, 1) < 0)
            return(xquery_server_end(stk, XQthread, "could not read response2"));
    }
    *user = 0;

    /* check for blocked mode */
    if (strncmp(buf + i - 8, ":blocked", 8) == 0) {
        in = block_stream(stream_rstream(in));
        out = block_stream(stream_wstream(out));
    }
    monetSetChannel(XQthread, in, out);

    /* use the MAPI protocol to read as much xquery buffer as possible */
    if (stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) < 0)
        return(xquery_server_end(stk, XQthread, "could not write prompt"));
    if (stream_flush(out))
        return(xquery_server_end(stk, XQthread, "could not flush prompt"));

    curlen = 0;
    for ( ; buf; ) {
        ssize_t n = stream_read(in, buf + curlen, 1, ctx->buflen - curlen);
        if (n < 0)
            return(xquery_server_end(stk, XQthread, NULL));
        if (n == 0) {
            break;
        }
        curlen += n;
        if (curlen == ctx->buflen) {
            ctx->buflen += 1024;
            ctx->buf = buf = GDKrealloc(buf, ctx->buflen + 1);
        }
    }
    msec = GDKms();

    /* execute query */
    if (buf) {
        buf[curlen] = 0;        /* terminate (we know there is space) */

        /* first line of the query is the mode */ 
        for (xquery = buf; *xquery; xquery++) {
            if (*xquery == '\n') {
                *xquery++ = 0;
                break;
            }
        }
        err = xquery_prepare(stk, msec, buf, xquery);
        if (err && err != (char*) -1) {
            /* report errors back to client */
            xquery_header(strstr(buf,"debug")?1:0, NULL, NULL, NULL, err, strstr(buf, "mapi")?"=":"");
        }
    }

    /* end of session */
    stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1);
    stream_flush(out);
    return(xquery_server_end(stk, XQthread, NULL));
}

/*
 * mapi_listen may call this routine to get a recycled MIL client session from the xquery query cache
 */
Client
CMDxquery_client_alloc(stream *fdin, stream *fdout) {
    Cntxt stk = xquery_client_alloc(fdin,fdout);
    if (stk) {
        Client c = monet_clients+stk;
        if (MAPIinitClient(c, "xquery_server", fdin, fdout) < 0) {
            xquery_client_end(stk, 0);
        } else {
            return c;
        }
    }
    return NULL; 
}

/*
 * flush the cache and return a magic pointer. It must be passed to mapi_listen to enable caching.
 */
int
CMDxquery_start_query_cache(ptr *res) {
    xquery_client_flushall();
    *res = (ptr) CMDxquery_client_alloc;
    return GDK_SUCCEED;
}

/*
 * execute xquery and return the result in a string.
 */
int
CMDxquery(Cntxt stk, YYSTREE lt, ValPtr res)
{
    int msec = GDKms();
    char *mode = "xml", *xquery = NULL, *err = NULL;
    bit no=0, *is_url=&no;
    Client c = NULL;

    /* this is a BUILTIN because we must obtain the client context (and
     * thus the streams) */
    if (lt->cnt > 4)
        return handle_argerror(res, lt->cnt, 3);
    if (lt->cnt == 1) {
        @:builtin_operand(0,TYPE_str,xquery)@
    } else {
        @:builtin_operand(0,TYPE_str,mode)@
        @:builtin_operand(1,TYPE_str,xquery)@
    }
    if (lt->cnt == 3) {
        @:builtin_operand(2,TYPE_bit,is_url)@
    }
    CNTXTclient(stk, &c);
    MT_set_lock(pf_cache_lock, "CMDxquery");
    err = xquery_client_init(c->stk);
    MT_unset_lock(pf_cache_lock, "CMDxquery");

    if (err == NULL && *is_url) {
        PFURLCACHE("CMDxquery", xquery);
    }
    if (err == NULL) {
        buffer *b = buffer_create(XQUERY_BUFSIZE);
        if (b) {
            stream *s = buffer_wastream(b, "CMDxquery");
            if (s) {
                /* run the query, but collect all output in a buffer */
                stream *bak = GDKout;
                THRsetdata(0,s);
                err = xquery_prepare(stk, msec, mode, xquery);
                if (err == NULL) {
                    res->val.sval = GDKmalloc(b->pos+1);
                    if (res->val.sval) {
                        memcpy(res->val.sval, b->buf, b->pos);
                        res->val.sval[b->pos] = 0;
                        res->vtype = TYPE_str;
                    } else {
                        err = "CMDxquery: failed to allocate buffer";
                    }
                }
                THRsetdata(0,bak);
                stream_close(s);
            } else {
                err = "CMDxquery: failed to create stream";
            }
            buffer_destroy(b);
            stream_destroy(s);
        } else {
            err = "CMDxquery: failed to allocate streambuffer";
        }
    }
    MT_set_lock(pf_cache_lock, "CMDxquery");
    xquery_client_free(c->stk, 0);
    MT_unset_lock(pf_cache_lock, "CMDxquery");
    if (err) {
        res->vtype = TYPE_void;
        if (err != (char*) -1) GDKerror(err);
        return GDK_FAIL;
    } 
    return GDK_SUCCEED;
}


/*
 * call a method in a temporary xquery client context
 */  
char*
xquery_method(stream *out, char* module, char *method, int argc, int* argcnt, char** argtpe, char** argval, BAT* docBAT)
{
    int msec = GDKms();
    Cntxt stk = xquery_client_alloc(NULL, out);
    char *err = NULL, *ns = "fn";

    if (stk == 0) 
        return "xquery_method: out of client slots.\n";

    err = xquery_client_init(stk);

    if (err == NULL && module)
        err = xquery_module_load(stk, "xml-noroot", ns="soap", module); 

    if (err == NULL) { 
        err = xquery_function_call(stk, msec, "xml", ns, method, argc, argcnt, argtpe, argval, docBAT);
        if (err == (char*) -1) err = "xquery_method: function could not be resolved.\n";
    }
    xquery_client_end(stk, 0);
    return err;
}

/*
 * module initialization
 */
bat *
xquery_prelude()
{
    pf_compiler_lock = MT_create_lock();
    pf_cache_lock = MT_create_lock();
    memset(xquery_clients, 0, sizeof(xquery_client)*(MAXCLIENTS+1));
    xquery_compiled_modules = NULL;
    return NULL;
}

/*
 * module cleanup
 */
void
xquery_epilogue()
{
    xquery_client_flushall();
    MT_destroy_lock(pf_compiler_lock);
    MT_destroy_lock(pf_cache_lock);
}
/* vim:set shiftwidth=4 expandtab: */
