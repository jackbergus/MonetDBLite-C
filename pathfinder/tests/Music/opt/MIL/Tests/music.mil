proc_vid.insert("fnC2597B28_Asset_xs_string1_xs_integer1", 38865001LL);
proc_vid.insert("fn3C3E7CFB_AssetByTrackNr1_xs_string1_xs_integer1", 38865003LL);
proc_vid.insert("fnE4CA7F21_AssetByTrackNr9999999_xs_string1_xs_integer1", 38865005LL);
var_usage.insert(38865009@0,38865002@0);
proc_vid.insert("fnF6794328_AlbumAsset_xs_string1_xs_integer1", 38865007LL);
var_usage.insert(38865013@0,38865004@0);
proc_vid.insert("fn32CF6417_AlbumAssetByTrackNr1_xs_string1_xs_integer1", 38865011LL);
proc_vid.insert("fnBACC827E_AssetSort_xs_string1_xs_integer1", 38865016LL);
PROC fnC2597B28_Asset_xs_string1_xs_integer1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:Asset
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 item_dbl_ := dbl(1LL);
 { # saveResult1 () : int
  var item_dbl_001 := item_dbl_; # end of saveResult1 () : int
  { # translateVar (limit)
   var vid := v_vid000.ord_uselect(38865002@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter000);
   item := vid.leftfetchjoin(v_item000);
  } # end of translateVar (limit)
  { # cast from integer to double
   var cast_val := item.leftfetchjoin(int_values).[dbl]();
   if (cast_val.texist(dbl(nil))) {
    ERROR ("err:FORG0001: could not cast value from integer to double.");
   }
   item_dbl_ := cast_val;
   if (iter.count() != loop000.count()) {
    ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
   }
  } # end of cast from integer to double
  { # saveResult2 () : int
   var item_dbl_002 := item_dbl_; # end of saveResult2 () : int
   { # translateVar (db)
    var vid := v_vid000.ord_uselect(38865001@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter000);
    item := vid.leftfetchjoin(v_item000);
    ipik := iter;
   } # end of translateVar (db)
   { # translate fn:doc (string?) as document?
    item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
     time_shred :+= add_doc(ws, $t);
    }
    kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
    item := 0@0;
   } # end of translate fn:doc (string?) as document?
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "Asset");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    pos  := tmark_grp_unique(iter,ipik);
    kind := res_scj.fetch(2).set_kind(ELEM);
   } # end of translateLocsteps (c)
   { # translate fn:subsequence
    if (loop000.count() = 1) {
     var lo := item_dbl_001.fetch(0) - 1.0LL;
     if (lo < 1.0LL) lo := 0.0;
     var hi := int(lo + item_dbl_002.fetch(0)) - 1;
     iter := iter.slice(int(lo),hi);
     kind := kind.slice(int(lo),hi);
     item := item.slice(int(lo), hi);
    } else { # evaluate selection tuple by tuple (note: fully constant-resistant code)
     var offset_dbl := item_dbl_001.tmark(1@0);
     var offset_oid := leftfetchjoin(iter, [oid](offset_dbl));
     var sel := [>=](pos, offset_oid);
     var limit_dbl := item_dbl_002.tmark(1@0);
     offset_oid := iter.leftfetchjoin([oid]([+](offset_dbl, limit_dbl)));
     sel := [and](sel, [<](pos, offset_oid)); # carry through the selection on the table
     if (type(sel) = bat) {
      ipik := sel.ord_uselect(true).hmark(0@0);
      sel := false;
     } else {
      if (sel = false) ipik := bat(oid,oid);
     }
     if (sel = false) {
      iter := ipik.leftfetchjoin(iter);
      kind := ipik.leftfetchjoin(kind);
      item := ipik.leftfetchjoin(item);
     }
    }
   } # end of deleteResult2 ()
  } # end of deleteResult1 ()
 } # end of translate fn:subsequence
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fnC2597B28_Asset_xs_string1_xs_integer1
PROC fn3C3E7CFB_AssetByTrackNr1_xs_string1_xs_integer1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:AssetByTrackNr1
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 item_dbl_ := dbl(1LL);
 { # saveResult1 () : int
  var item_dbl_001 := item_dbl_; # end of saveResult1 () : int
  { # translateVar (limit)
   var vid := v_vid000.ord_uselect(38865004@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter000);
   item := vid.leftfetchjoin(v_item000);
  } # end of translateVar (limit)
  { # cast from integer to double
   var cast_val := item.leftfetchjoin(int_values).[dbl]();
   if (cast_val.texist(dbl(nil))) {
    ERROR ("err:FORG0001: could not cast value from integer to double.");
   }
   item_dbl_ := cast_val;
   if (iter.count() != loop000.count()) {
    ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
   }
  } # end of cast from integer to double
  { # saveResult2 () : int
   var item_dbl_002 := item_dbl_; # end of saveResult2 () : int
   { # translateVar (db)
    var vid := v_vid000.ord_uselect(38865003@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter000);
    item := vid.leftfetchjoin(v_item000);
    ipik := iter;
   } # end of translateVar (db)
   { # translate fn:doc (string?) as document?
    item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
     time_shred :+= add_doc(ws, $t);
    }
    kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
    item := 0@0;
   } # end of translate fn:doc (string?) as document?
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "TrackNr1");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    pos  := tmark_grp_unique(iter,ipik);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   { # translate fn:subsequence
    if (loop000.count() = 1) {
     var lo := item_dbl_001.fetch(0) - 1.0LL;
     if (lo < 1.0LL) lo := 0.0;
     var hi := int(lo + item_dbl_002.fetch(0)) - 1; # select a slice
     ipik := ipik.slice(int(lo),hi);
     iter := iter.slice(int(lo),hi);
     kind := kind.slice(int(lo),hi);
     item := item.slice(int(lo), hi);
    } else { # evaluate selection tuple by tuple (note: fully constant-resistant code)
     var offset_dbl := item_dbl_001.tmark(1@0);
     var offset_oid := leftfetchjoin(iter, [oid](offset_dbl));
     var sel := [>=](pos, offset_oid);
     var limit_dbl := item_dbl_002.tmark(1@0);
     offset_oid := iter.leftfetchjoin([oid]([+](offset_dbl, limit_dbl)));
     sel := [and](sel, [<](pos, offset_oid)); # carry through the selection on the table
     if (type(sel) = bat) {
      ipik := sel.ord_uselect(true).hmark(0@0);
      sel := false;
     } else {
      if (sel = false) ipik := bat(oid,oid);
     }
     if (sel = false) {
      iter := ipik.leftfetchjoin(iter);
      kind := ipik.leftfetchjoin(kind);
      item := ipik.leftfetchjoin(item);
     }
    }
   } # end of deleteResult2 ()
  } # end of deleteResult1 ()
 } # end of translate fn:subsequence
 { # translate pf:distinct-doc-order (node*) as node*
  var sorting;
  var simple := false;
  if (type(kind) != bat) {
   simple := (kind = ELEM);
  }
  if (not(simple)) {
   kind := kind.materialize(ipik);
   simple := (kind.count() = kind.get_type(ELEM).count());
  }
  if (simple) {
   sorting := iter.tsort();
   sorting := sorting.CTrefine(kind);
   sorting := sorting.CTrefine(item);
  } else { # cope also with attributes and sort them according to their owner
   var elements := kind.get_type(ELEM).mirror();
   var elem_iters := elements.leftfetchjoin(iter);
   var elem_items := elements.leftfetchjoin(item);
   var elem_frags := elements.leftfetchjoin(kind.get_fragment());
   var elem_attrs := elements.mark(nil);
   var attributes := kind.get_type(ATTR).mirror();
   var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
   var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
   var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
   var attr_key := attributes.hmark(0@0);
   var temp_attr := attr_attrs.tmark(0@0);
   var temp_frag := attr_frags.tmark(0@0);
   var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
   sorting := elem_iters.union(attr_iters).tsort();
   sorting := sorting.CTrefine(elem_frags.union(attr_frags));
   sorting := sorting.CTrefine(elem_items.union(attr_items));
   sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
  }
  ipik := sorting.reverse().{min}().tmark(0@0);
  iter := ipik.leftfetchjoin(iter);
  item := ipik.leftfetchjoin(item);
  kind := ipik.leftfetchjoin(kind);
 } # end of translate pf:distinct-doc-order (node*) as node*
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_parent_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, ELEMENT);
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
 } # end of translateLocsteps (c)
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn3C3E7CFB_AssetByTrackNr1_xs_string1_xs_integer1
PROC fnE4CA7F21_AssetByTrackNr9999999_xs_string1_xs_integer1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:AssetByTrackNr9999999
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 item_dbl_ := dbl(1LL);
 { # saveResult1 () : int
  var item_dbl_001 := item_dbl_; # end of saveResult1 () : int
  { # translateVar (limit)
   var vid := v_vid000.ord_uselect(38865006@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter000);
   item := vid.leftfetchjoin(v_item000);
  } # end of translateVar (limit)
  { # cast from integer to double
   var cast_val := item.leftfetchjoin(int_values).[dbl]();
   if (cast_val.texist(dbl(nil))) {
    ERROR ("err:FORG0001: could not cast value from integer to double.");
   }
   item_dbl_ := cast_val;
   if (iter.count() != loop000.count()) {
    ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
   }
  } # end of cast from integer to double
  { # saveResult2 () : int
   var item_dbl_002 := item_dbl_; # end of saveResult2 () : int
   { # translateVar (db)
    var vid := v_vid000.ord_uselect(38865005@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter000);
    item := vid.leftfetchjoin(v_item000);
    ipik := iter;
   } # end of translateVar (db)
   { # translate fn:doc (string?) as document?
    item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
     time_shred :+= add_doc(ws, $t);
    }
    kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
    item := 0@0;
   } # end of translate fn:doc (string?) as document?
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "TrackNr9999999");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    pos  := tmark_grp_unique(iter,ipik);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   { # translate fn:subsequence
    if (loop000.count() = 1) {
     var lo := item_dbl_001.fetch(0) - 1.0LL;
     if (lo < 1.0LL) lo := 0.0;
     var hi := int(lo + item_dbl_002.fetch(0)) - 1; # select a slice
     ipik := ipik.slice(int(lo),hi);
     iter := iter.slice(int(lo),hi);
     kind := kind.slice(int(lo),hi);
     item := item.slice(int(lo), hi);
    } else { # evaluate selection tuple by tuple (note: fully constant-resistant code)
     var offset_dbl := item_dbl_001.tmark(1@0);
     var offset_oid := leftfetchjoin(iter, [oid](offset_dbl));
     var sel := [>=](pos, offset_oid);
     var limit_dbl := item_dbl_002.tmark(1@0);
     offset_oid := iter.leftfetchjoin([oid]([+](offset_dbl, limit_dbl)));
     sel := [and](sel, [<](pos, offset_oid)); # carry through the selection on the table
     if (type(sel) = bat) {
      ipik := sel.ord_uselect(true).hmark(0@0);
      sel := false;
     } else {
      if (sel = false) ipik := bat(oid,oid);
     }
     if (sel = false) {
      iter := ipik.leftfetchjoin(iter);
      kind := ipik.leftfetchjoin(kind);
      item := ipik.leftfetchjoin(item);
     }
    }
   } # end of deleteResult2 ()
  } # end of deleteResult1 ()
 } # end of translate fn:subsequence
 { # translate pf:distinct-doc-order (node*) as node*
  var sorting;
  var simple := false;
  if (type(kind) != bat) {
   simple := (kind = ELEM);
  }
  if (not(simple)) {
   kind := kind.materialize(ipik);
   simple := (kind.count() = kind.get_type(ELEM).count());
  }
  if (simple) {
   sorting := iter.tsort();
   sorting := sorting.CTrefine(kind);
   sorting := sorting.CTrefine(item);
  } else { # cope also with attributes and sort them according to their owner
   var elements := kind.get_type(ELEM).mirror();
   var elem_iters := elements.leftfetchjoin(iter);
   var elem_items := elements.leftfetchjoin(item);
   var elem_frags := elements.leftfetchjoin(kind.get_fragment());
   var elem_attrs := elements.mark(nil);
   var attributes := kind.get_type(ATTR).mirror();
   var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
   var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
   var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
   var attr_key := attributes.hmark(0@0);
   var temp_attr := attr_attrs.tmark(0@0);
   var temp_frag := attr_frags.tmark(0@0);
   var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
   sorting := elem_iters.union(attr_iters).tsort();
   sorting := sorting.CTrefine(elem_frags.union(attr_frags));
   sorting := sorting.CTrefine(elem_items.union(attr_items));
   sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
  }
  ipik := sorting.reverse().{min}().tmark(0@0);
  iter := ipik.leftfetchjoin(iter);
  item := ipik.leftfetchjoin(item);
  kind := ipik.leftfetchjoin(kind);
 } # end of translate pf:distinct-doc-order (node*) as node*
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_parent_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, ELEMENT);
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
 } # end of translateLocsteps (c)
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fnE4CA7F21_AssetByTrackNr9999999_xs_string1_xs_integer1
PROC fnF6794328_AlbumAsset_xs_string1_xs_integer1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:AlbumAsset
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 item_dbl_ := dbl(1LL);
 { # saveResult1 () : int
  var item_dbl_001 := item_dbl_; # end of saveResult1 () : int
  { # translateVar (limit)
   var vid := v_vid000.ord_uselect(38865008@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter000);
   item := vid.leftfetchjoin(v_item000);
  } # end of translateVar (limit)
  { # cast from integer to double
   var cast_val := item.leftfetchjoin(int_values).[dbl]();
   if (cast_val.texist(dbl(nil))) {
    ERROR ("err:FORG0001: could not cast value from integer to double.");
   }
   item_dbl_ := cast_val;
   if (iter.count() != loop000.count()) {
    ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
   }
  } # end of cast from integer to double
  { # saveResult2 () : int
   var item_dbl_002 := item_dbl_; # end of saveResult2 () : int
   item_dbl_ := dbl(1LL);
   { # saveResult3 () : int
    var item_dbl_003 := item_dbl_; # end of saveResult3 () : int
    { # translateVar (limit)
     var vid := v_vid000.ord_uselect(38865008@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter000);
     item := vid.leftfetchjoin(v_item000);
    } # end of translateVar (limit)
    { # cast from integer to double
     var cast_val := item.leftfetchjoin(int_values).[dbl]();
     if (cast_val.texist(dbl(nil))) {
      ERROR ("err:FORG0001: could not cast value from integer to double.");
     }
     item_dbl_ := cast_val;
     if (iter.count() != loop000.count()) {
      ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
     }
    } # end of cast from integer to double
    { # saveResult4 () : int
     var item_dbl_004 := item_dbl_; # end of saveResult4 () : int
     { # translateVar (db)
      var vid := v_vid000.ord_uselect(38865007@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter000);
      item := vid.leftfetchjoin(v_item000);
      ipik := iter;
     } # end of translateVar (db)
     { # translate fn:doc (string?) as document?
      item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
       time_shred :+= add_doc(ws, $t);
      }
      kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
      item := 0@0;
     } # end of translate fn:doc (string?) as document?
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "Asset");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      pos  := tmark_grp_unique(iter,ipik);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # translate fn:subsequence
      if (loop000.count() = 1) {
       var lo := item_dbl_003.fetch(0) - 1.0LL;
       if (lo < 1.0LL) lo := 0.0;
       var hi := int(lo + item_dbl_004.fetch(0)) - 1; # select a slice
       ipik := ipik.slice(int(lo),hi);
       iter := iter.slice(int(lo),hi);
       kind := kind.slice(int(lo),hi);
       item := item.slice(int(lo), hi);
      } else { # evaluate selection tuple by tuple (note: fully constant-resistant code)
       var offset_dbl := item_dbl_003.tmark(1@0);
       var offset_oid := leftfetchjoin(iter, [oid](offset_dbl));
       var sel := [>=](pos, offset_oid);
       var limit_dbl := item_dbl_004.tmark(1@0);
       offset_oid := iter.leftfetchjoin([oid]([+](offset_dbl, limit_dbl)));
       sel := [and](sel, [<](pos, offset_oid)); # carry through the selection on the table
       if (type(sel) = bat) {
        ipik := sel.ord_uselect(true).hmark(0@0);
        sel := false;
       } else {
        if (sel = false) ipik := bat(oid,oid);
       }
       if (sel = false) {
        iter := ipik.leftfetchjoin(iter);
        kind := ipik.leftfetchjoin(kind);
        item := ipik.leftfetchjoin(item);
       }
      }
     } # end of deleteResult4 ()
    } # end of deleteResult3 ()
   } # end of translate fn:subsequence
   { # translate pf:distinct-doc-order (node*) as node*
    var sorting;
    var simple := false;
    if (type(kind) != bat) {
     simple := (kind = ELEM);
    }
    if (not(simple)) {
     kind := kind.materialize(ipik);
     simple := (kind.count() = kind.get_type(ELEM).count());
    }
    if (simple) {
     sorting := iter.tsort();
     sorting := sorting.CTrefine(kind);
     sorting := sorting.CTrefine(item);
    } else { # cope also with attributes and sort them according to their owner
     var elements := kind.get_type(ELEM).mirror();
     var elem_iters := elements.leftfetchjoin(iter);
     var elem_items := elements.leftfetchjoin(item);
     var elem_frags := elements.leftfetchjoin(kind.get_fragment());
     var elem_attrs := elements.mark(nil);
     var attributes := kind.get_type(ATTR).mirror();
     var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
     var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
     var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
     var attr_key := attributes.hmark(0@0);
     var temp_attr := attr_attrs.tmark(0@0);
     var temp_frag := attr_frags.tmark(0@0);
     var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
     sorting := elem_iters.union(attr_iters).tsort();
     sorting := sorting.CTrefine(elem_frags.union(attr_frags));
     sorting := sorting.CTrefine(elem_items.union(attr_items));
     sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
    }
    ipik := sorting.reverse().{min}().tmark(0@0);
    iter := ipik.leftfetchjoin(iter);
    item := ipik.leftfetchjoin(item);
    kind := ipik.leftfetchjoin(kind);
   } # end of translate pf:distinct-doc-order (node*) as node*
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_parent_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, ELEMENT);
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    pos  := tmark_grp_unique(iter,ipik);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   if (ipik.count() != 0) 
   { # for-translation
    # project ()
    iter := iter.materialize(ipik);
    var outer001 := iter;
    iter := iter.mark(1@0);
    var inner001 := iter;
    var v_vid001;
    var v_iter001;
    var v_item001;
    var v_kind001;
    var expOid;
    { # getExpanded (fid)
     var vu_nil := vu_fid.ord_uselect(38865001@0);
     var vid_vu := vu_vid.reverse();
     var oid_nil := vid_vu.leftjoin(vu_nil);
     expOid := v_vid000.leftjoin(oid_nil);
     expOid := expOid.mirror();
    } # end of getExpanded (fid)
    if (expOid.count() != 0) {
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter000);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
      v_iter001 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter001)*2;
     v_iter001 := v_iter001.tmark(0@0);
     var new_v_iter := v_iter001;
     v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
     v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos ;
     var new_v_item := oidNew_expOid.leftjoin(v_item000);
     v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
     v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    } else { # createNewVarTable ()
     v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
    }
    { # insertVar (vid)
     var vid := project(ipik,38865009@0);
     { # append (vid, level)
      var seqb := oid(v_vid001.count());
      vid := vid.materialize(ipik);
      v_vid001 := v_vid001.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter001.count());
      iter := iter.materialize(ipik);
      v_iter001 := v_iter001.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb ;
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item001.count());
      item := item.materialize(ipik);
      v_item001 := v_item001.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind001.count());
      kind := kind.materialize(ipik);
      v_kind001 := v_kind001.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    { # translateVar (album)
     var vid := v_vid001.ord_uselect(38865009@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (album)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "Asset");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    if (ipik.count() != 0) 
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer002 := iter;
     iter := iter.mark(1@0);
     var inner002 := iter;
     var loop002 := inner002;
     var v_vid002;
     var v_iter002;
     var v_item002;
     var v_kind002;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(38865002@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid001.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     } else { # createNewVarTable ()
      v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,38865010@0);
      { # append (vid, level)
       var seqb := oid(v_vid002.count());
       vid := vid.materialize(ipik);
       v_vid002 := v_vid002.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter002.count());
       iter := iter.materialize(ipik);
       v_iter002 := v_iter002.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb ;
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item002.count());
       item := item.materialize(ipik);
       v_item002 := v_item002.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb := oid(v_kind002.count());
       kind := kind.materialize(ipik);
       v_kind002 := v_kind002.insert(kind.tmark(seqb));
      } # append (kind, level)
     } # end of insertVar (vid)
     { # tagname-translation
      var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
      var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
      var itemID;
      if (prop_str.texist("Result")) {
       itemID := prop_str.reverse().find("Result");
      } else {
       itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
       ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
       ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
       ws.fetch(QN_LOC).fetch(WS).insert(itemID,"Result");
       ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
       ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"Result"+str('\1')+"");
      } # translateConst (kind)
      iter := loop002.tmark(0@0);
      ipik := iter;
      item := itemID;
     } # end of tagname-translation
     { # saveResult3 () : int
      var ipik003 := ipik;
      var iter003 := iter;
      var item003 := item; # end of saveResult3 () : int
      { # tagname-translation
       var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
       var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
       var itemID;
       if (prop_str.texist("Album")) {
        itemID := prop_str.reverse().find("Album");
       } else {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
        ws.fetch(QN_LOC).fetch(WS).insert(itemID,"Album");
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"Album"+str('\1')+"");
       } # translateConst (kind)
       iter := loop002.tmark(0@0);
       ipik := iter;
       item := itemID;
      } # end of tagname-translation
      { # saveResult4 () : int
       var ipik004 := ipik;
       var iter004 := iter;
       var item004 := item; # end of saveResult4 () : int
       { # translateVar (album)
        var vid := v_vid002.ord_uselect(38865009@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter002);
        item := vid.leftfetchjoin(v_item002);
        kind := vid.leftfetchjoin(v_kind002);
        ipik := iter;
       } # end of translateVar (album)
       { # translateLocsteps (c)
        var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "Title");
        iter := res_scj.fetch(0);
        item := res_scj.fetch(1);
        kind := res_scj.fetch(2).set_kind(ELEM);
        ipik := item;
       } # end of translateLocsteps (c)
       { # translateLocsteps (c)
        var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
        iter := res_scj.fetch(0);
        item := res_scj.fetch(1);
        kind := res_scj.fetch(2).set_kind(ELEM);
        ipik := item;
       } # end of translateLocsteps (c)
       { # map2NODE_interface (counter)
        kind := kind.materialize(ipik);
        var attr := kind.get_type(ATTR).hmark(0@0);
        var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
        var attr_item := attr.leftfetchjoin(item);
        var attr_frag := attr.leftfetchjoin(kind).get_fragment();
        _r_attr_iter := attr_iter;
        _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
        _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
        _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
        var nodes := kind.get_type(ELEM);
        if (nodes.count() != 0) {
         var oid_oid := nodes.hmark(0@0);
         var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
         var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
         var iter_input := oid_oid.mirror();
         var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
         var res_iter := res_scj.fetch(0);
         var res_item := res_scj.fetch(1);
         var res_frag := res_scj.fetch(2);
         _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
         _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
         _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
         _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
         _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
         var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
         var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
         nodes := res_item.mark(0@0);
         var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
         root_level := nodes.leftfetchjoin(root_level);
         temp_ec_item := res_item;
         temp_ec_frag := res_frag;
         var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
         content_level := nodes.leftfetchjoin(content_level);
         content_level := content_level.[-](root_level);
         content_level := content_level.tmark(0@0);
         _elem_level := content_level;
         { # create attribute subtree copies
          var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
          var oid_attr := temp_attr.tmark(0@0);
          var oid_frag;
          if (is_constant(res_frag)) {
           oid_frag := res_frag;
          } else {
           oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
           oid_frag := oid_frag.tmark(0@0);
          }
          _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
          _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
          _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
          _attr_own  := temp_attr.hmark(0@0);
          _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
         } # end of create attribute subtree copies
        } else { # if (nodes.count() != 0) ...
         _elem_iter  := empty_bat;
         _elem_size  := empty_bat.project(int(nil));
         _elem_level := empty_bat.project(chr(nil));
         _elem_kind  := empty_bat.project(chr(nil));
         _elem_prop  := empty_bat;
         _elem_frag  := empty_bat;
         _attr_iter  := empty_bat;
         _attr_qn    := empty_bat;
         _attr_prop  := empty_bat;
         _attr_frag  := empty_bat;
         _attr_own   := empty_bat;
        } # end of else in 'if (nodes.count() != 0)'
       } # end of map2NODE_interface (counter)
       if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
        { # saveResult_node5 () : int
         var _elem_iter005   := _elem_iter  ;
         var _elem_size005   := _elem_size  ;
         var _elem_level005  := _elem_level ;
         var _elem_kind005   := _elem_kind  ;
         var _elem_prop005   := _elem_prop  ;
         var _elem_frag005   := _elem_frag  ;
         var _attr_iter005   := _attr_iter  ;
         var _attr_qn005     := _attr_qn    ;
         var _attr_prop005   := _attr_prop  ;
         var _attr_frag005   := _attr_frag  ;
         var _attr_own005    := _attr_own   ;
         var _r_attr_iter005 := _r_attr_iter;
         var _r_attr_qn005   := _r_attr_qn  ;
         var _r_attr_prop005 := _r_attr_prop;
         var _r_attr_frag005 := _r_attr_frag; # end of saveResult_node5 () : int
         _elem_iter := _elem_iter005;
         _elem_level := _elem_level005;
         _elem_kind := _elem_kind005;
         _elem_prop := _elem_prop005;
         _elem_frag := _elem_frag005;
         var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
         rootnodes := rootnodes.leftfetchjoin(_elem_kind);
         var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
         var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
         var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
         {
          var text_prop := textnodes.leftfetchjoin(_elem_prop);
          var text_frag := textnodes.leftfetchjoin(_elem_frag);
          var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
          var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
          var input_order := res_mu_is2ns.fetch(0);
          var input_str := res_mu_is2ns.fetch(1);
          var input_const := res_mu_is2ns.fetch(2);
          var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
          var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
          var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
          var result_order := result_str.hmark(0@0);
          result_order := result_order.leftfetchjoin(input_order);
          result_str := result_str.tmark(0@0);
          iter := result_order;
          ipik := iter;
          item_str_ := result_str;
         }
         { # adding new strings to text node content and create new nodes
          var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
          var unq_str := item_str_.tunique().hmark(0@0);
          var str_unq := reverse(unq_str.tdiff(ws_prop_text));
          var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
          unq_str := str_unq.hmark(seqb);
          ws_prop_text := ws_prop_text.insert(unq_str);
          var ws_text_prop := ws_prop_text.reverse().sort();
          item_str_ := item_str_.materialize(ipik);
          var X_item := item_str_.hmark(0@0);
          var X_strings := item_str_.tmark(0@0).tsort();
          var X_prop := X_strings.leftjoin(ws_text_prop);
          var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
          newPre_prop := newPre_prop.tmark(0@0);
          _elem_iter  := iter;
          _elem_size  := newPre_prop.project(0);
          _elem_level := newPre_prop.project(chr(0));
          _elem_kind  := newPre_prop.project(TEXT);
          _elem_prop  := newPre_prop;
          _elem_frag  := newPre_prop.project(WS);
         } # end of adding new fragments to the WS_FRAG bat
         var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter005), _elem_iter.leftfetchjoin(_elem_iter005), othernodes.leftfetchjoin(_elem_size005), _elem_size, othernodes.leftfetchjoin(_elem_level005), _elem_level, othernodes.leftfetchjoin(_elem_kind005), _elem_kind, othernodes.leftfetchjoin(_elem_prop005), _elem_prop, othernodes.leftfetchjoin(_elem_frag005), _elem_frag, othernodes.leftfetchjoin(_elem_iter005.mirror()), oid(nil));
         _elem_iter := res_mu_is2ns.fetch(1).chk_order();
         _elem_size := res_mu_is2ns.fetch(2);
         _elem_level:= res_mu_is2ns.fetch(3);
         _elem_kind := res_mu_is2ns.fetch(4);
         _elem_prop := res_mu_is2ns.fetch(5);
         _elem_frag := res_mu_is2ns.fetch(6);
         var preNew_preOld := res_mu_is2ns.fetch(7);
         _attr_own := _attr_own005.leftjoin(preNew_preOld.reverse());
         _attr_iter   := _attr_iter005  ;
         _attr_qn     := _attr_qn005    ;
         _attr_prop   := _attr_prop005  ;
         _attr_frag   := _attr_frag005  ;
         _r_attr_iter := _r_attr_iter005;
         _r_attr_qn   := _r_attr_qn005  ;
         _r_attr_prop := _r_attr_prop005;
         _r_attr_frag := _r_attr_frag005;
        } # end of deleteResult_node5 ()
       } # end of item-sequence-to-node-sequence
       { # loop_liftedElemConstr (counter)
        var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
        iter_size := {count}(iter_size, iter004.tunique(), FALSE);
        var root_iter  := iter_size.hmark(0@0).chk_order();
        var root_size  := iter_size.tmark(0@0);
        var root_prop  := iter004.reverse().leftfetchjoin(item004);
        if (not(is_constant(root_prop))) {
         root_prop  := root_prop.tmark(0@0);
        }
        {
         var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
         _elem_iter  := merged_result.fetch(0);
         _elem_size  := merged_result.fetch(1);
         _elem_level := merged_result.fetch(2);
         _elem_kind  := merged_result.fetch(3);
         _elem_prop  := merged_result.fetch(4);
         _elem_frag  := merged_result.fetch(5);
         var preNew_preOld := merged_result.fetch(6);
         _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
         _attr_own := _attr_own.tmark(0@0);
        }
        { # create attribute root entries
         var root_item := _elem_level.ord_uselect(chr(0));
         root_item := root_item.hmark(0@0);
         var iter_item := iter004.reverse().leftfetchjoin(root_item);
         var attr_own := _r_attr_iter.leftjoin(iter_item);
         if (_r_attr_iter.count() != 0) { # test uniqueness
          var sorting := _r_attr_iter.tsort();
          sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
          var unq_attrs := sorting.tunique();
          if (unq_attrs.count() != _r_attr_iter.count()) {
           item004 := materialize(item004,ipik004);
           if (item004.count() > 0) {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item004.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
           } else {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
          }
         } # end of test uniqueness
         if (_attr_iter.count() = 0) {
          _attr_iter := _r_attr_iter;
          _attr_qn   := _r_attr_qn;
          _attr_prop := _r_attr_prop;
          _attr_frag := _r_attr_frag;
          _attr_own  := attr_own.tmark(0@0);
         } else {
          var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
          _r_attr_iter := _r_attr_iter.tmark(seqb);
          _r_attr_qn   := _r_attr_qn  .tmark(seqb);
          _r_attr_prop := _r_attr_prop.tmark(seqb);
          _r_attr_frag := _r_attr_frag.tmark(seqb);
          attr_own := attr_own.tmark(seqb);
          _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
          _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
          _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
          _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
          _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
         }
         _r_attr_iter := empty_bat;
         _r_attr_qn   := empty_bat;
         _r_attr_prop := empty_bat;
         _r_attr_frag := empty_bat;
        } # end of create attribute root entries
       } # end of loop_liftedElemConstr (counter)
      } # end of deleteResult4 ()
      { # saveResult_node4 () : int
       var _elem_iter004   := _elem_iter  ;
       var _elem_size004   := _elem_size  ;
       var _elem_level004  := _elem_level ;
       var _elem_kind004   := _elem_kind  ;
       var _elem_prop004   := _elem_prop  ;
       var _elem_frag004   := _elem_frag  ;
       var _attr_iter004   := _attr_iter  ;
       var _attr_qn004     := _attr_qn    ;
       var _attr_prop004   := _attr_prop  ;
       var _attr_frag004   := _attr_frag  ;
       var _attr_own004    := _attr_own   ;
       var _r_attr_iter004 := _r_attr_iter;
       var _r_attr_qn004   := _r_attr_qn  ;
       var _r_attr_prop004 := _r_attr_prop;
       var _r_attr_frag004 := _r_attr_frag; # end of saveResult_node4 () : int
       { # tagname-translation
        var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
        var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
        var itemID;
        if (prop_str.texist("Track")) {
         itemID := prop_str.reverse().find("Track");
        } else {
         itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
         ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
         ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
         ws.fetch(QN_LOC).fetch(WS).insert(itemID,"Track");
         ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
         ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"Track"+str('\1')+"");
        } # translateConst (kind)
        iter := loop002.tmark(0@0);
        ipik := iter;
        item := itemID;
       } # end of tagname-translation
       { # saveResult5 () : int
        var ipik005 := ipik;
        var iter005 := iter;
        var item005 := item; # end of saveResult5 () : int
        { # translateVar (asset)
         var vid := v_vid002.ord_uselect(38865010@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter002);
         item := vid.leftfetchjoin(v_item002);
         kind := vid.leftfetchjoin(v_kind002);
         ipik := iter;
        } # end of translateVar (asset)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "TrackName");
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        { # map2NODE_interface (counter)
         kind := kind.materialize(ipik);
         var attr := kind.get_type(ATTR).hmark(0@0);
         var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
         var attr_item := attr.leftfetchjoin(item);
         var attr_frag := attr.leftfetchjoin(kind).get_fragment();
         _r_attr_iter := attr_iter;
         _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
         _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
         _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
         var nodes := kind.get_type(ELEM);
         if (nodes.count() != 0) {
          var oid_oid := nodes.hmark(0@0);
          var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
          var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
          var iter_input := oid_oid.mirror();
          var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
          var res_iter := res_scj.fetch(0);
          var res_item := res_scj.fetch(1);
          var res_frag := res_scj.fetch(2);
          _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
          _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
          _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
          _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
          _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
          var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
          var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
          nodes := res_item.mark(0@0);
          var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
          root_level := nodes.leftfetchjoin(root_level);
          temp_ec_item := res_item;
          temp_ec_frag := res_frag;
          var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
          content_level := nodes.leftfetchjoin(content_level);
          content_level := content_level.[-](root_level);
          content_level := content_level.tmark(0@0);
          _elem_level := content_level;
          { # create attribute subtree copies
           var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
           var oid_attr := temp_attr.tmark(0@0);
           var oid_frag;
           if (is_constant(res_frag)) {
            oid_frag := res_frag;
           } else {
            oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
            oid_frag := oid_frag.tmark(0@0);
           }
           _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
           _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
           _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
           _attr_own  := temp_attr.hmark(0@0);
           _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
          } # end of create attribute subtree copies
         } else { # if (nodes.count() != 0) ...
          _elem_iter  := empty_bat;
          _elem_size  := empty_bat.project(int(nil));
          _elem_level := empty_bat.project(chr(nil));
          _elem_kind  := empty_bat.project(chr(nil));
          _elem_prop  := empty_bat;
          _elem_frag  := empty_bat;
          _attr_iter  := empty_bat;
          _attr_qn    := empty_bat;
          _attr_prop  := empty_bat;
          _attr_frag  := empty_bat;
          _attr_own   := empty_bat;
         } # end of else in 'if (nodes.count() != 0)'
        } # end of map2NODE_interface (counter)
        if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
         { # saveResult_node6 () : int
          var _elem_iter006   := _elem_iter  ;
          var _elem_size006   := _elem_size  ;
          var _elem_level006  := _elem_level ;
          var _elem_kind006   := _elem_kind  ;
          var _elem_prop006   := _elem_prop  ;
          var _elem_frag006   := _elem_frag  ;
          var _attr_iter006   := _attr_iter  ;
          var _attr_qn006     := _attr_qn    ;
          var _attr_prop006   := _attr_prop  ;
          var _attr_frag006   := _attr_frag  ;
          var _attr_own006    := _attr_own   ;
          var _r_attr_iter006 := _r_attr_iter;
          var _r_attr_qn006   := _r_attr_qn  ;
          var _r_attr_prop006 := _r_attr_prop;
          var _r_attr_frag006 := _r_attr_frag; # end of saveResult_node6 () : int
          _elem_iter := _elem_iter006;
          _elem_level := _elem_level006;
          _elem_kind := _elem_kind006;
          _elem_prop := _elem_prop006;
          _elem_frag := _elem_frag006;
          var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
          rootnodes := rootnodes.leftfetchjoin(_elem_kind);
          var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
          var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
          var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
          {
           var text_prop := textnodes.leftfetchjoin(_elem_prop);
           var text_frag := textnodes.leftfetchjoin(_elem_frag);
           var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
           var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
           var input_order := res_mu_is2ns.fetch(0);
           var input_str := res_mu_is2ns.fetch(1);
           var input_const := res_mu_is2ns.fetch(2);
           var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
           var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
           var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
           var result_order := result_str.hmark(0@0);
           result_order := result_order.leftfetchjoin(input_order);
           result_str := result_str.tmark(0@0);
           iter := result_order;
           ipik := iter;
           item_str_ := result_str;
          }
          { # adding new strings to text node content and create new nodes
           var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
           var unq_str := item_str_.tunique().hmark(0@0);
           var str_unq := reverse(unq_str.tdiff(ws_prop_text));
           var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
           unq_str := str_unq.hmark(seqb);
           ws_prop_text := ws_prop_text.insert(unq_str);
           var ws_text_prop := ws_prop_text.reverse().sort();
           item_str_ := item_str_.materialize(ipik);
           var X_item := item_str_.hmark(0@0);
           var X_strings := item_str_.tmark(0@0).tsort();
           var X_prop := X_strings.leftjoin(ws_text_prop);
           var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
           newPre_prop := newPre_prop.tmark(0@0);
           _elem_iter  := iter;
           _elem_size  := newPre_prop.project(0);
           _elem_level := newPre_prop.project(chr(0));
           _elem_kind  := newPre_prop.project(TEXT);
           _elem_prop  := newPre_prop;
           _elem_frag  := newPre_prop.project(WS);
          } # end of adding new fragments to the WS_FRAG bat
          var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter006), _elem_iter.leftfetchjoin(_elem_iter006), othernodes.leftfetchjoin(_elem_size006), _elem_size, othernodes.leftfetchjoin(_elem_level006), _elem_level, othernodes.leftfetchjoin(_elem_kind006), _elem_kind, othernodes.leftfetchjoin(_elem_prop006), _elem_prop, othernodes.leftfetchjoin(_elem_frag006), _elem_frag, othernodes.leftfetchjoin(_elem_iter006.mirror()), oid(nil));
          _elem_iter := res_mu_is2ns.fetch(1).chk_order();
          _elem_size := res_mu_is2ns.fetch(2);
          _elem_level:= res_mu_is2ns.fetch(3);
          _elem_kind := res_mu_is2ns.fetch(4);
          _elem_prop := res_mu_is2ns.fetch(5);
          _elem_frag := res_mu_is2ns.fetch(6);
          var preNew_preOld := res_mu_is2ns.fetch(7);
          _attr_own := _attr_own006.leftjoin(preNew_preOld.reverse());
          _attr_iter   := _attr_iter006  ;
          _attr_qn     := _attr_qn006    ;
          _attr_prop   := _attr_prop006  ;
          _attr_frag   := _attr_frag006  ;
          _r_attr_iter := _r_attr_iter006;
          _r_attr_qn   := _r_attr_qn006  ;
          _r_attr_prop := _r_attr_prop006;
          _r_attr_frag := _r_attr_frag006;
         } # end of deleteResult_node6 ()
        } # end of item-sequence-to-node-sequence
        { # loop_liftedElemConstr (counter)
         var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
         iter_size := {count}(iter_size, iter005.tunique(), FALSE);
         var root_iter  := iter_size.hmark(0@0).chk_order();
         var root_size  := iter_size.tmark(0@0);
         var root_prop  := iter005.reverse().leftfetchjoin(item005);
         if (not(is_constant(root_prop))) {
          root_prop  := root_prop.tmark(0@0);
         }
         {
          var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
          _elem_iter  := merged_result.fetch(0);
          _elem_size  := merged_result.fetch(1);
          _elem_level := merged_result.fetch(2);
          _elem_kind  := merged_result.fetch(3);
          _elem_prop  := merged_result.fetch(4);
          _elem_frag  := merged_result.fetch(5);
          var preNew_preOld := merged_result.fetch(6);
          _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
          _attr_own := _attr_own.tmark(0@0);
         }
         { # create attribute root entries
          var root_item := _elem_level.ord_uselect(chr(0));
          root_item := root_item.hmark(0@0);
          var iter_item := iter005.reverse().leftfetchjoin(root_item);
          var attr_own := _r_attr_iter.leftjoin(iter_item);
          if (_r_attr_iter.count() != 0) { # test uniqueness
           var sorting := _r_attr_iter.tsort();
           sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
           var unq_attrs := sorting.tunique();
           if (unq_attrs.count() != _r_attr_iter.count()) {
            item005 := materialize(item005,ipik005);
            if (item005.count() > 0) {
             ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item005.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
            } else {
             ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
            }
           }
          } # end of test uniqueness
          if (_attr_iter.count() = 0) {
           _attr_iter := _r_attr_iter;
           _attr_qn   := _r_attr_qn;
           _attr_prop := _r_attr_prop;
           _attr_frag := _r_attr_frag;
           _attr_own  := attr_own.tmark(0@0);
          } else {
           var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
           _r_attr_iter := _r_attr_iter.tmark(seqb);
           _r_attr_qn   := _r_attr_qn  .tmark(seqb);
           _r_attr_prop := _r_attr_prop.tmark(seqb);
           _r_attr_frag := _r_attr_frag.tmark(seqb);
           attr_own := attr_own.tmark(seqb);
           _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
           _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
           _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
           _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
           _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
          }
          _r_attr_iter := empty_bat;
          _r_attr_qn   := empty_bat;
          _r_attr_prop := empty_bat;
          _r_attr_frag := empty_bat;
         } # end of create attribute root entries
        } # end of loop_liftedElemConstr (counter)
       } # end of deleteResult5 ()
       # translateSeq_node (f, counter)
       if (_r_attr_iter.count() = 0) {
        _r_attr_iter := _r_attr_iter004;
        _r_attr_qn := _r_attr_qn004;
        _r_attr_prop := _r_attr_prop004;
        _r_attr_frag := _r_attr_frag004;
       } else {
        if (_r_attr_iter004.count() != 0) 
        { # combine attribute roots
         var merged_result := merged_union (_r_attr_iter004.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn004, _r_attr_qn, _r_attr_prop004, _r_attr_prop, _r_attr_frag004, _r_attr_frag);
         _r_attr_iter := merged_result.fetch(0);
         _r_attr_qn := merged_result.fetch(1);
         _r_attr_prop := merged_result.fetch(2);
         _r_attr_frag := merged_result.fetch(3);
        }
       } # end of combine attribute roots
       if (_elem_iter.count() = 0) {
        _elem_iter  := _elem_iter004  ;
        _elem_size  := _elem_size004  ;
        _elem_level := _elem_level004 ;
        _elem_kind  := _elem_kind004  ;
        _elem_prop  := _elem_prop004  ;
        _elem_frag  := _elem_frag004  ;
        _attr_iter  := _attr_iter004  ;
        _attr_qn    := _attr_qn004    ;
        _attr_prop  := _attr_prop004  ;
        _attr_frag  := _attr_frag004  ;
        _attr_own   := _attr_own004   ;
       } else {
        if (_elem_iter004.count() != 0) 
        { # combine element nodes
         var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
         var shift_factor := int(seqb) - int(_elem_size004.seqbase());
         var merged_result := merged_union (_elem_iter004.chk_order(), _elem_iter.chk_order(), _elem_size004, _elem_size, _elem_level004, _elem_level, _elem_kind004, _elem_kind, _elem_prop004, _elem_prop, _elem_frag004, _elem_frag, _elem_size004.mark(seqb), _elem_size.mirror());
         _elem_iter := merged_result.fetch(0);
         _elem_size := merged_result.fetch(1);
         _elem_level:= merged_result.fetch(2);
         _elem_kind := merged_result.fetch(3);
         _elem_prop := merged_result.fetch(4);
         _elem_frag := merged_result.fetch(5);
         var preNew_preOld := merged_result.fetch(6);
         _attr_own004 := _attr_own004.[int]().[+](shift_factor).[oid]();
         merged_result := merged_union (_attr_iter004, _attr_iter, _attr_qn004, _attr_qn, _attr_prop004, _attr_prop, _attr_frag004, _attr_frag, _attr_own004, _attr_own);
         _attr_iter := merged_result.fetch(0);
         _attr_qn   := merged_result.fetch(1);
         _attr_prop := merged_result.fetch(2);
         _attr_frag := merged_result.fetch(3);
         _attr_own  := merged_result.fetch(4);
         _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
         _attr_own := _attr_own.tmark(0@0);
        }
       } # combine element nodes
       # end of translateSeq_node (f, counter)
      } # end of deleteResult_node4 ()
      { # loop_liftedElemConstr (counter)
       var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
       iter_size := {count}(iter_size, iter003.tunique(), FALSE);
       var root_iter  := iter_size.hmark(0@0).chk_order();
       var root_size  := iter_size.tmark(0@0);
       var root_prop  := iter003.reverse().leftfetchjoin(item003);
       if (not(is_constant(root_prop))) {
        root_prop  := root_prop.tmark(0@0);
       }
       {
        var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
        _elem_size  := merged_result.fetch(1);
        _elem_level := merged_result.fetch(2);
        _elem_kind  := merged_result.fetch(3);
        _elem_prop  := merged_result.fetch(4);
        _elem_frag  := merged_result.fetch(5);
        var preNew_preOld := merged_result.fetch(6);
        _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
        _attr_own := _attr_own.tmark(0@0);
       }
       { # create attribute root entries
        var root_item := _elem_level.ord_uselect(chr(0));
        root_item := root_item.hmark(0@0);
        var iter_item := iter003.reverse().leftfetchjoin(root_item);
        var attr_own := _r_attr_iter.leftjoin(iter_item);
        if (_r_attr_iter.count() != 0) { # test uniqueness
         var sorting := _r_attr_iter.tsort();
         sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
         var unq_attrs := sorting.tunique();
         if (unq_attrs.count() != _r_attr_iter.count()) {
          item003 := materialize(item003,ipik003);
          if (item003.count() > 0) {
           ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item003.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
          } else {
           ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
          }
         }
        } # end of test uniqueness
        if (_attr_iter.count() = 0) {
         _attr_qn   := _r_attr_qn;
         _attr_prop := _r_attr_prop;
         _attr_frag := _r_attr_frag;
         _attr_own  := attr_own.tmark(0@0);
        } else {
         var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
         _r_attr_qn   := _r_attr_qn  .tmark(seqb);
         _r_attr_prop := _r_attr_prop.tmark(seqb);
         _r_attr_frag := _r_attr_frag.tmark(seqb);
         attr_own := attr_own.tmark(seqb);
         _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
         _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
         _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
         _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
        }
       } # end of create attribute root entries
       {
        var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
        var preOld_preNew := _elem_size.mark(seqb);
        _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
        _elem_size  := _elem_size.tmark(seqb);
        _elem_level := _elem_level.tmark(seqb);
        _elem_kind  := _elem_kind.tmark(seqb);
        _elem_prop  := _elem_prop.tmark(seqb);
        _elem_frag  := _elem_frag.tmark(seqb);
       }
       ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
       ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
       ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
       ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
       ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
       {
        var knd := ELEMENT;
        while ( knd <= DOCUMENT ) {
         var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
         ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
         if ( knd = ELEMENT ) {
          var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
          ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
         }
         if ( knd = PI ) {
          var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
          ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
         }
         knd :+= chr(1);
        }
       }
       var roots := _elem_level.ord_uselect(chr(0));
       roots := roots.hmark(0@0);
       {
        var height := int(_elem_level.max());
        ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
       }
       { # adding new fragments to the WS_FRAG bat
        var seqb := oid(count(ws.fetch(WS_FRAG)));
        var new_pres := roots.tmark(seqb);
        ws.fetch(WS_FRAG).insert(new_pres);
       }
       iter := iter003;
       item := roots;
       ipik := item;
       kind := ELEM;
       { # add attribute subtree copies to WS
        var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
        _attr_qn   := _attr_qn  .tmark(seqb);
        _attr_prop := _attr_prop.tmark(seqb);
        _attr_own  := _attr_own .tmark(seqb);
        _attr_frag := _attr_frag.tmark(seqb);
        ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
        ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
        ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
        ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
       } # end of add attribute subtree copies to WS
      } # end of loop_liftedElemConstr (counter)
     } # end of deleteResult3 ()
     { # mapBack ()
      var iter_oidMap := inner002.reverse();
      var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
      iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
      # kind := kind;
      # ipik := ipik;
     } # end of mapBack ()
     # cleanUpLevel ()
    } # end of for-translation
    { # mapBack ()
     var iter_oidMap := inner001.reverse();
     var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
     iter := oid_oidMap.leftfetchjoin(outer001);
     pos := tmark_grp_unique(iter,ipik); # item := item;
     # kind := kind;
     # ipik := ipik;
    } # end of mapBack ()
    # cleanUpLevel ()
   } # end of for-translation
   { # translate fn:subsequence
    if (loop000.count() = 1) {
     var lo := item_dbl_001.fetch(0) - 1.0LL;
     if (lo < 1.0LL) lo := 0.0;
     var hi := int(lo + item_dbl_002.fetch(0)) - 1;
     iter := iter.slice(int(lo),hi);
     kind := kind.slice(int(lo),hi);
     item := item.slice(int(lo), hi);
    } else { # evaluate selection tuple by tuple (note: fully constant-resistant code)
     var offset_dbl := item_dbl_001.tmark(1@0);
     var offset_oid := leftfetchjoin(iter, [oid](offset_dbl));
     var sel := [>=](pos, offset_oid);
     var limit_dbl := item_dbl_002.tmark(1@0);
     offset_oid := iter.leftfetchjoin([oid]([+](offset_dbl, limit_dbl)));
     sel := [and](sel, [<](pos, offset_oid)); # carry through the selection on the table
     if (type(sel) = bat) {
      ipik := sel.ord_uselect(true).hmark(0@0);
      sel := false;
     } else {
      if (sel = false) ipik := bat(oid,oid);
     }
     if (sel = false) {
      iter := ipik.leftfetchjoin(iter);
      kind := ipik.leftfetchjoin(kind);
      item := ipik.leftfetchjoin(item);
     }
    }
   } # end of deleteResult2 ()
  } # end of deleteResult1 ()
 } # end of translate fn:subsequence
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fnF6794328_AlbumAsset_xs_string1_xs_integer1
PROC fn32CF6417_AlbumAssetByTrackNr1_xs_string1_xs_integer1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:AlbumAssetByTrackNr1
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 item_dbl_ := dbl(1LL);
 { # saveResult1 () : int
  var item_dbl_001 := item_dbl_; # end of saveResult1 () : int
  { # translateVar (limit)
   var vid := v_vid000.ord_uselect(38865012@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter000);
   item := vid.leftfetchjoin(v_item000);
  } # end of translateVar (limit)
  { # cast from integer to double
   var cast_val := item.leftfetchjoin(int_values).[dbl]();
   if (cast_val.texist(dbl(nil))) {
    ERROR ("err:FORG0001: could not cast value from integer to double.");
   }
   item_dbl_ := cast_val;
   if (iter.count() != loop000.count()) {
    ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
   }
  } # end of cast from integer to double
  { # saveResult2 () : int
   var item_dbl_002 := item_dbl_; # end of saveResult2 () : int
   item_dbl_ := dbl(1LL);
   { # saveResult3 () : int
    var item_dbl_003 := item_dbl_; # end of saveResult3 () : int
    { # translateVar (limit)
     var vid := v_vid000.ord_uselect(38865012@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter000);
     item := vid.leftfetchjoin(v_item000);
    } # end of translateVar (limit)
    { # cast from integer to double
     var cast_val := item.leftfetchjoin(int_values).[dbl]();
     if (cast_val.texist(dbl(nil))) {
      ERROR ("err:FORG0001: could not cast value from integer to double.");
     }
     item_dbl_ := cast_val;
     if (iter.count() != loop000.count()) {
      ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
     }
    } # end of cast from integer to double
    { # saveResult4 () : int
     var item_dbl_004 := item_dbl_; # end of saveResult4 () : int
     { # translateVar (db)
      var vid := v_vid000.ord_uselect(38865011@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter000);
      item := vid.leftfetchjoin(v_item000);
      ipik := iter;
     } # end of translateVar (db)
     { # translate fn:doc (string?) as document?
      item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
       time_shred :+= add_doc(ws, $t);
      }
      kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
      item := 0@0;
     } # end of translate fn:doc (string?) as document?
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "TrackNr1");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      pos  := tmark_grp_unique(iter,ipik);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # translate fn:subsequence
      if (loop000.count() = 1) {
       var lo := item_dbl_003.fetch(0) - 1.0LL;
       if (lo < 1.0LL) lo := 0.0;
       var hi := int(lo + item_dbl_004.fetch(0)) - 1; # select a slice
       ipik := ipik.slice(int(lo),hi);
       iter := iter.slice(int(lo),hi);
       kind := kind.slice(int(lo),hi);
       item := item.slice(int(lo), hi);
      } else { # evaluate selection tuple by tuple (note: fully constant-resistant code)
       var offset_dbl := item_dbl_003.tmark(1@0);
       var offset_oid := leftfetchjoin(iter, [oid](offset_dbl));
       var sel := [>=](pos, offset_oid);
       var limit_dbl := item_dbl_004.tmark(1@0);
       offset_oid := iter.leftfetchjoin([oid]([+](offset_dbl, limit_dbl)));
       sel := [and](sel, [<](pos, offset_oid)); # carry through the selection on the table
       if (type(sel) = bat) {
        ipik := sel.ord_uselect(true).hmark(0@0);
        sel := false;
       } else {
        if (sel = false) ipik := bat(oid,oid);
       }
       if (sel = false) {
        iter := ipik.leftfetchjoin(iter);
        kind := ipik.leftfetchjoin(kind);
        item := ipik.leftfetchjoin(item);
       }
      }
     } # end of deleteResult4 ()
    } # end of deleteResult3 ()
   } # end of translate fn:subsequence
   { # translate pf:distinct-doc-order (node*) as node*
    var sorting;
    var simple := false;
    if (type(kind) != bat) {
     simple := (kind = ELEM);
    }
    if (not(simple)) {
     kind := kind.materialize(ipik);
     simple := (kind.count() = kind.get_type(ELEM).count());
    }
    if (simple) {
     sorting := iter.tsort();
     sorting := sorting.CTrefine(kind);
     sorting := sorting.CTrefine(item);
    } else { # cope also with attributes and sort them according to their owner
     var elements := kind.get_type(ELEM).mirror();
     var elem_iters := elements.leftfetchjoin(iter);
     var elem_items := elements.leftfetchjoin(item);
     var elem_frags := elements.leftfetchjoin(kind.get_fragment());
     var elem_attrs := elements.mark(nil);
     var attributes := kind.get_type(ATTR).mirror();
     var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
     var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
     var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
     var attr_key := attributes.hmark(0@0);
     var temp_attr := attr_attrs.tmark(0@0);
     var temp_frag := attr_frags.tmark(0@0);
     var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
     sorting := elem_iters.union(attr_iters).tsort();
     sorting := sorting.CTrefine(elem_frags.union(attr_frags));
     sorting := sorting.CTrefine(elem_items.union(attr_items));
     sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
    }
    ipik := sorting.reverse().{min}().tmark(0@0);
    iter := ipik.leftfetchjoin(iter);
    item := ipik.leftfetchjoin(item);
    kind := ipik.leftfetchjoin(kind);
   } # end of translate pf:distinct-doc-order (node*) as node*
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_ancestor_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "Album");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    pos  := tmark_grp_unique(iter,ipik);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   if (ipik.count() != 0) 
   { # for-translation
    # project ()
    iter := iter.materialize(ipik);
    var outer001 := iter;
    iter := iter.mark(1@0);
    var inner001 := iter;
    var v_vid001;
    var v_iter001;
    var v_item001;
    var v_kind001;
    var expOid;
    { # getExpanded (fid)
     var vu_nil := vu_fid.ord_uselect(38865003@0);
     var vid_vu := vu_vid.reverse();
     var oid_nil := vid_vu.leftjoin(vu_nil);
     expOid := v_vid000.leftjoin(oid_nil);
     expOid := expOid.mirror();
    } # end of getExpanded (fid)
    if (expOid.count() != 0) {
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter000);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
      v_iter001 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter001)*2;
     v_iter001 := v_iter001.tmark(0@0);
     var new_v_iter := v_iter001;
     v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
     v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos ;
     var new_v_item := oidNew_expOid.leftjoin(v_item000);
     v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
     v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    } else { # createNewVarTable ()
     v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
    }
    { # insertVar (vid)
     var vid := project(ipik,38865013@0);
     { # append (vid, level)
      var seqb := oid(v_vid001.count());
      vid := vid.materialize(ipik);
      v_vid001 := v_vid001.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter001.count());
      iter := iter.materialize(ipik);
      v_iter001 := v_iter001.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb ;
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item001.count());
      item := item.materialize(ipik);
      v_item001 := v_item001.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind001.count());
      kind := kind.materialize(ipik);
      v_kind001 := v_kind001.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    { # translateVar (album)
     var vid := v_vid001.ord_uselect(38865013@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (album)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "Asset");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    if (ipik.count() != 0) 
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer002 := iter;
     iter := iter.mark(1@0);
     var inner002 := iter;
     var loop002 := inner002;
     var v_vid002;
     var v_iter002;
     var v_item002;
     var v_kind002;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(38865004@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid001.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     } else { # createNewVarTable ()
      v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,38865014@0);
      { # append (vid, level)
       var seqb := oid(v_vid002.count());
       vid := vid.materialize(ipik);
       v_vid002 := v_vid002.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter002.count());
       iter := iter.materialize(ipik);
       v_iter002 := v_iter002.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb ;
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item002.count());
       item := item.materialize(ipik);
       v_item002 := v_item002.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb := oid(v_kind002.count());
       kind := kind.materialize(ipik);
       v_kind002 := v_kind002.insert(kind.tmark(seqb));
      } # append (kind, level)
     } # end of insertVar (vid)
     { # translateVar (asset)
      var vid := v_vid002.ord_uselect(38865014@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter002);
      item := vid.leftfetchjoin(v_item002);
      kind := vid.leftfetchjoin(v_kind002);
      ipik := iter;
     } # end of translateVar (asset)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "TrackNr");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     if (ipik.count() != 0) 
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer003 := iter;
      iter := iter.mark(1@0);
      var inner003 := iter;
      var loop003 := inner003;
      var v_vid003;
      var v_iter003;
      var v_item003;
      var v_kind003;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(38865005@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid002.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter002);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
        v_iter003 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter003)*2;
       v_iter003 := v_iter003.tmark(0@0);
       var new_v_iter := v_iter003;
       v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
       v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item002);
       v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
       v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,38865015@0);
       { # append (vid, level)
        var seqb := oid(v_vid003.count());
        vid := vid.materialize(ipik);
        v_vid003 := v_vid003.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter003.count());
        iter := iter.materialize(ipik);
        v_iter003 := v_iter003.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item003.count());
        item := item.materialize(ipik);
        v_item003 := v_item003.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind003.count());
        kind := kind.materialize(ipik);
        v_kind003 := v_kind003.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (#pf:v_533)
       var vid := v_vid003.ord_uselect(38865015@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter003);
       item := vid.leftfetchjoin(v_item003);
       kind := vid.leftfetchjoin(v_kind003);
       ipik := iter;
      } # end of translateVar (#pf:v_533)
      { # string-value
       var input_iter := iter;
       kind := kind.materialize(ipik);
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       var kind_elem := kind.get_type(ELEM);
       var item_str;
       if (kind_elem.count() = kind.count()) {
        var frag := kind.get_fragment();
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var t_iter_unq := t_iter.tunique();
        t_iter := t_iter.materialize(t_item);
        if (t_iter_unq.count() != t_item.count()) {
         var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         iter_item := iter_item.string_join(t_iter_unq.project(""));
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
        }
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       } else {
        var kind_attr := kind.get_type(ATTR);
        if (kind_attr.count() = kind.count()) {
         var frag := kind.get_fragment();
         item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        } else {
         kind_attr := kind_attr.hmark(0@0);
         var item_attr := kind_attr.leftfetchjoin(item);
         var iter_attr := kind_attr.leftfetchjoin(iter);
         var frag := kind_attr.leftfetchjoin(kind).get_fragment();
         var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         kind_elem := kind_elem.hmark(0@0);
         iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
         frag := kind_elem.leftfetchjoin(kind).get_fragment();
         item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
         var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
         iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         {
          var item_unq := iter_item.reverse().tunique();
          if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
         }
         t_iter := iter_item.hmark(0@0);
         var t_item_str := iter_item.tmark(0@0);
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        }
       }
       item_str_ := item_str;
       if (iter.count() != input_iter.tunique().count()) {
        var difference := reverse(input_iter.tdiff(iter));
        difference := difference.hmark(0@0);
        var res_mu := merged_union(iter, difference, item_str_, "");
        iter := res_mu.fetch(0);
        item_str_ := res_mu.fetch(1);
       }
      } # end of string-value
      { # cast from string to untypedAtomic
       if (iter.count() != loop003.count()) {
        ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
       }
      } # end of cast from string to untypedAtomic
      { # cast from untypedAtomic to string
       if (iter.count() != loop003.count()) {
        ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
       }
      } # end of cast from untypedAtomic to string
      { # saveResult3 () : int
       var item_str_003 := item_str_; # end of saveResult3 () : int
       iter := loop003.tmark(0@0);
       item_str_ := "1";
       { # '=' calculation
        var val_snd := item_str_;
        var val_fst := item_str_003;
        val_fst := [=](val_fst,val_snd);
        item := val_fst.[oid]();
       } # end of '=' calculation
      } # end of deleteResult3 ()
      { # saveResult3 () : int
       var iter003 := iter;
       var item003 := item; # end of saveResult3 () : int
       { # ifthenelse-translation
        var selected;
        var skip;
        if (type(item003) = bat) {
         selected := item003.ord_uselect(1@0);
         var cnt := selected.count();
         if (item003.count() = cnt) {
          skip := 2;
         } else {
          skip := int(cnt = 0);
         }
        } else {
         skip := 1 + int(item003); # handle constants efficiently
        }
        { # translateIfThen
         var loop004 := loop003;
         var inner004 := inner003;
         var outer004 := outer003;
         if (skip = 0) {
          iter := selected.mirror().join(iter003);
          iter := iter.tmark(0@0);
          outer004 := iter;
          iter := iter.mark(1@0);
          inner004 := iter;
          loop004 := inner004;
          var expOid ;
          var oidNew_expOid;
          { # expand ()
           var expOid_iter ;
           var iter_expOid ;
           var oidMap_expOid ; # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
           var temp_sort ;
           var expOid_oidMap ;
          } # end of expand ()
          # join ()
          var cnt ;
          var new_v_iter ;
          var new_v_vid ;
          var new_v_pos ;
          var new_v_item ;
          var new_v_kind ; # end of join ()
         }
         if (skip != 1) {
          {
           int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
           var itemID ; # translateConst (kind)
           iter := loop004.tmark(0@0);
          }
         } else {
          iter := empty_bat;
         }
         if (skip = 0) {
          { # mapBack ()
           var iter_oidMap := inner004.reverse();
           var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
           iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
           # kind := kind;
           # ipik := ipik;
          } # end of mapBack ()
         } # cleanUpLevel ()
        } # end of translateIfThen
       } # end of ifthenelse-translation
      } # end of deleteResult3 ()
      { # mapBack ()
       var iter_oidMap := inner003.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
     { # translate fn:empty (item*) as boolean
      var iter_count := {count}(iter.reverse(),loop002.reverse(), FALSE);
      var iter_bool := iter_count.[=](0).[oid]();
      item := iter_bool.tmark(0@0);
      iter := loop002.tmark(0@0);
     } # end of translate fn:empty (item*) as boolean
     { # saveResult3 () : int
      var iter003 := iter;
      var item003 := item; # end of saveResult3 () : int
      { # ifthenelse-translation
       var selected;
       var skip;
       if (type(item003) = bat) {
        selected := item003.ord_uselect(1@0);
        var cnt := selected.count();
        if (item003.count() = cnt) {
         skip := 2;
        } else {
         skip := int(cnt = 0);
        }
       } else {
        skip := 1 + int(item003); # handle constants efficiently
       }
       { # translateIfThen
        var loop003 := loop002;
        var inner003 := inner002;
        var outer003 := outer002;
        var v_vid003 := v_vid002;
        var v_iter003 := v_iter002;
        var v_item003 := v_item002;
        var v_kind003 := v_kind002;
        if (skip = 0) {
         selected := item003.ord_uselect(0@0);
         iter := selected.mirror().join(iter003);
         iter := iter.tmark(0@0);
         outer003 := iter;
         iter := iter.mark(1@0);
         inner003 := iter;
         loop003 := inner003;
         var expOid := v_iter003.mirror();
         var oidNew_expOid;
         { # expand ()
          var expOid_iter := expOid.leftfetchjoin(v_iter002);
          var iter_expOid := expOid_iter.reverse();
          var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
          var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
          oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
          var expOid_oidMap := oidMap_expOid.reverse();
          expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
          v_iter003 := expOid_iter;
          oidNew_expOid := expOid_iter.hmark(0@0);
         } # end of expand ()
         # join ()
         var cnt := count(v_iter003)*2;
         v_iter003 := v_iter003.tmark(0@0);
         var new_v_iter := v_iter003;
         v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
         var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
         v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
         var new_v_pos ;
         var new_v_item := oidNew_expOid.leftjoin(v_item002);
         v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
         var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
         v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
        }
        if (skip != 2) {
         { # tagname-translation
          var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
          var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
          var itemID;
          if (prop_str.texist("Result")) {
           itemID := prop_str.reverse().find("Result");
          } else {
           itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
           ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
           ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
           ws.fetch(QN_LOC).fetch(WS).insert(itemID,"Result");
           ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
           ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"Result"+str('\1')+"");
          } # translateConst (kind)
          iter := loop003.tmark(0@0);
          ipik := iter;
          item := itemID;
         } # end of tagname-translation
         { # saveResult4 () : int
          var ipik004 := ipik;
          var iter004 := iter;
          var item004 := item; # end of saveResult4 () : int
          { # tagname-translation
           var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
           var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
           var itemID;
           if (prop_str.texist("Album")) {
            itemID := prop_str.reverse().find("Album");
           } else {
            itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
            ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
            ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
            ws.fetch(QN_LOC).fetch(WS).insert(itemID,"Album");
            ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
            ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"Album"+str('\1')+"");
           } # translateConst (kind)
           iter := loop003.tmark(0@0);
           ipik := iter;
           item := itemID;
          } # end of tagname-translation
          { # saveResult5 () : int
           var ipik005 := ipik;
           var iter005 := iter;
           var item005 := item; # end of saveResult5 () : int
           { # translateVar (album)
            var vid := v_vid003.ord_uselect(38865013@0);
            vid := vid.hmark(0@0);
            iter := vid.leftfetchjoin(v_iter003);
            item := vid.leftfetchjoin(v_item003);
            kind := vid.leftfetchjoin(v_kind003);
            ipik := iter;
           } # end of translateVar (album)
           { # translateLocsteps (c)
            var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "Title");
            iter := res_scj.fetch(0);
            item := res_scj.fetch(1);
            kind := res_scj.fetch(2).set_kind(ELEM);
            ipik := item;
           } # end of translateLocsteps (c)
           { # translateLocsteps (c)
            var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
            iter := res_scj.fetch(0);
            item := res_scj.fetch(1);
            kind := res_scj.fetch(2).set_kind(ELEM);
            ipik := item;
           } # end of translateLocsteps (c)
           { # map2NODE_interface (counter)
            kind := kind.materialize(ipik);
            var attr := kind.get_type(ATTR).hmark(0@0);
            var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
            var attr_item := attr.leftfetchjoin(item);
            var attr_frag := attr.leftfetchjoin(kind).get_fragment();
            _r_attr_iter := attr_iter;
            _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
            _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
            _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
            var nodes := kind.get_type(ELEM);
            if (nodes.count() != 0) {
             var oid_oid := nodes.hmark(0@0);
             var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
             var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
             var iter_input := oid_oid.mirror();
             var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
             var res_iter := res_scj.fetch(0);
             var res_item := res_scj.fetch(1);
             var res_frag := res_scj.fetch(2);
             _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
             _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
             _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
             _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
             _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
             var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
             var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
             nodes := res_item.mark(0@0);
             var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
             root_level := nodes.leftfetchjoin(root_level);
             temp_ec_item := res_item;
             temp_ec_frag := res_frag;
             var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
             content_level := nodes.leftfetchjoin(content_level);
             content_level := content_level.[-](root_level);
             content_level := content_level.tmark(0@0);
             _elem_level := content_level;
             { # create attribute subtree copies
              var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
              var oid_attr := temp_attr.tmark(0@0);
              var oid_frag;
              if (is_constant(res_frag)) {
               oid_frag := res_frag;
              } else {
               oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
               oid_frag := oid_frag.tmark(0@0);
              }
              _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
              _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
              _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
              _attr_own  := temp_attr.hmark(0@0);
              _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
             } # end of create attribute subtree copies
            } else { # if (nodes.count() != 0) ...
             _elem_iter  := empty_bat;
             _elem_size  := empty_bat.project(int(nil));
             _elem_level := empty_bat.project(chr(nil));
             _elem_kind  := empty_bat.project(chr(nil));
             _elem_prop  := empty_bat;
             _elem_frag  := empty_bat;
             _attr_iter  := empty_bat;
             _attr_qn    := empty_bat;
             _attr_prop  := empty_bat;
             _attr_frag  := empty_bat;
             _attr_own   := empty_bat;
            } # end of else in 'if (nodes.count() != 0)'
           } # end of map2NODE_interface (counter)
           if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
            { # saveResult_node6 () : int
             var _elem_iter006   := _elem_iter  ;
             var _elem_size006   := _elem_size  ;
             var _elem_level006  := _elem_level ;
             var _elem_kind006   := _elem_kind  ;
             var _elem_prop006   := _elem_prop  ;
             var _elem_frag006   := _elem_frag  ;
             var _attr_iter006   := _attr_iter  ;
             var _attr_qn006     := _attr_qn    ;
             var _attr_prop006   := _attr_prop  ;
             var _attr_frag006   := _attr_frag  ;
             var _attr_own006    := _attr_own   ;
             var _r_attr_iter006 := _r_attr_iter;
             var _r_attr_qn006   := _r_attr_qn  ;
             var _r_attr_prop006 := _r_attr_prop;
             var _r_attr_frag006 := _r_attr_frag; # end of saveResult_node6 () : int
             _elem_iter := _elem_iter006;
             _elem_level := _elem_level006;
             _elem_kind := _elem_kind006;
             _elem_prop := _elem_prop006;
             _elem_frag := _elem_frag006;
             var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
             rootnodes := rootnodes.leftfetchjoin(_elem_kind);
             var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
             var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
             var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
             {
              var text_prop := textnodes.leftfetchjoin(_elem_prop);
              var text_frag := textnodes.leftfetchjoin(_elem_frag);
              var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
              var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
              var input_order := res_mu_is2ns.fetch(0);
              var input_str := res_mu_is2ns.fetch(1);
              var input_const := res_mu_is2ns.fetch(2);
              var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
              var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
              var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
              var result_order := result_str.hmark(0@0);
              result_order := result_order.leftfetchjoin(input_order);
              result_str := result_str.tmark(0@0);
              iter := result_order;
              ipik := iter;
              item_str_ := result_str;
             }
             { # adding new strings to text node content and create new nodes
              var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
              var unq_str := item_str_.tunique().hmark(0@0);
              var str_unq := reverse(unq_str.tdiff(ws_prop_text));
              var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
              unq_str := str_unq.hmark(seqb);
              ws_prop_text := ws_prop_text.insert(unq_str);
              var ws_text_prop := ws_prop_text.reverse().sort();
              item_str_ := item_str_.materialize(ipik);
              var X_item := item_str_.hmark(0@0);
              var X_strings := item_str_.tmark(0@0).tsort();
              var X_prop := X_strings.leftjoin(ws_text_prop);
              var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
              newPre_prop := newPre_prop.tmark(0@0);
              _elem_iter  := iter;
              _elem_size  := newPre_prop.project(0);
              _elem_level := newPre_prop.project(chr(0));
              _elem_kind  := newPre_prop.project(TEXT);
              _elem_prop  := newPre_prop;
              _elem_frag  := newPre_prop.project(WS);
             } # end of adding new fragments to the WS_FRAG bat
             var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter006), _elem_iter.leftfetchjoin(_elem_iter006), othernodes.leftfetchjoin(_elem_size006), _elem_size, othernodes.leftfetchjoin(_elem_level006), _elem_level, othernodes.leftfetchjoin(_elem_kind006), _elem_kind, othernodes.leftfetchjoin(_elem_prop006), _elem_prop, othernodes.leftfetchjoin(_elem_frag006), _elem_frag, othernodes.leftfetchjoin(_elem_iter006.mirror()), oid(nil));
             _elem_iter := res_mu_is2ns.fetch(1).chk_order();
             _elem_size := res_mu_is2ns.fetch(2);
             _elem_level:= res_mu_is2ns.fetch(3);
             _elem_kind := res_mu_is2ns.fetch(4);
             _elem_prop := res_mu_is2ns.fetch(5);
             _elem_frag := res_mu_is2ns.fetch(6);
             var preNew_preOld := res_mu_is2ns.fetch(7);
             _attr_own := _attr_own006.leftjoin(preNew_preOld.reverse());
             _attr_iter   := _attr_iter006  ;
             _attr_qn     := _attr_qn006    ;
             _attr_prop   := _attr_prop006  ;
             _attr_frag   := _attr_frag006  ;
             _r_attr_iter := _r_attr_iter006;
             _r_attr_qn   := _r_attr_qn006  ;
             _r_attr_prop := _r_attr_prop006;
             _r_attr_frag := _r_attr_frag006;
            } # end of deleteResult_node6 ()
           } # end of item-sequence-to-node-sequence
           { # loop_liftedElemConstr (counter)
            var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
            iter_size := {count}(iter_size, iter005.tunique(), FALSE);
            var root_iter  := iter_size.hmark(0@0).chk_order();
            var root_size  := iter_size.tmark(0@0);
            var root_prop  := iter005.reverse().leftfetchjoin(item005);
            if (not(is_constant(root_prop))) {
             root_prop  := root_prop.tmark(0@0);
            }
            {
             var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
             _elem_iter  := merged_result.fetch(0);
             _elem_size  := merged_result.fetch(1);
             _elem_level := merged_result.fetch(2);
             _elem_kind  := merged_result.fetch(3);
             _elem_prop  := merged_result.fetch(4);
             _elem_frag  := merged_result.fetch(5);
             var preNew_preOld := merged_result.fetch(6);
             _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
             _attr_own := _attr_own.tmark(0@0);
            }
            { # create attribute root entries
             var root_item := _elem_level.ord_uselect(chr(0));
             root_item := root_item.hmark(0@0);
             var iter_item := iter005.reverse().leftfetchjoin(root_item);
             var attr_own := _r_attr_iter.leftjoin(iter_item);
             if (_r_attr_iter.count() != 0) { # test uniqueness
              var sorting := _r_attr_iter.tsort();
              sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
              var unq_attrs := sorting.tunique();
              if (unq_attrs.count() != _r_attr_iter.count()) {
               item005 := materialize(item005,ipik005);
               if (item005.count() > 0) {
                ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item005.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
               } else {
                ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
               }
              }
             } # end of test uniqueness
             if (_attr_iter.count() = 0) {
              _attr_iter := _r_attr_iter;
              _attr_qn   := _r_attr_qn;
              _attr_prop := _r_attr_prop;
              _attr_frag := _r_attr_frag;
              _attr_own  := attr_own.tmark(0@0);
             } else {
              var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
              _r_attr_iter := _r_attr_iter.tmark(seqb);
              _r_attr_qn   := _r_attr_qn  .tmark(seqb);
              _r_attr_prop := _r_attr_prop.tmark(seqb);
              _r_attr_frag := _r_attr_frag.tmark(seqb);
              attr_own := attr_own.tmark(seqb);
              _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
              _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
              _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
              _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
              _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
             }
             _r_attr_iter := empty_bat;
             _r_attr_qn   := empty_bat;
             _r_attr_prop := empty_bat;
             _r_attr_frag := empty_bat;
            } # end of create attribute root entries
           } # end of loop_liftedElemConstr (counter)
          } # end of deleteResult5 ()
          { # saveResult_node5 () : int
           var _elem_iter005   := _elem_iter  ;
           var _elem_size005   := _elem_size  ;
           var _elem_level005  := _elem_level ;
           var _elem_kind005   := _elem_kind  ;
           var _elem_prop005   := _elem_prop  ;
           var _elem_frag005   := _elem_frag  ;
           var _attr_iter005   := _attr_iter  ;
           var _attr_qn005     := _attr_qn    ;
           var _attr_prop005   := _attr_prop  ;
           var _attr_frag005   := _attr_frag  ;
           var _attr_own005    := _attr_own   ;
           var _r_attr_iter005 := _r_attr_iter;
           var _r_attr_qn005   := _r_attr_qn  ;
           var _r_attr_prop005 := _r_attr_prop;
           var _r_attr_frag005 := _r_attr_frag; # end of saveResult_node5 () : int
           { # tagname-translation
            var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
            var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
            var itemID;
            if (prop_str.texist("Track")) {
             itemID := prop_str.reverse().find("Track");
            } else {
             itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
             ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
             ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
             ws.fetch(QN_LOC).fetch(WS).insert(itemID,"Track");
             ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
             ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"Track"+str('\1')+"");
            } # translateConst (kind)
            iter := loop003.tmark(0@0);
            ipik := iter;
            item := itemID;
           } # end of tagname-translation
           { # saveResult6 () : int
            var ipik006 := ipik;
            var iter006 := iter;
            var item006 := item; # end of saveResult6 () : int
            { # translateVar (asset)
             var vid := v_vid003.ord_uselect(38865014@0);
             vid := vid.hmark(0@0);
             iter := vid.leftfetchjoin(v_iter003);
             item := vid.leftfetchjoin(v_item003);
             kind := vid.leftfetchjoin(v_kind003);
             ipik := iter;
            } # end of translateVar (asset)
            { # translateLocsteps (c)
             var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
             item := item.materialize(ipik);
             iter := iter.materialize(ipik);
             res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "TrackName");
             iter := res_scj.fetch(0);
             item := res_scj.fetch(1);
             kind := res_scj.fetch(2).set_kind(ELEM);
             ipik := item;
            } # end of translateLocsteps (c)
            { # translateLocsteps (c)
             var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
             item := item.materialize(ipik);
             iter := iter.materialize(ipik);
             res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
             iter := res_scj.fetch(0);
             item := res_scj.fetch(1);
             kind := res_scj.fetch(2).set_kind(ELEM);
             ipik := item;
            } # end of translateLocsteps (c)
            { # map2NODE_interface (counter)
             kind := kind.materialize(ipik);
             var attr := kind.get_type(ATTR).hmark(0@0);
             var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
             var attr_item := attr.leftfetchjoin(item);
             var attr_frag := attr.leftfetchjoin(kind).get_fragment();
             _r_attr_iter := attr_iter;
             _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
             _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
             _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
             var nodes := kind.get_type(ELEM);
             if (nodes.count() != 0) {
              var oid_oid := nodes.hmark(0@0);
              var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
              var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
              var iter_input := oid_oid.mirror();
              var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
              var res_iter := res_scj.fetch(0);
              var res_item := res_scj.fetch(1);
              var res_frag := res_scj.fetch(2);
              _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
              _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
              _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
              _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
              _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
              var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
              var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
              nodes := res_item.mark(0@0);
              var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
              root_level := nodes.leftfetchjoin(root_level);
              temp_ec_item := res_item;
              temp_ec_frag := res_frag;
              var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
              content_level := nodes.leftfetchjoin(content_level);
              content_level := content_level.[-](root_level);
              content_level := content_level.tmark(0@0);
              _elem_level := content_level;
              { # create attribute subtree copies
               var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
               var oid_attr := temp_attr.tmark(0@0);
               var oid_frag;
               if (is_constant(res_frag)) {
                oid_frag := res_frag;
               } else {
                oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
                oid_frag := oid_frag.tmark(0@0);
               }
               _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
               _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
               _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
               _attr_own  := temp_attr.hmark(0@0);
               _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
              } # end of create attribute subtree copies
             } else { # if (nodes.count() != 0) ...
              _elem_iter  := empty_bat;
              _elem_size  := empty_bat.project(int(nil));
              _elem_level := empty_bat.project(chr(nil));
              _elem_kind  := empty_bat.project(chr(nil));
              _elem_prop  := empty_bat;
              _elem_frag  := empty_bat;
              _attr_iter  := empty_bat;
              _attr_qn    := empty_bat;
              _attr_prop  := empty_bat;
              _attr_frag  := empty_bat;
              _attr_own   := empty_bat;
             } # end of else in 'if (nodes.count() != 0)'
            } # end of map2NODE_interface (counter)
            if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
             { # saveResult_node7 () : int
              var _elem_iter007   := _elem_iter  ;
              var _elem_size007   := _elem_size  ;
              var _elem_level007  := _elem_level ;
              var _elem_kind007   := _elem_kind  ;
              var _elem_prop007   := _elem_prop  ;
              var _elem_frag007   := _elem_frag  ;
              var _attr_iter007   := _attr_iter  ;
              var _attr_qn007     := _attr_qn    ;
              var _attr_prop007   := _attr_prop  ;
              var _attr_frag007   := _attr_frag  ;
              var _attr_own007    := _attr_own   ;
              var _r_attr_iter007 := _r_attr_iter;
              var _r_attr_qn007   := _r_attr_qn  ;
              var _r_attr_prop007 := _r_attr_prop;
              var _r_attr_frag007 := _r_attr_frag; # end of saveResult_node7 () : int
              _elem_iter := _elem_iter007;
              _elem_level := _elem_level007;
              _elem_kind := _elem_kind007;
              _elem_prop := _elem_prop007;
              _elem_frag := _elem_frag007;
              var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
              rootnodes := rootnodes.leftfetchjoin(_elem_kind);
              var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
              var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
              var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
              {
               var text_prop := textnodes.leftfetchjoin(_elem_prop);
               var text_frag := textnodes.leftfetchjoin(_elem_frag);
               var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
               var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
               var input_order := res_mu_is2ns.fetch(0);
               var input_str := res_mu_is2ns.fetch(1);
               var input_const := res_mu_is2ns.fetch(2);
               var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
               var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
               var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
               var result_order := result_str.hmark(0@0);
               result_order := result_order.leftfetchjoin(input_order);
               result_str := result_str.tmark(0@0);
               iter := result_order;
               ipik := iter;
               item_str_ := result_str;
              }
              { # adding new strings to text node content and create new nodes
               var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
               var unq_str := item_str_.tunique().hmark(0@0);
               var str_unq := reverse(unq_str.tdiff(ws_prop_text));
               var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
               unq_str := str_unq.hmark(seqb);
               ws_prop_text := ws_prop_text.insert(unq_str);
               var ws_text_prop := ws_prop_text.reverse().sort();
               item_str_ := item_str_.materialize(ipik);
               var X_item := item_str_.hmark(0@0);
               var X_strings := item_str_.tmark(0@0).tsort();
               var X_prop := X_strings.leftjoin(ws_text_prop);
               var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
               newPre_prop := newPre_prop.tmark(0@0);
               _elem_iter  := iter;
               _elem_size  := newPre_prop.project(0);
               _elem_level := newPre_prop.project(chr(0));
               _elem_kind  := newPre_prop.project(TEXT);
               _elem_prop  := newPre_prop;
               _elem_frag  := newPre_prop.project(WS);
              } # end of adding new fragments to the WS_FRAG bat
              var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter007), _elem_iter.leftfetchjoin(_elem_iter007), othernodes.leftfetchjoin(_elem_size007), _elem_size, othernodes.leftfetchjoin(_elem_level007), _elem_level, othernodes.leftfetchjoin(_elem_kind007), _elem_kind, othernodes.leftfetchjoin(_elem_prop007), _elem_prop, othernodes.leftfetchjoin(_elem_frag007), _elem_frag, othernodes.leftfetchjoin(_elem_iter007.mirror()), oid(nil));
              _elem_iter := res_mu_is2ns.fetch(1).chk_order();
              _elem_size := res_mu_is2ns.fetch(2);
              _elem_level:= res_mu_is2ns.fetch(3);
              _elem_kind := res_mu_is2ns.fetch(4);
              _elem_prop := res_mu_is2ns.fetch(5);
              _elem_frag := res_mu_is2ns.fetch(6);
              var preNew_preOld := res_mu_is2ns.fetch(7);
              _attr_own := _attr_own007.leftjoin(preNew_preOld.reverse());
              _attr_iter   := _attr_iter007  ;
              _attr_qn     := _attr_qn007    ;
              _attr_prop   := _attr_prop007  ;
              _attr_frag   := _attr_frag007  ;
              _r_attr_iter := _r_attr_iter007;
              _r_attr_qn   := _r_attr_qn007  ;
              _r_attr_prop := _r_attr_prop007;
              _r_attr_frag := _r_attr_frag007;
             } # end of deleteResult_node7 ()
            } # end of item-sequence-to-node-sequence
            { # loop_liftedElemConstr (counter)
             var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
             iter_size := {count}(iter_size, iter006.tunique(), FALSE);
             var root_iter  := iter_size.hmark(0@0).chk_order();
             var root_size  := iter_size.tmark(0@0);
             var root_prop  := iter006.reverse().leftfetchjoin(item006);
             if (not(is_constant(root_prop))) {
              root_prop  := root_prop.tmark(0@0);
             }
             {
              var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
              _elem_iter  := merged_result.fetch(0);
              _elem_size  := merged_result.fetch(1);
              _elem_level := merged_result.fetch(2);
              _elem_kind  := merged_result.fetch(3);
              _elem_prop  := merged_result.fetch(4);
              _elem_frag  := merged_result.fetch(5);
              var preNew_preOld := merged_result.fetch(6);
              _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
              _attr_own := _attr_own.tmark(0@0);
             }
             { # create attribute root entries
              var root_item := _elem_level.ord_uselect(chr(0));
              root_item := root_item.hmark(0@0);
              var iter_item := iter006.reverse().leftfetchjoin(root_item);
              var attr_own := _r_attr_iter.leftjoin(iter_item);
              if (_r_attr_iter.count() != 0) { # test uniqueness
               var sorting := _r_attr_iter.tsort();
               sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
               var unq_attrs := sorting.tunique();
               if (unq_attrs.count() != _r_attr_iter.count()) {
                item006 := materialize(item006,ipik006);
                if (item006.count() > 0) {
                 ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item006.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
                } else {
                 ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
                }
               }
              } # end of test uniqueness
              if (_attr_iter.count() = 0) {
               _attr_iter := _r_attr_iter;
               _attr_qn   := _r_attr_qn;
               _attr_prop := _r_attr_prop;
               _attr_frag := _r_attr_frag;
               _attr_own  := attr_own.tmark(0@0);
              } else {
               var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
               _r_attr_iter := _r_attr_iter.tmark(seqb);
               _r_attr_qn   := _r_attr_qn  .tmark(seqb);
               _r_attr_prop := _r_attr_prop.tmark(seqb);
               _r_attr_frag := _r_attr_frag.tmark(seqb);
               attr_own := attr_own.tmark(seqb);
               _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
               _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
               _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
               _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
               _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
              }
              _r_attr_iter := empty_bat;
              _r_attr_qn   := empty_bat;
              _r_attr_prop := empty_bat;
              _r_attr_frag := empty_bat;
             } # end of create attribute root entries
            } # end of loop_liftedElemConstr (counter)
           } # end of deleteResult6 ()
           # translateSeq_node (f, counter)
           if (_r_attr_iter.count() = 0) {
            _r_attr_iter := _r_attr_iter005;
            _r_attr_qn := _r_attr_qn005;
            _r_attr_prop := _r_attr_prop005;
            _r_attr_frag := _r_attr_frag005;
           } else {
            if (_r_attr_iter005.count() != 0) 
            { # combine attribute roots
             var merged_result := merged_union (_r_attr_iter005.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn005, _r_attr_qn, _r_attr_prop005, _r_attr_prop, _r_attr_frag005, _r_attr_frag);
             _r_attr_iter := merged_result.fetch(0);
             _r_attr_qn := merged_result.fetch(1);
             _r_attr_prop := merged_result.fetch(2);
             _r_attr_frag := merged_result.fetch(3);
            }
           } # end of combine attribute roots
           if (_elem_iter.count() = 0) {
            _elem_iter  := _elem_iter005  ;
            _elem_size  := _elem_size005  ;
            _elem_level := _elem_level005 ;
            _elem_kind  := _elem_kind005  ;
            _elem_prop  := _elem_prop005  ;
            _elem_frag  := _elem_frag005  ;
            _attr_iter  := _attr_iter005  ;
            _attr_qn    := _attr_qn005    ;
            _attr_prop  := _attr_prop005  ;
            _attr_frag  := _attr_frag005  ;
            _attr_own   := _attr_own005   ;
           } else {
            if (_elem_iter005.count() != 0) 
            { # combine element nodes
             var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
             var shift_factor := int(seqb) - int(_elem_size005.seqbase());
             var merged_result := merged_union (_elem_iter005.chk_order(), _elem_iter.chk_order(), _elem_size005, _elem_size, _elem_level005, _elem_level, _elem_kind005, _elem_kind, _elem_prop005, _elem_prop, _elem_frag005, _elem_frag, _elem_size005.mark(seqb), _elem_size.mirror());
             _elem_iter := merged_result.fetch(0);
             _elem_size := merged_result.fetch(1);
             _elem_level:= merged_result.fetch(2);
             _elem_kind := merged_result.fetch(3);
             _elem_prop := merged_result.fetch(4);
             _elem_frag := merged_result.fetch(5);
             var preNew_preOld := merged_result.fetch(6);
             _attr_own005 := _attr_own005.[int]().[+](shift_factor).[oid]();
             merged_result := merged_union (_attr_iter005, _attr_iter, _attr_qn005, _attr_qn, _attr_prop005, _attr_prop, _attr_frag005, _attr_frag, _attr_own005, _attr_own);
             _attr_iter := merged_result.fetch(0);
             _attr_qn   := merged_result.fetch(1);
             _attr_prop := merged_result.fetch(2);
             _attr_frag := merged_result.fetch(3);
             _attr_own  := merged_result.fetch(4);
             _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
             _attr_own := _attr_own.tmark(0@0);
            }
           } # combine element nodes
           # end of translateSeq_node (f, counter)
          } # end of deleteResult_node5 ()
          { # loop_liftedElemConstr (counter)
           var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
           iter_size := {count}(iter_size, iter004.tunique(), FALSE);
           var root_iter  := iter_size.hmark(0@0).chk_order();
           var root_size  := iter_size.tmark(0@0);
           var root_prop  := iter004.reverse().leftfetchjoin(item004);
           if (not(is_constant(root_prop))) {
            root_prop  := root_prop.tmark(0@0);
           }
           {
            var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
            _elem_size  := merged_result.fetch(1);
            _elem_level := merged_result.fetch(2);
            _elem_kind  := merged_result.fetch(3);
            _elem_prop  := merged_result.fetch(4);
            _elem_frag  := merged_result.fetch(5);
            var preNew_preOld := merged_result.fetch(6);
            _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
            _attr_own := _attr_own.tmark(0@0);
           }
           { # create attribute root entries
            var root_item := _elem_level.ord_uselect(chr(0));
            root_item := root_item.hmark(0@0);
            var iter_item := iter004.reverse().leftfetchjoin(root_item);
            var attr_own := _r_attr_iter.leftjoin(iter_item);
            if (_r_attr_iter.count() != 0) { # test uniqueness
             var sorting := _r_attr_iter.tsort();
             sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
             var unq_attrs := sorting.tunique();
             if (unq_attrs.count() != _r_attr_iter.count()) {
              item004 := materialize(item004,ipik004);
              if (item004.count() > 0) {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item004.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
              } else {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
              }
             }
            } # end of test uniqueness
            if (_attr_iter.count() = 0) {
             _attr_qn   := _r_attr_qn;
             _attr_prop := _r_attr_prop;
             _attr_frag := _r_attr_frag;
             _attr_own  := attr_own.tmark(0@0);
            } else {
             var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
             _r_attr_qn   := _r_attr_qn  .tmark(seqb);
             _r_attr_prop := _r_attr_prop.tmark(seqb);
             _r_attr_frag := _r_attr_frag.tmark(seqb);
             attr_own := attr_own.tmark(seqb);
             _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
             _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
             _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
             _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
            }
           } # end of create attribute root entries
           {
            var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
            var preOld_preNew := _elem_size.mark(seqb);
            _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
            _elem_size  := _elem_size.tmark(seqb);
            _elem_level := _elem_level.tmark(seqb);
            _elem_kind  := _elem_kind.tmark(seqb);
            _elem_prop  := _elem_prop.tmark(seqb);
            _elem_frag  := _elem_frag.tmark(seqb);
           }
           ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
           ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
           ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
           ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
           ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
           {
            var knd := ELEMENT;
            while ( knd <= DOCUMENT ) {
             var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
             ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
             if ( knd = ELEMENT ) {
              var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
              ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
             }
             if ( knd = PI ) {
              var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
              ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
             }
             knd :+= chr(1);
            }
           }
           var roots := _elem_level.ord_uselect(chr(0));
           roots := roots.hmark(0@0);
           {
            var height := int(_elem_level.max());
            ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
           }
           { # adding new fragments to the WS_FRAG bat
            var seqb := oid(count(ws.fetch(WS_FRAG)));
            var new_pres := roots.tmark(seqb);
            ws.fetch(WS_FRAG).insert(new_pres);
           }
           iter := iter004;
           item := roots;
           ipik := item;
           kind := ELEM;
           { # add attribute subtree copies to WS
            var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
            _attr_qn   := _attr_qn  .tmark(seqb);
            _attr_prop := _attr_prop.tmark(seqb);
            _attr_own  := _attr_own .tmark(seqb);
            _attr_frag := _attr_frag.tmark(seqb);
            ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
            ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
            ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
            ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
           } # end of add attribute subtree copies to WS
          } # end of loop_liftedElemConstr (counter)
         } # end of deleteResult4 ()
        } else { # translateEmpty ()
         ipik := empty_bat;
         iter := empty_bat;
         item := empty_bat;
         kind := empty_kind_bat;
        }
        if (skip = 0) {
         { # mapBack ()
          var iter_oidMap := inner003.reverse();
          var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
          iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
          # kind := kind;
          # ipik := ipik;
         } # end of mapBack ()
        } # cleanUpLevel ()
       } # end of translateIfThen
      } # end of ifthenelse-translation
     } # end of deleteResult3 ()
     { # mapBack ()
      var iter_oidMap := inner002.reverse();
      var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
      iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
      # kind := kind;
      # ipik := ipik;
     } # end of mapBack ()
     # cleanUpLevel ()
    } # end of for-translation
    { # mapBack ()
     var iter_oidMap := inner001.reverse();
     var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
     iter := oid_oidMap.leftfetchjoin(outer001);
     pos := tmark_grp_unique(iter,ipik); # item := item;
     # kind := kind;
     # ipik := ipik;
    } # end of mapBack ()
    # cleanUpLevel ()
   } # end of for-translation
   { # translate fn:subsequence
    if (loop000.count() = 1) {
     var lo := item_dbl_001.fetch(0) - 1.0LL;
     if (lo < 1.0LL) lo := 0.0;
     var hi := int(lo + item_dbl_002.fetch(0)) - 1;
     iter := iter.slice(int(lo),hi);
     kind := kind.slice(int(lo),hi);
     item := item.slice(int(lo), hi);
    } else { # evaluate selection tuple by tuple (note: fully constant-resistant code)
     var offset_dbl := item_dbl_001.tmark(1@0);
     var offset_oid := leftfetchjoin(iter, [oid](offset_dbl));
     var sel := [>=](pos, offset_oid);
     var limit_dbl := item_dbl_002.tmark(1@0);
     offset_oid := iter.leftfetchjoin([oid]([+](offset_dbl, limit_dbl)));
     sel := [and](sel, [<](pos, offset_oid)); # carry through the selection on the table
     if (type(sel) = bat) {
      ipik := sel.ord_uselect(true).hmark(0@0);
      sel := false;
     } else {
      if (sel = false) ipik := bat(oid,oid);
     }
     if (sel = false) {
      iter := ipik.leftfetchjoin(iter);
      kind := ipik.leftfetchjoin(kind);
      item := ipik.leftfetchjoin(item);
     }
    }
   } # end of deleteResult2 ()
  } # end of deleteResult1 ()
 } # end of translate fn:subsequence
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn32CF6417_AlbumAssetByTrackNr1_xs_string1_xs_integer1
PROC fnBACC827E_AssetSort_xs_string1_xs_integer1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:AssetSort
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (db)
  var vid := v_vid000.ord_uselect(38865016@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  pos := vid.leftfetchjoin(v_pos000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (db)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # insertVar (vid)
  var vid := project(ipik,38865018@0);
  { # append (vid, level)
   var seqb := oid(v_vid000.count());
   vid := vid.materialize(ipik);
   v_vid000 := v_vid000.insert(vid.tmark(seqb));
  } # append (vid, level)
  { # append (iter, level)
   var seqb := oid(v_iter000.count());
   iter := iter.materialize(ipik);
   v_iter000 := v_iter000.insert(iter.tmark(seqb));
  } # append (iter, level)
  { # append (pos, level)
   var seqb := oid(v_pos000.count());
   pos := pos.materialize(ipik);
   v_pos000 := v_pos000.insert(pos.tmark(seqb));
  } # append (pos, level)
  { # append (item, level)
   var seqb := oid(v_item000.count());
   item := item.materialize(ipik);
   v_item000 := v_item000.insert(item.tmark(seqb));
  } # append (item, level)
  { # append (kind, level)
   var seqb := oid(v_kind000.count());
   kind := kind.materialize(ipik);
   v_kind000 := v_kind000.insert(kind.tmark(seqb));
  } # append (kind, level)
 } # end of insertVar (vid)
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(38865018@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  kind := vid.leftfetchjoin(v_kind000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "TrackNr1");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_parent_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, ELEMENT);
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  pos  := tmark_grp_unique(iter,ipik);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # insertVar (vid)
  var vid := project(ipik,38865019@0);
  { # append (vid, level)
   var seqb := oid(v_vid000.count());
   vid := vid.materialize(ipik);
   v_vid000 := v_vid000.insert(vid.tmark(seqb));
  } # append (vid, level)
  { # append (iter, level)
   var seqb := oid(v_iter000.count());
   iter := iter.materialize(ipik);
   v_iter000 := v_iter000.insert(iter.tmark(seqb));
  } # append (iter, level)
  { # append (pos, level)
   var seqb := oid(v_pos000.count());
   pos := pos.materialize(ipik);
   v_pos000 := v_pos000.insert(pos.tmark(seqb));
  } # append (pos, level)
  { # append (item, level)
   var seqb := oid(v_item000.count());
   item := item.materialize(ipik);
   v_item000 := v_item000.insert(item.tmark(seqb));
  } # append (item, level)
  { # append (kind, level)
   var seqb := oid(v_kind000.count());
   kind := kind.materialize(ipik);
   v_kind000 := v_kind000.insert(kind.tmark(seqb));
  } # append (kind, level)
 } # end of insertVar (vid)
 { # translateVar (result)
  var vid := v_vid000.ord_uselect(38865019@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  ipik := iter;
 } # end of translateVar (result)
 { # translate fn:count (item*) as integer
  iter := iter.materialize(ipik);
  var iter_count := [lng]({count}(iter.reverse(),loop000.reverse(), FALSE)).tmark(0@0);
  item_int_ := iter_count;
 } # end of translate fn:count (item*) as integer
 { # saveResult1 () : int
  var item_int_001 := item_int_; # end of saveResult1 () : int
  { # translateVar (limit)
   var vid := v_vid000.ord_uselect(38865017@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter000);
   item := vid.leftfetchjoin(v_item000);
  } # end of translateVar (limit)
  { # '>=' calculation
   var val_snd := item.leftfetchjoin(int_values);
   var val_fst := item_int_001;
   val_fst := [>=](val_fst,val_snd);
   item := val_fst.[oid]();
  } # end of '>=' calculation
 } # end of deleteResult1 ()
 { # saveResult1 () : int
  var iter001 := iter;
  var item001 := item; # end of saveResult1 () : int
  { # ifthenelse-translation
   var selected;
   var skip;
   if (type(item001) = bat) {
    selected := item001.ord_uselect(1@0);
    var cnt := selected.count();
    if (item001.count() = cnt) {
     skip := 2;
    } else {
     skip := int(cnt = 0);
    }
   } else {
    skip := 1 + int(item001); # handle constants efficiently
   }
   { # translateIfThen
    var loop001 := loop000;
    var inner001 := inner000;
    var outer001 := outer000;
    var v_vid001 := v_vid000;
    var v_iter001 := v_iter000;
    var v_pos001 := v_pos000;
    var v_item001 := v_item000;
    var v_kind001 := v_kind000;
    if (skip = 0) {
     iter := selected.mirror().join(iter001);
     iter := iter.tmark(0@0);
     outer001 := iter;
     iter := iter.mark(1@0);
     inner001 := iter;
     loop001 := inner001;
     var expOid := v_iter001.mirror();
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter000);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
      v_iter001 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter001)*2;
     v_iter001 := v_iter001.tmark(0@0);
     var new_v_iter := v_iter001;
     v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
     v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
     v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
     var new_v_item := oidNew_expOid.leftjoin(v_item000);
     v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
     v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    }
    if (skip != 1) {
     item_dbl_ := dbl(1LL);
     { # saveResult2 () : int
      var item_dbl_002 := item_dbl_; # end of saveResult2 () : int
      { # translateVar (limit)
       var vid := v_vid001.ord_uselect(38865017@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter001);
       item := vid.leftfetchjoin(v_item001);
      } # end of translateVar (limit)
      { # cast from integer to double
       var cast_val := item.leftfetchjoin(int_values).[dbl]();
       if (cast_val.texist(dbl(nil))) {
        ERROR ("err:FORG0001: could not cast value from integer to double.");
       }
       item_dbl_ := cast_val;
       if (iter.count() != loop001.count()) {
        ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
       }
      } # end of cast from integer to double
      { # saveResult3 () : int
       var item_dbl_003 := item_dbl_; # end of saveResult3 () : int
       { # translateVar (result)
        var vid := v_vid001.ord_uselect(38865019@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter001);
        pos := vid.leftfetchjoin(v_pos001);
        item := vid.leftfetchjoin(v_item001);
        kind := vid.leftfetchjoin(v_kind001);
        ipik := iter;
       } # end of translateVar (result)
       { # translate fn:subsequence
        if (loop001.count() = 1) {
         var lo := item_dbl_002.fetch(0) - 1.0LL;
         if (lo < 1.0LL) lo := 0.0;
         var hi := int(lo + item_dbl_003.fetch(0)) - 1; # select a slice
         ipik := ipik.slice(int(lo),hi);
         iter := iter.slice(int(lo),hi);
         kind := kind.slice(int(lo),hi);
         item := item.slice(int(lo), hi);
        } else { # evaluate selection tuple by tuple (note: fully constant-resistant code)
         var offset_dbl := item_dbl_002.tmark(1@0);
         var offset_oid := leftfetchjoin(iter, [oid](offset_dbl));
         var sel := [>=](pos, offset_oid);
         var limit_dbl := item_dbl_003.tmark(1@0);
         offset_oid := iter.leftfetchjoin([oid]([+](offset_dbl, limit_dbl)));
         sel := [and](sel, [<](pos, offset_oid)); # carry through the selection on the table
         if (type(sel) = bat) {
          ipik := sel.ord_uselect(true).hmark(0@0);
          sel := false;
         } else {
          if (sel = false) ipik := bat(oid,oid);
         }
         if (sel = false) {
          iter := ipik.leftfetchjoin(iter);
          kind := ipik.leftfetchjoin(kind);
          item := ipik.leftfetchjoin(item);
         }
        }
       } # end of deleteResult3 ()
      } # end of deleteResult2 ()
     } # end of translate fn:subsequence
    } else { # translateEmpty ()
     ipik := empty_bat;
     iter := empty_bat;
     item := empty_bat;
     kind := empty_kind_bat;
    }
    if (skip = 0) {
     { # mapBack ()
      var iter_oidMap := inner001.reverse();
      var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
      iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
      # kind := kind;
      # ipik := ipik;
     } # end of mapBack ()
    } # cleanUpLevel ()
   } # end of translateIfThen
   { # saveResult2 () : int
    var ipik002 := ipik;
    var iter002 := iter;
    var pos002 ;
    var item002 := item;
    var kind002 := kind; # end of saveResult2 () : int
    { # translateIfThen
     var loop001 := loop000;
     var inner001 := inner000;
     var outer001 := outer000;
     var v_vid001 := v_vid000;
     var v_iter001 := v_iter000;
     var v_pos001 := v_pos000;
     var v_item001 := v_item000;
     var v_kind001 := v_kind000;
     if (skip = 0) {
      selected := item001.ord_uselect(0@0);
      iter := selected.mirror().join(iter001);
      iter := iter.tmark(0@0);
      outer001 := iter;
      iter := iter.mark(1@0);
      inner001 := iter;
      loop001 := inner001;
      var expOid := v_iter001.mirror();
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter000);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
       v_iter001 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter001)*2;
      v_iter001 := v_iter001.tmark(0@0);
      var new_v_iter := v_iter001;
      v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
      v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
      v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
      var new_v_item := oidNew_expOid.leftjoin(v_item000);
      v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
      v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     }
     if (skip != 2) {
      item_dbl_ := dbl(1LL);
      { # saveResult3 () : int
       var item_dbl_003 := item_dbl_; # end of saveResult3 () : int
       { # translateVar (limit)
        var vid := v_vid001.ord_uselect(38865017@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter001);
        item := vid.leftfetchjoin(v_item001);
       } # end of translateVar (limit)
       { # cast from integer to double
        var cast_val := item.leftfetchjoin(int_values).[dbl]();
        if (cast_val.texist(dbl(nil))) {
         ERROR ("err:FORG0001: could not cast value from integer to double.");
        }
        item_dbl_ := cast_val;
        if (iter.count() != loop001.count()) {
         ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
        }
       } # end of cast from integer to double
       { # saveResult4 () : int
        var item_dbl_004 := item_dbl_; # end of saveResult4 () : int
        { # translateVar (doc)
         var vid := v_vid001.ord_uselect(38865018@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter001);
         item := vid.leftfetchjoin(v_item001);
         kind := vid.leftfetchjoin(v_kind001);
         ipik := iter;
        } # end of translateVar (doc)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "Asset");
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         pos  := tmark_grp_unique(iter,ipik);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        if (ipik.count() != 0) 
        { # for-translation
         # project ()
         iter := iter.materialize(ipik);
         var outer002 := iter;
         var order_002 := iter;
         iter := iter.mark(1@0);
         var inner002 := iter;
         pos := 1@0;
         var loop002 := inner002;
         var v_vid002;
         var v_iter002;
         var v_pos002;
         var v_item002;
         var v_kind002;
         var expOid;
         { # getExpanded (fid)
          var vu_nil := vu_fid.ord_uselect(38865006@0);
          var vid_vu := vu_vid.reverse();
          var oid_nil := vid_vu.leftjoin(vu_nil);
          expOid := v_vid001.leftjoin(oid_nil);
          expOid := expOid.mirror();
         } # end of getExpanded (fid)
         if (expOid.count() != 0) {
          var oidNew_expOid;
          { # expand ()
           var expOid_iter := expOid.leftfetchjoin(v_iter001);
           var iter_expOid := expOid_iter.reverse();
           var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
           var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
           oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
           var expOid_oidMap := oidMap_expOid.reverse();
           expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
           v_iter002 := expOid_iter;
           oidNew_expOid := expOid_iter.hmark(0@0);
          } # end of expand ()
          # join ()
          var cnt := count(v_iter002)*2;
          v_iter002 := v_iter002.tmark(0@0);
          var new_v_iter := v_iter002;
          v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
          var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
          v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
          var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
          v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
          var new_v_item := oidNew_expOid.leftjoin(v_item001);
          v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
          var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
          v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
         } else { # createNewVarTable ()
          v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_pos002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
         }
         { # insertVar (vid)
          var vid := project(ipik,38865020@0);
          { # append (vid, level)
           var seqb := oid(v_vid002.count());
           vid := vid.materialize(ipik);
           v_vid002 := v_vid002.insert(vid.tmark(seqb));
          } # append (vid, level)
          { # append (iter, level)
           var seqb := oid(v_iter002.count());
           iter := iter.materialize(ipik);
           v_iter002 := v_iter002.insert(iter.tmark(seqb));
          } # append (iter, level)
          { # append (pos, level)
           var seqb := oid(v_pos002.count());
           pos := pos.materialize(ipik);
           v_pos002 := v_pos002.insert(pos.tmark(seqb));
          } # append (pos, level)
          { # append (item, level)
           var seqb := oid(v_item002.count());
           item := item.materialize(ipik);
           v_item002 := v_item002.insert(item.tmark(seqb));
          } # append (item, level)
          { # append (kind, level)
           var seqb := oid(v_kind002.count());
           kind := kind.materialize(ipik);
           v_kind002 := v_kind002.insert(kind.tmark(seqb));
          } # append (kind, level)
         } # end of insertVar (vid)
         { # order_by
          var refined005 := inner002.reverse().leftfetchjoin(order_002);
          { # translateVar (asset)
           var vid := v_vid002.ord_uselect(38865020@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter002);
           item := vid.leftfetchjoin(v_item002);
           kind := vid.leftfetchjoin(v_kind002);
           ipik := iter;
          } # end of translateVar (asset)
          { # translateLocsteps (c)
           var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "TrackNr");
           iter := res_scj.fetch(0);
           item := res_scj.fetch(1);
           kind := res_scj.fetch(2).set_kind(ELEM);
           ipik := item;
          } # end of translateLocsteps (c)
          { # translateLocsteps (c)
           var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
           iter := res_scj.fetch(0);
           item := res_scj.fetch(1);
           kind := res_scj.fetch(2).set_kind(ELEM);
           ipik := item;
          } # end of translateLocsteps (c)
          if (ipik.count() != 0) 
          { # for-translation
           # project ()
           iter := iter.materialize(ipik);
           var outer003 := iter;
           iter := iter.mark(1@0);
           var inner003 := iter;
           var loop003 := inner003;
           var v_vid003;
           var v_iter003;
           var v_item003;
           var v_kind003;
           var expOid;
           { # getExpanded (fid)
            var vu_nil := vu_fid.ord_uselect(38865007@0);
            var vid_vu := vu_vid.reverse();
            var oid_nil := vid_vu.leftjoin(vu_nil);
            expOid := v_vid002.leftjoin(oid_nil);
            expOid := expOid.mirror();
           } # end of getExpanded (fid)
           if (expOid.count() != 0) {
            var oidNew_expOid;
            { # expand ()
             var expOid_iter := expOid.leftfetchjoin(v_iter002);
             var iter_expOid := expOid_iter.reverse();
             var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
             var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
             oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
             var expOid_oidMap := oidMap_expOid.reverse();
             expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
             v_iter003 := expOid_iter;
             oidNew_expOid := expOid_iter.hmark(0@0);
            } # end of expand ()
            # join ()
            var cnt := count(v_iter003)*2;
            v_iter003 := v_iter003.tmark(0@0);
            var new_v_iter := v_iter003;
            v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
            var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
            v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
            var new_v_pos ;
            var new_v_item := oidNew_expOid.leftjoin(v_item002);
            v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
            var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
            v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
           } else { # createNewVarTable ()
            v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
            v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
            v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
            v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
           }
           { # insertVar (vid)
            var vid := project(ipik,38865021@0);
            { # append (vid, level)
             var seqb := oid(v_vid003.count());
             vid := vid.materialize(ipik);
             v_vid003 := v_vid003.insert(vid.tmark(seqb));
            } # append (vid, level)
            { # append (iter, level)
             var seqb := oid(v_iter003.count());
             iter := iter.materialize(ipik);
             v_iter003 := v_iter003.insert(iter.tmark(seqb));
            } # append (iter, level)
            { # append (pos, level)
             var seqb ;
            } # append (pos, level)
            { # append (item, level)
             var seqb := oid(v_item003.count());
             item := item.materialize(ipik);
             v_item003 := v_item003.insert(item.tmark(seqb));
            } # append (item, level)
            { # append (kind, level)
             var seqb := oid(v_kind003.count());
             kind := kind.materialize(ipik);
             v_kind003 := v_kind003.insert(kind.tmark(seqb));
            } # append (kind, level)
           } # end of insertVar (vid)
           { # translateVar (#pf:v_535)
            var vid := v_vid003.ord_uselect(38865021@0);
            vid := vid.hmark(0@0);
            iter := vid.leftfetchjoin(v_iter003);
            item := vid.leftfetchjoin(v_item003);
            kind := vid.leftfetchjoin(v_kind003);
            ipik := iter;
           } # end of translateVar (#pf:v_535)
           { # string-value
            var input_iter := iter;
            kind := kind.materialize(ipik);
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            var kind_elem := kind.get_type(ELEM);
            var item_str;
            if (kind_elem.count() = kind.count()) {
             var frag := kind.get_fragment();
             var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
             var t_iter := res_scj.fetch(0);
             var t_item := res_scj.fetch(1);
             var t_frag := res_scj.fetch(2);
             var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
             var t_iter_unq := t_iter.tunique();
             t_iter := t_iter.materialize(t_item);
             if (t_iter_unq.count() != t_item.count()) {
              var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
              iter_item := iter_item.string_join(t_iter_unq.project(""));
              t_iter := iter_item.hmark(0@0);
              t_item_str := iter_item.tmark(0@0);
             }
             var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
             if (c_map.count() > 0) { #process comments 
              var c_iter := c_map.leftfetchjoin(iter);
              var c_item := c_map.leftfetchjoin(item);
              var c_frag := c_map.leftfetchjoin(frag);
              var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
              var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
             } # end of comment processing
             var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
             if (pi_map.count() > 0) { #process processing-instructions 
              var pi_iter := pi_map.leftfetchjoin(iter);
              var pi_item := pi_map.leftfetchjoin(item);
              var pi_frag := pi_map.leftfetchjoin(frag);
              var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
              var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
              t_item_str := res_mu.fetch(1);
             } # end of processing-instruction processing
             iter := t_iter;
             item_str := t_item_str;
            } else {
             var kind_attr := kind.get_type(ATTR);
             if (kind_attr.count() = kind.count()) {
              var frag := kind.get_fragment();
              item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
             } else {
              kind_attr := kind_attr.hmark(0@0);
              var item_attr := kind_attr.leftfetchjoin(item);
              var iter_attr := kind_attr.leftfetchjoin(iter);
              var frag := kind_attr.leftfetchjoin(kind).get_fragment();
              var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
              kind_elem := kind_elem.hmark(0@0);
              iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
              frag := kind_elem.leftfetchjoin(kind).get_fragment();
              item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
              var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
              var t_iter := res_scj.fetch(0);
              var t_item := res_scj.fetch(1);
              var t_frag := res_scj.fetch(2);
              var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
              var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
              t_iter := iter_item.hmark(0@0);
              t_item_str := iter_item.tmark(0@0);
              var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
              iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
              {
               var item_unq := iter_item.reverse().tunique();
               if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
              }
              t_iter := iter_item.hmark(0@0);
              var t_item_str := iter_item.tmark(0@0);
              var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
              if (c_map.count() > 0) { #process comments 
               var c_iter := c_map.leftfetchjoin(iter);
               var c_item := c_map.leftfetchjoin(item);
               var c_frag := c_map.leftfetchjoin(frag);
               var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
               var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
               t_iter := res_mu.fetch(0);
               t_item_str := res_mu.fetch(1);
              } # end of comment processing
              var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
              if (pi_map.count() > 0) { #process processing-instructions 
               var pi_iter := pi_map.leftfetchjoin(iter);
               var pi_item := pi_map.leftfetchjoin(item);
               var pi_frag := pi_map.leftfetchjoin(frag);
               var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
               var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
               t_iter := res_mu.fetch(0);
               t_item_str := res_mu.fetch(1);
              } # end of processing-instruction processing
              iter := t_iter;
              item_str := t_item_str;
             }
            }
            item_str_ := item_str;
            if (iter.count() != input_iter.tunique().count()) {
             var difference := reverse(input_iter.tdiff(iter));
             difference := difference.hmark(0@0);
             var res_mu := merged_union(iter, difference, item_str_, "");
             iter := res_mu.fetch(0);
             item_str_ := res_mu.fetch(1);
            }
           } # end of string-value
           { # cast from string to untypedAtomic
            if (iter.count() != loop003.count()) {
             ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
            }
           } # end of cast from string to untypedAtomic
           { # mapBack ()
            var iter_oidMap := inner003.reverse();
            var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
            iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
            # kind := kind;
            # ipik := ipik;
           } # end of mapBack ()
           # cleanUpLevel ()
          } # end of for-translation
          if (iter.tunique().count() != iter.count()) {
           ERROR ("err:XPTY0004: order by expression expects at most one value.");
          }
          { # orderspec
           var order := iter.reverse().leftfetchjoin(item_str_);
           if (iter.count() != loop002.count()) {
            order := order.access(BAT_APPEND);
            order := order.insert(reverse(loop002.tdiff(iter)).project(cast(nil,ttype(order))));
            order := order.access(BAT_READ);
           }
           refined005 := refined005.CTrefine(order);
          } # end of orderspec
          { # translateVar (asset)
           var vid := v_vid002.ord_uselect(38865020@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter002);
           pos := vid.leftfetchjoin(v_pos002);
           item := vid.leftfetchjoin(v_item002);
           kind := vid.leftfetchjoin(v_kind002);
          } # end of translateVar (asset)
          refined005 := refined005.CTrefine(loop002.reverse());
          var sorting := refined005.mirror();
          sorting := sorting.leftjoin(iter.reverse()).reverse();
          sorting := sorting.CTrefine(pos);
          ipik := sorting.hmark(0@0);
          iter := ipik.leftfetchjoin(iter);
          item := ipik.leftfetchjoin(item);
          kind := ipik.leftfetchjoin(kind);
         } # end of order_by
         { # mapBack ()
          var iter_oidMap := inner002.reverse();
          var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
          iter := oid_oidMap.leftfetchjoin(outer002);
          pos := tmark_grp_unique(iter,ipik); # item := item;
          # kind := kind;
          # ipik := ipik;
         } # end of mapBack ()
         # cleanUpLevel ()
        } # end of for-translation
        { # translate fn:subsequence
         if (loop001.count() = 1) {
          var lo := item_dbl_003.fetch(0) - 1.0LL;
          if (lo < 1.0LL) lo := 0.0;
          var hi := int(lo + item_dbl_004.fetch(0)) - 1; # select a slice
          ipik := ipik.slice(int(lo),hi);
          iter := iter.slice(int(lo),hi);
          kind := kind.slice(int(lo),hi);
          item := item.slice(int(lo), hi);
         } else { # evaluate selection tuple by tuple (note: fully constant-resistant code)
          var offset_dbl := item_dbl_003.tmark(1@0);
          var offset_oid := leftfetchjoin(iter, [oid](offset_dbl));
          var sel := [>=](pos, offset_oid);
          var limit_dbl := item_dbl_004.tmark(1@0);
          offset_oid := iter.leftfetchjoin([oid]([+](offset_dbl, limit_dbl)));
          sel := [and](sel, [<](pos, offset_oid)); # carry through the selection on the table
          if (type(sel) = bat) {
           ipik := sel.ord_uselect(true).hmark(0@0);
           sel := false;
          } else {
           if (sel = false) ipik := bat(oid,oid);
          }
          if (sel = false) {
           iter := ipik.leftfetchjoin(iter);
           kind := ipik.leftfetchjoin(kind);
           item := ipik.leftfetchjoin(item);
          }
         }
        } # end of deleteResult4 ()
       } # end of deleteResult3 ()
      } # end of translate fn:subsequence
     } else { # translateEmpty ()
      ipik := empty_bat;
      iter := empty_bat;
      item := empty_bat;
      kind := empty_kind_bat;
     }
     if (skip = 0) {
      { # mapBack ()
       var iter_oidMap := inner001.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
     } # cleanUpLevel ()
    } # end of translateIfThen
    if (ipik.count() = 0) {
     iter := iter002;
     item := item002;
     kind := kind002;
    } else {
     if (ipik002.count() != 0) 
     { # translateSeq (counter)
      var merged_result := merged_union (iter002.chk_order(), iter.chk_order(), item002, item, kind002, kind);
      iter := merged_result.fetch(0);
      item := merged_result.fetch(1);
      kind := merged_result.fetch(2);
     } # end of translateSeq (counter)
    }
   } # end of deleteResult2 ()
  } # end of ifthenelse-translation
 } # end of deleteResult1 ()
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fnBACC827E_AssetSort_xs_string1_xs_integer1

