proc_vid.insert("fnC3889EBC_convert_xs_decimal0", 1303761001LL);
var_usage.insert(1303761003@0,1303761003@0);
var_usage.insert(1303761003@0,1303761002@0);
var_usage.insert(1303761003@0,1303761001@0);
proc_vid.insert("fnF75D71C7_q01_xs_string1_xs_string1", 1303761002LL);
proc_vid.insert("fn677B6783_q02_xs_string1", 1303761011LL);
var_usage.insert(1303761017@0,1303761008@0);
var_usage.insert(1303761017@0,1303761009@0);
var_usage.insert(1303761017@0,1303761008@0);
var_usage.insert(1303761021@0,1303761012@0);
var_usage.insert(1303761023@0,1303761014@0);
var_usage.insert(1303761026@0,1303761016@0);
proc_vid.insert("fn678383E3_q03_xs_string1", 1303761015LL);
var_usage.insert(1303761031@0,1303761020@0);
var_usage.insert(1303761031@0,1303761019@0);
var_usage.insert(1303761031@0,1303761018@0);
var_usage.insert(1303761038@0,1303761024@0);
var_usage.insert(1303761037@0,1303761025@0);
proc_vid.insert("fn62BBFC16_q04_xs_string1_xs_string1_xs_string1", 1303761030LL);
var_usage.insert(1303761043@0,1303761027@0);
var_usage.insert(1303761043@0,1303761026@0);
proc_vid.insert("fnB54D13A3_q05_xs_string1_xs_double1", 1303761042LL);
proc_vid.insert("fn679BD867_q06_xs_string1", 1303761046LL);
proc_vid.insert("fn67A3F466_q07_xs_string1", 1303761048LL);
var_usage.insert(1303761055@0,1303761035@0);
proc_vid.insert("fn67AC1097_q08_xs_string1", 1303761050LL);
var_usage.insert(1303761062@0,1303761041@0);
var_usage.insert(1303761065@0,1303761045@0);
proc_vid.insert("fn67B42CFE_q09_xs_string1", 1303761057LL);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
var_usage.insert(1303761071@0,1303761050@0);
proc_vid.insert("fn678385B6_q10_xs_string1", 1303761067LL);
var_usage.insert(1303761075@0,1303761055@0);
var_usage.insert(1303761080@0,1303761056@0);
proc_vid.insert("fnD173AF7F_q11_xs_string1_xs_integer1", 1303761074LL);
var_usage.insert(1303761083@0,1303761058@0);
var_usage.insert(1303761083@0,1303761057@0);
var_usage.insert(1303761082@0,1303761061@0);
var_usage.insert(1303761089@0,1303761062@0);
proc_vid.insert("fn5DFC73FE_q12_xs_string1_xs_integer1_xs_double1", 1303761081LL);
proc_vid.insert("fn679BDA41_q13_xs_string1", 1303761090LL);
var_usage.insert(1303761094@0,1303761065@0);
proc_vid.insert("fn9447651E_q14_xs_string1_xs_string1", 1303761093LL);
proc_vid.insert("fn67AC1243_q15_xs_string1", 1303761096LL);
proc_vid.insert("fn67B42E4C_q16_xs_string1", 1303761098LL);
proc_vid.insert("fn67BC4A58_q17_xs_string1", 1303761101LL);
proc_vid.insert("fn67C4666D_q18_xs_string1", 1303761104LL);
proc_vid.insert("fn67CC8286_q19_xs_string1", 1303761107LL);
var_usage.insert(1303761113@0,1303761079@0);
var_usage.insert(1303761113@0,1303761078@0);
var_usage.insert(1303761113@0,1303761077@0);
var_usage.insert(1303761113@0,1303761082@0);
var_usage.insert(1303761113@0,1303761081@0);
var_usage.insert(1303761113@0,1303761080@0);
var_usage.insert(1303761112@0,1303761083@0);
var_usage.insert(1303761112@0,1303761081@0);
var_usage.insert(1303761112@0,1303761080@0);
var_usage.insert(1303761112@0,1303761086@0);
var_usage.insert(1303761112@0,1303761085@0);
var_usage.insert(1303761112@0,1303761084@0);
proc_vid.insert("fn6A56537F_q20_xs_string1_xs_double1_xs_double1", 1303761111LL);
PROC fnC3889EBC_convert_xs_decimal0 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:convert
 var iter;
 var item;
 var kind ;
 var v_pos000 ;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 item_dec_ := dbl(2.20371LL);
 { # saveResult1 () : int
  var item_dec_001 := item_dec_; # end of saveResult1 () : int
  { # translateVar (v)
   var vid := v_vid000.ord_uselect(1303761001@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter000);
   item := vid.leftfetchjoin(v_item000);
   kind := vid.leftfetchjoin(v_kind000);
  } # end of translateVar (v)
  { # '*' calculation
   var val_snd := item.leftfetchjoin(dec_values);
   var val_fst := item_dec_001;
   val_fst := [*](val_fst,val_snd);
   item := dec_values.addValues(val_fst).tmark(0@0);
  } # end of '*' calculation
 } # end of deleteResult1 ()
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fnC3889EBC_convert_xs_decimal0
PROC fnF75D71C7_q01_xs_string1_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q01
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761002@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761001@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761004@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (#pf:dot_027)
   var vid := v_vid001.ord_uselect(1303761004@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (#pf:dot_027)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "person");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  if (ipik.count() != 0) 
  { # for-translation
   # project ()
   iter := iter.materialize(ipik);
   var outer002 := iter;
   iter := iter.mark(1@0);
   var inner002 := iter;
   var loop002 := inner002;
   var v_vid002;
   var v_iter002;
   var v_item002;
   var v_kind002;
   var expOid;
   { # getExpanded (fid)
    var vu_nil := vu_fid.ord_uselect(1303761002@0);
    var vid_vu := vu_vid.reverse();
    var oid_nil := vid_vu.leftjoin(vu_nil);
    expOid := v_vid001.leftjoin(oid_nil);
    expOid := expOid.mirror();
   } # end of getExpanded (fid)
   if (expOid.count() != 0) {
    var oidNew_expOid;
    { # expand ()
     var expOid_iter := expOid.leftfetchjoin(v_iter001);
     var iter_expOid := expOid_iter.reverse();
     var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
     var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
     oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
     var expOid_oidMap := oidMap_expOid.reverse();
     expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
     v_iter002 := expOid_iter;
     oidNew_expOid := expOid_iter.hmark(0@0);
    } # end of expand ()
    # join ()
    var cnt := count(v_iter002)*2;
    v_iter002 := v_iter002.tmark(0@0);
    var new_v_iter := v_iter002;
    v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
    var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
    v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
    var new_v_pos ;
    var new_v_item := oidNew_expOid.leftjoin(v_item001);
    v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
    var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
    v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
   } else { # createNewVarTable ()
    v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
   }
   { # insertVar (vid)
    var vid := project(ipik,1303761006@0);
    { # append (vid, level)
     var seqb := oid(v_vid002.count());
     vid := vid.materialize(ipik);
     v_vid002 := v_vid002.insert(vid.tmark(seqb));
    } # append (vid, level)
    { # append (iter, level)
     var seqb := oid(v_iter002.count());
     iter := iter.materialize(ipik);
     v_iter002 := v_iter002.insert(iter.tmark(seqb));
    } # append (iter, level)
    { # append (pos, level)
     var seqb ;
    } # append (pos, level)
    { # append (item, level)
     var seqb := oid(v_item002.count());
     item := item.materialize(ipik);
     v_item002 := v_item002.insert(item.tmark(seqb));
    } # append (item, level)
    { # append (kind, level)
     var seqb := oid(v_kind002.count());
     kind := kind.materialize(ipik);
     v_kind002 := v_kind002.insert(kind.tmark(seqb));
    } # append (kind, level)
   } # end of insertVar (vid)
   { # translateVar (#pf:dot_041)
    var vid := v_vid002.ord_uselect(1303761006@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter002);
    item := vid.leftfetchjoin(v_item002);
    kind := vid.leftfetchjoin(v_kind002);
    ipik := iter;
   } # end of translateVar (#pf:dot_041)
   { # loop_liftedSCJ (axis, kind, ns, loc)
    { # attribute axis
     var oid_iter := iter;
     var oid_item := item.materialize(ipik);
     var oid_frag := kind.get_fragment();
     var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
     oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
     var oid_attr := temp1.tmark(0@0);
     oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
     var temp1_str; # only needed for name test
     temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
     temp1 := temp1_str.ord_uselect("");
     temp1 := temp1.hmark(0@0);
     oid_attr := temp1.leftfetchjoin(oid_attr);
     oid_frag := temp1.leftfetchjoin(oid_frag);
     oid_iter := temp1.leftfetchjoin(oid_iter);
     temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
     temp1 := temp1_str.ord_uselect("id");
     temp1 := temp1.hmark(0@0);
     oid_attr := temp1.leftfetchjoin(oid_attr);
     oid_frag := temp1.leftfetchjoin(oid_frag);
     oid_iter := temp1.leftfetchjoin(oid_iter);
     iter := oid_iter.tmark(0@0);
     item := oid_attr.tmark(0@0);
     kind := oid_frag.tmark(0@0);
     if (type(iter) = bat) {
      ipik := iter;
     } else {
      if (type(item) = bat) {
       ipik := item;
      } else {
       ipik := kind;
      }
     }
    } # end of attribute axis
    kind := kind.set_kind(ATTR);
   } # end of translateLocsteps (c)
   if (ipik.count() != 0) 
   { # for-translation
    # project ()
    iter := iter.materialize(ipik);
    var outer003 := iter;
    iter := iter.mark(1@0);
    var inner003 := iter;
    var loop003 := inner003;
    var v_vid003;
    var v_iter003;
    var v_item003;
    var v_kind003;
    var expOid;
    { # getExpanded (fid)
     var vu_nil := vu_fid.ord_uselect(1303761003@0);
     var vid_vu := vu_vid.reverse();
     var oid_nil := vid_vu.leftjoin(vu_nil);
     expOid := v_vid002.leftjoin(oid_nil);
     expOid := expOid.mirror();
    } # end of getExpanded (fid)
    if (expOid.count() != 0) {
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter002);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
      v_iter003 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter003)*2;
     v_iter003 := v_iter003.tmark(0@0);
     var new_v_iter := v_iter003;
     v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
     v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos ;
     var new_v_item := oidNew_expOid.leftjoin(v_item002);
     v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
     v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    } else { # createNewVarTable ()
     v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
    }
    { # insertVar (vid)
     var vid := project(ipik,1303761008@0);
     { # append (vid, level)
      var seqb := oid(v_vid003.count());
      vid := vid.materialize(ipik);
      v_vid003 := v_vid003.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter003.count());
      iter := iter.materialize(ipik);
      v_iter003 := v_iter003.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb ;
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item003.count());
      item := item.materialize(ipik);
      v_item003 := v_item003.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind003.count());
      kind := kind.materialize(ipik);
      v_kind003 := v_kind003.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    { # translateVar (#pf:v_2784)
     var vid := v_vid003.ord_uselect(1303761008@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter003);
     item := vid.leftfetchjoin(v_item003);
     kind := vid.leftfetchjoin(v_kind003);
     ipik := iter;
    } # end of translateVar (#pf:v_2784)
    { # string-value
     var input_iter := iter;
     kind := kind.materialize(ipik);
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     var kind_elem := kind.get_type(ELEM);
     var item_str;
     if (kind_elem.count() = kind.count()) {
      var frag := kind.get_fragment();
      var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
      var t_iter := res_scj.fetch(0);
      var t_item := res_scj.fetch(1);
      var t_frag := res_scj.fetch(2);
      var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
      var t_iter_unq := t_iter.tunique();
      t_iter := t_iter.materialize(t_item);
      if (t_iter_unq.count() != t_item.count()) {
       var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       iter_item := iter_item.string_join(t_iter_unq.project(""));
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
      }
      var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
      if (c_map.count() > 0) { #process comments 
       var c_iter := c_map.leftfetchjoin(iter);
       var c_item := c_map.leftfetchjoin(item);
       var c_frag := c_map.leftfetchjoin(frag);
       var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
       var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of comment processing
      var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
      if (pi_map.count() > 0) { #process processing-instructions 
       var pi_iter := pi_map.leftfetchjoin(iter);
       var pi_item := pi_map.leftfetchjoin(item);
       var pi_frag := pi_map.leftfetchjoin(frag);
       var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
       var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
       t_item_str := res_mu.fetch(1);
      } # end of processing-instruction processing
      iter := t_iter;
      item_str := t_item_str;
     } else {
      var kind_attr := kind.get_type(ATTR);
      if (kind_attr.count() = kind.count()) {
       var frag := kind.get_fragment();
       item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
      } else {
       kind_attr := kind_attr.hmark(0@0);
       var item_attr := kind_attr.leftfetchjoin(item);
       var iter_attr := kind_attr.leftfetchjoin(iter);
       var frag := kind_attr.leftfetchjoin(kind).get_fragment();
       var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
       kind_elem := kind_elem.hmark(0@0);
       iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
       frag := kind_elem.leftfetchjoin(kind).get_fragment();
       item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
       var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
       var t_iter := res_scj.fetch(0);
       var t_item := res_scj.fetch(1);
       var t_frag := res_scj.fetch(2);
       var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
       var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
       iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       {
        var item_unq := iter_item.reverse().tunique();
        if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
       }
       t_iter := iter_item.hmark(0@0);
       var t_item_str := iter_item.tmark(0@0);
       var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
       if (c_map.count() > 0) { #process comments 
        var c_iter := c_map.leftfetchjoin(iter);
        var c_item := c_map.leftfetchjoin(item);
        var c_frag := c_map.leftfetchjoin(frag);
        var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
        var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of comment processing
       var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
       if (pi_map.count() > 0) { #process processing-instructions 
        var pi_iter := pi_map.leftfetchjoin(iter);
        var pi_item := pi_map.leftfetchjoin(item);
        var pi_frag := pi_map.leftfetchjoin(frag);
        var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
        var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of processing-instruction processing
       iter := t_iter;
       item_str := t_item_str;
      }
     }
     item_str_ := item_str;
     if (iter.count() != input_iter.tunique().count()) {
      var difference := reverse(input_iter.tdiff(iter));
      difference := difference.hmark(0@0);
      var res_mu := merged_union(iter, difference, item_str_, "");
      iter := res_mu.fetch(0);
      item_str_ := res_mu.fetch(1);
     }
    } # end of string-value
    { # cast from string to untypedAtomic
     if (iter.count() != loop003.count()) {
      ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
     }
    } # end of cast from string to untypedAtomic
    { # cast from untypedAtomic to string
     if (iter.count() != loop003.count()) {
      ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
     }
    } # end of cast from untypedAtomic to string
    { # saveResult1 () : int
     var item_str_001 := item_str_; # end of saveResult1 () : int
     { # translateVar (id)
      var vid := v_vid003.ord_uselect(1303761003@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter003);
      item := vid.leftfetchjoin(v_item003);
     } # end of translateVar (id)
     { # '=' calculation
      var val_snd := item.leftfetchjoin(str_values);
      var val_fst := item_str_001;
      val_fst := [=](val_fst,val_snd);
      item := val_fst.[oid]();
     } # end of '=' calculation
    } # end of deleteResult1 ()
    { # saveResult1 () : int
     var iter001 := iter;
     var item001 := item; # end of saveResult1 () : int
     { # ifthenelse-translation
      var selected;
      var skip;
      if (type(item001) = bat) {
       selected := item001.ord_uselect(1@0);
       var cnt := selected.count();
       if (item001.count() = cnt) {
        skip := 2;
       } else {
        skip := int(cnt = 0);
       }
      } else {
       skip := 1 + int(item001); # handle constants efficiently
      }
      { # translateIfThen
       var loop004 := loop003;
       var inner004 := inner003;
       var outer004 := outer003;
       if (skip = 0) {
        iter := selected.mirror().join(iter001);
        iter := iter.tmark(0@0);
        outer004 := iter;
        iter := iter.mark(1@0);
        inner004 := iter;
        loop004 := inner004;
        var expOid ;
        var oidNew_expOid;
        { # expand ()
         var expOid_iter ;
         var iter_expOid ;
         var oidMap_expOid ; # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
         var temp_sort ;
         var expOid_oidMap ;
        } # end of expand ()
        # join ()
        var cnt ;
        var new_v_iter ;
        var new_v_vid ;
        var new_v_pos ;
        var new_v_item ;
        var new_v_kind ; # end of join ()
       }
       if (skip != 1) {
        {
         int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
         var itemID ; # translateConst (kind)
         iter := loop004.tmark(0@0);
        }
       } else {
        iter := empty_bat;
       }
       if (skip = 0) {
        { # mapBack ()
         var iter_oidMap := inner004.reverse();
         var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
         iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
         # kind := kind;
         # ipik := ipik;
        } # end of mapBack ()
       } # cleanUpLevel ()
      } # end of translateIfThen
     } # end of ifthenelse-translation
    } # end of deleteResult1 ()
    { # mapBack ()
     var iter_oidMap := inner003.reverse();
     var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
     iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
     # kind := kind;
     # ipik := ipik;
    } # end of mapBack ()
    # cleanUpLevel ()
   } # end of for-translation
   { # translate fn:empty (item*) as boolean
    var iter_count := {count}(iter.reverse(),loop002.reverse(), FALSE);
    var iter_bool := iter_count.[=](0).[oid]();
    item := iter_bool.tmark(0@0);
    iter := loop002.tmark(0@0);
   } # end of translate fn:empty (item*) as boolean
   { # saveResult1 () : int
    var iter001 := iter;
    var item001 := item; # end of saveResult1 () : int
    { # ifthenelse-translation
     var selected;
     var skip;
     if (type(item001) = bat) {
      selected := item001.ord_uselect(1@0);
      var cnt := selected.count();
      if (item001.count() = cnt) {
       skip := 2;
      } else {
       skip := int(cnt = 0);
      }
     } else {
      skip := 1 + int(item001); # handle constants efficiently
     }
     { # translateIfThen
      var inner003 := inner002;
      var outer003 := outer002;
      var v_vid003 := v_vid002;
      var v_iter003 := v_iter002;
      var v_pos003 ;
      var v_item003 := v_item002;
      var v_kind003 := v_kind002;
      if (skip = 0) {
       selected := item001.ord_uselect(0@0);
       iter := selected.mirror().join(iter001);
       iter := iter.tmark(0@0);
       outer003 := iter;
       iter := iter.mark(1@0);
       inner003 := iter;
       var expOid := v_iter003.mirror();
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter002);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
        v_iter003 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter003)*2;
       v_iter003 := v_iter003.tmark(0@0);
       var new_v_iter := v_iter003;
       v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
       v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item002);
       v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
       v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      }
      if (skip != 2) {
       { # translateVar (#pf:dot_041)
        var vid := v_vid003.ord_uselect(1303761006@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter003);
        item := vid.leftfetchjoin(v_item003);
        kind := vid.leftfetchjoin(v_kind003);
        ipik := iter;
       } # end of translateVar (#pf:dot_041)
      } else { # translateEmpty ()
       ipik := empty_bat;
       iter := empty_bat;
       item := empty_bat;
       kind := empty_kind_bat;
      }
      if (skip = 0) {
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
      } # cleanUpLevel ()
     } # end of translateIfThen
    } # end of ifthenelse-translation
   } # end of deleteResult1 ()
   { # mapBack ()
    var iter_oidMap := inner002.reverse();
    var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
    iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
    # kind := kind;
    # ipik := ipik;
   } # end of mapBack ()
   # cleanUpLevel ()
  } # end of for-translation
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 { # translate pf:distinct-doc-order (node*) as node*
  var sorting;
  var simple := false;
  if (type(kind) != bat) {
   simple := (kind = ELEM);
  }
  if (not(simple)) {
   kind := kind.materialize(ipik);
   simple := (kind.count() = kind.get_type(ELEM).count());
  }
  if (simple) {
   sorting := iter.tsort();
   sorting := sorting.CTrefine(kind);
   sorting := sorting.CTrefine(item);
  } else { # cope also with attributes and sort them according to their owner
   var elements := kind.get_type(ELEM).mirror();
   var elem_iters := elements.leftfetchjoin(iter);
   var elem_items := elements.leftfetchjoin(item);
   var elem_frags := elements.leftfetchjoin(kind.get_fragment());
   var elem_attrs := elements.mark(nil);
   var attributes := kind.get_type(ATTR).mirror();
   var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
   var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
   var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
   var attr_key := attributes.hmark(0@0);
   var temp_attr := attr_attrs.tmark(0@0);
   var temp_frag := attr_frags.tmark(0@0);
   var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
   sorting := elem_iters.union(attr_iters).tsort();
   sorting := sorting.CTrefine(elem_frags.union(attr_frags));
   sorting := sorting.CTrefine(elem_items.union(attr_items));
   sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
  }
  ipik := sorting.reverse().{min}().tmark(0@0);
  iter := ipik.leftfetchjoin(iter);
  item := ipik.leftfetchjoin(item);
  kind := ipik.leftfetchjoin(kind);
 } # end of translate pf:distinct-doc-order (node*) as node*
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761004@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761009@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (b)
   var vid := v_vid001.ord_uselect(1303761009@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (b)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761005@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761010@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (#pf:v_2786)
   var vid := v_vid001.ord_uselect(1303761010@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (#pf:v_2786)
  { # string-value
   var input_iter := iter;
   kind := kind.materialize(ipik);
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   var kind_elem := kind.get_type(ELEM);
   var item_str;
   if (kind_elem.count() = kind.count()) {
    var frag := kind.get_fragment();
    var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
    var t_iter := res_scj.fetch(0);
    var t_item := res_scj.fetch(1);
    var t_frag := res_scj.fetch(2);
    var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
    var t_iter_unq := t_iter.tunique();
    t_iter := t_iter.materialize(t_item);
    if (t_iter_unq.count() != t_item.count()) {
     var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
     iter_item := iter_item.string_join(t_iter_unq.project(""));
     t_iter := iter_item.hmark(0@0);
     t_item_str := iter_item.tmark(0@0);
    }
    var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
    if (c_map.count() > 0) { #process comments 
     var c_iter := c_map.leftfetchjoin(iter);
     var c_item := c_map.leftfetchjoin(item);
     var c_frag := c_map.leftfetchjoin(frag);
     var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
     var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
     t_iter := res_mu.fetch(0);
     t_item_str := res_mu.fetch(1);
    } # end of comment processing
    var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
    if (pi_map.count() > 0) { #process processing-instructions 
     var pi_iter := pi_map.leftfetchjoin(iter);
     var pi_item := pi_map.leftfetchjoin(item);
     var pi_frag := pi_map.leftfetchjoin(frag);
     var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
     var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
     t_item_str := res_mu.fetch(1);
    } # end of processing-instruction processing
    iter := t_iter;
    item_str := t_item_str;
   } else {
    var kind_attr := kind.get_type(ATTR);
    if (kind_attr.count() = kind.count()) {
     var frag := kind.get_fragment();
     item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
    } else {
     kind_attr := kind_attr.hmark(0@0);
     var item_attr := kind_attr.leftfetchjoin(item);
     var iter_attr := kind_attr.leftfetchjoin(iter);
     var frag := kind_attr.leftfetchjoin(kind).get_fragment();
     var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
     kind_elem := kind_elem.hmark(0@0);
     iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
     frag := kind_elem.leftfetchjoin(kind).get_fragment();
     item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
     var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
     var t_iter := res_scj.fetch(0);
     var t_item := res_scj.fetch(1);
     var t_frag := res_scj.fetch(2);
     var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
     var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
     t_iter := iter_item.hmark(0@0);
     t_item_str := iter_item.tmark(0@0);
     var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
     t_iter := res_mu.fetch(0);
     t_item_str := res_mu.fetch(1);
     iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
     {
      var item_unq := iter_item.reverse().tunique();
      if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
     }
     t_iter := iter_item.hmark(0@0);
     var t_item_str := iter_item.tmark(0@0);
     var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
     if (c_map.count() > 0) { #process comments 
      var c_iter := c_map.leftfetchjoin(iter);
      var c_item := c_map.leftfetchjoin(item);
      var c_frag := c_map.leftfetchjoin(frag);
      var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
      var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
     } # end of comment processing
     var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
     if (pi_map.count() > 0) { #process processing-instructions 
      var pi_iter := pi_map.leftfetchjoin(iter);
      var pi_item := pi_map.leftfetchjoin(item);
      var pi_frag := pi_map.leftfetchjoin(frag);
      var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
      var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
     } # end of processing-instruction processing
     iter := t_iter;
     item_str := t_item_str;
    }
   }
   item_str_ := item_str;
   if (iter.count() != input_iter.tunique().count()) {
    var difference := reverse(input_iter.tdiff(iter));
    difference := difference.hmark(0@0);
    var res_mu := merged_union(iter, difference, item_str_, "");
    iter := res_mu.fetch(0);
    item_str_ := res_mu.fetch(1);
   }
  } # end of string-value
  { # cast from string to untypedAtomic
   kind := U_A;
   if (iter.count() != loop001.count()) {
    ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
   }
  } # end of cast from string to untypedAtomic
  { # cast from untypedAtomic to string
   item := str_values.addValues(item_str_).tmark(0@0);
   if (iter.count() != loop001.count()) {
    ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
   }
  } # end of cast from untypedAtomic to string
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fnF75D71C7_q01_xs_string1_xs_string1
PROC fn677B6783_q02_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q02
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761011@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "open_auction");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761006@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761012@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # tagname-translation
   var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
   var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
   var itemID;
   if (prop_str.texist("increase")) {
    itemID := prop_str.reverse().find("increase");
   } else {
    itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
    ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
    ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
    ws.fetch(QN_LOC).fetch(WS).insert(itemID,"increase");
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
    ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"increase"+str('\1')+"");
   } # translateConst (kind)
   iter := loop001.tmark(0@0);
   ipik := iter;
   item := itemID;
  } # end of tagname-translation
  { # saveResult1 () : int
   var ipik001 := ipik;
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # translateVar (b)
    var vid := v_vid001.ord_uselect(1303761012@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter001);
    item := vid.leftfetchjoin(v_item001);
    kind := vid.leftfetchjoin(v_kind001);
    ipik := iter;
   } # end of translateVar (b)
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "bidder");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   if (ipik.count() != 0) 
   { # for-translation
    # project ()
    iter := iter.materialize(ipik);
    var outer002 := iter;
    iter := iter.mark(1@0);
    var inner002 := iter;
    var v_vid002;
    var v_iter002;
    var v_item002;
    var v_kind002;
    var expOid;
    { # getExpanded (fid)
     var vu_nil := vu_fid.ord_uselect(1303761007@0);
     var vid_vu := vu_vid.reverse();
     var oid_nil := vid_vu.leftjoin(vu_nil);
     expOid := v_vid001.leftjoin(oid_nil);
     expOid := expOid.mirror();
    } # end of getExpanded (fid)
    if (expOid.count() != 0) {
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter001);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
      v_iter002 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter002)*2;
     v_iter002 := v_iter002.tmark(0@0);
     var new_v_iter := v_iter002;
     v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
     v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos ;
     var new_v_item := oidNew_expOid.leftjoin(v_item001);
     v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
     v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    } else { # createNewVarTable ()
     v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
    }
    { # insertVar (vid)
     var vid := project(ipik,1303761013@0);
     { # append (vid, level)
      var seqb := oid(v_vid002.count());
      vid := vid.materialize(ipik);
      v_vid002 := v_vid002.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter002.count());
      iter := iter.materialize(ipik);
      v_iter002 := v_iter002.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb ;
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item002.count());
      item := item.materialize(ipik);
      v_item002 := v_item002.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind002.count());
      kind := kind.materialize(ipik);
      v_kind002 := v_kind002.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    { # createEnumeration ()
     var ints_cE := tmark_grp_unique(outer002, outer002).[lng]();
     item := int_values.addValues(ints_cE).tmark(0@0);
     iter := inner002.tmark(0@0);
     ipik := iter;
     kind := INT;
    } # end of createEnumeration ()
    { # insertVar (vid)
     var vid := project(ipik,1303761014@0);
     { # append (vid, level)
      var seqb := oid(v_vid002.count());
      vid := vid.materialize(ipik);
      v_vid002 := v_vid002.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter002.count());
      iter := iter.materialize(ipik);
      v_iter002 := v_iter002.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb ;
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item002.count());
      item := item.materialize(ipik);
      v_item002 := v_item002.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind002.count());
      kind := kind.materialize(ipik);
      v_kind002 := v_kind002.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    item_int_ := 1LL;
    { # saveResult2 () : int
     var item_int_002 := item_int_; # end of saveResult2 () : int
     { # translateVar (#pf:pos_145)
      var vid := v_vid002.ord_uselect(1303761014@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter002);
      item := vid.leftfetchjoin(v_item002);
     } # end of translateVar (#pf:pos_145)
     { # '=' calculation
      var val_snd := item.leftfetchjoin(int_values);
      var val_fst := item_int_002;
      val_fst := [=](val_fst,val_snd);
      item := val_fst.[oid]();
     } # end of '=' calculation
    } # end of deleteResult2 ()
    { # saveResult2 () : int
     var iter002 := iter;
     var item002 := item; # end of saveResult2 () : int
     { # ifthenelse-translation
      var selected;
      var skip;
      if (type(item002) = bat) {
       selected := item002.ord_uselect(1@0);
       var cnt := selected.count();
       if (item002.count() = cnt) {
        skip := 2;
       } else {
        skip := int(cnt = 0);
       }
      } else {
       skip := 1 + int(item002); # handle constants efficiently
      }
      { # translateIfThen
       var inner003 := inner002;
       var outer003 := outer002;
       var v_vid003 := v_vid002;
       var v_iter003 := v_iter002;
       var v_pos003 ;
       var v_item003 := v_item002;
       var v_kind003 := v_kind002;
       if (skip = 0) {
        iter := selected.mirror().join(iter002);
        iter := iter.tmark(0@0);
        outer003 := iter;
        iter := iter.mark(1@0);
        inner003 := iter;
        var expOid := v_iter003.mirror();
        var oidNew_expOid;
        { # expand ()
         var expOid_iter := expOid.leftfetchjoin(v_iter002);
         var iter_expOid := expOid_iter.reverse();
         var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
         var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
         oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
         var expOid_oidMap := oidMap_expOid.reverse();
         expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
         v_iter003 := expOid_iter;
         oidNew_expOid := expOid_iter.hmark(0@0);
        } # end of expand ()
        # join ()
        var cnt := count(v_iter003)*2;
        v_iter003 := v_iter003.tmark(0@0);
        var new_v_iter := v_iter003;
        v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
        var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
        v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
        var new_v_pos ;
        var new_v_item := oidNew_expOid.leftjoin(v_item002);
        v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
        var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
        v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
       }
       if (skip != 1) {
        { # translateVar (#pf:dot_144)
         var vid := v_vid003.ord_uselect(1303761013@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter003);
         item := vid.leftfetchjoin(v_item003);
         kind := vid.leftfetchjoin(v_kind003);
         ipik := iter;
        } # end of translateVar (#pf:dot_144)
       } else { # translateEmpty ()
        ipik := empty_bat;
        iter := empty_bat;
        item := empty_bat;
        kind := empty_kind_bat;
       }
       if (skip = 0) {
        { # mapBack ()
         var iter_oidMap := inner003.reverse();
         var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
         iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
         # kind := kind;
         # ipik := ipik;
        } # end of mapBack ()
       } # cleanUpLevel ()
      } # end of translateIfThen
     } # end of ifthenelse-translation
    } # end of deleteResult2 ()
    { # mapBack ()
     var iter_oidMap := inner002.reverse();
     var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
     iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
     # kind := kind;
     # ipik := ipik;
    } # end of mapBack ()
    # cleanUpLevel ()
   } # end of for-translation
   { # translate pf:distinct-doc-order (node*) as node*
    var sorting;
    var simple := false;
    if (type(kind) != bat) {
     simple := (kind = ELEM);
    }
    if (not(simple)) {
     kind := kind.materialize(ipik);
     simple := (kind.count() = kind.get_type(ELEM).count());
    }
    if (simple) {
     sorting := iter.tsort();
     sorting := sorting.CTrefine(kind);
     sorting := sorting.CTrefine(item);
    } else { # cope also with attributes and sort them according to their owner
     var elements := kind.get_type(ELEM).mirror();
     var elem_iters := elements.leftfetchjoin(iter);
     var elem_items := elements.leftfetchjoin(item);
     var elem_frags := elements.leftfetchjoin(kind.get_fragment());
     var elem_attrs := elements.mark(nil);
     var attributes := kind.get_type(ATTR).mirror();
     var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
     var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
     var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
     var attr_key := attributes.hmark(0@0);
     var temp_attr := attr_attrs.tmark(0@0);
     var temp_frag := attr_frags.tmark(0@0);
     var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
     sorting := elem_iters.union(attr_iters).tsort();
     sorting := sorting.CTrefine(elem_frags.union(attr_frags));
     sorting := sorting.CTrefine(elem_items.union(attr_items));
     sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
    }
    ipik := sorting.reverse().{min}().tmark(0@0);
    iter := ipik.leftfetchjoin(iter);
    item := ipik.leftfetchjoin(item);
    kind := ipik.leftfetchjoin(kind);
   } # end of translate pf:distinct-doc-order (node*) as node*
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "increase");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   { # map2NODE_interface (counter)
    kind := kind.materialize(ipik);
    var attr := kind.get_type(ATTR).hmark(0@0);
    var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
    var attr_item := attr.leftfetchjoin(item);
    var attr_frag := attr.leftfetchjoin(kind).get_fragment();
    _r_attr_iter := attr_iter;
    _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
    _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
    _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
    var nodes := kind.get_type(ELEM);
    if (nodes.count() != 0) {
     var oid_oid := nodes.hmark(0@0);
     var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
     var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
     var iter_input := oid_oid.mirror();
     var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
     var res_iter := res_scj.fetch(0);
     var res_item := res_scj.fetch(1);
     var res_frag := res_scj.fetch(2);
     _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
     _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
     _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
     _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
     _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
     var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
     var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
     nodes := res_item.mark(0@0);
     var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
     root_level := nodes.leftfetchjoin(root_level);
     temp_ec_item := res_item;
     temp_ec_frag := res_frag;
     var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
     content_level := nodes.leftfetchjoin(content_level);
     content_level := content_level.[-](root_level);
     content_level := content_level.tmark(0@0);
     _elem_level := content_level;
     { # create attribute subtree copies
      var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
      var oid_attr := temp_attr.tmark(0@0);
      var oid_frag;
      if (is_constant(res_frag)) {
       oid_frag := res_frag;
      } else {
       oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
       oid_frag := oid_frag.tmark(0@0);
      }
      _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
      _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
      _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
      _attr_own  := temp_attr.hmark(0@0);
      _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
     } # end of create attribute subtree copies
    } else { # if (nodes.count() != 0) ...
     _elem_iter  := empty_bat;
     _elem_size  := empty_bat.project(int(nil));
     _elem_level := empty_bat.project(chr(nil));
     _elem_kind  := empty_bat.project(chr(nil));
     _elem_prop  := empty_bat;
     _elem_frag  := empty_bat;
     _attr_iter  := empty_bat;
     _attr_qn    := empty_bat;
     _attr_prop  := empty_bat;
     _attr_frag  := empty_bat;
     _attr_own   := empty_bat;
    } # end of else in 'if (nodes.count() != 0)'
   } # end of map2NODE_interface (counter)
   if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
    { # saveResult_node2 () : int
     var _elem_iter002   := _elem_iter  ;
     var _elem_size002   := _elem_size  ;
     var _elem_level002  := _elem_level ;
     var _elem_kind002   := _elem_kind  ;
     var _elem_prop002   := _elem_prop  ;
     var _elem_frag002   := _elem_frag  ;
     var _attr_iter002   := _attr_iter  ;
     var _attr_qn002     := _attr_qn    ;
     var _attr_prop002   := _attr_prop  ;
     var _attr_frag002   := _attr_frag  ;
     var _attr_own002    := _attr_own   ;
     var _r_attr_iter002 := _r_attr_iter;
     var _r_attr_qn002   := _r_attr_qn  ;
     var _r_attr_prop002 := _r_attr_prop;
     var _r_attr_frag002 := _r_attr_frag; # end of saveResult_node2 () : int
     _elem_iter := _elem_iter002;
     _elem_level := _elem_level002;
     _elem_kind := _elem_kind002;
     _elem_prop := _elem_prop002;
     _elem_frag := _elem_frag002;
     var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
     rootnodes := rootnodes.leftfetchjoin(_elem_kind);
     var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
     var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
     var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
     {
      var text_prop := textnodes.leftfetchjoin(_elem_prop);
      var text_frag := textnodes.leftfetchjoin(_elem_frag);
      var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
      var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
      var input_order := res_mu_is2ns.fetch(0);
      var input_str := res_mu_is2ns.fetch(1);
      var input_const := res_mu_is2ns.fetch(2);
      var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
      var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
      var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
      var result_order := result_str.hmark(0@0);
      result_order := result_order.leftfetchjoin(input_order);
      result_str := result_str.tmark(0@0);
      iter := result_order;
      ipik := iter;
      item_str_ := result_str;
     }
     { # adding new strings to text node content and create new nodes
      var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
      var unq_str := item_str_.tunique().hmark(0@0);
      var str_unq := reverse(unq_str.tdiff(ws_prop_text));
      var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
      unq_str := str_unq.hmark(seqb);
      ws_prop_text := ws_prop_text.insert(unq_str);
      var ws_text_prop := ws_prop_text.reverse().sort();
      item_str_ := item_str_.materialize(ipik);
      var X_item := item_str_.hmark(0@0);
      var X_strings := item_str_.tmark(0@0).tsort();
      var X_prop := X_strings.leftjoin(ws_text_prop);
      var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
      newPre_prop := newPre_prop.tmark(0@0);
      _elem_iter  := iter;
      _elem_size  := newPre_prop.project(0);
      _elem_level := newPre_prop.project(chr(0));
      _elem_kind  := newPre_prop.project(TEXT);
      _elem_prop  := newPre_prop;
      _elem_frag  := newPre_prop.project(WS);
     } # end of adding new fragments to the WS_FRAG bat
     var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter002), _elem_iter.leftfetchjoin(_elem_iter002), othernodes.leftfetchjoin(_elem_size002), _elem_size, othernodes.leftfetchjoin(_elem_level002), _elem_level, othernodes.leftfetchjoin(_elem_kind002), _elem_kind, othernodes.leftfetchjoin(_elem_prop002), _elem_prop, othernodes.leftfetchjoin(_elem_frag002), _elem_frag, othernodes.leftfetchjoin(_elem_iter002.mirror()), oid(nil));
     _elem_iter := res_mu_is2ns.fetch(1).chk_order();
     _elem_size := res_mu_is2ns.fetch(2);
     _elem_level:= res_mu_is2ns.fetch(3);
     _elem_kind := res_mu_is2ns.fetch(4);
     _elem_prop := res_mu_is2ns.fetch(5);
     _elem_frag := res_mu_is2ns.fetch(6);
     var preNew_preOld := res_mu_is2ns.fetch(7);
     _attr_own := _attr_own002.leftjoin(preNew_preOld.reverse());
     _attr_iter   := _attr_iter002  ;
     _attr_qn     := _attr_qn002    ;
     _attr_prop   := _attr_prop002  ;
     _attr_frag   := _attr_frag002  ;
     _r_attr_iter := _r_attr_iter002;
     _r_attr_qn   := _r_attr_qn002  ;
     _r_attr_prop := _r_attr_prop002;
     _r_attr_frag := _r_attr_frag002;
    } # end of deleteResult_node2 ()
   } # end of item-sequence-to-node-sequence
   { # loop_liftedElemConstr (counter)
    var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
    iter_size := {count}(iter_size, iter001.tunique(), FALSE);
    var root_iter  := iter_size.hmark(0@0).chk_order();
    var root_size  := iter_size.tmark(0@0);
    var root_prop  := iter001.reverse().leftfetchjoin(item001);
    if (not(is_constant(root_prop))) {
     root_prop  := root_prop.tmark(0@0);
    }
    {
     var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
     _elem_iter  := merged_result.fetch(0);
     _elem_size  := merged_result.fetch(1);
     _elem_level := merged_result.fetch(2);
     _elem_kind  := merged_result.fetch(3);
     _elem_prop  := merged_result.fetch(4);
     _elem_frag  := merged_result.fetch(5);
     var preNew_preOld := merged_result.fetch(6);
     _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
     _attr_own := _attr_own.tmark(0@0);
    }
    { # create attribute root entries
     var root_item := _elem_level.ord_uselect(chr(0));
     root_item := root_item.hmark(0@0);
     var iter_item := iter001.reverse().leftfetchjoin(root_item);
     var attr_own := _r_attr_iter.leftjoin(iter_item);
     if (_r_attr_iter.count() != 0) { # test uniqueness
      var sorting := _r_attr_iter.tsort();
      sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
      var unq_attrs := sorting.tunique();
      if (unq_attrs.count() != _r_attr_iter.count()) {
       item001 := materialize(item001,ipik001);
       if (item001.count() > 0) {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item001.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
       } else {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
       }
      }
     } # end of test uniqueness
     if (_attr_iter.count() = 0) {
      _attr_iter := _r_attr_iter;
      _attr_qn   := _r_attr_qn;
      _attr_prop := _r_attr_prop;
      _attr_frag := _r_attr_frag;
      _attr_own  := attr_own.tmark(0@0);
     } else {
      var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
      _r_attr_iter := _r_attr_iter.tmark(seqb);
      _r_attr_qn   := _r_attr_qn  .tmark(seqb);
      _r_attr_prop := _r_attr_prop.tmark(seqb);
      _r_attr_frag := _r_attr_frag.tmark(seqb);
      attr_own := attr_own.tmark(seqb);
      _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
      _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
      _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
      _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
      _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
     }
     _r_attr_iter := empty_bat;
     _r_attr_qn   := empty_bat;
     _r_attr_prop := empty_bat;
     _r_attr_frag := empty_bat;
    } # end of create attribute root entries
    {
     var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
     var preOld_preNew := _elem_size.mark(seqb);
     _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
     _elem_size  := _elem_size.tmark(seqb);
     _elem_level := _elem_level.tmark(seqb);
     _elem_kind  := _elem_kind.tmark(seqb);
     _elem_prop  := _elem_prop.tmark(seqb);
     _elem_frag  := _elem_frag.tmark(seqb);
    }
    ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
    ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
    ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
    ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
    ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
    {
     var knd := ELEMENT;
     while ( knd <= DOCUMENT ) {
      var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
      ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
      if ( knd = ELEMENT ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
      }
      if ( knd = PI ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
      }
      knd :+= chr(1);
     }
    }
    var roots := _elem_level.ord_uselect(chr(0));
    roots := roots.hmark(0@0);
    {
     var height := int(_elem_level.max());
     ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
    }
    { # adding new fragments to the WS_FRAG bat
     var seqb := oid(count(ws.fetch(WS_FRAG)));
     var new_pres := roots.tmark(seqb);
     ws.fetch(WS_FRAG).insert(new_pres);
    }
    iter := iter001;
    item := roots;
    kind := ELEM;
    { # add attribute subtree copies to WS
     var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
     _attr_qn   := _attr_qn  .tmark(seqb);
     _attr_prop := _attr_prop.tmark(seqb);
     _attr_own  := _attr_own .tmark(seqb);
     _attr_frag := _attr_frag.tmark(seqb);
     ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
     ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
     ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
     ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
    } # end of add attribute subtree copies to WS
   } # end of loop_liftedElemConstr (counter)
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn677B6783_q02_xs_string1
PROC fn678383E3_q03_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q03
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761015@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "open_auction");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761008@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761016@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (b)
   var vid := v_vid001.ord_uselect(1303761016@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (b)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "bidder");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # insertVar (vid)
   var vid := project(ipik,1303761017@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (#pf:v_263)
   var vid := v_vid001.ord_uselect(1303761017@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (#pf:v_263)
  if (ipik.count() != 0) 
  { # for-translation
   # project ()
   iter := iter.materialize(ipik);
   var outer002 := iter;
   iter := iter.mark(1@0);
   var inner002 := iter;
   var loop002 := inner002;
   var v_vid002;
   var v_iter002;
   var v_item002;
   var v_kind002;
   var expOid;
   { # getExpanded (fid)
    var vu_nil := vu_fid.ord_uselect(1303761009@0);
    var vid_vu := vu_vid.reverse();
    var oid_nil := vid_vu.leftjoin(vu_nil);
    expOid := v_vid001.leftjoin(oid_nil);
    expOid := expOid.mirror();
   } # end of getExpanded (fid)
   if (expOid.count() != 0) {
    var oidNew_expOid;
    { # expand ()
     var expOid_iter := expOid.leftfetchjoin(v_iter001);
     var iter_expOid := expOid_iter.reverse();
     var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
     var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
     oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
     var expOid_oidMap := oidMap_expOid.reverse();
     expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
     v_iter002 := expOid_iter;
     oidNew_expOid := expOid_iter.hmark(0@0);
    } # end of expand ()
    # join ()
    var cnt := count(v_iter002)*2;
    v_iter002 := v_iter002.tmark(0@0);
    var new_v_iter := v_iter002;
    v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
    var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
    v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
    var new_v_pos ;
    var new_v_item := oidNew_expOid.leftjoin(v_item001);
    v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
    var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
    v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
   } else { # createNewVarTable ()
    v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
   }
   { # insertVar (vid)
    var vid := project(ipik,1303761018@0);
    { # append (vid, level)
     var seqb := oid(v_vid002.count());
     vid := vid.materialize(ipik);
     v_vid002 := v_vid002.insert(vid.tmark(seqb));
    } # append (vid, level)
    { # append (iter, level)
     var seqb := oid(v_iter002.count());
     iter := iter.materialize(ipik);
     v_iter002 := v_iter002.insert(iter.tmark(seqb));
    } # append (iter, level)
    { # append (pos, level)
     var seqb ;
    } # append (pos, level)
    { # append (item, level)
     var seqb := oid(v_item002.count());
     item := item.materialize(ipik);
     v_item002 := v_item002.insert(item.tmark(seqb));
    } # append (item, level)
    { # append (kind, level)
     var seqb := oid(v_kind002.count());
     kind := kind.materialize(ipik);
     v_kind002 := v_kind002.insert(kind.tmark(seqb));
    } # append (kind, level)
   } # end of insertVar (vid)
   { # createEnumeration ()
    var ints_cE := tmark_grp_unique(outer002, outer002).[lng]();
    item := int_values.addValues(ints_cE).tmark(0@0);
    iter := inner002.tmark(0@0);
    ipik := iter;
    kind := INT;
   } # end of createEnumeration ()
   { # insertVar (vid)
    var vid := project(ipik,1303761019@0);
    { # append (vid, level)
     var seqb := oid(v_vid002.count());
     vid := vid.materialize(ipik);
     v_vid002 := v_vid002.insert(vid.tmark(seqb));
    } # append (vid, level)
    { # append (iter, level)
     var seqb := oid(v_iter002.count());
     iter := iter.materialize(ipik);
     v_iter002 := v_iter002.insert(iter.tmark(seqb));
    } # append (iter, level)
    { # append (pos, level)
     var seqb ;
    } # append (pos, level)
    { # append (item, level)
     var seqb := oid(v_item002.count());
     item := item.materialize(ipik);
     v_item002 := v_item002.insert(item.tmark(seqb));
    } # append (item, level)
    { # append (kind, level)
     var seqb := oid(v_kind002.count());
     kind := kind.materialize(ipik);
     v_kind002 := v_kind002.insert(kind.tmark(seqb));
    } # append (kind, level)
   } # end of insertVar (vid)
   { # translateVar (#pf:v_263)
    var vid := v_vid002.ord_uselect(1303761017@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter002);
    ipik := iter;
   } # end of translateVar (#pf:v_263)
   { # translate fn:count (item*) as integer
    iter := iter.materialize(ipik);
    var iter_count := [lng]({count}(iter.reverse(),loop002.reverse(), FALSE)).tmark(0@0);
    item_int_ := iter_count;
   } # end of translate fn:count (item*) as integer
   { # saveResult1 () : int
    var item_int_001 := item_int_; # end of saveResult1 () : int
    { # translateVar (#pf:pos_275)
     var vid := v_vid002.ord_uselect(1303761019@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter002);
     item := vid.leftfetchjoin(v_item002);
    } # end of translateVar (#pf:pos_275)
    { # '=' calculation
     var val_snd := item.leftfetchjoin(int_values);
     var val_fst := item_int_001;
     val_fst := [=](val_fst,val_snd);
     item := val_fst.[oid]();
    } # end of '=' calculation
   } # end of deleteResult1 ()
   { # saveResult1 () : int
    var iter001 := iter;
    var item001 := item; # end of saveResult1 () : int
    { # ifthenelse-translation
     var selected;
     var skip;
     if (type(item001) = bat) {
      selected := item001.ord_uselect(1@0);
      var cnt := selected.count();
      if (item001.count() = cnt) {
       skip := 2;
      } else {
       skip := int(cnt = 0);
      }
     } else {
      skip := 1 + int(item001); # handle constants efficiently
     }
     { # translateIfThen
      var inner003 := inner002;
      var outer003 := outer002;
      var v_vid003 := v_vid002;
      var v_iter003 := v_iter002;
      var v_pos003 ;
      var v_item003 := v_item002;
      var v_kind003 := v_kind002;
      if (skip = 0) {
       iter := selected.mirror().join(iter001);
       iter := iter.tmark(0@0);
       outer003 := iter;
       iter := iter.mark(1@0);
       inner003 := iter;
       var expOid := v_iter003.mirror();
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter002);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
        v_iter003 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter003)*2;
       v_iter003 := v_iter003.tmark(0@0);
       var new_v_iter := v_iter003;
       v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
       v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item002);
       v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
       v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      }
      if (skip != 1) {
       { # translateVar (#pf:dot_274)
        var vid := v_vid003.ord_uselect(1303761018@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter003);
        item := vid.leftfetchjoin(v_item003);
        kind := vid.leftfetchjoin(v_kind003);
        ipik := iter;
       } # end of translateVar (#pf:dot_274)
      } else { # translateEmpty ()
       ipik := empty_bat;
       iter := empty_bat;
       item := empty_bat;
       kind := empty_kind_bat;
      }
      if (skip = 0) {
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
      } # cleanUpLevel ()
     } # end of translateIfThen
    } # end of ifthenelse-translation
   } # end of deleteResult1 ()
   { # mapBack ()
    var iter_oidMap := inner002.reverse();
    var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
    iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
    # kind := kind;
    # ipik := ipik;
   } # end of mapBack ()
   # cleanUpLevel ()
  } # end of for-translation
  { # translate pf:distinct-doc-order (node*) as node*
   var sorting;
   var simple := false;
   if (type(kind) != bat) {
    simple := (kind = ELEM);
   }
   if (not(simple)) {
    kind := kind.materialize(ipik);
    simple := (kind.count() = kind.get_type(ELEM).count());
   }
   if (simple) {
    sorting := iter.tsort();
    sorting := sorting.CTrefine(kind);
    sorting := sorting.CTrefine(item);
   } else { # cope also with attributes and sort them according to their owner
    var elements := kind.get_type(ELEM).mirror();
    var elem_iters := elements.leftfetchjoin(iter);
    var elem_items := elements.leftfetchjoin(item);
    var elem_frags := elements.leftfetchjoin(kind.get_fragment());
    var elem_attrs := elements.mark(nil);
    var attributes := kind.get_type(ATTR).mirror();
    var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
    var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
    var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
    var attr_key := attributes.hmark(0@0);
    var temp_attr := attr_attrs.tmark(0@0);
    var temp_frag := attr_frags.tmark(0@0);
    var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
    sorting := elem_iters.union(attr_iters).tsort();
    sorting := sorting.CTrefine(elem_frags.union(attr_frags));
    sorting := sorting.CTrefine(elem_items.union(attr_items));
    sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
   }
   ipik := sorting.reverse().{min}().tmark(0@0);
   iter := ipik.leftfetchjoin(iter);
   item := ipik.leftfetchjoin(item);
   kind := ipik.leftfetchjoin(kind);
  } # end of translate pf:distinct-doc-order (node*) as node*
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "increase");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  if (ipik.count() != 0) 
  { # for-translation
   # project ()
   iter := iter.materialize(ipik);
   var outer002 := iter;
   iter := iter.mark(1@0);
   var inner002 := iter;
   var loop002 := inner002;
   var v_vid002;
   var v_iter002;
   var v_item002;
   var v_kind002;
   var expOid;
   { # getExpanded (fid)
    var vu_nil := vu_fid.ord_uselect(1303761010@0);
    var vid_vu := vu_vid.reverse();
    var oid_nil := vid_vu.leftjoin(vu_nil);
    expOid := v_vid001.leftjoin(oid_nil);
    expOid := expOid.mirror();
   } # end of getExpanded (fid)
   if (expOid.count() != 0) {
    var oidNew_expOid;
    { # expand ()
     var expOid_iter := expOid.leftfetchjoin(v_iter001);
     var iter_expOid := expOid_iter.reverse();
     var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
     var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
     oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
     var expOid_oidMap := oidMap_expOid.reverse();
     expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
     v_iter002 := expOid_iter;
     oidNew_expOid := expOid_iter.hmark(0@0);
    } # end of expand ()
    # join ()
    var cnt := count(v_iter002)*2;
    v_iter002 := v_iter002.tmark(0@0);
    var new_v_iter := v_iter002;
    v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
    var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
    v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
    var new_v_pos ;
    var new_v_item := oidNew_expOid.leftjoin(v_item001);
    v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
    var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
    v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
   } else { # createNewVarTable ()
    v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
   }
   { # insertVar (vid)
    var vid := project(ipik,1303761020@0);
    { # append (vid, level)
     var seqb := oid(v_vid002.count());
     vid := vid.materialize(ipik);
     v_vid002 := v_vid002.insert(vid.tmark(seqb));
    } # append (vid, level)
    { # append (iter, level)
     var seqb := oid(v_iter002.count());
     iter := iter.materialize(ipik);
     v_iter002 := v_iter002.insert(iter.tmark(seqb));
    } # append (iter, level)
    { # append (pos, level)
     var seqb ;
    } # append (pos, level)
    { # append (item, level)
     var seqb := oid(v_item002.count());
     item := item.materialize(ipik);
     v_item002 := v_item002.insert(item.tmark(seqb));
    } # append (item, level)
    { # append (kind, level)
     var seqb := oid(v_kind002.count());
     kind := kind.materialize(ipik);
     v_kind002 := v_kind002.insert(kind.tmark(seqb));
    } # append (kind, level)
   } # end of insertVar (vid)
   {
    var iter001;
    var item001;
    var kind001;
    var ipik002;
    var iter002;
    var item002;
    var match_outer002;
    var ipik003;
    var iter003;
    var item003;
    var match_outer003;
    var jouter002 ;
    var jorder_002 ;
    var jinner002 ;
    var jloop002  ;
    var jv_vid002 ;
    var jv_iter002;
    var jv_pos002 ;
    var jv_item002;
    var jv_kind002;
    iter := loop002.tmark(0@0);
    ipik := iter;
    item_int_ := 1LL;
    match_outer002 := iter.leftfetchjoin(inner002.reverse()).leftfetchjoin(outer002);
    ipik002 := ipik;
    iter002 := iter;
    item002 := item_int_;
    jouter002  := outer002 ;
    jinner002  := inner002 ;
    jloop002   := loop002  ;
    jv_vid002  := v_vid002 ;
    jv_iter002 := v_iter002;
    jv_item002 := v_item002;
    jv_kind002 := v_kind002;
    v_vid002  := v_vid001 .copy().access(BAT_WRITE);
    v_iter002 := v_iter001.copy().access(BAT_WRITE);
    v_item002 := v_item001.copy().access(BAT_WRITE);
    v_kind002 := v_kind001.copy().access(BAT_WRITE);
    { # translateVar (b)
     var vid := v_vid002.ord_uselect(1303761016@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter002);
     item := vid.leftfetchjoin(v_item002);
     kind := vid.leftfetchjoin(v_kind002);
     ipik := iter;
    } # end of translateVar (b)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "bidder");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer003 := iter;
     iter := iter.mark(1@0);
     var inner003 := iter;
     var v_vid003;
     var v_iter003;
     var v_pos003;
     var v_item003;
     var v_kind003;
     iter001 := iter;
     item001 := item;
     kind001 := kind;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(1303761011@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid002.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter002);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
       v_iter003 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter003)*2;
      v_iter003 := v_iter003.tmark(0@0);
      var new_v_iter := v_iter003;
      v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
      v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item002);
      v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind ; # end of join ()
     } else { # createNewVarTable ()
      v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,1303761021@0);
      { # append (vid, level)
       var seqb := oid(v_vid003.count());
       vid := vid.materialize(ipik);
       v_vid003 := v_vid003.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter003.count());
       iter := iter.materialize(ipik);
       v_iter003 := v_iter003.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb ;
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item003.count());
       item := item.materialize(ipik);
       v_item003 := v_item003.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb ;
      } # append (kind, level)
     } # end of insertVar (vid)
     { # createEnumeration ()
      var ints_cE := tmark_grp_unique(outer003, outer003).[lng]();
      item := int_values.addValues(ints_cE).tmark(0@0);
      iter := inner003.tmark(0@0);
      ipik := iter;
     } # end of createEnumeration ()
     { # insertVar (vid)
      var vid := project(ipik,1303761022@0);
      { # append (vid, level)
       var seqb := oid(v_vid003.count());
       vid := vid.materialize(ipik);
       v_vid003 := v_vid003.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter003.count());
       iter := iter.materialize(ipik);
       v_iter003 := v_iter003.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb ;
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item003.count());
       item := item.materialize(ipik);
       v_item003 := v_item003.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb ;
      } # append (kind, level)
     } # end of insertVar (vid)
     { # translateVar (#pf:pos_216)
      var vid := v_vid003.ord_uselect(1303761022@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter003);
      item := vid.leftfetchjoin(v_item003);
      ipik := iter;
     } # end of translateVar (#pf:pos_216)
     ipik003 := ipik;
     iter003 := iter;
     item003 := item;
     match_outer003 := iter.leftfetchjoin(inner003.reverse()).leftfetchjoin(outer003); # cleanUpLevel ()
    } # end of for-translation
    outer002  := jouter002 ;
    inner002  := jinner002 ;
    loop002   := jloop002  ;
    v_vid002  := jv_vid002 ;
    v_iter002 := jv_iter002;
    v_item002 := jv_item002;
    v_kind002 := jv_kind002;
    var join_item1 := item002;
    var join_item2 := item003.leftfetchjoin(int_values);
    join_item1 := join_item1.materialize(ipik002);
    join_item1 := join_item1.reverse().leftfetchjoin(iter002).reverse();
    join_item2 := join_item2.materialize(ipik003);
    join_item2 := join_item2.reverse().leftfetchjoin(iter003).reverse();
    var join_result := ll_htordered_unique_thetajoin(EQ, join_item1, join_item2, match_outer002, match_outer003,nil,iter001.reverse());
    var snd_iter := join_result.tmark(0@0);
    var fst_iter := join_result.hmark(0@0);
    ipik := fst_iter; # order_fst isn't needed until now
    # (cannot be pushed below the theta-join due to the 'iter := fst_iter;' hereafter)
    # var order_fst := fst_iter.leftfetchjoin(inner002.reverse());
    var order_snd := snd_iter; #.leftfetchjoin(iter001.reverse()); pushed below theta-join
    # could also be pushed below theta-join, if order_snd wasn't needed for kind (below) ...
    item := order_snd.leftfetchjoin(item001);
    iter := fst_iter; # could also be pushed below theta-join, if order_snd wasn't needed for item (above) ...
    kind := order_snd.leftfetchjoin(kind001);
   } # end of evaluate_join
   { # translate pf:distinct-doc-order (node*) as node*
    var sorting;
    var simple := false;
    if (type(kind) != bat) {
     simple := (kind = ELEM);
    }
    if (not(simple)) {
     kind := kind.materialize(ipik);
     simple := (kind.count() = kind.get_type(ELEM).count());
    }
    if (simple) {
     sorting := iter.tsort();
     sorting := sorting.CTrefine(kind);
     sorting := sorting.CTrefine(item);
    } else { # cope also with attributes and sort them according to their owner
     var elements := kind.get_type(ELEM).mirror();
     var elem_iters := elements.leftfetchjoin(iter);
     var elem_items := elements.leftfetchjoin(item);
     var elem_frags := elements.leftfetchjoin(kind.get_fragment());
     var elem_attrs := elements.mark(nil);
     var attributes := kind.get_type(ATTR).mirror();
     var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
     var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
     var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
     var attr_key := attributes.hmark(0@0);
     var temp_attr := attr_attrs.tmark(0@0);
     var temp_frag := attr_frags.tmark(0@0);
     var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
     sorting := elem_iters.union(attr_iters).tsort();
     sorting := sorting.CTrefine(elem_frags.union(attr_frags));
     sorting := sorting.CTrefine(elem_items.union(attr_items));
     sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
    }
    ipik := sorting.reverse().{min}().tmark(0@0);
    iter := ipik.leftfetchjoin(iter);
    item := ipik.leftfetchjoin(item);
    kind := ipik.leftfetchjoin(kind);
   } # end of translate pf:distinct-doc-order (node*) as node*
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "increase");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   if (iter.tunique().count() != loop002.count()) {
    ERROR ("err:FORG0005: function fn:exactly-one expects exactly one value.");
   }
   { # string-value
    var input_iter := iter;
    kind := kind.materialize(ipik);
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    var kind_elem := kind.get_type(ELEM);
    var item_str;
    if (kind_elem.count() = kind.count()) {
     var frag := kind.get_fragment();
     var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
     var t_iter := res_scj.fetch(0);
     var t_item := res_scj.fetch(1);
     var t_frag := res_scj.fetch(2);
     var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
     var t_iter_unq := t_iter.tunique();
     t_iter := t_iter.materialize(t_item);
     if (t_iter_unq.count() != t_item.count()) {
      var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
      iter_item := iter_item.string_join(t_iter_unq.project(""));
      t_iter := iter_item.hmark(0@0);
      t_item_str := iter_item.tmark(0@0);
     }
     var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
     if (c_map.count() > 0) { #process comments 
      var c_iter := c_map.leftfetchjoin(iter);
      var c_item := c_map.leftfetchjoin(item);
      var c_frag := c_map.leftfetchjoin(frag);
      var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
      var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
     } # end of comment processing
     var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
     if (pi_map.count() > 0) { #process processing-instructions 
      var pi_iter := pi_map.leftfetchjoin(iter);
      var pi_item := pi_map.leftfetchjoin(item);
      var pi_frag := pi_map.leftfetchjoin(frag);
      var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
      var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
      t_item_str := res_mu.fetch(1);
     } # end of processing-instruction processing
     iter := t_iter;
     item_str := t_item_str;
    } else {
     var kind_attr := kind.get_type(ATTR);
     if (kind_attr.count() = kind.count()) {
      var frag := kind.get_fragment();
      item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
     } else {
      kind_attr := kind_attr.hmark(0@0);
      var item_attr := kind_attr.leftfetchjoin(item);
      var iter_attr := kind_attr.leftfetchjoin(iter);
      var frag := kind_attr.leftfetchjoin(kind).get_fragment();
      var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
      kind_elem := kind_elem.hmark(0@0);
      iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
      frag := kind_elem.leftfetchjoin(kind).get_fragment();
      item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
      var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
      var t_iter := res_scj.fetch(0);
      var t_item := res_scj.fetch(1);
      var t_frag := res_scj.fetch(2);
      var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
      var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
      t_iter := iter_item.hmark(0@0);
      t_item_str := iter_item.tmark(0@0);
      var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
      iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
      {
       var item_unq := iter_item.reverse().tunique();
       if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
      }
      t_iter := iter_item.hmark(0@0);
      var t_item_str := iter_item.tmark(0@0);
      var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
      if (c_map.count() > 0) { #process comments 
       var c_iter := c_map.leftfetchjoin(iter);
       var c_item := c_map.leftfetchjoin(item);
       var c_frag := c_map.leftfetchjoin(frag);
       var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
       var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of comment processing
      var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
      if (pi_map.count() > 0) { #process processing-instructions 
       var pi_iter := pi_map.leftfetchjoin(iter);
       var pi_item := pi_map.leftfetchjoin(item);
       var pi_frag := pi_map.leftfetchjoin(frag);
       var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
       var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of processing-instruction processing
      iter := t_iter;
      item_str := t_item_str;
     }
    }
    item_str_ := item_str;
    if (iter.count() != input_iter.tunique().count()) {
     var difference := reverse(input_iter.tdiff(iter));
     difference := difference.hmark(0@0);
     var res_mu := merged_union(iter, difference, item_str_, "");
     iter := res_mu.fetch(0);
     item_str_ := res_mu.fetch(1);
    }
   } # end of string-value
   { # cast from string to double
    var cast_val := item_str_.[dbl]();
    if (cast_val.texist(dbl(nil))) {
     ERROR ("err:FORG0001: could not cast value from string to double.");
    }
    item_dbl_ := cast_val;
    if (iter.count() != loop002.count()) {
     ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
    }
   } # end of cast from string to double
   { # saveResult1 () : int
    var item_dbl_001 := item_dbl_; # end of saveResult1 () : int
    iter := loop002.tmark(0@0);
    item_int_ := 2LL;
    { # cast from integer to double
     var cast_val := item_int_.[dbl]();
     if (cast_val.texist(dbl(nil))) {
      ERROR ("err:FORG0001: could not cast value from integer to double.");
     }
     item_dbl_ := cast_val;
     if (iter.count() != loop002.count()) {
      ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
     }
    } # end of cast from integer to double
    { # '*' calculation
     var val_snd := item_dbl_;
     var val_fst := item_dbl_001;
     val_fst := [*](val_fst,val_snd);
     item_dbl_ := val_fst;
    } # end of '*' calculation
   } # end of deleteResult1 ()
   { # saveResult1 () : int
    var item_dbl_001 := item_dbl_; # end of saveResult1 () : int
    { # translateVar (#pf:v_2790)
     var vid := v_vid002.ord_uselect(1303761020@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter002);
     item := vid.leftfetchjoin(v_item002);
     kind := vid.leftfetchjoin(v_kind002);
     ipik := iter;
    } # end of translateVar (#pf:v_2790)
    { # string-value
     var input_iter := iter;
     kind := kind.materialize(ipik);
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     var kind_elem := kind.get_type(ELEM);
     var item_str;
     if (kind_elem.count() = kind.count()) {
      var frag := kind.get_fragment();
      var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
      var t_iter := res_scj.fetch(0);
      var t_item := res_scj.fetch(1);
      var t_frag := res_scj.fetch(2);
      var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
      var t_iter_unq := t_iter.tunique();
      t_iter := t_iter.materialize(t_item);
      if (t_iter_unq.count() != t_item.count()) {
       var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       iter_item := iter_item.string_join(t_iter_unq.project(""));
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
      }
      var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
      if (c_map.count() > 0) { #process comments 
       var c_iter := c_map.leftfetchjoin(iter);
       var c_item := c_map.leftfetchjoin(item);
       var c_frag := c_map.leftfetchjoin(frag);
       var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
       var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of comment processing
      var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
      if (pi_map.count() > 0) { #process processing-instructions 
       var pi_iter := pi_map.leftfetchjoin(iter);
       var pi_item := pi_map.leftfetchjoin(item);
       var pi_frag := pi_map.leftfetchjoin(frag);
       var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
       var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
       t_item_str := res_mu.fetch(1);
      } # end of processing-instruction processing
      iter := t_iter;
      item_str := t_item_str;
     } else {
      var kind_attr := kind.get_type(ATTR);
      if (kind_attr.count() = kind.count()) {
       var frag := kind.get_fragment();
       item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
      } else {
       kind_attr := kind_attr.hmark(0@0);
       var item_attr := kind_attr.leftfetchjoin(item);
       var iter_attr := kind_attr.leftfetchjoin(iter);
       var frag := kind_attr.leftfetchjoin(kind).get_fragment();
       var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
       kind_elem := kind_elem.hmark(0@0);
       iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
       frag := kind_elem.leftfetchjoin(kind).get_fragment();
       item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
       var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
       var t_iter := res_scj.fetch(0);
       var t_item := res_scj.fetch(1);
       var t_frag := res_scj.fetch(2);
       var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
       var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
       iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       {
        var item_unq := iter_item.reverse().tunique();
        if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
       }
       t_iter := iter_item.hmark(0@0);
       var t_item_str := iter_item.tmark(0@0);
       var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
       if (c_map.count() > 0) { #process comments 
        var c_iter := c_map.leftfetchjoin(iter);
        var c_item := c_map.leftfetchjoin(item);
        var c_frag := c_map.leftfetchjoin(frag);
        var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
        var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of comment processing
       var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
       if (pi_map.count() > 0) { #process processing-instructions 
        var pi_iter := pi_map.leftfetchjoin(iter);
        var pi_item := pi_map.leftfetchjoin(item);
        var pi_frag := pi_map.leftfetchjoin(frag);
        var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
        var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of processing-instruction processing
       iter := t_iter;
       item_str := t_item_str;
      }
     }
     item_str_ := item_str;
     if (iter.count() != input_iter.tunique().count()) {
      var difference := reverse(input_iter.tdiff(iter));
      difference := difference.hmark(0@0);
      var res_mu := merged_union(iter, difference, item_str_, "");
      iter := res_mu.fetch(0);
      item_str_ := res_mu.fetch(1);
     }
    } # end of string-value
    { # cast from string to untypedAtomic
     if (iter.count() != loop002.count()) {
      ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
     }
    } # end of cast from string to untypedAtomic
    { # cast from untypedAtomic to double
     var cast_val := item_str_.[dbl]();
     if (cast_val.texist(dbl(nil))) {
      ERROR ("err:FORG0001: could not cast value from string to double.");
     }
     item_dbl_ := cast_val;
     if (iter.count() != loop002.count()) {
      ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
     }
    } # end of cast from untypedAtomic to double
    { # '<=' calculation
     var val_snd := item_dbl_;
     var val_fst := item_dbl_001;
     val_fst := [<=](val_fst,val_snd);
     item := val_fst.[oid]();
    } # end of '<=' calculation
   } # end of deleteResult1 ()
   { # saveResult1 () : int
    var iter001 := iter;
    var item001 := item; # end of saveResult1 () : int
    { # ifthenelse-translation
     var selected;
     var skip;
     if (type(item001) = bat) {
      selected := item001.ord_uselect(1@0);
      var cnt := selected.count();
      if (item001.count() = cnt) {
       skip := 2;
      } else {
       skip := int(cnt = 0);
      }
     } else {
      skip := 1 + int(item001); # handle constants efficiently
     }
     { # translateIfThen
      var loop003 := loop002;
      var inner003 := inner002;
      var outer003 := outer002;
      if (skip = 0) {
       iter := selected.mirror().join(iter001);
       iter := iter.tmark(0@0);
       outer003 := iter;
       iter := iter.mark(1@0);
       inner003 := iter;
       loop003 := inner003;
       var expOid ;
       var oidNew_expOid;
       { # expand ()
        var expOid_iter ;
        var iter_expOid ;
        var oidMap_expOid ; # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
        var temp_sort ;
        var expOid_oidMap ;
       } # end of expand ()
       # join ()
       var cnt ;
       var new_v_iter ;
       var new_v_vid ;
       var new_v_pos ;
       var new_v_item ;
       var new_v_kind ; # end of join ()
      }
      if (skip != 1) {
       {
        int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
        var itemID ; # translateConst (kind)
        iter := loop003.tmark(0@0);
       }
      } else {
       iter := empty_bat;
      }
      if (skip = 0) {
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
      } # cleanUpLevel ()
     } # end of translateIfThen
    } # end of ifthenelse-translation
   } # end of deleteResult1 ()
   { # mapBack ()
    var iter_oidMap := inner002.reverse();
    var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
    iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
    # kind := kind;
    # ipik := ipik;
   } # end of mapBack ()
   # cleanUpLevel ()
  } # end of for-translation
  { # translate fn:empty (item*) as boolean
   var iter_count := {count}(iter.reverse(),loop001.reverse(), FALSE);
   var iter_bool := iter_count.[=](0).[oid]();
   item := iter_bool.tmark(0@0);
   iter := loop001.tmark(0@0);
  } # end of translate fn:empty (item*) as boolean
  { # saveResult1 () : int
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # ifthenelse-translation
    var selected;
    var skip;
    if (type(item001) = bat) {
     selected := item001.ord_uselect(1@0);
     var cnt := selected.count();
     if (item001.count() = cnt) {
      skip := 2;
     } else {
      skip := int(cnt = 0);
     }
    } else {
     skip := 1 + int(item001); # handle constants efficiently
    }
    { # translateIfThen
     var loop002 := loop001;
     var inner002 := inner001;
     var outer002 := outer001;
     var v_vid002 := v_vid001;
     var v_iter002 := v_iter001;
     var v_item002 := v_item001;
     var v_kind002 := v_kind001;
     if (skip = 0) {
      selected := item001.ord_uselect(0@0);
      iter := selected.mirror().join(iter001);
      iter := iter.tmark(0@0);
      outer002 := iter;
      iter := iter.mark(1@0);
      inner002 := iter;
      loop002 := inner002;
      var expOid := v_iter002.mirror();
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     }
     if (skip != 2) {
      { # tagname-translation
       var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
       var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
       var itemID;
       if (prop_str.texist("increase")) {
        itemID := prop_str.reverse().find("increase");
       } else {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
        ws.fetch(QN_LOC).fetch(WS).insert(itemID,"increase");
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"increase"+str('\1')+"");
       } # translateConst (kind)
       iter := loop002.tmark(0@0);
       ipik := iter;
       item := itemID;
      } # end of tagname-translation
      { # saveResult2 () : int
       var ipik002 := ipik;
       var iter002 := iter;
       var item002 := item; # end of saveResult2 () : int
       { # tagname-translation
        var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
        var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
        var itemID;
        if (prop_str.texist("first")) {
         itemID := prop_str.reverse().find("first");
        } else {
         itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
         ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
         ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
         ws.fetch(QN_LOC).fetch(WS).insert(itemID,"first");
         ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
         ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"first"+str('\1')+"");
        } # translateConst (kind)
        iter := loop002.tmark(0@0);
        ipik := iter;
        item := itemID;
       } # end of tagname-translation
       { # saveResult3 () : int
        var ipik003 := ipik;
        var iter003 := iter;
        var item003 := item; # end of saveResult3 () : int
        {
         var iter004;
         var item004;
         var kind004;
         var ipik005;
         var iter005;
         var item005;
         var match_outer005;
         var ipik006;
         var iter006;
         var item006;
         var match_outer006;
         var jouter005 ;
         var jorder_005 ;
         var jinner005 ;
         var jloop005  ;
         var jv_vid005 ;
         var jv_iter005;
         var jv_pos005 ;
         var jv_item005;
         var jv_kind005;
         iter := loop002.tmark(0@0);
         ipik := iter;
         item_int_ := 1LL;
         match_outer005 := iter.leftfetchjoin(inner002.reverse()).leftfetchjoin(outer002);
         ipik005 := ipik;
         iter005 := iter;
         item005 := item_int_;
         jouter005  := outer002 ;
         jinner005  := inner002 ;
         jloop005   := loop002  ;
         jv_vid005  := v_vid002 ;
         jv_iter005 := v_iter002;
         jv_item005 := v_item002;
         jv_kind005 := v_kind002;
         v_vid002  := v_vid001 .copy().access(BAT_WRITE);
         v_iter002 := v_iter001.copy().access(BAT_WRITE);
         v_item002 := v_item001.copy().access(BAT_WRITE);
         v_kind002 := v_kind001.copy().access(BAT_WRITE);
         { # translateVar (b)
          var vid := v_vid002.ord_uselect(1303761016@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter002);
          item := vid.leftfetchjoin(v_item002);
          kind := vid.leftfetchjoin(v_kind002);
          ipik := iter;
         } # end of translateVar (b)
         { # translateLocsteps (c)
          var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "bidder");
          iter := res_scj.fetch(0);
          item := res_scj.fetch(1);
          kind := res_scj.fetch(2).set_kind(ELEM);
          ipik := item;
         } # end of translateLocsteps (c)
         { # for-translation
          # project ()
          iter := iter.materialize(ipik);
          var outer003 := iter;
          iter := iter.mark(1@0);
          var inner003 := iter;
          var v_vid003;
          var v_iter003;
          var v_pos003;
          var v_item003;
          var v_kind003;
          iter004 := iter;
          item004 := item;
          kind004 := kind;
          var expOid;
          { # getExpanded (fid)
           var vu_nil := vu_fid.ord_uselect(1303761013@0);
           var vid_vu := vu_vid.reverse();
           var oid_nil := vid_vu.leftjoin(vu_nil);
           expOid := v_vid002.leftjoin(oid_nil);
           expOid := expOid.mirror();
          } # end of getExpanded (fid)
          if (expOid.count() != 0) {
           var oidNew_expOid;
           { # expand ()
            var expOid_iter := expOid.leftfetchjoin(v_iter002);
            var iter_expOid := expOid_iter.reverse();
            var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
            var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
            oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
            var expOid_oidMap := oidMap_expOid.reverse();
            expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
            v_iter003 := expOid_iter;
            oidNew_expOid := expOid_iter.hmark(0@0);
           } # end of expand ()
           # join ()
           var cnt := count(v_iter003)*2;
           v_iter003 := v_iter003.tmark(0@0);
           var new_v_iter := v_iter003;
           v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
           var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
           v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
           var new_v_pos ;
           var new_v_item := oidNew_expOid.leftjoin(v_item002);
           v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
           var new_v_kind ; # end of join ()
          } else { # createNewVarTable ()
           v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          }
          { # insertVar (vid)
           var vid := project(ipik,1303761023@0);
           { # append (vid, level)
            var seqb := oid(v_vid003.count());
            vid := vid.materialize(ipik);
            v_vid003 := v_vid003.insert(vid.tmark(seqb));
           } # append (vid, level)
           { # append (iter, level)
            var seqb := oid(v_iter003.count());
            iter := iter.materialize(ipik);
            v_iter003 := v_iter003.insert(iter.tmark(seqb));
           } # append (iter, level)
           { # append (pos, level)
            var seqb ;
           } # append (pos, level)
           { # append (item, level)
            var seqb := oid(v_item003.count());
            item := item.materialize(ipik);
            v_item003 := v_item003.insert(item.tmark(seqb));
           } # append (item, level)
           { # append (kind, level)
            var seqb ;
           } # append (kind, level)
          } # end of insertVar (vid)
          { # createEnumeration ()
           var ints_cE := tmark_grp_unique(outer003, outer003).[lng]();
           item := int_values.addValues(ints_cE).tmark(0@0);
           iter := inner003.tmark(0@0);
           ipik := iter;
          } # end of createEnumeration ()
          { # insertVar (vid)
           var vid := project(ipik,1303761024@0);
           { # append (vid, level)
            var seqb := oid(v_vid003.count());
            vid := vid.materialize(ipik);
            v_vid003 := v_vid003.insert(vid.tmark(seqb));
           } # append (vid, level)
           { # append (iter, level)
            var seqb := oid(v_iter003.count());
            iter := iter.materialize(ipik);
            v_iter003 := v_iter003.insert(iter.tmark(seqb));
           } # append (iter, level)
           { # append (pos, level)
            var seqb ;
           } # append (pos, level)
           { # append (item, level)
            var seqb := oid(v_item003.count());
            item := item.materialize(ipik);
            v_item003 := v_item003.insert(item.tmark(seqb));
           } # append (item, level)
           { # append (kind, level)
            var seqb ;
           } # append (kind, level)
          } # end of insertVar (vid)
          { # translateVar (#pf:pos_359)
           var vid := v_vid003.ord_uselect(1303761024@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter003);
           item := vid.leftfetchjoin(v_item003);
           ipik := iter;
          } # end of translateVar (#pf:pos_359)
          ipik006 := ipik;
          iter006 := iter;
          item006 := item;
          match_outer006 := iter.leftfetchjoin(inner003.reverse()).leftfetchjoin(outer003); # cleanUpLevel ()
         } # end of for-translation
         outer002  := jouter005 ;
         inner002  := jinner005 ;
         loop002   := jloop005  ;
         v_vid002  := jv_vid005 ;
         v_iter002 := jv_iter005;
         v_item002 := jv_item005;
         v_kind002 := jv_kind005;
         var join_item1 := item005;
         var join_item2 := item006.leftfetchjoin(int_values);
         join_item1 := join_item1.materialize(ipik005);
         join_item1 := join_item1.reverse().leftfetchjoin(iter005).reverse();
         join_item2 := join_item2.materialize(ipik006);
         join_item2 := join_item2.reverse().leftfetchjoin(iter006).reverse();
         var join_result := ll_htordered_unique_thetajoin(EQ, join_item1, join_item2, match_outer005, match_outer006,nil,iter004.reverse());
         var snd_iter := join_result.tmark(0@0);
         var fst_iter := join_result.hmark(0@0);
         ipik := fst_iter; # order_fst isn't needed until now
         # (cannot be pushed below the theta-join due to the 'iter := fst_iter;' hereafter)
         # var order_fst := fst_iter.leftfetchjoin(inner002.reverse());
         var order_snd := snd_iter; #.leftfetchjoin(iter004.reverse()); pushed below theta-join
         # could also be pushed below theta-join, if order_snd wasn't needed for kind (below) ...
         item := order_snd.leftfetchjoin(item004);
         iter := fst_iter; # could also be pushed below theta-join, if order_snd wasn't needed for item (above) ...
         kind := order_snd.leftfetchjoin(kind004);
        } # end of evaluate_join
        { # translate pf:distinct-doc-order (node*) as node*
         var sorting;
         var simple := false;
         if (type(kind) != bat) {
          simple := (kind = ELEM);
         }
         if (not(simple)) {
          kind := kind.materialize(ipik);
          simple := (kind.count() = kind.get_type(ELEM).count());
         }
         if (simple) {
          sorting := iter.tsort();
          sorting := sorting.CTrefine(kind);
          sorting := sorting.CTrefine(item);
         } else { # cope also with attributes and sort them according to their owner
          var elements := kind.get_type(ELEM).mirror();
          var elem_iters := elements.leftfetchjoin(iter);
          var elem_items := elements.leftfetchjoin(item);
          var elem_frags := elements.leftfetchjoin(kind.get_fragment());
          var elem_attrs := elements.mark(nil);
          var attributes := kind.get_type(ATTR).mirror();
          var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
          var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
          var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
          var attr_key := attributes.hmark(0@0);
          var temp_attr := attr_attrs.tmark(0@0);
          var temp_frag := attr_frags.tmark(0@0);
          var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
          sorting := elem_iters.union(attr_iters).tsort();
          sorting := sorting.CTrefine(elem_frags.union(attr_frags));
          sorting := sorting.CTrefine(elem_items.union(attr_items));
          sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
         }
         ipik := sorting.reverse().{min}().tmark(0@0);
         iter := ipik.leftfetchjoin(iter);
         item := ipik.leftfetchjoin(item);
         kind := ipik.leftfetchjoin(kind);
        } # end of translate pf:distinct-doc-order (node*) as node*
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "increase");
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        if (ipik.count() != 0) 
        { # for-translation
         # project ()
         iter := iter.materialize(ipik);
         var outer003 := iter;
         iter := iter.mark(1@0);
         var inner003 := iter;
         var v_vid003;
         var v_iter003;
         var v_item003;
         var v_kind003;
         var expOid;
         { # getExpanded (fid)
          var vu_nil := vu_fid.ord_uselect(1303761015@0);
          var vid_vu := vu_vid.reverse();
          var oid_nil := vid_vu.leftjoin(vu_nil);
          expOid := v_vid002.leftjoin(oid_nil);
          expOid := expOid.mirror();
         } # end of getExpanded (fid)
         if (expOid.count() != 0) {
          var oidNew_expOid;
          { # expand ()
           var expOid_iter := expOid.leftfetchjoin(v_iter002);
           var iter_expOid := expOid_iter.reverse();
           var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
           var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
           oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
           var expOid_oidMap := oidMap_expOid.reverse();
           expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
           v_iter003 := expOid_iter;
           oidNew_expOid := expOid_iter.hmark(0@0);
          } # end of expand ()
          # join ()
          var cnt := count(v_iter003)*2;
          v_iter003 := v_iter003.tmark(0@0);
          var new_v_iter := v_iter003;
          v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
          var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
          v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
          var new_v_pos ;
          var new_v_item := oidNew_expOid.leftjoin(v_item002);
          v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
          var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
          v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
         } else { # createNewVarTable ()
          v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
         }
         { # insertVar (vid)
          var vid := project(ipik,1303761025@0);
          { # append (vid, level)
           var seqb := oid(v_vid003.count());
           vid := vid.materialize(ipik);
           v_vid003 := v_vid003.insert(vid.tmark(seqb));
          } # append (vid, level)
          { # append (iter, level)
           var seqb := oid(v_iter003.count());
           iter := iter.materialize(ipik);
           v_iter003 := v_iter003.insert(iter.tmark(seqb));
          } # append (iter, level)
          { # append (pos, level)
           var seqb ;
          } # append (pos, level)
          { # append (item, level)
           var seqb := oid(v_item003.count());
           item := item.materialize(ipik);
           v_item003 := v_item003.insert(item.tmark(seqb));
          } # append (item, level)
          { # append (kind, level)
           var seqb := oid(v_kind003.count());
           kind := kind.materialize(ipik);
           v_kind003 := v_kind003.insert(kind.tmark(seqb));
          } # append (kind, level)
         } # end of insertVar (vid)
         { # translateVar (#pf:v_389)
          var vid := v_vid003.ord_uselect(1303761025@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter003);
          item := vid.leftfetchjoin(v_item003);
          kind := vid.leftfetchjoin(v_kind003);
          ipik := iter;
         } # end of translateVar (#pf:v_389)
         { # string-value
          var input_iter := iter;
          kind := kind.materialize(ipik);
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          var kind_elem := kind.get_type(ELEM);
          var item_str;
          if (kind_elem.count() = kind.count()) {
           var frag := kind.get_fragment();
           var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
           var t_iter := res_scj.fetch(0);
           var t_item := res_scj.fetch(1);
           var t_frag := res_scj.fetch(2);
           var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
           var t_iter_unq := t_iter.tunique();
           t_iter := t_iter.materialize(t_item);
           if (t_iter_unq.count() != t_item.count()) {
            var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            iter_item := iter_item.string_join(t_iter_unq.project(""));
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
           }
           var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
           if (c_map.count() > 0) { #process comments 
            var c_iter := c_map.leftfetchjoin(iter);
            var c_item := c_map.leftfetchjoin(item);
            var c_frag := c_map.leftfetchjoin(frag);
            var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
            var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
           } # end of comment processing
           var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
           if (pi_map.count() > 0) { #process processing-instructions 
            var pi_iter := pi_map.leftfetchjoin(iter);
            var pi_item := pi_map.leftfetchjoin(item);
            var pi_frag := pi_map.leftfetchjoin(frag);
            var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
            var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
            t_item_str := res_mu.fetch(1);
           } # end of processing-instruction processing
           iter := t_iter;
           item_str := t_item_str;
          } else {
           var kind_attr := kind.get_type(ATTR);
           if (kind_attr.count() = kind.count()) {
            var frag := kind.get_fragment();
            item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
           } else {
            kind_attr := kind_attr.hmark(0@0);
            var item_attr := kind_attr.leftfetchjoin(item);
            var iter_attr := kind_attr.leftfetchjoin(iter);
            var frag := kind_attr.leftfetchjoin(kind).get_fragment();
            var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
            kind_elem := kind_elem.hmark(0@0);
            iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
            frag := kind_elem.leftfetchjoin(kind).get_fragment();
            item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
            var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
            var t_iter := res_scj.fetch(0);
            var t_item := res_scj.fetch(1);
            var t_frag := res_scj.fetch(2);
            var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
            var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
            var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
            iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            {
             var item_unq := iter_item.reverse().tunique();
             if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
            }
            t_iter := iter_item.hmark(0@0);
            var t_item_str := iter_item.tmark(0@0);
            var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
            if (c_map.count() > 0) { #process comments 
             var c_iter := c_map.leftfetchjoin(iter);
             var c_item := c_map.leftfetchjoin(item);
             var c_frag := c_map.leftfetchjoin(frag);
             var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
             var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of comment processing
            var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
            if (pi_map.count() > 0) { #process processing-instructions 
             var pi_iter := pi_map.leftfetchjoin(iter);
             var pi_item := pi_map.leftfetchjoin(item);
             var pi_frag := pi_map.leftfetchjoin(frag);
             var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
             var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of processing-instruction processing
            iter := t_iter;
            item_str := t_item_str;
           }
          }
          item_str_ := item_str;
          if (iter.count() != input_iter.tunique().count()) {
           var difference := reverse(input_iter.tdiff(iter));
           difference := difference.hmark(0@0);
           var res_mu := merged_union(iter, difference, item_str_, "");
           iter := res_mu.fetch(0);
           item_str_ := res_mu.fetch(1);
          }
          ipik := iter;
         } # end of string-value
         { # mapBack ()
          var iter_oidMap := inner003.reverse();
          var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
          iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
          # kind := kind;
          # ipik := ipik;
         } # end of mapBack ()
         # cleanUpLevel ()
        } # end of for-translation
        { # saveResult4 () : int
         var ipik004 := ipik;
         var iter004 := iter;
         var item_str_004 := item_str_; # end of saveResult4 () : int
         iter := loop002.tmark(0@0);
         ipik := iter;
         item_str_ := " ";
         { # string-join (string*, string)
          var iter_item_str := iter004.materialize(ipik004).reverse();
          iter_item_str := iter_item_str.leftfetchjoin(item_str_004).materialize(iter_item_str).chk_order();
          var iter_sep_str := iter.materialize(ipik).reverse();
          iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
          iter_item_str := string_join(iter_item_str, iter_sep_str);
          iter := iter_item_str.hmark(0@0);
          iter_item_str := iter_item_str.tmark(0@0);
          item_str_ := iter_item_str;
         } # end of string-join (string*, string)
        } # end of deleteResult4 ()
        { # loop_liftedAttrConstr (int i)
         if (iter003.count() != loop002.count()) {
          ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
         }
         if (iter.count() != loop002.count()) {
          var difference := reverse(loop002.tdiff(iter));
          difference := difference.hmark(0@0);
          var res_mu := merged_union(iter, difference, item_str_, "");
          item_str_ := res_mu.fetch(1);
         }
         var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
         var unq := item_str_.tunique().hmark(0@0);
         var unq_str := unq;
         var str_unq := reverse(unq_str.tdiff(ws_prop_val));
         var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
         unq_str := str_unq.hmark(seqb);
         ws_prop_val := ws_prop_val.insert(unq_str);
         var strings := item_str_.materialize(loop002);
         var attr_oid := strings.leftjoin(ws_prop_val.reverse());
         { # translateEmpty_node ()
          _elem_iter  := empty_bat;
          _elem_size  := empty_bat.project(int(nil));
          _elem_level := empty_bat.project(chr(nil));
          _elem_kind  := empty_bat.project(chr(nil));
          _elem_prop  := empty_bat;
          _elem_frag  := empty_bat;
          _attr_iter  := empty_bat;
          _attr_qn    := empty_bat;
          _attr_prop  := empty_bat;
          _attr_frag  := empty_bat;
          _attr_own   := empty_bat;
         } # end of translateEmpty_node ()
         attr_oid := attr_oid.tmark(0@0);
         _r_attr_iter := iter003;
         _r_attr_qn   := item003.materialize(ipik003);
         _r_attr_prop := attr_oid;
         _r_attr_frag := attr_oid.project(WS);
        } # end of loop_liftedAttrConstr (int i)
       } # end of deleteResult3 ()
       { # saveResult_node3 () : int
        var _elem_iter003   := _elem_iter  ;
        var _elem_size003   := _elem_size  ;
        var _elem_level003  := _elem_level ;
        var _elem_kind003   := _elem_kind  ;
        var _elem_prop003   := _elem_prop  ;
        var _elem_frag003   := _elem_frag  ;
        var _attr_iter003   := _attr_iter  ;
        var _attr_qn003     := _attr_qn    ;
        var _attr_prop003   := _attr_prop  ;
        var _attr_frag003   := _attr_frag  ;
        var _attr_own003    := _attr_own   ;
        var _r_attr_iter003 := _r_attr_iter;
        var _r_attr_qn003   := _r_attr_qn  ;
        var _r_attr_prop003 := _r_attr_prop;
        var _r_attr_frag003 := _r_attr_frag; # end of saveResult_node3 () : int
        { # tagname-translation
         var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
         var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
         var itemID;
         if (prop_str.texist("last")) {
          itemID := prop_str.reverse().find("last");
         } else {
          itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
          ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
          ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
          ws.fetch(QN_LOC).fetch(WS).insert(itemID,"last");
          ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
          ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"last"+str('\1')+"");
         } # translateConst (kind)
         iter := loop002.tmark(0@0);
         ipik := iter;
         item := itemID;
        } # end of tagname-translation
        { # saveResult4 () : int
         var ipik004 := ipik;
         var iter004 := iter;
         var item004 := item; # end of saveResult4 () : int
         { # translateVar (b)
          var vid := v_vid002.ord_uselect(1303761016@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter002);
          item := vid.leftfetchjoin(v_item002);
          kind := vid.leftfetchjoin(v_kind002);
          ipik := iter;
         } # end of translateVar (b)
         { # translateLocsteps (c)
          var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "bidder");
          iter := res_scj.fetch(0);
          item := res_scj.fetch(1);
          kind := res_scj.fetch(2).set_kind(ELEM);
          ipik := item;
         } # end of translateLocsteps (c)
         { # insertVar (vid)
          var vid := project(ipik,1303761026@0);
          { # append (vid, level)
           var seqb := oid(v_vid002.count());
           vid := vid.materialize(ipik);
           v_vid002 := v_vid002.insert(vid.tmark(seqb));
          } # append (vid, level)
          { # append (iter, level)
           var seqb := oid(v_iter002.count());
           iter := iter.materialize(ipik);
           v_iter002 := v_iter002.insert(iter.tmark(seqb));
          } # append (iter, level)
          { # append (pos, level)
           var seqb ;
          } # append (pos, level)
          { # append (item, level)
           var seqb := oid(v_item002.count());
           item := item.materialize(ipik);
           v_item002 := v_item002.insert(item.tmark(seqb));
          } # append (item, level)
          { # append (kind, level)
           var seqb := oid(v_kind002.count());
           kind := kind.materialize(ipik);
           v_kind002 := v_kind002.insert(kind.tmark(seqb));
          } # append (kind, level)
         } # end of insertVar (vid)
         { # translateVar (#pf:v_405)
          var vid := v_vid002.ord_uselect(1303761026@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter002);
          item := vid.leftfetchjoin(v_item002);
          kind := vid.leftfetchjoin(v_kind002);
          ipik := iter;
         } # end of translateVar (#pf:v_405)
         if (ipik.count() != 0) 
         { # for-translation
          # project ()
          iter := iter.materialize(ipik);
          var outer003 := iter;
          iter := iter.mark(1@0);
          var inner003 := iter;
          var loop003 := inner003;
          var v_vid003;
          var v_iter003;
          var v_item003;
          var v_kind003;
          var expOid;
          { # getExpanded (fid)
           var vu_nil := vu_fid.ord_uselect(1303761016@0);
           var vid_vu := vu_vid.reverse();
           var oid_nil := vid_vu.leftjoin(vu_nil);
           expOid := v_vid002.leftjoin(oid_nil);
           expOid := expOid.mirror();
          } # end of getExpanded (fid)
          if (expOid.count() != 0) {
           var oidNew_expOid;
           { # expand ()
            var expOid_iter := expOid.leftfetchjoin(v_iter002);
            var iter_expOid := expOid_iter.reverse();
            var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
            var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
            oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
            var expOid_oidMap := oidMap_expOid.reverse();
            expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
            v_iter003 := expOid_iter;
            oidNew_expOid := expOid_iter.hmark(0@0);
           } # end of expand ()
           # join ()
           var cnt := count(v_iter003)*2;
           v_iter003 := v_iter003.tmark(0@0);
           var new_v_iter := v_iter003;
           v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
           var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
           v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
           var new_v_pos ;
           var new_v_item := oidNew_expOid.leftjoin(v_item002);
           v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
           var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
           v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
          } else { # createNewVarTable ()
           v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
          }
          { # insertVar (vid)
           var vid := project(ipik,1303761027@0);
           { # append (vid, level)
            var seqb := oid(v_vid003.count());
            vid := vid.materialize(ipik);
            v_vid003 := v_vid003.insert(vid.tmark(seqb));
           } # append (vid, level)
           { # append (iter, level)
            var seqb := oid(v_iter003.count());
            iter := iter.materialize(ipik);
            v_iter003 := v_iter003.insert(iter.tmark(seqb));
           } # append (iter, level)
           { # append (pos, level)
            var seqb ;
           } # append (pos, level)
           { # append (item, level)
            var seqb := oid(v_item003.count());
            item := item.materialize(ipik);
            v_item003 := v_item003.insert(item.tmark(seqb));
           } # append (item, level)
           { # append (kind, level)
            var seqb := oid(v_kind003.count());
            kind := kind.materialize(ipik);
            v_kind003 := v_kind003.insert(kind.tmark(seqb));
           } # append (kind, level)
          } # end of insertVar (vid)
          { # createEnumeration ()
           var ints_cE := tmark_grp_unique(outer003, outer003).[lng]();
           item := int_values.addValues(ints_cE).tmark(0@0);
           iter := inner003.tmark(0@0);
           ipik := iter;
           kind := INT;
          } # end of createEnumeration ()
          { # insertVar (vid)
           var vid := project(ipik,1303761028@0);
           { # append (vid, level)
            var seqb := oid(v_vid003.count());
            vid := vid.materialize(ipik);
            v_vid003 := v_vid003.insert(vid.tmark(seqb));
           } # append (vid, level)
           { # append (iter, level)
            var seqb := oid(v_iter003.count());
            iter := iter.materialize(ipik);
            v_iter003 := v_iter003.insert(iter.tmark(seqb));
           } # append (iter, level)
           { # append (pos, level)
            var seqb ;
           } # append (pos, level)
           { # append (item, level)
            var seqb := oid(v_item003.count());
            item := item.materialize(ipik);
            v_item003 := v_item003.insert(item.tmark(seqb));
           } # append (item, level)
           { # append (kind, level)
            var seqb := oid(v_kind003.count());
            kind := kind.materialize(ipik);
            v_kind003 := v_kind003.insert(kind.tmark(seqb));
           } # append (kind, level)
          } # end of insertVar (vid)
          { # translateVar (#pf:v_405)
           var vid := v_vid003.ord_uselect(1303761026@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter003);
           ipik := iter;
          } # end of translateVar (#pf:v_405)
          { # translate fn:count (item*) as integer
           iter := iter.materialize(ipik);
           var iter_count := [lng]({count}(iter.reverse(),loop003.reverse(), FALSE)).tmark(0@0);
           item_int_ := iter_count;
          } # end of translate fn:count (item*) as integer
          { # saveResult5 () : int
           var item_int_005 := item_int_; # end of saveResult5 () : int
           { # translateVar (#pf:pos_417)
            var vid := v_vid003.ord_uselect(1303761028@0);
            vid := vid.hmark(0@0);
            iter := vid.leftfetchjoin(v_iter003);
            item := vid.leftfetchjoin(v_item003);
           } # end of translateVar (#pf:pos_417)
           { # '=' calculation
            var val_snd := item.leftfetchjoin(int_values);
            var val_fst := item_int_005;
            val_fst := [=](val_fst,val_snd);
            item := val_fst.[oid]();
           } # end of '=' calculation
          } # end of deleteResult5 ()
          { # saveResult5 () : int
           var iter005 := iter;
           var item005 := item; # end of saveResult5 () : int
           { # ifthenelse-translation
            var selected;
            var skip;
            if (type(item005) = bat) {
             selected := item005.ord_uselect(1@0);
             var cnt := selected.count();
             if (item005.count() = cnt) {
              skip := 2;
             } else {
              skip := int(cnt = 0);
             }
            } else {
             skip := 1 + int(item005); # handle constants efficiently
            }
            { # translateIfThen
             var inner004 := inner003;
             var outer004 := outer003;
             var v_vid004 := v_vid003;
             var v_iter004 := v_iter003;
             var v_pos004 ;
             var v_item004 := v_item003;
             var v_kind004 := v_kind003;
             if (skip = 0) {
              iter := selected.mirror().join(iter005);
              iter := iter.tmark(0@0);
              outer004 := iter;
              iter := iter.mark(1@0);
              inner004 := iter;
              var expOid := v_iter004.mirror();
              var oidNew_expOid;
              { # expand ()
               var expOid_iter := expOid.leftfetchjoin(v_iter003);
               var iter_expOid := expOid_iter.reverse();
               var oidMap_expOid := outer004.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
               var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
               oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
               var expOid_oidMap := oidMap_expOid.reverse();
               expOid_iter := expOid_oidMap.leftfetchjoin(inner004);
               v_iter004 := expOid_iter;
               oidNew_expOid := expOid_iter.hmark(0@0);
              } # end of expand ()
              # join ()
              var cnt := count(v_iter004)*2;
              v_iter004 := v_iter004.tmark(0@0);
              var new_v_iter := v_iter004;
              v_iter004 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
              var new_v_vid := oidNew_expOid.leftjoin(v_vid003);
              v_vid004 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
              var new_v_pos ;
              var new_v_item := oidNew_expOid.leftjoin(v_item003);
              v_item004 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
              var new_v_kind := oidNew_expOid.leftjoin(v_kind003);
              v_kind004 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
             }
             if (skip != 1) {
              { # translateVar (#pf:dot_416)
               var vid := v_vid004.ord_uselect(1303761027@0);
               vid := vid.hmark(0@0);
               iter := vid.leftfetchjoin(v_iter004);
               item := vid.leftfetchjoin(v_item004);
               kind := vid.leftfetchjoin(v_kind004);
               ipik := iter;
              } # end of translateVar (#pf:dot_416)
             } else { # translateEmpty ()
              ipik := empty_bat;
              iter := empty_bat;
              item := empty_bat;
              kind := empty_kind_bat;
             }
             if (skip = 0) {
              { # mapBack ()
               var iter_oidMap := inner004.reverse();
               var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
               iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
               # kind := kind;
               # ipik := ipik;
              } # end of mapBack ()
             } # cleanUpLevel ()
            } # end of translateIfThen
           } # end of ifthenelse-translation
          } # end of deleteResult5 ()
          { # mapBack ()
           var iter_oidMap := inner003.reverse();
           var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
           iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
           # kind := kind;
           # ipik := ipik;
          } # end of mapBack ()
          # cleanUpLevel ()
         } # end of for-translation
         { # translate pf:distinct-doc-order (node*) as node*
          var sorting;
          var simple := false;
          if (type(kind) != bat) {
           simple := (kind = ELEM);
          }
          if (not(simple)) {
           kind := kind.materialize(ipik);
           simple := (kind.count() = kind.get_type(ELEM).count());
          }
          if (simple) {
           sorting := iter.tsort();
           sorting := sorting.CTrefine(kind);
           sorting := sorting.CTrefine(item);
          } else { # cope also with attributes and sort them according to their owner
           var elements := kind.get_type(ELEM).mirror();
           var elem_iters := elements.leftfetchjoin(iter);
           var elem_items := elements.leftfetchjoin(item);
           var elem_frags := elements.leftfetchjoin(kind.get_fragment());
           var elem_attrs := elements.mark(nil);
           var attributes := kind.get_type(ATTR).mirror();
           var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
           var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
           var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
           var attr_key := attributes.hmark(0@0);
           var temp_attr := attr_attrs.tmark(0@0);
           var temp_frag := attr_frags.tmark(0@0);
           var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
           sorting := elem_iters.union(attr_iters).tsort();
           sorting := sorting.CTrefine(elem_frags.union(attr_frags));
           sorting := sorting.CTrefine(elem_items.union(attr_items));
           sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
          }
          ipik := sorting.reverse().{min}().tmark(0@0);
          iter := ipik.leftfetchjoin(iter);
          item := ipik.leftfetchjoin(item);
          kind := ipik.leftfetchjoin(kind);
         } # end of translate pf:distinct-doc-order (node*) as node*
         { # translateLocsteps (c)
          var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "increase");
          iter := res_scj.fetch(0);
          item := res_scj.fetch(1);
          kind := res_scj.fetch(2).set_kind(ELEM);
          ipik := item;
         } # end of translateLocsteps (c)
         { # translateLocsteps (c)
          var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
          iter := res_scj.fetch(0);
          item := res_scj.fetch(1);
          kind := res_scj.fetch(2).set_kind(ELEM);
          ipik := item;
         } # end of translateLocsteps (c)
         if (ipik.count() != 0) 
         { # for-translation
          # project ()
          iter := iter.materialize(ipik);
          var outer003 := iter;
          iter := iter.mark(1@0);
          var inner003 := iter;
          var v_vid003;
          var v_iter003;
          var v_item003;
          var v_kind003;
          var expOid;
          { # getExpanded (fid)
           var vu_nil := vu_fid.ord_uselect(1303761017@0);
           var vid_vu := vu_vid.reverse();
           var oid_nil := vid_vu.leftjoin(vu_nil);
           expOid := v_vid002.leftjoin(oid_nil);
           expOid := expOid.mirror();
          } # end of getExpanded (fid)
          if (expOid.count() != 0) {
           var oidNew_expOid;
           { # expand ()
            var expOid_iter := expOid.leftfetchjoin(v_iter002);
            var iter_expOid := expOid_iter.reverse();
            var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
            var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
            oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
            var expOid_oidMap := oidMap_expOid.reverse();
            expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
            v_iter003 := expOid_iter;
            oidNew_expOid := expOid_iter.hmark(0@0);
           } # end of expand ()
           # join ()
           var cnt := count(v_iter003)*2;
           v_iter003 := v_iter003.tmark(0@0);
           var new_v_iter := v_iter003;
           v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
           var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
           v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
           var new_v_pos ;
           var new_v_item := oidNew_expOid.leftjoin(v_item002);
           v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
           var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
           v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
          } else { # createNewVarTable ()
           v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
          }
          { # insertVar (vid)
           var vid := project(ipik,1303761029@0);
           { # append (vid, level)
            var seqb := oid(v_vid003.count());
            vid := vid.materialize(ipik);
            v_vid003 := v_vid003.insert(vid.tmark(seqb));
           } # append (vid, level)
           { # append (iter, level)
            var seqb := oid(v_iter003.count());
            iter := iter.materialize(ipik);
            v_iter003 := v_iter003.insert(iter.tmark(seqb));
           } # append (iter, level)
           { # append (pos, level)
            var seqb ;
           } # append (pos, level)
           { # append (item, level)
            var seqb := oid(v_item003.count());
            item := item.materialize(ipik);
            v_item003 := v_item003.insert(item.tmark(seqb));
           } # append (item, level)
           { # append (kind, level)
            var seqb := oid(v_kind003.count());
            kind := kind.materialize(ipik);
            v_kind003 := v_kind003.insert(kind.tmark(seqb));
           } # append (kind, level)
          } # end of insertVar (vid)
          { # translateVar (#pf:v_447)
           var vid := v_vid003.ord_uselect(1303761029@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter003);
           item := vid.leftfetchjoin(v_item003);
           kind := vid.leftfetchjoin(v_kind003);
           ipik := iter;
          } # end of translateVar (#pf:v_447)
          { # string-value
           var input_iter := iter;
           kind := kind.materialize(ipik);
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           var kind_elem := kind.get_type(ELEM);
           var item_str;
           if (kind_elem.count() = kind.count()) {
            var frag := kind.get_fragment();
            var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
            var t_iter := res_scj.fetch(0);
            var t_item := res_scj.fetch(1);
            var t_frag := res_scj.fetch(2);
            var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
            var t_iter_unq := t_iter.tunique();
            t_iter := t_iter.materialize(t_item);
            if (t_iter_unq.count() != t_item.count()) {
             var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
             iter_item := iter_item.string_join(t_iter_unq.project(""));
             t_iter := iter_item.hmark(0@0);
             t_item_str := iter_item.tmark(0@0);
            }
            var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
            if (c_map.count() > 0) { #process comments 
             var c_iter := c_map.leftfetchjoin(iter);
             var c_item := c_map.leftfetchjoin(item);
             var c_frag := c_map.leftfetchjoin(frag);
             var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
             var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of comment processing
            var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
            if (pi_map.count() > 0) { #process processing-instructions 
             var pi_iter := pi_map.leftfetchjoin(iter);
             var pi_item := pi_map.leftfetchjoin(item);
             var pi_frag := pi_map.leftfetchjoin(frag);
             var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
             var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
             t_item_str := res_mu.fetch(1);
            } # end of processing-instruction processing
            iter := t_iter;
            item_str := t_item_str;
           } else {
            var kind_attr := kind.get_type(ATTR);
            if (kind_attr.count() = kind.count()) {
             var frag := kind.get_fragment();
             item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
            } else {
             kind_attr := kind_attr.hmark(0@0);
             var item_attr := kind_attr.leftfetchjoin(item);
             var iter_attr := kind_attr.leftfetchjoin(iter);
             var frag := kind_attr.leftfetchjoin(kind).get_fragment();
             var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
             kind_elem := kind_elem.hmark(0@0);
             iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
             frag := kind_elem.leftfetchjoin(kind).get_fragment();
             item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
             var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
             var t_iter := res_scj.fetch(0);
             var t_item := res_scj.fetch(1);
             var t_frag := res_scj.fetch(2);
             var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
             var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
             t_iter := iter_item.hmark(0@0);
             t_item_str := iter_item.tmark(0@0);
             var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
             iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
             {
              var item_unq := iter_item.reverse().tunique();
              if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
             }
             t_iter := iter_item.hmark(0@0);
             var t_item_str := iter_item.tmark(0@0);
             var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
             if (c_map.count() > 0) { #process comments 
              var c_iter := c_map.leftfetchjoin(iter);
              var c_item := c_map.leftfetchjoin(item);
              var c_frag := c_map.leftfetchjoin(frag);
              var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
              var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
             } # end of comment processing
             var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
             if (pi_map.count() > 0) { #process processing-instructions 
              var pi_iter := pi_map.leftfetchjoin(iter);
              var pi_item := pi_map.leftfetchjoin(item);
              var pi_frag := pi_map.leftfetchjoin(frag);
              var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
              var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
             } # end of processing-instruction processing
             iter := t_iter;
             item_str := t_item_str;
            }
           }
           item_str_ := item_str;
           if (iter.count() != input_iter.tunique().count()) {
            var difference := reverse(input_iter.tdiff(iter));
            difference := difference.hmark(0@0);
            var res_mu := merged_union(iter, difference, item_str_, "");
            iter := res_mu.fetch(0);
            item_str_ := res_mu.fetch(1);
           }
           ipik := iter;
          } # end of string-value
          { # mapBack ()
           var iter_oidMap := inner003.reverse();
           var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
           iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
           # kind := kind;
           # ipik := ipik;
          } # end of mapBack ()
          # cleanUpLevel ()
         } # end of for-translation
         { # saveResult5 () : int
          var ipik005 := ipik;
          var iter005 := iter;
          var item_str_005 := item_str_; # end of saveResult5 () : int
          iter := loop002.tmark(0@0);
          ipik := iter;
          item_str_ := " ";
          { # string-join (string*, string)
           var iter_item_str := iter005.materialize(ipik005).reverse();
           iter_item_str := iter_item_str.leftfetchjoin(item_str_005).materialize(iter_item_str).chk_order();
           var iter_sep_str := iter.materialize(ipik).reverse();
           iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
           iter_item_str := string_join(iter_item_str, iter_sep_str);
           iter := iter_item_str.hmark(0@0);
           iter_item_str := iter_item_str.tmark(0@0);
           item_str_ := iter_item_str;
          } # end of string-join (string*, string)
         } # end of deleteResult5 ()
         { # loop_liftedAttrConstr (int i)
          if (iter004.count() != loop002.count()) {
           ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
          }
          if (iter.count() != loop002.count()) {
           var difference := reverse(loop002.tdiff(iter));
           difference := difference.hmark(0@0);
           var res_mu := merged_union(iter, difference, item_str_, "");
           item_str_ := res_mu.fetch(1);
          }
          var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
          var unq := item_str_.tunique().hmark(0@0);
          var unq_str := unq;
          var str_unq := reverse(unq_str.tdiff(ws_prop_val));
          var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
          unq_str := str_unq.hmark(seqb);
          ws_prop_val := ws_prop_val.insert(unq_str);
          var strings := item_str_.materialize(loop002);
          var attr_oid := strings.leftjoin(ws_prop_val.reverse());
          { # translateEmpty_node ()
           _elem_iter  := empty_bat;
           _elem_size  := empty_bat.project(int(nil));
           _elem_level := empty_bat.project(chr(nil));
           _elem_kind  := empty_bat.project(chr(nil));
           _elem_prop  := empty_bat;
           _elem_frag  := empty_bat;
           _attr_iter  := empty_bat;
           _attr_qn    := empty_bat;
           _attr_prop  := empty_bat;
           _attr_frag  := empty_bat;
           _attr_own   := empty_bat;
          } # end of translateEmpty_node ()
          attr_oid := attr_oid.tmark(0@0);
          _r_attr_iter := iter004;
          _r_attr_qn   := item004.materialize(ipik004);
          _r_attr_prop := attr_oid;
          _r_attr_frag := attr_oid.project(WS);
         } # end of loop_liftedAttrConstr (int i)
        } # end of deleteResult4 ()
        # translateSeq_node (f, counter)
        if (_r_attr_iter.count() = 0) {
         _r_attr_iter := _r_attr_iter003;
         _r_attr_qn := _r_attr_qn003;
         _r_attr_prop := _r_attr_prop003;
         _r_attr_frag := _r_attr_frag003;
        } else {
         if (_r_attr_iter003.count() != 0) 
         { # combine attribute roots
          var merged_result := merged_union (_r_attr_iter003.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn003, _r_attr_qn, _r_attr_prop003, _r_attr_prop, _r_attr_frag003, _r_attr_frag);
          _r_attr_iter := merged_result.fetch(0);
          _r_attr_qn := merged_result.fetch(1);
          _r_attr_prop := merged_result.fetch(2);
          _r_attr_frag := merged_result.fetch(3);
         }
        } # end of combine attribute roots
        if (_elem_iter.count() = 0) {
         _elem_iter  := _elem_iter003  ;
         _elem_size  := _elem_size003  ;
         _elem_level := _elem_level003 ;
         _elem_kind  := _elem_kind003  ;
         _elem_prop  := _elem_prop003  ;
         _elem_frag  := _elem_frag003  ;
         _attr_iter  := _attr_iter003  ;
         _attr_qn    := _attr_qn003    ;
         _attr_prop  := _attr_prop003  ;
         _attr_frag  := _attr_frag003  ;
         _attr_own   := _attr_own003   ;
        } else {
         if (_elem_iter003.count() != 0) 
         { # combine element nodes
          var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
          var shift_factor := int(seqb) - int(_elem_size003.seqbase());
          var merged_result := merged_union (_elem_iter003.chk_order(), _elem_iter.chk_order(), _elem_size003, _elem_size, _elem_level003, _elem_level, _elem_kind003, _elem_kind, _elem_prop003, _elem_prop, _elem_frag003, _elem_frag, _elem_size003.mark(seqb), _elem_size.mirror());
          _elem_iter := merged_result.fetch(0);
          _elem_size := merged_result.fetch(1);
          _elem_level:= merged_result.fetch(2);
          _elem_kind := merged_result.fetch(3);
          _elem_prop := merged_result.fetch(4);
          _elem_frag := merged_result.fetch(5);
          var preNew_preOld := merged_result.fetch(6);
          _attr_own003 := _attr_own003.[int]().[+](shift_factor).[oid]();
          merged_result := merged_union (_attr_iter003, _attr_iter, _attr_qn003, _attr_qn, _attr_prop003, _attr_prop, _attr_frag003, _attr_frag, _attr_own003, _attr_own);
          _attr_iter := merged_result.fetch(0);
          _attr_qn   := merged_result.fetch(1);
          _attr_prop := merged_result.fetch(2);
          _attr_frag := merged_result.fetch(3);
          _attr_own  := merged_result.fetch(4);
          _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
          _attr_own := _attr_own.tmark(0@0);
         }
        } # combine element nodes
        # end of translateSeq_node (f, counter)
       } # end of deleteResult_node3 ()
       { # loop_liftedElemConstr (counter)
        var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
        iter_size := {count}(iter_size, iter002.tunique(), FALSE);
        var root_iter  := iter_size.hmark(0@0).chk_order();
        var root_size  := iter_size.tmark(0@0);
        var root_prop  := iter002.reverse().leftfetchjoin(item002);
        if (not(is_constant(root_prop))) {
         root_prop  := root_prop.tmark(0@0);
        }
        {
         var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
         _elem_iter  := merged_result.fetch(0);
         _elem_size  := merged_result.fetch(1);
         _elem_level := merged_result.fetch(2);
         _elem_kind  := merged_result.fetch(3);
         _elem_prop  := merged_result.fetch(4);
         _elem_frag  := merged_result.fetch(5);
         var preNew_preOld := merged_result.fetch(6);
         _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
         _attr_own := _attr_own.tmark(0@0);
        }
        { # create attribute root entries
         var root_item := _elem_level.ord_uselect(chr(0));
         root_item := root_item.hmark(0@0);
         var iter_item := iter002.reverse().leftfetchjoin(root_item);
         var attr_own := _r_attr_iter.leftjoin(iter_item);
         if (_r_attr_iter.count() != 0) { # test uniqueness
          var sorting := _r_attr_iter.tsort();
          sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
          var unq_attrs := sorting.tunique();
          if (unq_attrs.count() != _r_attr_iter.count()) {
           item002 := materialize(item002,ipik002);
           if (item002.count() > 0) {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item002.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
           } else {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
          }
         } # end of test uniqueness
         if (_attr_iter.count() = 0) {
          _attr_iter := _r_attr_iter;
          _attr_qn   := _r_attr_qn;
          _attr_prop := _r_attr_prop;
          _attr_frag := _r_attr_frag;
          _attr_own  := attr_own.tmark(0@0);
         } else {
          var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
          _r_attr_iter := _r_attr_iter.tmark(seqb);
          _r_attr_qn   := _r_attr_qn  .tmark(seqb);
          _r_attr_prop := _r_attr_prop.tmark(seqb);
          _r_attr_frag := _r_attr_frag.tmark(seqb);
          attr_own := attr_own.tmark(seqb);
          _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
          _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
          _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
          _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
          _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
         }
         _r_attr_iter := empty_bat;
         _r_attr_qn   := empty_bat;
         _r_attr_prop := empty_bat;
         _r_attr_frag := empty_bat;
        } # end of create attribute root entries
        {
         var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
         var preOld_preNew := _elem_size.mark(seqb);
         _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
         _elem_size  := _elem_size.tmark(seqb);
         _elem_level := _elem_level.tmark(seqb);
         _elem_kind  := _elem_kind.tmark(seqb);
         _elem_prop  := _elem_prop.tmark(seqb);
         _elem_frag  := _elem_frag.tmark(seqb);
        }
        ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
        ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
        ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
        ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
        ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
        {
         var knd := ELEMENT;
         while ( knd <= DOCUMENT ) {
          var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
          ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
          if ( knd = ELEMENT ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
          }
          if ( knd = PI ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
          }
          knd :+= chr(1);
         }
        }
        var roots := _elem_level.ord_uselect(chr(0));
        roots := roots.hmark(0@0);
        {
         var height := int(_elem_level.max());
         ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
        }
        { # adding new fragments to the WS_FRAG bat
         var seqb := oid(count(ws.fetch(WS_FRAG)));
         var new_pres := roots.tmark(seqb);
         ws.fetch(WS_FRAG).insert(new_pres);
        }
        iter := iter002;
        item := roots;
        kind := ELEM;
        { # add attribute subtree copies to WS
         var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
         _attr_qn   := _attr_qn  .tmark(seqb);
         _attr_prop := _attr_prop.tmark(seqb);
         _attr_own  := _attr_own .tmark(seqb);
         _attr_frag := _attr_frag.tmark(seqb);
         ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
         ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
         ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
         ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
        } # end of add attribute subtree copies to WS
       } # end of loop_liftedElemConstr (counter)
      } # end of deleteResult2 ()
     } else {
      iter := empty_bat;
      item := empty_bat;
      kind := empty_kind_bat;
     }
     if (skip = 0) {
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
     } # cleanUpLevel ()
    } # end of translateIfThen
   } # end of ifthenelse-translation
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn678383E3_q03_xs_string1
PROC fn62BBFC16_q04_xs_string1_xs_string1_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q04
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761030@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "open_auction");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761018@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761033@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (b)
   var vid := v_vid001.ord_uselect(1303761033@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (b)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "personref");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  if (ipik.count() != 0) 
  { # for-translation
   # project ()
   iter := iter.materialize(ipik);
   var outer002 := iter;
   iter := iter.mark(1@0);
   var inner002 := iter;
   var loop002 := inner002;
   var v_vid002;
   var v_iter002;
   var v_item002;
   var v_kind002;
   var expOid;
   { # getExpanded (fid)
    var vu_nil := vu_fid.ord_uselect(1303761019@0);
    var vid_vu := vu_vid.reverse();
    var oid_nil := vid_vu.leftjoin(vu_nil);
    expOid := v_vid001.leftjoin(oid_nil);
    expOid := expOid.mirror();
   } # end of getExpanded (fid)
   if (expOid.count() != 0) {
    var oidNew_expOid;
    { # expand ()
     var expOid_iter := expOid.leftfetchjoin(v_iter001);
     var iter_expOid := expOid_iter.reverse();
     var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
     var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
     oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
     var expOid_oidMap := oidMap_expOid.reverse();
     expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
     v_iter002 := expOid_iter;
     oidNew_expOid := expOid_iter.hmark(0@0);
    } # end of expand ()
    # join ()
    var cnt := count(v_iter002)*2;
    v_iter002 := v_iter002.tmark(0@0);
    var new_v_iter := v_iter002;
    v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
    var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
    v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
    var new_v_pos ;
    var new_v_item := oidNew_expOid.leftjoin(v_item001);
    v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
    var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
    v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
   } else { # createNewVarTable ()
    v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
   }
   { # insertVar (vid)
    var vid := project(ipik,1303761034@0);
    { # append (vid, level)
     var seqb := oid(v_vid002.count());
     vid := vid.materialize(ipik);
     v_vid002 := v_vid002.insert(vid.tmark(seqb));
    } # append (vid, level)
    { # append (iter, level)
     var seqb := oid(v_iter002.count());
     iter := iter.materialize(ipik);
     v_iter002 := v_iter002.insert(iter.tmark(seqb));
    } # append (iter, level)
    { # append (pos, level)
     var seqb ;
    } # append (pos, level)
    { # append (item, level)
     var seqb := oid(v_item002.count());
     item := item.materialize(ipik);
     v_item002 := v_item002.insert(item.tmark(seqb));
    } # append (item, level)
    { # append (kind, level)
     var seqb := oid(v_kind002.count());
     kind := kind.materialize(ipik);
     v_kind002 := v_kind002.insert(kind.tmark(seqb));
    } # append (kind, level)
   } # end of insertVar (vid)
   { # translateVar (#pf:dot_496)
    var vid := v_vid002.ord_uselect(1303761034@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter002);
    item := vid.leftfetchjoin(v_item002);
    kind := vid.leftfetchjoin(v_kind002);
    ipik := iter;
   } # end of translateVar (#pf:dot_496)
   { # loop_liftedSCJ (axis, kind, ns, loc)
    { # attribute axis
     var oid_iter := iter;
     var oid_item := item.materialize(ipik);
     var oid_frag := kind.get_fragment();
     var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
     oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
     var oid_attr := temp1.tmark(0@0);
     oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
     var temp1_str; # only needed for name test
     temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
     temp1 := temp1_str.ord_uselect("");
     temp1 := temp1.hmark(0@0);
     oid_attr := temp1.leftfetchjoin(oid_attr);
     oid_frag := temp1.leftfetchjoin(oid_frag);
     oid_iter := temp1.leftfetchjoin(oid_iter);
     temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
     temp1 := temp1_str.ord_uselect("person");
     temp1 := temp1.hmark(0@0);
     oid_attr := temp1.leftfetchjoin(oid_attr);
     oid_frag := temp1.leftfetchjoin(oid_frag);
     oid_iter := temp1.leftfetchjoin(oid_iter);
     iter := oid_iter.tmark(0@0);
     item := oid_attr.tmark(0@0);
     kind := oid_frag.tmark(0@0);
     if (type(iter) = bat) {
      ipik := iter;
     } else {
      if (type(item) = bat) {
       ipik := item;
      } else {
       ipik := kind;
      }
     }
    } # end of attribute axis
    kind := kind.set_kind(ATTR);
   } # end of translateLocsteps (c)
   if (ipik.count() != 0) 
   { # for-translation
    # project ()
    iter := iter.materialize(ipik);
    var outer003 := iter;
    iter := iter.mark(1@0);
    var inner003 := iter;
    var loop003 := inner003;
    var v_vid003;
    var v_iter003;
    var v_item003;
    var v_kind003;
    var expOid;
    { # getExpanded (fid)
     var vu_nil := vu_fid.ord_uselect(1303761020@0);
     var vid_vu := vu_vid.reverse();
     var oid_nil := vid_vu.leftjoin(vu_nil);
     expOid := v_vid002.leftjoin(oid_nil);
     expOid := expOid.mirror();
    } # end of getExpanded (fid)
    if (expOid.count() != 0) {
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter002);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
      v_iter003 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter003)*2;
     v_iter003 := v_iter003.tmark(0@0);
     var new_v_iter := v_iter003;
     v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
     v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos ;
     var new_v_item := oidNew_expOid.leftjoin(v_item002);
     v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
     v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    } else { # createNewVarTable ()
     v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
    }
    { # insertVar (vid)
     var vid := project(ipik,1303761036@0);
     { # append (vid, level)
      var seqb := oid(v_vid003.count());
      vid := vid.materialize(ipik);
      v_vid003 := v_vid003.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter003.count());
      iter := iter.materialize(ipik);
      v_iter003 := v_iter003.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb ;
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item003.count());
      item := item.materialize(ipik);
      v_item003 := v_item003.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind003.count());
      kind := kind.materialize(ipik);
      v_kind003 := v_kind003.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    { # translateVar (#pf:v_2792)
     var vid := v_vid003.ord_uselect(1303761036@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter003);
     item := vid.leftfetchjoin(v_item003);
     kind := vid.leftfetchjoin(v_kind003);
     ipik := iter;
    } # end of translateVar (#pf:v_2792)
    { # string-value
     var input_iter := iter;
     kind := kind.materialize(ipik);
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     var kind_elem := kind.get_type(ELEM);
     var item_str;
     if (kind_elem.count() = kind.count()) {
      var frag := kind.get_fragment();
      var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
      var t_iter := res_scj.fetch(0);
      var t_item := res_scj.fetch(1);
      var t_frag := res_scj.fetch(2);
      var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
      var t_iter_unq := t_iter.tunique();
      t_iter := t_iter.materialize(t_item);
      if (t_iter_unq.count() != t_item.count()) {
       var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       iter_item := iter_item.string_join(t_iter_unq.project(""));
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
      }
      var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
      if (c_map.count() > 0) { #process comments 
       var c_iter := c_map.leftfetchjoin(iter);
       var c_item := c_map.leftfetchjoin(item);
       var c_frag := c_map.leftfetchjoin(frag);
       var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
       var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of comment processing
      var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
      if (pi_map.count() > 0) { #process processing-instructions 
       var pi_iter := pi_map.leftfetchjoin(iter);
       var pi_item := pi_map.leftfetchjoin(item);
       var pi_frag := pi_map.leftfetchjoin(frag);
       var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
       var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
       t_item_str := res_mu.fetch(1);
      } # end of processing-instruction processing
      iter := t_iter;
      item_str := t_item_str;
     } else {
      var kind_attr := kind.get_type(ATTR);
      if (kind_attr.count() = kind.count()) {
       var frag := kind.get_fragment();
       item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
      } else {
       kind_attr := kind_attr.hmark(0@0);
       var item_attr := kind_attr.leftfetchjoin(item);
       var iter_attr := kind_attr.leftfetchjoin(iter);
       var frag := kind_attr.leftfetchjoin(kind).get_fragment();
       var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
       kind_elem := kind_elem.hmark(0@0);
       iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
       frag := kind_elem.leftfetchjoin(kind).get_fragment();
       item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
       var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
       var t_iter := res_scj.fetch(0);
       var t_item := res_scj.fetch(1);
       var t_frag := res_scj.fetch(2);
       var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
       var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
       iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       {
        var item_unq := iter_item.reverse().tunique();
        if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
       }
       t_iter := iter_item.hmark(0@0);
       var t_item_str := iter_item.tmark(0@0);
       var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
       if (c_map.count() > 0) { #process comments 
        var c_iter := c_map.leftfetchjoin(iter);
        var c_item := c_map.leftfetchjoin(item);
        var c_frag := c_map.leftfetchjoin(frag);
        var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
        var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of comment processing
       var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
       if (pi_map.count() > 0) { #process processing-instructions 
        var pi_iter := pi_map.leftfetchjoin(iter);
        var pi_item := pi_map.leftfetchjoin(item);
        var pi_frag := pi_map.leftfetchjoin(frag);
        var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
        var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of processing-instruction processing
       iter := t_iter;
       item_str := t_item_str;
      }
     }
     item_str_ := item_str;
     if (iter.count() != input_iter.tunique().count()) {
      var difference := reverse(input_iter.tdiff(iter));
      difference := difference.hmark(0@0);
      var res_mu := merged_union(iter, difference, item_str_, "");
      iter := res_mu.fetch(0);
      item_str_ := res_mu.fetch(1);
     }
    } # end of string-value
    { # cast from string to untypedAtomic
     if (iter.count() != loop003.count()) {
      ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
     }
    } # end of cast from string to untypedAtomic
    { # cast from untypedAtomic to string
     if (iter.count() != loop003.count()) {
      ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
     }
    } # end of cast from untypedAtomic to string
    { # saveResult1 () : int
     var item_str_001 := item_str_; # end of saveResult1 () : int
     { # translateVar (person1)
      var vid := v_vid003.ord_uselect(1303761031@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter003);
      item := vid.leftfetchjoin(v_item003);
     } # end of translateVar (person1)
     { # '=' calculation
      var val_snd := item.leftfetchjoin(str_values);
      var val_fst := item_str_001;
      val_fst := [=](val_fst,val_snd);
      item := val_fst.[oid]();
     } # end of '=' calculation
    } # end of deleteResult1 ()
    { # saveResult1 () : int
     var iter001 := iter;
     var item001 := item; # end of saveResult1 () : int
     { # ifthenelse-translation
      var selected;
      var skip;
      if (type(item001) = bat) {
       selected := item001.ord_uselect(1@0);
       var cnt := selected.count();
       if (item001.count() = cnt) {
        skip := 2;
       } else {
        skip := int(cnt = 0);
       }
      } else {
       skip := 1 + int(item001); # handle constants efficiently
      }
      { # translateIfThen
       var loop004 := loop003;
       var inner004 := inner003;
       var outer004 := outer003;
       if (skip = 0) {
        iter := selected.mirror().join(iter001);
        iter := iter.tmark(0@0);
        outer004 := iter;
        iter := iter.mark(1@0);
        inner004 := iter;
        loop004 := inner004;
        var expOid ;
        var oidNew_expOid;
        { # expand ()
         var expOid_iter ;
         var iter_expOid ;
         var oidMap_expOid ; # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
         var temp_sort ;
         var expOid_oidMap ;
        } # end of expand ()
        # join ()
        var cnt ;
        var new_v_iter ;
        var new_v_vid ;
        var new_v_pos ;
        var new_v_item ;
        var new_v_kind ; # end of join ()
       }
       if (skip != 1) {
        {
         int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
         var itemID ; # translateConst (kind)
         iter := loop004.tmark(0@0);
        }
       } else {
        iter := empty_bat;
       }
       if (skip = 0) {
        { # mapBack ()
         var iter_oidMap := inner004.reverse();
         var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
         iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
         # kind := kind;
         # ipik := ipik;
        } # end of mapBack ()
       } # cleanUpLevel ()
      } # end of translateIfThen
     } # end of ifthenelse-translation
    } # end of deleteResult1 ()
    { # mapBack ()
     var iter_oidMap := inner003.reverse();
     var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
     iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
     # kind := kind;
     # ipik := ipik;
    } # end of mapBack ()
    # cleanUpLevel ()
   } # end of for-translation
   { # translate fn:empty (item*) as boolean
    var iter_count := {count}(iter.reverse(),loop002.reverse(), FALSE);
    var iter_bool := iter_count.[=](0).[oid]();
    item := iter_bool.tmark(0@0);
    iter := loop002.tmark(0@0);
   } # end of translate fn:empty (item*) as boolean
   { # saveResult1 () : int
    var iter001 := iter;
    var item001 := item; # end of saveResult1 () : int
    { # ifthenelse-translation
     var selected;
     var skip;
     if (type(item001) = bat) {
      selected := item001.ord_uselect(1@0);
      var cnt := selected.count();
      if (item001.count() = cnt) {
       skip := 2;
      } else {
       skip := int(cnt = 0);
      }
     } else {
      skip := 1 + int(item001); # handle constants efficiently
     }
     { # translateIfThen
      var inner003 := inner002;
      var outer003 := outer002;
      var v_vid003 := v_vid002;
      var v_iter003 := v_iter002;
      var v_pos003 ;
      var v_item003 := v_item002;
      var v_kind003 := v_kind002;
      if (skip = 0) {
       selected := item001.ord_uselect(0@0);
       iter := selected.mirror().join(iter001);
       iter := iter.tmark(0@0);
       outer003 := iter;
       iter := iter.mark(1@0);
       inner003 := iter;
       var expOid := v_iter003.mirror();
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter002);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
        v_iter003 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter003)*2;
       v_iter003 := v_iter003.tmark(0@0);
       var new_v_iter := v_iter003;
       v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
       v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item002);
       v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
       v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      }
      if (skip != 2) {
       { # translateVar (#pf:dot_496)
        var vid := v_vid003.ord_uselect(1303761034@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter003);
        item := vid.leftfetchjoin(v_item003);
        kind := vid.leftfetchjoin(v_kind003);
        ipik := iter;
       } # end of translateVar (#pf:dot_496)
      } else { # translateEmpty ()
       ipik := empty_bat;
       iter := empty_bat;
       item := empty_bat;
       kind := empty_kind_bat;
      }
      if (skip = 0) {
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
      } # cleanUpLevel ()
     } # end of translateIfThen
    } # end of ifthenelse-translation
   } # end of deleteResult1 ()
   { # mapBack ()
    var iter_oidMap := inner002.reverse();
    var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
    iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
    # kind := kind;
    # ipik := ipik;
   } # end of mapBack ()
   # cleanUpLevel ()
  } # end of for-translation
  { # translate pf:distinct-doc-order (node*) as node*
   var sorting;
   var simple := false;
   if (type(kind) != bat) {
    simple := (kind = ELEM);
   }
   if (not(simple)) {
    kind := kind.materialize(ipik);
    simple := (kind.count() = kind.get_type(ELEM).count());
   }
   if (simple) {
    sorting := iter.tsort();
    sorting := sorting.CTrefine(kind);
    sorting := sorting.CTrefine(item);
   } else { # cope also with attributes and sort them according to their owner
    var elements := kind.get_type(ELEM).mirror();
    var elem_iters := elements.leftfetchjoin(iter);
    var elem_items := elements.leftfetchjoin(item);
    var elem_frags := elements.leftfetchjoin(kind.get_fragment());
    var elem_attrs := elements.mark(nil);
    var attributes := kind.get_type(ATTR).mirror();
    var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
    var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
    var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
    var attr_key := attributes.hmark(0@0);
    var temp_attr := attr_attrs.tmark(0@0);
    var temp_frag := attr_frags.tmark(0@0);
    var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
    sorting := elem_iters.union(attr_iters).tsort();
    sorting := sorting.CTrefine(elem_frags.union(attr_frags));
    sorting := sorting.CTrefine(elem_items.union(attr_items));
    sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
   }
   ipik := sorting.reverse().{min}().tmark(0@0);
   iter := ipik.leftfetchjoin(iter);
   item := ipik.leftfetchjoin(item);
   kind := ipik.leftfetchjoin(kind);
  } # end of translate pf:distinct-doc-order (node*) as node*
  if (ipik.count() != 0) 
  { # for-translation
   # project ()
   iter := iter.materialize(ipik);
   var outer002 := iter;
   iter := iter.mark(1@0);
   var inner002 := iter;
   var loop002 := inner002;
   var v_vid002;
   var v_iter002;
   var v_item002;
   var v_kind002;
   var expOid;
   { # getExpanded (fid)
    var vu_nil := vu_fid.ord_uselect(1303761021@0);
    var vid_vu := vu_vid.reverse();
    var oid_nil := vid_vu.leftjoin(vu_nil);
    expOid := v_vid001.leftjoin(oid_nil);
    expOid := expOid.mirror();
   } # end of getExpanded (fid)
   if (expOid.count() != 0) {
    var oidNew_expOid;
    { # expand ()
     var expOid_iter := expOid.leftfetchjoin(v_iter001);
     var iter_expOid := expOid_iter.reverse();
     var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
     var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
     oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
     var expOid_oidMap := oidMap_expOid.reverse();
     expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
     v_iter002 := expOid_iter;
     oidNew_expOid := expOid_iter.hmark(0@0);
    } # end of expand ()
    # join ()
    var cnt := count(v_iter002)*2;
    v_iter002 := v_iter002.tmark(0@0);
    var new_v_iter := v_iter002;
    v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
    var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
    v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
    var new_v_pos ;
    var new_v_item := oidNew_expOid.leftjoin(v_item001);
    v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
    var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
    v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
   } else { # createNewVarTable ()
    v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
   }
   { # insertVar (vid)
    var vid := project(ipik,1303761037@0);
    { # append (vid, level)
     var seqb := oid(v_vid002.count());
     vid := vid.materialize(ipik);
     v_vid002 := v_vid002.insert(vid.tmark(seqb));
    } # append (vid, level)
    { # append (iter, level)
     var seqb := oid(v_iter002.count());
     iter := iter.materialize(ipik);
     v_iter002 := v_iter002.insert(iter.tmark(seqb));
    } # append (iter, level)
    { # append (pos, level)
     var seqb ;
    } # append (pos, level)
    { # append (item, level)
     var seqb := oid(v_item002.count());
     item := item.materialize(ipik);
     v_item002 := v_item002.insert(item.tmark(seqb));
    } # append (item, level)
    { # append (kind, level)
     var seqb := oid(v_kind002.count());
     kind := kind.materialize(ipik);
     v_kind002 := v_kind002.insert(kind.tmark(seqb));
    } # append (kind, level)
   } # end of insertVar (vid)
   {
    var iter001;
    var item001;
    var kind001;
    var ipik002;
    var iter002;
    var item002;
    var match_outer002;
    var ipik003;
    var iter003;
    var item003;
    var match_outer003;
    var jouter002 ;
    var jorder_002 ;
    var jinner002 ;
    var jloop002  ;
    var jv_vid002 ;
    var jv_iter002;
    var jv_pos002 ;
    var jv_item002;
    var jv_kind002;
    { # translateVar (person2)
     var vid := v_vid002.ord_uselect(1303761032@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter002);
     item := vid.leftfetchjoin(v_item002);
     ipik := iter;
    } # end of translateVar (person2)
    match_outer002 := iter.leftfetchjoin(inner002.reverse()).leftfetchjoin(outer002);
    ipik002 := ipik;
    iter002 := iter;
    item002 := item;
    jouter002  := outer002 ;
    jinner002  := inner002 ;
    jloop002   := loop002  ;
    jv_vid002  := v_vid002 ;
    jv_iter002 := v_iter002;
    jv_item002 := v_item002;
    jv_kind002 := v_kind002;
    v_vid002  := v_vid001 .copy().access(BAT_WRITE);
    v_iter002 := v_iter001.copy().access(BAT_WRITE);
    v_item002 := v_item001.copy().access(BAT_WRITE);
    v_kind002 := v_kind001.copy().access(BAT_WRITE);
    { # translateVar (b)
     var vid := v_vid002.ord_uselect(1303761033@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter002);
     item := vid.leftfetchjoin(v_item002);
     kind := vid.leftfetchjoin(v_kind002);
     ipik := iter;
    } # end of translateVar (b)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "personref");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer003 := iter;
     iter := iter.mark(1@0);
     var inner003 := iter;
     var v_vid003;
     var v_iter003;
     var v_pos003;
     var v_item003;
     var v_kind003;
     iter001 := iter;
     item001 := item;
     kind001 := kind;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(1303761022@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid002.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter002);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
       v_iter003 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter003)*2;
      v_iter003 := v_iter003.tmark(0@0);
      var new_v_iter := v_iter003;
      v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
      v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item002);
      v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
      v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     } else { # createNewVarTable ()
      v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,1303761038@0);
      { # append (vid, level)
       var seqb := oid(v_vid003.count());
       vid := vid.materialize(ipik);
       v_vid003 := v_vid003.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter003.count());
       iter := iter.materialize(ipik);
       v_iter003 := v_iter003.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb ;
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item003.count());
       item := item.materialize(ipik);
       v_item003 := v_item003.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb := oid(v_kind003.count());
       kind := kind.materialize(ipik);
       v_kind003 := v_kind003.insert(kind.tmark(seqb));
      } # append (kind, level)
     } # end of insertVar (vid)
     { # translateVar (#pf:dot_574)
      var vid := v_vid003.ord_uselect(1303761038@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter003);
      item := vid.leftfetchjoin(v_item003);
      kind := vid.leftfetchjoin(v_kind003);
      ipik := iter;
     } # end of translateVar (#pf:dot_574)
     { # loop_liftedSCJ (axis, kind, ns, loc)
      { # attribute axis
       var oid_iter := iter;
       var oid_item := item.materialize(ipik);
       var oid_frag := kind.get_fragment();
       var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
       oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
       var oid_attr := temp1.tmark(0@0);
       oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
       var temp1_str; # only needed for name test
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
       temp1 := temp1_str.ord_uselect("");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
       temp1 := temp1_str.ord_uselect("person");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       iter := oid_iter.tmark(0@0);
       item := oid_attr.tmark(0@0);
       kind := oid_frag.tmark(0@0);
       if (type(iter) = bat) {
        ipik := iter;
       } else {
        if (type(item) = bat) {
         ipik := item;
        } else {
         ipik := kind;
        }
       }
      } # end of attribute axis
      kind := kind.set_kind(ATTR);
     } # end of translateLocsteps (c)
     if (ipik.count() != 0) 
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer004 := iter;
      iter := iter.mark(1@0);
      var inner004 := iter;
      var loop004 := inner004;
      var v_vid004;
      var v_iter004;
      var v_item004;
      var v_kind004;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761023@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid003.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter003);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer004.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner004);
        v_iter004 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter004)*2;
       v_iter004 := v_iter004.tmark(0@0);
       var new_v_iter := v_iter004;
       v_iter004 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid003);
       v_vid004 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item003);
       v_item004 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind003);
       v_kind004 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter004 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid004 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item004 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind004 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761040@0);
       { # append (vid, level)
        var seqb := oid(v_vid004.count());
        vid := vid.materialize(ipik);
        v_vid004 := v_vid004.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter004.count());
        iter := iter.materialize(ipik);
        v_iter004 := v_iter004.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item004.count());
        item := item.materialize(ipik);
        v_item004 := v_item004.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind004.count());
        kind := kind.materialize(ipik);
        v_kind004 := v_kind004.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (#pf:v_2794)
       var vid := v_vid004.ord_uselect(1303761040@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter004);
       item := vid.leftfetchjoin(v_item004);
       kind := vid.leftfetchjoin(v_kind004);
       ipik := iter;
      } # end of translateVar (#pf:v_2794)
      { # string-value
       var input_iter := iter;
       kind := kind.materialize(ipik);
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       var kind_elem := kind.get_type(ELEM);
       var item_str;
       if (kind_elem.count() = kind.count()) {
        var frag := kind.get_fragment();
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var t_iter_unq := t_iter.tunique();
        t_iter := t_iter.materialize(t_item);
        if (t_iter_unq.count() != t_item.count()) {
         var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         iter_item := iter_item.string_join(t_iter_unq.project(""));
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
        }
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       } else {
        var kind_attr := kind.get_type(ATTR);
        if (kind_attr.count() = kind.count()) {
         var frag := kind.get_fragment();
         item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        } else {
         kind_attr := kind_attr.hmark(0@0);
         var item_attr := kind_attr.leftfetchjoin(item);
         var iter_attr := kind_attr.leftfetchjoin(iter);
         var frag := kind_attr.leftfetchjoin(kind).get_fragment();
         var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         kind_elem := kind_elem.hmark(0@0);
         iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
         frag := kind_elem.leftfetchjoin(kind).get_fragment();
         item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
         var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
         iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         {
          var item_unq := iter_item.reverse().tunique();
          if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
         }
         t_iter := iter_item.hmark(0@0);
         var t_item_str := iter_item.tmark(0@0);
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        }
       }
       item_str_ := item_str;
       if (iter.count() != input_iter.tunique().count()) {
        var difference := reverse(input_iter.tdiff(iter));
        difference := difference.hmark(0@0);
        var res_mu := merged_union(iter, difference, item_str_, "");
        iter := res_mu.fetch(0);
        item_str_ := res_mu.fetch(1);
       }
       ipik := iter;
      } # end of string-value
      { # cast from string to untypedAtomic
       if (iter.count() != loop004.count()) {
        ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
       }
      } # end of cast from string to untypedAtomic
      { # cast from untypedAtomic to string
       if (iter.count() != loop004.count()) {
        ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
       }
      } # end of cast from untypedAtomic to string
      { # mapBack ()
       var iter_oidMap := inner004.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
     ipik003 := ipik;
     iter003 := iter;
     item003 := item_str_;
     match_outer003 := iter.leftfetchjoin(inner003.reverse()).leftfetchjoin(outer003); # cleanUpLevel ()
    } # end of for-translation
    outer002  := jouter002 ;
    inner002  := jinner002 ;
    loop002   := jloop002  ;
    v_vid002  := jv_vid002 ;
    v_iter002 := jv_iter002;
    v_item002 := jv_item002;
    v_kind002 := jv_kind002;
    var join_item1 := item002.leftfetchjoin(str_values);
    var join_item2 := item003;
    join_item1 := join_item1.materialize(ipik002);
    join_item1 := join_item1.reverse().leftfetchjoin(iter002).reverse();
    join_item2 := join_item2.materialize(ipik003);
    join_item2 := join_item2.reverse().leftfetchjoin(iter003).reverse();
    var join_result := ll_htordered_unique_thetajoin(EQ, join_item1, join_item2, match_outer002, match_outer003,nil,iter001.reverse());
    var snd_iter := join_result.tmark(0@0);
    var fst_iter := join_result.hmark(0@0);
    ipik := fst_iter; # order_fst isn't needed until now
    # (cannot be pushed below the theta-join due to the 'iter := fst_iter;' hereafter)
    # var order_fst := fst_iter.leftfetchjoin(inner002.reverse());
    var order_snd := snd_iter; #.leftfetchjoin(iter001.reverse()); pushed below theta-join
    # could also be pushed below theta-join, if order_snd wasn't needed for kind (below) ...
    item := order_snd.leftfetchjoin(item001);
    iter := fst_iter; # could also be pushed below theta-join, if order_snd wasn't needed for item (above) ...
    kind := order_snd.leftfetchjoin(kind001);
   } # end of evaluate_join
   { # translate pf:distinct-doc-order (node*) as node*
    var sorting;
    var simple := false;
    if (type(kind) != bat) {
     simple := (kind = ELEM);
    }
    if (not(simple)) {
     kind := kind.materialize(ipik);
     simple := (kind.count() = kind.get_type(ELEM).count());
    }
    if (simple) {
     sorting := iter.tsort();
     sorting := sorting.CTrefine(kind);
     sorting := sorting.CTrefine(item);
    } else { # cope also with attributes and sort them according to their owner
     var elements := kind.get_type(ELEM).mirror();
     var elem_iters := elements.leftfetchjoin(iter);
     var elem_items := elements.leftfetchjoin(item);
     var elem_frags := elements.leftfetchjoin(kind.get_fragment());
     var elem_attrs := elements.mark(nil);
     var attributes := kind.get_type(ATTR).mirror();
     var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
     var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
     var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
     var attr_key := attributes.hmark(0@0);
     var temp_attr := attr_attrs.tmark(0@0);
     var temp_frag := attr_frags.tmark(0@0);
     var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
     sorting := elem_iters.union(attr_iters).tsort();
     sorting := sorting.CTrefine(elem_frags.union(attr_frags));
     sorting := sorting.CTrefine(elem_items.union(attr_items));
     sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
    }
    ipik := sorting.reverse().{min}().tmark(0@0);
    iter := ipik.leftfetchjoin(iter);
    item := ipik.leftfetchjoin(item);
    kind := ipik.leftfetchjoin(kind);
   } # end of translate pf:distinct-doc-order (node*) as node*
   if (ipik.count() != 0) 
   { # for-translation
    # project ()
    iter := iter.materialize(ipik);
    var outer003 := iter;
    iter := iter.mark(1@0);
    var inner003 := iter;
    var loop003 := inner003;
    var v_vid003;
    var v_iter003;
    var v_item003;
    var v_kind003;
    var expOid;
    { # getExpanded (fid)
     var vu_nil := vu_fid.ord_uselect(1303761025@0);
     var vid_vu := vu_vid.reverse();
     var oid_nil := vid_vu.leftjoin(vu_nil);
     expOid := v_vid002.leftjoin(oid_nil);
     expOid := expOid.mirror();
    } # end of getExpanded (fid)
    if (expOid.count() != 0) {
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter002);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
      v_iter003 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter003)*2;
     v_iter003 := v_iter003.tmark(0@0);
     var new_v_iter := v_iter003;
     v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
     v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos ;
     var new_v_item := oidNew_expOid.leftjoin(v_item002);
     v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
     v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    } else { # createNewVarTable ()
     v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
    }
    { # insertVar (vid)
     var vid := project(ipik,1303761041@0);
     { # append (vid, level)
      var seqb := oid(v_vid003.count());
      vid := vid.materialize(ipik);
      v_vid003 := v_vid003.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter003.count());
      iter := iter.materialize(ipik);
      v_iter003 := v_iter003.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb ;
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item003.count());
      item := item.materialize(ipik);
      v_item003 := v_item003.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind003.count());
      kind := kind.materialize(ipik);
      v_kind003 := v_kind003.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    { # translateVar (pr1)
     var vid := v_vid003.ord_uselect(1303761037@0);
     vid := vid.hmark(0@0);
     item := vid.leftfetchjoin(v_item003);
     kind := vid.leftfetchjoin(v_kind003);
    } # end of translateVar (pr1)
    { # saveResult1 () : int
     var item001 := item;
     var kind001 := kind; # end of saveResult1 () : int
     { # translateVar (pr2)
      var vid := v_vid003.ord_uselect(1303761041@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter003);
      item := vid.leftfetchjoin(v_item003);
      kind := vid.leftfetchjoin(v_kind003);
     } # end of translateVar (pr2)
     { # translate op:node-before (node, node) as boolean
      var frag_before := kind001.[<](kind);
      var frag_equal := kind001.[=](kind);
      var pre_before := item001.[<](item);
      var node_before := frag_before.[or](frag_equal.[and](pre_before));
      item := node_before.[oid]().tmark(0@0);
     } # end of translate op:node-before (node, node) as boolean
    } # end of deleteResult1 ()
    { # saveResult1 () : int
     var iter001 := iter;
     var item001 := item; # end of saveResult1 () : int
     { # ifthenelse-translation
      var selected;
      var skip;
      if (type(item001) = bat) {
       selected := item001.ord_uselect(1@0);
       var cnt := selected.count();
       if (item001.count() = cnt) {
        skip := 2;
       } else {
        skip := int(cnt = 0);
       }
      } else {
       skip := 1 + int(item001); # handle constants efficiently
      }
      { # translateIfThen
       var loop004 := loop003;
       var inner004 := inner003;
       var outer004 := outer003;
       if (skip = 0) {
        iter := selected.mirror().join(iter001);
        iter := iter.tmark(0@0);
        outer004 := iter;
        iter := iter.mark(1@0);
        inner004 := iter;
        loop004 := inner004;
        var expOid ;
        var oidNew_expOid;
        { # expand ()
         var expOid_iter ;
         var iter_expOid ;
         var oidMap_expOid ; # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
         var temp_sort ;
         var expOid_oidMap ;
        } # end of expand ()
        # join ()
        var cnt ;
        var new_v_iter ;
        var new_v_vid ;
        var new_v_pos ;
        var new_v_item ;
        var new_v_kind ; # end of join ()
       }
       if (skip != 1) {
        {
         int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
         var itemID ; # translateConst (kind)
         iter := loop004.tmark(0@0);
        }
       } else {
        iter := empty_bat;
       }
       if (skip = 0) {
        { # mapBack ()
         var iter_oidMap := inner004.reverse();
         var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
         iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
         # kind := kind;
         # ipik := ipik;
        } # end of mapBack ()
       } # cleanUpLevel ()
      } # end of translateIfThen
     } # end of ifthenelse-translation
    } # end of deleteResult1 ()
    { # mapBack ()
     var iter_oidMap := inner003.reverse();
     var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
     iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
     # kind := kind;
     # ipik := ipik;
    } # end of mapBack ()
    # cleanUpLevel ()
   } # end of for-translation
   { # translate fn:empty (item*) as boolean
    var iter_count := {count}(iter.reverse(),loop002.reverse(), FALSE);
    var iter_bool := iter_count.[=](0).[oid]();
    item := iter_bool.tmark(0@0);
    iter := loop002.tmark(0@0);
   } # end of translate fn:empty (item*) as boolean
   { # saveResult1 () : int
    var iter001 := iter;
    var item001 := item; # end of saveResult1 () : int
    { # ifthenelse-translation
     var selected;
     var skip;
     if (type(item001) = bat) {
      selected := item001.ord_uselect(1@0);
      var cnt := selected.count();
      if (item001.count() = cnt) {
       skip := 2;
      } else {
       skip := int(cnt = 0);
      }
     } else {
      skip := 1 + int(item001); # handle constants efficiently
     }
     { # translateIfThen
      var loop003 := loop002;
      var inner003 := inner002;
      var outer003 := outer002;
      if (skip = 0) {
       selected := item001.ord_uselect(0@0);
       iter := selected.mirror().join(iter001);
       iter := iter.tmark(0@0);
       outer003 := iter;
       iter := iter.mark(1@0);
       inner003 := iter;
       loop003 := inner003;
       var expOid ;
       var oidNew_expOid;
       { # expand ()
        var expOid_iter ;
        var iter_expOid ;
        var oidMap_expOid ; # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
        var temp_sort ;
        var expOid_oidMap ;
       } # end of expand ()
       # join ()
       var cnt ;
       var new_v_iter ;
       var new_v_vid ;
       var new_v_pos ;
       var new_v_item ;
       var new_v_kind ; # end of join ()
      }
      if (skip != 2) {
       {
        int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
        var itemID ; # translateConst (kind)
        iter := loop003.tmark(0@0);
       }
      } else {
       iter := empty_bat;
      }
      if (skip = 0) {
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
      } # cleanUpLevel ()
     } # end of translateIfThen
    } # end of ifthenelse-translation
   } # end of deleteResult1 ()
   { # mapBack ()
    var iter_oidMap := inner002.reverse();
    var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
    iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
    # kind := kind;
    # ipik := ipik;
   } # end of mapBack ()
   # cleanUpLevel ()
  } # end of for-translation
  { # translate fn:empty (item*) as boolean
   var iter_count := {count}(iter.reverse(),loop001.reverse(), FALSE);
   var iter_bool := iter_count.[=](0).[oid]();
   item := iter_bool.tmark(0@0);
   iter := loop001.tmark(0@0);
  } # end of translate fn:empty (item*) as boolean
  { # saveResult1 () : int
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # ifthenelse-translation
    var selected;
    var skip;
    if (type(item001) = bat) {
     selected := item001.ord_uselect(1@0);
     var cnt := selected.count();
     if (item001.count() = cnt) {
      skip := 2;
     } else {
      skip := int(cnt = 0);
     }
    } else {
     skip := 1 + int(item001); # handle constants efficiently
    }
    { # translateIfThen
     var loop002 := loop001;
     var inner002 := inner001;
     var outer002 := outer001;
     var v_vid002 := v_vid001;
     var v_iter002 := v_iter001;
     var v_item002 := v_item001;
     var v_kind002 := v_kind001;
     if (skip = 0) {
      selected := item001.ord_uselect(0@0);
      iter := selected.mirror().join(iter001);
      iter := iter.tmark(0@0);
      outer002 := iter;
      iter := iter.mark(1@0);
      inner002 := iter;
      loop002 := inner002;
      var expOid := v_iter002.mirror();
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     }
     if (skip != 2) {
      { # tagname-translation
       var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
       var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
       var itemID;
       if (prop_str.texist("history")) {
        itemID := prop_str.reverse().find("history");
       } else {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
        ws.fetch(QN_LOC).fetch(WS).insert(itemID,"history");
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"history"+str('\1')+"");
       } # translateConst (kind)
       iter := loop002.tmark(0@0);
       ipik := iter;
       item := itemID;
      } # end of tagname-translation
      { # saveResult2 () : int
       var ipik002 := ipik;
       var iter002 := iter;
       var item002 := item; # end of saveResult2 () : int
       { # translateVar (b)
        var vid := v_vid002.ord_uselect(1303761033@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter002);
        item := vid.leftfetchjoin(v_item002);
        kind := vid.leftfetchjoin(v_kind002);
        ipik := iter;
       } # end of translateVar (b)
       { # translateLocsteps (c)
        var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "reserve");
        iter := res_scj.fetch(0);
        item := res_scj.fetch(1);
        kind := res_scj.fetch(2).set_kind(ELEM);
        ipik := item;
       } # end of translateLocsteps (c)
       { # translateLocsteps (c)
        var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
        iter := res_scj.fetch(0);
        item := res_scj.fetch(1);
        kind := res_scj.fetch(2).set_kind(ELEM);
        ipik := item;
       } # end of translateLocsteps (c)
       { # map2NODE_interface (counter)
        kind := kind.materialize(ipik);
        var attr := kind.get_type(ATTR).hmark(0@0);
        var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
        var attr_item := attr.leftfetchjoin(item);
        var attr_frag := attr.leftfetchjoin(kind).get_fragment();
        _r_attr_iter := attr_iter;
        _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
        _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
        _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
        var nodes := kind.get_type(ELEM);
        if (nodes.count() != 0) {
         var oid_oid := nodes.hmark(0@0);
         var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
         var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
         var iter_input := oid_oid.mirror();
         var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
         var res_iter := res_scj.fetch(0);
         var res_item := res_scj.fetch(1);
         var res_frag := res_scj.fetch(2);
         _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
         _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
         _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
         _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
         _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
         var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
         var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
         nodes := res_item.mark(0@0);
         var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
         root_level := nodes.leftfetchjoin(root_level);
         temp_ec_item := res_item;
         temp_ec_frag := res_frag;
         var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
         content_level := nodes.leftfetchjoin(content_level);
         content_level := content_level.[-](root_level);
         content_level := content_level.tmark(0@0);
         _elem_level := content_level;
         { # create attribute subtree copies
          var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
          var oid_attr := temp_attr.tmark(0@0);
          var oid_frag;
          if (is_constant(res_frag)) {
           oid_frag := res_frag;
          } else {
           oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
           oid_frag := oid_frag.tmark(0@0);
          }
          _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
          _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
          _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
          _attr_own  := temp_attr.hmark(0@0);
          _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
         } # end of create attribute subtree copies
        } else { # if (nodes.count() != 0) ...
         _elem_iter  := empty_bat;
         _elem_size  := empty_bat.project(int(nil));
         _elem_level := empty_bat.project(chr(nil));
         _elem_kind  := empty_bat.project(chr(nil));
         _elem_prop  := empty_bat;
         _elem_frag  := empty_bat;
         _attr_iter  := empty_bat;
         _attr_qn    := empty_bat;
         _attr_prop  := empty_bat;
         _attr_frag  := empty_bat;
         _attr_own   := empty_bat;
        } # end of else in 'if (nodes.count() != 0)'
       } # end of map2NODE_interface (counter)
       if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
        { # saveResult_node3 () : int
         var _elem_iter003   := _elem_iter  ;
         var _elem_size003   := _elem_size  ;
         var _elem_level003  := _elem_level ;
         var _elem_kind003   := _elem_kind  ;
         var _elem_prop003   := _elem_prop  ;
         var _elem_frag003   := _elem_frag  ;
         var _attr_iter003   := _attr_iter  ;
         var _attr_qn003     := _attr_qn    ;
         var _attr_prop003   := _attr_prop  ;
         var _attr_frag003   := _attr_frag  ;
         var _attr_own003    := _attr_own   ;
         var _r_attr_iter003 := _r_attr_iter;
         var _r_attr_qn003   := _r_attr_qn  ;
         var _r_attr_prop003 := _r_attr_prop;
         var _r_attr_frag003 := _r_attr_frag; # end of saveResult_node3 () : int
         _elem_iter := _elem_iter003;
         _elem_level := _elem_level003;
         _elem_kind := _elem_kind003;
         _elem_prop := _elem_prop003;
         _elem_frag := _elem_frag003;
         var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
         rootnodes := rootnodes.leftfetchjoin(_elem_kind);
         var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
         var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
         var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
         {
          var text_prop := textnodes.leftfetchjoin(_elem_prop);
          var text_frag := textnodes.leftfetchjoin(_elem_frag);
          var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
          var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
          var input_order := res_mu_is2ns.fetch(0);
          var input_str := res_mu_is2ns.fetch(1);
          var input_const := res_mu_is2ns.fetch(2);
          var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
          var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
          var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
          var result_order := result_str.hmark(0@0);
          result_order := result_order.leftfetchjoin(input_order);
          result_str := result_str.tmark(0@0);
          iter := result_order;
          ipik := iter;
          item_str_ := result_str;
         }
         { # adding new strings to text node content and create new nodes
          var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
          var unq_str := item_str_.tunique().hmark(0@0);
          var str_unq := reverse(unq_str.tdiff(ws_prop_text));
          var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
          unq_str := str_unq.hmark(seqb);
          ws_prop_text := ws_prop_text.insert(unq_str);
          var ws_text_prop := ws_prop_text.reverse().sort();
          item_str_ := item_str_.materialize(ipik);
          var X_item := item_str_.hmark(0@0);
          var X_strings := item_str_.tmark(0@0).tsort();
          var X_prop := X_strings.leftjoin(ws_text_prop);
          var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
          newPre_prop := newPre_prop.tmark(0@0);
          _elem_iter  := iter;
          _elem_size  := newPre_prop.project(0);
          _elem_level := newPre_prop.project(chr(0));
          _elem_kind  := newPre_prop.project(TEXT);
          _elem_prop  := newPre_prop;
          _elem_frag  := newPre_prop.project(WS);
         } # end of adding new fragments to the WS_FRAG bat
         var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter003), _elem_iter.leftfetchjoin(_elem_iter003), othernodes.leftfetchjoin(_elem_size003), _elem_size, othernodes.leftfetchjoin(_elem_level003), _elem_level, othernodes.leftfetchjoin(_elem_kind003), _elem_kind, othernodes.leftfetchjoin(_elem_prop003), _elem_prop, othernodes.leftfetchjoin(_elem_frag003), _elem_frag, othernodes.leftfetchjoin(_elem_iter003.mirror()), oid(nil));
         _elem_iter := res_mu_is2ns.fetch(1).chk_order();
         _elem_size := res_mu_is2ns.fetch(2);
         _elem_level:= res_mu_is2ns.fetch(3);
         _elem_kind := res_mu_is2ns.fetch(4);
         _elem_prop := res_mu_is2ns.fetch(5);
         _elem_frag := res_mu_is2ns.fetch(6);
         var preNew_preOld := res_mu_is2ns.fetch(7);
         _attr_own := _attr_own003.leftjoin(preNew_preOld.reverse());
         _attr_iter   := _attr_iter003  ;
         _attr_qn     := _attr_qn003    ;
         _attr_prop   := _attr_prop003  ;
         _attr_frag   := _attr_frag003  ;
         _r_attr_iter := _r_attr_iter003;
         _r_attr_qn   := _r_attr_qn003  ;
         _r_attr_prop := _r_attr_prop003;
         _r_attr_frag := _r_attr_frag003;
        } # end of deleteResult_node3 ()
       } # end of item-sequence-to-node-sequence
       { # loop_liftedElemConstr (counter)
        var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
        iter_size := {count}(iter_size, iter002.tunique(), FALSE);
        var root_iter  := iter_size.hmark(0@0).chk_order();
        var root_size  := iter_size.tmark(0@0);
        var root_prop  := iter002.reverse().leftfetchjoin(item002);
        if (not(is_constant(root_prop))) {
         root_prop  := root_prop.tmark(0@0);
        }
        {
         var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
         _elem_iter  := merged_result.fetch(0);
         _elem_size  := merged_result.fetch(1);
         _elem_level := merged_result.fetch(2);
         _elem_kind  := merged_result.fetch(3);
         _elem_prop  := merged_result.fetch(4);
         _elem_frag  := merged_result.fetch(5);
         var preNew_preOld := merged_result.fetch(6);
         _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
         _attr_own := _attr_own.tmark(0@0);
        }
        { # create attribute root entries
         var root_item := _elem_level.ord_uselect(chr(0));
         root_item := root_item.hmark(0@0);
         var iter_item := iter002.reverse().leftfetchjoin(root_item);
         var attr_own := _r_attr_iter.leftjoin(iter_item);
         if (_r_attr_iter.count() != 0) { # test uniqueness
          var sorting := _r_attr_iter.tsort();
          sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
          var unq_attrs := sorting.tunique();
          if (unq_attrs.count() != _r_attr_iter.count()) {
           item002 := materialize(item002,ipik002);
           if (item002.count() > 0) {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item002.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
           } else {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
          }
         } # end of test uniqueness
         if (_attr_iter.count() = 0) {
          _attr_iter := _r_attr_iter;
          _attr_qn   := _r_attr_qn;
          _attr_prop := _r_attr_prop;
          _attr_frag := _r_attr_frag;
          _attr_own  := attr_own.tmark(0@0);
         } else {
          var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
          _r_attr_iter := _r_attr_iter.tmark(seqb);
          _r_attr_qn   := _r_attr_qn  .tmark(seqb);
          _r_attr_prop := _r_attr_prop.tmark(seqb);
          _r_attr_frag := _r_attr_frag.tmark(seqb);
          attr_own := attr_own.tmark(seqb);
          _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
          _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
          _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
          _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
          _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
         }
         _r_attr_iter := empty_bat;
         _r_attr_qn   := empty_bat;
         _r_attr_prop := empty_bat;
         _r_attr_frag := empty_bat;
        } # end of create attribute root entries
        {
         var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
         var preOld_preNew := _elem_size.mark(seqb);
         _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
         _elem_size  := _elem_size.tmark(seqb);
         _elem_level := _elem_level.tmark(seqb);
         _elem_kind  := _elem_kind.tmark(seqb);
         _elem_prop  := _elem_prop.tmark(seqb);
         _elem_frag  := _elem_frag.tmark(seqb);
        }
        ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
        ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
        ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
        ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
        ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
        {
         var knd := ELEMENT;
         while ( knd <= DOCUMENT ) {
          var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
          ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
          if ( knd = ELEMENT ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
          }
          if ( knd = PI ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
          }
          knd :+= chr(1);
         }
        }
        var roots := _elem_level.ord_uselect(chr(0));
        roots := roots.hmark(0@0);
        {
         var height := int(_elem_level.max());
         ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
        }
        { # adding new fragments to the WS_FRAG bat
         var seqb := oid(count(ws.fetch(WS_FRAG)));
         var new_pres := roots.tmark(seqb);
         ws.fetch(WS_FRAG).insert(new_pres);
        }
        iter := iter002;
        item := roots;
        kind := ELEM;
        { # add attribute subtree copies to WS
         var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
         _attr_qn   := _attr_qn  .tmark(seqb);
         _attr_prop := _attr_prop.tmark(seqb);
         _attr_own  := _attr_own .tmark(seqb);
         _attr_frag := _attr_frag.tmark(seqb);
         ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
         ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
         ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
         ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
        } # end of add attribute subtree copies to WS
       } # end of loop_liftedElemConstr (counter)
      } # end of deleteResult2 ()
     } else {
      iter := empty_bat;
      item := empty_bat;
      kind := empty_kind_bat;
     }
     if (skip = 0) {
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
     } # cleanUpLevel ()
    } # end of translateIfThen
   } # end of ifthenelse-translation
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn62BBFC16_q04_xs_string1_xs_string1_xs_string1
PROC fnB54D13A3_q05_xs_string1_xs_double1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q05
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761042@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "closed_auction");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761026@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761044@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (i)
   var vid := v_vid001.ord_uselect(1303761044@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (i)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "price");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  if (ipik.count() != 0) 
  { # for-translation
   # project ()
   iter := iter.materialize(ipik);
   var outer002 := iter;
   iter := iter.mark(1@0);
   var inner002 := iter;
   var loop002 := inner002;
   var v_vid002;
   var v_iter002;
   var v_item002;
   var v_kind002;
   var expOid;
   { # getExpanded (fid)
    var vu_nil := vu_fid.ord_uselect(1303761027@0);
    var vid_vu := vu_vid.reverse();
    var oid_nil := vid_vu.leftjoin(vu_nil);
    expOid := v_vid001.leftjoin(oid_nil);
    expOid := expOid.mirror();
   } # end of getExpanded (fid)
   if (expOid.count() != 0) {
    var oidNew_expOid;
    { # expand ()
     var expOid_iter := expOid.leftfetchjoin(v_iter001);
     var iter_expOid := expOid_iter.reverse();
     var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
     var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
     oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
     var expOid_oidMap := oidMap_expOid.reverse();
     expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
     v_iter002 := expOid_iter;
     oidNew_expOid := expOid_iter.hmark(0@0);
    } # end of expand ()
    # join ()
    var cnt := count(v_iter002)*2;
    v_iter002 := v_iter002.tmark(0@0);
    var new_v_iter := v_iter002;
    v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
    var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
    v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
    var new_v_pos ;
    var new_v_item := oidNew_expOid.leftjoin(v_item001);
    v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
    var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
    v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
   } else { # createNewVarTable ()
    v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
   }
   { # insertVar (vid)
    var vid := project(ipik,1303761045@0);
    { # append (vid, level)
     var seqb := oid(v_vid002.count());
     vid := vid.materialize(ipik);
     v_vid002 := v_vid002.insert(vid.tmark(seqb));
    } # append (vid, level)
    { # append (iter, level)
     var seqb := oid(v_iter002.count());
     iter := iter.materialize(ipik);
     v_iter002 := v_iter002.insert(iter.tmark(seqb));
    } # append (iter, level)
    { # append (pos, level)
     var seqb ;
    } # append (pos, level)
    { # append (item, level)
     var seqb := oid(v_item002.count());
     item := item.materialize(ipik);
     v_item002 := v_item002.insert(item.tmark(seqb));
    } # append (item, level)
    { # append (kind, level)
     var seqb := oid(v_kind002.count());
     kind := kind.materialize(ipik);
     v_kind002 := v_kind002.insert(kind.tmark(seqb));
    } # append (kind, level)
   } # end of insertVar (vid)
   { # translateVar (#pf:v_2796)
    var vid := v_vid002.ord_uselect(1303761045@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter002);
    item := vid.leftfetchjoin(v_item002);
    kind := vid.leftfetchjoin(v_kind002);
    ipik := iter;
   } # end of translateVar (#pf:v_2796)
   { # string-value
    var input_iter := iter;
    kind := kind.materialize(ipik);
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    var kind_elem := kind.get_type(ELEM);
    var item_str;
    if (kind_elem.count() = kind.count()) {
     var frag := kind.get_fragment();
     var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
     var t_iter := res_scj.fetch(0);
     var t_item := res_scj.fetch(1);
     var t_frag := res_scj.fetch(2);
     var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
     var t_iter_unq := t_iter.tunique();
     t_iter := t_iter.materialize(t_item);
     if (t_iter_unq.count() != t_item.count()) {
      var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
      iter_item := iter_item.string_join(t_iter_unq.project(""));
      t_iter := iter_item.hmark(0@0);
      t_item_str := iter_item.tmark(0@0);
     }
     var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
     if (c_map.count() > 0) { #process comments 
      var c_iter := c_map.leftfetchjoin(iter);
      var c_item := c_map.leftfetchjoin(item);
      var c_frag := c_map.leftfetchjoin(frag);
      var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
      var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
     } # end of comment processing
     var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
     if (pi_map.count() > 0) { #process processing-instructions 
      var pi_iter := pi_map.leftfetchjoin(iter);
      var pi_item := pi_map.leftfetchjoin(item);
      var pi_frag := pi_map.leftfetchjoin(frag);
      var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
      var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
      t_item_str := res_mu.fetch(1);
     } # end of processing-instruction processing
     iter := t_iter;
     item_str := t_item_str;
    } else {
     var kind_attr := kind.get_type(ATTR);
     if (kind_attr.count() = kind.count()) {
      var frag := kind.get_fragment();
      item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
     } else {
      kind_attr := kind_attr.hmark(0@0);
      var item_attr := kind_attr.leftfetchjoin(item);
      var iter_attr := kind_attr.leftfetchjoin(iter);
      var frag := kind_attr.leftfetchjoin(kind).get_fragment();
      var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
      kind_elem := kind_elem.hmark(0@0);
      iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
      frag := kind_elem.leftfetchjoin(kind).get_fragment();
      item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
      var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
      var t_iter := res_scj.fetch(0);
      var t_item := res_scj.fetch(1);
      var t_frag := res_scj.fetch(2);
      var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
      var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
      t_iter := iter_item.hmark(0@0);
      t_item_str := iter_item.tmark(0@0);
      var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
      iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
      {
       var item_unq := iter_item.reverse().tunique();
       if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
      }
      t_iter := iter_item.hmark(0@0);
      var t_item_str := iter_item.tmark(0@0);
      var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
      if (c_map.count() > 0) { #process comments 
       var c_iter := c_map.leftfetchjoin(iter);
       var c_item := c_map.leftfetchjoin(item);
       var c_frag := c_map.leftfetchjoin(frag);
       var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
       var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of comment processing
      var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
      if (pi_map.count() > 0) { #process processing-instructions 
       var pi_iter := pi_map.leftfetchjoin(iter);
       var pi_item := pi_map.leftfetchjoin(item);
       var pi_frag := pi_map.leftfetchjoin(frag);
       var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
       var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of processing-instruction processing
      iter := t_iter;
      item_str := t_item_str;
     }
    }
    item_str_ := item_str;
    if (iter.count() != input_iter.tunique().count()) {
     var difference := reverse(input_iter.tdiff(iter));
     difference := difference.hmark(0@0);
     var res_mu := merged_union(iter, difference, item_str_, "");
     iter := res_mu.fetch(0);
     item_str_ := res_mu.fetch(1);
    }
   } # end of string-value
   { # cast from string to untypedAtomic
    if (iter.count() != loop002.count()) {
     ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
    }
   } # end of cast from string to untypedAtomic
   { # cast from untypedAtomic to double
    var cast_val := item_str_.[dbl]();
    if (cast_val.texist(dbl(nil))) {
     ERROR ("err:FORG0001: could not cast value from string to double.");
    }
    item_dbl_ := cast_val;
    if (iter.count() != loop002.count()) {
     ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
    }
   } # end of cast from untypedAtomic to double
   { # saveResult1 () : int
    var item_dbl_001 := item_dbl_; # end of saveResult1 () : int
    { # translateVar (min)
     var vid := v_vid002.ord_uselect(1303761043@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter002);
     item := vid.leftfetchjoin(v_item002);
    } # end of translateVar (min)
    { # '>=' calculation
     var val_snd := item.leftfetchjoin(dbl_values);
     var val_fst := item_dbl_001;
     val_fst := [>=](val_fst,val_snd);
     item := val_fst.[oid]();
    } # end of '>=' calculation
   } # end of deleteResult1 ()
   { # saveResult1 () : int
    var iter001 := iter;
    var item001 := item; # end of saveResult1 () : int
    { # ifthenelse-translation
     var selected;
     var skip;
     if (type(item001) = bat) {
      selected := item001.ord_uselect(1@0);
      var cnt := selected.count();
      if (item001.count() = cnt) {
       skip := 2;
      } else {
       skip := int(cnt = 0);
      }
     } else {
      skip := 1 + int(item001); # handle constants efficiently
     }
     { # translateIfThen
      var loop003 := loop002;
      var inner003 := inner002;
      var outer003 := outer002;
      if (skip = 0) {
       iter := selected.mirror().join(iter001);
       iter := iter.tmark(0@0);
       outer003 := iter;
       iter := iter.mark(1@0);
       inner003 := iter;
       loop003 := inner003;
       var expOid ;
       var oidNew_expOid;
       { # expand ()
        var expOid_iter ;
        var iter_expOid ;
        var oidMap_expOid ; # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
        var temp_sort ;
        var expOid_oidMap ;
       } # end of expand ()
       # join ()
       var cnt ;
       var new_v_iter ;
       var new_v_vid ;
       var new_v_pos ;
       var new_v_item ;
       var new_v_kind ; # end of join ()
      }
      if (skip != 1) {
       {
        int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
        var itemID ; # translateConst (kind)
        iter := loop003.tmark(0@0);
       }
      } else {
       iter := empty_bat;
      }
      if (skip = 0) {
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
      } # cleanUpLevel ()
     } # end of translateIfThen
    } # end of ifthenelse-translation
   } # end of deleteResult1 ()
   { # mapBack ()
    var iter_oidMap := inner002.reverse();
    var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
    iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
    # kind := kind;
    # ipik := ipik;
   } # end of mapBack ()
   # cleanUpLevel ()
  } # end of for-translation
  { # translate fn:empty (item*) as boolean
   var iter_count := {count}(iter.reverse(),loop001.reverse(), FALSE);
   var iter_bool := iter_count.[=](0).[oid]();
   item := iter_bool.tmark(0@0);
   iter := loop001.tmark(0@0);
  } # end of translate fn:empty (item*) as boolean
  { # saveResult1 () : int
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # ifthenelse-translation
    var selected;
    var skip;
    if (type(item001) = bat) {
     selected := item001.ord_uselect(1@0);
     var cnt := selected.count();
     if (item001.count() = cnt) {
      skip := 2;
     } else {
      skip := int(cnt = 0);
     }
    } else {
     skip := 1 + int(item001); # handle constants efficiently
    }
    { # translateIfThen
     var inner002 := inner001;
     var outer002 := outer001;
     var v_vid002 := v_vid001;
     var v_iter002 := v_iter001;
     var v_item002 := v_item001;
     var v_kind002 := v_kind001;
     if (skip = 0) {
      selected := item001.ord_uselect(0@0);
      iter := selected.mirror().join(iter001);
      iter := iter.tmark(0@0);
      outer002 := iter;
      iter := iter.mark(1@0);
      inner002 := iter;
      var expOid := v_iter002.mirror();
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     }
     if (skip != 2) {
      { # translateVar (i)
       var vid := v_vid002.ord_uselect(1303761044@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (i)
      { # translateLocsteps (c)
       var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "price");
       iter := res_scj.fetch(0);
       item := res_scj.fetch(1);
       ipik := item;
      } # end of translateLocsteps (c)
     } else { # translateEmpty ()
      ipik := empty_bat;
      iter := empty_bat;
     }
     if (skip = 0) {
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
     } # cleanUpLevel ()
    } # end of translateIfThen
   } # end of ifthenelse-translation
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 { # translate fn:count (item*) as integer
  iter := iter.materialize(ipik);
  var iter_count := [lng]({count}(iter.reverse(),loop000.reverse(), FALSE)).tmark(0@0);
  item := int_values.addValues(iter_count).tmark(0@0);
  iter := loop000.tmark(0@0);
  kind := INT;
 } # end of translate fn:count (item*) as integer
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fnB54D13A3_q05_xs_string1_xs_double1
PROC fn679BD867_q06_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q06
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761046@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "regions");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761028@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761047@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (b)
   var vid := v_vid001.ord_uselect(1303761047@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (b)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "item");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translate fn:count (item*) as integer
   iter := iter.materialize(ipik);
   var iter_count := [lng]({count}(iter.reverse(),loop001.reverse(), FALSE)).tmark(0@0);
   item := int_values.addValues(iter_count).tmark(0@0);
   iter := loop001.tmark(0@0);
   kind := INT;
  } # end of translate fn:count (item*) as integer
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn679BD867_q06_xs_string1
PROC fn67A3F466_q07_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q07
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761048@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "site");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761029@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761049@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (p)
   var vid := v_vid001.ord_uselect(1303761049@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (p)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "description");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translate fn:count (item*) as integer
   iter := iter.materialize(ipik);
   var iter_count := [lng]({count}(iter.reverse(),loop001.reverse(), FALSE)).tmark(0@0);
   item_int_ := iter_count;
  } # end of translate fn:count (item*) as integer
  { # saveResult1 () : int
   var item_int_001 := item_int_; # end of saveResult1 () : int
   { # translateVar (p)
    var vid := v_vid001.ord_uselect(1303761049@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter001);
    item := vid.leftfetchjoin(v_item001);
    kind := vid.leftfetchjoin(v_kind001);
    ipik := iter;
   } # end of translateVar (p)
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "annotation");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    ipik := item;
   } # end of translateLocsteps (c)
   { # translate fn:count (item*) as integer
    iter := iter.materialize(ipik);
    var iter_count := [lng]({count}(iter.reverse(),loop001.reverse(), FALSE)).tmark(0@0);
    item_int_ := iter_count;
   } # end of translate fn:count (item*) as integer
   { # saveResult2 () : int
    var item_int_002 := item_int_; # end of saveResult2 () : int
    { # translateVar (p)
     var vid := v_vid001.ord_uselect(1303761049@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (p)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "emailaddress");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     ipik := item;
    } # end of translateLocsteps (c)
    { # translate fn:count (item*) as integer
     iter := iter.materialize(ipik);
     var iter_count := [lng]({count}(iter.reverse(),loop001.reverse(), FALSE)).tmark(0@0);
     item_int_ := iter_count;
     iter := loop001.tmark(0@0);
     kind := INT;
    } # end of translate fn:count (item*) as integer
    { # '+' calculation
     var val_snd := item_int_;
     var val_fst := item_int_002;
     val_fst := [+](val_fst,val_snd);
     item_int_ := val_fst;
    } # end of '+' calculation
   } # end of deleteResult2 ()
   { # '+' calculation
    var val_snd := item_int_;
    var val_fst := item_int_001;
    val_fst := [+](val_fst,val_snd);
    item := int_values.addValues(val_fst).tmark(0@0);
   } # end of '+' calculation
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn67A3F466_q07_xs_string1
PROC fn67AC1097_q08_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q08
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761050@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # insertVar (vid)
  var vid := project(ipik,1303761051@0);
  { # append (vid, level)
   var seqb := oid(v_vid000.count());
   vid := vid.materialize(ipik);
   v_vid000 := v_vid000.insert(vid.tmark(seqb));
  } # append (vid, level)
  { # append (iter, level)
   var seqb := oid(v_iter000.count());
   iter := iter.materialize(ipik);
   v_iter000 := v_iter000.insert(iter.tmark(seqb));
  } # append (iter, level)
  { # append (pos, level)
   var seqb ;
  } # append (pos, level)
  { # append (item, level)
   var seqb := oid(v_item000.count());
   item := item.materialize(ipik);
   v_item000 := v_item000.insert(item.tmark(seqb));
  } # append (item, level)
  { # append (kind, level)
   var seqb := oid(v_kind000.count());
   kind := kind.materialize(ipik);
   v_kind000 := v_kind000.insert(kind.tmark(seqb));
  } # append (kind, level)
 } # end of insertVar (vid)
 { # translateVar (auction)
  var vid := v_vid000.ord_uselect(1303761051@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  kind := vid.leftfetchjoin(v_kind000);
  ipik := iter;
 } # end of translateVar (auction)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "person");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761030@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761052@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # tagname-translation
   var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
   var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
   var itemID;
   if (prop_str.texist("item")) {
    itemID := prop_str.reverse().find("item");
   } else {
    itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
    ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
    ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
    ws.fetch(QN_LOC).fetch(WS).insert(itemID,"item");
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
    ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"item"+str('\1')+"");
   } # translateConst (kind)
   iter := loop001.tmark(0@0);
   ipik := iter;
   item := itemID;
  } # end of tagname-translation
  { # saveResult1 () : int
   var ipik001 := ipik;
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # tagname-translation
    var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
    var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    var itemID;
    if (prop_str.texist("person")) {
     itemID := prop_str.reverse().find("person");
    } else {
     itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
     ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
     ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
     ws.fetch(QN_LOC).fetch(WS).insert(itemID,"person");
     ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
     ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"person"+str('\1')+"");
    } # translateConst (kind)
    iter := loop001.tmark(0@0);
    ipik := iter;
    item := itemID;
   } # end of tagname-translation
   { # saveResult2 () : int
    var ipik002 := ipik;
    var iter002 := iter;
    var item002 := item; # end of saveResult2 () : int
    { # translateVar (p)
     var vid := v_vid001.ord_uselect(1303761052@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (p)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    if (ipik.count() != 0) 
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer002 := iter;
     iter := iter.mark(1@0);
     var inner002 := iter;
     var v_vid002;
     var v_iter002;
     var v_item002;
     var v_kind002;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(1303761031@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid001.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     } else { # createNewVarTable ()
      v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,1303761053@0);
      { # append (vid, level)
       var seqb := oid(v_vid002.count());
       vid := vid.materialize(ipik);
       v_vid002 := v_vid002.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter002.count());
       iter := iter.materialize(ipik);
       v_iter002 := v_iter002.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb ;
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item002.count());
       item := item.materialize(ipik);
       v_item002 := v_item002.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb := oid(v_kind002.count());
       kind := kind.materialize(ipik);
       v_kind002 := v_kind002.insert(kind.tmark(seqb));
      } # append (kind, level)
     } # end of insertVar (vid)
     { # translateVar (#pf:v_930)
      var vid := v_vid002.ord_uselect(1303761053@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter002);
      item := vid.leftfetchjoin(v_item002);
      kind := vid.leftfetchjoin(v_kind002);
      ipik := iter;
     } # end of translateVar (#pf:v_930)
     { # string-value
      var input_iter := iter;
      kind := kind.materialize(ipik);
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      var kind_elem := kind.get_type(ELEM);
      var item_str;
      if (kind_elem.count() = kind.count()) {
       var frag := kind.get_fragment();
       var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
       var t_iter := res_scj.fetch(0);
       var t_item := res_scj.fetch(1);
       var t_frag := res_scj.fetch(2);
       var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var t_iter_unq := t_iter.tunique();
       t_iter := t_iter.materialize(t_item);
       if (t_iter_unq.count() != t_item.count()) {
        var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
        iter_item := iter_item.string_join(t_iter_unq.project(""));
        t_iter := iter_item.hmark(0@0);
        t_item_str := iter_item.tmark(0@0);
       }
       var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
       if (c_map.count() > 0) { #process comments 
        var c_iter := c_map.leftfetchjoin(iter);
        var c_item := c_map.leftfetchjoin(item);
        var c_frag := c_map.leftfetchjoin(frag);
        var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
        var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of comment processing
       var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
       if (pi_map.count() > 0) { #process processing-instructions 
        var pi_iter := pi_map.leftfetchjoin(iter);
        var pi_item := pi_map.leftfetchjoin(item);
        var pi_frag := pi_map.leftfetchjoin(frag);
        var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
        var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
        t_item_str := res_mu.fetch(1);
       } # end of processing-instruction processing
       iter := t_iter;
       item_str := t_item_str;
      } else {
       var kind_attr := kind.get_type(ATTR);
       if (kind_attr.count() = kind.count()) {
        var frag := kind.get_fragment();
        item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
       } else {
        kind_attr := kind_attr.hmark(0@0);
        var item_attr := kind_attr.leftfetchjoin(item);
        var iter_attr := kind_attr.leftfetchjoin(iter);
        var frag := kind_attr.leftfetchjoin(kind).get_fragment();
        var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        kind_elem := kind_elem.hmark(0@0);
        iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
        frag := kind_elem.leftfetchjoin(kind).get_fragment();
        item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
        t_iter := iter_item.hmark(0@0);
        t_item_str := iter_item.tmark(0@0);
        var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
        iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
        {
         var item_unq := iter_item.reverse().tunique();
         if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
        }
        t_iter := iter_item.hmark(0@0);
        var t_item_str := iter_item.tmark(0@0);
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       }
      }
      item_str_ := item_str;
      if (iter.count() != input_iter.tunique().count()) {
       var difference := reverse(input_iter.tdiff(iter));
       difference := difference.hmark(0@0);
       var res_mu := merged_union(iter, difference, item_str_, "");
       iter := res_mu.fetch(0);
       item_str_ := res_mu.fetch(1);
      }
      ipik := iter;
     } # end of string-value
     { # mapBack ()
      var iter_oidMap := inner002.reverse();
      var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
      iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
      # kind := kind;
      # ipik := ipik;
     } # end of mapBack ()
     # cleanUpLevel ()
    } # end of for-translation
    { # saveResult3 () : int
     var ipik003 := ipik;
     var iter003 := iter;
     var item_str_003 := item_str_; # end of saveResult3 () : int
     iter := loop001.tmark(0@0);
     ipik := iter;
     item_str_ := " ";
     { # string-join (string*, string)
      var iter_item_str := iter003.materialize(ipik003).reverse();
      iter_item_str := iter_item_str.leftfetchjoin(item_str_003).materialize(iter_item_str).chk_order();
      var iter_sep_str := iter.materialize(ipik).reverse();
      iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
      iter_item_str := string_join(iter_item_str, iter_sep_str);
      iter := iter_item_str.hmark(0@0);
      iter_item_str := iter_item_str.tmark(0@0);
      item_str_ := iter_item_str;
     } # end of string-join (string*, string)
    } # end of deleteResult3 ()
    { # loop_liftedAttrConstr (int i)
     if (iter002.count() != loop001.count()) {
      ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
     }
     if (iter.count() != loop001.count()) {
      var difference := reverse(loop001.tdiff(iter));
      difference := difference.hmark(0@0);
      var res_mu := merged_union(iter, difference, item_str_, "");
      item_str_ := res_mu.fetch(1);
     }
     var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
     var unq := item_str_.tunique().hmark(0@0);
     var unq_str := unq;
     var str_unq := reverse(unq_str.tdiff(ws_prop_val));
     var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
     unq_str := str_unq.hmark(seqb);
     ws_prop_val := ws_prop_val.insert(unq_str);
     var strings := item_str_.materialize(loop001);
     var attr_oid := strings.leftjoin(ws_prop_val.reverse());
     { # translateEmpty_node ()
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of translateEmpty_node ()
     attr_oid := attr_oid.tmark(0@0);
     _r_attr_iter := iter002;
     _r_attr_qn   := item002.materialize(ipik002);
     _r_attr_prop := attr_oid;
     _r_attr_frag := attr_oid.project(WS);
    } # end of loop_liftedAttrConstr (int i)
   } # end of deleteResult2 ()
   { # saveResult_node2 () : int
    var _elem_iter002   := _elem_iter  ;
    var _elem_size002   := _elem_size  ;
    var _elem_level002  := _elem_level ;
    var _elem_kind002   := _elem_kind  ;
    var _elem_prop002   := _elem_prop  ;
    var _elem_frag002   := _elem_frag  ;
    var _attr_iter002   := _attr_iter  ;
    var _attr_qn002     := _attr_qn    ;
    var _attr_prop002   := _attr_prop  ;
    var _attr_frag002   := _attr_frag  ;
    var _attr_own002    := _attr_own   ;
    var _r_attr_iter002 := _r_attr_iter;
    var _r_attr_qn002   := _r_attr_qn  ;
    var _r_attr_prop002 := _r_attr_prop;
    var _r_attr_frag002 := _r_attr_frag; # end of saveResult_node2 () : int
    {
     var iter003;
     var item003;
     var kind003;
     var ipik004;
     var iter004;
     var item004;
     var match_outer004;
     var ipik005;
     var iter005;
     var item005;
     var match_outer005;
     var jouter004 ;
     var jorder_004 ;
     var jinner004 ;
     var jloop004  ;
     var jv_vid004 ;
     var jv_iter004;
     var jv_pos004 ;
     var jv_item004;
     var jv_kind004;
     { # translateVar (p)
      var vid := v_vid001.ord_uselect(1303761052@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (p)
     { # loop_liftedSCJ (axis, kind, ns, loc)
      { # attribute axis
       var oid_iter := iter;
       var oid_item := item.materialize(ipik);
       var oid_frag := kind.get_fragment();
       var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
       oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
       var oid_attr := temp1.tmark(0@0);
       oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
       var temp1_str; # only needed for name test
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
       temp1 := temp1_str.ord_uselect("");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
       temp1 := temp1_str.ord_uselect("id");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       iter := oid_iter.tmark(0@0);
       item := oid_attr.tmark(0@0);
       kind := oid_frag.tmark(0@0);
       if (type(iter) = bat) {
        ipik := iter;
       } else {
        if (type(item) = bat) {
         ipik := item;
        } else {
         ipik := kind;
        }
       }
      } # end of attribute axis
      kind := kind.set_kind(ATTR);
     } # end of translateLocsteps (c)
     if (ipik.count() != 0) 
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      var loop002 := inner002;
      var v_vid002;
      var v_iter002;
      var v_item002;
      var v_kind002;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761032@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761054@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (#pf:v_2800)
       var vid := v_vid002.ord_uselect(1303761054@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (#pf:v_2800)
      { # string-value
       var input_iter := iter;
       kind := kind.materialize(ipik);
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       var kind_elem := kind.get_type(ELEM);
       var item_str;
       if (kind_elem.count() = kind.count()) {
        var frag := kind.get_fragment();
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var t_iter_unq := t_iter.tunique();
        t_iter := t_iter.materialize(t_item);
        if (t_iter_unq.count() != t_item.count()) {
         var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         iter_item := iter_item.string_join(t_iter_unq.project(""));
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
        }
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       } else {
        var kind_attr := kind.get_type(ATTR);
        if (kind_attr.count() = kind.count()) {
         var frag := kind.get_fragment();
         item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        } else {
         kind_attr := kind_attr.hmark(0@0);
         var item_attr := kind_attr.leftfetchjoin(item);
         var iter_attr := kind_attr.leftfetchjoin(iter);
         var frag := kind_attr.leftfetchjoin(kind).get_fragment();
         var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         kind_elem := kind_elem.hmark(0@0);
         iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
         frag := kind_elem.leftfetchjoin(kind).get_fragment();
         item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
         var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
         iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         {
          var item_unq := iter_item.reverse().tunique();
          if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
         }
         t_iter := iter_item.hmark(0@0);
         var t_item_str := iter_item.tmark(0@0);
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        }
       }
       item_str_ := item_str;
       if (iter.count() != input_iter.tunique().count()) {
        var difference := reverse(input_iter.tdiff(iter));
        difference := difference.hmark(0@0);
        var res_mu := merged_union(iter, difference, item_str_, "");
        iter := res_mu.fetch(0);
        item_str_ := res_mu.fetch(1);
       }
       ipik := iter;
      } # end of string-value
      { # cast from string to untypedAtomic
       if (iter.count() != loop002.count()) {
        ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
       }
      } # end of cast from string to untypedAtomic
      { # cast from untypedAtomic to string
       if (iter.count() != loop002.count()) {
        ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
       }
      } # end of cast from untypedAtomic to string
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
     {
      var mapping := outer000.reverse().leftfetchjoin(inner000);
      mapping := mapping.leftjoin(outer001.reverse());
      mapping := mapping.leftfetchjoin(inner001);
      match_outer004 := iter.leftjoin(mapping.reverse()).tmark(iter.seqbase());
     }
     ipik004 := ipik;
     iter004 := iter;
     item004 := item_str_;
     jouter004  := outer001 ;
     jinner004  := inner001 ;
     jloop004   := loop001  ;
     v_vid001  := v_vid000 .copy().access(BAT_WRITE);
     v_iter001 := v_iter000.copy().access(BAT_WRITE);
     v_item001 := v_item000.copy().access(BAT_WRITE);
     v_kind001 := v_kind000.copy().access(BAT_WRITE);
     { # translateVar (auction)
      var vid := v_vid001.ord_uselect(1303761051@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (auction)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "closed_auction");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      var v_vid002;
      var v_iter002;
      var v_item002;
      var v_kind002;
      iter003 := iter;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761033@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761055@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (t)
       var vid := v_vid002.ord_uselect(1303761055@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (t)
      { # translateLocsteps (c)
       var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "buyer");
       iter := res_scj.fetch(0);
       item := res_scj.fetch(1);
       kind := res_scj.fetch(2).set_kind(ELEM);
       ipik := item;
      } # end of translateLocsteps (c)
      { # loop_liftedSCJ (axis, kind, ns, loc)
       { # attribute axis
        var oid_iter := iter;
        var oid_item := item.materialize(ipik);
        var oid_frag := kind.get_fragment();
        var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
        oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
        var oid_attr := temp1.tmark(0@0);
        oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
        var temp1_str; # only needed for name test
        temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
        temp1 := temp1_str.ord_uselect("");
        temp1 := temp1.hmark(0@0);
        oid_attr := temp1.leftfetchjoin(oid_attr);
        oid_frag := temp1.leftfetchjoin(oid_frag);
        oid_iter := temp1.leftfetchjoin(oid_iter);
        temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
        temp1 := temp1_str.ord_uselect("person");
        temp1 := temp1.hmark(0@0);
        oid_attr := temp1.leftfetchjoin(oid_attr);
        oid_frag := temp1.leftfetchjoin(oid_frag);
        oid_iter := temp1.leftfetchjoin(oid_iter);
        iter := oid_iter.tmark(0@0);
        item := oid_attr.tmark(0@0);
        kind := oid_frag.tmark(0@0);
        if (type(iter) = bat) {
         ipik := iter;
        } else {
         if (type(item) = bat) {
          ipik := item;
         } else {
          ipik := kind;
         }
        }
       } # end of attribute axis
       kind := kind.set_kind(ATTR);
      } # end of translateLocsteps (c)
      if (ipik.count() != 0) 
      { # for-translation
       # project ()
       iter := iter.materialize(ipik);
       var outer003 := iter;
       iter := iter.mark(1@0);
       var inner003 := iter;
       var loop003 := inner003;
       var v_vid003;
       var v_iter003;
       var v_item003;
       var v_kind003;
       var expOid;
       { # getExpanded (fid)
        var vu_nil := vu_fid.ord_uselect(1303761034@0);
        var vid_vu := vu_vid.reverse();
        var oid_nil := vid_vu.leftjoin(vu_nil);
        expOid := v_vid002.leftjoin(oid_nil);
        expOid := expOid.mirror();
       } # end of getExpanded (fid)
       if (expOid.count() != 0) {
        var oidNew_expOid;
        { # expand ()
         var expOid_iter := expOid.leftfetchjoin(v_iter002);
         var iter_expOid := expOid_iter.reverse();
         var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
         var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
         oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
         var expOid_oidMap := oidMap_expOid.reverse();
         expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
         v_iter003 := expOid_iter;
         oidNew_expOid := expOid_iter.hmark(0@0);
        } # end of expand ()
        # join ()
        var cnt := count(v_iter003)*2;
        v_iter003 := v_iter003.tmark(0@0);
        var new_v_iter := v_iter003;
        v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
        var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
        v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
        var new_v_pos ;
        var new_v_item := oidNew_expOid.leftjoin(v_item002);
        v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
        var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
        v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
       } else { # createNewVarTable ()
        v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
       }
       { # insertVar (vid)
        var vid := project(ipik,1303761056@0);
        { # append (vid, level)
         var seqb := oid(v_vid003.count());
         vid := vid.materialize(ipik);
         v_vid003 := v_vid003.insert(vid.tmark(seqb));
        } # append (vid, level)
        { # append (iter, level)
         var seqb := oid(v_iter003.count());
         iter := iter.materialize(ipik);
         v_iter003 := v_iter003.insert(iter.tmark(seqb));
        } # append (iter, level)
        { # append (pos, level)
         var seqb ;
        } # append (pos, level)
        { # append (item, level)
         var seqb := oid(v_item003.count());
         item := item.materialize(ipik);
         v_item003 := v_item003.insert(item.tmark(seqb));
        } # append (item, level)
        { # append (kind, level)
         var seqb := oid(v_kind003.count());
         kind := kind.materialize(ipik);
         v_kind003 := v_kind003.insert(kind.tmark(seqb));
        } # append (kind, level)
       } # end of insertVar (vid)
       { # translateVar (#pf:v_2798)
        var vid := v_vid003.ord_uselect(1303761056@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter003);
        item := vid.leftfetchjoin(v_item003);
        kind := vid.leftfetchjoin(v_kind003);
        ipik := iter;
       } # end of translateVar (#pf:v_2798)
       { # string-value
        var input_iter := iter;
        kind := kind.materialize(ipik);
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        var kind_elem := kind.get_type(ELEM);
        var item_str;
        if (kind_elem.count() = kind.count()) {
         var frag := kind.get_fragment();
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var t_iter_unq := t_iter.tunique();
         t_iter := t_iter.materialize(t_item);
         if (t_iter_unq.count() != t_item.count()) {
          var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          iter_item := iter_item.string_join(t_iter_unq.project(""));
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
         }
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        } else {
         var kind_attr := kind.get_type(ATTR);
         if (kind_attr.count() = kind.count()) {
          var frag := kind.get_fragment();
          item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         } else {
          kind_attr := kind_attr.hmark(0@0);
          var item_attr := kind_attr.leftfetchjoin(item);
          var iter_attr := kind_attr.leftfetchjoin(iter);
          var frag := kind_attr.leftfetchjoin(kind).get_fragment();
          var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
          kind_elem := kind_elem.hmark(0@0);
          iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
          frag := kind_elem.leftfetchjoin(kind).get_fragment();
          item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
          var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
          var t_iter := res_scj.fetch(0);
          var t_item := res_scj.fetch(1);
          var t_frag := res_scj.fetch(2);
          var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
          var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
          var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
          iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          {
           var item_unq := iter_item.reverse().tunique();
           if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
          }
          t_iter := iter_item.hmark(0@0);
          var t_item_str := iter_item.tmark(0@0);
          var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
          if (c_map.count() > 0) { #process comments 
           var c_iter := c_map.leftfetchjoin(iter);
           var c_item := c_map.leftfetchjoin(item);
           var c_frag := c_map.leftfetchjoin(frag);
           var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
           var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of comment processing
          var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
          if (pi_map.count() > 0) { #process processing-instructions 
           var pi_iter := pi_map.leftfetchjoin(iter);
           var pi_item := pi_map.leftfetchjoin(item);
           var pi_frag := pi_map.leftfetchjoin(frag);
           var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
           var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of processing-instruction processing
          iter := t_iter;
          item_str := t_item_str;
         }
        }
        item_str_ := item_str;
        if (iter.count() != input_iter.tunique().count()) {
         var difference := reverse(input_iter.tdiff(iter));
         difference := difference.hmark(0@0);
         var res_mu := merged_union(iter, difference, item_str_, "");
         iter := res_mu.fetch(0);
         item_str_ := res_mu.fetch(1);
        }
        ipik := iter;
       } # end of string-value
       { # cast from string to untypedAtomic
        if (iter.count() != loop003.count()) {
         ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
        }
       } # end of cast from string to untypedAtomic
       { # cast from untypedAtomic to string
        if (iter.count() != loop003.count()) {
         ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
        }
       } # end of cast from untypedAtomic to string
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
       # cleanUpLevel ()
      } # end of for-translation
      ipik005 := ipik;
      iter005 := iter;
      item005 := item_str_;
      match_outer005 := iter.leftfetchjoin(inner002.reverse()).leftfetchjoin(outer002); # cleanUpLevel ()
     } # end of for-translation
     outer001  := jouter004 ;
     inner001  := jinner004 ;
     loop001   := jloop004  ;
     var join_item1 := item004;
     var join_item2 := item005;
     join_item1 := join_item1.materialize(ipik004);
     join_item1 := join_item1.reverse().leftfetchjoin(iter004).reverse();
     join_item2 := join_item2.materialize(ipik005);
     join_item2 := join_item2.reverse().leftfetchjoin(iter005).reverse();
     var join_result := ll_htordered_unique_thetajoin(EQ, join_item1, join_item2, match_outer004, match_outer005,nil,iter003.reverse());
     var snd_iter ;
     var fst_iter := join_result.hmark(0@0);
     ipik := fst_iter; # order_fst isn't needed until now
     # (cannot be pushed below the theta-join due to the 'iter := fst_iter;' hereafter)
     # var order_fst := fst_iter.leftfetchjoin(inner001.reverse());
     var order_snd ; #.leftfetchjoin(iter003.reverse()); pushed below theta-join
     iter := fst_iter;
    } # end of evaluate_join
    { # translate fn:count (item*) as integer
     iter := iter.materialize(ipik);
     var iter_count := [lng]({count}(iter.reverse(),loop001.reverse(), FALSE)).tmark(0@0);
     item := int_values.addValues(iter_count).tmark(0@0);
     iter := loop001.tmark(0@0);
     ipik := iter;
     kind := INT;
    } # end of translate fn:count (item*) as integer
    { # saveResult3 () : int
     var ipik003 := ipik;
     var iter003 := iter;
     var item003 := item;
     var kind003 := kind; # end of saveResult3 () : int
     { # item-sequence-to-node-sequence
      var nodes_order;
      {
       ipik := ipik003;
       item := item003;
       kind := kind003;
       kind := kind.materialize(ipik);
       var elem := kind.get_type(ELEM);
       elem := elem.hmark(0@0);
       var kind_elem := elem.leftfetchjoin(kind);
       var frag_elem := kind_elem.get_fragment();
       var item_elem := elem.leftfetchjoin(item).materialize(elem);
       var kind_node := mposjoin (item_elem, frag_elem, ws.fetch(PRE_KIND));
       var text := kind_node.ord_uselect(TEXT).hmark(0@0);
       var item_text := text.leftfetchjoin(item_elem);
       var frag_text := text.leftfetchjoin(frag_elem);
       var text_str := mposjoin (mposjoin (item_text, frag_text, ws.fetch(PRE_PROP)), mposjoin (item_text, frag_text, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var str_text := text_str.reverse().leftfetchjoin(text);
       var texts := str_text.leftfetchjoin(elem).reverse();
       var texts_order := texts.hmark(0@0);
       texts := texts.tmark(0@0);
       var nodes := kind_node.[!=](TEXT).ord_uselect(true).project("");
       nodes := nodes.reverse().leftfetchjoin(elem).reverse();
       nodes_order := nodes.hmark(0@0);
       nodes := nodes.tmark(0@0);
       var res_mu_is2ns := merged_union (nodes_order, texts_order, nodes, texts, 0@0, 1@0);
       var input_order := res_mu_is2ns.fetch(0);
       var input_str := res_mu_is2ns.fetch(1);
       var input_const := res_mu_is2ns.fetch(2);
       kind := kind.materialize(ipik);
       var atomic := kind.get_type_atomic();
       atomic := atomic.hmark(0@0);
       item := atomic.leftfetchjoin(item);
       var cast_val := item.leftfetchjoin(int_values).[str]();
       if (cast_val.texist(str(nil))) {
        ERROR ("err:FORG0001: could not cast value from integer to string.");
       }
       item_str_ := cast_val;
       res_mu_is2ns := merged_union (input_order, atomic, input_str, item_str_, input_const, 2@0);
       input_order := res_mu_is2ns.fetch(0);
       input_str := res_mu_is2ns.fetch(1);
       input_const := res_mu_is2ns.fetch(2);
       var input_iter := input_order.leftfetchjoin(iter003).chk_order();
       var result_size := iter003.tunique().count() + nodes_order.count() + 1;
       var result_str := combine_text_string (input_iter.materialize(input_str), input_const.materialize(input_str), input_str, result_size);
       var result_order := result_str.hmark(0@0);
       result_order := result_order.leftfetchjoin(input_order);
       result_str := result_str.tmark(0@0);
       iter := result_order;
       ipik := iter;
       item_str_ := result_str;
      }
      { # adding new strings to text node content and create new nodes
       var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
       var unq_str := item_str_.tunique().hmark(0@0);
       var str_unq := reverse(unq_str.tdiff(ws_prop_text));
       var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
       unq_str := str_unq.hmark(seqb);
       ws_prop_text := ws_prop_text.insert(unq_str);
       var ws_text_prop := ws_prop_text.reverse().sort();
       item_str_ := item_str_.materialize(ipik);
       var X_item := item_str_.hmark(0@0);
       var X_strings := item_str_.tmark(0@0).tsort();
       var X_prop := X_strings.leftjoin(ws_text_prop);
       var newPre_prop := X_item.reverse().leftjoin(X_prop);
       seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS))+ int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
       newPre_prop := newPre_prop.tmark(seqb);
       ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
       ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
       ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
       ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
       ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));
       {
        var kind_pre_ := newPre_prop.hmark(nil).chk_order();
        ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
       }
       item := item_str_.mark(seqb);
       kind := ELEM;
      } # end of adding new strings to text node content and create new nodes
      { # adding new fragments to the WS_FRAG bat
       var seqb := ws.fetch(WS_FRAG).count();
       seqb := oid(seqb);
       var new_pres := item.tmark(seqb);
       ws.fetch(WS_FRAG).insert(new_pres);
       ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
      } # end of adding new fragments to the WS_FRAG bat
      var res_mu_is2ns := merged_union (iter, nodes_order, item, nodes_order.leftfetchjoin(item003), kind, nodes_order.leftfetchjoin(kind003));
      kind003 := kind003.materialize(ipik003);
      var attr := kind003.get_type(ATTR).hmark(0@0);
      var item_attr := attr.leftfetchjoin(item003);
      var kind_attr := attr.leftfetchjoin(kind003);
      res_mu_is2ns := merged_union (res_mu_is2ns.fetch(0), attr, res_mu_is2ns.fetch(1), item_attr, res_mu_is2ns.fetch(2), kind_attr);
      iter := res_mu_is2ns.fetch(0).leftfetchjoin(iter003);
      item := res_mu_is2ns.fetch(1);
      kind := res_mu_is2ns.fetch(2);
      ipik := item;
     } # end of item-sequence-to-node-sequence
    } # end of deleteResult3 ()
    { # map2NODE_interface (counter)
     kind := kind.materialize(ipik);
     var attr := kind.get_type(ATTR).hmark(0@0);
     var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
     var attr_item := attr.leftfetchjoin(item);
     var attr_frag := attr.leftfetchjoin(kind).get_fragment();
     _r_attr_iter := attr_iter;
     _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
     _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
     _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
     var nodes := kind.get_type(ELEM);
     if (nodes.count() != 0) {
      var oid_oid := nodes.hmark(0@0);
      var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
      var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
      var iter_input := oid_oid.mirror();
      var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
      var res_iter := res_scj.fetch(0);
      var res_item := res_scj.fetch(1);
      var res_frag := res_scj.fetch(2);
      _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
      _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
      _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
      _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
      _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
      var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
      var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
      nodes := res_item.mark(0@0);
      var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      root_level := nodes.leftfetchjoin(root_level);
      temp_ec_item := res_item;
      temp_ec_frag := res_frag;
      var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      content_level := nodes.leftfetchjoin(content_level);
      content_level := content_level.[-](root_level);
      content_level := content_level.tmark(0@0);
      _elem_level := content_level;
      { # create attribute subtree copies
       var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
       var oid_attr := temp_attr.tmark(0@0);
       var oid_frag;
       if (is_constant(res_frag)) {
        oid_frag := res_frag;
       } else {
        oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
        oid_frag := oid_frag.tmark(0@0);
       }
       _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
       _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
       _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
       _attr_own  := temp_attr.hmark(0@0);
       _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
      } # end of create attribute subtree copies
     } else { # if (nodes.count() != 0) ...
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of else in 'if (nodes.count() != 0)'
    } # end of map2NODE_interface (counter)
    # translateSeq_node (f, counter)
    if (_r_attr_iter.count() = 0) {
     _r_attr_iter := _r_attr_iter002;
     _r_attr_qn := _r_attr_qn002;
     _r_attr_prop := _r_attr_prop002;
     _r_attr_frag := _r_attr_frag002;
    } else {
     if (_r_attr_iter002.count() != 0) 
     { # combine attribute roots
      var merged_result := merged_union (_r_attr_iter002.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn002, _r_attr_qn, _r_attr_prop002, _r_attr_prop, _r_attr_frag002, _r_attr_frag);
      _r_attr_iter := merged_result.fetch(0);
      _r_attr_qn := merged_result.fetch(1);
      _r_attr_prop := merged_result.fetch(2);
      _r_attr_frag := merged_result.fetch(3);
     }
    } # end of combine attribute roots
    if (_elem_iter.count() = 0) {
     _elem_iter  := _elem_iter002  ;
     _elem_size  := _elem_size002  ;
     _elem_level := _elem_level002 ;
     _elem_kind  := _elem_kind002  ;
     _elem_prop  := _elem_prop002  ;
     _elem_frag  := _elem_frag002  ;
     _attr_iter  := _attr_iter002  ;
     _attr_qn    := _attr_qn002    ;
     _attr_prop  := _attr_prop002  ;
     _attr_frag  := _attr_frag002  ;
     _attr_own   := _attr_own002   ;
    } else {
     if (_elem_iter002.count() != 0) 
     { # combine element nodes
      var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
      var shift_factor := int(seqb) - int(_elem_size002.seqbase());
      var merged_result := merged_union (_elem_iter002.chk_order(), _elem_iter.chk_order(), _elem_size002, _elem_size, _elem_level002, _elem_level, _elem_kind002, _elem_kind, _elem_prop002, _elem_prop, _elem_frag002, _elem_frag, _elem_size002.mark(seqb), _elem_size.mirror());
      _elem_iter := merged_result.fetch(0);
      _elem_size := merged_result.fetch(1);
      _elem_level:= merged_result.fetch(2);
      _elem_kind := merged_result.fetch(3);
      _elem_prop := merged_result.fetch(4);
      _elem_frag := merged_result.fetch(5);
      var preNew_preOld := merged_result.fetch(6);
      _attr_own002 := _attr_own002.[int]().[+](shift_factor).[oid]();
      merged_result := merged_union (_attr_iter002, _attr_iter, _attr_qn002, _attr_qn, _attr_prop002, _attr_prop, _attr_frag002, _attr_frag, _attr_own002, _attr_own);
      _attr_iter := merged_result.fetch(0);
      _attr_qn   := merged_result.fetch(1);
      _attr_prop := merged_result.fetch(2);
      _attr_frag := merged_result.fetch(3);
      _attr_own  := merged_result.fetch(4);
      _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
      _attr_own := _attr_own.tmark(0@0);
     }
    } # combine element nodes
    # end of translateSeq_node (f, counter)
   } # end of deleteResult_node2 ()
   { # loop_liftedElemConstr (counter)
    var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
    iter_size := {count}(iter_size, iter001.tunique(), FALSE);
    var root_iter  := iter_size.hmark(0@0).chk_order();
    var root_size  := iter_size.tmark(0@0);
    var root_prop  := iter001.reverse().leftfetchjoin(item001);
    if (not(is_constant(root_prop))) {
     root_prop  := root_prop.tmark(0@0);
    }
    {
     var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
     _elem_iter  := merged_result.fetch(0);
     _elem_size  := merged_result.fetch(1);
     _elem_level := merged_result.fetch(2);
     _elem_kind  := merged_result.fetch(3);
     _elem_prop  := merged_result.fetch(4);
     _elem_frag  := merged_result.fetch(5);
     var preNew_preOld := merged_result.fetch(6);
     _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
     _attr_own := _attr_own.tmark(0@0);
    }
    { # create attribute root entries
     var root_item := _elem_level.ord_uselect(chr(0));
     root_item := root_item.hmark(0@0);
     var iter_item := iter001.reverse().leftfetchjoin(root_item);
     var attr_own := _r_attr_iter.leftjoin(iter_item);
     if (_r_attr_iter.count() != 0) { # test uniqueness
      var sorting := _r_attr_iter.tsort();
      sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
      var unq_attrs := sorting.tunique();
      if (unq_attrs.count() != _r_attr_iter.count()) {
       item001 := materialize(item001,ipik001);
       if (item001.count() > 0) {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item001.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
       } else {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
       }
      }
     } # end of test uniqueness
     if (_attr_iter.count() = 0) {
      _attr_iter := _r_attr_iter;
      _attr_qn   := _r_attr_qn;
      _attr_prop := _r_attr_prop;
      _attr_frag := _r_attr_frag;
      _attr_own  := attr_own.tmark(0@0);
     } else {
      var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
      _r_attr_iter := _r_attr_iter.tmark(seqb);
      _r_attr_qn   := _r_attr_qn  .tmark(seqb);
      _r_attr_prop := _r_attr_prop.tmark(seqb);
      _r_attr_frag := _r_attr_frag.tmark(seqb);
      attr_own := attr_own.tmark(seqb);
      _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
      _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
      _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
      _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
      _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
     }
     _r_attr_iter := empty_bat;
     _r_attr_qn   := empty_bat;
     _r_attr_prop := empty_bat;
     _r_attr_frag := empty_bat;
    } # end of create attribute root entries
    {
     var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
     var preOld_preNew := _elem_size.mark(seqb);
     _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
     _elem_size  := _elem_size.tmark(seqb);
     _elem_level := _elem_level.tmark(seqb);
     _elem_kind  := _elem_kind.tmark(seqb);
     _elem_prop  := _elem_prop.tmark(seqb);
     _elem_frag  := _elem_frag.tmark(seqb);
    }
    ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
    ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
    ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
    ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
    ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
    {
     var knd := ELEMENT;
     while ( knd <= DOCUMENT ) {
      var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
      ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
      if ( knd = ELEMENT ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
      }
      if ( knd = PI ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
      }
      knd :+= chr(1);
     }
    }
    var roots := _elem_level.ord_uselect(chr(0));
    roots := roots.hmark(0@0);
    {
     var height := int(_elem_level.max());
     ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
    }
    { # adding new fragments to the WS_FRAG bat
     var seqb := oid(count(ws.fetch(WS_FRAG)));
     var new_pres := roots.tmark(seqb);
     ws.fetch(WS_FRAG).insert(new_pres);
    }
    iter := iter001;
    item := roots;
    kind := ELEM;
    { # add attribute subtree copies to WS
     var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
     _attr_qn   := _attr_qn  .tmark(seqb);
     _attr_prop := _attr_prop.tmark(seqb);
     _attr_own  := _attr_own .tmark(seqb);
     _attr_frag := _attr_frag.tmark(seqb);
     ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
     ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
     ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
     ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
    } # end of add attribute subtree copies to WS
   } # end of loop_liftedElemConstr (counter)
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn67AC1097_q08_xs_string1
PROC fn67B42CFE_q09_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q09
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761057@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # insertVar (vid)
  var vid := project(ipik,1303761058@0);
  { # append (vid, level)
   var seqb := oid(v_vid000.count());
   vid := vid.materialize(ipik);
   v_vid000 := v_vid000.insert(vid.tmark(seqb));
  } # append (vid, level)
  { # append (iter, level)
   var seqb := oid(v_iter000.count());
   iter := iter.materialize(ipik);
   v_iter000 := v_iter000.insert(iter.tmark(seqb));
  } # append (iter, level)
  { # append (pos, level)
   var seqb ;
  } # append (pos, level)
  { # append (item, level)
   var seqb := oid(v_item000.count());
   item := item.materialize(ipik);
   v_item000 := v_item000.insert(item.tmark(seqb));
  } # append (item, level)
  { # append (kind, level)
   var seqb := oid(v_kind000.count());
   kind := kind.materialize(ipik);
   v_kind000 := v_kind000.insert(kind.tmark(seqb));
  } # append (kind, level)
 } # end of insertVar (vid)
 { # translateVar (auction)
  var vid := v_vid000.ord_uselect(1303761058@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  kind := vid.leftfetchjoin(v_kind000);
  ipik := iter;
 } # end of translateVar (auction)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "person");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761036@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761059@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # tagname-translation
   var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
   var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
   var itemID;
   if (prop_str.texist("person")) {
    itemID := prop_str.reverse().find("person");
   } else {
    itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
    ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
    ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
    ws.fetch(QN_LOC).fetch(WS).insert(itemID,"person");
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
    ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"person"+str('\1')+"");
   } # translateConst (kind)
   iter := loop001.tmark(0@0);
   ipik := iter;
   item := itemID;
  } # end of tagname-translation
  { # saveResult1 () : int
   var ipik001 := ipik;
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # tagname-translation
    var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
    var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    var itemID;
    if (prop_str.texist("name")) {
     itemID := prop_str.reverse().find("name");
    } else {
     itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
     ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
     ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
     ws.fetch(QN_LOC).fetch(WS).insert(itemID,"name");
     ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
     ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"name"+str('\1')+"");
    } # translateConst (kind)
    iter := loop001.tmark(0@0);
    ipik := iter;
    item := itemID;
   } # end of tagname-translation
   { # saveResult2 () : int
    var ipik002 := ipik;
    var iter002 := iter;
    var item002 := item; # end of saveResult2 () : int
    { # translateVar (p)
     var vid := v_vid001.ord_uselect(1303761059@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (p)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    if (ipik.count() != 0) 
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer002 := iter;
     iter := iter.mark(1@0);
     var inner002 := iter;
     var v_vid002;
     var v_iter002;
     var v_item002;
     var v_kind002;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(1303761037@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid001.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     } else { # createNewVarTable ()
      v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,1303761060@0);
      { # append (vid, level)
       var seqb := oid(v_vid002.count());
       vid := vid.materialize(ipik);
       v_vid002 := v_vid002.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter002.count());
       iter := iter.materialize(ipik);
       v_iter002 := v_iter002.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb ;
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item002.count());
       item := item.materialize(ipik);
       v_item002 := v_item002.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb := oid(v_kind002.count());
       kind := kind.materialize(ipik);
       v_kind002 := v_kind002.insert(kind.tmark(seqb));
      } # append (kind, level)
     } # end of insertVar (vid)
     { # translateVar (#pf:v_1122)
      var vid := v_vid002.ord_uselect(1303761060@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter002);
      item := vid.leftfetchjoin(v_item002);
      kind := vid.leftfetchjoin(v_kind002);
      ipik := iter;
     } # end of translateVar (#pf:v_1122)
     { # string-value
      var input_iter := iter;
      kind := kind.materialize(ipik);
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      var kind_elem := kind.get_type(ELEM);
      var item_str;
      if (kind_elem.count() = kind.count()) {
       var frag := kind.get_fragment();
       var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
       var t_iter := res_scj.fetch(0);
       var t_item := res_scj.fetch(1);
       var t_frag := res_scj.fetch(2);
       var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var t_iter_unq := t_iter.tunique();
       t_iter := t_iter.materialize(t_item);
       if (t_iter_unq.count() != t_item.count()) {
        var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
        iter_item := iter_item.string_join(t_iter_unq.project(""));
        t_iter := iter_item.hmark(0@0);
        t_item_str := iter_item.tmark(0@0);
       }
       var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
       if (c_map.count() > 0) { #process comments 
        var c_iter := c_map.leftfetchjoin(iter);
        var c_item := c_map.leftfetchjoin(item);
        var c_frag := c_map.leftfetchjoin(frag);
        var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
        var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of comment processing
       var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
       if (pi_map.count() > 0) { #process processing-instructions 
        var pi_iter := pi_map.leftfetchjoin(iter);
        var pi_item := pi_map.leftfetchjoin(item);
        var pi_frag := pi_map.leftfetchjoin(frag);
        var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
        var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
        t_item_str := res_mu.fetch(1);
       } # end of processing-instruction processing
       iter := t_iter;
       item_str := t_item_str;
      } else {
       var kind_attr := kind.get_type(ATTR);
       if (kind_attr.count() = kind.count()) {
        var frag := kind.get_fragment();
        item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
       } else {
        kind_attr := kind_attr.hmark(0@0);
        var item_attr := kind_attr.leftfetchjoin(item);
        var iter_attr := kind_attr.leftfetchjoin(iter);
        var frag := kind_attr.leftfetchjoin(kind).get_fragment();
        var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        kind_elem := kind_elem.hmark(0@0);
        iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
        frag := kind_elem.leftfetchjoin(kind).get_fragment();
        item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
        t_iter := iter_item.hmark(0@0);
        t_item_str := iter_item.tmark(0@0);
        var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
        iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
        {
         var item_unq := iter_item.reverse().tunique();
         if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
        }
        t_iter := iter_item.hmark(0@0);
        var t_item_str := iter_item.tmark(0@0);
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       }
      }
      item_str_ := item_str;
      if (iter.count() != input_iter.tunique().count()) {
       var difference := reverse(input_iter.tdiff(iter));
       difference := difference.hmark(0@0);
       var res_mu := merged_union(iter, difference, item_str_, "");
       iter := res_mu.fetch(0);
       item_str_ := res_mu.fetch(1);
      }
      ipik := iter;
     } # end of string-value
     { # mapBack ()
      var iter_oidMap := inner002.reverse();
      var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
      iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
      # kind := kind;
      # ipik := ipik;
     } # end of mapBack ()
     # cleanUpLevel ()
    } # end of for-translation
    { # saveResult3 () : int
     var ipik003 := ipik;
     var iter003 := iter;
     var item_str_003 := item_str_; # end of saveResult3 () : int
     iter := loop001.tmark(0@0);
     ipik := iter;
     item_str_ := " ";
     { # string-join (string*, string)
      var iter_item_str := iter003.materialize(ipik003).reverse();
      iter_item_str := iter_item_str.leftfetchjoin(item_str_003).materialize(iter_item_str).chk_order();
      var iter_sep_str := iter.materialize(ipik).reverse();
      iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
      iter_item_str := string_join(iter_item_str, iter_sep_str);
      iter := iter_item_str.hmark(0@0);
      iter_item_str := iter_item_str.tmark(0@0);
      item_str_ := iter_item_str;
     } # end of string-join (string*, string)
    } # end of deleteResult3 ()
    { # loop_liftedAttrConstr (int i)
     if (iter002.count() != loop001.count()) {
      ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
     }
     if (iter.count() != loop001.count()) {
      var difference := reverse(loop001.tdiff(iter));
      difference := difference.hmark(0@0);
      var res_mu := merged_union(iter, difference, item_str_, "");
      item_str_ := res_mu.fetch(1);
     }
     var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
     var unq := item_str_.tunique().hmark(0@0);
     var unq_str := unq;
     var str_unq := reverse(unq_str.tdiff(ws_prop_val));
     var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
     unq_str := str_unq.hmark(seqb);
     ws_prop_val := ws_prop_val.insert(unq_str);
     var strings := item_str_.materialize(loop001);
     var attr_oid := strings.leftjoin(ws_prop_val.reverse());
     { # translateEmpty_node ()
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of translateEmpty_node ()
     attr_oid := attr_oid.tmark(0@0);
     _r_attr_iter := iter002;
     _r_attr_qn   := item002.materialize(ipik002);
     _r_attr_prop := attr_oid;
     _r_attr_frag := attr_oid.project(WS);
    } # end of loop_liftedAttrConstr (int i)
   } # end of deleteResult2 ()
   { # saveResult_node2 () : int
    var _elem_iter002   := _elem_iter  ;
    var _elem_size002   := _elem_size  ;
    var _elem_level002  := _elem_level ;
    var _elem_kind002   := _elem_kind  ;
    var _elem_prop002   := _elem_prop  ;
    var _elem_frag002   := _elem_frag  ;
    var _attr_iter002   := _attr_iter  ;
    var _attr_qn002     := _attr_qn    ;
    var _attr_prop002   := _attr_prop  ;
    var _attr_frag002   := _attr_frag  ;
    var _attr_own002    := _attr_own   ;
    var _r_attr_iter002 := _r_attr_iter;
    var _r_attr_qn002   := _r_attr_qn  ;
    var _r_attr_prop002 := _r_attr_prop;
    var _r_attr_frag002 := _r_attr_frag; # end of saveResult_node2 () : int
    {
     var iter003;
     var item003;
     var kind003;
     var ipik004;
     var iter004;
     var item004;
     var match_outer004;
     var ipik005;
     var iter005;
     var item005;
     var match_outer005;
     var jouter004 ;
     var jorder_004 ;
     var jinner004 ;
     var jloop004  ;
     var jv_vid004 ;
     var jv_iter004;
     var jv_pos004 ;
     var jv_item004;
     var jv_kind004;
     { # translateVar (p)
      var vid := v_vid001.ord_uselect(1303761059@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (p)
     { # loop_liftedSCJ (axis, kind, ns, loc)
      { # attribute axis
       var oid_iter := iter;
       var oid_item := item.materialize(ipik);
       var oid_frag := kind.get_fragment();
       var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
       oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
       var oid_attr := temp1.tmark(0@0);
       oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
       var temp1_str; # only needed for name test
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
       temp1 := temp1_str.ord_uselect("");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
       temp1 := temp1_str.ord_uselect("id");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       iter := oid_iter.tmark(0@0);
       item := oid_attr.tmark(0@0);
       kind := oid_frag.tmark(0@0);
       if (type(iter) = bat) {
        ipik := iter;
       } else {
        if (type(item) = bat) {
         ipik := item;
        } else {
         ipik := kind;
        }
       }
      } # end of attribute axis
      kind := kind.set_kind(ATTR);
     } # end of translateLocsteps (c)
     if (ipik.count() != 0) 
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      var loop002 := inner002;
      var v_vid002;
      var v_iter002;
      var v_item002;
      var v_kind002;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761038@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761061@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (#pf:v_2802)
       var vid := v_vid002.ord_uselect(1303761061@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (#pf:v_2802)
      { # string-value
       var input_iter := iter;
       kind := kind.materialize(ipik);
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       var kind_elem := kind.get_type(ELEM);
       var item_str;
       if (kind_elem.count() = kind.count()) {
        var frag := kind.get_fragment();
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var t_iter_unq := t_iter.tunique();
        t_iter := t_iter.materialize(t_item);
        if (t_iter_unq.count() != t_item.count()) {
         var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         iter_item := iter_item.string_join(t_iter_unq.project(""));
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
        }
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       } else {
        var kind_attr := kind.get_type(ATTR);
        if (kind_attr.count() = kind.count()) {
         var frag := kind.get_fragment();
         item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        } else {
         kind_attr := kind_attr.hmark(0@0);
         var item_attr := kind_attr.leftfetchjoin(item);
         var iter_attr := kind_attr.leftfetchjoin(iter);
         var frag := kind_attr.leftfetchjoin(kind).get_fragment();
         var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         kind_elem := kind_elem.hmark(0@0);
         iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
         frag := kind_elem.leftfetchjoin(kind).get_fragment();
         item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
         var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
         iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         {
          var item_unq := iter_item.reverse().tunique();
          if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
         }
         t_iter := iter_item.hmark(0@0);
         var t_item_str := iter_item.tmark(0@0);
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        }
       }
       item_str_ := item_str;
       if (iter.count() != input_iter.tunique().count()) {
        var difference := reverse(input_iter.tdiff(iter));
        difference := difference.hmark(0@0);
        var res_mu := merged_union(iter, difference, item_str_, "");
        iter := res_mu.fetch(0);
        item_str_ := res_mu.fetch(1);
       }
       ipik := iter;
      } # end of string-value
      { # cast from string to untypedAtomic
       if (iter.count() != loop002.count()) {
        ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
       }
      } # end of cast from string to untypedAtomic
      { # cast from untypedAtomic to string
       if (iter.count() != loop002.count()) {
        ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
       }
      } # end of cast from untypedAtomic to string
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
     {
      var mapping := outer000.reverse().leftfetchjoin(inner000);
      mapping := mapping.leftjoin(outer001.reverse());
      mapping := mapping.leftfetchjoin(inner001);
      match_outer004 := iter.leftjoin(mapping.reverse()).tmark(iter.seqbase());
     }
     ipik004 := ipik;
     iter004 := iter;
     item004 := item_str_;
     jouter004  := outer001 ;
     jinner004  := inner001 ;
     jv_vid004  := v_vid001 ;
     jv_iter004 := v_iter001;
     jv_item004 := v_item001;
     jv_kind004 := v_kind001;
     v_vid001  := v_vid000 .copy().access(BAT_WRITE);
     v_iter001 := v_iter000.copy().access(BAT_WRITE);
     v_item001 := v_item000.copy().access(BAT_WRITE);
     v_kind001 := v_kind000.copy().access(BAT_WRITE);
     { # translateVar (auction)
      var vid := v_vid001.ord_uselect(1303761058@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (auction)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "s");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, "", "closed_auction");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      var v_vid002;
      var v_iter002;
      var v_item002;
      var v_kind002;
      iter003 := iter;
      item003 := item;
      kind003 := kind;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761039@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761062@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (t)
       var vid := v_vid002.ord_uselect(1303761062@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (t)
      { # translateLocsteps (c)
       var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "buyer");
       iter := res_scj.fetch(0);
       item := res_scj.fetch(1);
       kind := res_scj.fetch(2).set_kind(ELEM);
       ipik := item;
      } # end of translateLocsteps (c)
      { # loop_liftedSCJ (axis, kind, ns, loc)
       { # attribute axis
        var oid_iter := iter;
        var oid_item := item.materialize(ipik);
        var oid_frag := kind.get_fragment();
        var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
        oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
        var oid_attr := temp1.tmark(0@0);
        oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
        var temp1_str; # only needed for name test
        temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
        temp1 := temp1_str.ord_uselect("");
        temp1 := temp1.hmark(0@0);
        oid_attr := temp1.leftfetchjoin(oid_attr);
        oid_frag := temp1.leftfetchjoin(oid_frag);
        oid_iter := temp1.leftfetchjoin(oid_iter);
        temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
        temp1 := temp1_str.ord_uselect("person");
        temp1 := temp1.hmark(0@0);
        oid_attr := temp1.leftfetchjoin(oid_attr);
        oid_frag := temp1.leftfetchjoin(oid_frag);
        oid_iter := temp1.leftfetchjoin(oid_iter);
        iter := oid_iter.tmark(0@0);
        item := oid_attr.tmark(0@0);
        kind := oid_frag.tmark(0@0);
        if (type(iter) = bat) {
         ipik := iter;
        } else {
         if (type(item) = bat) {
          ipik := item;
         } else {
          ipik := kind;
         }
        }
       } # end of attribute axis
       kind := kind.set_kind(ATTR);
      } # end of translateLocsteps (c)
      if (ipik.count() != 0) 
      { # for-translation
       # project ()
       iter := iter.materialize(ipik);
       var outer003 := iter;
       iter := iter.mark(1@0);
       var inner003 := iter;
       var loop003 := inner003;
       var v_vid003;
       var v_iter003;
       var v_item003;
       var v_kind003;
       var expOid;
       { # getExpanded (fid)
        var vu_nil := vu_fid.ord_uselect(1303761040@0);
        var vid_vu := vu_vid.reverse();
        var oid_nil := vid_vu.leftjoin(vu_nil);
        expOid := v_vid002.leftjoin(oid_nil);
        expOid := expOid.mirror();
       } # end of getExpanded (fid)
       if (expOid.count() != 0) {
        var oidNew_expOid;
        { # expand ()
         var expOid_iter := expOid.leftfetchjoin(v_iter002);
         var iter_expOid := expOid_iter.reverse();
         var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
         var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
         oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
         var expOid_oidMap := oidMap_expOid.reverse();
         expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
         v_iter003 := expOid_iter;
         oidNew_expOid := expOid_iter.hmark(0@0);
        } # end of expand ()
        # join ()
        var cnt := count(v_iter003)*2;
        v_iter003 := v_iter003.tmark(0@0);
        var new_v_iter := v_iter003;
        v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
        var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
        v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
        var new_v_pos ;
        var new_v_item := oidNew_expOid.leftjoin(v_item002);
        v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
        var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
        v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
       } else { # createNewVarTable ()
        v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
       }
       { # insertVar (vid)
        var vid := project(ipik,1303761063@0);
        { # append (vid, level)
         var seqb := oid(v_vid003.count());
         vid := vid.materialize(ipik);
         v_vid003 := v_vid003.insert(vid.tmark(seqb));
        } # append (vid, level)
        { # append (iter, level)
         var seqb := oid(v_iter003.count());
         iter := iter.materialize(ipik);
         v_iter003 := v_iter003.insert(iter.tmark(seqb));
        } # append (iter, level)
        { # append (pos, level)
         var seqb ;
        } # append (pos, level)
        { # append (item, level)
         var seqb := oid(v_item003.count());
         item := item.materialize(ipik);
         v_item003 := v_item003.insert(item.tmark(seqb));
        } # append (item, level)
        { # append (kind, level)
         var seqb := oid(v_kind003.count());
         kind := kind.materialize(ipik);
         v_kind003 := v_kind003.insert(kind.tmark(seqb));
        } # append (kind, level)
       } # end of insertVar (vid)
       { # translateVar (#pf:v_2804)
        var vid := v_vid003.ord_uselect(1303761063@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter003);
        item := vid.leftfetchjoin(v_item003);
        kind := vid.leftfetchjoin(v_kind003);
        ipik := iter;
       } # end of translateVar (#pf:v_2804)
       { # string-value
        var input_iter := iter;
        kind := kind.materialize(ipik);
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        var kind_elem := kind.get_type(ELEM);
        var item_str;
        if (kind_elem.count() = kind.count()) {
         var frag := kind.get_fragment();
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var t_iter_unq := t_iter.tunique();
         t_iter := t_iter.materialize(t_item);
         if (t_iter_unq.count() != t_item.count()) {
          var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          iter_item := iter_item.string_join(t_iter_unq.project(""));
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
         }
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        } else {
         var kind_attr := kind.get_type(ATTR);
         if (kind_attr.count() = kind.count()) {
          var frag := kind.get_fragment();
          item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         } else {
          kind_attr := kind_attr.hmark(0@0);
          var item_attr := kind_attr.leftfetchjoin(item);
          var iter_attr := kind_attr.leftfetchjoin(iter);
          var frag := kind_attr.leftfetchjoin(kind).get_fragment();
          var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
          kind_elem := kind_elem.hmark(0@0);
          iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
          frag := kind_elem.leftfetchjoin(kind).get_fragment();
          item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
          var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
          var t_iter := res_scj.fetch(0);
          var t_item := res_scj.fetch(1);
          var t_frag := res_scj.fetch(2);
          var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
          var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
          var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
          iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          {
           var item_unq := iter_item.reverse().tunique();
           if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
          }
          t_iter := iter_item.hmark(0@0);
          var t_item_str := iter_item.tmark(0@0);
          var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
          if (c_map.count() > 0) { #process comments 
           var c_iter := c_map.leftfetchjoin(iter);
           var c_item := c_map.leftfetchjoin(item);
           var c_frag := c_map.leftfetchjoin(frag);
           var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
           var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of comment processing
          var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
          if (pi_map.count() > 0) { #process processing-instructions 
           var pi_iter := pi_map.leftfetchjoin(iter);
           var pi_item := pi_map.leftfetchjoin(item);
           var pi_frag := pi_map.leftfetchjoin(frag);
           var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
           var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of processing-instruction processing
          iter := t_iter;
          item_str := t_item_str;
         }
        }
        item_str_ := item_str;
        if (iter.count() != input_iter.tunique().count()) {
         var difference := reverse(input_iter.tdiff(iter));
         difference := difference.hmark(0@0);
         var res_mu := merged_union(iter, difference, item_str_, "");
         iter := res_mu.fetch(0);
         item_str_ := res_mu.fetch(1);
        }
        ipik := iter;
       } # end of string-value
       { # cast from string to untypedAtomic
        if (iter.count() != loop003.count()) {
         ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
        }
       } # end of cast from string to untypedAtomic
       { # cast from untypedAtomic to string
        if (iter.count() != loop003.count()) {
         ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
        }
       } # end of cast from untypedAtomic to string
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
       # cleanUpLevel ()
      } # end of for-translation
      ipik005 := ipik;
      iter005 := iter;
      item005 := item_str_;
      match_outer005 := iter.leftfetchjoin(inner002.reverse()).leftfetchjoin(outer002); # cleanUpLevel ()
     } # end of for-translation
     outer001  := jouter004 ;
     inner001  := jinner004 ;
     v_vid001  := jv_vid004 ;
     v_iter001 := jv_iter004;
     v_item001 := jv_item004;
     v_kind001 := jv_kind004;
     var join_item1 := item004;
     var join_item2 := item005;
     join_item1 := join_item1.materialize(ipik004);
     join_item1 := join_item1.reverse().leftfetchjoin(iter004).reverse();
     join_item2 := join_item2.materialize(ipik005);
     join_item2 := join_item2.reverse().leftfetchjoin(iter005).reverse();
     var join_result := ll_htordered_unique_thetajoin(EQ, join_item1, join_item2, match_outer004, match_outer005,nil,iter003.reverse());
     var snd_iter := join_result.tmark(0@0);
     var fst_iter := join_result.hmark(0@0);
     ipik := fst_iter; # order_fst isn't needed until now
     # (cannot be pushed below the theta-join due to the 'iter := fst_iter;' hereafter)
     # var order_fst := fst_iter.leftfetchjoin(inner001.reverse());
     var order_snd := snd_iter; #.leftfetchjoin(iter003.reverse()); pushed below theta-join
     { # for-translation
      iter := fst_iter; # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      var loop002 := inner002;
      var v_vid002;
      var v_iter002;
      var v_item002;
      var v_kind002;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761041@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      } # could also be pushed below theta-join, if order_snd wasn't needed for kind (below) ...
      item := order_snd.leftfetchjoin(item003);
      iter := ipik.mark(1@0); # could also be pushed below theta-join, if order_snd wasn't needed for item (above) ...
      kind := order_snd.leftfetchjoin(kind003);
      { # insertVar (vid)
       var vid := project(ipik,1303761062@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # tagname-translation
       var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
       var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
       var itemID;
       if (prop_str.texist("item")) {
        itemID := prop_str.reverse().find("item");
       } else {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
        ws.fetch(QN_LOC).fetch(WS).insert(itemID,"item");
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"item"+str('\1')+"");
       } # translateConst (kind)
       iter := loop002.tmark(0@0);
       ipik := iter;
       item := itemID;
      } # end of tagname-translation
      { # saveResult6 () : int
       var ipik006 := ipik;
       var iter006 := iter;
       var item006 := item; # end of saveResult6 () : int
       {
        var iter007;
        var item007;
        var kind007;
        var ipik008;
        var iter008;
        var item008;
        var match_outer008;
        var ipik009;
        var iter009;
        var item009;
        var match_outer009;
        var jouter008 ;
        var jorder_008 ;
        var jinner008 ;
        var jloop008  ;
        var jv_vid008 ;
        var jv_iter008;
        var jv_pos008 ;
        var jv_item008;
        var jv_kind008;
        { # translateVar (t)
         var vid := v_vid002.ord_uselect(1303761062@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter002);
         item := vid.leftfetchjoin(v_item002);
         kind := vid.leftfetchjoin(v_kind002);
         ipik := iter;
        } # end of translateVar (t)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "itemref");
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        { # loop_liftedSCJ (axis, kind, ns, loc)
         { # attribute axis
          var oid_iter := iter;
          var oid_item := item.materialize(ipik);
          var oid_frag := kind.get_fragment();
          var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
          oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
          var oid_attr := temp1.tmark(0@0);
          oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
          var temp1_str; # only needed for name test
          temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
          temp1 := temp1_str.ord_uselect("");
          temp1 := temp1.hmark(0@0);
          oid_attr := temp1.leftfetchjoin(oid_attr);
          oid_frag := temp1.leftfetchjoin(oid_frag);
          oid_iter := temp1.leftfetchjoin(oid_iter);
          temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
          temp1 := temp1_str.ord_uselect("item");
          temp1 := temp1.hmark(0@0);
          oid_attr := temp1.leftfetchjoin(oid_attr);
          oid_frag := temp1.leftfetchjoin(oid_frag);
          oid_iter := temp1.leftfetchjoin(oid_iter);
          iter := oid_iter.tmark(0@0);
          item := oid_attr.tmark(0@0);
          kind := oid_frag.tmark(0@0);
          if (type(iter) = bat) {
           ipik := iter;
          } else {
           if (type(item) = bat) {
            ipik := item;
           } else {
            ipik := kind;
           }
          }
         } # end of attribute axis
         kind := kind.set_kind(ATTR);
        } # end of translateLocsteps (c)
        if (ipik.count() != 0) 
        { # for-translation
         # project ()
         iter := iter.materialize(ipik);
         var outer003 := iter;
         iter := iter.mark(1@0);
         var inner003 := iter;
         var loop003 := inner003;
         var v_vid003;
         var v_iter003;
         var v_item003;
         var v_kind003;
         var expOid;
         { # getExpanded (fid)
          var vu_nil := vu_fid.ord_uselect(1303761042@0);
          var vid_vu := vu_vid.reverse();
          var oid_nil := vid_vu.leftjoin(vu_nil);
          expOid := v_vid002.leftjoin(oid_nil);
          expOid := expOid.mirror();
         } # end of getExpanded (fid)
         if (expOid.count() != 0) {
          var oidNew_expOid;
          { # expand ()
           var expOid_iter := expOid.leftfetchjoin(v_iter002);
           var iter_expOid := expOid_iter.reverse();
           var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
           var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
           oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
           var expOid_oidMap := oidMap_expOid.reverse();
           expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
           v_iter003 := expOid_iter;
           oidNew_expOid := expOid_iter.hmark(0@0);
          } # end of expand ()
          # join ()
          var cnt := count(v_iter003)*2;
          v_iter003 := v_iter003.tmark(0@0);
          var new_v_iter := v_iter003;
          v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
          var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
          v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
          var new_v_pos ;
          var new_v_item := oidNew_expOid.leftjoin(v_item002);
          v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
          var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
          v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
         } else { # createNewVarTable ()
          v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
         }
         { # insertVar (vid)
          var vid := project(ipik,1303761064@0);
          { # append (vid, level)
           var seqb := oid(v_vid003.count());
           vid := vid.materialize(ipik);
           v_vid003 := v_vid003.insert(vid.tmark(seqb));
          } # append (vid, level)
          { # append (iter, level)
           var seqb := oid(v_iter003.count());
           iter := iter.materialize(ipik);
           v_iter003 := v_iter003.insert(iter.tmark(seqb));
          } # append (iter, level)
          { # append (pos, level)
           var seqb ;
          } # append (pos, level)
          { # append (item, level)
           var seqb := oid(v_item003.count());
           item := item.materialize(ipik);
           v_item003 := v_item003.insert(item.tmark(seqb));
          } # append (item, level)
          { # append (kind, level)
           var seqb := oid(v_kind003.count());
           kind := kind.materialize(ipik);
           v_kind003 := v_kind003.insert(kind.tmark(seqb));
          } # append (kind, level)
         } # end of insertVar (vid)
         { # translateVar (#pf:v_2806)
          var vid := v_vid003.ord_uselect(1303761064@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter003);
          item := vid.leftfetchjoin(v_item003);
          kind := vid.leftfetchjoin(v_kind003);
          ipik := iter;
         } # end of translateVar (#pf:v_2806)
         { # string-value
          var input_iter := iter;
          kind := kind.materialize(ipik);
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          var kind_elem := kind.get_type(ELEM);
          var item_str;
          if (kind_elem.count() = kind.count()) {
           var frag := kind.get_fragment();
           var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
           var t_iter := res_scj.fetch(0);
           var t_item := res_scj.fetch(1);
           var t_frag := res_scj.fetch(2);
           var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
           var t_iter_unq := t_iter.tunique();
           t_iter := t_iter.materialize(t_item);
           if (t_iter_unq.count() != t_item.count()) {
            var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            iter_item := iter_item.string_join(t_iter_unq.project(""));
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
           }
           var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
           if (c_map.count() > 0) { #process comments 
            var c_iter := c_map.leftfetchjoin(iter);
            var c_item := c_map.leftfetchjoin(item);
            var c_frag := c_map.leftfetchjoin(frag);
            var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
            var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
           } # end of comment processing
           var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
           if (pi_map.count() > 0) { #process processing-instructions 
            var pi_iter := pi_map.leftfetchjoin(iter);
            var pi_item := pi_map.leftfetchjoin(item);
            var pi_frag := pi_map.leftfetchjoin(frag);
            var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
            var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
            t_item_str := res_mu.fetch(1);
           } # end of processing-instruction processing
           iter := t_iter;
           item_str := t_item_str;
          } else {
           var kind_attr := kind.get_type(ATTR);
           if (kind_attr.count() = kind.count()) {
            var frag := kind.get_fragment();
            item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
           } else {
            kind_attr := kind_attr.hmark(0@0);
            var item_attr := kind_attr.leftfetchjoin(item);
            var iter_attr := kind_attr.leftfetchjoin(iter);
            var frag := kind_attr.leftfetchjoin(kind).get_fragment();
            var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
            kind_elem := kind_elem.hmark(0@0);
            iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
            frag := kind_elem.leftfetchjoin(kind).get_fragment();
            item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
            var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
            var t_iter := res_scj.fetch(0);
            var t_item := res_scj.fetch(1);
            var t_frag := res_scj.fetch(2);
            var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
            var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
            var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
            iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            {
             var item_unq := iter_item.reverse().tunique();
             if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
            }
            t_iter := iter_item.hmark(0@0);
            var t_item_str := iter_item.tmark(0@0);
            var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
            if (c_map.count() > 0) { #process comments 
             var c_iter := c_map.leftfetchjoin(iter);
             var c_item := c_map.leftfetchjoin(item);
             var c_frag := c_map.leftfetchjoin(frag);
             var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
             var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of comment processing
            var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
            if (pi_map.count() > 0) { #process processing-instructions 
             var pi_iter := pi_map.leftfetchjoin(iter);
             var pi_item := pi_map.leftfetchjoin(item);
             var pi_frag := pi_map.leftfetchjoin(frag);
             var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
             var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of processing-instruction processing
            iter := t_iter;
            item_str := t_item_str;
           }
          }
          item_str_ := item_str;
          if (iter.count() != input_iter.tunique().count()) {
           var difference := reverse(input_iter.tdiff(iter));
           difference := difference.hmark(0@0);
           var res_mu := merged_union(iter, difference, item_str_, "");
           iter := res_mu.fetch(0);
           item_str_ := res_mu.fetch(1);
          }
          ipik := iter;
         } # end of string-value
         { # cast from string to untypedAtomic
          if (iter.count() != loop003.count()) {
           ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
          }
         } # end of cast from string to untypedAtomic
         { # cast from untypedAtomic to string
          if (iter.count() != loop003.count()) {
           ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
          }
         } # end of cast from untypedAtomic to string
         { # mapBack ()
          var iter_oidMap := inner003.reverse();
          var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
          iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
          # kind := kind;
          # ipik := ipik;
         } # end of mapBack ()
         # cleanUpLevel ()
        } # end of for-translation
        {
         var mapping := outer000.reverse().leftfetchjoin(inner000);
         mapping := mapping.leftjoin(outer001.reverse());
         mapping := mapping.leftfetchjoin(inner001);
         mapping := mapping.leftjoin(outer002.reverse());
         mapping := mapping.leftfetchjoin(inner002);
         match_outer008 := iter.leftjoin(mapping.reverse()).tmark(iter.seqbase());
        }
        ipik008 := ipik;
        iter008 := iter;
        item008 := item_str_;
        jouter008  := outer002 ;
        jinner008  := inner002 ;
        v_vid002  := v_vid000 .copy().access(BAT_WRITE);
        v_iter002 := v_iter000.copy().access(BAT_WRITE);
        v_item002 := v_item000.copy().access(BAT_WRITE);
        v_kind002 := v_kind000.copy().access(BAT_WRITE);
        { # translateVar (auction)
         var vid := v_vid002.ord_uselect(1303761058@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter002);
         item := vid.leftfetchjoin(v_item002);
         kind := vid.leftfetchjoin(v_kind002);
         ipik := iter;
        } # end of translateVar (auction)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "item");
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        { # for-translation
         # project ()
         iter := iter.materialize(ipik);
         var outer003 := iter;
         iter := iter.mark(1@0);
         var inner003 := iter;
         var v_vid003;
         var v_iter003;
         var v_pos003;
         var v_item003;
         var v_kind003;
         iter007 := iter;
         item007 := item;
         kind007 := kind;
         var expOid;
         { # getExpanded (fid)
          var vu_nil := vu_fid.ord_uselect(1303761043@0);
          var vid_vu := vu_vid.reverse();
          var oid_nil := vid_vu.leftjoin(vu_nil);
          expOid := v_vid002.leftjoin(oid_nil);
          expOid := expOid.mirror();
         } # end of getExpanded (fid)
         if (expOid.count() != 0) {
          var oidNew_expOid;
          { # expand ()
           var expOid_iter := expOid.leftfetchjoin(v_iter002);
           var iter_expOid := expOid_iter.reverse();
           var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
           var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
           oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
           var expOid_oidMap := oidMap_expOid.reverse();
           expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
           v_iter003 := expOid_iter;
           oidNew_expOid := expOid_iter.hmark(0@0);
          } # end of expand ()
          # join ()
          var cnt := count(v_iter003)*2;
          v_iter003 := v_iter003.tmark(0@0);
          var new_v_iter := v_iter003;
          v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
          var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
          v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
          var new_v_pos ;
          var new_v_item := oidNew_expOid.leftjoin(v_item002);
          v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
          var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
          v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
         } else { # createNewVarTable ()
          v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
         }
         { # insertVar (vid)
          var vid := project(ipik,1303761065@0);
          { # append (vid, level)
           var seqb := oid(v_vid003.count());
           vid := vid.materialize(ipik);
           v_vid003 := v_vid003.insert(vid.tmark(seqb));
          } # append (vid, level)
          { # append (iter, level)
           var seqb := oid(v_iter003.count());
           iter := iter.materialize(ipik);
           v_iter003 := v_iter003.insert(iter.tmark(seqb));
          } # append (iter, level)
          { # append (pos, level)
           var seqb ;
          } # append (pos, level)
          { # append (item, level)
           var seqb := oid(v_item003.count());
           item := item.materialize(ipik);
           v_item003 := v_item003.insert(item.tmark(seqb));
          } # append (item, level)
          { # append (kind, level)
           var seqb := oid(v_kind003.count());
           kind := kind.materialize(ipik);
           v_kind003 := v_kind003.insert(kind.tmark(seqb));
          } # append (kind, level)
         } # end of insertVar (vid)
         { # translateVar (t2)
          var vid := v_vid003.ord_uselect(1303761065@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter003);
          item := vid.leftfetchjoin(v_item003);
          kind := vid.leftfetchjoin(v_kind003);
          ipik := iter;
         } # end of translateVar (t2)
         { # loop_liftedSCJ (axis, kind, ns, loc)
          { # attribute axis
           var oid_iter := iter;
           var oid_item := item.materialize(ipik);
           var oid_frag := kind.get_fragment();
           var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
           oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
           var oid_attr := temp1.tmark(0@0);
           oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
           var temp1_str; # only needed for name test
           temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
           temp1 := temp1_str.ord_uselect("");
           temp1 := temp1.hmark(0@0);
           oid_attr := temp1.leftfetchjoin(oid_attr);
           oid_frag := temp1.leftfetchjoin(oid_frag);
           oid_iter := temp1.leftfetchjoin(oid_iter);
           temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
           temp1 := temp1_str.ord_uselect("id");
           temp1 := temp1.hmark(0@0);
           oid_attr := temp1.leftfetchjoin(oid_attr);
           oid_frag := temp1.leftfetchjoin(oid_frag);
           oid_iter := temp1.leftfetchjoin(oid_iter);
           iter := oid_iter.tmark(0@0);
           item := oid_attr.tmark(0@0);
           kind := oid_frag.tmark(0@0);
           if (type(iter) = bat) {
            ipik := iter;
           } else {
            if (type(item) = bat) {
             ipik := item;
            } else {
             ipik := kind;
            }
           }
          } # end of attribute axis
          kind := kind.set_kind(ATTR);
         } # end of translateLocsteps (c)
         if (ipik.count() != 0) 
         { # for-translation
          # project ()
          iter := iter.materialize(ipik);
          var outer004 := iter;
          iter := iter.mark(1@0);
          var inner004 := iter;
          var loop004 := inner004;
          var v_vid004;
          var v_iter004;
          var v_item004;
          var v_kind004;
          var expOid;
          { # getExpanded (fid)
           var vu_nil := vu_fid.ord_uselect(1303761044@0);
           var vid_vu := vu_vid.reverse();
           var oid_nil := vid_vu.leftjoin(vu_nil);
           expOid := v_vid003.leftjoin(oid_nil);
           expOid := expOid.mirror();
          } # end of getExpanded (fid)
          if (expOid.count() != 0) {
           var oidNew_expOid;
           { # expand ()
            var expOid_iter := expOid.leftfetchjoin(v_iter003);
            var iter_expOid := expOid_iter.reverse();
            var oidMap_expOid := outer004.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
            var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
            oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
            var expOid_oidMap := oidMap_expOid.reverse();
            expOid_iter := expOid_oidMap.leftfetchjoin(inner004);
            v_iter004 := expOid_iter;
            oidNew_expOid := expOid_iter.hmark(0@0);
           } # end of expand ()
           # join ()
           var cnt := count(v_iter004)*2;
           v_iter004 := v_iter004.tmark(0@0);
           var new_v_iter := v_iter004;
           v_iter004 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
           var new_v_vid := oidNew_expOid.leftjoin(v_vid003);
           v_vid004 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
           var new_v_pos ;
           var new_v_item := oidNew_expOid.leftjoin(v_item003);
           v_item004 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
           var new_v_kind := oidNew_expOid.leftjoin(v_kind003);
           v_kind004 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
          } else { # createNewVarTable ()
           v_iter004 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_vid004 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_item004 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_kind004 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
          }
          { # insertVar (vid)
           var vid := project(ipik,1303761066@0);
           { # append (vid, level)
            var seqb := oid(v_vid004.count());
            vid := vid.materialize(ipik);
            v_vid004 := v_vid004.insert(vid.tmark(seqb));
           } # append (vid, level)
           { # append (iter, level)
            var seqb := oid(v_iter004.count());
            iter := iter.materialize(ipik);
            v_iter004 := v_iter004.insert(iter.tmark(seqb));
           } # append (iter, level)
           { # append (pos, level)
            var seqb ;
           } # append (pos, level)
           { # append (item, level)
            var seqb := oid(v_item004.count());
            item := item.materialize(ipik);
            v_item004 := v_item004.insert(item.tmark(seqb));
           } # append (item, level)
           { # append (kind, level)
            var seqb := oid(v_kind004.count());
            kind := kind.materialize(ipik);
            v_kind004 := v_kind004.insert(kind.tmark(seqb));
           } # append (kind, level)
          } # end of insertVar (vid)
          { # translateVar (#pf:v_2808)
           var vid := v_vid004.ord_uselect(1303761066@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter004);
           item := vid.leftfetchjoin(v_item004);
           kind := vid.leftfetchjoin(v_kind004);
           ipik := iter;
          } # end of translateVar (#pf:v_2808)
          { # string-value
           var input_iter := iter;
           kind := kind.materialize(ipik);
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           var kind_elem := kind.get_type(ELEM);
           var item_str;
           if (kind_elem.count() = kind.count()) {
            var frag := kind.get_fragment();
            var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
            var t_iter := res_scj.fetch(0);
            var t_item := res_scj.fetch(1);
            var t_frag := res_scj.fetch(2);
            var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
            var t_iter_unq := t_iter.tunique();
            t_iter := t_iter.materialize(t_item);
            if (t_iter_unq.count() != t_item.count()) {
             var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
             iter_item := iter_item.string_join(t_iter_unq.project(""));
             t_iter := iter_item.hmark(0@0);
             t_item_str := iter_item.tmark(0@0);
            }
            var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
            if (c_map.count() > 0) { #process comments 
             var c_iter := c_map.leftfetchjoin(iter);
             var c_item := c_map.leftfetchjoin(item);
             var c_frag := c_map.leftfetchjoin(frag);
             var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
             var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of comment processing
            var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
            if (pi_map.count() > 0) { #process processing-instructions 
             var pi_iter := pi_map.leftfetchjoin(iter);
             var pi_item := pi_map.leftfetchjoin(item);
             var pi_frag := pi_map.leftfetchjoin(frag);
             var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
             var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
             t_item_str := res_mu.fetch(1);
            } # end of processing-instruction processing
            iter := t_iter;
            item_str := t_item_str;
           } else {
            var kind_attr := kind.get_type(ATTR);
            if (kind_attr.count() = kind.count()) {
             var frag := kind.get_fragment();
             item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
            } else {
             kind_attr := kind_attr.hmark(0@0);
             var item_attr := kind_attr.leftfetchjoin(item);
             var iter_attr := kind_attr.leftfetchjoin(iter);
             var frag := kind_attr.leftfetchjoin(kind).get_fragment();
             var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
             kind_elem := kind_elem.hmark(0@0);
             iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
             frag := kind_elem.leftfetchjoin(kind).get_fragment();
             item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
             var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
             var t_iter := res_scj.fetch(0);
             var t_item := res_scj.fetch(1);
             var t_frag := res_scj.fetch(2);
             var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
             var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
             t_iter := iter_item.hmark(0@0);
             t_item_str := iter_item.tmark(0@0);
             var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
             iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
             {
              var item_unq := iter_item.reverse().tunique();
              if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
             }
             t_iter := iter_item.hmark(0@0);
             var t_item_str := iter_item.tmark(0@0);
             var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
             if (c_map.count() > 0) { #process comments 
              var c_iter := c_map.leftfetchjoin(iter);
              var c_item := c_map.leftfetchjoin(item);
              var c_frag := c_map.leftfetchjoin(frag);
              var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
              var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
             } # end of comment processing
             var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
             if (pi_map.count() > 0) { #process processing-instructions 
              var pi_iter := pi_map.leftfetchjoin(iter);
              var pi_item := pi_map.leftfetchjoin(item);
              var pi_frag := pi_map.leftfetchjoin(frag);
              var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
              var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
             } # end of processing-instruction processing
             iter := t_iter;
             item_str := t_item_str;
            }
           }
           item_str_ := item_str;
           if (iter.count() != input_iter.tunique().count()) {
            var difference := reverse(input_iter.tdiff(iter));
            difference := difference.hmark(0@0);
            var res_mu := merged_union(iter, difference, item_str_, "");
            iter := res_mu.fetch(0);
            item_str_ := res_mu.fetch(1);
           }
           ipik := iter;
          } # end of string-value
          { # cast from string to untypedAtomic
           if (iter.count() != loop004.count()) {
            ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
           }
          } # end of cast from string to untypedAtomic
          { # cast from untypedAtomic to string
           if (iter.count() != loop004.count()) {
            ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
           }
          } # end of cast from untypedAtomic to string
          { # mapBack ()
           var iter_oidMap := inner004.reverse();
           var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
           iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
           # kind := kind;
           # ipik := ipik;
          } # end of mapBack ()
          # cleanUpLevel ()
         } # end of for-translation
         ipik009 := ipik;
         iter009 := iter;
         item009 := item_str_;
         match_outer009 := iter.leftfetchjoin(inner003.reverse()).leftfetchjoin(outer003); # cleanUpLevel ()
        } # end of for-translation
        outer002  := jouter008 ;
        inner002  := jinner008 ;
        var join_item1 := item008;
        var join_item2 := item009;
        join_item1 := join_item1.materialize(ipik008);
        join_item1 := join_item1.reverse().leftfetchjoin(iter008).reverse();
        join_item2 := join_item2.materialize(ipik009);
        join_item2 := join_item2.reverse().leftfetchjoin(iter009).reverse();
        var join_result := ll_htordered_unique_thetajoin(EQ, join_item1, join_item2, match_outer008, match_outer009,nil,iter007.reverse());
        var snd_iter := join_result.tmark(0@0);
        var fst_iter := join_result.hmark(0@0);
        ipik := fst_iter; # order_fst isn't needed until now
        # (cannot be pushed below the theta-join due to the 'iter := fst_iter;' hereafter)
        # var order_fst := fst_iter.leftfetchjoin(inner002.reverse());
        var order_snd := snd_iter; #.leftfetchjoin(iter007.reverse()); pushed below theta-join
        # could also be pushed below theta-join, if order_snd wasn't needed for kind (below) ...
        item := order_snd.leftfetchjoin(item007);
        iter := fst_iter; # could also be pushed below theta-join, if order_snd wasn't needed for item (above) ...
        kind := order_snd.leftfetchjoin(kind007);
       } # end of evaluate_join
       { # translate pf:distinct-doc-order (node*) as node*
        var sorting;
        var simple := false;
        if (type(kind) != bat) {
         simple := (kind = ELEM);
        }
        if (not(simple)) {
         kind := kind.materialize(ipik);
         simple := (kind.count() = kind.get_type(ELEM).count());
        }
        if (simple) {
         sorting := iter.tsort();
         sorting := sorting.CTrefine(kind);
         sorting := sorting.CTrefine(item);
        } else { # cope also with attributes and sort them according to their owner
         var elements := kind.get_type(ELEM).mirror();
         var elem_iters := elements.leftfetchjoin(iter);
         var elem_items := elements.leftfetchjoin(item);
         var elem_frags := elements.leftfetchjoin(kind.get_fragment());
         var elem_attrs := elements.mark(nil);
         var attributes := kind.get_type(ATTR).mirror();
         var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
         var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
         var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
         var attr_key := attributes.hmark(0@0);
         var temp_attr := attr_attrs.tmark(0@0);
         var temp_frag := attr_frags.tmark(0@0);
         var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
         sorting := elem_iters.union(attr_iters).tsort();
         sorting := sorting.CTrefine(elem_frags.union(attr_frags));
         sorting := sorting.CTrefine(elem_items.union(attr_items));
         sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
        }
        ipik := sorting.reverse().{min}().tmark(0@0);
        iter := ipik.leftfetchjoin(iter);
        item := ipik.leftfetchjoin(item);
        kind := ipik.leftfetchjoin(kind);
       } # end of translate pf:distinct-doc-order (node*) as node*
       { # translateLocsteps (c)
        var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
        iter := res_scj.fetch(0);
        item := res_scj.fetch(1);
        kind := res_scj.fetch(2).set_kind(ELEM);
        ipik := item;
       } # end of translateLocsteps (c)
       { # translateLocsteps (c)
        var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
        iter := res_scj.fetch(0);
        item := res_scj.fetch(1);
        kind := res_scj.fetch(2).set_kind(ELEM);
        ipik := item;
       } # end of translateLocsteps (c)
       { # map2NODE_interface (counter)
        kind := kind.materialize(ipik);
        var attr := kind.get_type(ATTR).hmark(0@0);
        var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
        var attr_item := attr.leftfetchjoin(item);
        var attr_frag := attr.leftfetchjoin(kind).get_fragment();
        _r_attr_iter := attr_iter;
        _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
        _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
        _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
        var nodes := kind.get_type(ELEM);
        if (nodes.count() != 0) {
         var oid_oid := nodes.hmark(0@0);
         var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
         var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
         var iter_input := oid_oid.mirror();
         var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
         var res_iter := res_scj.fetch(0);
         var res_item := res_scj.fetch(1);
         var res_frag := res_scj.fetch(2);
         _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
         _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
         _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
         _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
         _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
         var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
         var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
         nodes := res_item.mark(0@0);
         var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
         root_level := nodes.leftfetchjoin(root_level);
         temp_ec_item := res_item;
         temp_ec_frag := res_frag;
         var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
         content_level := nodes.leftfetchjoin(content_level);
         content_level := content_level.[-](root_level);
         content_level := content_level.tmark(0@0);
         _elem_level := content_level;
         { # create attribute subtree copies
          var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
          var oid_attr := temp_attr.tmark(0@0);
          var oid_frag;
          if (is_constant(res_frag)) {
           oid_frag := res_frag;
          } else {
           oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
           oid_frag := oid_frag.tmark(0@0);
          }
          _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
          _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
          _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
          _attr_own  := temp_attr.hmark(0@0);
          _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
         } # end of create attribute subtree copies
        } else { # if (nodes.count() != 0) ...
         _elem_iter  := empty_bat;
         _elem_size  := empty_bat.project(int(nil));
         _elem_level := empty_bat.project(chr(nil));
         _elem_kind  := empty_bat.project(chr(nil));
         _elem_prop  := empty_bat;
         _elem_frag  := empty_bat;
         _attr_iter  := empty_bat;
         _attr_qn    := empty_bat;
         _attr_prop  := empty_bat;
         _attr_frag  := empty_bat;
         _attr_own   := empty_bat;
        } # end of else in 'if (nodes.count() != 0)'
       } # end of map2NODE_interface (counter)
       if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
        { # saveResult_node7 () : int
         var _elem_iter007   := _elem_iter  ;
         var _elem_size007   := _elem_size  ;
         var _elem_level007  := _elem_level ;
         var _elem_kind007   := _elem_kind  ;
         var _elem_prop007   := _elem_prop  ;
         var _elem_frag007   := _elem_frag  ;
         var _attr_iter007   := _attr_iter  ;
         var _attr_qn007     := _attr_qn    ;
         var _attr_prop007   := _attr_prop  ;
         var _attr_frag007   := _attr_frag  ;
         var _attr_own007    := _attr_own   ;
         var _r_attr_iter007 := _r_attr_iter;
         var _r_attr_qn007   := _r_attr_qn  ;
         var _r_attr_prop007 := _r_attr_prop;
         var _r_attr_frag007 := _r_attr_frag; # end of saveResult_node7 () : int
         _elem_iter := _elem_iter007;
         _elem_level := _elem_level007;
         _elem_kind := _elem_kind007;
         _elem_prop := _elem_prop007;
         _elem_frag := _elem_frag007;
         var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
         rootnodes := rootnodes.leftfetchjoin(_elem_kind);
         var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
         var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
         var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
         {
          var text_prop := textnodes.leftfetchjoin(_elem_prop);
          var text_frag := textnodes.leftfetchjoin(_elem_frag);
          var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
          var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
          var input_order := res_mu_is2ns.fetch(0);
          var input_str := res_mu_is2ns.fetch(1);
          var input_const := res_mu_is2ns.fetch(2);
          var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
          var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
          var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
          var result_order := result_str.hmark(0@0);
          result_order := result_order.leftfetchjoin(input_order);
          result_str := result_str.tmark(0@0);
          iter := result_order;
          ipik := iter;
          item_str_ := result_str;
         }
         { # adding new strings to text node content and create new nodes
          var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
          var unq_str := item_str_.tunique().hmark(0@0);
          var str_unq := reverse(unq_str.tdiff(ws_prop_text));
          var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
          unq_str := str_unq.hmark(seqb);
          ws_prop_text := ws_prop_text.insert(unq_str);
          var ws_text_prop := ws_prop_text.reverse().sort();
          item_str_ := item_str_.materialize(ipik);
          var X_item := item_str_.hmark(0@0);
          var X_strings := item_str_.tmark(0@0).tsort();
          var X_prop := X_strings.leftjoin(ws_text_prop);
          var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
          newPre_prop := newPre_prop.tmark(0@0);
          _elem_iter  := iter;
          _elem_size  := newPre_prop.project(0);
          _elem_level := newPre_prop.project(chr(0));
          _elem_kind  := newPre_prop.project(TEXT);
          _elem_prop  := newPre_prop;
          _elem_frag  := newPre_prop.project(WS);
         } # end of adding new fragments to the WS_FRAG bat
         var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter007), _elem_iter.leftfetchjoin(_elem_iter007), othernodes.leftfetchjoin(_elem_size007), _elem_size, othernodes.leftfetchjoin(_elem_level007), _elem_level, othernodes.leftfetchjoin(_elem_kind007), _elem_kind, othernodes.leftfetchjoin(_elem_prop007), _elem_prop, othernodes.leftfetchjoin(_elem_frag007), _elem_frag, othernodes.leftfetchjoin(_elem_iter007.mirror()), oid(nil));
         _elem_iter := res_mu_is2ns.fetch(1).chk_order();
         _elem_size := res_mu_is2ns.fetch(2);
         _elem_level:= res_mu_is2ns.fetch(3);
         _elem_kind := res_mu_is2ns.fetch(4);
         _elem_prop := res_mu_is2ns.fetch(5);
         _elem_frag := res_mu_is2ns.fetch(6);
         var preNew_preOld := res_mu_is2ns.fetch(7);
         _attr_own := _attr_own007.leftjoin(preNew_preOld.reverse());
         _attr_iter   := _attr_iter007  ;
         _attr_qn     := _attr_qn007    ;
         _attr_prop   := _attr_prop007  ;
         _attr_frag   := _attr_frag007  ;
         _r_attr_iter := _r_attr_iter007;
         _r_attr_qn   := _r_attr_qn007  ;
         _r_attr_prop := _r_attr_prop007;
         _r_attr_frag := _r_attr_frag007;
        } # end of deleteResult_node7 ()
       } # end of item-sequence-to-node-sequence
       { # loop_liftedElemConstr (counter)
        var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
        iter_size := {count}(iter_size, iter006.tunique(), FALSE);
        var root_iter  := iter_size.hmark(0@0).chk_order();
        var root_size  := iter_size.tmark(0@0);
        var root_prop  := iter006.reverse().leftfetchjoin(item006);
        if (not(is_constant(root_prop))) {
         root_prop  := root_prop.tmark(0@0);
        }
        {
         var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
         _elem_size  := merged_result.fetch(1);
         _elem_level := merged_result.fetch(2);
         _elem_kind  := merged_result.fetch(3);
         _elem_prop  := merged_result.fetch(4);
         _elem_frag  := merged_result.fetch(5);
         var preNew_preOld := merged_result.fetch(6);
         _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
         _attr_own := _attr_own.tmark(0@0);
        }
        { # create attribute root entries
         var root_item := _elem_level.ord_uselect(chr(0));
         root_item := root_item.hmark(0@0);
         var iter_item := iter006.reverse().leftfetchjoin(root_item);
         var attr_own := _r_attr_iter.leftjoin(iter_item);
         if (_r_attr_iter.count() != 0) { # test uniqueness
          var sorting := _r_attr_iter.tsort();
          sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
          var unq_attrs := sorting.tunique();
          if (unq_attrs.count() != _r_attr_iter.count()) {
           item006 := materialize(item006,ipik006);
           if (item006.count() > 0) {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item006.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
           } else {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
          }
         } # end of test uniqueness
         if (_attr_iter.count() = 0) {
          _attr_qn   := _r_attr_qn;
          _attr_prop := _r_attr_prop;
          _attr_frag := _r_attr_frag;
          _attr_own  := attr_own.tmark(0@0);
         } else {
          var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
          _r_attr_qn   := _r_attr_qn  .tmark(seqb);
          _r_attr_prop := _r_attr_prop.tmark(seqb);
          _r_attr_frag := _r_attr_frag.tmark(seqb);
          attr_own := attr_own.tmark(seqb);
          _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
          _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
          _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
          _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
         }
        } # end of create attribute root entries
        {
         var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
         var preOld_preNew := _elem_size.mark(seqb);
         _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
         _elem_size  := _elem_size.tmark(seqb);
         _elem_level := _elem_level.tmark(seqb);
         _elem_kind  := _elem_kind.tmark(seqb);
         _elem_prop  := _elem_prop.tmark(seqb);
         _elem_frag  := _elem_frag.tmark(seqb);
        }
        ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
        ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
        ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
        ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
        ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
        {
         var knd := ELEMENT;
         while ( knd <= DOCUMENT ) {
          var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
          ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
          if ( knd = ELEMENT ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
          }
          if ( knd = PI ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
          }
          knd :+= chr(1);
         }
        }
        var roots := _elem_level.ord_uselect(chr(0));
        roots := roots.hmark(0@0);
        {
         var height := int(_elem_level.max());
         ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
        }
        { # adding new fragments to the WS_FRAG bat
         var seqb := oid(count(ws.fetch(WS_FRAG)));
         var new_pres := roots.tmark(seqb);
         ws.fetch(WS_FRAG).insert(new_pres);
        }
        iter := iter006;
        item := roots;
        ipik := item;
        kind := ELEM;
        { # add attribute subtree copies to WS
         var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
         _attr_qn   := _attr_qn  .tmark(seqb);
         _attr_prop := _attr_prop.tmark(seqb);
         _attr_own  := _attr_own .tmark(seqb);
         _attr_frag := _attr_frag.tmark(seqb);
         ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
         ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
         ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
         ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
        } # end of add attribute subtree copies to WS
       } # end of loop_liftedElemConstr (counter)
      } # end of deleteResult6 ()
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
    } # end of evaluate_join
    { # map2NODE_interface (counter)
     kind := kind.materialize(ipik);
     var attr := kind.get_type(ATTR).hmark(0@0);
     var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
     var attr_item := attr.leftfetchjoin(item);
     var attr_frag := attr.leftfetchjoin(kind).get_fragment();
     _r_attr_iter := attr_iter;
     _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
     _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
     _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
     var nodes := kind.get_type(ELEM);
     if (nodes.count() != 0) {
      var oid_oid := nodes.hmark(0@0);
      var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
      var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
      var iter_input := oid_oid.mirror();
      var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
      var res_iter := res_scj.fetch(0);
      var res_item := res_scj.fetch(1);
      var res_frag := res_scj.fetch(2);
      _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
      _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
      _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
      _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
      _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
      var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
      var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
      nodes := res_item.mark(0@0);
      var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      root_level := nodes.leftfetchjoin(root_level);
      temp_ec_item := res_item;
      temp_ec_frag := res_frag;
      var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      content_level := nodes.leftfetchjoin(content_level);
      content_level := content_level.[-](root_level);
      content_level := content_level.tmark(0@0);
      _elem_level := content_level;
      { # create attribute subtree copies
       var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
       var oid_attr := temp_attr.tmark(0@0);
       var oid_frag;
       if (is_constant(res_frag)) {
        oid_frag := res_frag;
       } else {
        oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
        oid_frag := oid_frag.tmark(0@0);
       }
       _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
       _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
       _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
       _attr_own  := temp_attr.hmark(0@0);
       _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
      } # end of create attribute subtree copies
     } else { # if (nodes.count() != 0) ...
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of else in 'if (nodes.count() != 0)'
    } # end of map2NODE_interface (counter)
    # translateSeq_node (f, counter)
    if (_r_attr_iter.count() = 0) {
     _r_attr_iter := _r_attr_iter002;
     _r_attr_qn := _r_attr_qn002;
     _r_attr_prop := _r_attr_prop002;
     _r_attr_frag := _r_attr_frag002;
    } else {
     if (_r_attr_iter002.count() != 0) 
     { # combine attribute roots
      var merged_result := merged_union (_r_attr_iter002.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn002, _r_attr_qn, _r_attr_prop002, _r_attr_prop, _r_attr_frag002, _r_attr_frag);
      _r_attr_iter := merged_result.fetch(0);
      _r_attr_qn := merged_result.fetch(1);
      _r_attr_prop := merged_result.fetch(2);
      _r_attr_frag := merged_result.fetch(3);
     }
    } # end of combine attribute roots
    if (_elem_iter.count() = 0) {
     _elem_iter  := _elem_iter002  ;
     _elem_size  := _elem_size002  ;
     _elem_level := _elem_level002 ;
     _elem_kind  := _elem_kind002  ;
     _elem_prop  := _elem_prop002  ;
     _elem_frag  := _elem_frag002  ;
     _attr_iter  := _attr_iter002  ;
     _attr_qn    := _attr_qn002    ;
     _attr_prop  := _attr_prop002  ;
     _attr_frag  := _attr_frag002  ;
     _attr_own   := _attr_own002   ;
    } else {
     if (_elem_iter002.count() != 0) 
     { # combine element nodes
      var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
      var shift_factor := int(seqb) - int(_elem_size002.seqbase());
      var merged_result := merged_union (_elem_iter002.chk_order(), _elem_iter.chk_order(), _elem_size002, _elem_size, _elem_level002, _elem_level, _elem_kind002, _elem_kind, _elem_prop002, _elem_prop, _elem_frag002, _elem_frag, _elem_size002.mark(seqb), _elem_size.mirror());
      _elem_iter := merged_result.fetch(0);
      _elem_size := merged_result.fetch(1);
      _elem_level:= merged_result.fetch(2);
      _elem_kind := merged_result.fetch(3);
      _elem_prop := merged_result.fetch(4);
      _elem_frag := merged_result.fetch(5);
      var preNew_preOld := merged_result.fetch(6);
      _attr_own002 := _attr_own002.[int]().[+](shift_factor).[oid]();
      merged_result := merged_union (_attr_iter002, _attr_iter, _attr_qn002, _attr_qn, _attr_prop002, _attr_prop, _attr_frag002, _attr_frag, _attr_own002, _attr_own);
      _attr_iter := merged_result.fetch(0);
      _attr_qn   := merged_result.fetch(1);
      _attr_prop := merged_result.fetch(2);
      _attr_frag := merged_result.fetch(3);
      _attr_own  := merged_result.fetch(4);
      _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
      _attr_own := _attr_own.tmark(0@0);
     }
    } # combine element nodes
    # end of translateSeq_node (f, counter)
   } # end of deleteResult_node2 ()
   if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
    { # saveResult_node2 () : int
     var _elem_iter002   := _elem_iter  ;
     var _elem_size002   := _elem_size  ;
     var _elem_level002  := _elem_level ;
     var _elem_kind002   := _elem_kind  ;
     var _elem_prop002   := _elem_prop  ;
     var _elem_frag002   := _elem_frag  ;
     var _attr_iter002   := _attr_iter  ;
     var _attr_qn002     := _attr_qn    ;
     var _attr_prop002   := _attr_prop  ;
     var _attr_frag002   := _attr_frag  ;
     var _attr_own002    := _attr_own   ;
     var _r_attr_iter002 := _r_attr_iter;
     var _r_attr_qn002   := _r_attr_qn  ;
     var _r_attr_prop002 := _r_attr_prop;
     var _r_attr_frag002 := _r_attr_frag; # end of saveResult_node2 () : int
     _elem_iter := _elem_iter002;
     _elem_level := _elem_level002;
     _elem_kind := _elem_kind002;
     _elem_prop := _elem_prop002;
     _elem_frag := _elem_frag002;
     var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
     rootnodes := rootnodes.leftfetchjoin(_elem_kind);
     var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
     var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
     var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
     {
      var text_prop := textnodes.leftfetchjoin(_elem_prop);
      var text_frag := textnodes.leftfetchjoin(_elem_frag);
      var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
      var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
      var input_order := res_mu_is2ns.fetch(0);
      var input_str := res_mu_is2ns.fetch(1);
      var input_const := res_mu_is2ns.fetch(2);
      var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
      var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
      var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
      var result_order := result_str.hmark(0@0);
      result_order := result_order.leftfetchjoin(input_order);
      result_str := result_str.tmark(0@0);
      iter := result_order;
      ipik := iter;
      item_str_ := result_str;
     }
     { # adding new strings to text node content and create new nodes
      var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
      var unq_str := item_str_.tunique().hmark(0@0);
      var str_unq := reverse(unq_str.tdiff(ws_prop_text));
      var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
      unq_str := str_unq.hmark(seqb);
      ws_prop_text := ws_prop_text.insert(unq_str);
      var ws_text_prop := ws_prop_text.reverse().sort();
      item_str_ := item_str_.materialize(ipik);
      var X_item := item_str_.hmark(0@0);
      var X_strings := item_str_.tmark(0@0).tsort();
      var X_prop := X_strings.leftjoin(ws_text_prop);
      var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
      newPre_prop := newPre_prop.tmark(0@0);
      _elem_iter  := iter;
      _elem_size  := newPre_prop.project(0);
      _elem_level := newPre_prop.project(chr(0));
      _elem_kind  := newPre_prop.project(TEXT);
      _elem_prop  := newPre_prop;
      _elem_frag  := newPre_prop.project(WS);
     } # end of adding new fragments to the WS_FRAG bat
     var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter002), _elem_iter.leftfetchjoin(_elem_iter002), othernodes.leftfetchjoin(_elem_size002), _elem_size, othernodes.leftfetchjoin(_elem_level002), _elem_level, othernodes.leftfetchjoin(_elem_kind002), _elem_kind, othernodes.leftfetchjoin(_elem_prop002), _elem_prop, othernodes.leftfetchjoin(_elem_frag002), _elem_frag, othernodes.leftfetchjoin(_elem_iter002.mirror()), oid(nil));
     _elem_iter := res_mu_is2ns.fetch(1).chk_order();
     _elem_size := res_mu_is2ns.fetch(2);
     _elem_level:= res_mu_is2ns.fetch(3);
     _elem_kind := res_mu_is2ns.fetch(4);
     _elem_prop := res_mu_is2ns.fetch(5);
     _elem_frag := res_mu_is2ns.fetch(6);
     var preNew_preOld := res_mu_is2ns.fetch(7);
     _attr_own := _attr_own002.leftjoin(preNew_preOld.reverse());
     _attr_iter   := _attr_iter002  ;
     _attr_qn     := _attr_qn002    ;
     _attr_prop   := _attr_prop002  ;
     _attr_frag   := _attr_frag002  ;
     _r_attr_iter := _r_attr_iter002;
     _r_attr_qn   := _r_attr_qn002  ;
     _r_attr_prop := _r_attr_prop002;
     _r_attr_frag := _r_attr_frag002;
    } # end of deleteResult_node2 ()
   } # end of item-sequence-to-node-sequence
   { # loop_liftedElemConstr (counter)
    var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
    iter_size := {count}(iter_size, iter001.tunique(), FALSE);
    var root_iter  := iter_size.hmark(0@0).chk_order();
    var root_size  := iter_size.tmark(0@0);
    var root_prop  := iter001.reverse().leftfetchjoin(item001);
    if (not(is_constant(root_prop))) {
     root_prop  := root_prop.tmark(0@0);
    }
    {
     var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
     _elem_iter  := merged_result.fetch(0);
     _elem_size  := merged_result.fetch(1);
     _elem_level := merged_result.fetch(2);
     _elem_kind  := merged_result.fetch(3);
     _elem_prop  := merged_result.fetch(4);
     _elem_frag  := merged_result.fetch(5);
     var preNew_preOld := merged_result.fetch(6);
     _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
     _attr_own := _attr_own.tmark(0@0);
    }
    { # create attribute root entries
     var root_item := _elem_level.ord_uselect(chr(0));
     root_item := root_item.hmark(0@0);
     var iter_item := iter001.reverse().leftfetchjoin(root_item);
     var attr_own := _r_attr_iter.leftjoin(iter_item);
     if (_r_attr_iter.count() != 0) { # test uniqueness
      var sorting := _r_attr_iter.tsort();
      sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
      var unq_attrs := sorting.tunique();
      if (unq_attrs.count() != _r_attr_iter.count()) {
       item001 := materialize(item001,ipik001);
       if (item001.count() > 0) {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item001.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
       } else {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
       }
      }
     } # end of test uniqueness
     if (_attr_iter.count() = 0) {
      _attr_iter := _r_attr_iter;
      _attr_qn   := _r_attr_qn;
      _attr_prop := _r_attr_prop;
      _attr_frag := _r_attr_frag;
      _attr_own  := attr_own.tmark(0@0);
     } else {
      var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
      _r_attr_iter := _r_attr_iter.tmark(seqb);
      _r_attr_qn   := _r_attr_qn  .tmark(seqb);
      _r_attr_prop := _r_attr_prop.tmark(seqb);
      _r_attr_frag := _r_attr_frag.tmark(seqb);
      attr_own := attr_own.tmark(seqb);
      _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
      _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
      _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
      _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
      _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
     }
     _r_attr_iter := empty_bat;
     _r_attr_qn   := empty_bat;
     _r_attr_prop := empty_bat;
     _r_attr_frag := empty_bat;
    } # end of create attribute root entries
    {
     var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
     var preOld_preNew := _elem_size.mark(seqb);
     _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
     _elem_size  := _elem_size.tmark(seqb);
     _elem_level := _elem_level.tmark(seqb);
     _elem_kind  := _elem_kind.tmark(seqb);
     _elem_prop  := _elem_prop.tmark(seqb);
     _elem_frag  := _elem_frag.tmark(seqb);
    }
    ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
    ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
    ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
    ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
    ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
    {
     var knd := ELEMENT;
     while ( knd <= DOCUMENT ) {
      var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
      ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
      if ( knd = ELEMENT ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
      }
      if ( knd = PI ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
      }
      knd :+= chr(1);
     }
    }
    var roots := _elem_level.ord_uselect(chr(0));
    roots := roots.hmark(0@0);
    {
     var height := int(_elem_level.max());
     ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
    }
    { # adding new fragments to the WS_FRAG bat
     var seqb := oid(count(ws.fetch(WS_FRAG)));
     var new_pres := roots.tmark(seqb);
     ws.fetch(WS_FRAG).insert(new_pres);
    }
    iter := iter001;
    item := roots;
    kind := ELEM;
    { # add attribute subtree copies to WS
     var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
     _attr_qn   := _attr_qn  .tmark(seqb);
     _attr_prop := _attr_prop.tmark(seqb);
     _attr_own  := _attr_own .tmark(seqb);
     _attr_frag := _attr_frag.tmark(seqb);
     ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
     ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
     ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
     ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
    } # end of add attribute subtree copies to WS
   } # end of loop_liftedElemConstr (counter)
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn67B42CFE_q09_xs_string1
PROC fn678385B6_q10_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q10
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761067@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # insertVar (vid)
  var vid := project(ipik,1303761068@0);
  { # append (vid, level)
   var seqb := oid(v_vid000.count());
   vid := vid.materialize(ipik);
   v_vid000 := v_vid000.insert(vid.tmark(seqb));
  } # append (vid, level)
  { # append (iter, level)
   var seqb := oid(v_iter000.count());
   iter := iter.materialize(ipik);
   v_iter000 := v_iter000.insert(iter.tmark(seqb));
  } # append (iter, level)
  { # append (pos, level)
   var seqb ;
  } # append (pos, level)
  { # append (item, level)
   var seqb := oid(v_item000.count());
   item := item.materialize(ipik);
   v_item000 := v_item000.insert(item.tmark(seqb));
  } # append (item, level)
  { # append (kind, level)
   var seqb := oid(v_kind000.count());
   kind := kind.materialize(ipik);
   v_kind000 := v_kind000.insert(kind.tmark(seqb));
  } # append (kind, level)
 } # end of insertVar (vid)
 { # translateVar (auction)
  var vid := v_vid000.ord_uselect(1303761068@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  kind := vid.leftfetchjoin(v_kind000);
  ipik := iter;
 } # end of translateVar (auction)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "interest");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # loop_liftedSCJ (axis, kind, ns, loc)
  { # attribute axis
   var oid_iter := iter;
   var oid_item := item.materialize(ipik);
   var oid_frag := kind.get_fragment();
   var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
   oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
   var oid_attr := temp1.tmark(0@0);
   oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
   var temp1_str; # only needed for name test
   temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
   temp1 := temp1_str.ord_uselect("");
   temp1 := temp1.hmark(0@0);
   oid_attr := temp1.leftfetchjoin(oid_attr);
   oid_frag := temp1.leftfetchjoin(oid_frag);
   oid_iter := temp1.leftfetchjoin(oid_iter);
   temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
   temp1 := temp1_str.ord_uselect("category");
   temp1 := temp1.hmark(0@0);
   oid_attr := temp1.leftfetchjoin(oid_attr);
   oid_frag := temp1.leftfetchjoin(oid_frag);
   oid_iter := temp1.leftfetchjoin(oid_iter);
   iter := oid_iter.tmark(0@0);
   item := oid_attr.tmark(0@0);
   kind := oid_frag.tmark(0@0);
   if (type(iter) = bat) {
    ipik := iter;
   } else {
    if (type(item) = bat) {
     ipik := item;
    } else {
     ipik := kind;
    }
   }
  } # end of attribute axis
  kind := kind.set_kind(ATTR);
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761046@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761069@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (#pf:v_2810)
   var vid := v_vid001.ord_uselect(1303761069@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (#pf:v_2810)
  { # string-value
   var input_iter := iter;
   kind := kind.materialize(ipik);
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   var kind_elem := kind.get_type(ELEM);
   var item_str;
   if (kind_elem.count() = kind.count()) {
    var frag := kind.get_fragment();
    var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
    var t_iter := res_scj.fetch(0);
    var t_item := res_scj.fetch(1);
    var t_frag := res_scj.fetch(2);
    var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
    var t_iter_unq := t_iter.tunique();
    t_iter := t_iter.materialize(t_item);
    if (t_iter_unq.count() != t_item.count()) {
     var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
     iter_item := iter_item.string_join(t_iter_unq.project(""));
     t_iter := iter_item.hmark(0@0);
     t_item_str := iter_item.tmark(0@0);
    }
    var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
    if (c_map.count() > 0) { #process comments 
     var c_iter := c_map.leftfetchjoin(iter);
     var c_item := c_map.leftfetchjoin(item);
     var c_frag := c_map.leftfetchjoin(frag);
     var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
     var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
     t_iter := res_mu.fetch(0);
     t_item_str := res_mu.fetch(1);
    } # end of comment processing
    var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
    if (pi_map.count() > 0) { #process processing-instructions 
     var pi_iter := pi_map.leftfetchjoin(iter);
     var pi_item := pi_map.leftfetchjoin(item);
     var pi_frag := pi_map.leftfetchjoin(frag);
     var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
     var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
     t_item_str := res_mu.fetch(1);
    } # end of processing-instruction processing
    iter := t_iter;
    item_str := t_item_str;
   } else {
    var kind_attr := kind.get_type(ATTR);
    if (kind_attr.count() = kind.count()) {
     var frag := kind.get_fragment();
     item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
    } else {
     kind_attr := kind_attr.hmark(0@0);
     var item_attr := kind_attr.leftfetchjoin(item);
     var iter_attr := kind_attr.leftfetchjoin(iter);
     var frag := kind_attr.leftfetchjoin(kind).get_fragment();
     var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
     kind_elem := kind_elem.hmark(0@0);
     iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
     frag := kind_elem.leftfetchjoin(kind).get_fragment();
     item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
     var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
     var t_iter := res_scj.fetch(0);
     var t_item := res_scj.fetch(1);
     var t_frag := res_scj.fetch(2);
     var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
     var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
     t_iter := iter_item.hmark(0@0);
     t_item_str := iter_item.tmark(0@0);
     var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
     t_iter := res_mu.fetch(0);
     t_item_str := res_mu.fetch(1);
     iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
     {
      var item_unq := iter_item.reverse().tunique();
      if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
     }
     t_iter := iter_item.hmark(0@0);
     var t_item_str := iter_item.tmark(0@0);
     var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
     if (c_map.count() > 0) { #process comments 
      var c_iter := c_map.leftfetchjoin(iter);
      var c_item := c_map.leftfetchjoin(item);
      var c_frag := c_map.leftfetchjoin(frag);
      var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
      var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
     } # end of comment processing
     var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
     if (pi_map.count() > 0) { #process processing-instructions 
      var pi_iter := pi_map.leftfetchjoin(iter);
      var pi_item := pi_map.leftfetchjoin(item);
      var pi_frag := pi_map.leftfetchjoin(frag);
      var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
      var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
     } # end of processing-instruction processing
     iter := t_iter;
     item_str := t_item_str;
    }
   }
   item_str_ := item_str;
   if (iter.count() != input_iter.tunique().count()) {
    var difference := reverse(input_iter.tdiff(iter));
    difference := difference.hmark(0@0);
    var res_mu := merged_union(iter, difference, item_str_, "");
    iter := res_mu.fetch(0);
    item_str_ := res_mu.fetch(1);
   }
   ipik := iter;
   kind := STR;
  } # end of string-value
  { # cast from string to untypedAtomic
   item := str_values.addValues(item_str_).tmark(0@0);
   if (iter.count() != loop001.count()) {
    ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
   }
  } # end of cast from string to untypedAtomic
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 { # translate fn:distinct-values (atomic*) as atomic*
  var sorting := iter.tsort();
  sorting := sorting.CTrefine(kind);
  sorting := sorting.CTrefine(item);
  sorting := sorting.materialize(ipik);
  ipik := sorting.reverse().{min}().tmark(0@0);
  iter := ipik.leftfetchjoin(iter);
  item := ipik.leftfetchjoin(item);
  kind := ipik.leftfetchjoin(kind);
 } # end of translate fn:distinct-values (atomic*) as atomic*
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761047@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761070@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # tagname-translation
   var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
   var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
   var itemID;
   if (prop_str.texist("categorie")) {
    itemID := prop_str.reverse().find("categorie");
   } else {
    itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
    ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
    ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
    ws.fetch(QN_LOC).fetch(WS).insert(itemID,"categorie");
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
    ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"categorie"+str('\1')+"");
   } # translateConst (kind)
   iter := loop001.tmark(0@0);
   ipik := iter;
   item := itemID;
  } # end of tagname-translation
  { # saveResult1 () : int
   var ipik001 := ipik;
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # tagname-translation
    var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
    var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    var itemID;
    if (prop_str.texist("id")) {
     itemID := prop_str.reverse().find("id");
    } else {
     itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
     ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
     ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
     ws.fetch(QN_LOC).fetch(WS).insert(itemID,"id");
     ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
     ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"id"+str('\1')+"");
    } # translateConst (kind)
    iter := loop001.tmark(0@0);
    ipik := iter;
    item := itemID;
   } # end of tagname-translation
   { # saveResult2 () : int
    var ipik002 := ipik;
    var iter002 := iter;
    var item002 := item; # end of saveResult2 () : int
    { # translateVar (i)
     var vid := v_vid001.ord_uselect(1303761070@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (i)
    { # saveResult3 () : int
     var ipik003 := ipik;
     var iter003 := iter;
     var item003 := item;
     var kind003 := kind; # end of saveResult3 () : int
     { # item-sequence-to-node-sequence
      var nodes_order;
      {
       ipik := ipik003;
       item := item003;
       kind := kind003;
       kind := kind.materialize(ipik);
       var elem := kind.get_type(ELEM);
       elem := elem.hmark(0@0);
       var kind_elem := elem.leftfetchjoin(kind);
       var frag_elem := kind_elem.get_fragment();
       var item_elem := elem.leftfetchjoin(item).materialize(elem);
       var kind_node := mposjoin (item_elem, frag_elem, ws.fetch(PRE_KIND));
       var text := kind_node.ord_uselect(TEXT).hmark(0@0);
       var item_text := text.leftfetchjoin(item_elem);
       var frag_text := text.leftfetchjoin(frag_elem);
       var text_str := mposjoin (mposjoin (item_text, frag_text, ws.fetch(PRE_PROP)), mposjoin (item_text, frag_text, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var str_text := text_str.reverse().leftfetchjoin(text);
       var texts := str_text.leftfetchjoin(elem).reverse();
       var texts_order := texts.hmark(0@0);
       texts := texts.tmark(0@0);
       var nodes := kind_node.[!=](TEXT).ord_uselect(true).project("");
       nodes := nodes.reverse().leftfetchjoin(elem).reverse();
       nodes_order := nodes.hmark(0@0);
       nodes := nodes.tmark(0@0);
       var res_mu_is2ns := merged_union (nodes_order, texts_order, nodes, texts, 0@0, 1@0);
       var input_order := res_mu_is2ns.fetch(0);
       var input_str := res_mu_is2ns.fetch(1);
       var input_const := res_mu_is2ns.fetch(2);
       kind := kind.materialize(ipik);
       var atomic := kind.get_type_atomic();
       atomic := atomic.hmark(0@0);
       item := atomic.leftfetchjoin(item);
       item_str_ := item.leftfetchjoin(str_values);
       res_mu_is2ns := merged_union (input_order, atomic, input_str, item_str_, input_const, 2@0);
       input_order := res_mu_is2ns.fetch(0);
       input_str := res_mu_is2ns.fetch(1);
       input_const := res_mu_is2ns.fetch(2);
       var input_iter := input_order.leftfetchjoin(iter003).chk_order();
       var result_size := iter003.tunique().count() + nodes_order.count() + 1;
       var result_str := combine_text_string (input_iter.materialize(input_str), input_const.materialize(input_str), input_str, result_size);
       var result_order := result_str.hmark(0@0);
       result_order := result_order.leftfetchjoin(input_order);
       result_str := result_str.tmark(0@0);
       iter := result_order;
       ipik := iter;
       item_str_ := result_str;
      }
      { # adding new strings to text node content and create new nodes
       var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
       var unq_str := item_str_.tunique().hmark(0@0);
       var str_unq := reverse(unq_str.tdiff(ws_prop_text));
       var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
       unq_str := str_unq.hmark(seqb);
       ws_prop_text := ws_prop_text.insert(unq_str);
       var ws_text_prop := ws_prop_text.reverse().sort();
       item_str_ := item_str_.materialize(ipik);
       var X_item := item_str_.hmark(0@0);
       var X_strings := item_str_.tmark(0@0).tsort();
       var X_prop := X_strings.leftjoin(ws_text_prop);
       var newPre_prop := X_item.reverse().leftjoin(X_prop);
       seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS))+ int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
       newPre_prop := newPre_prop.tmark(seqb);
       ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
       ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
       ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
       ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
       ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));
       {
        var kind_pre_ := newPre_prop.hmark(nil).chk_order();
        ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
       }
       item := item_str_.mark(seqb);
       kind := ELEM;
      } # end of adding new strings to text node content and create new nodes
      { # adding new fragments to the WS_FRAG bat
       var seqb := ws.fetch(WS_FRAG).count();
       seqb := oid(seqb);
       var new_pres := item.tmark(seqb);
       ws.fetch(WS_FRAG).insert(new_pres);
       ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
      } # end of adding new fragments to the WS_FRAG bat
      var res_mu_is2ns := merged_union (iter, nodes_order, item, nodes_order.leftfetchjoin(item003), kind, nodes_order.leftfetchjoin(kind003));
      kind003 := kind003.materialize(ipik003);
      var attr := kind003.get_type(ATTR).hmark(0@0);
      var item_attr := attr.leftfetchjoin(item003);
      var kind_attr := attr.leftfetchjoin(kind003);
      res_mu_is2ns := merged_union (res_mu_is2ns.fetch(0), attr, res_mu_is2ns.fetch(1), item_attr, res_mu_is2ns.fetch(2), kind_attr);
      iter := res_mu_is2ns.fetch(0).leftfetchjoin(iter003);
      item := res_mu_is2ns.fetch(1);
      kind := res_mu_is2ns.fetch(2);
      ipik := item;
     } # end of item-sequence-to-node-sequence
    } # end of deleteResult3 ()
    { # map2NODE_interface (counter)
     kind := kind.materialize(ipik);
     var attr := kind.get_type(ATTR).hmark(0@0);
     var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
     var attr_item := attr.leftfetchjoin(item);
     var attr_frag := attr.leftfetchjoin(kind).get_fragment();
     _r_attr_iter := attr_iter;
     _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
     _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
     _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
     var nodes := kind.get_type(ELEM);
     if (nodes.count() != 0) {
      var oid_oid := nodes.hmark(0@0);
      var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
      var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
      var iter_input := oid_oid.mirror();
      var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
      var res_iter := res_scj.fetch(0);
      var res_item := res_scj.fetch(1);
      var res_frag := res_scj.fetch(2);
      _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
      _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
      _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
      _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
      _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
      var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
      var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
      nodes := res_item.mark(0@0);
      var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      root_level := nodes.leftfetchjoin(root_level);
      temp_ec_item := res_item;
      temp_ec_frag := res_frag;
      var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      content_level := nodes.leftfetchjoin(content_level);
      content_level := content_level.[-](root_level);
      content_level := content_level.tmark(0@0);
      _elem_level := content_level;
      { # create attribute subtree copies
       var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
       var oid_attr := temp_attr.tmark(0@0);
       var oid_frag;
       if (is_constant(res_frag)) {
        oid_frag := res_frag;
       } else {
        oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
        oid_frag := oid_frag.tmark(0@0);
       }
       _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
       _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
       _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
       _attr_own  := temp_attr.hmark(0@0);
       _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
      } # end of create attribute subtree copies
     } else { # if (nodes.count() != 0) ...
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of else in 'if (nodes.count() != 0)'
    } # end of map2NODE_interface (counter)
    { # loop_liftedElemConstr (counter)
     var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
     iter_size := {count}(iter_size, iter002.tunique(), FALSE);
     var root_iter  := iter_size.hmark(0@0).chk_order();
     var root_size  := iter_size.tmark(0@0);
     var root_prop  := iter002.reverse().leftfetchjoin(item002);
     if (not(is_constant(root_prop))) {
      root_prop  := root_prop.tmark(0@0);
     }
     {
      var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
      _elem_iter  := merged_result.fetch(0);
      _elem_size  := merged_result.fetch(1);
      _elem_level := merged_result.fetch(2);
      _elem_kind  := merged_result.fetch(3);
      _elem_prop  := merged_result.fetch(4);
      _elem_frag  := merged_result.fetch(5);
      var preNew_preOld := merged_result.fetch(6);
      _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
      _attr_own := _attr_own.tmark(0@0);
     }
     { # create attribute root entries
      var root_item := _elem_level.ord_uselect(chr(0));
      root_item := root_item.hmark(0@0);
      var iter_item := iter002.reverse().leftfetchjoin(root_item);
      var attr_own := _r_attr_iter.leftjoin(iter_item);
      if (_r_attr_iter.count() != 0) { # test uniqueness
       var sorting := _r_attr_iter.tsort();
       sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
       var unq_attrs := sorting.tunique();
       if (unq_attrs.count() != _r_attr_iter.count()) {
        item002 := materialize(item002,ipik002);
        if (item002.count() > 0) {
         ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item002.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
        } else {
         ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
        }
       }
      } # end of test uniqueness
      if (_attr_iter.count() = 0) {
       _attr_iter := _r_attr_iter;
       _attr_qn   := _r_attr_qn;
       _attr_prop := _r_attr_prop;
       _attr_frag := _r_attr_frag;
       _attr_own  := attr_own.tmark(0@0);
      } else {
       var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
       _r_attr_iter := _r_attr_iter.tmark(seqb);
       _r_attr_qn   := _r_attr_qn  .tmark(seqb);
       _r_attr_prop := _r_attr_prop.tmark(seqb);
       _r_attr_frag := _r_attr_frag.tmark(seqb);
       attr_own := attr_own.tmark(seqb);
       _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
       _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
       _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
       _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
       _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
      }
      _r_attr_iter := empty_bat;
      _r_attr_qn   := empty_bat;
      _r_attr_prop := empty_bat;
      _r_attr_frag := empty_bat;
     } # end of create attribute root entries
    } # end of loop_liftedElemConstr (counter)
   } # end of deleteResult2 ()
   { # saveResult_node2 () : int
    var _elem_iter002   := _elem_iter  ;
    var _elem_size002   := _elem_size  ;
    var _elem_level002  := _elem_level ;
    var _elem_kind002   := _elem_kind  ;
    var _elem_prop002   := _elem_prop  ;
    var _elem_frag002   := _elem_frag  ;
    var _attr_iter002   := _attr_iter  ;
    var _attr_qn002     := _attr_qn    ;
    var _attr_prop002   := _attr_prop  ;
    var _attr_frag002   := _attr_frag  ;
    var _attr_own002    := _attr_own   ;
    var _r_attr_iter002 := _r_attr_iter;
    var _r_attr_qn002   := _r_attr_qn  ;
    var _r_attr_prop002 := _r_attr_prop;
    var _r_attr_frag002 := _r_attr_frag; # end of saveResult_node2 () : int
    {
     var iter003;
     var item003;
     var kind003;
     var ipik004;
     var iter004;
     var item004;
     var match_outer004;
     var ipik005;
     var iter005;
     var item005;
     var match_outer005;
     var jouter004 ;
     var jorder_004 ;
     var jinner004 ;
     var jloop004  ;
     var jv_vid004 ;
     var jv_iter004;
     var jv_pos004 ;
     var jv_item004;
     var jv_kind004;
     { # translateVar (i)
      var vid := v_vid001.ord_uselect(1303761070@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      ipik := iter;
     } # end of translateVar (i)
     { # cast from untypedAtomic to string
      item_str_ := item.leftfetchjoin(str_values);
      if (iter.count() != loop001.count()) {
       ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
      }
     } # end of cast from untypedAtomic to string
     {
      var mapping := outer000.reverse().leftfetchjoin(inner000);
      mapping := mapping.leftjoin(outer001.reverse());
      mapping := mapping.leftfetchjoin(inner001);
      match_outer004 := iter.leftjoin(mapping.reverse()).tmark(iter.seqbase());
     }
     ipik004 := ipik;
     iter004 := iter;
     item004 := item_str_;
     jouter004  := outer001 ;
     jinner004  := inner001 ;
     jv_vid004  := v_vid001 ;
     jv_iter004 := v_iter001;
     jv_item004 := v_item001;
     jv_kind004 := v_kind001;
     v_vid001  := v_vid000 .copy().access(BAT_WRITE);
     v_iter001 := v_iter000.copy().access(BAT_WRITE);
     v_item001 := v_item000.copy().access(BAT_WRITE);
     v_kind001 := v_kind000.copy().access(BAT_WRITE);
     { # translateVar (auction)
      var vid := v_vid001.ord_uselect(1303761068@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (auction)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "person");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      var v_vid002;
      var v_iter002;
      var v_item002;
      var v_kind002;
      iter003 := iter;
      item003 := item;
      kind003 := kind;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761048@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761071@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (t)
       var vid := v_vid002.ord_uselect(1303761071@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (t)
      { # translateLocsteps (c)
       var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "profile");
       iter := res_scj.fetch(0);
       item := res_scj.fetch(1);
       kind := res_scj.fetch(2).set_kind(ELEM);
       ipik := item;
      } # end of translateLocsteps (c)
      { # translateLocsteps (c)
       var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, "", "interest");
       iter := res_scj.fetch(0);
       item := res_scj.fetch(1);
       kind := res_scj.fetch(2).set_kind(ELEM);
       ipik := item;
      } # end of translateLocsteps (c)
      { # loop_liftedSCJ (axis, kind, ns, loc)
       { # attribute axis
        var oid_iter := iter;
        var oid_item := item.materialize(ipik);
        var oid_frag := kind.get_fragment();
        var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
        oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
        var oid_attr := temp1.tmark(0@0);
        oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
        var temp1_str; # only needed for name test
        temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
        temp1 := temp1_str.ord_uselect("");
        temp1 := temp1.hmark(0@0);
        oid_attr := temp1.leftfetchjoin(oid_attr);
        oid_frag := temp1.leftfetchjoin(oid_frag);
        oid_iter := temp1.leftfetchjoin(oid_iter);
        temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
        temp1 := temp1_str.ord_uselect("category");
        temp1 := temp1.hmark(0@0);
        oid_attr := temp1.leftfetchjoin(oid_attr);
        oid_frag := temp1.leftfetchjoin(oid_frag);
        oid_iter := temp1.leftfetchjoin(oid_iter);
        iter := oid_iter.tmark(0@0);
        item := oid_attr.tmark(0@0);
        kind := oid_frag.tmark(0@0);
        if (type(iter) = bat) {
         ipik := iter;
        } else {
         if (type(item) = bat) {
          ipik := item;
         } else {
          ipik := kind;
         }
        }
       } # end of attribute axis
       kind := kind.set_kind(ATTR);
      } # end of translateLocsteps (c)
      if (ipik.count() != 0) 
      { # for-translation
       # project ()
       iter := iter.materialize(ipik);
       var outer003 := iter;
       iter := iter.mark(1@0);
       var inner003 := iter;
       var loop003 := inner003;
       var v_vid003;
       var v_iter003;
       var v_item003;
       var v_kind003;
       var expOid;
       { # getExpanded (fid)
        var vu_nil := vu_fid.ord_uselect(1303761049@0);
        var vid_vu := vu_vid.reverse();
        var oid_nil := vid_vu.leftjoin(vu_nil);
        expOid := v_vid002.leftjoin(oid_nil);
        expOid := expOid.mirror();
       } # end of getExpanded (fid)
       if (expOid.count() != 0) {
        var oidNew_expOid;
        { # expand ()
         var expOid_iter := expOid.leftfetchjoin(v_iter002);
         var iter_expOid := expOid_iter.reverse();
         var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
         var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
         oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
         var expOid_oidMap := oidMap_expOid.reverse();
         expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
         v_iter003 := expOid_iter;
         oidNew_expOid := expOid_iter.hmark(0@0);
        } # end of expand ()
        # join ()
        var cnt := count(v_iter003)*2;
        v_iter003 := v_iter003.tmark(0@0);
        var new_v_iter := v_iter003;
        v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
        var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
        v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
        var new_v_pos ;
        var new_v_item := oidNew_expOid.leftjoin(v_item002);
        v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
        var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
        v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
       } else { # createNewVarTable ()
        v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
       }
       { # insertVar (vid)
        var vid := project(ipik,1303761072@0);
        { # append (vid, level)
         var seqb := oid(v_vid003.count());
         vid := vid.materialize(ipik);
         v_vid003 := v_vid003.insert(vid.tmark(seqb));
        } # append (vid, level)
        { # append (iter, level)
         var seqb := oid(v_iter003.count());
         iter := iter.materialize(ipik);
         v_iter003 := v_iter003.insert(iter.tmark(seqb));
        } # append (iter, level)
        { # append (pos, level)
         var seqb ;
        } # append (pos, level)
        { # append (item, level)
         var seqb := oid(v_item003.count());
         item := item.materialize(ipik);
         v_item003 := v_item003.insert(item.tmark(seqb));
        } # append (item, level)
        { # append (kind, level)
         var seqb := oid(v_kind003.count());
         kind := kind.materialize(ipik);
         v_kind003 := v_kind003.insert(kind.tmark(seqb));
        } # append (kind, level)
       } # end of insertVar (vid)
       { # translateVar (#pf:v_2812)
        var vid := v_vid003.ord_uselect(1303761072@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter003);
        item := vid.leftfetchjoin(v_item003);
        kind := vid.leftfetchjoin(v_kind003);
        ipik := iter;
       } # end of translateVar (#pf:v_2812)
       { # string-value
        var input_iter := iter;
        kind := kind.materialize(ipik);
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        var kind_elem := kind.get_type(ELEM);
        var item_str;
        if (kind_elem.count() = kind.count()) {
         var frag := kind.get_fragment();
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var t_iter_unq := t_iter.tunique();
         t_iter := t_iter.materialize(t_item);
         if (t_iter_unq.count() != t_item.count()) {
          var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          iter_item := iter_item.string_join(t_iter_unq.project(""));
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
         }
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        } else {
         var kind_attr := kind.get_type(ATTR);
         if (kind_attr.count() = kind.count()) {
          var frag := kind.get_fragment();
          item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         } else {
          kind_attr := kind_attr.hmark(0@0);
          var item_attr := kind_attr.leftfetchjoin(item);
          var iter_attr := kind_attr.leftfetchjoin(iter);
          var frag := kind_attr.leftfetchjoin(kind).get_fragment();
          var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
          kind_elem := kind_elem.hmark(0@0);
          iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
          frag := kind_elem.leftfetchjoin(kind).get_fragment();
          item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
          var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
          var t_iter := res_scj.fetch(0);
          var t_item := res_scj.fetch(1);
          var t_frag := res_scj.fetch(2);
          var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
          var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
          var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
          iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          {
           var item_unq := iter_item.reverse().tunique();
           if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
          }
          t_iter := iter_item.hmark(0@0);
          var t_item_str := iter_item.tmark(0@0);
          var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
          if (c_map.count() > 0) { #process comments 
           var c_iter := c_map.leftfetchjoin(iter);
           var c_item := c_map.leftfetchjoin(item);
           var c_frag := c_map.leftfetchjoin(frag);
           var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
           var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of comment processing
          var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
          if (pi_map.count() > 0) { #process processing-instructions 
           var pi_iter := pi_map.leftfetchjoin(iter);
           var pi_item := pi_map.leftfetchjoin(item);
           var pi_frag := pi_map.leftfetchjoin(frag);
           var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
           var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of processing-instruction processing
          iter := t_iter;
          item_str := t_item_str;
         }
        }
        item_str_ := item_str;
        if (iter.count() != input_iter.tunique().count()) {
         var difference := reverse(input_iter.tdiff(iter));
         difference := difference.hmark(0@0);
         var res_mu := merged_union(iter, difference, item_str_, "");
         iter := res_mu.fetch(0);
         item_str_ := res_mu.fetch(1);
        }
        ipik := iter;
       } # end of string-value
       { # cast from string to untypedAtomic
        if (iter.count() != loop003.count()) {
         ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
        }
       } # end of cast from string to untypedAtomic
       { # cast from untypedAtomic to string
        if (iter.count() != loop003.count()) {
         ERROR("err:XPTY0004: cast to 'string' does not allow empty sequences to be casted.");
        }
       } # end of cast from untypedAtomic to string
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
       # cleanUpLevel ()
      } # end of for-translation
      ipik005 := ipik;
      iter005 := iter;
      item005 := item_str_;
      match_outer005 := iter.leftfetchjoin(inner002.reverse()).leftfetchjoin(outer002); # cleanUpLevel ()
     } # end of for-translation
     outer001  := jouter004 ;
     inner001  := jinner004 ;
     v_vid001  := jv_vid004 ;
     v_iter001 := jv_iter004;
     v_item001 := jv_item004;
     v_kind001 := jv_kind004;
     var join_item1 := item004;
     var join_item2 := item005;
     join_item1 := join_item1.materialize(ipik004);
     join_item1 := join_item1.reverse().leftfetchjoin(iter004).reverse();
     join_item2 := join_item2.materialize(ipik005);
     join_item2 := join_item2.reverse().leftfetchjoin(iter005).reverse();
     var join_result := ll_htordered_unique_thetajoin(EQ, join_item1, join_item2, match_outer004, match_outer005,nil,iter003.reverse());
     var snd_iter := join_result.tmark(0@0);
     var fst_iter := join_result.hmark(0@0);
     ipik := fst_iter; # order_fst isn't needed until now
     # (cannot be pushed below the theta-join due to the 'iter := fst_iter;' hereafter)
     # var order_fst := fst_iter.leftfetchjoin(inner001.reverse());
     var order_snd := snd_iter; #.leftfetchjoin(iter003.reverse()); pushed below theta-join
     { # for-translation
      iter := fst_iter; # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      var loop002 := inner002;
      var v_vid002;
      var v_iter002;
      var v_item002;
      var v_kind002;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761050@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      } # could also be pushed below theta-join, if order_snd wasn't needed for kind (below) ...
      item := order_snd.leftfetchjoin(item003);
      iter := ipik.mark(1@0); # could also be pushed below theta-join, if order_snd wasn't needed for item (above) ...
      kind := order_snd.leftfetchjoin(kind003);
      { # insertVar (vid)
       var vid := project(ipik,1303761071@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # tagname-translation
       var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
       var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
       var itemID;
       if (prop_str.texist("personne")) {
        itemID := prop_str.reverse().find("personne");
       } else {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
        ws.fetch(QN_LOC).fetch(WS).insert(itemID,"personne");
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"personne"+str('\1')+"");
       } # translateConst (kind)
       iter := loop002.tmark(0@0);
       ipik := iter;
       item := itemID;
      } # end of tagname-translation
      { # saveResult6 () : int
       var ipik006 := ipik;
       var iter006 := iter;
       var item006 := item; # end of saveResult6 () : int
       { # tagname-translation
        var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
        var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
        var itemID;
        if (prop_str.texist("statistiques")) {
         itemID := prop_str.reverse().find("statistiques");
        } else {
         itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
         ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
         ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
         ws.fetch(QN_LOC).fetch(WS).insert(itemID,"statistiques");
         ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
         ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"statistiques"+str('\1')+"");
        } # translateConst (kind)
        iter := loop002.tmark(0@0);
        ipik := iter;
        item := itemID;
       } # end of tagname-translation
       { # saveResult7 () : int
        var ipik007 := ipik;
        var iter007 := iter;
        var item007 := item; # end of saveResult7 () : int
        { # tagname-translation
         var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
         var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
         var itemID;
         if (prop_str.texist("sexe")) {
          itemID := prop_str.reverse().find("sexe");
         } else {
          itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
          ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
          ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
          ws.fetch(QN_LOC).fetch(WS).insert(itemID,"sexe");
          ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
          ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"sexe"+str('\1')+"");
         } # translateConst (kind)
         iter := loop002.tmark(0@0);
         ipik := iter;
         item := itemID;
        } # end of tagname-translation
        { # saveResult8 () : int
         var ipik008 := ipik;
         var iter008 := iter;
         var item008 := item; # end of saveResult8 () : int
         { # translateVar (t)
          var vid := v_vid002.ord_uselect(1303761071@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter002);
          item := vid.leftfetchjoin(v_item002);
          kind := vid.leftfetchjoin(v_kind002);
          ipik := iter;
         } # end of translateVar (t)
         { # translateLocsteps (c)
          var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "profile");
          iter := res_scj.fetch(0);
          item := res_scj.fetch(1);
          kind := res_scj.fetch(2).set_kind(ELEM);
          ipik := item;
         } # end of translateLocsteps (c)
         { # translateLocsteps (c)
          var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "gender");
          iter := res_scj.fetch(0);
          item := res_scj.fetch(1);
          kind := res_scj.fetch(2).set_kind(ELEM);
          ipik := item;
         } # end of translateLocsteps (c)
         { # translateLocsteps (c)
          var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
          iter := res_scj.fetch(0);
          item := res_scj.fetch(1);
          kind := res_scj.fetch(2).set_kind(ELEM);
          ipik := item;
         } # end of translateLocsteps (c)
         { # map2NODE_interface (counter)
          kind := kind.materialize(ipik);
          var attr := kind.get_type(ATTR).hmark(0@0);
          var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
          var attr_item := attr.leftfetchjoin(item);
          var attr_frag := attr.leftfetchjoin(kind).get_fragment();
          _r_attr_iter := attr_iter;
          _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
          _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
          _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
          var nodes := kind.get_type(ELEM);
          if (nodes.count() != 0) {
           var oid_oid := nodes.hmark(0@0);
           var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
           var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
           var iter_input := oid_oid.mirror();
           var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
           var res_iter := res_scj.fetch(0);
           var res_item := res_scj.fetch(1);
           var res_frag := res_scj.fetch(2);
           _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
           _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
           _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
           _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
           _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
           var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
           var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
           nodes := res_item.mark(0@0);
           var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
           root_level := nodes.leftfetchjoin(root_level);
           temp_ec_item := res_item;
           temp_ec_frag := res_frag;
           var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
           content_level := nodes.leftfetchjoin(content_level);
           content_level := content_level.[-](root_level);
           content_level := content_level.tmark(0@0);
           _elem_level := content_level;
           { # create attribute subtree copies
            var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
            var oid_attr := temp_attr.tmark(0@0);
            var oid_frag;
            if (is_constant(res_frag)) {
             oid_frag := res_frag;
            } else {
             oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
             oid_frag := oid_frag.tmark(0@0);
            }
            _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
            _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
            _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
            _attr_own  := temp_attr.hmark(0@0);
            _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
           } # end of create attribute subtree copies
          } else { # if (nodes.count() != 0) ...
           _elem_iter  := empty_bat;
           _elem_size  := empty_bat.project(int(nil));
           _elem_level := empty_bat.project(chr(nil));
           _elem_kind  := empty_bat.project(chr(nil));
           _elem_prop  := empty_bat;
           _elem_frag  := empty_bat;
           _attr_iter  := empty_bat;
           _attr_qn    := empty_bat;
           _attr_prop  := empty_bat;
           _attr_frag  := empty_bat;
           _attr_own   := empty_bat;
          } # end of else in 'if (nodes.count() != 0)'
         } # end of map2NODE_interface (counter)
         if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
          { # saveResult_node9 () : int
           var _elem_iter009   := _elem_iter  ;
           var _elem_size009   := _elem_size  ;
           var _elem_level009  := _elem_level ;
           var _elem_kind009   := _elem_kind  ;
           var _elem_prop009   := _elem_prop  ;
           var _elem_frag009   := _elem_frag  ;
           var _attr_iter009   := _attr_iter  ;
           var _attr_qn009     := _attr_qn    ;
           var _attr_prop009   := _attr_prop  ;
           var _attr_frag009   := _attr_frag  ;
           var _attr_own009    := _attr_own   ;
           var _r_attr_iter009 := _r_attr_iter;
           var _r_attr_qn009   := _r_attr_qn  ;
           var _r_attr_prop009 := _r_attr_prop;
           var _r_attr_frag009 := _r_attr_frag; # end of saveResult_node9 () : int
           _elem_iter := _elem_iter009;
           _elem_level := _elem_level009;
           _elem_kind := _elem_kind009;
           _elem_prop := _elem_prop009;
           _elem_frag := _elem_frag009;
           var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
           rootnodes := rootnodes.leftfetchjoin(_elem_kind);
           var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
           var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
           var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
           {
            var text_prop := textnodes.leftfetchjoin(_elem_prop);
            var text_frag := textnodes.leftfetchjoin(_elem_frag);
            var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
            var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
            var input_order := res_mu_is2ns.fetch(0);
            var input_str := res_mu_is2ns.fetch(1);
            var input_const := res_mu_is2ns.fetch(2);
            var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
            var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
            var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
            var result_order := result_str.hmark(0@0);
            result_order := result_order.leftfetchjoin(input_order);
            result_str := result_str.tmark(0@0);
            iter := result_order;
            ipik := iter;
            item_str_ := result_str;
           }
           { # adding new strings to text node content and create new nodes
            var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
            var unq_str := item_str_.tunique().hmark(0@0);
            var str_unq := reverse(unq_str.tdiff(ws_prop_text));
            var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
            unq_str := str_unq.hmark(seqb);
            ws_prop_text := ws_prop_text.insert(unq_str);
            var ws_text_prop := ws_prop_text.reverse().sort();
            item_str_ := item_str_.materialize(ipik);
            var X_item := item_str_.hmark(0@0);
            var X_strings := item_str_.tmark(0@0).tsort();
            var X_prop := X_strings.leftjoin(ws_text_prop);
            var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
            newPre_prop := newPre_prop.tmark(0@0);
            _elem_iter  := iter;
            _elem_size  := newPre_prop.project(0);
            _elem_level := newPre_prop.project(chr(0));
            _elem_kind  := newPre_prop.project(TEXT);
            _elem_prop  := newPre_prop;
            _elem_frag  := newPre_prop.project(WS);
           } # end of adding new fragments to the WS_FRAG bat
           var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter009), _elem_iter.leftfetchjoin(_elem_iter009), othernodes.leftfetchjoin(_elem_size009), _elem_size, othernodes.leftfetchjoin(_elem_level009), _elem_level, othernodes.leftfetchjoin(_elem_kind009), _elem_kind, othernodes.leftfetchjoin(_elem_prop009), _elem_prop, othernodes.leftfetchjoin(_elem_frag009), _elem_frag, othernodes.leftfetchjoin(_elem_iter009.mirror()), oid(nil));
           _elem_iter := res_mu_is2ns.fetch(1).chk_order();
           _elem_size := res_mu_is2ns.fetch(2);
           _elem_level:= res_mu_is2ns.fetch(3);
           _elem_kind := res_mu_is2ns.fetch(4);
           _elem_prop := res_mu_is2ns.fetch(5);
           _elem_frag := res_mu_is2ns.fetch(6);
           var preNew_preOld := res_mu_is2ns.fetch(7);
           _attr_own := _attr_own009.leftjoin(preNew_preOld.reverse());
           _attr_iter   := _attr_iter009  ;
           _attr_qn     := _attr_qn009    ;
           _attr_prop   := _attr_prop009  ;
           _attr_frag   := _attr_frag009  ;
           _r_attr_iter := _r_attr_iter009;
           _r_attr_qn   := _r_attr_qn009  ;
           _r_attr_prop := _r_attr_prop009;
           _r_attr_frag := _r_attr_frag009;
          } # end of deleteResult_node9 ()
         } # end of item-sequence-to-node-sequence
         { # loop_liftedElemConstr (counter)
          var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
          iter_size := {count}(iter_size, iter008.tunique(), FALSE);
          var root_iter  := iter_size.hmark(0@0).chk_order();
          var root_size  := iter_size.tmark(0@0);
          var root_prop  := iter008.reverse().leftfetchjoin(item008);
          if (not(is_constant(root_prop))) {
           root_prop  := root_prop.tmark(0@0);
          }
          {
           var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
           _elem_iter  := merged_result.fetch(0);
           _elem_size  := merged_result.fetch(1);
           _elem_level := merged_result.fetch(2);
           _elem_kind  := merged_result.fetch(3);
           _elem_prop  := merged_result.fetch(4);
           _elem_frag  := merged_result.fetch(5);
           var preNew_preOld := merged_result.fetch(6);
           _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
           _attr_own := _attr_own.tmark(0@0);
          }
          { # create attribute root entries
           var root_item := _elem_level.ord_uselect(chr(0));
           root_item := root_item.hmark(0@0);
           var iter_item := iter008.reverse().leftfetchjoin(root_item);
           var attr_own := _r_attr_iter.leftjoin(iter_item);
           if (_r_attr_iter.count() != 0) { # test uniqueness
            var sorting := _r_attr_iter.tsort();
            sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
            var unq_attrs := sorting.tunique();
            if (unq_attrs.count() != _r_attr_iter.count()) {
             item008 := materialize(item008,ipik008);
             if (item008.count() > 0) {
              ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item008.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
             } else {
              ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
             }
            }
           } # end of test uniqueness
           if (_attr_iter.count() = 0) {
            _attr_iter := _r_attr_iter;
            _attr_qn   := _r_attr_qn;
            _attr_prop := _r_attr_prop;
            _attr_frag := _r_attr_frag;
            _attr_own  := attr_own.tmark(0@0);
           } else {
            var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
            _r_attr_iter := _r_attr_iter.tmark(seqb);
            _r_attr_qn   := _r_attr_qn  .tmark(seqb);
            _r_attr_prop := _r_attr_prop.tmark(seqb);
            _r_attr_frag := _r_attr_frag.tmark(seqb);
            attr_own := attr_own.tmark(seqb);
            _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
            _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
            _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
            _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
            _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
           }
           _r_attr_iter := empty_bat;
           _r_attr_qn   := empty_bat;
           _r_attr_prop := empty_bat;
           _r_attr_frag := empty_bat;
          } # end of create attribute root entries
         } # end of loop_liftedElemConstr (counter)
        } # end of deleteResult8 ()
        { # saveResult_node8 () : int
         var _elem_iter008   := _elem_iter  ;
         var _elem_size008   := _elem_size  ;
         var _elem_level008  := _elem_level ;
         var _elem_kind008   := _elem_kind  ;
         var _elem_prop008   := _elem_prop  ;
         var _elem_frag008   := _elem_frag  ;
         var _attr_iter008   := _attr_iter  ;
         var _attr_qn008     := _attr_qn    ;
         var _attr_prop008   := _attr_prop  ;
         var _attr_frag008   := _attr_frag  ;
         var _attr_own008    := _attr_own   ;
         var _r_attr_iter008 := _r_attr_iter;
         var _r_attr_qn008   := _r_attr_qn  ;
         var _r_attr_prop008 := _r_attr_prop;
         var _r_attr_frag008 := _r_attr_frag; # end of saveResult_node8 () : int
         { # tagname-translation
          var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
          var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
          var itemID;
          if (prop_str.texist("age")) {
           itemID := prop_str.reverse().find("age");
          } else {
           itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
           ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
           ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
           ws.fetch(QN_LOC).fetch(WS).insert(itemID,"age");
           ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
           ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"age"+str('\1')+"");
          } # translateConst (kind)
          iter := loop002.tmark(0@0);
          ipik := iter;
          item := itemID;
         } # end of tagname-translation
         { # saveResult9 () : int
          var ipik009 := ipik;
          var iter009 := iter;
          var item009 := item; # end of saveResult9 () : int
          { # translateVar (t)
           var vid := v_vid002.ord_uselect(1303761071@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter002);
           item := vid.leftfetchjoin(v_item002);
           kind := vid.leftfetchjoin(v_kind002);
           ipik := iter;
          } # end of translateVar (t)
          { # translateLocsteps (c)
           var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "profile");
           iter := res_scj.fetch(0);
           item := res_scj.fetch(1);
           kind := res_scj.fetch(2).set_kind(ELEM);
           ipik := item;
          } # end of translateLocsteps (c)
          { # translateLocsteps (c)
           var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "age");
           iter := res_scj.fetch(0);
           item := res_scj.fetch(1);
           kind := res_scj.fetch(2).set_kind(ELEM);
           ipik := item;
          } # end of translateLocsteps (c)
          { # translateLocsteps (c)
           var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
           iter := res_scj.fetch(0);
           item := res_scj.fetch(1);
           kind := res_scj.fetch(2).set_kind(ELEM);
           ipik := item;
          } # end of translateLocsteps (c)
          { # map2NODE_interface (counter)
           kind := kind.materialize(ipik);
           var attr := kind.get_type(ATTR).hmark(0@0);
           var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
           var attr_item := attr.leftfetchjoin(item);
           var attr_frag := attr.leftfetchjoin(kind).get_fragment();
           _r_attr_iter := attr_iter;
           _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
           _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
           _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
           var nodes := kind.get_type(ELEM);
           if (nodes.count() != 0) {
            var oid_oid := nodes.hmark(0@0);
            var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
            var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
            var iter_input := oid_oid.mirror();
            var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
            var res_iter := res_scj.fetch(0);
            var res_item := res_scj.fetch(1);
            var res_frag := res_scj.fetch(2);
            _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
            _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
            _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
            _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
            _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
            var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
            var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
            nodes := res_item.mark(0@0);
            var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
            root_level := nodes.leftfetchjoin(root_level);
            temp_ec_item := res_item;
            temp_ec_frag := res_frag;
            var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
            content_level := nodes.leftfetchjoin(content_level);
            content_level := content_level.[-](root_level);
            content_level := content_level.tmark(0@0);
            _elem_level := content_level;
            { # create attribute subtree copies
             var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
             var oid_attr := temp_attr.tmark(0@0);
             var oid_frag;
             if (is_constant(res_frag)) {
              oid_frag := res_frag;
             } else {
              oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
              oid_frag := oid_frag.tmark(0@0);
             }
             _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
             _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
             _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
             _attr_own  := temp_attr.hmark(0@0);
             _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
            } # end of create attribute subtree copies
           } else { # if (nodes.count() != 0) ...
            _elem_iter  := empty_bat;
            _elem_size  := empty_bat.project(int(nil));
            _elem_level := empty_bat.project(chr(nil));
            _elem_kind  := empty_bat.project(chr(nil));
            _elem_prop  := empty_bat;
            _elem_frag  := empty_bat;
            _attr_iter  := empty_bat;
            _attr_qn    := empty_bat;
            _attr_prop  := empty_bat;
            _attr_frag  := empty_bat;
            _attr_own   := empty_bat;
           } # end of else in 'if (nodes.count() != 0)'
          } # end of map2NODE_interface (counter)
          if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
           { # saveResult_node10 () : int
            var _elem_iter010   := _elem_iter  ;
            var _elem_size010   := _elem_size  ;
            var _elem_level010  := _elem_level ;
            var _elem_kind010   := _elem_kind  ;
            var _elem_prop010   := _elem_prop  ;
            var _elem_frag010   := _elem_frag  ;
            var _attr_iter010   := _attr_iter  ;
            var _attr_qn010     := _attr_qn    ;
            var _attr_prop010   := _attr_prop  ;
            var _attr_frag010   := _attr_frag  ;
            var _attr_own010    := _attr_own   ;
            var _r_attr_iter010 := _r_attr_iter;
            var _r_attr_qn010   := _r_attr_qn  ;
            var _r_attr_prop010 := _r_attr_prop;
            var _r_attr_frag010 := _r_attr_frag; # end of saveResult_node10 () : int
            _elem_iter := _elem_iter010;
            _elem_level := _elem_level010;
            _elem_kind := _elem_kind010;
            _elem_prop := _elem_prop010;
            _elem_frag := _elem_frag010;
            var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
            rootnodes := rootnodes.leftfetchjoin(_elem_kind);
            var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
            var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
            var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
            {
             var text_prop := textnodes.leftfetchjoin(_elem_prop);
             var text_frag := textnodes.leftfetchjoin(_elem_frag);
             var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
             var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
             var input_order := res_mu_is2ns.fetch(0);
             var input_str := res_mu_is2ns.fetch(1);
             var input_const := res_mu_is2ns.fetch(2);
             var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
             var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
             var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
             var result_order := result_str.hmark(0@0);
             result_order := result_order.leftfetchjoin(input_order);
             result_str := result_str.tmark(0@0);
             iter := result_order;
             ipik := iter;
             item_str_ := result_str;
            }
            { # adding new strings to text node content and create new nodes
             var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
             var unq_str := item_str_.tunique().hmark(0@0);
             var str_unq := reverse(unq_str.tdiff(ws_prop_text));
             var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
             unq_str := str_unq.hmark(seqb);
             ws_prop_text := ws_prop_text.insert(unq_str);
             var ws_text_prop := ws_prop_text.reverse().sort();
             item_str_ := item_str_.materialize(ipik);
             var X_item := item_str_.hmark(0@0);
             var X_strings := item_str_.tmark(0@0).tsort();
             var X_prop := X_strings.leftjoin(ws_text_prop);
             var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
             newPre_prop := newPre_prop.tmark(0@0);
             _elem_iter  := iter;
             _elem_size  := newPre_prop.project(0);
             _elem_level := newPre_prop.project(chr(0));
             _elem_kind  := newPre_prop.project(TEXT);
             _elem_prop  := newPre_prop;
             _elem_frag  := newPre_prop.project(WS);
            } # end of adding new fragments to the WS_FRAG bat
            var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter010), _elem_iter.leftfetchjoin(_elem_iter010), othernodes.leftfetchjoin(_elem_size010), _elem_size, othernodes.leftfetchjoin(_elem_level010), _elem_level, othernodes.leftfetchjoin(_elem_kind010), _elem_kind, othernodes.leftfetchjoin(_elem_prop010), _elem_prop, othernodes.leftfetchjoin(_elem_frag010), _elem_frag, othernodes.leftfetchjoin(_elem_iter010.mirror()), oid(nil));
            _elem_iter := res_mu_is2ns.fetch(1).chk_order();
            _elem_size := res_mu_is2ns.fetch(2);
            _elem_level:= res_mu_is2ns.fetch(3);
            _elem_kind := res_mu_is2ns.fetch(4);
            _elem_prop := res_mu_is2ns.fetch(5);
            _elem_frag := res_mu_is2ns.fetch(6);
            var preNew_preOld := res_mu_is2ns.fetch(7);
            _attr_own := _attr_own010.leftjoin(preNew_preOld.reverse());
            _attr_iter   := _attr_iter010  ;
            _attr_qn     := _attr_qn010    ;
            _attr_prop   := _attr_prop010  ;
            _attr_frag   := _attr_frag010  ;
            _r_attr_iter := _r_attr_iter010;
            _r_attr_qn   := _r_attr_qn010  ;
            _r_attr_prop := _r_attr_prop010;
            _r_attr_frag := _r_attr_frag010;
           } # end of deleteResult_node10 ()
          } # end of item-sequence-to-node-sequence
          { # loop_liftedElemConstr (counter)
           var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
           iter_size := {count}(iter_size, iter009.tunique(), FALSE);
           var root_iter  := iter_size.hmark(0@0).chk_order();
           var root_size  := iter_size.tmark(0@0);
           var root_prop  := iter009.reverse().leftfetchjoin(item009);
           if (not(is_constant(root_prop))) {
            root_prop  := root_prop.tmark(0@0);
           }
           {
            var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
            _elem_iter  := merged_result.fetch(0);
            _elem_size  := merged_result.fetch(1);
            _elem_level := merged_result.fetch(2);
            _elem_kind  := merged_result.fetch(3);
            _elem_prop  := merged_result.fetch(4);
            _elem_frag  := merged_result.fetch(5);
            var preNew_preOld := merged_result.fetch(6);
            _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
            _attr_own := _attr_own.tmark(0@0);
           }
           { # create attribute root entries
            var root_item := _elem_level.ord_uselect(chr(0));
            root_item := root_item.hmark(0@0);
            var iter_item := iter009.reverse().leftfetchjoin(root_item);
            var attr_own := _r_attr_iter.leftjoin(iter_item);
            if (_r_attr_iter.count() != 0) { # test uniqueness
             var sorting := _r_attr_iter.tsort();
             sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
             var unq_attrs := sorting.tunique();
             if (unq_attrs.count() != _r_attr_iter.count()) {
              item009 := materialize(item009,ipik009);
              if (item009.count() > 0) {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item009.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
              } else {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
              }
             }
            } # end of test uniqueness
            if (_attr_iter.count() = 0) {
             _attr_iter := _r_attr_iter;
             _attr_qn   := _r_attr_qn;
             _attr_prop := _r_attr_prop;
             _attr_frag := _r_attr_frag;
             _attr_own  := attr_own.tmark(0@0);
            } else {
             var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
             _r_attr_iter := _r_attr_iter.tmark(seqb);
             _r_attr_qn   := _r_attr_qn  .tmark(seqb);
             _r_attr_prop := _r_attr_prop.tmark(seqb);
             _r_attr_frag := _r_attr_frag.tmark(seqb);
             attr_own := attr_own.tmark(seqb);
             _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
             _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
             _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
             _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
             _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
            }
            _r_attr_iter := empty_bat;
            _r_attr_qn   := empty_bat;
            _r_attr_prop := empty_bat;
            _r_attr_frag := empty_bat;
           } # end of create attribute root entries
          } # end of loop_liftedElemConstr (counter)
         } # end of deleteResult9 ()
         { # saveResult_node9 () : int
          var _elem_iter009   := _elem_iter  ;
          var _elem_size009   := _elem_size  ;
          var _elem_level009  := _elem_level ;
          var _elem_kind009   := _elem_kind  ;
          var _elem_prop009   := _elem_prop  ;
          var _elem_frag009   := _elem_frag  ;
          var _attr_iter009   := _attr_iter  ;
          var _attr_qn009     := _attr_qn    ;
          var _attr_prop009   := _attr_prop  ;
          var _attr_frag009   := _attr_frag  ;
          var _attr_own009    := _attr_own   ;
          var _r_attr_iter009 := _r_attr_iter;
          var _r_attr_qn009   := _r_attr_qn  ;
          var _r_attr_prop009 := _r_attr_prop;
          var _r_attr_frag009 := _r_attr_frag; # end of saveResult_node9 () : int
          { # tagname-translation
           var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
           var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
           var itemID;
           if (prop_str.texist("education")) {
            itemID := prop_str.reverse().find("education");
           } else {
            itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
            ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
            ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
            ws.fetch(QN_LOC).fetch(WS).insert(itemID,"education");
            ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
            ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"education"+str('\1')+"");
           } # translateConst (kind)
           iter := loop002.tmark(0@0);
           ipik := iter;
           item := itemID;
          } # end of tagname-translation
          { # saveResult10 () : int
           var ipik010 := ipik;
           var iter010 := iter;
           var item010 := item; # end of saveResult10 () : int
           { # translateVar (t)
            var vid := v_vid002.ord_uselect(1303761071@0);
            vid := vid.hmark(0@0);
            iter := vid.leftfetchjoin(v_iter002);
            item := vid.leftfetchjoin(v_item002);
            kind := vid.leftfetchjoin(v_kind002);
            ipik := iter;
           } # end of translateVar (t)
           { # translateLocsteps (c)
            var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "profile");
            iter := res_scj.fetch(0);
            item := res_scj.fetch(1);
            kind := res_scj.fetch(2).set_kind(ELEM);
            ipik := item;
           } # end of translateLocsteps (c)
           { # translateLocsteps (c)
            var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "education");
            iter := res_scj.fetch(0);
            item := res_scj.fetch(1);
            kind := res_scj.fetch(2).set_kind(ELEM);
            ipik := item;
           } # end of translateLocsteps (c)
           { # translateLocsteps (c)
            var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
            iter := res_scj.fetch(0);
            item := res_scj.fetch(1);
            kind := res_scj.fetch(2).set_kind(ELEM);
            ipik := item;
           } # end of translateLocsteps (c)
           { # map2NODE_interface (counter)
            kind := kind.materialize(ipik);
            var attr := kind.get_type(ATTR).hmark(0@0);
            var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
            var attr_item := attr.leftfetchjoin(item);
            var attr_frag := attr.leftfetchjoin(kind).get_fragment();
            _r_attr_iter := attr_iter;
            _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
            _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
            _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
            var nodes := kind.get_type(ELEM);
            if (nodes.count() != 0) {
             var oid_oid := nodes.hmark(0@0);
             var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
             var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
             var iter_input := oid_oid.mirror();
             var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
             var res_iter := res_scj.fetch(0);
             var res_item := res_scj.fetch(1);
             var res_frag := res_scj.fetch(2);
             _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
             _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
             _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
             _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
             _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
             var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
             var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
             nodes := res_item.mark(0@0);
             var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
             root_level := nodes.leftfetchjoin(root_level);
             temp_ec_item := res_item;
             temp_ec_frag := res_frag;
             var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
             content_level := nodes.leftfetchjoin(content_level);
             content_level := content_level.[-](root_level);
             content_level := content_level.tmark(0@0);
             _elem_level := content_level;
             { # create attribute subtree copies
              var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
              var oid_attr := temp_attr.tmark(0@0);
              var oid_frag;
              if (is_constant(res_frag)) {
               oid_frag := res_frag;
              } else {
               oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
               oid_frag := oid_frag.tmark(0@0);
              }
              _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
              _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
              _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
              _attr_own  := temp_attr.hmark(0@0);
              _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
             } # end of create attribute subtree copies
            } else { # if (nodes.count() != 0) ...
             _elem_iter  := empty_bat;
             _elem_size  := empty_bat.project(int(nil));
             _elem_level := empty_bat.project(chr(nil));
             _elem_kind  := empty_bat.project(chr(nil));
             _elem_prop  := empty_bat;
             _elem_frag  := empty_bat;
             _attr_iter  := empty_bat;
             _attr_qn    := empty_bat;
             _attr_prop  := empty_bat;
             _attr_frag  := empty_bat;
             _attr_own   := empty_bat;
            } # end of else in 'if (nodes.count() != 0)'
           } # end of map2NODE_interface (counter)
           if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
            { # saveResult_node11 () : int
             var _elem_iter011   := _elem_iter  ;
             var _elem_size011   := _elem_size  ;
             var _elem_level011  := _elem_level ;
             var _elem_kind011   := _elem_kind  ;
             var _elem_prop011   := _elem_prop  ;
             var _elem_frag011   := _elem_frag  ;
             var _attr_iter011   := _attr_iter  ;
             var _attr_qn011     := _attr_qn    ;
             var _attr_prop011   := _attr_prop  ;
             var _attr_frag011   := _attr_frag  ;
             var _attr_own011    := _attr_own   ;
             var _r_attr_iter011 := _r_attr_iter;
             var _r_attr_qn011   := _r_attr_qn  ;
             var _r_attr_prop011 := _r_attr_prop;
             var _r_attr_frag011 := _r_attr_frag; # end of saveResult_node11 () : int
             _elem_iter := _elem_iter011;
             _elem_level := _elem_level011;
             _elem_kind := _elem_kind011;
             _elem_prop := _elem_prop011;
             _elem_frag := _elem_frag011;
             var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
             rootnodes := rootnodes.leftfetchjoin(_elem_kind);
             var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
             var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
             var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
             {
              var text_prop := textnodes.leftfetchjoin(_elem_prop);
              var text_frag := textnodes.leftfetchjoin(_elem_frag);
              var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
              var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
              var input_order := res_mu_is2ns.fetch(0);
              var input_str := res_mu_is2ns.fetch(1);
              var input_const := res_mu_is2ns.fetch(2);
              var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
              var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
              var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
              var result_order := result_str.hmark(0@0);
              result_order := result_order.leftfetchjoin(input_order);
              result_str := result_str.tmark(0@0);
              iter := result_order;
              ipik := iter;
              item_str_ := result_str;
             }
             { # adding new strings to text node content and create new nodes
              var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
              var unq_str := item_str_.tunique().hmark(0@0);
              var str_unq := reverse(unq_str.tdiff(ws_prop_text));
              var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
              unq_str := str_unq.hmark(seqb);
              ws_prop_text := ws_prop_text.insert(unq_str);
              var ws_text_prop := ws_prop_text.reverse().sort();
              item_str_ := item_str_.materialize(ipik);
              var X_item := item_str_.hmark(0@0);
              var X_strings := item_str_.tmark(0@0).tsort();
              var X_prop := X_strings.leftjoin(ws_text_prop);
              var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
              newPre_prop := newPre_prop.tmark(0@0);
              _elem_iter  := iter;
              _elem_size  := newPre_prop.project(0);
              _elem_level := newPre_prop.project(chr(0));
              _elem_kind  := newPre_prop.project(TEXT);
              _elem_prop  := newPre_prop;
              _elem_frag  := newPre_prop.project(WS);
             } # end of adding new fragments to the WS_FRAG bat
             var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter011), _elem_iter.leftfetchjoin(_elem_iter011), othernodes.leftfetchjoin(_elem_size011), _elem_size, othernodes.leftfetchjoin(_elem_level011), _elem_level, othernodes.leftfetchjoin(_elem_kind011), _elem_kind, othernodes.leftfetchjoin(_elem_prop011), _elem_prop, othernodes.leftfetchjoin(_elem_frag011), _elem_frag, othernodes.leftfetchjoin(_elem_iter011.mirror()), oid(nil));
             _elem_iter := res_mu_is2ns.fetch(1).chk_order();
             _elem_size := res_mu_is2ns.fetch(2);
             _elem_level:= res_mu_is2ns.fetch(3);
             _elem_kind := res_mu_is2ns.fetch(4);
             _elem_prop := res_mu_is2ns.fetch(5);
             _elem_frag := res_mu_is2ns.fetch(6);
             var preNew_preOld := res_mu_is2ns.fetch(7);
             _attr_own := _attr_own011.leftjoin(preNew_preOld.reverse());
             _attr_iter   := _attr_iter011  ;
             _attr_qn     := _attr_qn011    ;
             _attr_prop   := _attr_prop011  ;
             _attr_frag   := _attr_frag011  ;
             _r_attr_iter := _r_attr_iter011;
             _r_attr_qn   := _r_attr_qn011  ;
             _r_attr_prop := _r_attr_prop011;
             _r_attr_frag := _r_attr_frag011;
            } # end of deleteResult_node11 ()
           } # end of item-sequence-to-node-sequence
           { # loop_liftedElemConstr (counter)
            var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
            iter_size := {count}(iter_size, iter010.tunique(), FALSE);
            var root_iter  := iter_size.hmark(0@0).chk_order();
            var root_size  := iter_size.tmark(0@0);
            var root_prop  := iter010.reverse().leftfetchjoin(item010);
            if (not(is_constant(root_prop))) {
             root_prop  := root_prop.tmark(0@0);
            }
            {
             var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
             _elem_iter  := merged_result.fetch(0);
             _elem_size  := merged_result.fetch(1);
             _elem_level := merged_result.fetch(2);
             _elem_kind  := merged_result.fetch(3);
             _elem_prop  := merged_result.fetch(4);
             _elem_frag  := merged_result.fetch(5);
             var preNew_preOld := merged_result.fetch(6);
             _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
             _attr_own := _attr_own.tmark(0@0);
            }
            { # create attribute root entries
             var root_item := _elem_level.ord_uselect(chr(0));
             root_item := root_item.hmark(0@0);
             var iter_item := iter010.reverse().leftfetchjoin(root_item);
             var attr_own := _r_attr_iter.leftjoin(iter_item);
             if (_r_attr_iter.count() != 0) { # test uniqueness
              var sorting := _r_attr_iter.tsort();
              sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
              var unq_attrs := sorting.tunique();
              if (unq_attrs.count() != _r_attr_iter.count()) {
               item010 := materialize(item010,ipik010);
               if (item010.count() > 0) {
                ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item010.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
               } else {
                ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
               }
              }
             } # end of test uniqueness
             if (_attr_iter.count() = 0) {
              _attr_iter := _r_attr_iter;
              _attr_qn   := _r_attr_qn;
              _attr_prop := _r_attr_prop;
              _attr_frag := _r_attr_frag;
              _attr_own  := attr_own.tmark(0@0);
             } else {
              var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
              _r_attr_iter := _r_attr_iter.tmark(seqb);
              _r_attr_qn   := _r_attr_qn  .tmark(seqb);
              _r_attr_prop := _r_attr_prop.tmark(seqb);
              _r_attr_frag := _r_attr_frag.tmark(seqb);
              attr_own := attr_own.tmark(seqb);
              _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
              _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
              _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
              _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
              _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
             }
             _r_attr_iter := empty_bat;
             _r_attr_qn   := empty_bat;
             _r_attr_prop := empty_bat;
             _r_attr_frag := empty_bat;
            } # end of create attribute root entries
           } # end of loop_liftedElemConstr (counter)
          } # end of deleteResult10 ()
          { # saveResult_node10 () : int
           var _elem_iter010   := _elem_iter  ;
           var _elem_size010   := _elem_size  ;
           var _elem_level010  := _elem_level ;
           var _elem_kind010   := _elem_kind  ;
           var _elem_prop010   := _elem_prop  ;
           var _elem_frag010   := _elem_frag  ;
           var _attr_iter010   := _attr_iter  ;
           var _attr_qn010     := _attr_qn    ;
           var _attr_prop010   := _attr_prop  ;
           var _attr_frag010   := _attr_frag  ;
           var _attr_own010    := _attr_own   ;
           var _r_attr_iter010 := _r_attr_iter;
           var _r_attr_qn010   := _r_attr_qn  ;
           var _r_attr_prop010 := _r_attr_prop;
           var _r_attr_frag010 := _r_attr_frag; # end of saveResult_node10 () : int
           { # tagname-translation
            var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
            var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
            var itemID;
            if (prop_str.texist("revenu")) {
             itemID := prop_str.reverse().find("revenu");
            } else {
             itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
             ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
             ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
             ws.fetch(QN_LOC).fetch(WS).insert(itemID,"revenu");
             ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
             ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"revenu"+str('\1')+"");
            } # translateConst (kind)
            iter := loop002.tmark(0@0);
            ipik := iter;
            item := itemID;
           } # end of tagname-translation
           { # saveResult11 () : int
            var ipik011 := ipik;
            var iter011 := iter;
            var item011 := item; # end of saveResult11 () : int
            { # translateVar (t)
             var vid := v_vid002.ord_uselect(1303761071@0);
             vid := vid.hmark(0@0);
             iter := vid.leftfetchjoin(v_iter002);
             item := vid.leftfetchjoin(v_item002);
             kind := vid.leftfetchjoin(v_kind002);
             ipik := iter;
            } # end of translateVar (t)
            { # translateLocsteps (c)
             var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
             item := item.materialize(ipik);
             iter := iter.materialize(ipik);
             res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "profile");
             iter := res_scj.fetch(0);
             item := res_scj.fetch(1);
             kind := res_scj.fetch(2).set_kind(ELEM);
             ipik := item;
            } # end of translateLocsteps (c)
            { # loop_liftedSCJ (axis, kind, ns, loc)
             { # attribute axis
              var oid_iter := iter;
              var oid_item := item.materialize(ipik);
              var oid_frag := kind.get_fragment();
              var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
              oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
              var oid_attr := temp1.tmark(0@0);
              oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
              var temp1_str; # only needed for name test
              temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
              temp1 := temp1_str.ord_uselect("");
              temp1 := temp1.hmark(0@0);
              oid_attr := temp1.leftfetchjoin(oid_attr);
              oid_frag := temp1.leftfetchjoin(oid_frag);
              oid_iter := temp1.leftfetchjoin(oid_iter);
              temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
              temp1 := temp1_str.ord_uselect("income");
              temp1 := temp1.hmark(0@0);
              oid_attr := temp1.leftfetchjoin(oid_attr);
              oid_frag := temp1.leftfetchjoin(oid_frag);
              oid_iter := temp1.leftfetchjoin(oid_iter);
              iter := oid_iter.tmark(0@0);
              item := oid_attr.tmark(0@0);
              kind := oid_frag.tmark(0@0);
              if (type(iter) = bat) {
               ipik := iter;
              } else {
               if (type(item) = bat) {
                ipik := item;
               } else {
                ipik := kind;
               }
              }
             } # end of attribute axis
             kind := kind.set_kind(ATTR);
            } # end of translateLocsteps (c)
            if (ipik.count() != 0) 
            { # for-translation
             # project ()
             iter := iter.materialize(ipik);
             var outer003 := iter;
             iter := iter.mark(1@0);
             var inner003 := iter;
             var loop003 := inner003;
             var v_vid003;
             var v_iter003;
             var v_item003;
             var v_kind003;
             var expOid;
             { # getExpanded (fid)
              var vu_nil := vu_fid.ord_uselect(1303761051@0);
              var vid_vu := vu_vid.reverse();
              var oid_nil := vid_vu.leftjoin(vu_nil);
              expOid := v_vid002.leftjoin(oid_nil);
              expOid := expOid.mirror();
             } # end of getExpanded (fid)
             if (expOid.count() != 0) {
              var oidNew_expOid;
              { # expand ()
               var expOid_iter := expOid.leftfetchjoin(v_iter002);
               var iter_expOid := expOid_iter.reverse();
               var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
               var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
               oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
               var expOid_oidMap := oidMap_expOid.reverse();
               expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
               v_iter003 := expOid_iter;
               oidNew_expOid := expOid_iter.hmark(0@0);
              } # end of expand ()
              # join ()
              var cnt := count(v_iter003)*2;
              v_iter003 := v_iter003.tmark(0@0);
              var new_v_iter := v_iter003;
              v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
              var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
              v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
              var new_v_pos ;
              var new_v_item := oidNew_expOid.leftjoin(v_item002);
              v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
              var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
              v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
             } else { # createNewVarTable ()
              v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
              v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
              v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
              v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
             }
             { # insertVar (vid)
              var vid := project(ipik,1303761073@0);
              { # append (vid, level)
               var seqb := oid(v_vid003.count());
               vid := vid.materialize(ipik);
               v_vid003 := v_vid003.insert(vid.tmark(seqb));
              } # append (vid, level)
              { # append (iter, level)
               var seqb := oid(v_iter003.count());
               iter := iter.materialize(ipik);
               v_iter003 := v_iter003.insert(iter.tmark(seqb));
              } # append (iter, level)
              { # append (pos, level)
               var seqb ;
              } # append (pos, level)
              { # append (item, level)
               var seqb := oid(v_item003.count());
               item := item.materialize(ipik);
               v_item003 := v_item003.insert(item.tmark(seqb));
              } # append (item, level)
              { # append (kind, level)
               var seqb := oid(v_kind003.count());
               kind := kind.materialize(ipik);
               v_kind003 := v_kind003.insert(kind.tmark(seqb));
              } # append (kind, level)
             } # end of insertVar (vid)
             { # translateVar (#pf:v_2814)
              var vid := v_vid003.ord_uselect(1303761073@0);
              vid := vid.hmark(0@0);
              iter := vid.leftfetchjoin(v_iter003);
              item := vid.leftfetchjoin(v_item003);
              kind := vid.leftfetchjoin(v_kind003);
              ipik := iter;
             } # end of translateVar (#pf:v_2814)
             { # string-value
              var input_iter := iter;
              kind := kind.materialize(ipik);
              item := item.materialize(ipik);
              iter := iter.materialize(ipik);
              var kind_elem := kind.get_type(ELEM);
              var item_str;
              if (kind_elem.count() = kind.count()) {
               var frag := kind.get_fragment();
               var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
               var t_iter := res_scj.fetch(0);
               var t_item := res_scj.fetch(1);
               var t_frag := res_scj.fetch(2);
               var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
               var t_iter_unq := t_iter.tunique();
               t_iter := t_iter.materialize(t_item);
               if (t_iter_unq.count() != t_item.count()) {
                var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
                iter_item := iter_item.string_join(t_iter_unq.project(""));
                t_iter := iter_item.hmark(0@0);
                t_item_str := iter_item.tmark(0@0);
               }
               var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
               if (c_map.count() > 0) { #process comments 
                var c_iter := c_map.leftfetchjoin(iter);
                var c_item := c_map.leftfetchjoin(item);
                var c_frag := c_map.leftfetchjoin(frag);
                var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
                var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
                t_iter := res_mu.fetch(0);
                t_item_str := res_mu.fetch(1);
               } # end of comment processing
               var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
               if (pi_map.count() > 0) { #process processing-instructions 
                var pi_iter := pi_map.leftfetchjoin(iter);
                var pi_item := pi_map.leftfetchjoin(item);
                var pi_frag := pi_map.leftfetchjoin(frag);
                var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
                var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
                t_item_str := res_mu.fetch(1);
               } # end of processing-instruction processing
               iter := t_iter;
               item_str := t_item_str;
              } else {
               var kind_attr := kind.get_type(ATTR);
               if (kind_attr.count() = kind.count()) {
                var frag := kind.get_fragment();
                item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
               } else {
                kind_attr := kind_attr.hmark(0@0);
                var item_attr := kind_attr.leftfetchjoin(item);
                var iter_attr := kind_attr.leftfetchjoin(iter);
                var frag := kind_attr.leftfetchjoin(kind).get_fragment();
                var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
                kind_elem := kind_elem.hmark(0@0);
                iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
                frag := kind_elem.leftfetchjoin(kind).get_fragment();
                item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
                var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
                var t_iter := res_scj.fetch(0);
                var t_item := res_scj.fetch(1);
                var t_frag := res_scj.fetch(2);
                var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
                var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
                t_iter := iter_item.hmark(0@0);
                t_item_str := iter_item.tmark(0@0);
                var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
                t_iter := res_mu.fetch(0);
                t_item_str := res_mu.fetch(1);
                iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
                {
                 var item_unq := iter_item.reverse().tunique();
                 if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
                }
                t_iter := iter_item.hmark(0@0);
                var t_item_str := iter_item.tmark(0@0);
                var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
                if (c_map.count() > 0) { #process comments 
                 var c_iter := c_map.leftfetchjoin(iter);
                 var c_item := c_map.leftfetchjoin(item);
                 var c_frag := c_map.leftfetchjoin(frag);
                 var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
                 var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
                 t_iter := res_mu.fetch(0);
                 t_item_str := res_mu.fetch(1);
                } # end of comment processing
                var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
                if (pi_map.count() > 0) { #process processing-instructions 
                 var pi_iter := pi_map.leftfetchjoin(iter);
                 var pi_item := pi_map.leftfetchjoin(item);
                 var pi_frag := pi_map.leftfetchjoin(frag);
                 var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
                 var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
                 t_iter := res_mu.fetch(0);
                 t_item_str := res_mu.fetch(1);
                } # end of processing-instruction processing
                iter := t_iter;
                item_str := t_item_str;
               }
              }
              item_str_ := item_str;
              if (iter.count() != input_iter.tunique().count()) {
               var difference := reverse(input_iter.tdiff(iter));
               difference := difference.hmark(0@0);
               var res_mu := merged_union(iter, difference, item_str_, "");
               iter := res_mu.fetch(0);
               item_str_ := res_mu.fetch(1);
              }
              ipik := iter;
              kind := STR;
             } # end of string-value
             { # cast from string to untypedAtomic
              item := str_values.addValues(item_str_).tmark(0@0);
              if (iter.count() != loop003.count()) {
               ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
              }
             } # end of cast from string to untypedAtomic
             { # mapBack ()
              var iter_oidMap := inner003.reverse();
              var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
              iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
              # kind := kind;
              # ipik := ipik;
             } # end of mapBack ()
             # cleanUpLevel ()
            } # end of for-translation
            { # saveResult12 () : int
             var ipik012 := ipik;
             var iter012 := iter;
             var item012 := item;
             var kind012 := kind; # end of saveResult12 () : int
             { # item-sequence-to-node-sequence
              var nodes_order;
              {
               ipik := ipik012;
               item := item012;
               kind := kind012;
               kind := kind.materialize(ipik);
               var elem := kind.get_type(ELEM);
               elem := elem.hmark(0@0);
               var kind_elem := elem.leftfetchjoin(kind);
               var frag_elem := kind_elem.get_fragment();
               var item_elem := elem.leftfetchjoin(item).materialize(elem);
               var kind_node := mposjoin (item_elem, frag_elem, ws.fetch(PRE_KIND));
               var text := kind_node.ord_uselect(TEXT).hmark(0@0);
               var item_text := text.leftfetchjoin(item_elem);
               var frag_text := text.leftfetchjoin(frag_elem);
               var text_str := mposjoin (mposjoin (item_text, frag_text, ws.fetch(PRE_PROP)), mposjoin (item_text, frag_text, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
               var str_text := text_str.reverse().leftfetchjoin(text);
               var texts := str_text.leftfetchjoin(elem).reverse();
               var texts_order := texts.hmark(0@0);
               texts := texts.tmark(0@0);
               var nodes := kind_node.[!=](TEXT).ord_uselect(true).project("");
               nodes := nodes.reverse().leftfetchjoin(elem).reverse();
               nodes_order := nodes.hmark(0@0);
               nodes := nodes.tmark(0@0);
               var res_mu_is2ns := merged_union (nodes_order, texts_order, nodes, texts, 0@0, 1@0);
               var input_order := res_mu_is2ns.fetch(0);
               var input_str := res_mu_is2ns.fetch(1);
               var input_const := res_mu_is2ns.fetch(2);
               kind := kind.materialize(ipik);
               var atomic := kind.get_type_atomic();
               atomic := atomic.hmark(0@0);
               item := atomic.leftfetchjoin(item);
               kind := atomic.leftfetchjoin(kind);
               var _oid := kind.ord_uselect(STR);
               _oid := _oid.hmark(0@0);
               var part_item := _oid.leftfetchjoin(item).materialize(_oid);
               var _val := part_item.leftfetchjoin(str_values);
               {
                var part_kind := kind.ord_uselect(BOOL);
                var oid_oid := part_kind.hmark(0@0);
                var part_item := oid_oid.leftfetchjoin(item).materialize(oid_oid);
                var part_bit := part_item;
                var part_val := [str]([bit](part_bit));
                var res_mu := merged_union(_oid, oid_oid, _val, part_val);
                _oid := res_mu.fetch(0);
                _val := res_mu.fetch(1);
               }
               {
                var part_kind := kind.ord_uselect(DEC);
                var oid_oid := part_kind.hmark(0@0);
                var part_item := oid_oid.leftfetchjoin(item).materialize(oid_oid);
                var part_dbl := part_item.leftfetchjoin(dec_values);
                var part_val := part_dbl.[str]();
                var res_mu := merged_union(_oid, oid_oid, _val, part_val);
                _oid := res_mu.fetch(0);
                _val := res_mu.fetch(1);
               }
               {
                var part_kind := kind.ord_uselect(DBL);
                var oid_oid := part_kind.hmark(0@0);
                var part_item := oid_oid.leftfetchjoin(item).materialize(oid_oid);
                var part_dbl := part_item.leftfetchjoin(dbl_values);
                var part_val := part_dbl.[str]();
                var res_mu := merged_union(_oid, oid_oid, _val, part_val);
                _oid := res_mu.fetch(0);
                _val := res_mu.fetch(1);
               }
               {
                var part_kind := kind.ord_uselect(INT);
                var oid_oid := part_kind.hmark(0@0);
                var part_item := oid_oid.leftfetchjoin(item).materialize(oid_oid);
                var part_lng := part_item.leftfetchjoin(int_values);
                var part_val := part_lng.[str]();
                var res_mu := merged_union(_oid, oid_oid, _val, part_val);
                _oid := res_mu.fetch(0);
                _val := res_mu.fetch(1);
               }
               {
                var part_kind := kind.ord_uselect(U_A);
                var oid_oid := part_kind.hmark(0@0);
                var part_item := oid_oid.leftfetchjoin(item).materialize(oid_oid);
                var part_str := part_item.leftfetchjoin(str_values);
                var part_val := part_str.[str]();
                var res_mu := merged_union(_oid, oid_oid, _val, part_val);
                _val := res_mu.fetch(1);
               }
               if (_val.texist(str(nil))) {
                ERROR ("err:FORG0001: could not cast value to string.");
               }
               item_str_ := _val;
               res_mu_is2ns := merged_union (input_order, atomic, input_str, item_str_, input_const, 2@0);
               input_order := res_mu_is2ns.fetch(0);
               input_str := res_mu_is2ns.fetch(1);
               input_const := res_mu_is2ns.fetch(2);
               var input_iter := input_order.leftfetchjoin(iter012).chk_order();
               var result_size := iter012.tunique().count() + nodes_order.count() + 1;
               var result_str := combine_text_string (input_iter.materialize(input_str), input_const.materialize(input_str), input_str, result_size);
               var result_order := result_str.hmark(0@0);
               result_order := result_order.leftfetchjoin(input_order);
               result_str := result_str.tmark(0@0);
               iter := result_order;
               ipik := iter;
               item_str_ := result_str;
              }
              { # adding new strings to text node content and create new nodes
               var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
               var unq_str := item_str_.tunique().hmark(0@0);
               var str_unq := reverse(unq_str.tdiff(ws_prop_text));
               var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
               unq_str := str_unq.hmark(seqb);
               ws_prop_text := ws_prop_text.insert(unq_str);
               var ws_text_prop := ws_prop_text.reverse().sort();
               item_str_ := item_str_.materialize(ipik);
               var X_item := item_str_.hmark(0@0);
               var X_strings := item_str_.tmark(0@0).tsort();
               var X_prop := X_strings.leftjoin(ws_text_prop);
               var newPre_prop := X_item.reverse().leftjoin(X_prop);
               seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS))+ int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
               newPre_prop := newPre_prop.tmark(seqb);
               ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
               ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
               ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
               ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
               ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));
               {
                var kind_pre_ := newPre_prop.hmark(nil).chk_order();
                ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
               }
               item := item_str_.mark(seqb);
               kind := ELEM;
              } # end of adding new strings to text node content and create new nodes
              { # adding new fragments to the WS_FRAG bat
               var seqb := ws.fetch(WS_FRAG).count();
               seqb := oid(seqb);
               var new_pres := item.tmark(seqb);
               ws.fetch(WS_FRAG).insert(new_pres);
               ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
              } # end of adding new fragments to the WS_FRAG bat
              var res_mu_is2ns := merged_union (iter, nodes_order, item, nodes_order.leftfetchjoin(item012), kind, nodes_order.leftfetchjoin(kind012));
              kind012 := kind012.materialize(ipik012);
              var attr := kind012.get_type(ATTR).hmark(0@0);
              var item_attr := attr.leftfetchjoin(item012);
              var kind_attr := attr.leftfetchjoin(kind012);
              res_mu_is2ns := merged_union (res_mu_is2ns.fetch(0), attr, res_mu_is2ns.fetch(1), item_attr, res_mu_is2ns.fetch(2), kind_attr);
              iter := res_mu_is2ns.fetch(0).leftfetchjoin(iter012);
              item := res_mu_is2ns.fetch(1);
              kind := res_mu_is2ns.fetch(2);
              ipik := item;
             } # end of item-sequence-to-node-sequence
            } # end of deleteResult12 ()
            { # map2NODE_interface (counter)
             kind := kind.materialize(ipik);
             var attr := kind.get_type(ATTR).hmark(0@0);
             var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
             var attr_item := attr.leftfetchjoin(item);
             var attr_frag := attr.leftfetchjoin(kind).get_fragment();
             _r_attr_iter := attr_iter;
             _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
             _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
             _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
             var nodes := kind.get_type(ELEM);
             if (nodes.count() != 0) {
              var oid_oid := nodes.hmark(0@0);
              var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
              var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
              var iter_input := oid_oid.mirror();
              var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
              var res_iter := res_scj.fetch(0);
              var res_item := res_scj.fetch(1);
              var res_frag := res_scj.fetch(2);
              _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
              _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
              _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
              _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
              _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
              var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
              var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
              nodes := res_item.mark(0@0);
              var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
              root_level := nodes.leftfetchjoin(root_level);
              temp_ec_item := res_item;
              temp_ec_frag := res_frag;
              var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
              content_level := nodes.leftfetchjoin(content_level);
              content_level := content_level.[-](root_level);
              content_level := content_level.tmark(0@0);
              _elem_level := content_level;
              { # create attribute subtree copies
               var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
               var oid_attr := temp_attr.tmark(0@0);
               var oid_frag;
               if (is_constant(res_frag)) {
                oid_frag := res_frag;
               } else {
                oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
                oid_frag := oid_frag.tmark(0@0);
               }
               _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
               _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
               _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
               _attr_own  := temp_attr.hmark(0@0);
               _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
              } # end of create attribute subtree copies
             } else { # if (nodes.count() != 0) ...
              _elem_iter  := empty_bat;
              _elem_size  := empty_bat.project(int(nil));
              _elem_level := empty_bat.project(chr(nil));
              _elem_kind  := empty_bat.project(chr(nil));
              _elem_prop  := empty_bat;
              _elem_frag  := empty_bat;
              _attr_iter  := empty_bat;
              _attr_qn    := empty_bat;
              _attr_prop  := empty_bat;
              _attr_frag  := empty_bat;
              _attr_own   := empty_bat;
             } # end of else in 'if (nodes.count() != 0)'
            } # end of map2NODE_interface (counter)
            { # loop_liftedElemConstr (counter)
             var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
             iter_size := {count}(iter_size, iter011.tunique(), FALSE);
             var root_iter  := iter_size.hmark(0@0).chk_order();
             var root_size  := iter_size.tmark(0@0);
             var root_prop  := iter011.reverse().leftfetchjoin(item011);
             if (not(is_constant(root_prop))) {
              root_prop  := root_prop.tmark(0@0);
             }
             {
              var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
              _elem_iter  := merged_result.fetch(0);
              _elem_size  := merged_result.fetch(1);
              _elem_level := merged_result.fetch(2);
              _elem_kind  := merged_result.fetch(3);
              _elem_prop  := merged_result.fetch(4);
              _elem_frag  := merged_result.fetch(5);
              var preNew_preOld := merged_result.fetch(6);
              _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
              _attr_own := _attr_own.tmark(0@0);
             }
             { # create attribute root entries
              var root_item := _elem_level.ord_uselect(chr(0));
              root_item := root_item.hmark(0@0);
              var iter_item := iter011.reverse().leftfetchjoin(root_item);
              var attr_own := _r_attr_iter.leftjoin(iter_item);
              if (_r_attr_iter.count() != 0) { # test uniqueness
               var sorting := _r_attr_iter.tsort();
               sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
               var unq_attrs := sorting.tunique();
               if (unq_attrs.count() != _r_attr_iter.count()) {
                item011 := materialize(item011,ipik011);
                if (item011.count() > 0) {
                 ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item011.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
                } else {
                 ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
                }
               }
              } # end of test uniqueness
              if (_attr_iter.count() = 0) {
               _attr_iter := _r_attr_iter;
               _attr_qn   := _r_attr_qn;
               _attr_prop := _r_attr_prop;
               _attr_frag := _r_attr_frag;
               _attr_own  := attr_own.tmark(0@0);
              } else {
               var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
               _r_attr_iter := _r_attr_iter.tmark(seqb);
               _r_attr_qn   := _r_attr_qn  .tmark(seqb);
               _r_attr_prop := _r_attr_prop.tmark(seqb);
               _r_attr_frag := _r_attr_frag.tmark(seqb);
               attr_own := attr_own.tmark(seqb);
               _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
               _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
               _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
               _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
               _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
              }
              _r_attr_iter := empty_bat;
              _r_attr_qn   := empty_bat;
              _r_attr_prop := empty_bat;
              _r_attr_frag := empty_bat;
             } # end of create attribute root entries
            } # end of loop_liftedElemConstr (counter)
           } # end of deleteResult11 ()
           # translateSeq_node (f, counter)
           if (_r_attr_iter.count() = 0) {
            _r_attr_iter := _r_attr_iter010;
            _r_attr_qn := _r_attr_qn010;
            _r_attr_prop := _r_attr_prop010;
            _r_attr_frag := _r_attr_frag010;
           } else {
            if (_r_attr_iter010.count() != 0) 
            { # combine attribute roots
             var merged_result := merged_union (_r_attr_iter010.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn010, _r_attr_qn, _r_attr_prop010, _r_attr_prop, _r_attr_frag010, _r_attr_frag);
             _r_attr_iter := merged_result.fetch(0);
             _r_attr_qn := merged_result.fetch(1);
             _r_attr_prop := merged_result.fetch(2);
             _r_attr_frag := merged_result.fetch(3);
            }
           } # end of combine attribute roots
           if (_elem_iter.count() = 0) {
            _elem_iter  := _elem_iter010  ;
            _elem_size  := _elem_size010  ;
            _elem_level := _elem_level010 ;
            _elem_kind  := _elem_kind010  ;
            _elem_prop  := _elem_prop010  ;
            _elem_frag  := _elem_frag010  ;
            _attr_iter  := _attr_iter010  ;
            _attr_qn    := _attr_qn010    ;
            _attr_prop  := _attr_prop010  ;
            _attr_frag  := _attr_frag010  ;
            _attr_own   := _attr_own010   ;
           } else {
            if (_elem_iter010.count() != 0) 
            { # combine element nodes
             var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
             var shift_factor := int(seqb) - int(_elem_size010.seqbase());
             var merged_result := merged_union (_elem_iter010.chk_order(), _elem_iter.chk_order(), _elem_size010, _elem_size, _elem_level010, _elem_level, _elem_kind010, _elem_kind, _elem_prop010, _elem_prop, _elem_frag010, _elem_frag, _elem_size010.mark(seqb), _elem_size.mirror());
             _elem_iter := merged_result.fetch(0);
             _elem_size := merged_result.fetch(1);
             _elem_level:= merged_result.fetch(2);
             _elem_kind := merged_result.fetch(3);
             _elem_prop := merged_result.fetch(4);
             _elem_frag := merged_result.fetch(5);
             var preNew_preOld := merged_result.fetch(6);
             _attr_own010 := _attr_own010.[int]().[+](shift_factor).[oid]();
             merged_result := merged_union (_attr_iter010, _attr_iter, _attr_qn010, _attr_qn, _attr_prop010, _attr_prop, _attr_frag010, _attr_frag, _attr_own010, _attr_own);
             _attr_iter := merged_result.fetch(0);
             _attr_qn   := merged_result.fetch(1);
             _attr_prop := merged_result.fetch(2);
             _attr_frag := merged_result.fetch(3);
             _attr_own  := merged_result.fetch(4);
             _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
             _attr_own := _attr_own.tmark(0@0);
            }
           } # combine element nodes
           # end of translateSeq_node (f, counter)
          } # end of deleteResult_node10 ()
          # translateSeq_node (f, counter)
          if (_r_attr_iter.count() = 0) {
           _r_attr_iter := _r_attr_iter009;
           _r_attr_qn := _r_attr_qn009;
           _r_attr_prop := _r_attr_prop009;
           _r_attr_frag := _r_attr_frag009;
          } else {
           if (_r_attr_iter009.count() != 0) 
           { # combine attribute roots
            var merged_result := merged_union (_r_attr_iter009.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn009, _r_attr_qn, _r_attr_prop009, _r_attr_prop, _r_attr_frag009, _r_attr_frag);
            _r_attr_iter := merged_result.fetch(0);
            _r_attr_qn := merged_result.fetch(1);
            _r_attr_prop := merged_result.fetch(2);
            _r_attr_frag := merged_result.fetch(3);
           }
          } # end of combine attribute roots
          if (_elem_iter.count() = 0) {
           _elem_iter  := _elem_iter009  ;
           _elem_size  := _elem_size009  ;
           _elem_level := _elem_level009 ;
           _elem_kind  := _elem_kind009  ;
           _elem_prop  := _elem_prop009  ;
           _elem_frag  := _elem_frag009  ;
           _attr_iter  := _attr_iter009  ;
           _attr_qn    := _attr_qn009    ;
           _attr_prop  := _attr_prop009  ;
           _attr_frag  := _attr_frag009  ;
           _attr_own   := _attr_own009   ;
          } else {
           if (_elem_iter009.count() != 0) 
           { # combine element nodes
            var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
            var shift_factor := int(seqb) - int(_elem_size009.seqbase());
            var merged_result := merged_union (_elem_iter009.chk_order(), _elem_iter.chk_order(), _elem_size009, _elem_size, _elem_level009, _elem_level, _elem_kind009, _elem_kind, _elem_prop009, _elem_prop, _elem_frag009, _elem_frag, _elem_size009.mark(seqb), _elem_size.mirror());
            _elem_iter := merged_result.fetch(0);
            _elem_size := merged_result.fetch(1);
            _elem_level:= merged_result.fetch(2);
            _elem_kind := merged_result.fetch(3);
            _elem_prop := merged_result.fetch(4);
            _elem_frag := merged_result.fetch(5);
            var preNew_preOld := merged_result.fetch(6);
            _attr_own009 := _attr_own009.[int]().[+](shift_factor).[oid]();
            merged_result := merged_union (_attr_iter009, _attr_iter, _attr_qn009, _attr_qn, _attr_prop009, _attr_prop, _attr_frag009, _attr_frag, _attr_own009, _attr_own);
            _attr_iter := merged_result.fetch(0);
            _attr_qn   := merged_result.fetch(1);
            _attr_prop := merged_result.fetch(2);
            _attr_frag := merged_result.fetch(3);
            _attr_own  := merged_result.fetch(4);
            _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
            _attr_own := _attr_own.tmark(0@0);
           }
          } # combine element nodes
          # end of translateSeq_node (f, counter)
         } # end of deleteResult_node9 ()
         # translateSeq_node (f, counter)
         if (_r_attr_iter.count() = 0) {
          _r_attr_iter := _r_attr_iter008;
          _r_attr_qn := _r_attr_qn008;
          _r_attr_prop := _r_attr_prop008;
          _r_attr_frag := _r_attr_frag008;
         } else {
          if (_r_attr_iter008.count() != 0) 
          { # combine attribute roots
           var merged_result := merged_union (_r_attr_iter008.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn008, _r_attr_qn, _r_attr_prop008, _r_attr_prop, _r_attr_frag008, _r_attr_frag);
           _r_attr_iter := merged_result.fetch(0);
           _r_attr_qn := merged_result.fetch(1);
           _r_attr_prop := merged_result.fetch(2);
           _r_attr_frag := merged_result.fetch(3);
          }
         } # end of combine attribute roots
         if (_elem_iter.count() = 0) {
          _elem_iter  := _elem_iter008  ;
          _elem_size  := _elem_size008  ;
          _elem_level := _elem_level008 ;
          _elem_kind  := _elem_kind008  ;
          _elem_prop  := _elem_prop008  ;
          _elem_frag  := _elem_frag008  ;
          _attr_iter  := _attr_iter008  ;
          _attr_qn    := _attr_qn008    ;
          _attr_prop  := _attr_prop008  ;
          _attr_frag  := _attr_frag008  ;
          _attr_own   := _attr_own008   ;
         } else {
          if (_elem_iter008.count() != 0) 
          { # combine element nodes
           var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
           var shift_factor := int(seqb) - int(_elem_size008.seqbase());
           var merged_result := merged_union (_elem_iter008.chk_order(), _elem_iter.chk_order(), _elem_size008, _elem_size, _elem_level008, _elem_level, _elem_kind008, _elem_kind, _elem_prop008, _elem_prop, _elem_frag008, _elem_frag, _elem_size008.mark(seqb), _elem_size.mirror());
           _elem_iter := merged_result.fetch(0);
           _elem_size := merged_result.fetch(1);
           _elem_level:= merged_result.fetch(2);
           _elem_kind := merged_result.fetch(3);
           _elem_prop := merged_result.fetch(4);
           _elem_frag := merged_result.fetch(5);
           var preNew_preOld := merged_result.fetch(6);
           _attr_own008 := _attr_own008.[int]().[+](shift_factor).[oid]();
           merged_result := merged_union (_attr_iter008, _attr_iter, _attr_qn008, _attr_qn, _attr_prop008, _attr_prop, _attr_frag008, _attr_frag, _attr_own008, _attr_own);
           _attr_iter := merged_result.fetch(0);
           _attr_qn   := merged_result.fetch(1);
           _attr_prop := merged_result.fetch(2);
           _attr_frag := merged_result.fetch(3);
           _attr_own  := merged_result.fetch(4);
           _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
           _attr_own := _attr_own.tmark(0@0);
          }
         } # combine element nodes
         # end of translateSeq_node (f, counter)
        } # end of deleteResult_node8 ()
        { # loop_liftedElemConstr (counter)
         var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
         iter_size := {count}(iter_size, iter007.tunique(), FALSE);
         var root_iter  := iter_size.hmark(0@0).chk_order();
         var root_size  := iter_size.tmark(0@0);
         var root_prop  := iter007.reverse().leftfetchjoin(item007);
         if (not(is_constant(root_prop))) {
          root_prop  := root_prop.tmark(0@0);
         }
         {
          var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
          _elem_iter  := merged_result.fetch(0);
          _elem_size  := merged_result.fetch(1);
          _elem_level := merged_result.fetch(2);
          _elem_kind  := merged_result.fetch(3);
          _elem_prop  := merged_result.fetch(4);
          _elem_frag  := merged_result.fetch(5);
          var preNew_preOld := merged_result.fetch(6);
          _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
          _attr_own := _attr_own.tmark(0@0);
         }
         { # create attribute root entries
          var root_item := _elem_level.ord_uselect(chr(0));
          root_item := root_item.hmark(0@0);
          var iter_item := iter007.reverse().leftfetchjoin(root_item);
          var attr_own := _r_attr_iter.leftjoin(iter_item);
          if (_r_attr_iter.count() != 0) { # test uniqueness
           var sorting := _r_attr_iter.tsort();
           sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
           var unq_attrs := sorting.tunique();
           if (unq_attrs.count() != _r_attr_iter.count()) {
            item007 := materialize(item007,ipik007);
            if (item007.count() > 0) {
             ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item007.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
            } else {
             ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
            }
           }
          } # end of test uniqueness
          if (_attr_iter.count() = 0) {
           _attr_iter := _r_attr_iter;
           _attr_qn   := _r_attr_qn;
           _attr_prop := _r_attr_prop;
           _attr_frag := _r_attr_frag;
           _attr_own  := attr_own.tmark(0@0);
          } else {
           var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
           _r_attr_iter := _r_attr_iter.tmark(seqb);
           _r_attr_qn   := _r_attr_qn  .tmark(seqb);
           _r_attr_prop := _r_attr_prop.tmark(seqb);
           _r_attr_frag := _r_attr_frag.tmark(seqb);
           attr_own := attr_own.tmark(seqb);
           _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
           _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
           _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
           _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
           _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
          }
          _r_attr_iter := empty_bat;
          _r_attr_qn   := empty_bat;
          _r_attr_prop := empty_bat;
          _r_attr_frag := empty_bat;
         } # end of create attribute root entries
        } # end of loop_liftedElemConstr (counter)
       } # end of deleteResult7 ()
       { # saveResult_node7 () : int
        var _elem_iter007   := _elem_iter  ;
        var _elem_size007   := _elem_size  ;
        var _elem_level007  := _elem_level ;
        var _elem_kind007   := _elem_kind  ;
        var _elem_prop007   := _elem_prop  ;
        var _elem_frag007   := _elem_frag  ;
        var _attr_iter007   := _attr_iter  ;
        var _attr_qn007     := _attr_qn    ;
        var _attr_prop007   := _attr_prop  ;
        var _attr_frag007   := _attr_frag  ;
        var _attr_own007    := _attr_own   ;
        var _r_attr_iter007 := _r_attr_iter;
        var _r_attr_qn007   := _r_attr_qn  ;
        var _r_attr_prop007 := _r_attr_prop;
        var _r_attr_frag007 := _r_attr_frag; # end of saveResult_node7 () : int
        { # tagname-translation
         var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
         var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
         var itemID;
         if (prop_str.texist("coordonnees")) {
          itemID := prop_str.reverse().find("coordonnees");
         } else {
          itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
          ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
          ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
          ws.fetch(QN_LOC).fetch(WS).insert(itemID,"coordonnees");
          ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
          ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"coordonnees"+str('\1')+"");
         } # translateConst (kind)
         iter := loop002.tmark(0@0);
         ipik := iter;
         item := itemID;
        } # end of tagname-translation
        { # saveResult8 () : int
         var ipik008 := ipik;
         var iter008 := iter;
         var item008 := item; # end of saveResult8 () : int
         { # tagname-translation
          var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
          var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
          var itemID;
          if (prop_str.texist("nom")) {
           itemID := prop_str.reverse().find("nom");
          } else {
           itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
           ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
           ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
           ws.fetch(QN_LOC).fetch(WS).insert(itemID,"nom");
           ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
           ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"nom"+str('\1')+"");
          } # translateConst (kind)
          iter := loop002.tmark(0@0);
          ipik := iter;
          item := itemID;
         } # end of tagname-translation
         { # saveResult9 () : int
          var ipik009 := ipik;
          var iter009 := iter;
          var item009 := item; # end of saveResult9 () : int
          { # translateVar (t)
           var vid := v_vid002.ord_uselect(1303761071@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter002);
           item := vid.leftfetchjoin(v_item002);
           kind := vid.leftfetchjoin(v_kind002);
           ipik := iter;
          } # end of translateVar (t)
          { # translateLocsteps (c)
           var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
           iter := res_scj.fetch(0);
           item := res_scj.fetch(1);
           kind := res_scj.fetch(2).set_kind(ELEM);
           ipik := item;
          } # end of translateLocsteps (c)
          { # translateLocsteps (c)
           var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
           iter := res_scj.fetch(0);
           item := res_scj.fetch(1);
           kind := res_scj.fetch(2).set_kind(ELEM);
           ipik := item;
          } # end of translateLocsteps (c)
          { # map2NODE_interface (counter)
           kind := kind.materialize(ipik);
           var attr := kind.get_type(ATTR).hmark(0@0);
           var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
           var attr_item := attr.leftfetchjoin(item);
           var attr_frag := attr.leftfetchjoin(kind).get_fragment();
           _r_attr_iter := attr_iter;
           _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
           _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
           _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
           var nodes := kind.get_type(ELEM);
           if (nodes.count() != 0) {
            var oid_oid := nodes.hmark(0@0);
            var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
            var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
            var iter_input := oid_oid.mirror();
            var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
            var res_iter := res_scj.fetch(0);
            var res_item := res_scj.fetch(1);
            var res_frag := res_scj.fetch(2);
            _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
            _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
            _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
            _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
            _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
            var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
            var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
            nodes := res_item.mark(0@0);
            var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
            root_level := nodes.leftfetchjoin(root_level);
            temp_ec_item := res_item;
            temp_ec_frag := res_frag;
            var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
            content_level := nodes.leftfetchjoin(content_level);
            content_level := content_level.[-](root_level);
            content_level := content_level.tmark(0@0);
            _elem_level := content_level;
            { # create attribute subtree copies
             var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
             var oid_attr := temp_attr.tmark(0@0);
             var oid_frag;
             if (is_constant(res_frag)) {
              oid_frag := res_frag;
             } else {
              oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
              oid_frag := oid_frag.tmark(0@0);
             }
             _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
             _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
             _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
             _attr_own  := temp_attr.hmark(0@0);
             _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
            } # end of create attribute subtree copies
           } else { # if (nodes.count() != 0) ...
            _elem_iter  := empty_bat;
            _elem_size  := empty_bat.project(int(nil));
            _elem_level := empty_bat.project(chr(nil));
            _elem_kind  := empty_bat.project(chr(nil));
            _elem_prop  := empty_bat;
            _elem_frag  := empty_bat;
            _attr_iter  := empty_bat;
            _attr_qn    := empty_bat;
            _attr_prop  := empty_bat;
            _attr_frag  := empty_bat;
            _attr_own   := empty_bat;
           } # end of else in 'if (nodes.count() != 0)'
          } # end of map2NODE_interface (counter)
          if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
           { # saveResult_node10 () : int
            var _elem_iter010   := _elem_iter  ;
            var _elem_size010   := _elem_size  ;
            var _elem_level010  := _elem_level ;
            var _elem_kind010   := _elem_kind  ;
            var _elem_prop010   := _elem_prop  ;
            var _elem_frag010   := _elem_frag  ;
            var _attr_iter010   := _attr_iter  ;
            var _attr_qn010     := _attr_qn    ;
            var _attr_prop010   := _attr_prop  ;
            var _attr_frag010   := _attr_frag  ;
            var _attr_own010    := _attr_own   ;
            var _r_attr_iter010 := _r_attr_iter;
            var _r_attr_qn010   := _r_attr_qn  ;
            var _r_attr_prop010 := _r_attr_prop;
            var _r_attr_frag010 := _r_attr_frag; # end of saveResult_node10 () : int
            _elem_iter := _elem_iter010;
            _elem_level := _elem_level010;
            _elem_kind := _elem_kind010;
            _elem_prop := _elem_prop010;
            _elem_frag := _elem_frag010;
            var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
            rootnodes := rootnodes.leftfetchjoin(_elem_kind);
            var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
            var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
            var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
            {
             var text_prop := textnodes.leftfetchjoin(_elem_prop);
             var text_frag := textnodes.leftfetchjoin(_elem_frag);
             var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
             var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
             var input_order := res_mu_is2ns.fetch(0);
             var input_str := res_mu_is2ns.fetch(1);
             var input_const := res_mu_is2ns.fetch(2);
             var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
             var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
             var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
             var result_order := result_str.hmark(0@0);
             result_order := result_order.leftfetchjoin(input_order);
             result_str := result_str.tmark(0@0);
             iter := result_order;
             ipik := iter;
             item_str_ := result_str;
            }
            { # adding new strings to text node content and create new nodes
             var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
             var unq_str := item_str_.tunique().hmark(0@0);
             var str_unq := reverse(unq_str.tdiff(ws_prop_text));
             var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
             unq_str := str_unq.hmark(seqb);
             ws_prop_text := ws_prop_text.insert(unq_str);
             var ws_text_prop := ws_prop_text.reverse().sort();
             item_str_ := item_str_.materialize(ipik);
             var X_item := item_str_.hmark(0@0);
             var X_strings := item_str_.tmark(0@0).tsort();
             var X_prop := X_strings.leftjoin(ws_text_prop);
             var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
             newPre_prop := newPre_prop.tmark(0@0);
             _elem_iter  := iter;
             _elem_size  := newPre_prop.project(0);
             _elem_level := newPre_prop.project(chr(0));
             _elem_kind  := newPre_prop.project(TEXT);
             _elem_prop  := newPre_prop;
             _elem_frag  := newPre_prop.project(WS);
            } # end of adding new fragments to the WS_FRAG bat
            var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter010), _elem_iter.leftfetchjoin(_elem_iter010), othernodes.leftfetchjoin(_elem_size010), _elem_size, othernodes.leftfetchjoin(_elem_level010), _elem_level, othernodes.leftfetchjoin(_elem_kind010), _elem_kind, othernodes.leftfetchjoin(_elem_prop010), _elem_prop, othernodes.leftfetchjoin(_elem_frag010), _elem_frag, othernodes.leftfetchjoin(_elem_iter010.mirror()), oid(nil));
            _elem_iter := res_mu_is2ns.fetch(1).chk_order();
            _elem_size := res_mu_is2ns.fetch(2);
            _elem_level:= res_mu_is2ns.fetch(3);
            _elem_kind := res_mu_is2ns.fetch(4);
            _elem_prop := res_mu_is2ns.fetch(5);
            _elem_frag := res_mu_is2ns.fetch(6);
            var preNew_preOld := res_mu_is2ns.fetch(7);
            _attr_own := _attr_own010.leftjoin(preNew_preOld.reverse());
            _attr_iter   := _attr_iter010  ;
            _attr_qn     := _attr_qn010    ;
            _attr_prop   := _attr_prop010  ;
            _attr_frag   := _attr_frag010  ;
            _r_attr_iter := _r_attr_iter010;
            _r_attr_qn   := _r_attr_qn010  ;
            _r_attr_prop := _r_attr_prop010;
            _r_attr_frag := _r_attr_frag010;
           } # end of deleteResult_node10 ()
          } # end of item-sequence-to-node-sequence
          { # loop_liftedElemConstr (counter)
           var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
           iter_size := {count}(iter_size, iter009.tunique(), FALSE);
           var root_iter  := iter_size.hmark(0@0).chk_order();
           var root_size  := iter_size.tmark(0@0);
           var root_prop  := iter009.reverse().leftfetchjoin(item009);
           if (not(is_constant(root_prop))) {
            root_prop  := root_prop.tmark(0@0);
           }
           {
            var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
            _elem_iter  := merged_result.fetch(0);
            _elem_size  := merged_result.fetch(1);
            _elem_level := merged_result.fetch(2);
            _elem_kind  := merged_result.fetch(3);
            _elem_prop  := merged_result.fetch(4);
            _elem_frag  := merged_result.fetch(5);
            var preNew_preOld := merged_result.fetch(6);
            _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
            _attr_own := _attr_own.tmark(0@0);
           }
           { # create attribute root entries
            var root_item := _elem_level.ord_uselect(chr(0));
            root_item := root_item.hmark(0@0);
            var iter_item := iter009.reverse().leftfetchjoin(root_item);
            var attr_own := _r_attr_iter.leftjoin(iter_item);
            if (_r_attr_iter.count() != 0) { # test uniqueness
             var sorting := _r_attr_iter.tsort();
             sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
             var unq_attrs := sorting.tunique();
             if (unq_attrs.count() != _r_attr_iter.count()) {
              item009 := materialize(item009,ipik009);
              if (item009.count() > 0) {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item009.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
              } else {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
              }
             }
            } # end of test uniqueness
            if (_attr_iter.count() = 0) {
             _attr_iter := _r_attr_iter;
             _attr_qn   := _r_attr_qn;
             _attr_prop := _r_attr_prop;
             _attr_frag := _r_attr_frag;
             _attr_own  := attr_own.tmark(0@0);
            } else {
             var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
             _r_attr_iter := _r_attr_iter.tmark(seqb);
             _r_attr_qn   := _r_attr_qn  .tmark(seqb);
             _r_attr_prop := _r_attr_prop.tmark(seqb);
             _r_attr_frag := _r_attr_frag.tmark(seqb);
             attr_own := attr_own.tmark(seqb);
             _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
             _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
             _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
             _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
             _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
            }
            _r_attr_iter := empty_bat;
            _r_attr_qn   := empty_bat;
            _r_attr_prop := empty_bat;
            _r_attr_frag := empty_bat;
           } # end of create attribute root entries
          } # end of loop_liftedElemConstr (counter)
         } # end of deleteResult9 ()
         { # saveResult_node9 () : int
          var _elem_iter009   := _elem_iter  ;
          var _elem_size009   := _elem_size  ;
          var _elem_level009  := _elem_level ;
          var _elem_kind009   := _elem_kind  ;
          var _elem_prop009   := _elem_prop  ;
          var _elem_frag009   := _elem_frag  ;
          var _attr_iter009   := _attr_iter  ;
          var _attr_qn009     := _attr_qn    ;
          var _attr_prop009   := _attr_prop  ;
          var _attr_frag009   := _attr_frag  ;
          var _attr_own009    := _attr_own   ;
          var _r_attr_iter009 := _r_attr_iter;
          var _r_attr_qn009   := _r_attr_qn  ;
          var _r_attr_prop009 := _r_attr_prop;
          var _r_attr_frag009 := _r_attr_frag; # end of saveResult_node9 () : int
          { # tagname-translation
           var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
           var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
           var itemID;
           if (prop_str.texist("rue")) {
            itemID := prop_str.reverse().find("rue");
           } else {
            itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
            ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
            ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
            ws.fetch(QN_LOC).fetch(WS).insert(itemID,"rue");
            ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
            ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"rue"+str('\1')+"");
           } # translateConst (kind)
           iter := loop002.tmark(0@0);
           ipik := iter;
           item := itemID;
          } # end of tagname-translation
          { # saveResult10 () : int
           var ipik010 := ipik;
           var iter010 := iter;
           var item010 := item; # end of saveResult10 () : int
           { # translateVar (t)
            var vid := v_vid002.ord_uselect(1303761071@0);
            vid := vid.hmark(0@0);
            iter := vid.leftfetchjoin(v_iter002);
            item := vid.leftfetchjoin(v_item002);
            kind := vid.leftfetchjoin(v_kind002);
            ipik := iter;
           } # end of translateVar (t)
           { # translateLocsteps (c)
            var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "address");
            iter := res_scj.fetch(0);
            item := res_scj.fetch(1);
            kind := res_scj.fetch(2).set_kind(ELEM);
            ipik := item;
           } # end of translateLocsteps (c)
           { # translateLocsteps (c)
            var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "street");
            iter := res_scj.fetch(0);
            item := res_scj.fetch(1);
            kind := res_scj.fetch(2).set_kind(ELEM);
            ipik := item;
           } # end of translateLocsteps (c)
           { # translateLocsteps (c)
            var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
            iter := res_scj.fetch(0);
            item := res_scj.fetch(1);
            kind := res_scj.fetch(2).set_kind(ELEM);
            ipik := item;
           } # end of translateLocsteps (c)
           { # map2NODE_interface (counter)
            kind := kind.materialize(ipik);
            var attr := kind.get_type(ATTR).hmark(0@0);
            var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
            var attr_item := attr.leftfetchjoin(item);
            var attr_frag := attr.leftfetchjoin(kind).get_fragment();
            _r_attr_iter := attr_iter;
            _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
            _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
            _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
            var nodes := kind.get_type(ELEM);
            if (nodes.count() != 0) {
             var oid_oid := nodes.hmark(0@0);
             var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
             var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
             var iter_input := oid_oid.mirror();
             var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
             var res_iter := res_scj.fetch(0);
             var res_item := res_scj.fetch(1);
             var res_frag := res_scj.fetch(2);
             _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
             _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
             _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
             _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
             _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
             var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
             var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
             nodes := res_item.mark(0@0);
             var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
             root_level := nodes.leftfetchjoin(root_level);
             temp_ec_item := res_item;
             temp_ec_frag := res_frag;
             var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
             content_level := nodes.leftfetchjoin(content_level);
             content_level := content_level.[-](root_level);
             content_level := content_level.tmark(0@0);
             _elem_level := content_level;
             { # create attribute subtree copies
              var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
              var oid_attr := temp_attr.tmark(0@0);
              var oid_frag;
              if (is_constant(res_frag)) {
               oid_frag := res_frag;
              } else {
               oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
               oid_frag := oid_frag.tmark(0@0);
              }
              _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
              _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
              _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
              _attr_own  := temp_attr.hmark(0@0);
              _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
             } # end of create attribute subtree copies
            } else { # if (nodes.count() != 0) ...
             _elem_iter  := empty_bat;
             _elem_size  := empty_bat.project(int(nil));
             _elem_level := empty_bat.project(chr(nil));
             _elem_kind  := empty_bat.project(chr(nil));
             _elem_prop  := empty_bat;
             _elem_frag  := empty_bat;
             _attr_iter  := empty_bat;
             _attr_qn    := empty_bat;
             _attr_prop  := empty_bat;
             _attr_frag  := empty_bat;
             _attr_own   := empty_bat;
            } # end of else in 'if (nodes.count() != 0)'
           } # end of map2NODE_interface (counter)
           if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
            { # saveResult_node11 () : int
             var _elem_iter011   := _elem_iter  ;
             var _elem_size011   := _elem_size  ;
             var _elem_level011  := _elem_level ;
             var _elem_kind011   := _elem_kind  ;
             var _elem_prop011   := _elem_prop  ;
             var _elem_frag011   := _elem_frag  ;
             var _attr_iter011   := _attr_iter  ;
             var _attr_qn011     := _attr_qn    ;
             var _attr_prop011   := _attr_prop  ;
             var _attr_frag011   := _attr_frag  ;
             var _attr_own011    := _attr_own   ;
             var _r_attr_iter011 := _r_attr_iter;
             var _r_attr_qn011   := _r_attr_qn  ;
             var _r_attr_prop011 := _r_attr_prop;
             var _r_attr_frag011 := _r_attr_frag; # end of saveResult_node11 () : int
             _elem_iter := _elem_iter011;
             _elem_level := _elem_level011;
             _elem_kind := _elem_kind011;
             _elem_prop := _elem_prop011;
             _elem_frag := _elem_frag011;
             var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
             rootnodes := rootnodes.leftfetchjoin(_elem_kind);
             var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
             var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
             var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
             {
              var text_prop := textnodes.leftfetchjoin(_elem_prop);
              var text_frag := textnodes.leftfetchjoin(_elem_frag);
              var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
              var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
              var input_order := res_mu_is2ns.fetch(0);
              var input_str := res_mu_is2ns.fetch(1);
              var input_const := res_mu_is2ns.fetch(2);
              var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
              var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
              var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
              var result_order := result_str.hmark(0@0);
              result_order := result_order.leftfetchjoin(input_order);
              result_str := result_str.tmark(0@0);
              iter := result_order;
              ipik := iter;
              item_str_ := result_str;
             }
             { # adding new strings to text node content and create new nodes
              var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
              var unq_str := item_str_.tunique().hmark(0@0);
              var str_unq := reverse(unq_str.tdiff(ws_prop_text));
              var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
              unq_str := str_unq.hmark(seqb);
              ws_prop_text := ws_prop_text.insert(unq_str);
              var ws_text_prop := ws_prop_text.reverse().sort();
              item_str_ := item_str_.materialize(ipik);
              var X_item := item_str_.hmark(0@0);
              var X_strings := item_str_.tmark(0@0).tsort();
              var X_prop := X_strings.leftjoin(ws_text_prop);
              var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
              newPre_prop := newPre_prop.tmark(0@0);
              _elem_iter  := iter;
              _elem_size  := newPre_prop.project(0);
              _elem_level := newPre_prop.project(chr(0));
              _elem_kind  := newPre_prop.project(TEXT);
              _elem_prop  := newPre_prop;
              _elem_frag  := newPre_prop.project(WS);
             } # end of adding new fragments to the WS_FRAG bat
             var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter011), _elem_iter.leftfetchjoin(_elem_iter011), othernodes.leftfetchjoin(_elem_size011), _elem_size, othernodes.leftfetchjoin(_elem_level011), _elem_level, othernodes.leftfetchjoin(_elem_kind011), _elem_kind, othernodes.leftfetchjoin(_elem_prop011), _elem_prop, othernodes.leftfetchjoin(_elem_frag011), _elem_frag, othernodes.leftfetchjoin(_elem_iter011.mirror()), oid(nil));
             _elem_iter := res_mu_is2ns.fetch(1).chk_order();
             _elem_size := res_mu_is2ns.fetch(2);
             _elem_level:= res_mu_is2ns.fetch(3);
             _elem_kind := res_mu_is2ns.fetch(4);
             _elem_prop := res_mu_is2ns.fetch(5);
             _elem_frag := res_mu_is2ns.fetch(6);
             var preNew_preOld := res_mu_is2ns.fetch(7);
             _attr_own := _attr_own011.leftjoin(preNew_preOld.reverse());
             _attr_iter   := _attr_iter011  ;
             _attr_qn     := _attr_qn011    ;
             _attr_prop   := _attr_prop011  ;
             _attr_frag   := _attr_frag011  ;
             _r_attr_iter := _r_attr_iter011;
             _r_attr_qn   := _r_attr_qn011  ;
             _r_attr_prop := _r_attr_prop011;
             _r_attr_frag := _r_attr_frag011;
            } # end of deleteResult_node11 ()
           } # end of item-sequence-to-node-sequence
           { # loop_liftedElemConstr (counter)
            var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
            iter_size := {count}(iter_size, iter010.tunique(), FALSE);
            var root_iter  := iter_size.hmark(0@0).chk_order();
            var root_size  := iter_size.tmark(0@0);
            var root_prop  := iter010.reverse().leftfetchjoin(item010);
            if (not(is_constant(root_prop))) {
             root_prop  := root_prop.tmark(0@0);
            }
            {
             var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
             _elem_iter  := merged_result.fetch(0);
             _elem_size  := merged_result.fetch(1);
             _elem_level := merged_result.fetch(2);
             _elem_kind  := merged_result.fetch(3);
             _elem_prop  := merged_result.fetch(4);
             _elem_frag  := merged_result.fetch(5);
             var preNew_preOld := merged_result.fetch(6);
             _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
             _attr_own := _attr_own.tmark(0@0);
            }
            { # create attribute root entries
             var root_item := _elem_level.ord_uselect(chr(0));
             root_item := root_item.hmark(0@0);
             var iter_item := iter010.reverse().leftfetchjoin(root_item);
             var attr_own := _r_attr_iter.leftjoin(iter_item);
             if (_r_attr_iter.count() != 0) { # test uniqueness
              var sorting := _r_attr_iter.tsort();
              sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
              var unq_attrs := sorting.tunique();
              if (unq_attrs.count() != _r_attr_iter.count()) {
               item010 := materialize(item010,ipik010);
               if (item010.count() > 0) {
                ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item010.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
               } else {
                ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
               }
              }
             } # end of test uniqueness
             if (_attr_iter.count() = 0) {
              _attr_iter := _r_attr_iter;
              _attr_qn   := _r_attr_qn;
              _attr_prop := _r_attr_prop;
              _attr_frag := _r_attr_frag;
              _attr_own  := attr_own.tmark(0@0);
             } else {
              var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
              _r_attr_iter := _r_attr_iter.tmark(seqb);
              _r_attr_qn   := _r_attr_qn  .tmark(seqb);
              _r_attr_prop := _r_attr_prop.tmark(seqb);
              _r_attr_frag := _r_attr_frag.tmark(seqb);
              attr_own := attr_own.tmark(seqb);
              _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
              _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
              _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
              _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
              _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
             }
             _r_attr_iter := empty_bat;
             _r_attr_qn   := empty_bat;
             _r_attr_prop := empty_bat;
             _r_attr_frag := empty_bat;
            } # end of create attribute root entries
           } # end of loop_liftedElemConstr (counter)
          } # end of deleteResult10 ()
          { # saveResult_node10 () : int
           var _elem_iter010   := _elem_iter  ;
           var _elem_size010   := _elem_size  ;
           var _elem_level010  := _elem_level ;
           var _elem_kind010   := _elem_kind  ;
           var _elem_prop010   := _elem_prop  ;
           var _elem_frag010   := _elem_frag  ;
           var _attr_iter010   := _attr_iter  ;
           var _attr_qn010     := _attr_qn    ;
           var _attr_prop010   := _attr_prop  ;
           var _attr_frag010   := _attr_frag  ;
           var _attr_own010    := _attr_own   ;
           var _r_attr_iter010 := _r_attr_iter;
           var _r_attr_qn010   := _r_attr_qn  ;
           var _r_attr_prop010 := _r_attr_prop;
           var _r_attr_frag010 := _r_attr_frag; # end of saveResult_node10 () : int
           { # tagname-translation
            var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
            var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
            var itemID;
            if (prop_str.texist("ville")) {
             itemID := prop_str.reverse().find("ville");
            } else {
             itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
             ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
             ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
             ws.fetch(QN_LOC).fetch(WS).insert(itemID,"ville");
             ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
             ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"ville"+str('\1')+"");
            } # translateConst (kind)
            iter := loop002.tmark(0@0);
            ipik := iter;
            item := itemID;
           } # end of tagname-translation
           { # saveResult11 () : int
            var ipik011 := ipik;
            var iter011 := iter;
            var item011 := item; # end of saveResult11 () : int
            { # translateVar (t)
             var vid := v_vid002.ord_uselect(1303761071@0);
             vid := vid.hmark(0@0);
             iter := vid.leftfetchjoin(v_iter002);
             item := vid.leftfetchjoin(v_item002);
             kind := vid.leftfetchjoin(v_kind002);
             ipik := iter;
            } # end of translateVar (t)
            { # translateLocsteps (c)
             var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
             item := item.materialize(ipik);
             iter := iter.materialize(ipik);
             res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "address");
             iter := res_scj.fetch(0);
             item := res_scj.fetch(1);
             kind := res_scj.fetch(2).set_kind(ELEM);
             ipik := item;
            } # end of translateLocsteps (c)
            { # translateLocsteps (c)
             var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
             item := item.materialize(ipik);
             iter := iter.materialize(ipik);
             res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "city");
             iter := res_scj.fetch(0);
             item := res_scj.fetch(1);
             kind := res_scj.fetch(2).set_kind(ELEM);
             ipik := item;
            } # end of translateLocsteps (c)
            { # translateLocsteps (c)
             var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
             item := item.materialize(ipik);
             iter := iter.materialize(ipik);
             res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
             iter := res_scj.fetch(0);
             item := res_scj.fetch(1);
             kind := res_scj.fetch(2).set_kind(ELEM);
             ipik := item;
            } # end of translateLocsteps (c)
            { # map2NODE_interface (counter)
             kind := kind.materialize(ipik);
             var attr := kind.get_type(ATTR).hmark(0@0);
             var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
             var attr_item := attr.leftfetchjoin(item);
             var attr_frag := attr.leftfetchjoin(kind).get_fragment();
             _r_attr_iter := attr_iter;
             _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
             _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
             _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
             var nodes := kind.get_type(ELEM);
             if (nodes.count() != 0) {
              var oid_oid := nodes.hmark(0@0);
              var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
              var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
              var iter_input := oid_oid.mirror();
              var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
              var res_iter := res_scj.fetch(0);
              var res_item := res_scj.fetch(1);
              var res_frag := res_scj.fetch(2);
              _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
              _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
              _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
              _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
              _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
              var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
              var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
              nodes := res_item.mark(0@0);
              var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
              root_level := nodes.leftfetchjoin(root_level);
              temp_ec_item := res_item;
              temp_ec_frag := res_frag;
              var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
              content_level := nodes.leftfetchjoin(content_level);
              content_level := content_level.[-](root_level);
              content_level := content_level.tmark(0@0);
              _elem_level := content_level;
              { # create attribute subtree copies
               var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
               var oid_attr := temp_attr.tmark(0@0);
               var oid_frag;
               if (is_constant(res_frag)) {
                oid_frag := res_frag;
               } else {
                oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
                oid_frag := oid_frag.tmark(0@0);
               }
               _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
               _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
               _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
               _attr_own  := temp_attr.hmark(0@0);
               _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
              } # end of create attribute subtree copies
             } else { # if (nodes.count() != 0) ...
              _elem_iter  := empty_bat;
              _elem_size  := empty_bat.project(int(nil));
              _elem_level := empty_bat.project(chr(nil));
              _elem_kind  := empty_bat.project(chr(nil));
              _elem_prop  := empty_bat;
              _elem_frag  := empty_bat;
              _attr_iter  := empty_bat;
              _attr_qn    := empty_bat;
              _attr_prop  := empty_bat;
              _attr_frag  := empty_bat;
              _attr_own   := empty_bat;
             } # end of else in 'if (nodes.count() != 0)'
            } # end of map2NODE_interface (counter)
            if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
             { # saveResult_node12 () : int
              var _elem_iter012   := _elem_iter  ;
              var _elem_size012   := _elem_size  ;
              var _elem_level012  := _elem_level ;
              var _elem_kind012   := _elem_kind  ;
              var _elem_prop012   := _elem_prop  ;
              var _elem_frag012   := _elem_frag  ;
              var _attr_iter012   := _attr_iter  ;
              var _attr_qn012     := _attr_qn    ;
              var _attr_prop012   := _attr_prop  ;
              var _attr_frag012   := _attr_frag  ;
              var _attr_own012    := _attr_own   ;
              var _r_attr_iter012 := _r_attr_iter;
              var _r_attr_qn012   := _r_attr_qn  ;
              var _r_attr_prop012 := _r_attr_prop;
              var _r_attr_frag012 := _r_attr_frag; # end of saveResult_node12 () : int
              _elem_iter := _elem_iter012;
              _elem_level := _elem_level012;
              _elem_kind := _elem_kind012;
              _elem_prop := _elem_prop012;
              _elem_frag := _elem_frag012;
              var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
              rootnodes := rootnodes.leftfetchjoin(_elem_kind);
              var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
              var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
              var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
              {
               var text_prop := textnodes.leftfetchjoin(_elem_prop);
               var text_frag := textnodes.leftfetchjoin(_elem_frag);
               var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
               var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
               var input_order := res_mu_is2ns.fetch(0);
               var input_str := res_mu_is2ns.fetch(1);
               var input_const := res_mu_is2ns.fetch(2);
               var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
               var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
               var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
               var result_order := result_str.hmark(0@0);
               result_order := result_order.leftfetchjoin(input_order);
               result_str := result_str.tmark(0@0);
               iter := result_order;
               ipik := iter;
               item_str_ := result_str;
              }
              { # adding new strings to text node content and create new nodes
               var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
               var unq_str := item_str_.tunique().hmark(0@0);
               var str_unq := reverse(unq_str.tdiff(ws_prop_text));
               var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
               unq_str := str_unq.hmark(seqb);
               ws_prop_text := ws_prop_text.insert(unq_str);
               var ws_text_prop := ws_prop_text.reverse().sort();
               item_str_ := item_str_.materialize(ipik);
               var X_item := item_str_.hmark(0@0);
               var X_strings := item_str_.tmark(0@0).tsort();
               var X_prop := X_strings.leftjoin(ws_text_prop);
               var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
               newPre_prop := newPre_prop.tmark(0@0);
               _elem_iter  := iter;
               _elem_size  := newPre_prop.project(0);
               _elem_level := newPre_prop.project(chr(0));
               _elem_kind  := newPre_prop.project(TEXT);
               _elem_prop  := newPre_prop;
               _elem_frag  := newPre_prop.project(WS);
              } # end of adding new fragments to the WS_FRAG bat
              var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter012), _elem_iter.leftfetchjoin(_elem_iter012), othernodes.leftfetchjoin(_elem_size012), _elem_size, othernodes.leftfetchjoin(_elem_level012), _elem_level, othernodes.leftfetchjoin(_elem_kind012), _elem_kind, othernodes.leftfetchjoin(_elem_prop012), _elem_prop, othernodes.leftfetchjoin(_elem_frag012), _elem_frag, othernodes.leftfetchjoin(_elem_iter012.mirror()), oid(nil));
              _elem_iter := res_mu_is2ns.fetch(1).chk_order();
              _elem_size := res_mu_is2ns.fetch(2);
              _elem_level:= res_mu_is2ns.fetch(3);
              _elem_kind := res_mu_is2ns.fetch(4);
              _elem_prop := res_mu_is2ns.fetch(5);
              _elem_frag := res_mu_is2ns.fetch(6);
              var preNew_preOld := res_mu_is2ns.fetch(7);
              _attr_own := _attr_own012.leftjoin(preNew_preOld.reverse());
              _attr_iter   := _attr_iter012  ;
              _attr_qn     := _attr_qn012    ;
              _attr_prop   := _attr_prop012  ;
              _attr_frag   := _attr_frag012  ;
              _r_attr_iter := _r_attr_iter012;
              _r_attr_qn   := _r_attr_qn012  ;
              _r_attr_prop := _r_attr_prop012;
              _r_attr_frag := _r_attr_frag012;
             } # end of deleteResult_node12 ()
            } # end of item-sequence-to-node-sequence
            { # loop_liftedElemConstr (counter)
             var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
             iter_size := {count}(iter_size, iter011.tunique(), FALSE);
             var root_iter  := iter_size.hmark(0@0).chk_order();
             var root_size  := iter_size.tmark(0@0);
             var root_prop  := iter011.reverse().leftfetchjoin(item011);
             if (not(is_constant(root_prop))) {
              root_prop  := root_prop.tmark(0@0);
             }
             {
              var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
              _elem_iter  := merged_result.fetch(0);
              _elem_size  := merged_result.fetch(1);
              _elem_level := merged_result.fetch(2);
              _elem_kind  := merged_result.fetch(3);
              _elem_prop  := merged_result.fetch(4);
              _elem_frag  := merged_result.fetch(5);
              var preNew_preOld := merged_result.fetch(6);
              _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
              _attr_own := _attr_own.tmark(0@0);
             }
             { # create attribute root entries
              var root_item := _elem_level.ord_uselect(chr(0));
              root_item := root_item.hmark(0@0);
              var iter_item := iter011.reverse().leftfetchjoin(root_item);
              var attr_own := _r_attr_iter.leftjoin(iter_item);
              if (_r_attr_iter.count() != 0) { # test uniqueness
               var sorting := _r_attr_iter.tsort();
               sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
               var unq_attrs := sorting.tunique();
               if (unq_attrs.count() != _r_attr_iter.count()) {
                item011 := materialize(item011,ipik011);
                if (item011.count() > 0) {
                 ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item011.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
                } else {
                 ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
                }
               }
              } # end of test uniqueness
              if (_attr_iter.count() = 0) {
               _attr_iter := _r_attr_iter;
               _attr_qn   := _r_attr_qn;
               _attr_prop := _r_attr_prop;
               _attr_frag := _r_attr_frag;
               _attr_own  := attr_own.tmark(0@0);
              } else {
               var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
               _r_attr_iter := _r_attr_iter.tmark(seqb);
               _r_attr_qn   := _r_attr_qn  .tmark(seqb);
               _r_attr_prop := _r_attr_prop.tmark(seqb);
               _r_attr_frag := _r_attr_frag.tmark(seqb);
               attr_own := attr_own.tmark(seqb);
               _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
               _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
               _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
               _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
               _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
              }
              _r_attr_iter := empty_bat;
              _r_attr_qn   := empty_bat;
              _r_attr_prop := empty_bat;
              _r_attr_frag := empty_bat;
             } # end of create attribute root entries
            } # end of loop_liftedElemConstr (counter)
           } # end of deleteResult11 ()
           { # saveResult_node11 () : int
            var _elem_iter011   := _elem_iter  ;
            var _elem_size011   := _elem_size  ;
            var _elem_level011  := _elem_level ;
            var _elem_kind011   := _elem_kind  ;
            var _elem_prop011   := _elem_prop  ;
            var _elem_frag011   := _elem_frag  ;
            var _attr_iter011   := _attr_iter  ;
            var _attr_qn011     := _attr_qn    ;
            var _attr_prop011   := _attr_prop  ;
            var _attr_frag011   := _attr_frag  ;
            var _attr_own011    := _attr_own   ;
            var _r_attr_iter011 := _r_attr_iter;
            var _r_attr_qn011   := _r_attr_qn  ;
            var _r_attr_prop011 := _r_attr_prop;
            var _r_attr_frag011 := _r_attr_frag; # end of saveResult_node11 () : int
            { # tagname-translation
             var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
             var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
             var itemID;
             if (prop_str.texist("pays")) {
              itemID := prop_str.reverse().find("pays");
             } else {
              itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
              ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
              ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
              ws.fetch(QN_LOC).fetch(WS).insert(itemID,"pays");
              ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
              ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"pays"+str('\1')+"");
             } # translateConst (kind)
             iter := loop002.tmark(0@0);
             ipik := iter;
             item := itemID;
            } # end of tagname-translation
            { # saveResult12 () : int
             var ipik012 := ipik;
             var iter012 := iter;
             var item012 := item; # end of saveResult12 () : int
             { # translateVar (t)
              var vid := v_vid002.ord_uselect(1303761071@0);
              vid := vid.hmark(0@0);
              iter := vid.leftfetchjoin(v_iter002);
              item := vid.leftfetchjoin(v_item002);
              kind := vid.leftfetchjoin(v_kind002);
              ipik := iter;
             } # end of translateVar (t)
             { # translateLocsteps (c)
              var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
              item := item.materialize(ipik);
              iter := iter.materialize(ipik);
              res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "address");
              iter := res_scj.fetch(0);
              item := res_scj.fetch(1);
              kind := res_scj.fetch(2).set_kind(ELEM);
              ipik := item;
             } # end of translateLocsteps (c)
             { # translateLocsteps (c)
              var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
              item := item.materialize(ipik);
              iter := iter.materialize(ipik);
              res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "country");
              iter := res_scj.fetch(0);
              item := res_scj.fetch(1);
              kind := res_scj.fetch(2).set_kind(ELEM);
              ipik := item;
             } # end of translateLocsteps (c)
             { # translateLocsteps (c)
              var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
              item := item.materialize(ipik);
              iter := iter.materialize(ipik);
              res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
              iter := res_scj.fetch(0);
              item := res_scj.fetch(1);
              kind := res_scj.fetch(2).set_kind(ELEM);
              ipik := item;
             } # end of translateLocsteps (c)
             { # map2NODE_interface (counter)
              kind := kind.materialize(ipik);
              var attr := kind.get_type(ATTR).hmark(0@0);
              var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
              var attr_item := attr.leftfetchjoin(item);
              var attr_frag := attr.leftfetchjoin(kind).get_fragment();
              _r_attr_iter := attr_iter;
              _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
              _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
              _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
              var nodes := kind.get_type(ELEM);
              if (nodes.count() != 0) {
               var oid_oid := nodes.hmark(0@0);
               var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
               var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
               var iter_input := oid_oid.mirror();
               var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
               var res_iter := res_scj.fetch(0);
               var res_item := res_scj.fetch(1);
               var res_frag := res_scj.fetch(2);
               _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
               _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
               _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
               _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
               _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
               var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
               var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
               nodes := res_item.mark(0@0);
               var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
               root_level := nodes.leftfetchjoin(root_level);
               temp_ec_item := res_item;
               temp_ec_frag := res_frag;
               var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
               content_level := nodes.leftfetchjoin(content_level);
               content_level := content_level.[-](root_level);
               content_level := content_level.tmark(0@0);
               _elem_level := content_level;
               { # create attribute subtree copies
                var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
                var oid_attr := temp_attr.tmark(0@0);
                var oid_frag;
                if (is_constant(res_frag)) {
                 oid_frag := res_frag;
                } else {
                 oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
                 oid_frag := oid_frag.tmark(0@0);
                }
                _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
                _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
                _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
                _attr_own  := temp_attr.hmark(0@0);
                _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
               } # end of create attribute subtree copies
              } else { # if (nodes.count() != 0) ...
               _elem_iter  := empty_bat;
               _elem_size  := empty_bat.project(int(nil));
               _elem_level := empty_bat.project(chr(nil));
               _elem_kind  := empty_bat.project(chr(nil));
               _elem_prop  := empty_bat;
               _elem_frag  := empty_bat;
               _attr_iter  := empty_bat;
               _attr_qn    := empty_bat;
               _attr_prop  := empty_bat;
               _attr_frag  := empty_bat;
               _attr_own   := empty_bat;
              } # end of else in 'if (nodes.count() != 0)'
             } # end of map2NODE_interface (counter)
             if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
              { # saveResult_node13 () : int
               var _elem_iter013   := _elem_iter  ;
               var _elem_size013   := _elem_size  ;
               var _elem_level013  := _elem_level ;
               var _elem_kind013   := _elem_kind  ;
               var _elem_prop013   := _elem_prop  ;
               var _elem_frag013   := _elem_frag  ;
               var _attr_iter013   := _attr_iter  ;
               var _attr_qn013     := _attr_qn    ;
               var _attr_prop013   := _attr_prop  ;
               var _attr_frag013   := _attr_frag  ;
               var _attr_own013    := _attr_own   ;
               var _r_attr_iter013 := _r_attr_iter;
               var _r_attr_qn013   := _r_attr_qn  ;
               var _r_attr_prop013 := _r_attr_prop;
               var _r_attr_frag013 := _r_attr_frag; # end of saveResult_node13 () : int
               _elem_iter := _elem_iter013;
               _elem_level := _elem_level013;
               _elem_kind := _elem_kind013;
               _elem_prop := _elem_prop013;
               _elem_frag := _elem_frag013;
               var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
               rootnodes := rootnodes.leftfetchjoin(_elem_kind);
               var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
               var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
               var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
               {
                var text_prop := textnodes.leftfetchjoin(_elem_prop);
                var text_frag := textnodes.leftfetchjoin(_elem_frag);
                var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
                var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
                var input_order := res_mu_is2ns.fetch(0);
                var input_str := res_mu_is2ns.fetch(1);
                var input_const := res_mu_is2ns.fetch(2);
                var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
                var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
                var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
                var result_order := result_str.hmark(0@0);
                result_order := result_order.leftfetchjoin(input_order);
                result_str := result_str.tmark(0@0);
                iter := result_order;
                ipik := iter;
                item_str_ := result_str;
               }
               { # adding new strings to text node content and create new nodes
                var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
                var unq_str := item_str_.tunique().hmark(0@0);
                var str_unq := reverse(unq_str.tdiff(ws_prop_text));
                var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
                unq_str := str_unq.hmark(seqb);
                ws_prop_text := ws_prop_text.insert(unq_str);
                var ws_text_prop := ws_prop_text.reverse().sort();
                item_str_ := item_str_.materialize(ipik);
                var X_item := item_str_.hmark(0@0);
                var X_strings := item_str_.tmark(0@0).tsort();
                var X_prop := X_strings.leftjoin(ws_text_prop);
                var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
                newPre_prop := newPre_prop.tmark(0@0);
                _elem_iter  := iter;
                _elem_size  := newPre_prop.project(0);
                _elem_level := newPre_prop.project(chr(0));
                _elem_kind  := newPre_prop.project(TEXT);
                _elem_prop  := newPre_prop;
                _elem_frag  := newPre_prop.project(WS);
               } # end of adding new fragments to the WS_FRAG bat
               var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter013), _elem_iter.leftfetchjoin(_elem_iter013), othernodes.leftfetchjoin(_elem_size013), _elem_size, othernodes.leftfetchjoin(_elem_level013), _elem_level, othernodes.leftfetchjoin(_elem_kind013), _elem_kind, othernodes.leftfetchjoin(_elem_prop013), _elem_prop, othernodes.leftfetchjoin(_elem_frag013), _elem_frag, othernodes.leftfetchjoin(_elem_iter013.mirror()), oid(nil));
               _elem_iter := res_mu_is2ns.fetch(1).chk_order();
               _elem_size := res_mu_is2ns.fetch(2);
               _elem_level:= res_mu_is2ns.fetch(3);
               _elem_kind := res_mu_is2ns.fetch(4);
               _elem_prop := res_mu_is2ns.fetch(5);
               _elem_frag := res_mu_is2ns.fetch(6);
               var preNew_preOld := res_mu_is2ns.fetch(7);
               _attr_own := _attr_own013.leftjoin(preNew_preOld.reverse());
               _attr_iter   := _attr_iter013  ;
               _attr_qn     := _attr_qn013    ;
               _attr_prop   := _attr_prop013  ;
               _attr_frag   := _attr_frag013  ;
               _r_attr_iter := _r_attr_iter013;
               _r_attr_qn   := _r_attr_qn013  ;
               _r_attr_prop := _r_attr_prop013;
               _r_attr_frag := _r_attr_frag013;
              } # end of deleteResult_node13 ()
             } # end of item-sequence-to-node-sequence
             { # loop_liftedElemConstr (counter)
              var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
              iter_size := {count}(iter_size, iter012.tunique(), FALSE);
              var root_iter  := iter_size.hmark(0@0).chk_order();
              var root_size  := iter_size.tmark(0@0);
              var root_prop  := iter012.reverse().leftfetchjoin(item012);
              if (not(is_constant(root_prop))) {
               root_prop  := root_prop.tmark(0@0);
              }
              {
               var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
               _elem_iter  := merged_result.fetch(0);
               _elem_size  := merged_result.fetch(1);
               _elem_level := merged_result.fetch(2);
               _elem_kind  := merged_result.fetch(3);
               _elem_prop  := merged_result.fetch(4);
               _elem_frag  := merged_result.fetch(5);
               var preNew_preOld := merged_result.fetch(6);
               _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
               _attr_own := _attr_own.tmark(0@0);
              }
              { # create attribute root entries
               var root_item := _elem_level.ord_uselect(chr(0));
               root_item := root_item.hmark(0@0);
               var iter_item := iter012.reverse().leftfetchjoin(root_item);
               var attr_own := _r_attr_iter.leftjoin(iter_item);
               if (_r_attr_iter.count() != 0) { # test uniqueness
                var sorting := _r_attr_iter.tsort();
                sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
                var unq_attrs := sorting.tunique();
                if (unq_attrs.count() != _r_attr_iter.count()) {
                 item012 := materialize(item012,ipik012);
                 if (item012.count() > 0) {
                  ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item012.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
                 } else {
                  ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
                 }
                }
               } # end of test uniqueness
               if (_attr_iter.count() = 0) {
                _attr_iter := _r_attr_iter;
                _attr_qn   := _r_attr_qn;
                _attr_prop := _r_attr_prop;
                _attr_frag := _r_attr_frag;
                _attr_own  := attr_own.tmark(0@0);
               } else {
                var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
                _r_attr_iter := _r_attr_iter.tmark(seqb);
                _r_attr_qn   := _r_attr_qn  .tmark(seqb);
                _r_attr_prop := _r_attr_prop.tmark(seqb);
                _r_attr_frag := _r_attr_frag.tmark(seqb);
                attr_own := attr_own.tmark(seqb);
                _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
                _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
                _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
                _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
                _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
               }
               _r_attr_iter := empty_bat;
               _r_attr_qn   := empty_bat;
               _r_attr_prop := empty_bat;
               _r_attr_frag := empty_bat;
              } # end of create attribute root entries
             } # end of loop_liftedElemConstr (counter)
            } # end of deleteResult12 ()
            { # saveResult_node12 () : int
             var _elem_iter012   := _elem_iter  ;
             var _elem_size012   := _elem_size  ;
             var _elem_level012  := _elem_level ;
             var _elem_kind012   := _elem_kind  ;
             var _elem_prop012   := _elem_prop  ;
             var _elem_frag012   := _elem_frag  ;
             var _attr_iter012   := _attr_iter  ;
             var _attr_qn012     := _attr_qn    ;
             var _attr_prop012   := _attr_prop  ;
             var _attr_frag012   := _attr_frag  ;
             var _attr_own012    := _attr_own   ;
             var _r_attr_iter012 := _r_attr_iter;
             var _r_attr_qn012   := _r_attr_qn  ;
             var _r_attr_prop012 := _r_attr_prop;
             var _r_attr_frag012 := _r_attr_frag; # end of saveResult_node12 () : int
             { # tagname-translation
              var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
              var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
              var itemID;
              if (prop_str.texist("reseau")) {
               itemID := prop_str.reverse().find("reseau");
              } else {
               itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
               ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
               ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
               ws.fetch(QN_LOC).fetch(WS).insert(itemID,"reseau");
               ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
               ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"reseau"+str('\1')+"");
              } # translateConst (kind)
              iter := loop002.tmark(0@0);
              ipik := iter;
              item := itemID;
             } # end of tagname-translation
             { # saveResult13 () : int
              var ipik013 := ipik;
              var iter013 := iter;
              var item013 := item; # end of saveResult13 () : int
              { # tagname-translation
               var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
               var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
               var itemID;
               if (prop_str.texist("courrier")) {
                itemID := prop_str.reverse().find("courrier");
               } else {
                itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
                ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
                ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
                ws.fetch(QN_LOC).fetch(WS).insert(itemID,"courrier");
                ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
                ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"courrier"+str('\1')+"");
               } # translateConst (kind)
               iter := loop002.tmark(0@0);
               ipik := iter;
               item := itemID;
              } # end of tagname-translation
              { # saveResult14 () : int
               var ipik014 := ipik;
               var iter014 := iter;
               var item014 := item; # end of saveResult14 () : int
               { # translateVar (t)
                var vid := v_vid002.ord_uselect(1303761071@0);
                vid := vid.hmark(0@0);
                iter := vid.leftfetchjoin(v_iter002);
                item := vid.leftfetchjoin(v_item002);
                kind := vid.leftfetchjoin(v_kind002);
                ipik := iter;
               } # end of translateVar (t)
               { # translateLocsteps (c)
                var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
                item := item.materialize(ipik);
                iter := iter.materialize(ipik);
                res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "emailaddress");
                iter := res_scj.fetch(0);
                item := res_scj.fetch(1);
                kind := res_scj.fetch(2).set_kind(ELEM);
                ipik := item;
               } # end of translateLocsteps (c)
               { # translateLocsteps (c)
                var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
                item := item.materialize(ipik);
                iter := iter.materialize(ipik);
                res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
                iter := res_scj.fetch(0);
                item := res_scj.fetch(1);
                kind := res_scj.fetch(2).set_kind(ELEM);
                ipik := item;
               } # end of translateLocsteps (c)
               { # map2NODE_interface (counter)
                kind := kind.materialize(ipik);
                var attr := kind.get_type(ATTR).hmark(0@0);
                var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
                var attr_item := attr.leftfetchjoin(item);
                var attr_frag := attr.leftfetchjoin(kind).get_fragment();
                _r_attr_iter := attr_iter;
                _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
                _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
                _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
                var nodes := kind.get_type(ELEM);
                if (nodes.count() != 0) {
                 var oid_oid := nodes.hmark(0@0);
                 var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
                 var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
                 var iter_input := oid_oid.mirror();
                 var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
                 var res_iter := res_scj.fetch(0);
                 var res_item := res_scj.fetch(1);
                 var res_frag := res_scj.fetch(2);
                 _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
                 _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
                 _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
                 _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
                 _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
                 var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
                 var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
                 nodes := res_item.mark(0@0);
                 var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
                 root_level := nodes.leftfetchjoin(root_level);
                 temp_ec_item := res_item;
                 temp_ec_frag := res_frag;
                 var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
                 content_level := nodes.leftfetchjoin(content_level);
                 content_level := content_level.[-](root_level);
                 content_level := content_level.tmark(0@0);
                 _elem_level := content_level;
                 { # create attribute subtree copies
                  var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
                  var oid_attr := temp_attr.tmark(0@0);
                  var oid_frag;
                  if (is_constant(res_frag)) {
                   oid_frag := res_frag;
                  } else {
                   oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
                   oid_frag := oid_frag.tmark(0@0);
                  }
                  _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
                  _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
                  _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
                  _attr_own  := temp_attr.hmark(0@0);
                  _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
                 } # end of create attribute subtree copies
                } else { # if (nodes.count() != 0) ...
                 _elem_iter  := empty_bat;
                 _elem_size  := empty_bat.project(int(nil));
                 _elem_level := empty_bat.project(chr(nil));
                 _elem_kind  := empty_bat.project(chr(nil));
                 _elem_prop  := empty_bat;
                 _elem_frag  := empty_bat;
                 _attr_iter  := empty_bat;
                 _attr_qn    := empty_bat;
                 _attr_prop  := empty_bat;
                 _attr_frag  := empty_bat;
                 _attr_own   := empty_bat;
                } # end of else in 'if (nodes.count() != 0)'
               } # end of map2NODE_interface (counter)
               if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
                { # saveResult_node15 () : int
                 var _elem_iter015   := _elem_iter  ;
                 var _elem_size015   := _elem_size  ;
                 var _elem_level015  := _elem_level ;
                 var _elem_kind015   := _elem_kind  ;
                 var _elem_prop015   := _elem_prop  ;
                 var _elem_frag015   := _elem_frag  ;
                 var _attr_iter015   := _attr_iter  ;
                 var _attr_qn015     := _attr_qn    ;
                 var _attr_prop015   := _attr_prop  ;
                 var _attr_frag015   := _attr_frag  ;
                 var _attr_own015    := _attr_own   ;
                 var _r_attr_iter015 := _r_attr_iter;
                 var _r_attr_qn015   := _r_attr_qn  ;
                 var _r_attr_prop015 := _r_attr_prop;
                 var _r_attr_frag015 := _r_attr_frag; # end of saveResult_node15 () : int
                 _elem_iter := _elem_iter015;
                 _elem_level := _elem_level015;
                 _elem_kind := _elem_kind015;
                 _elem_prop := _elem_prop015;
                 _elem_frag := _elem_frag015;
                 var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
                 rootnodes := rootnodes.leftfetchjoin(_elem_kind);
                 var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
                 var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
                 var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
                 {
                  var text_prop := textnodes.leftfetchjoin(_elem_prop);
                  var text_frag := textnodes.leftfetchjoin(_elem_frag);
                  var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
                  var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
                  var input_order := res_mu_is2ns.fetch(0);
                  var input_str := res_mu_is2ns.fetch(1);
                  var input_const := res_mu_is2ns.fetch(2);
                  var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
                  var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
                  var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
                  var result_order := result_str.hmark(0@0);
                  result_order := result_order.leftfetchjoin(input_order);
                  result_str := result_str.tmark(0@0);
                  iter := result_order;
                  ipik := iter;
                  item_str_ := result_str;
                 }
                 { # adding new strings to text node content and create new nodes
                  var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
                  var unq_str := item_str_.tunique().hmark(0@0);
                  var str_unq := reverse(unq_str.tdiff(ws_prop_text));
                  var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
                  unq_str := str_unq.hmark(seqb);
                  ws_prop_text := ws_prop_text.insert(unq_str);
                  var ws_text_prop := ws_prop_text.reverse().sort();
                  item_str_ := item_str_.materialize(ipik);
                  var X_item := item_str_.hmark(0@0);
                  var X_strings := item_str_.tmark(0@0).tsort();
                  var X_prop := X_strings.leftjoin(ws_text_prop);
                  var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
                  newPre_prop := newPre_prop.tmark(0@0);
                  _elem_iter  := iter;
                  _elem_size  := newPre_prop.project(0);
                  _elem_level := newPre_prop.project(chr(0));
                  _elem_kind  := newPre_prop.project(TEXT);
                  _elem_prop  := newPre_prop;
                  _elem_frag  := newPre_prop.project(WS);
                 } # end of adding new fragments to the WS_FRAG bat
                 var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter015), _elem_iter.leftfetchjoin(_elem_iter015), othernodes.leftfetchjoin(_elem_size015), _elem_size, othernodes.leftfetchjoin(_elem_level015), _elem_level, othernodes.leftfetchjoin(_elem_kind015), _elem_kind, othernodes.leftfetchjoin(_elem_prop015), _elem_prop, othernodes.leftfetchjoin(_elem_frag015), _elem_frag, othernodes.leftfetchjoin(_elem_iter015.mirror()), oid(nil));
                 _elem_iter := res_mu_is2ns.fetch(1).chk_order();
                 _elem_size := res_mu_is2ns.fetch(2);
                 _elem_level:= res_mu_is2ns.fetch(3);
                 _elem_kind := res_mu_is2ns.fetch(4);
                 _elem_prop := res_mu_is2ns.fetch(5);
                 _elem_frag := res_mu_is2ns.fetch(6);
                 var preNew_preOld := res_mu_is2ns.fetch(7);
                 _attr_own := _attr_own015.leftjoin(preNew_preOld.reverse());
                 _attr_iter   := _attr_iter015  ;
                 _attr_qn     := _attr_qn015    ;
                 _attr_prop   := _attr_prop015  ;
                 _attr_frag   := _attr_frag015  ;
                 _r_attr_iter := _r_attr_iter015;
                 _r_attr_qn   := _r_attr_qn015  ;
                 _r_attr_prop := _r_attr_prop015;
                 _r_attr_frag := _r_attr_frag015;
                } # end of deleteResult_node15 ()
               } # end of item-sequence-to-node-sequence
               { # loop_liftedElemConstr (counter)
                var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
                iter_size := {count}(iter_size, iter014.tunique(), FALSE);
                var root_iter  := iter_size.hmark(0@0).chk_order();
                var root_size  := iter_size.tmark(0@0);
                var root_prop  := iter014.reverse().leftfetchjoin(item014);
                if (not(is_constant(root_prop))) {
                 root_prop  := root_prop.tmark(0@0);
                }
                {
                 var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
                 _elem_iter  := merged_result.fetch(0);
                 _elem_size  := merged_result.fetch(1);
                 _elem_level := merged_result.fetch(2);
                 _elem_kind  := merged_result.fetch(3);
                 _elem_prop  := merged_result.fetch(4);
                 _elem_frag  := merged_result.fetch(5);
                 var preNew_preOld := merged_result.fetch(6);
                 _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
                 _attr_own := _attr_own.tmark(0@0);
                }
                { # create attribute root entries
                 var root_item := _elem_level.ord_uselect(chr(0));
                 root_item := root_item.hmark(0@0);
                 var iter_item := iter014.reverse().leftfetchjoin(root_item);
                 var attr_own := _r_attr_iter.leftjoin(iter_item);
                 if (_r_attr_iter.count() != 0) { # test uniqueness
                  var sorting := _r_attr_iter.tsort();
                  sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
                  var unq_attrs := sorting.tunique();
                  if (unq_attrs.count() != _r_attr_iter.count()) {
                   item014 := materialize(item014,ipik014);
                   if (item014.count() > 0) {
                    ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item014.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
                   } else {
                    ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
                   }
                  }
                 } # end of test uniqueness
                 if (_attr_iter.count() = 0) {
                  _attr_iter := _r_attr_iter;
                  _attr_qn   := _r_attr_qn;
                  _attr_prop := _r_attr_prop;
                  _attr_frag := _r_attr_frag;
                  _attr_own  := attr_own.tmark(0@0);
                 } else {
                  var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
                  _r_attr_iter := _r_attr_iter.tmark(seqb);
                  _r_attr_qn   := _r_attr_qn  .tmark(seqb);
                  _r_attr_prop := _r_attr_prop.tmark(seqb);
                  _r_attr_frag := _r_attr_frag.tmark(seqb);
                  attr_own := attr_own.tmark(seqb);
                  _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
                  _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
                  _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
                  _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
                  _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
                 }
                 _r_attr_iter := empty_bat;
                 _r_attr_qn   := empty_bat;
                 _r_attr_prop := empty_bat;
                 _r_attr_frag := empty_bat;
                } # end of create attribute root entries
               } # end of loop_liftedElemConstr (counter)
              } # end of deleteResult14 ()
              { # saveResult_node14 () : int
               var _elem_iter014   := _elem_iter  ;
               var _elem_size014   := _elem_size  ;
               var _elem_level014  := _elem_level ;
               var _elem_kind014   := _elem_kind  ;
               var _elem_prop014   := _elem_prop  ;
               var _elem_frag014   := _elem_frag  ;
               var _attr_iter014   := _attr_iter  ;
               var _attr_qn014     := _attr_qn    ;
               var _attr_prop014   := _attr_prop  ;
               var _attr_frag014   := _attr_frag  ;
               var _attr_own014    := _attr_own   ;
               var _r_attr_iter014 := _r_attr_iter;
               var _r_attr_qn014   := _r_attr_qn  ;
               var _r_attr_prop014 := _r_attr_prop;
               var _r_attr_frag014 := _r_attr_frag; # end of saveResult_node14 () : int
               { # tagname-translation
                var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
                var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
                var itemID;
                if (prop_str.texist("pagePerso")) {
                 itemID := prop_str.reverse().find("pagePerso");
                } else {
                 itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
                 ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
                 ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
                 ws.fetch(QN_LOC).fetch(WS).insert(itemID,"pagePerso");
                 ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
                 ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"pagePerso"+str('\1')+"");
                } # translateConst (kind)
                iter := loop002.tmark(0@0);
                ipik := iter;
                item := itemID;
               } # end of tagname-translation
               { # saveResult15 () : int
                var ipik015 := ipik;
                var iter015 := iter;
                var item015 := item; # end of saveResult15 () : int
                { # translateVar (t)
                 var vid := v_vid002.ord_uselect(1303761071@0);
                 vid := vid.hmark(0@0);
                 iter := vid.leftfetchjoin(v_iter002);
                 item := vid.leftfetchjoin(v_item002);
                 kind := vid.leftfetchjoin(v_kind002);
                 ipik := iter;
                } # end of translateVar (t)
                { # translateLocsteps (c)
                 var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
                 item := item.materialize(ipik);
                 iter := iter.materialize(ipik);
                 res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "homepage");
                 iter := res_scj.fetch(0);
                 item := res_scj.fetch(1);
                 kind := res_scj.fetch(2).set_kind(ELEM);
                 ipik := item;
                } # end of translateLocsteps (c)
                { # translateLocsteps (c)
                 var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
                 item := item.materialize(ipik);
                 iter := iter.materialize(ipik);
                 res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
                 iter := res_scj.fetch(0);
                 item := res_scj.fetch(1);
                 kind := res_scj.fetch(2).set_kind(ELEM);
                 ipik := item;
                } # end of translateLocsteps (c)
                { # map2NODE_interface (counter)
                 kind := kind.materialize(ipik);
                 var attr := kind.get_type(ATTR).hmark(0@0);
                 var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
                 var attr_item := attr.leftfetchjoin(item);
                 var attr_frag := attr.leftfetchjoin(kind).get_fragment();
                 _r_attr_iter := attr_iter;
                 _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
                 _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
                 _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
                 var nodes := kind.get_type(ELEM);
                 if (nodes.count() != 0) {
                  var oid_oid := nodes.hmark(0@0);
                  var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
                  var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
                  var iter_input := oid_oid.mirror();
                  var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
                  var res_iter := res_scj.fetch(0);
                  var res_item := res_scj.fetch(1);
                  var res_frag := res_scj.fetch(2);
                  _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
                  _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
                  _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
                  _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
                  _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
                  var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
                  var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
                  nodes := res_item.mark(0@0);
                  var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
                  root_level := nodes.leftfetchjoin(root_level);
                  temp_ec_item := res_item;
                  temp_ec_frag := res_frag;
                  var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
                  content_level := nodes.leftfetchjoin(content_level);
                  content_level := content_level.[-](root_level);
                  content_level := content_level.tmark(0@0);
                  _elem_level := content_level;
                  { # create attribute subtree copies
                   var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
                   var oid_attr := temp_attr.tmark(0@0);
                   var oid_frag;
                   if (is_constant(res_frag)) {
                    oid_frag := res_frag;
                   } else {
                    oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
                    oid_frag := oid_frag.tmark(0@0);
                   }
                   _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
                   _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
                   _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
                   _attr_own  := temp_attr.hmark(0@0);
                   _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
                  } # end of create attribute subtree copies
                 } else { # if (nodes.count() != 0) ...
                  _elem_iter  := empty_bat;
                  _elem_size  := empty_bat.project(int(nil));
                  _elem_level := empty_bat.project(chr(nil));
                  _elem_kind  := empty_bat.project(chr(nil));
                  _elem_prop  := empty_bat;
                  _elem_frag  := empty_bat;
                  _attr_iter  := empty_bat;
                  _attr_qn    := empty_bat;
                  _attr_prop  := empty_bat;
                  _attr_frag  := empty_bat;
                  _attr_own   := empty_bat;
                 } # end of else in 'if (nodes.count() != 0)'
                } # end of map2NODE_interface (counter)
                if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
                 { # saveResult_node16 () : int
                  var _elem_iter016   := _elem_iter  ;
                  var _elem_size016   := _elem_size  ;
                  var _elem_level016  := _elem_level ;
                  var _elem_kind016   := _elem_kind  ;
                  var _elem_prop016   := _elem_prop  ;
                  var _elem_frag016   := _elem_frag  ;
                  var _attr_iter016   := _attr_iter  ;
                  var _attr_qn016     := _attr_qn    ;
                  var _attr_prop016   := _attr_prop  ;
                  var _attr_frag016   := _attr_frag  ;
                  var _attr_own016    := _attr_own   ;
                  var _r_attr_iter016 := _r_attr_iter;
                  var _r_attr_qn016   := _r_attr_qn  ;
                  var _r_attr_prop016 := _r_attr_prop;
                  var _r_attr_frag016 := _r_attr_frag; # end of saveResult_node16 () : int
                  _elem_iter := _elem_iter016;
                  _elem_level := _elem_level016;
                  _elem_kind := _elem_kind016;
                  _elem_prop := _elem_prop016;
                  _elem_frag := _elem_frag016;
                  var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
                  rootnodes := rootnodes.leftfetchjoin(_elem_kind);
                  var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
                  var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
                  var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
                  {
                   var text_prop := textnodes.leftfetchjoin(_elem_prop);
                   var text_frag := textnodes.leftfetchjoin(_elem_frag);
                   var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
                   var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
                   var input_order := res_mu_is2ns.fetch(0);
                   var input_str := res_mu_is2ns.fetch(1);
                   var input_const := res_mu_is2ns.fetch(2);
                   var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
                   var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
                   var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
                   var result_order := result_str.hmark(0@0);
                   result_order := result_order.leftfetchjoin(input_order);
                   result_str := result_str.tmark(0@0);
                   iter := result_order;
                   ipik := iter;
                   item_str_ := result_str;
                  }
                  { # adding new strings to text node content and create new nodes
                   var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
                   var unq_str := item_str_.tunique().hmark(0@0);
                   var str_unq := reverse(unq_str.tdiff(ws_prop_text));
                   var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
                   unq_str := str_unq.hmark(seqb);
                   ws_prop_text := ws_prop_text.insert(unq_str);
                   var ws_text_prop := ws_prop_text.reverse().sort();
                   item_str_ := item_str_.materialize(ipik);
                   var X_item := item_str_.hmark(0@0);
                   var X_strings := item_str_.tmark(0@0).tsort();
                   var X_prop := X_strings.leftjoin(ws_text_prop);
                   var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
                   newPre_prop := newPre_prop.tmark(0@0);
                   _elem_iter  := iter;
                   _elem_size  := newPre_prop.project(0);
                   _elem_level := newPre_prop.project(chr(0));
                   _elem_kind  := newPre_prop.project(TEXT);
                   _elem_prop  := newPre_prop;
                   _elem_frag  := newPre_prop.project(WS);
                  } # end of adding new fragments to the WS_FRAG bat
                  var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter016), _elem_iter.leftfetchjoin(_elem_iter016), othernodes.leftfetchjoin(_elem_size016), _elem_size, othernodes.leftfetchjoin(_elem_level016), _elem_level, othernodes.leftfetchjoin(_elem_kind016), _elem_kind, othernodes.leftfetchjoin(_elem_prop016), _elem_prop, othernodes.leftfetchjoin(_elem_frag016), _elem_frag, othernodes.leftfetchjoin(_elem_iter016.mirror()), oid(nil));
                  _elem_iter := res_mu_is2ns.fetch(1).chk_order();
                  _elem_size := res_mu_is2ns.fetch(2);
                  _elem_level:= res_mu_is2ns.fetch(3);
                  _elem_kind := res_mu_is2ns.fetch(4);
                  _elem_prop := res_mu_is2ns.fetch(5);
                  _elem_frag := res_mu_is2ns.fetch(6);
                  var preNew_preOld := res_mu_is2ns.fetch(7);
                  _attr_own := _attr_own016.leftjoin(preNew_preOld.reverse());
                  _attr_iter   := _attr_iter016  ;
                  _attr_qn     := _attr_qn016    ;
                  _attr_prop   := _attr_prop016  ;
                  _attr_frag   := _attr_frag016  ;
                  _r_attr_iter := _r_attr_iter016;
                  _r_attr_qn   := _r_attr_qn016  ;
                  _r_attr_prop := _r_attr_prop016;
                  _r_attr_frag := _r_attr_frag016;
                 } # end of deleteResult_node16 ()
                } # end of item-sequence-to-node-sequence
                { # loop_liftedElemConstr (counter)
                 var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
                 iter_size := {count}(iter_size, iter015.tunique(), FALSE);
                 var root_iter  := iter_size.hmark(0@0).chk_order();
                 var root_size  := iter_size.tmark(0@0);
                 var root_prop  := iter015.reverse().leftfetchjoin(item015);
                 if (not(is_constant(root_prop))) {
                  root_prop  := root_prop.tmark(0@0);
                 }
                 {
                  var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
                  _elem_iter  := merged_result.fetch(0);
                  _elem_size  := merged_result.fetch(1);
                  _elem_level := merged_result.fetch(2);
                  _elem_kind  := merged_result.fetch(3);
                  _elem_prop  := merged_result.fetch(4);
                  _elem_frag  := merged_result.fetch(5);
                  var preNew_preOld := merged_result.fetch(6);
                  _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
                  _attr_own := _attr_own.tmark(0@0);
                 }
                 { # create attribute root entries
                  var root_item := _elem_level.ord_uselect(chr(0));
                  root_item := root_item.hmark(0@0);
                  var iter_item := iter015.reverse().leftfetchjoin(root_item);
                  var attr_own := _r_attr_iter.leftjoin(iter_item);
                  if (_r_attr_iter.count() != 0) { # test uniqueness
                   var sorting := _r_attr_iter.tsort();
                   sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
                   var unq_attrs := sorting.tunique();
                   if (unq_attrs.count() != _r_attr_iter.count()) {
                    item015 := materialize(item015,ipik015);
                    if (item015.count() > 0) {
                     ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item015.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
                    } else {
                     ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
                    }
                   }
                  } # end of test uniqueness
                  if (_attr_iter.count() = 0) {
                   _attr_iter := _r_attr_iter;
                   _attr_qn   := _r_attr_qn;
                   _attr_prop := _r_attr_prop;
                   _attr_frag := _r_attr_frag;
                   _attr_own  := attr_own.tmark(0@0);
                  } else {
                   var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
                   _r_attr_iter := _r_attr_iter.tmark(seqb);
                   _r_attr_qn   := _r_attr_qn  .tmark(seqb);
                   _r_attr_prop := _r_attr_prop.tmark(seqb);
                   _r_attr_frag := _r_attr_frag.tmark(seqb);
                   attr_own := attr_own.tmark(seqb);
                   _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
                   _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
                   _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
                   _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
                   _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
                  }
                  _r_attr_iter := empty_bat;
                  _r_attr_qn   := empty_bat;
                  _r_attr_prop := empty_bat;
                  _r_attr_frag := empty_bat;
                 } # end of create attribute root entries
                } # end of loop_liftedElemConstr (counter)
               } # end of deleteResult15 ()
               # translateSeq_node (f, counter)
               if (_r_attr_iter.count() = 0) {
                _r_attr_iter := _r_attr_iter014;
                _r_attr_qn := _r_attr_qn014;
                _r_attr_prop := _r_attr_prop014;
                _r_attr_frag := _r_attr_frag014;
               } else {
                if (_r_attr_iter014.count() != 0) 
                { # combine attribute roots
                 var merged_result := merged_union (_r_attr_iter014.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn014, _r_attr_qn, _r_attr_prop014, _r_attr_prop, _r_attr_frag014, _r_attr_frag);
                 _r_attr_iter := merged_result.fetch(0);
                 _r_attr_qn := merged_result.fetch(1);
                 _r_attr_prop := merged_result.fetch(2);
                 _r_attr_frag := merged_result.fetch(3);
                }
               } # end of combine attribute roots
               if (_elem_iter.count() = 0) {
                _elem_iter  := _elem_iter014  ;
                _elem_size  := _elem_size014  ;
                _elem_level := _elem_level014 ;
                _elem_kind  := _elem_kind014  ;
                _elem_prop  := _elem_prop014  ;
                _elem_frag  := _elem_frag014  ;
                _attr_iter  := _attr_iter014  ;
                _attr_qn    := _attr_qn014    ;
                _attr_prop  := _attr_prop014  ;
                _attr_frag  := _attr_frag014  ;
                _attr_own   := _attr_own014   ;
               } else {
                if (_elem_iter014.count() != 0) 
                { # combine element nodes
                 var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
                 var shift_factor := int(seqb) - int(_elem_size014.seqbase());
                 var merged_result := merged_union (_elem_iter014.chk_order(), _elem_iter.chk_order(), _elem_size014, _elem_size, _elem_level014, _elem_level, _elem_kind014, _elem_kind, _elem_prop014, _elem_prop, _elem_frag014, _elem_frag, _elem_size014.mark(seqb), _elem_size.mirror());
                 _elem_iter := merged_result.fetch(0);
                 _elem_size := merged_result.fetch(1);
                 _elem_level:= merged_result.fetch(2);
                 _elem_kind := merged_result.fetch(3);
                 _elem_prop := merged_result.fetch(4);
                 _elem_frag := merged_result.fetch(5);
                 var preNew_preOld := merged_result.fetch(6);
                 _attr_own014 := _attr_own014.[int]().[+](shift_factor).[oid]();
                 merged_result := merged_union (_attr_iter014, _attr_iter, _attr_qn014, _attr_qn, _attr_prop014, _attr_prop, _attr_frag014, _attr_frag, _attr_own014, _attr_own);
                 _attr_iter := merged_result.fetch(0);
                 _attr_qn   := merged_result.fetch(1);
                 _attr_prop := merged_result.fetch(2);
                 _attr_frag := merged_result.fetch(3);
                 _attr_own  := merged_result.fetch(4);
                 _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
                 _attr_own := _attr_own.tmark(0@0);
                }
               } # combine element nodes
               # end of translateSeq_node (f, counter)
              } # end of deleteResult_node14 ()
              { # loop_liftedElemConstr (counter)
               var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
               iter_size := {count}(iter_size, iter013.tunique(), FALSE);
               var root_iter  := iter_size.hmark(0@0).chk_order();
               var root_size  := iter_size.tmark(0@0);
               var root_prop  := iter013.reverse().leftfetchjoin(item013);
               if (not(is_constant(root_prop))) {
                root_prop  := root_prop.tmark(0@0);
               }
               {
                var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
                _elem_iter  := merged_result.fetch(0);
                _elem_size  := merged_result.fetch(1);
                _elem_level := merged_result.fetch(2);
                _elem_kind  := merged_result.fetch(3);
                _elem_prop  := merged_result.fetch(4);
                _elem_frag  := merged_result.fetch(5);
                var preNew_preOld := merged_result.fetch(6);
                _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
                _attr_own := _attr_own.tmark(0@0);
               }
               { # create attribute root entries
                var root_item := _elem_level.ord_uselect(chr(0));
                root_item := root_item.hmark(0@0);
                var iter_item := iter013.reverse().leftfetchjoin(root_item);
                var attr_own := _r_attr_iter.leftjoin(iter_item);
                if (_r_attr_iter.count() != 0) { # test uniqueness
                 var sorting := _r_attr_iter.tsort();
                 sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
                 var unq_attrs := sorting.tunique();
                 if (unq_attrs.count() != _r_attr_iter.count()) {
                  item013 := materialize(item013,ipik013);
                  if (item013.count() > 0) {
                   ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item013.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
                  } else {
                   ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
                  }
                 }
                } # end of test uniqueness
                if (_attr_iter.count() = 0) {
                 _attr_iter := _r_attr_iter;
                 _attr_qn   := _r_attr_qn;
                 _attr_prop := _r_attr_prop;
                 _attr_frag := _r_attr_frag;
                 _attr_own  := attr_own.tmark(0@0);
                } else {
                 var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
                 _r_attr_iter := _r_attr_iter.tmark(seqb);
                 _r_attr_qn   := _r_attr_qn  .tmark(seqb);
                 _r_attr_prop := _r_attr_prop.tmark(seqb);
                 _r_attr_frag := _r_attr_frag.tmark(seqb);
                 attr_own := attr_own.tmark(seqb);
                 _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
                 _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
                 _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
                 _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
                 _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
                }
                _r_attr_iter := empty_bat;
                _r_attr_qn   := empty_bat;
                _r_attr_prop := empty_bat;
                _r_attr_frag := empty_bat;
               } # end of create attribute root entries
              } # end of loop_liftedElemConstr (counter)
             } # end of deleteResult13 ()
             # translateSeq_node (f, counter)
             if (_r_attr_iter.count() = 0) {
              _r_attr_iter := _r_attr_iter012;
              _r_attr_qn := _r_attr_qn012;
              _r_attr_prop := _r_attr_prop012;
              _r_attr_frag := _r_attr_frag012;
             } else {
              if (_r_attr_iter012.count() != 0) 
              { # combine attribute roots
               var merged_result := merged_union (_r_attr_iter012.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn012, _r_attr_qn, _r_attr_prop012, _r_attr_prop, _r_attr_frag012, _r_attr_frag);
               _r_attr_iter := merged_result.fetch(0);
               _r_attr_qn := merged_result.fetch(1);
               _r_attr_prop := merged_result.fetch(2);
               _r_attr_frag := merged_result.fetch(3);
              }
             } # end of combine attribute roots
             if (_elem_iter.count() = 0) {
              _elem_iter  := _elem_iter012  ;
              _elem_size  := _elem_size012  ;
              _elem_level := _elem_level012 ;
              _elem_kind  := _elem_kind012  ;
              _elem_prop  := _elem_prop012  ;
              _elem_frag  := _elem_frag012  ;
              _attr_iter  := _attr_iter012  ;
              _attr_qn    := _attr_qn012    ;
              _attr_prop  := _attr_prop012  ;
              _attr_frag  := _attr_frag012  ;
              _attr_own   := _attr_own012   ;
             } else {
              if (_elem_iter012.count() != 0) 
              { # combine element nodes
               var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
               var shift_factor := int(seqb) - int(_elem_size012.seqbase());
               var merged_result := merged_union (_elem_iter012.chk_order(), _elem_iter.chk_order(), _elem_size012, _elem_size, _elem_level012, _elem_level, _elem_kind012, _elem_kind, _elem_prop012, _elem_prop, _elem_frag012, _elem_frag, _elem_size012.mark(seqb), _elem_size.mirror());
               _elem_iter := merged_result.fetch(0);
               _elem_size := merged_result.fetch(1);
               _elem_level:= merged_result.fetch(2);
               _elem_kind := merged_result.fetch(3);
               _elem_prop := merged_result.fetch(4);
               _elem_frag := merged_result.fetch(5);
               var preNew_preOld := merged_result.fetch(6);
               _attr_own012 := _attr_own012.[int]().[+](shift_factor).[oid]();
               merged_result := merged_union (_attr_iter012, _attr_iter, _attr_qn012, _attr_qn, _attr_prop012, _attr_prop, _attr_frag012, _attr_frag, _attr_own012, _attr_own);
               _attr_iter := merged_result.fetch(0);
               _attr_qn   := merged_result.fetch(1);
               _attr_prop := merged_result.fetch(2);
               _attr_frag := merged_result.fetch(3);
               _attr_own  := merged_result.fetch(4);
               _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
               _attr_own := _attr_own.tmark(0@0);
              }
             } # combine element nodes
             # end of translateSeq_node (f, counter)
            } # end of deleteResult_node12 ()
            # translateSeq_node (f, counter)
            if (_r_attr_iter.count() = 0) {
             _r_attr_iter := _r_attr_iter011;
             _r_attr_qn := _r_attr_qn011;
             _r_attr_prop := _r_attr_prop011;
             _r_attr_frag := _r_attr_frag011;
            } else {
             if (_r_attr_iter011.count() != 0) 
             { # combine attribute roots
              var merged_result := merged_union (_r_attr_iter011.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn011, _r_attr_qn, _r_attr_prop011, _r_attr_prop, _r_attr_frag011, _r_attr_frag);
              _r_attr_iter := merged_result.fetch(0);
              _r_attr_qn := merged_result.fetch(1);
              _r_attr_prop := merged_result.fetch(2);
              _r_attr_frag := merged_result.fetch(3);
             }
            } # end of combine attribute roots
            if (_elem_iter.count() = 0) {
             _elem_iter  := _elem_iter011  ;
             _elem_size  := _elem_size011  ;
             _elem_level := _elem_level011 ;
             _elem_kind  := _elem_kind011  ;
             _elem_prop  := _elem_prop011  ;
             _elem_frag  := _elem_frag011  ;
             _attr_iter  := _attr_iter011  ;
             _attr_qn    := _attr_qn011    ;
             _attr_prop  := _attr_prop011  ;
             _attr_frag  := _attr_frag011  ;
             _attr_own   := _attr_own011   ;
            } else {
             if (_elem_iter011.count() != 0) 
             { # combine element nodes
              var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
              var shift_factor := int(seqb) - int(_elem_size011.seqbase());
              var merged_result := merged_union (_elem_iter011.chk_order(), _elem_iter.chk_order(), _elem_size011, _elem_size, _elem_level011, _elem_level, _elem_kind011, _elem_kind, _elem_prop011, _elem_prop, _elem_frag011, _elem_frag, _elem_size011.mark(seqb), _elem_size.mirror());
              _elem_iter := merged_result.fetch(0);
              _elem_size := merged_result.fetch(1);
              _elem_level:= merged_result.fetch(2);
              _elem_kind := merged_result.fetch(3);
              _elem_prop := merged_result.fetch(4);
              _elem_frag := merged_result.fetch(5);
              var preNew_preOld := merged_result.fetch(6);
              _attr_own011 := _attr_own011.[int]().[+](shift_factor).[oid]();
              merged_result := merged_union (_attr_iter011, _attr_iter, _attr_qn011, _attr_qn, _attr_prop011, _attr_prop, _attr_frag011, _attr_frag, _attr_own011, _attr_own);
              _attr_iter := merged_result.fetch(0);
              _attr_qn   := merged_result.fetch(1);
              _attr_prop := merged_result.fetch(2);
              _attr_frag := merged_result.fetch(3);
              _attr_own  := merged_result.fetch(4);
              _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
              _attr_own := _attr_own.tmark(0@0);
             }
            } # combine element nodes
            # end of translateSeq_node (f, counter)
           } # end of deleteResult_node11 ()
           # translateSeq_node (f, counter)
           if (_r_attr_iter.count() = 0) {
            _r_attr_iter := _r_attr_iter010;
            _r_attr_qn := _r_attr_qn010;
            _r_attr_prop := _r_attr_prop010;
            _r_attr_frag := _r_attr_frag010;
           } else {
            if (_r_attr_iter010.count() != 0) 
            { # combine attribute roots
             var merged_result := merged_union (_r_attr_iter010.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn010, _r_attr_qn, _r_attr_prop010, _r_attr_prop, _r_attr_frag010, _r_attr_frag);
             _r_attr_iter := merged_result.fetch(0);
             _r_attr_qn := merged_result.fetch(1);
             _r_attr_prop := merged_result.fetch(2);
             _r_attr_frag := merged_result.fetch(3);
            }
           } # end of combine attribute roots
           if (_elem_iter.count() = 0) {
            _elem_iter  := _elem_iter010  ;
            _elem_size  := _elem_size010  ;
            _elem_level := _elem_level010 ;
            _elem_kind  := _elem_kind010  ;
            _elem_prop  := _elem_prop010  ;
            _elem_frag  := _elem_frag010  ;
            _attr_iter  := _attr_iter010  ;
            _attr_qn    := _attr_qn010    ;
            _attr_prop  := _attr_prop010  ;
            _attr_frag  := _attr_frag010  ;
            _attr_own   := _attr_own010   ;
           } else {
            if (_elem_iter010.count() != 0) 
            { # combine element nodes
             var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
             var shift_factor := int(seqb) - int(_elem_size010.seqbase());
             var merged_result := merged_union (_elem_iter010.chk_order(), _elem_iter.chk_order(), _elem_size010, _elem_size, _elem_level010, _elem_level, _elem_kind010, _elem_kind, _elem_prop010, _elem_prop, _elem_frag010, _elem_frag, _elem_size010.mark(seqb), _elem_size.mirror());
             _elem_iter := merged_result.fetch(0);
             _elem_size := merged_result.fetch(1);
             _elem_level:= merged_result.fetch(2);
             _elem_kind := merged_result.fetch(3);
             _elem_prop := merged_result.fetch(4);
             _elem_frag := merged_result.fetch(5);
             var preNew_preOld := merged_result.fetch(6);
             _attr_own010 := _attr_own010.[int]().[+](shift_factor).[oid]();
             merged_result := merged_union (_attr_iter010, _attr_iter, _attr_qn010, _attr_qn, _attr_prop010, _attr_prop, _attr_frag010, _attr_frag, _attr_own010, _attr_own);
             _attr_iter := merged_result.fetch(0);
             _attr_qn   := merged_result.fetch(1);
             _attr_prop := merged_result.fetch(2);
             _attr_frag := merged_result.fetch(3);
             _attr_own  := merged_result.fetch(4);
             _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
             _attr_own := _attr_own.tmark(0@0);
            }
           } # combine element nodes
           # end of translateSeq_node (f, counter)
          } # end of deleteResult_node10 ()
          # translateSeq_node (f, counter)
          if (_r_attr_iter.count() = 0) {
           _r_attr_iter := _r_attr_iter009;
           _r_attr_qn := _r_attr_qn009;
           _r_attr_prop := _r_attr_prop009;
           _r_attr_frag := _r_attr_frag009;
          } else {
           if (_r_attr_iter009.count() != 0) 
           { # combine attribute roots
            var merged_result := merged_union (_r_attr_iter009.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn009, _r_attr_qn, _r_attr_prop009, _r_attr_prop, _r_attr_frag009, _r_attr_frag);
            _r_attr_iter := merged_result.fetch(0);
            _r_attr_qn := merged_result.fetch(1);
            _r_attr_prop := merged_result.fetch(2);
            _r_attr_frag := merged_result.fetch(3);
           }
          } # end of combine attribute roots
          if (_elem_iter.count() = 0) {
           _elem_iter  := _elem_iter009  ;
           _elem_size  := _elem_size009  ;
           _elem_level := _elem_level009 ;
           _elem_kind  := _elem_kind009  ;
           _elem_prop  := _elem_prop009  ;
           _elem_frag  := _elem_frag009  ;
           _attr_iter  := _attr_iter009  ;
           _attr_qn    := _attr_qn009    ;
           _attr_prop  := _attr_prop009  ;
           _attr_frag  := _attr_frag009  ;
           _attr_own   := _attr_own009   ;
          } else {
           if (_elem_iter009.count() != 0) 
           { # combine element nodes
            var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
            var shift_factor := int(seqb) - int(_elem_size009.seqbase());
            var merged_result := merged_union (_elem_iter009.chk_order(), _elem_iter.chk_order(), _elem_size009, _elem_size, _elem_level009, _elem_level, _elem_kind009, _elem_kind, _elem_prop009, _elem_prop, _elem_frag009, _elem_frag, _elem_size009.mark(seqb), _elem_size.mirror());
            _elem_iter := merged_result.fetch(0);
            _elem_size := merged_result.fetch(1);
            _elem_level:= merged_result.fetch(2);
            _elem_kind := merged_result.fetch(3);
            _elem_prop := merged_result.fetch(4);
            _elem_frag := merged_result.fetch(5);
            var preNew_preOld := merged_result.fetch(6);
            _attr_own009 := _attr_own009.[int]().[+](shift_factor).[oid]();
            merged_result := merged_union (_attr_iter009, _attr_iter, _attr_qn009, _attr_qn, _attr_prop009, _attr_prop, _attr_frag009, _attr_frag, _attr_own009, _attr_own);
            _attr_iter := merged_result.fetch(0);
            _attr_qn   := merged_result.fetch(1);
            _attr_prop := merged_result.fetch(2);
            _attr_frag := merged_result.fetch(3);
            _attr_own  := merged_result.fetch(4);
            _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
            _attr_own := _attr_own.tmark(0@0);
           }
          } # combine element nodes
          # end of translateSeq_node (f, counter)
         } # end of deleteResult_node9 ()
         { # loop_liftedElemConstr (counter)
          var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
          iter_size := {count}(iter_size, iter008.tunique(), FALSE);
          var root_iter  := iter_size.hmark(0@0).chk_order();
          var root_size  := iter_size.tmark(0@0);
          var root_prop  := iter008.reverse().leftfetchjoin(item008);
          if (not(is_constant(root_prop))) {
           root_prop  := root_prop.tmark(0@0);
          }
          {
           var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
           _elem_iter  := merged_result.fetch(0);
           _elem_size  := merged_result.fetch(1);
           _elem_level := merged_result.fetch(2);
           _elem_kind  := merged_result.fetch(3);
           _elem_prop  := merged_result.fetch(4);
           _elem_frag  := merged_result.fetch(5);
           var preNew_preOld := merged_result.fetch(6);
           _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
           _attr_own := _attr_own.tmark(0@0);
          }
          { # create attribute root entries
           var root_item := _elem_level.ord_uselect(chr(0));
           root_item := root_item.hmark(0@0);
           var iter_item := iter008.reverse().leftfetchjoin(root_item);
           var attr_own := _r_attr_iter.leftjoin(iter_item);
           if (_r_attr_iter.count() != 0) { # test uniqueness
            var sorting := _r_attr_iter.tsort();
            sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
            var unq_attrs := sorting.tunique();
            if (unq_attrs.count() != _r_attr_iter.count()) {
             item008 := materialize(item008,ipik008);
             if (item008.count() > 0) {
              ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item008.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
             } else {
              ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
             }
            }
           } # end of test uniqueness
           if (_attr_iter.count() = 0) {
            _attr_iter := _r_attr_iter;
            _attr_qn   := _r_attr_qn;
            _attr_prop := _r_attr_prop;
            _attr_frag := _r_attr_frag;
            _attr_own  := attr_own.tmark(0@0);
           } else {
            var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
            _r_attr_iter := _r_attr_iter.tmark(seqb);
            _r_attr_qn   := _r_attr_qn  .tmark(seqb);
            _r_attr_prop := _r_attr_prop.tmark(seqb);
            _r_attr_frag := _r_attr_frag.tmark(seqb);
            attr_own := attr_own.tmark(seqb);
            _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
            _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
            _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
            _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
            _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
           }
           _r_attr_iter := empty_bat;
           _r_attr_qn   := empty_bat;
           _r_attr_prop := empty_bat;
           _r_attr_frag := empty_bat;
          } # end of create attribute root entries
         } # end of loop_liftedElemConstr (counter)
        } # end of deleteResult8 ()
        { # saveResult_node8 () : int
         var _elem_iter008   := _elem_iter  ;
         var _elem_size008   := _elem_size  ;
         var _elem_level008  := _elem_level ;
         var _elem_kind008   := _elem_kind  ;
         var _elem_prop008   := _elem_prop  ;
         var _elem_frag008   := _elem_frag  ;
         var _attr_iter008   := _attr_iter  ;
         var _attr_qn008     := _attr_qn    ;
         var _attr_prop008   := _attr_prop  ;
         var _attr_frag008   := _attr_frag  ;
         var _attr_own008    := _attr_own   ;
         var _r_attr_iter008 := _r_attr_iter;
         var _r_attr_qn008   := _r_attr_qn  ;
         var _r_attr_prop008 := _r_attr_prop;
         var _r_attr_frag008 := _r_attr_frag; # end of saveResult_node8 () : int
         { # tagname-translation
          var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
          var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
          var itemID;
          if (prop_str.texist("cartePaiement")) {
           itemID := prop_str.reverse().find("cartePaiement");
          } else {
           itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
           ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
           ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
           ws.fetch(QN_LOC).fetch(WS).insert(itemID,"cartePaiement");
           ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
           ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"cartePaiement"+str('\1')+"");
          } # translateConst (kind)
          iter := loop002.tmark(0@0);
          ipik := iter;
          item := itemID;
         } # end of tagname-translation
         { # saveResult9 () : int
          var ipik009 := ipik;
          var iter009 := iter;
          var item009 := item; # end of saveResult9 () : int
          { # translateVar (t)
           var vid := v_vid002.ord_uselect(1303761071@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter002);
           item := vid.leftfetchjoin(v_item002);
           kind := vid.leftfetchjoin(v_kind002);
           ipik := iter;
          } # end of translateVar (t)
          { # translateLocsteps (c)
           var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "creditcard");
           iter := res_scj.fetch(0);
           item := res_scj.fetch(1);
           kind := res_scj.fetch(2).set_kind(ELEM);
           ipik := item;
          } # end of translateLocsteps (c)
          { # translateLocsteps (c)
           var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
           iter := res_scj.fetch(0);
           item := res_scj.fetch(1);
           kind := res_scj.fetch(2).set_kind(ELEM);
           ipik := item;
          } # end of translateLocsteps (c)
          { # map2NODE_interface (counter)
           kind := kind.materialize(ipik);
           var attr := kind.get_type(ATTR).hmark(0@0);
           var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
           var attr_item := attr.leftfetchjoin(item);
           var attr_frag := attr.leftfetchjoin(kind).get_fragment();
           _r_attr_iter := attr_iter;
           _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
           _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
           _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
           var nodes := kind.get_type(ELEM);
           if (nodes.count() != 0) {
            var oid_oid := nodes.hmark(0@0);
            var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
            var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
            var iter_input := oid_oid.mirror();
            var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
            var res_iter := res_scj.fetch(0);
            var res_item := res_scj.fetch(1);
            var res_frag := res_scj.fetch(2);
            _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
            _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
            _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
            _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
            _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
            var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
            var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
            nodes := res_item.mark(0@0);
            var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
            root_level := nodes.leftfetchjoin(root_level);
            temp_ec_item := res_item;
            temp_ec_frag := res_frag;
            var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
            content_level := nodes.leftfetchjoin(content_level);
            content_level := content_level.[-](root_level);
            content_level := content_level.tmark(0@0);
            _elem_level := content_level;
            { # create attribute subtree copies
             var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
             var oid_attr := temp_attr.tmark(0@0);
             var oid_frag;
             if (is_constant(res_frag)) {
              oid_frag := res_frag;
             } else {
              oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
              oid_frag := oid_frag.tmark(0@0);
             }
             _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
             _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
             _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
             _attr_own  := temp_attr.hmark(0@0);
             _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
            } # end of create attribute subtree copies
           } else { # if (nodes.count() != 0) ...
            _elem_iter  := empty_bat;
            _elem_size  := empty_bat.project(int(nil));
            _elem_level := empty_bat.project(chr(nil));
            _elem_kind  := empty_bat.project(chr(nil));
            _elem_prop  := empty_bat;
            _elem_frag  := empty_bat;
            _attr_iter  := empty_bat;
            _attr_qn    := empty_bat;
            _attr_prop  := empty_bat;
            _attr_frag  := empty_bat;
            _attr_own   := empty_bat;
           } # end of else in 'if (nodes.count() != 0)'
          } # end of map2NODE_interface (counter)
          if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
           { # saveResult_node10 () : int
            var _elem_iter010   := _elem_iter  ;
            var _elem_size010   := _elem_size  ;
            var _elem_level010  := _elem_level ;
            var _elem_kind010   := _elem_kind  ;
            var _elem_prop010   := _elem_prop  ;
            var _elem_frag010   := _elem_frag  ;
            var _attr_iter010   := _attr_iter  ;
            var _attr_qn010     := _attr_qn    ;
            var _attr_prop010   := _attr_prop  ;
            var _attr_frag010   := _attr_frag  ;
            var _attr_own010    := _attr_own   ;
            var _r_attr_iter010 := _r_attr_iter;
            var _r_attr_qn010   := _r_attr_qn  ;
            var _r_attr_prop010 := _r_attr_prop;
            var _r_attr_frag010 := _r_attr_frag; # end of saveResult_node10 () : int
            _elem_iter := _elem_iter010;
            _elem_level := _elem_level010;
            _elem_kind := _elem_kind010;
            _elem_prop := _elem_prop010;
            _elem_frag := _elem_frag010;
            var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
            rootnodes := rootnodes.leftfetchjoin(_elem_kind);
            var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
            var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
            var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
            {
             var text_prop := textnodes.leftfetchjoin(_elem_prop);
             var text_frag := textnodes.leftfetchjoin(_elem_frag);
             var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
             var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
             var input_order := res_mu_is2ns.fetch(0);
             var input_str := res_mu_is2ns.fetch(1);
             var input_const := res_mu_is2ns.fetch(2);
             var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
             var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
             var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
             var result_order := result_str.hmark(0@0);
             result_order := result_order.leftfetchjoin(input_order);
             result_str := result_str.tmark(0@0);
             iter := result_order;
             ipik := iter;
             item_str_ := result_str;
            }
            { # adding new strings to text node content and create new nodes
             var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
             var unq_str := item_str_.tunique().hmark(0@0);
             var str_unq := reverse(unq_str.tdiff(ws_prop_text));
             var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
             unq_str := str_unq.hmark(seqb);
             ws_prop_text := ws_prop_text.insert(unq_str);
             var ws_text_prop := ws_prop_text.reverse().sort();
             item_str_ := item_str_.materialize(ipik);
             var X_item := item_str_.hmark(0@0);
             var X_strings := item_str_.tmark(0@0).tsort();
             var X_prop := X_strings.leftjoin(ws_text_prop);
             var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
             newPre_prop := newPre_prop.tmark(0@0);
             _elem_iter  := iter;
             _elem_size  := newPre_prop.project(0);
             _elem_level := newPre_prop.project(chr(0));
             _elem_kind  := newPre_prop.project(TEXT);
             _elem_prop  := newPre_prop;
             _elem_frag  := newPre_prop.project(WS);
            } # end of adding new fragments to the WS_FRAG bat
            var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter010), _elem_iter.leftfetchjoin(_elem_iter010), othernodes.leftfetchjoin(_elem_size010), _elem_size, othernodes.leftfetchjoin(_elem_level010), _elem_level, othernodes.leftfetchjoin(_elem_kind010), _elem_kind, othernodes.leftfetchjoin(_elem_prop010), _elem_prop, othernodes.leftfetchjoin(_elem_frag010), _elem_frag, othernodes.leftfetchjoin(_elem_iter010.mirror()), oid(nil));
            _elem_iter := res_mu_is2ns.fetch(1).chk_order();
            _elem_size := res_mu_is2ns.fetch(2);
            _elem_level:= res_mu_is2ns.fetch(3);
            _elem_kind := res_mu_is2ns.fetch(4);
            _elem_prop := res_mu_is2ns.fetch(5);
            _elem_frag := res_mu_is2ns.fetch(6);
            var preNew_preOld := res_mu_is2ns.fetch(7);
            _attr_own := _attr_own010.leftjoin(preNew_preOld.reverse());
            _attr_iter   := _attr_iter010  ;
            _attr_qn     := _attr_qn010    ;
            _attr_prop   := _attr_prop010  ;
            _attr_frag   := _attr_frag010  ;
            _r_attr_iter := _r_attr_iter010;
            _r_attr_qn   := _r_attr_qn010  ;
            _r_attr_prop := _r_attr_prop010;
            _r_attr_frag := _r_attr_frag010;
           } # end of deleteResult_node10 ()
          } # end of item-sequence-to-node-sequence
          { # loop_liftedElemConstr (counter)
           var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
           iter_size := {count}(iter_size, iter009.tunique(), FALSE);
           var root_iter  := iter_size.hmark(0@0).chk_order();
           var root_size  := iter_size.tmark(0@0);
           var root_prop  := iter009.reverse().leftfetchjoin(item009);
           if (not(is_constant(root_prop))) {
            root_prop  := root_prop.tmark(0@0);
           }
           {
            var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
            _elem_iter  := merged_result.fetch(0);
            _elem_size  := merged_result.fetch(1);
            _elem_level := merged_result.fetch(2);
            _elem_kind  := merged_result.fetch(3);
            _elem_prop  := merged_result.fetch(4);
            _elem_frag  := merged_result.fetch(5);
            var preNew_preOld := merged_result.fetch(6);
            _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
            _attr_own := _attr_own.tmark(0@0);
           }
           { # create attribute root entries
            var root_item := _elem_level.ord_uselect(chr(0));
            root_item := root_item.hmark(0@0);
            var iter_item := iter009.reverse().leftfetchjoin(root_item);
            var attr_own := _r_attr_iter.leftjoin(iter_item);
            if (_r_attr_iter.count() != 0) { # test uniqueness
             var sorting := _r_attr_iter.tsort();
             sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
             var unq_attrs := sorting.tunique();
             if (unq_attrs.count() != _r_attr_iter.count()) {
              item009 := materialize(item009,ipik009);
              if (item009.count() > 0) {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item009.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
              } else {
               ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
              }
             }
            } # end of test uniqueness
            if (_attr_iter.count() = 0) {
             _attr_iter := _r_attr_iter;
             _attr_qn   := _r_attr_qn;
             _attr_prop := _r_attr_prop;
             _attr_frag := _r_attr_frag;
             _attr_own  := attr_own.tmark(0@0);
            } else {
             var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
             _r_attr_iter := _r_attr_iter.tmark(seqb);
             _r_attr_qn   := _r_attr_qn  .tmark(seqb);
             _r_attr_prop := _r_attr_prop.tmark(seqb);
             _r_attr_frag := _r_attr_frag.tmark(seqb);
             attr_own := attr_own.tmark(seqb);
             _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
             _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
             _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
             _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
             _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
            }
            _r_attr_iter := empty_bat;
            _r_attr_qn   := empty_bat;
            _r_attr_prop := empty_bat;
            _r_attr_frag := empty_bat;
           } # end of create attribute root entries
          } # end of loop_liftedElemConstr (counter)
         } # end of deleteResult9 ()
         # translateSeq_node (f, counter)
         if (_r_attr_iter.count() = 0) {
          _r_attr_iter := _r_attr_iter008;
          _r_attr_qn := _r_attr_qn008;
          _r_attr_prop := _r_attr_prop008;
          _r_attr_frag := _r_attr_frag008;
         } else {
          if (_r_attr_iter008.count() != 0) 
          { # combine attribute roots
           var merged_result := merged_union (_r_attr_iter008.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn008, _r_attr_qn, _r_attr_prop008, _r_attr_prop, _r_attr_frag008, _r_attr_frag);
           _r_attr_iter := merged_result.fetch(0);
           _r_attr_qn := merged_result.fetch(1);
           _r_attr_prop := merged_result.fetch(2);
           _r_attr_frag := merged_result.fetch(3);
          }
         } # end of combine attribute roots
         if (_elem_iter.count() = 0) {
          _elem_iter  := _elem_iter008  ;
          _elem_size  := _elem_size008  ;
          _elem_level := _elem_level008 ;
          _elem_kind  := _elem_kind008  ;
          _elem_prop  := _elem_prop008  ;
          _elem_frag  := _elem_frag008  ;
          _attr_iter  := _attr_iter008  ;
          _attr_qn    := _attr_qn008    ;
          _attr_prop  := _attr_prop008  ;
          _attr_frag  := _attr_frag008  ;
          _attr_own   := _attr_own008   ;
         } else {
          if (_elem_iter008.count() != 0) 
          { # combine element nodes
           var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
           var shift_factor := int(seqb) - int(_elem_size008.seqbase());
           var merged_result := merged_union (_elem_iter008.chk_order(), _elem_iter.chk_order(), _elem_size008, _elem_size, _elem_level008, _elem_level, _elem_kind008, _elem_kind, _elem_prop008, _elem_prop, _elem_frag008, _elem_frag, _elem_size008.mark(seqb), _elem_size.mirror());
           _elem_iter := merged_result.fetch(0);
           _elem_size := merged_result.fetch(1);
           _elem_level:= merged_result.fetch(2);
           _elem_kind := merged_result.fetch(3);
           _elem_prop := merged_result.fetch(4);
           _elem_frag := merged_result.fetch(5);
           var preNew_preOld := merged_result.fetch(6);
           _attr_own008 := _attr_own008.[int]().[+](shift_factor).[oid]();
           merged_result := merged_union (_attr_iter008, _attr_iter, _attr_qn008, _attr_qn, _attr_prop008, _attr_prop, _attr_frag008, _attr_frag, _attr_own008, _attr_own);
           _attr_iter := merged_result.fetch(0);
           _attr_qn   := merged_result.fetch(1);
           _attr_prop := merged_result.fetch(2);
           _attr_frag := merged_result.fetch(3);
           _attr_own  := merged_result.fetch(4);
           _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
           _attr_own := _attr_own.tmark(0@0);
          }
         } # combine element nodes
         # end of translateSeq_node (f, counter)
        } # end of deleteResult_node8 ()
        # translateSeq_node (f, counter)
        if (_r_attr_iter.count() = 0) {
         _r_attr_iter := _r_attr_iter007;
         _r_attr_qn := _r_attr_qn007;
         _r_attr_prop := _r_attr_prop007;
         _r_attr_frag := _r_attr_frag007;
        } else {
         if (_r_attr_iter007.count() != 0) 
         { # combine attribute roots
          var merged_result := merged_union (_r_attr_iter007.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn007, _r_attr_qn, _r_attr_prop007, _r_attr_prop, _r_attr_frag007, _r_attr_frag);
          _r_attr_iter := merged_result.fetch(0);
          _r_attr_qn := merged_result.fetch(1);
          _r_attr_prop := merged_result.fetch(2);
          _r_attr_frag := merged_result.fetch(3);
         }
        } # end of combine attribute roots
        if (_elem_iter.count() = 0) {
         _elem_iter  := _elem_iter007  ;
         _elem_size  := _elem_size007  ;
         _elem_level := _elem_level007 ;
         _elem_kind  := _elem_kind007  ;
         _elem_prop  := _elem_prop007  ;
         _elem_frag  := _elem_frag007  ;
         _attr_iter  := _attr_iter007  ;
         _attr_qn    := _attr_qn007    ;
         _attr_prop  := _attr_prop007  ;
         _attr_frag  := _attr_frag007  ;
         _attr_own   := _attr_own007   ;
        } else {
         if (_elem_iter007.count() != 0) 
         { # combine element nodes
          var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
          var shift_factor := int(seqb) - int(_elem_size007.seqbase());
          var merged_result := merged_union (_elem_iter007.chk_order(), _elem_iter.chk_order(), _elem_size007, _elem_size, _elem_level007, _elem_level, _elem_kind007, _elem_kind, _elem_prop007, _elem_prop, _elem_frag007, _elem_frag, _elem_size007.mark(seqb), _elem_size.mirror());
          _elem_iter := merged_result.fetch(0);
          _elem_size := merged_result.fetch(1);
          _elem_level:= merged_result.fetch(2);
          _elem_kind := merged_result.fetch(3);
          _elem_prop := merged_result.fetch(4);
          _elem_frag := merged_result.fetch(5);
          var preNew_preOld := merged_result.fetch(6);
          _attr_own007 := _attr_own007.[int]().[+](shift_factor).[oid]();
          merged_result := merged_union (_attr_iter007, _attr_iter, _attr_qn007, _attr_qn, _attr_prop007, _attr_prop, _attr_frag007, _attr_frag, _attr_own007, _attr_own);
          _attr_iter := merged_result.fetch(0);
          _attr_qn   := merged_result.fetch(1);
          _attr_prop := merged_result.fetch(2);
          _attr_frag := merged_result.fetch(3);
          _attr_own  := merged_result.fetch(4);
          _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
          _attr_own := _attr_own.tmark(0@0);
         }
        } # combine element nodes
        # end of translateSeq_node (f, counter)
       } # end of deleteResult_node7 ()
       { # loop_liftedElemConstr (counter)
        var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
        iter_size := {count}(iter_size, iter006.tunique(), FALSE);
        var root_iter  := iter_size.hmark(0@0).chk_order();
        var root_size  := iter_size.tmark(0@0);
        var root_prop  := iter006.reverse().leftfetchjoin(item006);
        if (not(is_constant(root_prop))) {
         root_prop  := root_prop.tmark(0@0);
        }
        {
         var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
         _elem_size  := merged_result.fetch(1);
         _elem_level := merged_result.fetch(2);
         _elem_kind  := merged_result.fetch(3);
         _elem_prop  := merged_result.fetch(4);
         _elem_frag  := merged_result.fetch(5);
         var preNew_preOld := merged_result.fetch(6);
         _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
         _attr_own := _attr_own.tmark(0@0);
        }
        { # create attribute root entries
         var root_item := _elem_level.ord_uselect(chr(0));
         root_item := root_item.hmark(0@0);
         var iter_item := iter006.reverse().leftfetchjoin(root_item);
         var attr_own := _r_attr_iter.leftjoin(iter_item);
         if (_r_attr_iter.count() != 0) { # test uniqueness
          var sorting := _r_attr_iter.tsort();
          sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
          var unq_attrs := sorting.tunique();
          if (unq_attrs.count() != _r_attr_iter.count()) {
           item006 := materialize(item006,ipik006);
           if (item006.count() > 0) {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item006.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
           } else {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
          }
         } # end of test uniqueness
         if (_attr_iter.count() = 0) {
          _attr_qn   := _r_attr_qn;
          _attr_prop := _r_attr_prop;
          _attr_frag := _r_attr_frag;
          _attr_own  := attr_own.tmark(0@0);
         } else {
          var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
          _r_attr_qn   := _r_attr_qn  .tmark(seqb);
          _r_attr_prop := _r_attr_prop.tmark(seqb);
          _r_attr_frag := _r_attr_frag.tmark(seqb);
          attr_own := attr_own.tmark(seqb);
          _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
          _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
          _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
          _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
         }
        } # end of create attribute root entries
        {
         var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
         var preOld_preNew := _elem_size.mark(seqb);
         _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
         _elem_size  := _elem_size.tmark(seqb);
         _elem_level := _elem_level.tmark(seqb);
         _elem_kind  := _elem_kind.tmark(seqb);
         _elem_prop  := _elem_prop.tmark(seqb);
         _elem_frag  := _elem_frag.tmark(seqb);
        }
        ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
        ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
        ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
        ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
        ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
        {
         var knd := ELEMENT;
         while ( knd <= DOCUMENT ) {
          var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
          ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
          if ( knd = ELEMENT ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
          }
          if ( knd = PI ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
          }
          knd :+= chr(1);
         }
        }
        var roots := _elem_level.ord_uselect(chr(0));
        roots := roots.hmark(0@0);
        {
         var height := int(_elem_level.max());
         ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
        }
        { # adding new fragments to the WS_FRAG bat
         var seqb := oid(count(ws.fetch(WS_FRAG)));
         var new_pres := roots.tmark(seqb);
         ws.fetch(WS_FRAG).insert(new_pres);
        }
        iter := iter006;
        item := roots;
        ipik := item;
        kind := ELEM;
        { # add attribute subtree copies to WS
         var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
         _attr_qn   := _attr_qn  .tmark(seqb);
         _attr_prop := _attr_prop.tmark(seqb);
         _attr_own  := _attr_own .tmark(seqb);
         _attr_frag := _attr_frag.tmark(seqb);
         ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
         ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
         ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
         ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
        } # end of add attribute subtree copies to WS
       } # end of loop_liftedElemConstr (counter)
      } # end of deleteResult6 ()
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
    } # end of evaluate_join
    { # map2NODE_interface (counter)
     kind := kind.materialize(ipik);
     var attr := kind.get_type(ATTR).hmark(0@0);
     var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
     var attr_item := attr.leftfetchjoin(item);
     var attr_frag := attr.leftfetchjoin(kind).get_fragment();
     _r_attr_iter := attr_iter;
     _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
     _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
     _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
     var nodes := kind.get_type(ELEM);
     if (nodes.count() != 0) {
      var oid_oid := nodes.hmark(0@0);
      var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
      var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
      var iter_input := oid_oid.mirror();
      var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
      var res_iter := res_scj.fetch(0);
      var res_item := res_scj.fetch(1);
      var res_frag := res_scj.fetch(2);
      _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
      _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
      _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
      _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
      _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
      var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
      var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
      nodes := res_item.mark(0@0);
      var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      root_level := nodes.leftfetchjoin(root_level);
      temp_ec_item := res_item;
      temp_ec_frag := res_frag;
      var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      content_level := nodes.leftfetchjoin(content_level);
      content_level := content_level.[-](root_level);
      content_level := content_level.tmark(0@0);
      _elem_level := content_level;
      { # create attribute subtree copies
       var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
       var oid_attr := temp_attr.tmark(0@0);
       var oid_frag;
       if (is_constant(res_frag)) {
        oid_frag := res_frag;
       } else {
        oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
        oid_frag := oid_frag.tmark(0@0);
       }
       _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
       _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
       _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
       _attr_own  := temp_attr.hmark(0@0);
       _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
      } # end of create attribute subtree copies
     } else { # if (nodes.count() != 0) ...
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of else in 'if (nodes.count() != 0)'
    } # end of map2NODE_interface (counter)
    # translateSeq_node (f, counter)
    if (_r_attr_iter.count() = 0) {
     _r_attr_iter := _r_attr_iter002;
     _r_attr_qn := _r_attr_qn002;
     _r_attr_prop := _r_attr_prop002;
     _r_attr_frag := _r_attr_frag002;
    } else {
     if (_r_attr_iter002.count() != 0) 
     { # combine attribute roots
      var merged_result := merged_union (_r_attr_iter002.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn002, _r_attr_qn, _r_attr_prop002, _r_attr_prop, _r_attr_frag002, _r_attr_frag);
      _r_attr_iter := merged_result.fetch(0);
      _r_attr_qn := merged_result.fetch(1);
      _r_attr_prop := merged_result.fetch(2);
      _r_attr_frag := merged_result.fetch(3);
     }
    } # end of combine attribute roots
    if (_elem_iter.count() = 0) {
     _elem_iter  := _elem_iter002  ;
     _elem_size  := _elem_size002  ;
     _elem_level := _elem_level002 ;
     _elem_kind  := _elem_kind002  ;
     _elem_prop  := _elem_prop002  ;
     _elem_frag  := _elem_frag002  ;
     _attr_iter  := _attr_iter002  ;
     _attr_qn    := _attr_qn002    ;
     _attr_prop  := _attr_prop002  ;
     _attr_frag  := _attr_frag002  ;
     _attr_own   := _attr_own002   ;
    } else {
     if (_elem_iter002.count() != 0) 
     { # combine element nodes
      var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
      var shift_factor := int(seqb) - int(_elem_size002.seqbase());
      var merged_result := merged_union (_elem_iter002.chk_order(), _elem_iter.chk_order(), _elem_size002, _elem_size, _elem_level002, _elem_level, _elem_kind002, _elem_kind, _elem_prop002, _elem_prop, _elem_frag002, _elem_frag, _elem_size002.mark(seqb), _elem_size.mirror());
      _elem_iter := merged_result.fetch(0);
      _elem_size := merged_result.fetch(1);
      _elem_level:= merged_result.fetch(2);
      _elem_kind := merged_result.fetch(3);
      _elem_prop := merged_result.fetch(4);
      _elem_frag := merged_result.fetch(5);
      var preNew_preOld := merged_result.fetch(6);
      _attr_own002 := _attr_own002.[int]().[+](shift_factor).[oid]();
      merged_result := merged_union (_attr_iter002, _attr_iter, _attr_qn002, _attr_qn, _attr_prop002, _attr_prop, _attr_frag002, _attr_frag, _attr_own002, _attr_own);
      _attr_iter := merged_result.fetch(0);
      _attr_qn   := merged_result.fetch(1);
      _attr_prop := merged_result.fetch(2);
      _attr_frag := merged_result.fetch(3);
      _attr_own  := merged_result.fetch(4);
      _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
      _attr_own := _attr_own.tmark(0@0);
     }
    } # combine element nodes
    # end of translateSeq_node (f, counter)
   } # end of deleteResult_node2 ()
   if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
    { # saveResult_node2 () : int
     var _elem_iter002   := _elem_iter  ;
     var _elem_size002   := _elem_size  ;
     var _elem_level002  := _elem_level ;
     var _elem_kind002   := _elem_kind  ;
     var _elem_prop002   := _elem_prop  ;
     var _elem_frag002   := _elem_frag  ;
     var _attr_iter002   := _attr_iter  ;
     var _attr_qn002     := _attr_qn    ;
     var _attr_prop002   := _attr_prop  ;
     var _attr_frag002   := _attr_frag  ;
     var _attr_own002    := _attr_own   ;
     var _r_attr_iter002 := _r_attr_iter;
     var _r_attr_qn002   := _r_attr_qn  ;
     var _r_attr_prop002 := _r_attr_prop;
     var _r_attr_frag002 := _r_attr_frag; # end of saveResult_node2 () : int
     _elem_iter := _elem_iter002;
     _elem_level := _elem_level002;
     _elem_kind := _elem_kind002;
     _elem_prop := _elem_prop002;
     _elem_frag := _elem_frag002;
     var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
     rootnodes := rootnodes.leftfetchjoin(_elem_kind);
     var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
     var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
     var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
     {
      var text_prop := textnodes.leftfetchjoin(_elem_prop);
      var text_frag := textnodes.leftfetchjoin(_elem_frag);
      var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
      var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
      var input_order := res_mu_is2ns.fetch(0);
      var input_str := res_mu_is2ns.fetch(1);
      var input_const := res_mu_is2ns.fetch(2);
      var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
      var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
      var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
      var result_order := result_str.hmark(0@0);
      result_order := result_order.leftfetchjoin(input_order);
      result_str := result_str.tmark(0@0);
      iter := result_order;
      ipik := iter;
      item_str_ := result_str;
     }
     { # adding new strings to text node content and create new nodes
      var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
      var unq_str := item_str_.tunique().hmark(0@0);
      var str_unq := reverse(unq_str.tdiff(ws_prop_text));
      var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
      unq_str := str_unq.hmark(seqb);
      ws_prop_text := ws_prop_text.insert(unq_str);
      var ws_text_prop := ws_prop_text.reverse().sort();
      item_str_ := item_str_.materialize(ipik);
      var X_item := item_str_.hmark(0@0);
      var X_strings := item_str_.tmark(0@0).tsort();
      var X_prop := X_strings.leftjoin(ws_text_prop);
      var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
      newPre_prop := newPre_prop.tmark(0@0);
      _elem_iter  := iter;
      _elem_size  := newPre_prop.project(0);
      _elem_level := newPre_prop.project(chr(0));
      _elem_kind  := newPre_prop.project(TEXT);
      _elem_prop  := newPre_prop;
      _elem_frag  := newPre_prop.project(WS);
     } # end of adding new fragments to the WS_FRAG bat
     var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter002), _elem_iter.leftfetchjoin(_elem_iter002), othernodes.leftfetchjoin(_elem_size002), _elem_size, othernodes.leftfetchjoin(_elem_level002), _elem_level, othernodes.leftfetchjoin(_elem_kind002), _elem_kind, othernodes.leftfetchjoin(_elem_prop002), _elem_prop, othernodes.leftfetchjoin(_elem_frag002), _elem_frag, othernodes.leftfetchjoin(_elem_iter002.mirror()), oid(nil));
     _elem_iter := res_mu_is2ns.fetch(1).chk_order();
     _elem_size := res_mu_is2ns.fetch(2);
     _elem_level:= res_mu_is2ns.fetch(3);
     _elem_kind := res_mu_is2ns.fetch(4);
     _elem_prop := res_mu_is2ns.fetch(5);
     _elem_frag := res_mu_is2ns.fetch(6);
     var preNew_preOld := res_mu_is2ns.fetch(7);
     _attr_own := _attr_own002.leftjoin(preNew_preOld.reverse());
     _attr_iter   := _attr_iter002  ;
     _attr_qn     := _attr_qn002    ;
     _attr_prop   := _attr_prop002  ;
     _attr_frag   := _attr_frag002  ;
     _r_attr_iter := _r_attr_iter002;
     _r_attr_qn   := _r_attr_qn002  ;
     _r_attr_prop := _r_attr_prop002;
     _r_attr_frag := _r_attr_frag002;
    } # end of deleteResult_node2 ()
   } # end of item-sequence-to-node-sequence
   { # loop_liftedElemConstr (counter)
    var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
    iter_size := {count}(iter_size, iter001.tunique(), FALSE);
    var root_iter  := iter_size.hmark(0@0).chk_order();
    var root_size  := iter_size.tmark(0@0);
    var root_prop  := iter001.reverse().leftfetchjoin(item001);
    if (not(is_constant(root_prop))) {
     root_prop  := root_prop.tmark(0@0);
    }
    {
     var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
     _elem_iter  := merged_result.fetch(0);
     _elem_size  := merged_result.fetch(1);
     _elem_level := merged_result.fetch(2);
     _elem_kind  := merged_result.fetch(3);
     _elem_prop  := merged_result.fetch(4);
     _elem_frag  := merged_result.fetch(5);
     var preNew_preOld := merged_result.fetch(6);
     _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
     _attr_own := _attr_own.tmark(0@0);
    }
    { # create attribute root entries
     var root_item := _elem_level.ord_uselect(chr(0));
     root_item := root_item.hmark(0@0);
     var iter_item := iter001.reverse().leftfetchjoin(root_item);
     var attr_own := _r_attr_iter.leftjoin(iter_item);
     if (_r_attr_iter.count() != 0) { # test uniqueness
      var sorting := _r_attr_iter.tsort();
      sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
      var unq_attrs := sorting.tunique();
      if (unq_attrs.count() != _r_attr_iter.count()) {
       item001 := materialize(item001,ipik001);
       if (item001.count() > 0) {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item001.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
       } else {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
       }
      }
     } # end of test uniqueness
     if (_attr_iter.count() = 0) {
      _attr_iter := _r_attr_iter;
      _attr_qn   := _r_attr_qn;
      _attr_prop := _r_attr_prop;
      _attr_frag := _r_attr_frag;
      _attr_own  := attr_own.tmark(0@0);
     } else {
      var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
      _r_attr_iter := _r_attr_iter.tmark(seqb);
      _r_attr_qn   := _r_attr_qn  .tmark(seqb);
      _r_attr_prop := _r_attr_prop.tmark(seqb);
      _r_attr_frag := _r_attr_frag.tmark(seqb);
      attr_own := attr_own.tmark(seqb);
      _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
      _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
      _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
      _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
      _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
     }
     _r_attr_iter := empty_bat;
     _r_attr_qn   := empty_bat;
     _r_attr_prop := empty_bat;
     _r_attr_frag := empty_bat;
    } # end of create attribute root entries
    {
     var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
     var preOld_preNew := _elem_size.mark(seqb);
     _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
     _elem_size  := _elem_size.tmark(seqb);
     _elem_level := _elem_level.tmark(seqb);
     _elem_kind  := _elem_kind.tmark(seqb);
     _elem_prop  := _elem_prop.tmark(seqb);
     _elem_frag  := _elem_frag.tmark(seqb);
    }
    ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
    ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
    ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
    ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
    ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
    {
     var knd := ELEMENT;
     while ( knd <= DOCUMENT ) {
      var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
      ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
      if ( knd = ELEMENT ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
      }
      if ( knd = PI ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
      }
      knd :+= chr(1);
     }
    }
    var roots := _elem_level.ord_uselect(chr(0));
    roots := roots.hmark(0@0);
    {
     var height := int(_elem_level.max());
     ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
    }
    { # adding new fragments to the WS_FRAG bat
     var seqb := oid(count(ws.fetch(WS_FRAG)));
     var new_pres := roots.tmark(seqb);
     ws.fetch(WS_FRAG).insert(new_pres);
    }
    iter := iter001;
    item := roots;
    kind := ELEM;
    { # add attribute subtree copies to WS
     var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
     _attr_qn   := _attr_qn  .tmark(seqb);
     _attr_prop := _attr_prop.tmark(seqb);
     _attr_own  := _attr_own .tmark(seqb);
     _attr_frag := _attr_frag.tmark(seqb);
     ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
     ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
     ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
     ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
    } # end of add attribute subtree copies to WS
   } # end of loop_liftedElemConstr (counter)
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn678385B6_q10_xs_string1
PROC fnD173AF7F_q11_xs_string1_xs_integer1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q11
 var iter;
 var item;
 var kind ;
 var ipik;
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761074@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # insertVar (vid)
  var vid := project(ipik,1303761076@0);
  { # append (vid, level)
   var seqb := oid(v_vid000.count());
   vid := vid.materialize(ipik);
   v_vid000 := v_vid000.insert(vid.tmark(seqb));
  } # append (vid, level)
  { # append (iter, level)
   var seqb := oid(v_iter000.count());
   iter := iter.materialize(ipik);
   v_iter000 := v_iter000.insert(iter.tmark(seqb));
  } # append (iter, level)
  { # append (pos, level)
   var seqb ;
  } # append (pos, level)
  { # append (item, level)
   var seqb := oid(v_item000.count());
   item := item.materialize(ipik);
   v_item000 := v_item000.insert(item.tmark(seqb));
  } # append (item, level)
  { # append (kind, level)
   var seqb := oid(v_kind000.count());
   kind := kind.materialize(ipik);
   v_kind000 := v_kind000.insert(kind.tmark(seqb));
  } # append (kind, level)
 } # end of insertVar (vid)
 { # translateVar (auction)
  var vid := v_vid000.ord_uselect(1303761076@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  kind := vid.leftfetchjoin(v_kind000);
  ipik := iter;
 } # end of translateVar (auction)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "person");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761052@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos ;
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761077@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb ;
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # tagname-translation
   var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
   var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
   var itemID;
   if (prop_str.texist("items")) {
    itemID := prop_str.reverse().find("items");
   } else {
    itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
    ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
    ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
    ws.fetch(QN_LOC).fetch(WS).insert(itemID,"items");
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
    ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"items"+str('\1')+"");
   } # translateConst (kind)
   iter := loop001.tmark(0@0);
   ipik := iter;
   item := itemID;
  } # end of tagname-translation
  { # saveResult1 () : int
   var ipik001 := ipik;
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # tagname-translation
    var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
    var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    var itemID;
    if (prop_str.texist("name")) {
     itemID := prop_str.reverse().find("name");
    } else {
     itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
     ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
     ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
     ws.fetch(QN_LOC).fetch(WS).insert(itemID,"name");
     ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
     ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"name"+str('\1')+"");
    } # translateConst (kind)
    iter := loop001.tmark(0@0);
    ipik := iter;
    item := itemID;
   } # end of tagname-translation
   { # saveResult2 () : int
    var ipik002 := ipik;
    var iter002 := iter;
    var item002 := item; # end of saveResult2 () : int
    { # translateVar (p)
     var vid := v_vid001.ord_uselect(1303761077@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (p)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    if (ipik.count() != 0) 
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer002 := iter;
     iter := iter.mark(1@0);
     var inner002 := iter;
     var v_vid002;
     var v_iter002;
     var v_item002;
     var v_kind002;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(1303761053@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid001.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos ;
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     } else { # createNewVarTable ()
      v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,1303761078@0);
      { # append (vid, level)
       var seqb := oid(v_vid002.count());
       vid := vid.materialize(ipik);
       v_vid002 := v_vid002.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter002.count());
       iter := iter.materialize(ipik);
       v_iter002 := v_iter002.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb ;
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item002.count());
       item := item.materialize(ipik);
       v_item002 := v_item002.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb := oid(v_kind002.count());
       kind := kind.materialize(ipik);
       v_kind002 := v_kind002.insert(kind.tmark(seqb));
      } # append (kind, level)
     } # end of insertVar (vid)
     { # translateVar (#pf:v_1666)
      var vid := v_vid002.ord_uselect(1303761078@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter002);
      item := vid.leftfetchjoin(v_item002);
      kind := vid.leftfetchjoin(v_kind002);
      ipik := iter;
     } # end of translateVar (#pf:v_1666)
     { # string-value
      var input_iter := iter;
      kind := kind.materialize(ipik);
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      var kind_elem := kind.get_type(ELEM);
      var item_str;
      if (kind_elem.count() = kind.count()) {
       var frag := kind.get_fragment();
       var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
       var t_iter := res_scj.fetch(0);
       var t_item := res_scj.fetch(1);
       var t_frag := res_scj.fetch(2);
       var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var t_iter_unq := t_iter.tunique();
       t_iter := t_iter.materialize(t_item);
       if (t_iter_unq.count() != t_item.count()) {
        var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
        iter_item := iter_item.string_join(t_iter_unq.project(""));
        t_iter := iter_item.hmark(0@0);
        t_item_str := iter_item.tmark(0@0);
       }
       var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
       if (c_map.count() > 0) { #process comments 
        var c_iter := c_map.leftfetchjoin(iter);
        var c_item := c_map.leftfetchjoin(item);
        var c_frag := c_map.leftfetchjoin(frag);
        var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
        var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of comment processing
       var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
       if (pi_map.count() > 0) { #process processing-instructions 
        var pi_iter := pi_map.leftfetchjoin(iter);
        var pi_item := pi_map.leftfetchjoin(item);
        var pi_frag := pi_map.leftfetchjoin(frag);
        var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
        var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
        t_item_str := res_mu.fetch(1);
       } # end of processing-instruction processing
       iter := t_iter;
       item_str := t_item_str;
      } else {
       var kind_attr := kind.get_type(ATTR);
       if (kind_attr.count() = kind.count()) {
        var frag := kind.get_fragment();
        item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
       } else {
        kind_attr := kind_attr.hmark(0@0);
        var item_attr := kind_attr.leftfetchjoin(item);
        var iter_attr := kind_attr.leftfetchjoin(iter);
        var frag := kind_attr.leftfetchjoin(kind).get_fragment();
        var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        kind_elem := kind_elem.hmark(0@0);
        iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
        frag := kind_elem.leftfetchjoin(kind).get_fragment();
        item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
        t_iter := iter_item.hmark(0@0);
        t_item_str := iter_item.tmark(0@0);
        var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
        iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
        {
         var item_unq := iter_item.reverse().tunique();
         if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
        }
        t_iter := iter_item.hmark(0@0);
        var t_item_str := iter_item.tmark(0@0);
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       }
      }
      item_str_ := item_str;
      if (iter.count() != input_iter.tunique().count()) {
       var difference := reverse(input_iter.tdiff(iter));
       difference := difference.hmark(0@0);
       var res_mu := merged_union(iter, difference, item_str_, "");
       iter := res_mu.fetch(0);
       item_str_ := res_mu.fetch(1);
      }
      ipik := iter;
     } # end of string-value
     { # mapBack ()
      var iter_oidMap := inner002.reverse();
      var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
      iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
      # kind := kind;
      # ipik := ipik;
     } # end of mapBack ()
     # cleanUpLevel ()
    } # end of for-translation
    { # saveResult3 () : int
     var ipik003 := ipik;
     var iter003 := iter;
     var item_str_003 := item_str_; # end of saveResult3 () : int
     iter := loop001.tmark(0@0);
     ipik := iter;
     item_str_ := " ";
     { # string-join (string*, string)
      var iter_item_str := iter003.materialize(ipik003).reverse();
      iter_item_str := iter_item_str.leftfetchjoin(item_str_003).materialize(iter_item_str).chk_order();
      var iter_sep_str := iter.materialize(ipik).reverse();
      iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
      iter_item_str := string_join(iter_item_str, iter_sep_str);
      iter := iter_item_str.hmark(0@0);
      iter_item_str := iter_item_str.tmark(0@0);
      item_str_ := iter_item_str;
     } # end of string-join (string*, string)
    } # end of deleteResult3 ()
    { # loop_liftedAttrConstr (int i)
     if (iter002.count() != loop001.count()) {
      ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
     }
     if (iter.count() != loop001.count()) {
      var difference := reverse(loop001.tdiff(iter));
      difference := difference.hmark(0@0);
      var res_mu := merged_union(iter, difference, item_str_, "");
      item_str_ := res_mu.fetch(1);
     }
     var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
     var unq := item_str_.tunique().hmark(0@0);
     var unq_str := unq;
     var str_unq := reverse(unq_str.tdiff(ws_prop_val));
     var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
     unq_str := str_unq.hmark(seqb);
     ws_prop_val := ws_prop_val.insert(unq_str);
     var strings := item_str_.materialize(loop001);
     var attr_oid := strings.leftjoin(ws_prop_val.reverse());
     { # translateEmpty_node ()
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of translateEmpty_node ()
     attr_oid := attr_oid.tmark(0@0);
     _r_attr_iter := iter002;
     _r_attr_qn   := item002.materialize(ipik002);
     _r_attr_prop := attr_oid;
     _r_attr_frag := attr_oid.project(WS);
    } # end of loop_liftedAttrConstr (int i)
   } # end of deleteResult2 ()
   { # saveResult_node2 () : int
    var _elem_iter002   := _elem_iter  ;
    var _elem_size002   := _elem_size  ;
    var _elem_level002  := _elem_level ;
    var _elem_kind002   := _elem_kind  ;
    var _elem_prop002   := _elem_prop  ;
    var _elem_frag002   := _elem_frag  ;
    var _attr_iter002   := _attr_iter  ;
    var _attr_qn002     := _attr_qn    ;
    var _attr_prop002   := _attr_prop  ;
    var _attr_frag002   := _attr_frag  ;
    var _attr_own002    := _attr_own   ;
    var _r_attr_iter002 := _r_attr_iter;
    var _r_attr_qn002   := _r_attr_qn  ;
    var _r_attr_prop002 := _r_attr_prop;
    var _r_attr_frag002 := _r_attr_frag; # end of saveResult_node2 () : int
    {
     var iter003;
     var item003;
     var kind003;
     var ipik004;
     var iter004;
     var item004;
     var match_outer004;
     var ipik005;
     var iter005;
     var item005;
     var match_outer005;
     var jouter004 ;
     var jorder_004 ;
     var jinner004 ;
     var jloop004  ;
     var jv_vid004 ;
     var jv_iter004;
     var jv_pos004 ;
     var jv_item004;
     var jv_kind004;
     { # translateVar (p)
      var vid := v_vid001.ord_uselect(1303761077@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (p)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "profile");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # loop_liftedSCJ (axis, kind, ns, loc)
      { # attribute axis
       var oid_iter := iter;
       var oid_item := item.materialize(ipik);
       var oid_frag := kind.get_fragment();
       var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
       oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
       var oid_attr := temp1.tmark(0@0);
       oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
       var temp1_str; # only needed for name test
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
       temp1 := temp1_str.ord_uselect("");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
       temp1 := temp1_str.ord_uselect("income");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       iter := oid_iter.tmark(0@0);
       item := oid_attr.tmark(0@0);
       kind := oid_frag.tmark(0@0);
       if (type(iter) = bat) {
        ipik := iter;
       } else {
        if (type(item) = bat) {
         ipik := item;
        } else {
         ipik := kind;
        }
       }
      } # end of attribute axis
      kind := kind.set_kind(ATTR);
     } # end of translateLocsteps (c)
     if (ipik.count() != 0) 
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      var loop002 := inner002;
      var v_vid002;
      var v_iter002;
      var v_item002;
      var v_kind002;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761054@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761079@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (#pf:v_2816)
       var vid := v_vid002.ord_uselect(1303761079@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (#pf:v_2816)
      { # string-value
       var input_iter := iter;
       kind := kind.materialize(ipik);
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       var kind_elem := kind.get_type(ELEM);
       var item_str;
       if (kind_elem.count() = kind.count()) {
        var frag := kind.get_fragment();
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var t_iter_unq := t_iter.tunique();
        t_iter := t_iter.materialize(t_item);
        if (t_iter_unq.count() != t_item.count()) {
         var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         iter_item := iter_item.string_join(t_iter_unq.project(""));
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
        }
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       } else {
        var kind_attr := kind.get_type(ATTR);
        if (kind_attr.count() = kind.count()) {
         var frag := kind.get_fragment();
         item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        } else {
         kind_attr := kind_attr.hmark(0@0);
         var item_attr := kind_attr.leftfetchjoin(item);
         var iter_attr := kind_attr.leftfetchjoin(iter);
         var frag := kind_attr.leftfetchjoin(kind).get_fragment();
         var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         kind_elem := kind_elem.hmark(0@0);
         iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
         frag := kind_elem.leftfetchjoin(kind).get_fragment();
         item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
         var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
         iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         {
          var item_unq := iter_item.reverse().tunique();
          if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
         }
         t_iter := iter_item.hmark(0@0);
         var t_item_str := iter_item.tmark(0@0);
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        }
       }
       item_str_ := item_str;
       if (iter.count() != input_iter.tunique().count()) {
        var difference := reverse(input_iter.tdiff(iter));
        difference := difference.hmark(0@0);
        var res_mu := merged_union(iter, difference, item_str_, "");
        iter := res_mu.fetch(0);
        item_str_ := res_mu.fetch(1);
       }
       ipik := iter;
      } # end of string-value
      { # cast from string to untypedAtomic
       if (iter.count() != loop002.count()) {
        ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
       }
      } # end of cast from string to untypedAtomic
      { # cast from untypedAtomic to double
       var cast_val := item_str_.[dbl]();
       if (cast_val.texist(dbl(nil))) {
        ERROR ("err:FORG0001: could not cast value from string to double.");
       }
       item_dbl_ := cast_val;
       if (iter.count() != loop002.count()) {
        ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
       }
      } # end of cast from untypedAtomic to double
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
     {
      var mapping := outer000.reverse().leftfetchjoin(inner000);
      mapping := mapping.leftjoin(outer001.reverse());
      mapping := mapping.leftfetchjoin(inner001);
      match_outer004 := iter.leftjoin(mapping.reverse()).tmark(iter.seqbase());
     }
     ipik004 := ipik;
     iter004 := iter;
     item004 := item_dbl_;
     jouter004  := outer001 ;
     jinner004  := inner001 ;
     jloop004   := loop001  ;
     v_vid001  := v_vid000 .copy().access(BAT_WRITE);
     v_iter001 := v_iter000.copy().access(BAT_WRITE);
     v_item001 := v_item000.copy().access(BAT_WRITE);
     v_kind001 := v_kind000.copy().access(BAT_WRITE);
     { # translateVar (auction)
      var vid := v_vid001.ord_uselect(1303761076@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (auction)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "initial");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      var loop002 := inner002;
      var v_vid002;
      var v_iter002;
      var v_item002;
      var v_kind002;
      iter003 := iter;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761055@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos ;
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761080@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb ;
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (factor)
       var vid := v_vid002.ord_uselect(1303761075@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
      } # end of translateVar (factor)
      { # cast from integer to double
       var cast_val := item.leftfetchjoin(int_values).[dbl]();
       if (cast_val.texist(dbl(nil))) {
        ERROR ("err:FORG0001: could not cast value from integer to double.");
       }
       item_dbl_ := cast_val;
       if (iter.count() != loop002.count()) {
        ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
       }
      } # end of cast from integer to double
      { # saveResult6 () : int
       var item_dbl_006 := item_dbl_; # end of saveResult6 () : int
       { # translateVar (i)
        var vid := v_vid002.ord_uselect(1303761080@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter002);
        item := vid.leftfetchjoin(v_item002);
        kind := vid.leftfetchjoin(v_kind002);
        ipik := iter;
       } # end of translateVar (i)
       { # translateLocsteps (c)
        var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, TEXT);
        iter := res_scj.fetch(0);
        item := res_scj.fetch(1);
        kind := res_scj.fetch(2).set_kind(ELEM);
        ipik := item;
       } # end of translateLocsteps (c)
       if (iter.tunique().count() != loop002.count()) {
        ERROR ("err:FORG0005: function fn:exactly-one expects exactly one value.");
       }
       { # string-value
        var input_iter := iter;
        kind := kind.materialize(ipik);
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        var kind_elem := kind.get_type(ELEM);
        var item_str;
        if (kind_elem.count() = kind.count()) {
         var frag := kind.get_fragment();
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var t_iter_unq := t_iter.tunique();
         t_iter := t_iter.materialize(t_item);
         if (t_iter_unq.count() != t_item.count()) {
          var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          iter_item := iter_item.string_join(t_iter_unq.project(""));
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
         }
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        } else {
         var kind_attr := kind.get_type(ATTR);
         if (kind_attr.count() = kind.count()) {
          var frag := kind.get_fragment();
          item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         } else {
          kind_attr := kind_attr.hmark(0@0);
          var item_attr := kind_attr.leftfetchjoin(item);
          var iter_attr := kind_attr.leftfetchjoin(iter);
          var frag := kind_attr.leftfetchjoin(kind).get_fragment();
          var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
          kind_elem := kind_elem.hmark(0@0);
          iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
          frag := kind_elem.leftfetchjoin(kind).get_fragment();
          item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
          var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
          var t_iter := res_scj.fetch(0);
          var t_item := res_scj.fetch(1);
          var t_frag := res_scj.fetch(2);
          var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
          var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
          var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
          iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          {
           var item_unq := iter_item.reverse().tunique();
           if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
          }
          t_iter := iter_item.hmark(0@0);
          var t_item_str := iter_item.tmark(0@0);
          var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
          if (c_map.count() > 0) { #process comments 
           var c_iter := c_map.leftfetchjoin(iter);
           var c_item := c_map.leftfetchjoin(item);
           var c_frag := c_map.leftfetchjoin(frag);
           var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
           var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of comment processing
          var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
          if (pi_map.count() > 0) { #process processing-instructions 
           var pi_iter := pi_map.leftfetchjoin(iter);
           var pi_item := pi_map.leftfetchjoin(item);
           var pi_frag := pi_map.leftfetchjoin(frag);
           var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
           var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of processing-instruction processing
          iter := t_iter;
          item_str := t_item_str;
         }
        }
        item_str_ := item_str;
        if (iter.count() != input_iter.tunique().count()) {
         var difference := reverse(input_iter.tdiff(iter));
         difference := difference.hmark(0@0);
         var res_mu := merged_union(iter, difference, item_str_, "");
         iter := res_mu.fetch(0);
         item_str_ := res_mu.fetch(1);
        }
        ipik := iter;
       } # end of string-value
       { # cast from string to double
        var cast_val := item_str_.[dbl]();
        if (cast_val.texist(dbl(nil))) {
         ERROR ("err:FORG0001: could not cast value from string to double.");
        }
        item_dbl_ := cast_val;
        if (iter.count() != loop002.count()) {
         ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
        }
       } # end of cast from string to double
       { # '*' calculation
        var val_snd := item_dbl_;
        var val_fst := item_dbl_006;
        val_fst := [*](val_fst,val_snd);
        item_dbl_ := val_fst;
       } # end of '*' calculation
      } # end of deleteResult6 ()
      ipik005 := ipik;
      iter005 := iter;
      item005 := item_dbl_;
      match_outer005 := iter.leftfetchjoin(inner002.reverse()).leftfetchjoin(outer002); # cleanUpLevel ()
     } # end of for-translation
     outer001  := jouter004 ;
     inner001  := jinner004 ;
     loop001   := jloop004  ;
     var join_item1 := item004;
     var join_item2 := item005;
     join_item1 := join_item1.materialize(ipik004);
     join_item1 := join_item1.reverse().leftfetchjoin(iter004).reverse();
     join_item2 := join_item2.materialize(ipik005);
     join_item2 := join_item2.reverse().leftfetchjoin(iter005).reverse();
     var join_result := ll_htordered_unique_thetajoin(GT, join_item1, join_item2, match_outer004, match_outer005,nil,iter003.reverse());
     var snd_iter ;
     var fst_iter := join_result.hmark(0@0);
     ipik := fst_iter; # order_fst isn't needed until now
     # (cannot be pushed below the theta-join due to the 'iter := fst_iter;' hereafter)
     # var order_fst := fst_iter.leftfetchjoin(inner001.reverse());
     var order_snd ; #.leftfetchjoin(iter003.reverse()); pushed below theta-join
     iter := fst_iter;
    } # end of evaluate_join
    { # translate fn:count (item*) as integer
     iter := iter.materialize(ipik);
     var iter_count := [lng]({count}(iter.reverse(),loop001.reverse(), FALSE)).tmark(0@0);
     item := int_values.addValues(iter_count).tmark(0@0);
     iter := loop001.tmark(0@0);
     ipik := iter;
     kind := INT;
    } # end of translate fn:count (item*) as integer
    { # saveResult3 () : int
     var ipik003 := ipik;
     var iter003 := iter;
     var item003 := item;
     var kind003 := kind; # end of saveResult3 () : int
     { # item-sequence-to-node-sequence
      var nodes_order;
      {
       ipik := ipik003;
       item := item003;
       kind := kind003;
       kind := kind.materialize(ipik);
       var elem := kind.get_type(ELEM);
       elem := elem.hmark(0@0);
       var kind_elem := elem.leftfetchjoin(kind);
       var frag_elem := kind_elem.get_fragment();
       var item_elem := elem.leftfetchjoin(item).materialize(elem);
       var kind_node := mposjoin (item_elem, frag_elem, ws.fetch(PRE_KIND));
       var text := kind_node.ord_uselect(TEXT).hmark(0@0);
       var item_text := text.leftfetchjoin(item_elem);
       var frag_text := text.leftfetchjoin(frag_elem);
       var text_str := mposjoin (mposjoin (item_text, frag_text, ws.fetch(PRE_PROP)), mposjoin (item_text, frag_text, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var str_text := text_str.reverse().leftfetchjoin(text);
       var texts := str_text.leftfetchjoin(elem).reverse();
       var texts_order := texts.hmark(0@0);
       texts := texts.tmark(0@0);
       var nodes := kind_node.[!=](TEXT).ord_uselect(true).project("");
       nodes := nodes.reverse().leftfetchjoin(elem).reverse();
       nodes_order := nodes.hmark(0@0);
       nodes := nodes.tmark(0@0);
       var res_mu_is2ns := merged_union (nodes_order, texts_order, nodes, texts, 0@0, 1@0);
       var input_order := res_mu_is2ns.fetch(0);
       var input_str := res_mu_is2ns.fetch(1);
       var input_const := res_mu_is2ns.fetch(2);
       kind := kind.materialize(ipik);
       var atomic := kind.get_type_atomic();
       atomic := atomic.hmark(0@0);
       item := atomic.leftfetchjoin(item);
       var cast_val := item.leftfetchjoin(int_values).[str]();
       if (cast_val.texist(str(nil))) {
        ERROR ("err:FORG0001: could not cast value from integer to string.");
       }
       item_str_ := cast_val;
       res_mu_is2ns := merged_union (input_order, atomic, input_str, item_str_, input_const, 2@0);
       input_order := res_mu_is2ns.fetch(0);
       input_str := res_mu_is2ns.fetch(1);
       input_const := res_mu_is2ns.fetch(2);
       var input_iter := input_order.leftfetchjoin(iter003).chk_order();
       var result_size := iter003.tunique().count() + nodes_order.count() + 1;
       var result_str := combine_text_string (input_iter.materialize(input_str), input_const.materialize(input_str), input_str, result_size);
       var result_order := result_str.hmark(0@0);
       result_order := result_order.leftfetchjoin(input_order);
       result_str := result_str.tmark(0@0);
       iter := result_order;
       ipik := iter;
       item_str_ := result_str;
      }
      { # adding new strings to text node content and create new nodes
       var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
       var unq_str := item_str_.tunique().hmark(0@0);
       var str_unq := reverse(unq_str.tdiff(ws_prop_text));
       var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
       unq_str := str_unq.hmark(seqb);
       ws_prop_text := ws_prop_text.insert(unq_str);
       var ws_text_prop := ws_prop_text.reverse().sort();
       item_str_ := item_str_.materialize(ipik);
       var X_item := item_str_.hmark(0@0);
       var X_strings := item_str_.tmark(0@0).tsort();
       var X_prop := X_strings.leftjoin(ws_text_prop);
       var newPre_prop := X_item.reverse().leftjoin(X_prop);
       seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS))+ int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
       newPre_prop := newPre_prop.tmark(seqb);
       ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
       ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
       ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
       ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
       ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));
       {
        var kind_pre_ := newPre_prop.hmark(nil).chk_order();
        ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
       }
       item := item_str_.mark(seqb);
       kind := ELEM;
      } # end of adding new strings to text node content and create new nodes
      { # adding new fragments to the WS_FRAG bat
       var seqb := ws.fetch(WS_FRAG).count();
       seqb := oid(seqb);
       var new_pres := item.tmark(seqb);
       ws.fetch(WS_FRAG).insert(new_pres);
       ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
      } # end of adding new fragments to the WS_FRAG bat
      var res_mu_is2ns := merged_union (iter, nodes_order, item, nodes_order.leftfetchjoin(item003), kind, nodes_order.leftfetchjoin(kind003));
      kind003 := kind003.materialize(ipik003);
      var attr := kind003.get_type(ATTR).hmark(0@0);
      var item_attr := attr.leftfetchjoin(item003);
      var kind_attr := attr.leftfetchjoin(kind003);
      res_mu_is2ns := merged_union (res_mu_is2ns.fetch(0), attr, res_mu_is2ns.fetch(1), item_attr, res_mu_is2ns.fetch(2), kind_attr);
      iter := res_mu_is2ns.fetch(0).leftfetchjoin(iter003);
      item := res_mu_is2ns.fetch(1);
      kind := res_mu_is2ns.fetch(2);
      ipik := item;
     } # end of item-sequence-to-node-sequence
    } # end of deleteResult3 ()
    { # map2NODE_interface (counter)
     kind := kind.materialize(ipik);
     var attr := kind.get_type(ATTR).hmark(0@0);
     var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
     var attr_item := attr.leftfetchjoin(item);
     var attr_frag := attr.leftfetchjoin(kind).get_fragment();
     _r_attr_iter := attr_iter;
     _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
     _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
     _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
     var nodes := kind.get_type(ELEM);
     if (nodes.count() != 0) {
      var oid_oid := nodes.hmark(0@0);
      var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
      var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
      var iter_input := oid_oid.mirror();
      var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
      var res_iter := res_scj.fetch(0);
      var res_item := res_scj.fetch(1);
      var res_frag := res_scj.fetch(2);
      _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
      _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
      _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
      _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
      _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
      var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
      var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
      nodes := res_item.mark(0@0);
      var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      root_level := nodes.leftfetchjoin(root_level);
      temp_ec_item := res_item;
      temp_ec_frag := res_frag;
      var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      content_level := nodes.leftfetchjoin(content_level);
      content_level := content_level.[-](root_level);
      content_level := content_level.tmark(0@0);
      _elem_level := content_level;
      { # create attribute subtree copies
       var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
       var oid_attr := temp_attr.tmark(0@0);
       var oid_frag;
       if (is_constant(res_frag)) {
        oid_frag := res_frag;
       } else {
        oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
        oid_frag := oid_frag.tmark(0@0);
       }
       _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
       _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
       _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
       _attr_own  := temp_attr.hmark(0@0);
       _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
      } # end of create attribute subtree copies
     } else { # if (nodes.count() != 0) ...
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of else in 'if (nodes.count() != 0)'
    } # end of map2NODE_interface (counter)
    # translateSeq_node (f, counter)
    if (_r_attr_iter.count() = 0) {
     _r_attr_iter := _r_attr_iter002;
     _r_attr_qn := _r_attr_qn002;
     _r_attr_prop := _r_attr_prop002;
     _r_attr_frag := _r_attr_frag002;
    } else {
     if (_r_attr_iter002.count() != 0) 
     { # combine attribute roots
      var merged_result := merged_union (_r_attr_iter002.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn002, _r_attr_qn, _r_attr_prop002, _r_attr_prop, _r_attr_frag002, _r_attr_frag);
      _r_attr_iter := merged_result.fetch(0);
      _r_attr_qn := merged_result.fetch(1);
      _r_attr_prop := merged_result.fetch(2);
      _r_attr_frag := merged_result.fetch(3);
     }
    } # end of combine attribute roots
    if (_elem_iter.count() = 0) {
     _elem_iter  := _elem_iter002  ;
     _elem_size  := _elem_size002  ;
     _elem_level := _elem_level002 ;
     _elem_kind  := _elem_kind002  ;
     _elem_prop  := _elem_prop002  ;
     _elem_frag  := _elem_frag002  ;
     _attr_iter  := _attr_iter002  ;
     _attr_qn    := _attr_qn002    ;
     _attr_prop  := _attr_prop002  ;
     _attr_frag  := _attr_frag002  ;
     _attr_own   := _attr_own002   ;
    } else {
     if (_elem_iter002.count() != 0) 
     { # combine element nodes
      var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
      var shift_factor := int(seqb) - int(_elem_size002.seqbase());
      var merged_result := merged_union (_elem_iter002.chk_order(), _elem_iter.chk_order(), _elem_size002, _elem_size, _elem_level002, _elem_level, _elem_kind002, _elem_kind, _elem_prop002, _elem_prop, _elem_frag002, _elem_frag, _elem_size002.mark(seqb), _elem_size.mirror());
      _elem_iter := merged_result.fetch(0);
      _elem_size := merged_result.fetch(1);
      _elem_level:= merged_result.fetch(2);
      _elem_kind := merged_result.fetch(3);
      _elem_prop := merged_result.fetch(4);
      _elem_frag := merged_result.fetch(5);
      var preNew_preOld := merged_result.fetch(6);
      _attr_own002 := _attr_own002.[int]().[+](shift_factor).[oid]();
      merged_result := merged_union (_attr_iter002, _attr_iter, _attr_qn002, _attr_qn, _attr_prop002, _attr_prop, _attr_frag002, _attr_frag, _attr_own002, _attr_own);
      _attr_iter := merged_result.fetch(0);
      _attr_qn   := merged_result.fetch(1);
      _attr_prop := merged_result.fetch(2);
      _attr_frag := merged_result.fetch(3);
      _attr_own  := merged_result.fetch(4);
      _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
      _attr_own := _attr_own.tmark(0@0);
     }
    } # combine element nodes
    # end of translateSeq_node (f, counter)
   } # end of deleteResult_node2 ()
   { # loop_liftedElemConstr (counter)
    var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
    iter_size := {count}(iter_size, iter001.tunique(), FALSE);
    var root_iter  := iter_size.hmark(0@0).chk_order();
    var root_size  := iter_size.tmark(0@0);
    var root_prop  := iter001.reverse().leftfetchjoin(item001);
    if (not(is_constant(root_prop))) {
     root_prop  := root_prop.tmark(0@0);
    }
    {
     var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
     _elem_iter  := merged_result.fetch(0);
     _elem_size  := merged_result.fetch(1);
     _elem_level := merged_result.fetch(2);
     _elem_kind  := merged_result.fetch(3);
     _elem_prop  := merged_result.fetch(4);
     _elem_frag  := merged_result.fetch(5);
     var preNew_preOld := merged_result.fetch(6);
     _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
     _attr_own := _attr_own.tmark(0@0);
    }
    { # create attribute root entries
     var root_item := _elem_level.ord_uselect(chr(0));
     root_item := root_item.hmark(0@0);
     var iter_item := iter001.reverse().leftfetchjoin(root_item);
     var attr_own := _r_attr_iter.leftjoin(iter_item);
     if (_r_attr_iter.count() != 0) { # test uniqueness
      var sorting := _r_attr_iter.tsort();
      sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
      var unq_attrs := sorting.tunique();
      if (unq_attrs.count() != _r_attr_iter.count()) {
       item001 := materialize(item001,ipik001);
       if (item001.count() > 0) {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item001.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
       } else {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
       }
      }
     } # end of test uniqueness
     if (_attr_iter.count() = 0) {
      _attr_iter := _r_attr_iter;
      _attr_qn   := _r_attr_qn;
      _attr_prop := _r_attr_prop;
      _attr_frag := _r_attr_frag;
      _attr_own  := attr_own.tmark(0@0);
     } else {
      var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
      _r_attr_iter := _r_attr_iter.tmark(seqb);
      _r_attr_qn   := _r_attr_qn  .tmark(seqb);
      _r_attr_prop := _r_attr_prop.tmark(seqb);
      _r_attr_frag := _r_attr_frag.tmark(seqb);
      attr_own := attr_own.tmark(seqb);
      _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
      _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
      _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
      _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
      _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
     }
     _r_attr_iter := empty_bat;
     _r_attr_qn   := empty_bat;
     _r_attr_prop := empty_bat;
     _r_attr_frag := empty_bat;
    } # end of create attribute root entries
    {
     var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
     var preOld_preNew := _elem_size.mark(seqb);
     _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
     _elem_size  := _elem_size.tmark(seqb);
     _elem_level := _elem_level.tmark(seqb);
     _elem_kind  := _elem_kind.tmark(seqb);
     _elem_prop  := _elem_prop.tmark(seqb);
     _elem_frag  := _elem_frag.tmark(seqb);
    }
    ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
    ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
    ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
    ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
    ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
    {
     var knd := ELEMENT;
     while ( knd <= DOCUMENT ) {
      var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
      ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
      if ( knd = ELEMENT ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
      }
      if ( knd = PI ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
      }
      knd :+= chr(1);
     }
    }
    var roots := _elem_level.ord_uselect(chr(0));
    roots := roots.hmark(0@0);
    {
     var height := int(_elem_level.max());
     ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
    }
    { # adding new fragments to the WS_FRAG bat
     var seqb := oid(count(ws.fetch(WS_FRAG)));
     var new_pres := roots.tmark(seqb);
     ws.fetch(WS_FRAG).insert(new_pres);
    }
    iter := iter001;
    item := roots;
    kind := ELEM;
    { # add attribute subtree copies to WS
     var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
     _attr_qn   := _attr_qn  .tmark(seqb);
     _attr_prop := _attr_prop.tmark(seqb);
     _attr_own  := _attr_own .tmark(seqb);
     _attr_frag := _attr_frag.tmark(seqb);
     ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
     ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
     ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
     ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
    } # end of add attribute subtree copies to WS
   } # end of loop_liftedElemConstr (counter)
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fnD173AF7F_q11_xs_string1_xs_integer1
PROC fn5DFC73FE_q12_xs_string1_xs_integer1_xs_double1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q12
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761081@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  pos := vid.leftfetchjoin(v_pos000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # insertVar (vid)
  var vid := project(ipik,1303761084@0);
  { # append (vid, level)
   var seqb := oid(v_vid000.count());
   vid := vid.materialize(ipik);
   v_vid000 := v_vid000.insert(vid.tmark(seqb));
  } # append (vid, level)
  { # append (iter, level)
   var seqb := oid(v_iter000.count());
   iter := iter.materialize(ipik);
   v_iter000 := v_iter000.insert(iter.tmark(seqb));
  } # append (iter, level)
  { # append (pos, level)
   var seqb := oid(v_pos000.count());
   pos := pos.materialize(ipik);
   v_pos000 := v_pos000.insert(pos.tmark(seqb));
  } # append (pos, level)
  { # append (item, level)
   var seqb := oid(v_item000.count());
   item := item.materialize(ipik);
   v_item000 := v_item000.insert(item.tmark(seqb));
  } # append (item, level)
  { # append (kind, level)
   var seqb := oid(v_kind000.count());
   kind := kind.materialize(ipik);
   v_kind000 := v_kind000.insert(kind.tmark(seqb));
  } # append (kind, level)
 } # end of insertVar (vid)
 { # translateVar (auction)
  var vid := v_vid000.ord_uselect(1303761084@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  kind := vid.leftfetchjoin(v_kind000);
  ipik := iter;
 } # end of translateVar (auction)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "person");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  var order_001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  pos := 1@0;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_pos001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761057@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
   v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761085@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb := oid(v_pos001.count());
    pos := pos.materialize(ipik);
    v_pos001 := v_pos001.insert(pos.tmark(seqb));
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (p)
   var vid := v_vid001.ord_uselect(1303761085@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (p)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "profile");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # loop_liftedSCJ (axis, kind, ns, loc)
   { # attribute axis
    var oid_iter := iter;
    var oid_item := item.materialize(ipik);
    var oid_frag := kind.get_fragment();
    var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
    oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
    var oid_attr := temp1.tmark(0@0);
    oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
    var temp1_str; # only needed for name test
    temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
    temp1 := temp1_str.ord_uselect("");
    temp1 := temp1.hmark(0@0);
    oid_attr := temp1.leftfetchjoin(oid_attr);
    oid_frag := temp1.leftfetchjoin(oid_frag);
    oid_iter := temp1.leftfetchjoin(oid_iter);
    temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
    temp1 := temp1_str.ord_uselect("income");
    temp1 := temp1.hmark(0@0);
    oid_attr := temp1.leftfetchjoin(oid_attr);
    oid_frag := temp1.leftfetchjoin(oid_frag);
    oid_iter := temp1.leftfetchjoin(oid_iter);
    iter := oid_iter.tmark(0@0);
    item := oid_attr.tmark(0@0);
    kind := oid_frag.tmark(0@0);
    if (type(iter) = bat) {
     ipik := iter;
    } else {
     if (type(item) = bat) {
      ipik := item;
     } else {
      ipik := kind;
     }
    }
   } # end of attribute axis
   kind := kind.set_kind(ATTR);
  } # end of translateLocsteps (c)
  if (ipik.count() != 0) 
  { # for-translation
   # project ()
   iter := iter.materialize(ipik);
   var outer002 := iter;
   var order_002 := iter;
   iter := iter.mark(1@0);
   var inner002 := iter;
   pos := 1@0;
   var loop002 := inner002;
   var v_vid002;
   var v_iter002;
   var v_pos002;
   var v_item002;
   var v_kind002;
   var expOid;
   { # getExpanded (fid)
    var vu_nil := vu_fid.ord_uselect(1303761058@0);
    var vid_vu := vu_vid.reverse();
    var oid_nil := vid_vu.leftjoin(vu_nil);
    expOid := v_vid001.leftjoin(oid_nil);
    expOid := expOid.mirror();
   } # end of getExpanded (fid)
   if (expOid.count() != 0) {
    var oidNew_expOid;
    { # expand ()
     var expOid_iter := expOid.leftfetchjoin(v_iter001);
     var iter_expOid := expOid_iter.reverse();
     var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
     var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
     oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
     var expOid_oidMap := oidMap_expOid.reverse();
     expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
     v_iter002 := expOid_iter;
     oidNew_expOid := expOid_iter.hmark(0@0);
    } # end of expand ()
    # join ()
    var cnt := count(v_iter002)*2;
    v_iter002 := v_iter002.tmark(0@0);
    var new_v_iter := v_iter002;
    v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
    var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
    v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
    var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
    v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
    var new_v_item := oidNew_expOid.leftjoin(v_item001);
    v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
    var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
    v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
   } else { # createNewVarTable ()
    v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_pos002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
    v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
   }
   { # insertVar (vid)
    var vid := project(ipik,1303761086@0);
    { # append (vid, level)
     var seqb := oid(v_vid002.count());
     vid := vid.materialize(ipik);
     v_vid002 := v_vid002.insert(vid.tmark(seqb));
    } # append (vid, level)
    { # append (iter, level)
     var seqb := oid(v_iter002.count());
     iter := iter.materialize(ipik);
     v_iter002 := v_iter002.insert(iter.tmark(seqb));
    } # append (iter, level)
    { # append (pos, level)
     var seqb := oid(v_pos002.count());
     pos := pos.materialize(ipik);
     v_pos002 := v_pos002.insert(pos.tmark(seqb));
    } # append (pos, level)
    { # append (item, level)
     var seqb := oid(v_item002.count());
     item := item.materialize(ipik);
     v_item002 := v_item002.insert(item.tmark(seqb));
    } # append (item, level)
    { # append (kind, level)
     var seqb := oid(v_kind002.count());
     kind := kind.materialize(ipik);
     v_kind002 := v_kind002.insert(kind.tmark(seqb));
    } # append (kind, level)
   } # end of insertVar (vid)
   { # translateVar (#pf:v_2824)
    var vid := v_vid002.ord_uselect(1303761086@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter002);
    item := vid.leftfetchjoin(v_item002);
    kind := vid.leftfetchjoin(v_kind002);
    ipik := iter;
   } # end of translateVar (#pf:v_2824)
   { # string-value
    var input_iter := iter;
    kind := kind.materialize(ipik);
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    var kind_elem := kind.get_type(ELEM);
    var item_str;
    if (kind_elem.count() = kind.count()) {
     var frag := kind.get_fragment();
     var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
     var t_iter := res_scj.fetch(0);
     var t_item := res_scj.fetch(1);
     var t_frag := res_scj.fetch(2);
     var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
     var t_iter_unq := t_iter.tunique();
     t_iter := t_iter.materialize(t_item);
     if (t_iter_unq.count() != t_item.count()) {
      var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
      iter_item := iter_item.string_join(t_iter_unq.project(""));
      t_iter := iter_item.hmark(0@0);
      t_item_str := iter_item.tmark(0@0);
     }
     var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
     if (c_map.count() > 0) { #process comments 
      var c_iter := c_map.leftfetchjoin(iter);
      var c_item := c_map.leftfetchjoin(item);
      var c_frag := c_map.leftfetchjoin(frag);
      var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
      var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
     } # end of comment processing
     var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
     if (pi_map.count() > 0) { #process processing-instructions 
      var pi_iter := pi_map.leftfetchjoin(iter);
      var pi_item := pi_map.leftfetchjoin(item);
      var pi_frag := pi_map.leftfetchjoin(frag);
      var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
      var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
      t_item_str := res_mu.fetch(1);
     } # end of processing-instruction processing
     iter := t_iter;
     item_str := t_item_str;
    } else {
     var kind_attr := kind.get_type(ATTR);
     if (kind_attr.count() = kind.count()) {
      var frag := kind.get_fragment();
      item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
     } else {
      kind_attr := kind_attr.hmark(0@0);
      var item_attr := kind_attr.leftfetchjoin(item);
      var iter_attr := kind_attr.leftfetchjoin(iter);
      var frag := kind_attr.leftfetchjoin(kind).get_fragment();
      var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
      kind_elem := kind_elem.hmark(0@0);
      iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
      frag := kind_elem.leftfetchjoin(kind).get_fragment();
      item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
      var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
      var t_iter := res_scj.fetch(0);
      var t_item := res_scj.fetch(1);
      var t_frag := res_scj.fetch(2);
      var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
      var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
      t_iter := iter_item.hmark(0@0);
      t_item_str := iter_item.tmark(0@0);
      var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
      iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
      {
       var item_unq := iter_item.reverse().tunique();
       if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
      }
      t_iter := iter_item.hmark(0@0);
      var t_item_str := iter_item.tmark(0@0);
      var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
      if (c_map.count() > 0) { #process comments 
       var c_iter := c_map.leftfetchjoin(iter);
       var c_item := c_map.leftfetchjoin(item);
       var c_frag := c_map.leftfetchjoin(frag);
       var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
       var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of comment processing
      var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
      if (pi_map.count() > 0) { #process processing-instructions 
       var pi_iter := pi_map.leftfetchjoin(iter);
       var pi_item := pi_map.leftfetchjoin(item);
       var pi_frag := pi_map.leftfetchjoin(frag);
       var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
       var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of processing-instruction processing
      iter := t_iter;
      item_str := t_item_str;
     }
    }
    item_str_ := item_str;
    if (iter.count() != input_iter.tunique().count()) {
     var difference := reverse(input_iter.tdiff(iter));
     difference := difference.hmark(0@0);
     var res_mu := merged_union(iter, difference, item_str_, "");
     iter := res_mu.fetch(0);
     item_str_ := res_mu.fetch(1);
    }
    ipik := iter;
    pos := tmark_grp_unique(iter,ipik);
   } # end of string-value
   { # cast from string to untypedAtomic
    if (iter.count() != loop002.count()) {
     ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
    }
   } # end of cast from string to untypedAtomic
   { # cast from untypedAtomic to double
    var cast_val := item_str_.[dbl]();
    if (cast_val.texist(dbl(nil))) {
     ERROR ("err:FORG0001: could not cast value from string to double.");
    }
    item_dbl_ := cast_val;
    kind := DBL;
    if (iter.count() != loop002.count()) {
     ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
    }
   } # end of cast from untypedAtomic to double
   { # saveResult1 () : int
    var item_dbl_001 := item_dbl_; # end of saveResult1 () : int
    { # translateVar (min)
     var vid := v_vid002.ord_uselect(1303761083@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter002);
     pos := vid.leftfetchjoin(v_pos002);
     item := vid.leftfetchjoin(v_item002);
     ipik := iter;
    } # end of translateVar (min)
    { # '>' calculation
     var val_snd := item.leftfetchjoin(dbl_values);
     var val_fst := item_dbl_001;
     val_fst := [>](val_fst,val_snd);
     item := val_fst.[oid]();
     kind := BOOL;
    } # end of '>' calculation
   } # end of deleteResult1 ()
   { # saveResult1 () : int
    var iter001 := iter;
    var item001 := item; # end of saveResult1 () : int
    { # ifthenelse-translation
     var selected;
     var skip;
     if (type(item001) = bat) {
      selected := item001.ord_uselect(1@0);
      var cnt := selected.count();
      if (item001.count() = cnt) {
       skip := 2;
      } else {
       skip := int(cnt = 0);
      }
     } else {
      skip := 1 + int(item001); # handle constants efficiently
     }
     { # translateIfThen
      var loop003 := loop002;
      var inner003 := inner002;
      var outer003 := outer002;
      var v_iter003 := v_iter002;
      if (skip = 0) {
       iter := selected.mirror().join(iter001);
       iter := iter.tmark(0@0);
       outer003 := iter;
       iter := iter.mark(1@0);
       inner003 := iter;
       loop003 := inner003;
       var expOid := v_iter003.mirror();
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter002);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
        v_iter003 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter003)*2;
       v_iter003 := v_iter003.tmark(0@0);
       var new_v_iter := v_iter003;
       var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
       var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
       var new_v_item := oidNew_expOid.leftjoin(v_item002);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind002); # end of join ()
      }
      if (skip != 1) {
       {
        int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
        var itemID := int_values.reverse().find(1LL); # translateConst (kind)
        iter := loop003.tmark(0@0);
        ipik := iter;
       }
      } else { # translateEmpty ()
       ipik := empty_bat;
       iter := empty_bat;
      }
      if (skip = 0) {
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
      } # cleanUpLevel ()
     } # end of translateIfThen
    } # end of ifthenelse-translation
   } # end of deleteResult1 ()
   { # mapBack ()
    var iter_oidMap := inner002.reverse();
    var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
    iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
    # kind := kind;
    # ipik := ipik;
   } # end of mapBack ()
   # cleanUpLevel ()
  } # end of for-translation
  { # translate fn:empty (item*) as boolean
   var iter_count := {count}(iter.reverse(),loop001.reverse(), FALSE);
   var iter_bool := iter_count.[=](0).[oid]();
   item := iter_bool.tmark(0@0);
   iter := loop001.tmark(0@0);
   ipik := iter;
   pos := 1@0;
   kind := BOOL;
  } # end of translate fn:empty (item*) as boolean
  { # saveResult1 () : int
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # ifthenelse-translation
    var selected;
    var skip;
    if (type(item001) = bat) {
     selected := item001.ord_uselect(1@0);
     var cnt := selected.count();
     if (item001.count() = cnt) {
      skip := 2;
     } else {
      skip := int(cnt = 0);
     }
    } else {
     skip := 1 + int(item001); # handle constants efficiently
    }
    { # translateIfThen
     var loop002 := loop001;
     var inner002 := inner001;
     var outer002 := outer001;
     var order_002 := order_001;
     var v_vid002 := v_vid001;
     var v_iter002 := v_iter001;
     var v_pos002 := v_pos001;
     var v_item002 := v_item001;
     var v_kind002 := v_kind001;
     if (skip = 0) {
      selected := item001.ord_uselect(0@0);
      iter := selected.mirror().join(iter001);
      iter := iter.tmark(0@0);
      outer002 := iter;
      order_002 := outer002.leftfetchjoin(inner001.reverse()).leftfetchjoin(order_001);
      iter := iter.mark(1@0);
      inner002 := iter;
      loop002 := inner002;
      var expOid := v_iter002.mirror();
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
      v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     }
     if (skip != 2) {
      { # tagname-translation
       var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
       var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
       var itemID;
       if (prop_str.texist("items")) {
        itemID := prop_str.reverse().find("items");
       } else {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
        ws.fetch(QN_LOC).fetch(WS).insert(itemID,"items");
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"items"+str('\1')+"");
       } # translateConst (kind)
       iter := loop002.tmark(0@0);
       ipik := iter;
       pos := 1@0;
       item := itemID;
       kind := QNAME;
      } # end of tagname-translation
      { # saveResult2 () : int
       var ipik002 := ipik;
       var iter002 := iter;
       var item002 := item; # end of saveResult2 () : int
       { # tagname-translation
        var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
        var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
        var itemID;
        if (prop_str.texist("person")) {
         itemID := prop_str.reverse().find("person");
        } else {
         itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
         ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
         ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
         ws.fetch(QN_LOC).fetch(WS).insert(itemID,"person");
         ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
         ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"person"+str('\1')+"");
        } # translateConst (kind)
        iter := loop002.tmark(0@0);
        ipik := iter;
        pos := 1@0;
        item := itemID;
        kind := QNAME;
       } # end of tagname-translation
       { # saveResult3 () : int
        var ipik003 := ipik;
        var iter003 := iter;
        var item003 := item; # end of saveResult3 () : int
        { # translateVar (p)
         var vid := v_vid002.ord_uselect(1303761085@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter002);
         item := vid.leftfetchjoin(v_item002);
         kind := vid.leftfetchjoin(v_kind002);
         ipik := iter;
        } # end of translateVar (p)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "profile");
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         pos  := tmark_grp_unique(iter,ipik);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        { # loop_liftedSCJ (axis, kind, ns, loc)
         { # attribute axis
          var oid_iter := iter;
          var oid_item := item.materialize(ipik);
          var oid_frag := kind.get_fragment();
          var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
          oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
          var oid_attr := temp1.tmark(0@0);
          oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
          var temp1_str; # only needed for name test
          temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
          temp1 := temp1_str.ord_uselect("");
          temp1 := temp1.hmark(0@0);
          oid_attr := temp1.leftfetchjoin(oid_attr);
          oid_frag := temp1.leftfetchjoin(oid_frag);
          oid_iter := temp1.leftfetchjoin(oid_iter);
          temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
          temp1 := temp1_str.ord_uselect("income");
          temp1 := temp1.hmark(0@0);
          oid_attr := temp1.leftfetchjoin(oid_attr);
          oid_frag := temp1.leftfetchjoin(oid_frag);
          oid_iter := temp1.leftfetchjoin(oid_iter);
          iter := oid_iter.tmark(0@0);
          item := oid_attr.tmark(0@0);
          kind := oid_frag.tmark(0@0);
          if (type(iter) = bat) {
           ipik := iter;
          } else {
           if (type(item) = bat) {
            ipik := item;
           } else {
            ipik := kind;
           }
          }
         } # end of attribute axis
         kind := kind.set_kind(ATTR);
        } # end of translateLocsteps (c)
        if (ipik.count() != 0) 
        { # for-translation
         # project ()
         iter := iter.materialize(ipik);
         var outer003 := iter;
         iter := iter.mark(1@0);
         var inner003 := iter;
         pos := 1@0;
         var v_vid003;
         var v_iter003;
         var v_pos003;
         var v_item003;
         var v_kind003;
         var expOid;
         { # getExpanded (fid)
          var vu_nil := vu_fid.ord_uselect(1303761059@0);
          var vid_vu := vu_vid.reverse();
          var oid_nil := vid_vu.leftjoin(vu_nil);
          expOid := v_vid002.leftjoin(oid_nil);
          expOid := expOid.mirror();
         } # end of getExpanded (fid)
         if (expOid.count() != 0) {
          var oidNew_expOid;
          { # expand ()
           var expOid_iter := expOid.leftfetchjoin(v_iter002);
           var iter_expOid := expOid_iter.reverse();
           var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
           var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
           oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
           var expOid_oidMap := oidMap_expOid.reverse();
           expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
           v_iter003 := expOid_iter;
           oidNew_expOid := expOid_iter.hmark(0@0);
          } # end of expand ()
          # join ()
          var cnt := count(v_iter003)*2;
          v_iter003 := v_iter003.tmark(0@0);
          var new_v_iter := v_iter003;
          v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
          var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
          v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
          var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
          v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
          var new_v_item := oidNew_expOid.leftjoin(v_item002);
          v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
          var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
          v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
         } else { # createNewVarTable ()
          v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_pos003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
         }
         { # insertVar (vid)
          var vid := project(ipik,1303761087@0);
          { # append (vid, level)
           var seqb := oid(v_vid003.count());
           vid := vid.materialize(ipik);
           v_vid003 := v_vid003.insert(vid.tmark(seqb));
          } # append (vid, level)
          { # append (iter, level)
           var seqb := oid(v_iter003.count());
           iter := iter.materialize(ipik);
           v_iter003 := v_iter003.insert(iter.tmark(seqb));
          } # append (iter, level)
          { # append (pos, level)
           var seqb := oid(v_pos003.count());
           pos := pos.materialize(ipik);
           v_pos003 := v_pos003.insert(pos.tmark(seqb));
          } # append (pos, level)
          { # append (item, level)
           var seqb := oid(v_item003.count());
           item := item.materialize(ipik);
           v_item003 := v_item003.insert(item.tmark(seqb));
          } # append (item, level)
          { # append (kind, level)
           var seqb := oid(v_kind003.count());
           kind := kind.materialize(ipik);
           v_kind003 := v_kind003.insert(kind.tmark(seqb));
          } # append (kind, level)
         } # end of insertVar (vid)
         { # translateVar (#pf:v_1846)
          var vid := v_vid003.ord_uselect(1303761087@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter003);
          item := vid.leftfetchjoin(v_item003);
          kind := vid.leftfetchjoin(v_kind003);
          ipik := iter;
         } # end of translateVar (#pf:v_1846)
         { # string-value
          var input_iter := iter;
          kind := kind.materialize(ipik);
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          var kind_elem := kind.get_type(ELEM);
          var item_str;
          if (kind_elem.count() = kind.count()) {
           var frag := kind.get_fragment();
           var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
           var t_iter := res_scj.fetch(0);
           var t_item := res_scj.fetch(1);
           var t_frag := res_scj.fetch(2);
           var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
           var t_iter_unq := t_iter.tunique();
           t_iter := t_iter.materialize(t_item);
           if (t_iter_unq.count() != t_item.count()) {
            var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            iter_item := iter_item.string_join(t_iter_unq.project(""));
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
           }
           var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
           if (c_map.count() > 0) { #process comments 
            var c_iter := c_map.leftfetchjoin(iter);
            var c_item := c_map.leftfetchjoin(item);
            var c_frag := c_map.leftfetchjoin(frag);
            var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
            var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
           } # end of comment processing
           var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
           if (pi_map.count() > 0) { #process processing-instructions 
            var pi_iter := pi_map.leftfetchjoin(iter);
            var pi_item := pi_map.leftfetchjoin(item);
            var pi_frag := pi_map.leftfetchjoin(frag);
            var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
            var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
            t_item_str := res_mu.fetch(1);
           } # end of processing-instruction processing
           iter := t_iter;
           item_str := t_item_str;
          } else {
           var kind_attr := kind.get_type(ATTR);
           if (kind_attr.count() = kind.count()) {
            var frag := kind.get_fragment();
            item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
           } else {
            kind_attr := kind_attr.hmark(0@0);
            var item_attr := kind_attr.leftfetchjoin(item);
            var iter_attr := kind_attr.leftfetchjoin(iter);
            var frag := kind_attr.leftfetchjoin(kind).get_fragment();
            var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
            kind_elem := kind_elem.hmark(0@0);
            iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
            frag := kind_elem.leftfetchjoin(kind).get_fragment();
            item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
            var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
            var t_iter := res_scj.fetch(0);
            var t_item := res_scj.fetch(1);
            var t_frag := res_scj.fetch(2);
            var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
            var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
            var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
            iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            {
             var item_unq := iter_item.reverse().tunique();
             if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
            }
            t_iter := iter_item.hmark(0@0);
            var t_item_str := iter_item.tmark(0@0);
            var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
            if (c_map.count() > 0) { #process comments 
             var c_iter := c_map.leftfetchjoin(iter);
             var c_item := c_map.leftfetchjoin(item);
             var c_frag := c_map.leftfetchjoin(frag);
             var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
             var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of comment processing
            var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
            if (pi_map.count() > 0) { #process processing-instructions 
             var pi_iter := pi_map.leftfetchjoin(iter);
             var pi_item := pi_map.leftfetchjoin(item);
             var pi_frag := pi_map.leftfetchjoin(frag);
             var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
             var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of processing-instruction processing
            iter := t_iter;
            item_str := t_item_str;
           }
          }
          item_str_ := item_str;
          if (iter.count() != input_iter.tunique().count()) {
           var difference := reverse(input_iter.tdiff(iter));
           difference := difference.hmark(0@0);
           var res_mu := merged_union(iter, difference, item_str_, "");
           iter := res_mu.fetch(0);
           item_str_ := res_mu.fetch(1);
          }
          ipik := iter;
          kind := STR;
         } # end of string-value
         { # mapBack ()
          var iter_oidMap := inner003.reverse();
          var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
          iter := oid_oidMap.leftfetchjoin(outer003);
          pos := tmark_grp_unique(iter,ipik); # item := item;
          # kind := kind;
          # ipik := ipik;
         } # end of mapBack ()
         # cleanUpLevel ()
        } # end of for-translation
        { # saveResult4 () : int
         var ipik004 := ipik;
         var iter004 := iter;
         var item_str_004 := item_str_; # end of saveResult4 () : int
         iter := loop002.tmark(0@0);
         ipik := iter;
         item_str_ := " ";
         { # string-join (string*, string)
          var iter_item_str := iter004.materialize(ipik004).reverse();
          iter_item_str := iter_item_str.leftfetchjoin(item_str_004).materialize(iter_item_str).chk_order();
          var iter_sep_str := iter.materialize(ipik).reverse();
          iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
          iter_item_str := string_join(iter_item_str, iter_sep_str);
          iter := iter_item_str.hmark(0@0);
          iter_item_str := iter_item_str.tmark(0@0);
          item_str_ := iter_item_str;
         } # end of string-join (string*, string)
        } # end of deleteResult4 ()
        { # loop_liftedAttrConstr (int i)
         if (iter003.count() != loop002.count()) {
          ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
         }
         if (iter.count() != loop002.count()) {
          var difference := reverse(loop002.tdiff(iter));
          difference := difference.hmark(0@0);
          var res_mu := merged_union(iter, difference, item_str_, "");
          item_str_ := res_mu.fetch(1);
         }
         var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
         var unq := item_str_.tunique().hmark(0@0);
         var unq_str := unq;
         var str_unq := reverse(unq_str.tdiff(ws_prop_val));
         var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
         unq_str := str_unq.hmark(seqb);
         ws_prop_val := ws_prop_val.insert(unq_str);
         var strings := item_str_.materialize(loop002);
         var attr_oid := strings.leftjoin(ws_prop_val.reverse());
         { # translateEmpty_node ()
          _elem_iter  := empty_bat;
          _elem_size  := empty_bat.project(int(nil));
          _elem_level := empty_bat.project(chr(nil));
          _elem_kind  := empty_bat.project(chr(nil));
          _elem_prop  := empty_bat;
          _elem_frag  := empty_bat;
          _attr_iter  := empty_bat;
          _attr_qn    := empty_bat;
          _attr_prop  := empty_bat;
          _attr_frag  := empty_bat;
          _attr_own   := empty_bat;
         } # end of translateEmpty_node ()
         attr_oid := attr_oid.tmark(0@0);
         _r_attr_iter := iter003;
         _r_attr_qn   := item003.materialize(ipik003);
         _r_attr_prop := attr_oid;
         _r_attr_frag := attr_oid.project(WS);
        } # end of loop_liftedAttrConstr (int i)
       } # end of deleteResult3 ()
       { # saveResult_node3 () : int
        var _elem_iter003   := _elem_iter  ;
        var _elem_size003   := _elem_size  ;
        var _elem_level003  := _elem_level ;
        var _elem_kind003   := _elem_kind  ;
        var _elem_prop003   := _elem_prop  ;
        var _elem_frag003   := _elem_frag  ;
        var _attr_iter003   := _attr_iter  ;
        var _attr_qn003     := _attr_qn    ;
        var _attr_prop003   := _attr_prop  ;
        var _attr_frag003   := _attr_frag  ;
        var _attr_own003    := _attr_own   ;
        var _r_attr_iter003 := _r_attr_iter;
        var _r_attr_qn003   := _r_attr_qn  ;
        var _r_attr_prop003 := _r_attr_prop;
        var _r_attr_frag003 := _r_attr_frag; # end of saveResult_node3 () : int
        {
         var iter004;
         var item004;
         var kind004;
         var ipik005;
         var iter005;
         var item005;
         var match_outer005;
         var ipik006;
         var iter006;
         var item006;
         var match_outer006;
         var jouter005 ;
         var jorder_005 ;
         var jinner005 ;
         var jloop005  ;
         var jv_vid005 ;
         var jv_iter005;
         var jv_pos005 ;
         var jv_item005;
         var jv_kind005;
         { # translateVar (p)
          var vid := v_vid002.ord_uselect(1303761085@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter002);
          item := vid.leftfetchjoin(v_item002);
          kind := vid.leftfetchjoin(v_kind002);
          ipik := iter;
         } # end of translateVar (p)
         { # translateLocsteps (c)
          var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "profile");
          iter := res_scj.fetch(0);
          item := res_scj.fetch(1);
          pos  := tmark_grp_unique(iter,ipik);
          kind := res_scj.fetch(2).set_kind(ELEM);
          ipik := item;
         } # end of translateLocsteps (c)
         { # loop_liftedSCJ (axis, kind, ns, loc)
          { # attribute axis
           var oid_iter := iter;
           var oid_item := item.materialize(ipik);
           var oid_frag := kind.get_fragment();
           var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
           oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
           var oid_attr := temp1.tmark(0@0);
           oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
           var temp1_str; # only needed for name test
           temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
           temp1 := temp1_str.ord_uselect("");
           temp1 := temp1.hmark(0@0);
           oid_attr := temp1.leftfetchjoin(oid_attr);
           oid_frag := temp1.leftfetchjoin(oid_frag);
           oid_iter := temp1.leftfetchjoin(oid_iter);
           temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
           temp1 := temp1_str.ord_uselect("income");
           temp1 := temp1.hmark(0@0);
           oid_attr := temp1.leftfetchjoin(oid_attr);
           oid_frag := temp1.leftfetchjoin(oid_frag);
           oid_iter := temp1.leftfetchjoin(oid_iter);
           iter := oid_iter.tmark(0@0);
           item := oid_attr.tmark(0@0);
           kind := oid_frag.tmark(0@0);
           if (type(iter) = bat) {
            ipik := iter;
           } else {
            if (type(item) = bat) {
             ipik := item;
            } else {
             ipik := kind;
            }
           }
          } # end of attribute axis
          kind := kind.set_kind(ATTR);
         } # end of translateLocsteps (c)
         if (ipik.count() != 0) 
         { # for-translation
          # project ()
          iter := iter.materialize(ipik);
          var outer003 := iter;
          iter := iter.mark(1@0);
          var inner003 := iter;
          pos := 1@0;
          var loop003 := inner003;
          var v_vid003;
          var v_iter003;
          var v_pos003;
          var v_item003;
          var v_kind003;
          var expOid;
          { # getExpanded (fid)
           var vu_nil := vu_fid.ord_uselect(1303761060@0);
           var vid_vu := vu_vid.reverse();
           var oid_nil := vid_vu.leftjoin(vu_nil);
           expOid := v_vid002.leftjoin(oid_nil);
           expOid := expOid.mirror();
          } # end of getExpanded (fid)
          if (expOid.count() != 0) {
           var oidNew_expOid;
           { # expand ()
            var expOid_iter := expOid.leftfetchjoin(v_iter002);
            var iter_expOid := expOid_iter.reverse();
            var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
            var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
            oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
            var expOid_oidMap := oidMap_expOid.reverse();
            expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
            v_iter003 := expOid_iter;
            oidNew_expOid := expOid_iter.hmark(0@0);
           } # end of expand ()
           # join ()
           var cnt := count(v_iter003)*2;
           v_iter003 := v_iter003.tmark(0@0);
           var new_v_iter := v_iter003;
           v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
           var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
           v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
           var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
           v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
           var new_v_item := oidNew_expOid.leftjoin(v_item002);
           v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
           var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
           v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
          } else { # createNewVarTable ()
           v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_pos003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
          }
          { # insertVar (vid)
           var vid := project(ipik,1303761088@0);
           { # append (vid, level)
            var seqb := oid(v_vid003.count());
            vid := vid.materialize(ipik);
            v_vid003 := v_vid003.insert(vid.tmark(seqb));
           } # append (vid, level)
           { # append (iter, level)
            var seqb := oid(v_iter003.count());
            iter := iter.materialize(ipik);
            v_iter003 := v_iter003.insert(iter.tmark(seqb));
           } # append (iter, level)
           { # append (pos, level)
            var seqb := oid(v_pos003.count());
            pos := pos.materialize(ipik);
            v_pos003 := v_pos003.insert(pos.tmark(seqb));
           } # append (pos, level)
           { # append (item, level)
            var seqb := oid(v_item003.count());
            item := item.materialize(ipik);
            v_item003 := v_item003.insert(item.tmark(seqb));
           } # append (item, level)
           { # append (kind, level)
            var seqb := oid(v_kind003.count());
            kind := kind.materialize(ipik);
            v_kind003 := v_kind003.insert(kind.tmark(seqb));
           } # append (kind, level)
          } # end of insertVar (vid)
          { # translateVar (#pf:v_2820)
           var vid := v_vid003.ord_uselect(1303761088@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter003);
           item := vid.leftfetchjoin(v_item003);
           kind := vid.leftfetchjoin(v_kind003);
           ipik := iter;
          } # end of translateVar (#pf:v_2820)
          { # string-value
           var input_iter := iter;
           kind := kind.materialize(ipik);
           item := item.materialize(ipik);
           iter := iter.materialize(ipik);
           var kind_elem := kind.get_type(ELEM);
           var item_str;
           if (kind_elem.count() = kind.count()) {
            var frag := kind.get_fragment();
            var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
            var t_iter := res_scj.fetch(0);
            var t_item := res_scj.fetch(1);
            var t_frag := res_scj.fetch(2);
            var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
            var t_iter_unq := t_iter.tunique();
            t_iter := t_iter.materialize(t_item);
            if (t_iter_unq.count() != t_item.count()) {
             var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
             iter_item := iter_item.string_join(t_iter_unq.project(""));
             t_iter := iter_item.hmark(0@0);
             t_item_str := iter_item.tmark(0@0);
            }
            var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
            if (c_map.count() > 0) { #process comments 
             var c_iter := c_map.leftfetchjoin(iter);
             var c_item := c_map.leftfetchjoin(item);
             var c_frag := c_map.leftfetchjoin(frag);
             var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
             var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of comment processing
            var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
            if (pi_map.count() > 0) { #process processing-instructions 
             var pi_iter := pi_map.leftfetchjoin(iter);
             var pi_item := pi_map.leftfetchjoin(item);
             var pi_frag := pi_map.leftfetchjoin(frag);
             var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
             var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
             t_item_str := res_mu.fetch(1);
            } # end of processing-instruction processing
            iter := t_iter;
            item_str := t_item_str;
           } else {
            var kind_attr := kind.get_type(ATTR);
            if (kind_attr.count() = kind.count()) {
             var frag := kind.get_fragment();
             item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
            } else {
             kind_attr := kind_attr.hmark(0@0);
             var item_attr := kind_attr.leftfetchjoin(item);
             var iter_attr := kind_attr.leftfetchjoin(iter);
             var frag := kind_attr.leftfetchjoin(kind).get_fragment();
             var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
             kind_elem := kind_elem.hmark(0@0);
             iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
             frag := kind_elem.leftfetchjoin(kind).get_fragment();
             item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
             var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
             var t_iter := res_scj.fetch(0);
             var t_item := res_scj.fetch(1);
             var t_frag := res_scj.fetch(2);
             var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
             var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
             t_iter := iter_item.hmark(0@0);
             t_item_str := iter_item.tmark(0@0);
             var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
             iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
             {
              var item_unq := iter_item.reverse().tunique();
              if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
             }
             t_iter := iter_item.hmark(0@0);
             var t_item_str := iter_item.tmark(0@0);
             var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
             if (c_map.count() > 0) { #process comments 
              var c_iter := c_map.leftfetchjoin(iter);
              var c_item := c_map.leftfetchjoin(item);
              var c_frag := c_map.leftfetchjoin(frag);
              var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
              var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
             } # end of comment processing
             var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
             if (pi_map.count() > 0) { #process processing-instructions 
              var pi_iter := pi_map.leftfetchjoin(iter);
              var pi_item := pi_map.leftfetchjoin(item);
              var pi_frag := pi_map.leftfetchjoin(frag);
              var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
              var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
             } # end of processing-instruction processing
             iter := t_iter;
             item_str := t_item_str;
            }
           }
           item_str_ := item_str;
           if (iter.count() != input_iter.tunique().count()) {
            var difference := reverse(input_iter.tdiff(iter));
            difference := difference.hmark(0@0);
            var res_mu := merged_union(iter, difference, item_str_, "");
            iter := res_mu.fetch(0);
            item_str_ := res_mu.fetch(1);
           }
           ipik := iter;
          } # end of string-value
          { # cast from string to untypedAtomic
           if (iter.count() != loop003.count()) {
            ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
           }
          } # end of cast from string to untypedAtomic
          { # cast from untypedAtomic to double
           var cast_val := item_str_.[dbl]();
           if (cast_val.texist(dbl(nil))) {
            ERROR ("err:FORG0001: could not cast value from string to double.");
           }
           item_dbl_ := cast_val;
           kind := DBL;
           if (iter.count() != loop003.count()) {
            ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
           }
          } # end of cast from untypedAtomic to double
          { # mapBack ()
           var iter_oidMap := inner003.reverse();
           var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
           iter := oid_oidMap.leftfetchjoin(outer003);
           pos := tmark_grp_unique(iter,ipik); # item := item;
           # kind := kind;
           # ipik := ipik;
          } # end of mapBack ()
          # cleanUpLevel ()
         } # end of for-translation
         {
          var mapping := outer000.reverse().leftfetchjoin(inner000);
          mapping := mapping.leftjoin(outer001.reverse());
          mapping := mapping.leftfetchjoin(inner001);
          mapping := mapping.leftjoin(outer002.reverse());
          mapping := mapping.leftfetchjoin(inner002);
          match_outer005 := iter.leftjoin(mapping.reverse()).tmark(iter.seqbase());
         }
         ipik005 := ipik;
         iter005 := iter;
         item005 := item_dbl_;
         jouter005  := outer002 ;
         jorder_005  := order_002 ;
         jinner005  := inner002 ;
         jloop005   := loop002  ;
         jv_vid005  := v_vid002 ;
         jv_iter005 := v_iter002;
         jv_pos005  := v_pos002 ;
         jv_item005 := v_item002;
         jv_kind005 := v_kind002;
         v_vid002  := v_vid000 .copy().access(BAT_WRITE);
         v_iter002 := v_iter000.copy().access(BAT_WRITE);
         v_pos002  := v_pos000 .copy().access(BAT_WRITE);
         v_item002 := v_item000.copy().access(BAT_WRITE);
         v_kind002 := v_kind000.copy().access(BAT_WRITE);
         { # translateVar (auction)
          var vid := v_vid002.ord_uselect(1303761084@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter002);
          item := vid.leftfetchjoin(v_item002);
          kind := vid.leftfetchjoin(v_kind002);
          ipik := iter;
         } # end of translateVar (auction)
         { # translateLocsteps (c)
          var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "initial");
          iter := res_scj.fetch(0);
          item := res_scj.fetch(1);
          kind := res_scj.fetch(2).set_kind(ELEM);
          ipik := item;
         } # end of translateLocsteps (c)
         { # for-translation
          # project ()
          iter := iter.materialize(ipik);
          var outer003 := iter;
          iter := iter.mark(1@0);
          var inner003 := iter;
          pos := 1@0;
          var loop003 := inner003;
          var v_vid003;
          var v_iter003;
          var v_pos003;
          var v_item003;
          var v_kind003;
          iter004 := iter;
          item004 := item;
          kind004 := kind;
          var expOid;
          { # getExpanded (fid)
           var vu_nil := vu_fid.ord_uselect(1303761061@0);
           var vid_vu := vu_vid.reverse();
           var oid_nil := vid_vu.leftjoin(vu_nil);
           expOid := v_vid002.leftjoin(oid_nil);
           expOid := expOid.mirror();
          } # end of getExpanded (fid)
          if (expOid.count() != 0) {
           var oidNew_expOid;
           { # expand ()
            var expOid_iter := expOid.leftfetchjoin(v_iter002);
            var iter_expOid := expOid_iter.reverse();
            var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
            var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
            oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
            var expOid_oidMap := oidMap_expOid.reverse();
            expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
            v_iter003 := expOid_iter;
            oidNew_expOid := expOid_iter.hmark(0@0);
           } # end of expand ()
           # join ()
           var cnt := count(v_iter003)*2;
           v_iter003 := v_iter003.tmark(0@0);
           var new_v_iter := v_iter003;
           v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
           var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
           v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
           var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
           v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
           var new_v_item := oidNew_expOid.leftjoin(v_item002);
           v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
           var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
           v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
          } else { # createNewVarTable ()
           v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_pos003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
           v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
          }
          { # insertVar (vid)
           var vid := project(ipik,1303761089@0);
           { # append (vid, level)
            var seqb := oid(v_vid003.count());
            vid := vid.materialize(ipik);
            v_vid003 := v_vid003.insert(vid.tmark(seqb));
           } # append (vid, level)
           { # append (iter, level)
            var seqb := oid(v_iter003.count());
            iter := iter.materialize(ipik);
            v_iter003 := v_iter003.insert(iter.tmark(seqb));
           } # append (iter, level)
           { # append (pos, level)
            var seqb := oid(v_pos003.count());
            pos := pos.materialize(ipik);
            v_pos003 := v_pos003.insert(pos.tmark(seqb));
           } # append (pos, level)
           { # append (item, level)
            var seqb := oid(v_item003.count());
            item := item.materialize(ipik);
            v_item003 := v_item003.insert(item.tmark(seqb));
           } # append (item, level)
           { # append (kind, level)
            var seqb := oid(v_kind003.count());
            kind := kind.materialize(ipik);
            v_kind003 := v_kind003.insert(kind.tmark(seqb));
           } # append (kind, level)
          } # end of insertVar (vid)
          { # translateVar (factor)
           var vid := v_vid003.ord_uselect(1303761082@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter003);
           pos := vid.leftfetchjoin(v_pos003);
           item := vid.leftfetchjoin(v_item003);
           ipik := iter;
          } # end of translateVar (factor)
          { # cast from integer to double
           var cast_val := item.leftfetchjoin(int_values).[dbl]();
           if (cast_val.texist(dbl(nil))) {
            ERROR ("err:FORG0001: could not cast value from integer to double.");
           }
           item_dbl_ := cast_val;
           kind := DBL;
           if (iter.count() != loop003.count()) {
            ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
           }
          } # end of cast from integer to double
          { # saveResult7 () : int
           var item_dbl_007 := item_dbl_; # end of saveResult7 () : int
           { # translateVar (i)
            var vid := v_vid003.ord_uselect(1303761089@0);
            vid := vid.hmark(0@0);
            iter := vid.leftfetchjoin(v_iter003);
            item := vid.leftfetchjoin(v_item003);
            kind := vid.leftfetchjoin(v_kind003);
            ipik := iter;
           } # end of translateVar (i)
           { # translateLocsteps (c)
            var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, TEXT);
            iter := res_scj.fetch(0);
            item := res_scj.fetch(1);
            kind := res_scj.fetch(2).set_kind(ELEM);
            ipik := item;
           } # end of translateLocsteps (c)
           if (iter.tunique().count() != loop003.count()) {
            ERROR ("err:FORG0005: function fn:exactly-one expects exactly one value.");
           }
           { # string-value
            var input_iter := iter;
            kind := kind.materialize(ipik);
            item := item.materialize(ipik);
            iter := iter.materialize(ipik);
            var kind_elem := kind.get_type(ELEM);
            var item_str;
            if (kind_elem.count() = kind.count()) {
             var frag := kind.get_fragment();
             var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
             var t_iter := res_scj.fetch(0);
             var t_item := res_scj.fetch(1);
             var t_frag := res_scj.fetch(2);
             var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
             var t_iter_unq := t_iter.tunique();
             t_iter := t_iter.materialize(t_item);
             if (t_iter_unq.count() != t_item.count()) {
              var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
              iter_item := iter_item.string_join(t_iter_unq.project(""));
              t_iter := iter_item.hmark(0@0);
              t_item_str := iter_item.tmark(0@0);
             }
             var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
             if (c_map.count() > 0) { #process comments 
              var c_iter := c_map.leftfetchjoin(iter);
              var c_item := c_map.leftfetchjoin(item);
              var c_frag := c_map.leftfetchjoin(frag);
              var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
              var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
             } # end of comment processing
             var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
             if (pi_map.count() > 0) { #process processing-instructions 
              var pi_iter := pi_map.leftfetchjoin(iter);
              var pi_item := pi_map.leftfetchjoin(item);
              var pi_frag := pi_map.leftfetchjoin(frag);
              var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
              var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
              t_item_str := res_mu.fetch(1);
             } # end of processing-instruction processing
             iter := t_iter;
             item_str := t_item_str;
            } else {
             var kind_attr := kind.get_type(ATTR);
             if (kind_attr.count() = kind.count()) {
              var frag := kind.get_fragment();
              item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
             } else {
              kind_attr := kind_attr.hmark(0@0);
              var item_attr := kind_attr.leftfetchjoin(item);
              var iter_attr := kind_attr.leftfetchjoin(iter);
              var frag := kind_attr.leftfetchjoin(kind).get_fragment();
              var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
              kind_elem := kind_elem.hmark(0@0);
              iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
              frag := kind_elem.leftfetchjoin(kind).get_fragment();
              item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
              var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
              var t_iter := res_scj.fetch(0);
              var t_item := res_scj.fetch(1);
              var t_frag := res_scj.fetch(2);
              var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
              var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
              t_iter := iter_item.hmark(0@0);
              t_item_str := iter_item.tmark(0@0);
              var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
              t_iter := res_mu.fetch(0);
              t_item_str := res_mu.fetch(1);
              iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
              {
               var item_unq := iter_item.reverse().tunique();
               if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
              }
              t_iter := iter_item.hmark(0@0);
              var t_item_str := iter_item.tmark(0@0);
              var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
              if (c_map.count() > 0) { #process comments 
               var c_iter := c_map.leftfetchjoin(iter);
               var c_item := c_map.leftfetchjoin(item);
               var c_frag := c_map.leftfetchjoin(frag);
               var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
               var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
               t_iter := res_mu.fetch(0);
               t_item_str := res_mu.fetch(1);
              } # end of comment processing
              var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
              if (pi_map.count() > 0) { #process processing-instructions 
               var pi_iter := pi_map.leftfetchjoin(iter);
               var pi_item := pi_map.leftfetchjoin(item);
               var pi_frag := pi_map.leftfetchjoin(frag);
               var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
               var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
               t_iter := res_mu.fetch(0);
               t_item_str := res_mu.fetch(1);
              } # end of processing-instruction processing
              iter := t_iter;
              item_str := t_item_str;
             }
            }
            item_str_ := item_str;
            if (iter.count() != input_iter.tunique().count()) {
             var difference := reverse(input_iter.tdiff(iter));
             difference := difference.hmark(0@0);
             var res_mu := merged_union(iter, difference, item_str_, "");
             iter := res_mu.fetch(0);
             item_str_ := res_mu.fetch(1);
            }
            ipik := iter;
            pos := tmark_grp_unique(iter,ipik);
           } # end of string-value
           { # cast from string to double
            var cast_val := item_str_.[dbl]();
            if (cast_val.texist(dbl(nil))) {
             ERROR ("err:FORG0001: could not cast value from string to double.");
            }
            item_dbl_ := cast_val;
            kind := DBL;
            if (iter.count() != loop003.count()) {
             ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
            }
           } # end of cast from string to double
           { # '*' calculation
            var val_snd := item_dbl_;
            var val_fst := item_dbl_007;
            val_fst := [*](val_fst,val_snd);
            item_dbl_ := val_fst;
           } # end of '*' calculation
          } # end of deleteResult7 ()
          ipik006 := ipik;
          iter006 := iter;
          item006 := item_dbl_;
          match_outer006 := iter.leftfetchjoin(inner003.reverse()).leftfetchjoin(outer003); # cleanUpLevel ()
         } # end of for-translation
         outer002  := jouter005 ;
         inner002  := jinner005 ;
         loop002   := jloop005  ;
         var join_item1 := item005;
         var join_item2 := item006;
         join_item1 := join_item1.materialize(ipik005);
         join_item1 := join_item1.reverse().leftfetchjoin(iter005).reverse();
         join_item2 := join_item2.materialize(ipik006);
         join_item2 := join_item2.reverse().leftfetchjoin(iter006).reverse();
         var join_result := ll_htordered_unique_thetajoin(GT, join_item1, join_item2, match_outer005, match_outer006,nil,iter004.reverse());
         var snd_iter := join_result.tmark(0@0);
         var fst_iter := join_result.hmark(0@0);
         ipik := fst_iter; # order_fst isn't needed until now
         # (cannot be pushed below the theta-join due to the 'iter := fst_iter;' hereafter)
         # var order_fst := fst_iter.leftfetchjoin(inner002.reverse());
         var order_snd := snd_iter; #.leftfetchjoin(iter004.reverse()); pushed below theta-join
         iter := fst_iter;
        } # end of evaluate_join
        { # translate fn:count (item*) as integer
         iter := iter.materialize(ipik);
         var iter_count := [lng]({count}(iter.reverse(),loop002.reverse(), FALSE)).tmark(0@0);
         item := int_values.addValues(iter_count).tmark(0@0);
         iter := loop002.tmark(0@0);
         ipik := iter;
         pos := 1@0;
         kind := INT;
        } # end of translate fn:count (item*) as integer
        { # saveResult4 () : int
         var ipik004 := ipik;
         var iter004 := iter;
         var pos004 := pos;
         var item004 := item;
         var kind004 := kind; # end of saveResult4 () : int
         { # item-sequence-to-node-sequence
          var nodes_order;
          {
           ipik := ipik004;
           pos := pos004;
           item := item004;
           kind := kind004;
           kind := kind.materialize(ipik);
           var elem := kind.get_type(ELEM);
           elem := elem.hmark(0@0);
           var kind_elem := elem.leftfetchjoin(kind);
           var frag_elem := kind_elem.get_fragment();
           var item_elem := elem.leftfetchjoin(item).materialize(elem);
           var kind_node := mposjoin (item_elem, frag_elem, ws.fetch(PRE_KIND));
           var text := kind_node.ord_uselect(TEXT).hmark(0@0);
           var item_text := text.leftfetchjoin(item_elem);
           var frag_text := text.leftfetchjoin(frag_elem);
           var text_str := mposjoin (mposjoin (item_text, frag_text, ws.fetch(PRE_PROP)), mposjoin (item_text, frag_text, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
           var str_text := text_str.reverse().leftfetchjoin(text);
           var texts := str_text.leftfetchjoin(elem).reverse();
           var texts_order := texts.hmark(0@0);
           texts := texts.tmark(0@0);
           var nodes := kind_node.[!=](TEXT).ord_uselect(true).project("");
           nodes := nodes.reverse().leftfetchjoin(elem).reverse();
           nodes_order := nodes.hmark(0@0);
           nodes := nodes.tmark(0@0);
           var res_mu_is2ns := merged_union (nodes_order, texts_order, nodes, texts, 0@0, 1@0);
           var input_order := res_mu_is2ns.fetch(0);
           var input_str := res_mu_is2ns.fetch(1);
           var input_const := res_mu_is2ns.fetch(2);
           kind := kind.materialize(ipik);
           var atomic := kind.get_type_atomic();
           atomic := atomic.hmark(0@0);
           iter := atomic.mirror();
           item := atomic.leftfetchjoin(item);
           var cast_val := item.leftfetchjoin(int_values).[str]();
           if (cast_val.texist(str(nil))) {
            ERROR ("err:FORG0001: could not cast value from integer to string.");
           }
           item_str_ := cast_val;
           res_mu_is2ns := merged_union (input_order, atomic, input_str, item_str_, input_const, 2@0);
           input_order := res_mu_is2ns.fetch(0);
           input_str := res_mu_is2ns.fetch(1);
           input_const := res_mu_is2ns.fetch(2);
           var input_iter := input_order.leftfetchjoin(iter004).chk_order();
           var result_size := iter004.tunique().count() + nodes_order.count() + 1;
           var result_str := combine_text_string (input_iter.materialize(input_str), input_const.materialize(input_str), input_str, result_size);
           var result_order := result_str.hmark(0@0);
           result_order := result_order.leftfetchjoin(input_order);
           result_str := result_str.tmark(0@0);
           iter := result_order;
           ipik := iter;
           item_str_ := result_str;
          }
          { # adding new strings to text node content and create new nodes
           var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
           var unq_str := item_str_.tunique().hmark(0@0);
           var str_unq := reverse(unq_str.tdiff(ws_prop_text));
           var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
           unq_str := str_unq.hmark(seqb);
           ws_prop_text := ws_prop_text.insert(unq_str);
           var ws_text_prop := ws_prop_text.reverse().sort();
           item_str_ := item_str_.materialize(ipik);
           var X_item := item_str_.hmark(0@0);
           var X_strings := item_str_.tmark(0@0).tsort();
           var X_prop := X_strings.leftjoin(ws_text_prop);
           var newPre_prop := X_item.reverse().leftjoin(X_prop);
           seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS))+ int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
           newPre_prop := newPre_prop.tmark(seqb);
           ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
           ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
           ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
           ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
           ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));
           {
            var kind_pre_ := newPre_prop.hmark(nil).chk_order();
            ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
           }
           item := item_str_.mark(seqb);
           kind := ELEM;
          } # end of adding new strings to text node content and create new nodes
          { # adding new fragments to the WS_FRAG bat
           var seqb := ws.fetch(WS_FRAG).count();
           seqb := oid(seqb);
           var new_pres := item.tmark(seqb);
           ws.fetch(WS_FRAG).insert(new_pres);
           ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
          } # end of adding new fragments to the WS_FRAG bat
          var res_mu_is2ns := merged_union (iter, nodes_order, item, nodes_order.leftfetchjoin(item004), kind, nodes_order.leftfetchjoin(kind004));
          kind004 := kind004.materialize(ipik004);
          var attr := kind004.get_type(ATTR).hmark(0@0);
          var item_attr := attr.leftfetchjoin(item004);
          var kind_attr := attr.leftfetchjoin(kind004);
          res_mu_is2ns := merged_union (res_mu_is2ns.fetch(0), attr, res_mu_is2ns.fetch(1), item_attr, res_mu_is2ns.fetch(2), kind_attr);
          iter := res_mu_is2ns.fetch(0).leftfetchjoin(iter004);
          item := res_mu_is2ns.fetch(1);
          kind := res_mu_is2ns.fetch(2);
          ipik := item;
         } # end of item-sequence-to-node-sequence
        } # end of deleteResult4 ()
        { # map2NODE_interface (counter)
         kind := kind.materialize(ipik);
         var attr := kind.get_type(ATTR).hmark(0@0);
         var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
         var attr_item := attr.leftfetchjoin(item);
         var attr_frag := attr.leftfetchjoin(kind).get_fragment();
         _r_attr_iter := attr_iter;
         _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
         _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
         _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
         var nodes := kind.get_type(ELEM);
         if (nodes.count() != 0) {
          var oid_oid := nodes.hmark(0@0);
          var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
          var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
          var iter_input := oid_oid.mirror();
          var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
          var res_iter := res_scj.fetch(0);
          var res_item := res_scj.fetch(1);
          var res_frag := res_scj.fetch(2);
          _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
          _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
          _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
          _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
          _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
          var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
          var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
          nodes := res_item.mark(0@0);
          var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
          root_level := nodes.leftfetchjoin(root_level);
          temp_ec_item := res_item;
          temp_ec_frag := res_frag;
          var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
          content_level := nodes.leftfetchjoin(content_level);
          content_level := content_level.[-](root_level);
          content_level := content_level.tmark(0@0);
          _elem_level := content_level;
          { # create attribute subtree copies
           var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
           var oid_attr := temp_attr.tmark(0@0);
           var oid_frag;
           if (is_constant(res_frag)) {
            oid_frag := res_frag;
           } else {
            oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
            oid_frag := oid_frag.tmark(0@0);
           }
           _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
           _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
           _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
           _attr_own  := temp_attr.hmark(0@0);
           _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
          } # end of create attribute subtree copies
         } else { # if (nodes.count() != 0) ...
          _elem_iter  := empty_bat;
          _elem_size  := empty_bat.project(int(nil));
          _elem_level := empty_bat.project(chr(nil));
          _elem_kind  := empty_bat.project(chr(nil));
          _elem_prop  := empty_bat;
          _elem_frag  := empty_bat;
          _attr_iter  := empty_bat;
          _attr_qn    := empty_bat;
          _attr_prop  := empty_bat;
          _attr_frag  := empty_bat;
          _attr_own   := empty_bat;
         } # end of else in 'if (nodes.count() != 0)'
        } # end of map2NODE_interface (counter)
        # translateSeq_node (f, counter)
        if (_r_attr_iter.count() = 0) {
         _r_attr_iter := _r_attr_iter003;
         _r_attr_qn := _r_attr_qn003;
         _r_attr_prop := _r_attr_prop003;
         _r_attr_frag := _r_attr_frag003;
        } else {
         if (_r_attr_iter003.count() != 0) 
         { # combine attribute roots
          var merged_result := merged_union (_r_attr_iter003.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn003, _r_attr_qn, _r_attr_prop003, _r_attr_prop, _r_attr_frag003, _r_attr_frag);
          _r_attr_iter := merged_result.fetch(0);
          _r_attr_qn := merged_result.fetch(1);
          _r_attr_prop := merged_result.fetch(2);
          _r_attr_frag := merged_result.fetch(3);
         }
        } # end of combine attribute roots
        if (_elem_iter.count() = 0) {
         _elem_iter  := _elem_iter003  ;
         _elem_size  := _elem_size003  ;
         _elem_level := _elem_level003 ;
         _elem_kind  := _elem_kind003  ;
         _elem_prop  := _elem_prop003  ;
         _elem_frag  := _elem_frag003  ;
         _attr_iter  := _attr_iter003  ;
         _attr_qn    := _attr_qn003    ;
         _attr_prop  := _attr_prop003  ;
         _attr_frag  := _attr_frag003  ;
         _attr_own   := _attr_own003   ;
        } else {
         if (_elem_iter003.count() != 0) 
         { # combine element nodes
          var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
          var shift_factor := int(seqb) - int(_elem_size003.seqbase());
          var merged_result := merged_union (_elem_iter003.chk_order(), _elem_iter.chk_order(), _elem_size003, _elem_size, _elem_level003, _elem_level, _elem_kind003, _elem_kind, _elem_prop003, _elem_prop, _elem_frag003, _elem_frag, _elem_size003.mark(seqb), _elem_size.mirror());
          _elem_iter := merged_result.fetch(0);
          _elem_size := merged_result.fetch(1);
          _elem_level:= merged_result.fetch(2);
          _elem_kind := merged_result.fetch(3);
          _elem_prop := merged_result.fetch(4);
          _elem_frag := merged_result.fetch(5);
          var preNew_preOld := merged_result.fetch(6);
          _attr_own003 := _attr_own003.[int]().[+](shift_factor).[oid]();
          merged_result := merged_union (_attr_iter003, _attr_iter, _attr_qn003, _attr_qn, _attr_prop003, _attr_prop, _attr_frag003, _attr_frag, _attr_own003, _attr_own);
          _attr_iter := merged_result.fetch(0);
          _attr_qn   := merged_result.fetch(1);
          _attr_prop := merged_result.fetch(2);
          _attr_frag := merged_result.fetch(3);
          _attr_own  := merged_result.fetch(4);
          _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
          _attr_own := _attr_own.tmark(0@0);
         }
        } # combine element nodes
        # end of translateSeq_node (f, counter)
       } # end of deleteResult_node3 ()
       { # loop_liftedElemConstr (counter)
        var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
        iter_size := {count}(iter_size, iter002.tunique(), FALSE);
        var root_iter  := iter_size.hmark(0@0).chk_order();
        var root_size  := iter_size.tmark(0@0);
        var root_prop  := iter002.reverse().leftfetchjoin(item002);
        if (not(is_constant(root_prop))) {
         root_prop  := root_prop.tmark(0@0);
        }
        {
         var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
         _elem_iter  := merged_result.fetch(0);
         _elem_size  := merged_result.fetch(1);
         _elem_level := merged_result.fetch(2);
         _elem_kind  := merged_result.fetch(3);
         _elem_prop  := merged_result.fetch(4);
         _elem_frag  := merged_result.fetch(5);
         var preNew_preOld := merged_result.fetch(6);
         _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
         _attr_own := _attr_own.tmark(0@0);
        }
        { # create attribute root entries
         var root_item := _elem_level.ord_uselect(chr(0));
         root_item := root_item.hmark(0@0);
         var iter_item := iter002.reverse().leftfetchjoin(root_item);
         var attr_own := _r_attr_iter.leftjoin(iter_item);
         if (_r_attr_iter.count() != 0) { # test uniqueness
          var sorting := _r_attr_iter.tsort();
          sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
          var unq_attrs := sorting.tunique();
          if (unq_attrs.count() != _r_attr_iter.count()) {
           item002 := materialize(item002,ipik002);
           if (item002.count() > 0) {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item002.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
           } else {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
          }
         } # end of test uniqueness
         if (_attr_iter.count() = 0) {
          _attr_iter := _r_attr_iter;
          _attr_qn   := _r_attr_qn;
          _attr_prop := _r_attr_prop;
          _attr_frag := _r_attr_frag;
          _attr_own  := attr_own.tmark(0@0);
         } else {
          var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
          _r_attr_iter := _r_attr_iter.tmark(seqb);
          _r_attr_qn   := _r_attr_qn  .tmark(seqb);
          _r_attr_prop := _r_attr_prop.tmark(seqb);
          _r_attr_frag := _r_attr_frag.tmark(seqb);
          attr_own := attr_own.tmark(seqb);
          _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
          _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
          _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
          _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
          _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
         }
         _r_attr_iter := empty_bat;
         _r_attr_qn   := empty_bat;
         _r_attr_prop := empty_bat;
         _r_attr_frag := empty_bat;
        } # end of create attribute root entries
        {
         var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
         var preOld_preNew := _elem_size.mark(seqb);
         _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
         _elem_size  := _elem_size.tmark(seqb);
         _elem_level := _elem_level.tmark(seqb);
         _elem_kind  := _elem_kind.tmark(seqb);
         _elem_prop  := _elem_prop.tmark(seqb);
         _elem_frag  := _elem_frag.tmark(seqb);
        }
        ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
        ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
        ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
        ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
        ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
        {
         var knd := ELEMENT;
         while ( knd <= DOCUMENT ) {
          var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
          ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
          if ( knd = ELEMENT ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
          }
          if ( knd = PI ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
          }
          knd :+= chr(1);
         }
        }
        var roots := _elem_level.ord_uselect(chr(0));
        roots := roots.hmark(0@0);
        {
         var height := int(_elem_level.max());
         ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
        }
        { # adding new fragments to the WS_FRAG bat
         var seqb := oid(count(ws.fetch(WS_FRAG)));
         var new_pres := roots.tmark(seqb);
         ws.fetch(WS_FRAG).insert(new_pres);
        }
        iter := iter002;
        item := roots;
        ipik := item;
        kind := ELEM;
        { # add attribute subtree copies to WS
         var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
         _attr_qn   := _attr_qn  .tmark(seqb);
         _attr_prop := _attr_prop.tmark(seqb);
         _attr_own  := _attr_own .tmark(seqb);
         _attr_frag := _attr_frag.tmark(seqb);
         ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
         ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
         ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
         ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
        } # end of add attribute subtree copies to WS
       } # end of loop_liftedElemConstr (counter)
      } # end of deleteResult2 ()
     } else { # translateEmpty ()
      ipik := empty_bat;
      iter := empty_bat;
      item := empty_bat;
      kind := empty_kind_bat;
     }
     if (skip = 0) {
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
     } # cleanUpLevel ()
    } # end of translateIfThen
   } # end of ifthenelse-translation
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn5DFC73FE_q12_xs_string1_xs_integer1_xs_double1
PROC fn679BDA41_q13_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q13
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761090@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "australia");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, "", "item");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  pos := 1@0;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_pos001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761063@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
   v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761091@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb := oid(v_pos001.count());
    pos := pos.materialize(ipik);
    v_pos001 := v_pos001.insert(pos.tmark(seqb));
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # tagname-translation
   var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
   var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
   var itemID;
   if (prop_str.texist("item")) {
    itemID := prop_str.reverse().find("item");
   } else {
    itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
    ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
    ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
    ws.fetch(QN_LOC).fetch(WS).insert(itemID,"item");
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
    ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"item"+str('\1')+"");
   } # translateConst (kind)
   iter := loop001.tmark(0@0);
   ipik := iter;
   pos := 1@0;
   item := itemID;
   kind := QNAME;
  } # end of tagname-translation
  { # saveResult1 () : int
   var ipik001 := ipik;
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # tagname-translation
    var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
    var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    var itemID;
    if (prop_str.texist("name")) {
     itemID := prop_str.reverse().find("name");
    } else {
     itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
     ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
     ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
     ws.fetch(QN_LOC).fetch(WS).insert(itemID,"name");
     ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
     ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"name"+str('\1')+"");
    } # translateConst (kind)
    iter := loop001.tmark(0@0);
    ipik := iter;
    pos := 1@0;
    item := itemID;
    kind := QNAME;
   } # end of tagname-translation
   { # saveResult2 () : int
    var ipik002 := ipik;
    var iter002 := iter;
    var item002 := item; # end of saveResult2 () : int
    { # translateVar (i)
     var vid := v_vid001.ord_uselect(1303761091@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (i)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     pos  := tmark_grp_unique(iter,ipik);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    if (ipik.count() != 0) 
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer002 := iter;
     iter := iter.mark(1@0);
     var inner002 := iter;
     pos := 1@0;
     var v_vid002;
     var v_iter002;
     var v_pos002;
     var v_item002;
     var v_kind002;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(1303761064@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid001.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
      v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     } else { # createNewVarTable ()
      v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_pos002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,1303761092@0);
      { # append (vid, level)
       var seqb := oid(v_vid002.count());
       vid := vid.materialize(ipik);
       v_vid002 := v_vid002.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter002.count());
       iter := iter.materialize(ipik);
       v_iter002 := v_iter002.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb := oid(v_pos002.count());
       pos := pos.materialize(ipik);
       v_pos002 := v_pos002.insert(pos.tmark(seqb));
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item002.count());
       item := item.materialize(ipik);
       v_item002 := v_item002.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb := oid(v_kind002.count());
       kind := kind.materialize(ipik);
       v_kind002 := v_kind002.insert(kind.tmark(seqb));
      } # append (kind, level)
     } # end of insertVar (vid)
     { # translateVar (#pf:v_1906)
      var vid := v_vid002.ord_uselect(1303761092@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter002);
      item := vid.leftfetchjoin(v_item002);
      kind := vid.leftfetchjoin(v_kind002);
      ipik := iter;
     } # end of translateVar (#pf:v_1906)
     { # string-value
      var input_iter := iter;
      kind := kind.materialize(ipik);
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      var kind_elem := kind.get_type(ELEM);
      var item_str;
      if (kind_elem.count() = kind.count()) {
       var frag := kind.get_fragment();
       var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
       var t_iter := res_scj.fetch(0);
       var t_item := res_scj.fetch(1);
       var t_frag := res_scj.fetch(2);
       var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var t_iter_unq := t_iter.tunique();
       t_iter := t_iter.materialize(t_item);
       if (t_iter_unq.count() != t_item.count()) {
        var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
        iter_item := iter_item.string_join(t_iter_unq.project(""));
        t_iter := iter_item.hmark(0@0);
        t_item_str := iter_item.tmark(0@0);
       }
       var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
       if (c_map.count() > 0) { #process comments 
        var c_iter := c_map.leftfetchjoin(iter);
        var c_item := c_map.leftfetchjoin(item);
        var c_frag := c_map.leftfetchjoin(frag);
        var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
        var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of comment processing
       var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
       if (pi_map.count() > 0) { #process processing-instructions 
        var pi_iter := pi_map.leftfetchjoin(iter);
        var pi_item := pi_map.leftfetchjoin(item);
        var pi_frag := pi_map.leftfetchjoin(frag);
        var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
        var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
        t_item_str := res_mu.fetch(1);
       } # end of processing-instruction processing
       iter := t_iter;
       item_str := t_item_str;
      } else {
       var kind_attr := kind.get_type(ATTR);
       if (kind_attr.count() = kind.count()) {
        var frag := kind.get_fragment();
        item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
       } else {
        kind_attr := kind_attr.hmark(0@0);
        var item_attr := kind_attr.leftfetchjoin(item);
        var iter_attr := kind_attr.leftfetchjoin(iter);
        var frag := kind_attr.leftfetchjoin(kind).get_fragment();
        var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        kind_elem := kind_elem.hmark(0@0);
        iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
        frag := kind_elem.leftfetchjoin(kind).get_fragment();
        item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
        t_iter := iter_item.hmark(0@0);
        t_item_str := iter_item.tmark(0@0);
        var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
        iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
        {
         var item_unq := iter_item.reverse().tunique();
         if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
        }
        t_iter := iter_item.hmark(0@0);
        var t_item_str := iter_item.tmark(0@0);
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       }
      }
      item_str_ := item_str;
      if (iter.count() != input_iter.tunique().count()) {
       var difference := reverse(input_iter.tdiff(iter));
       difference := difference.hmark(0@0);
       var res_mu := merged_union(iter, difference, item_str_, "");
       iter := res_mu.fetch(0);
       item_str_ := res_mu.fetch(1);
      }
      ipik := iter;
      kind := STR;
     } # end of string-value
     { # mapBack ()
      var iter_oidMap := inner002.reverse();
      var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
      iter := oid_oidMap.leftfetchjoin(outer002);
      pos := tmark_grp_unique(iter,ipik); # item := item;
      # kind := kind;
      # ipik := ipik;
     } # end of mapBack ()
     # cleanUpLevel ()
    } # end of for-translation
    { # saveResult3 () : int
     var ipik003 := ipik;
     var iter003 := iter;
     var item_str_003 := item_str_; # end of saveResult3 () : int
     iter := loop001.tmark(0@0);
     ipik := iter;
     item_str_ := " ";
     { # string-join (string*, string)
      var iter_item_str := iter003.materialize(ipik003).reverse();
      iter_item_str := iter_item_str.leftfetchjoin(item_str_003).materialize(iter_item_str).chk_order();
      var iter_sep_str := iter.materialize(ipik).reverse();
      iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
      iter_item_str := string_join(iter_item_str, iter_sep_str);
      iter := iter_item_str.hmark(0@0);
      iter_item_str := iter_item_str.tmark(0@0);
      item_str_ := iter_item_str;
     } # end of string-join (string*, string)
    } # end of deleteResult3 ()
    { # loop_liftedAttrConstr (int i)
     if (iter002.count() != loop001.count()) {
      ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
     }
     if (iter.count() != loop001.count()) {
      var difference := reverse(loop001.tdiff(iter));
      difference := difference.hmark(0@0);
      var res_mu := merged_union(iter, difference, item_str_, "");
      item_str_ := res_mu.fetch(1);
     }
     var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
     var unq := item_str_.tunique().hmark(0@0);
     var unq_str := unq;
     var str_unq := reverse(unq_str.tdiff(ws_prop_val));
     var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
     unq_str := str_unq.hmark(seqb);
     ws_prop_val := ws_prop_val.insert(unq_str);
     var strings := item_str_.materialize(loop001);
     var attr_oid := strings.leftjoin(ws_prop_val.reverse());
     { # translateEmpty_node ()
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of translateEmpty_node ()
     attr_oid := attr_oid.tmark(0@0);
     _r_attr_iter := iter002;
     _r_attr_qn   := item002.materialize(ipik002);
     _r_attr_prop := attr_oid;
     _r_attr_frag := attr_oid.project(WS);
    } # end of loop_liftedAttrConstr (int i)
   } # end of deleteResult2 ()
   { # saveResult_node2 () : int
    var _elem_iter002   := _elem_iter  ;
    var _elem_size002   := _elem_size  ;
    var _elem_level002  := _elem_level ;
    var _elem_kind002   := _elem_kind  ;
    var _elem_prop002   := _elem_prop  ;
    var _elem_frag002   := _elem_frag  ;
    var _attr_iter002   := _attr_iter  ;
    var _attr_qn002     := _attr_qn    ;
    var _attr_prop002   := _attr_prop  ;
    var _attr_frag002   := _attr_frag  ;
    var _attr_own002    := _attr_own   ;
    var _r_attr_iter002 := _r_attr_iter;
    var _r_attr_qn002   := _r_attr_qn  ;
    var _r_attr_prop002 := _r_attr_prop;
    var _r_attr_frag002 := _r_attr_frag; # end of saveResult_node2 () : int
    { # translateVar (i)
     var vid := v_vid001.ord_uselect(1303761091@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (i)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "description");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    { # map2NODE_interface (counter)
     kind := kind.materialize(ipik);
     var attr := kind.get_type(ATTR).hmark(0@0);
     var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
     var attr_item := attr.leftfetchjoin(item);
     var attr_frag := attr.leftfetchjoin(kind).get_fragment();
     _r_attr_iter := attr_iter;
     _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
     _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
     _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
     var nodes := kind.get_type(ELEM);
     if (nodes.count() != 0) {
      var oid_oid := nodes.hmark(0@0);
      var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
      var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
      var iter_input := oid_oid.mirror();
      var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
      var res_iter := res_scj.fetch(0);
      var res_item := res_scj.fetch(1);
      var res_frag := res_scj.fetch(2);
      _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
      _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
      _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
      _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
      _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
      var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
      var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
      nodes := res_item.mark(0@0);
      var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      root_level := nodes.leftfetchjoin(root_level);
      temp_ec_item := res_item;
      temp_ec_frag := res_frag;
      var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      content_level := nodes.leftfetchjoin(content_level);
      content_level := content_level.[-](root_level);
      content_level := content_level.tmark(0@0);
      _elem_level := content_level;
      { # create attribute subtree copies
       var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
       var oid_attr := temp_attr.tmark(0@0);
       var oid_frag;
       if (is_constant(res_frag)) {
        oid_frag := res_frag;
       } else {
        oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
        oid_frag := oid_frag.tmark(0@0);
       }
       _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
       _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
       _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
       _attr_own  := temp_attr.hmark(0@0);
       _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
      } # end of create attribute subtree copies
     } else { # if (nodes.count() != 0) ...
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of else in 'if (nodes.count() != 0)'
    } # end of map2NODE_interface (counter)
    # translateSeq_node (f, counter)
    if (_r_attr_iter.count() = 0) {
     _r_attr_iter := _r_attr_iter002;
     _r_attr_qn := _r_attr_qn002;
     _r_attr_prop := _r_attr_prop002;
     _r_attr_frag := _r_attr_frag002;
    } else {
     if (_r_attr_iter002.count() != 0) 
     { # combine attribute roots
      var merged_result := merged_union (_r_attr_iter002.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn002, _r_attr_qn, _r_attr_prop002, _r_attr_prop, _r_attr_frag002, _r_attr_frag);
      _r_attr_iter := merged_result.fetch(0);
      _r_attr_qn := merged_result.fetch(1);
      _r_attr_prop := merged_result.fetch(2);
      _r_attr_frag := merged_result.fetch(3);
     }
    } # end of combine attribute roots
    if (_elem_iter.count() = 0) {
     _elem_iter  := _elem_iter002  ;
     _elem_size  := _elem_size002  ;
     _elem_level := _elem_level002 ;
     _elem_kind  := _elem_kind002  ;
     _elem_prop  := _elem_prop002  ;
     _elem_frag  := _elem_frag002  ;
     _attr_iter  := _attr_iter002  ;
     _attr_qn    := _attr_qn002    ;
     _attr_prop  := _attr_prop002  ;
     _attr_frag  := _attr_frag002  ;
     _attr_own   := _attr_own002   ;
    } else {
     if (_elem_iter002.count() != 0) 
     { # combine element nodes
      var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
      var shift_factor := int(seqb) - int(_elem_size002.seqbase());
      var merged_result := merged_union (_elem_iter002.chk_order(), _elem_iter.chk_order(), _elem_size002, _elem_size, _elem_level002, _elem_level, _elem_kind002, _elem_kind, _elem_prop002, _elem_prop, _elem_frag002, _elem_frag, _elem_size002.mark(seqb), _elem_size.mirror());
      _elem_iter := merged_result.fetch(0);
      _elem_size := merged_result.fetch(1);
      _elem_level:= merged_result.fetch(2);
      _elem_kind := merged_result.fetch(3);
      _elem_prop := merged_result.fetch(4);
      _elem_frag := merged_result.fetch(5);
      var preNew_preOld := merged_result.fetch(6);
      _attr_own002 := _attr_own002.[int]().[+](shift_factor).[oid]();
      merged_result := merged_union (_attr_iter002, _attr_iter, _attr_qn002, _attr_qn, _attr_prop002, _attr_prop, _attr_frag002, _attr_frag, _attr_own002, _attr_own);
      _attr_iter := merged_result.fetch(0);
      _attr_qn   := merged_result.fetch(1);
      _attr_prop := merged_result.fetch(2);
      _attr_frag := merged_result.fetch(3);
      _attr_own  := merged_result.fetch(4);
      _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
      _attr_own := _attr_own.tmark(0@0);
     }
    } # combine element nodes
    # end of translateSeq_node (f, counter)
   } # end of deleteResult_node2 ()
   { # loop_liftedElemConstr (counter)
    var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
    iter_size := {count}(iter_size, iter001.tunique(), FALSE);
    var root_iter  := iter_size.hmark(0@0).chk_order();
    var root_size  := iter_size.tmark(0@0);
    var root_prop  := iter001.reverse().leftfetchjoin(item001);
    if (not(is_constant(root_prop))) {
     root_prop  := root_prop.tmark(0@0);
    }
    {
     var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
     _elem_iter  := merged_result.fetch(0);
     _elem_size  := merged_result.fetch(1);
     _elem_level := merged_result.fetch(2);
     _elem_kind  := merged_result.fetch(3);
     _elem_prop  := merged_result.fetch(4);
     _elem_frag  := merged_result.fetch(5);
     var preNew_preOld := merged_result.fetch(6);
     _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
     _attr_own := _attr_own.tmark(0@0);
    }
    { # create attribute root entries
     var root_item := _elem_level.ord_uselect(chr(0));
     root_item := root_item.hmark(0@0);
     var iter_item := iter001.reverse().leftfetchjoin(root_item);
     var attr_own := _r_attr_iter.leftjoin(iter_item);
     if (_r_attr_iter.count() != 0) { # test uniqueness
      var sorting := _r_attr_iter.tsort();
      sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
      var unq_attrs := sorting.tunique();
      if (unq_attrs.count() != _r_attr_iter.count()) {
       item001 := materialize(item001,ipik001);
       if (item001.count() > 0) {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item001.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
       } else {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
       }
      }
     } # end of test uniqueness
     if (_attr_iter.count() = 0) {
      _attr_iter := _r_attr_iter;
      _attr_qn   := _r_attr_qn;
      _attr_prop := _r_attr_prop;
      _attr_frag := _r_attr_frag;
      _attr_own  := attr_own.tmark(0@0);
     } else {
      var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
      _r_attr_iter := _r_attr_iter.tmark(seqb);
      _r_attr_qn   := _r_attr_qn  .tmark(seqb);
      _r_attr_prop := _r_attr_prop.tmark(seqb);
      _r_attr_frag := _r_attr_frag.tmark(seqb);
      attr_own := attr_own.tmark(seqb);
      _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
      _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
      _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
      _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
      _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
     }
     _r_attr_iter := empty_bat;
     _r_attr_qn   := empty_bat;
     _r_attr_prop := empty_bat;
     _r_attr_frag := empty_bat;
    } # end of create attribute root entries
    {
     var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
     var preOld_preNew := _elem_size.mark(seqb);
     _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
     _elem_size  := _elem_size.tmark(seqb);
     _elem_level := _elem_level.tmark(seqb);
     _elem_kind  := _elem_kind.tmark(seqb);
     _elem_prop  := _elem_prop.tmark(seqb);
     _elem_frag  := _elem_frag.tmark(seqb);
    }
    ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
    ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
    ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
    ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
    ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
    {
     var knd := ELEMENT;
     while ( knd <= DOCUMENT ) {
      var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
      ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
      if ( knd = ELEMENT ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
      }
      if ( knd = PI ) {
       var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
      }
      knd :+= chr(1);
     }
    }
    var roots := _elem_level.ord_uselect(chr(0));
    roots := roots.hmark(0@0);
    {
     var height := int(_elem_level.max());
     ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
    }
    { # adding new fragments to the WS_FRAG bat
     var seqb := oid(count(ws.fetch(WS_FRAG)));
     var new_pres := roots.tmark(seqb);
     ws.fetch(WS_FRAG).insert(new_pres);
    }
    iter := iter001;
    item := roots;
    ipik := item;
    kind := ELEM;
    { # add attribute subtree copies to WS
     var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
     _attr_qn   := _attr_qn  .tmark(seqb);
     _attr_prop := _attr_prop.tmark(seqb);
     _attr_own  := _attr_own .tmark(seqb);
     _attr_frag := _attr_frag.tmark(seqb);
     ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
     ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
     ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
     ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
    } # end of add attribute subtree copies to WS
   } # end of loop_liftedElemConstr (counter)
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn679BDA41_q13_xs_string1
PROC fn9447651E_q14_xs_string1_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q14
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761093@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "item");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  var order_001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  pos := 1@0;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_pos001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761065@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
   v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761095@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb := oid(v_pos001.count());
    pos := pos.materialize(ipik);
    v_pos001 := v_pos001.insert(pos.tmark(seqb));
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (i)
   var vid := v_vid001.ord_uselect(1303761095@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (i)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "description");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  if (iter.tunique().count() != loop001.count()) {
   ERROR ("err:FORG0005: function fn:exactly-one expects exactly one value.");
  }
  { # string-value
   var input_iter := iter;
   kind := kind.materialize(ipik);
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   var kind_elem := kind.get_type(ELEM);
   var item_str;
   if (kind_elem.count() = kind.count()) {
    var frag := kind.get_fragment();
    var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
    var t_iter := res_scj.fetch(0);
    var t_item := res_scj.fetch(1);
    var t_frag := res_scj.fetch(2);
    var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
    var t_iter_unq := t_iter.tunique();
    t_iter := t_iter.materialize(t_item);
    if (t_iter_unq.count() != t_item.count()) {
     var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
     iter_item := iter_item.string_join(t_iter_unq.project(""));
     t_iter := iter_item.hmark(0@0);
     t_item_str := iter_item.tmark(0@0);
    }
    var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
    if (c_map.count() > 0) { #process comments 
     var c_iter := c_map.leftfetchjoin(iter);
     var c_item := c_map.leftfetchjoin(item);
     var c_frag := c_map.leftfetchjoin(frag);
     var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
     var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
     t_iter := res_mu.fetch(0);
     t_item_str := res_mu.fetch(1);
    } # end of comment processing
    var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
    if (pi_map.count() > 0) { #process processing-instructions 
     var pi_iter := pi_map.leftfetchjoin(iter);
     var pi_item := pi_map.leftfetchjoin(item);
     var pi_frag := pi_map.leftfetchjoin(frag);
     var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
     var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
     t_item_str := res_mu.fetch(1);
    } # end of processing-instruction processing
    iter := t_iter;
    item_str := t_item_str;
   } else {
    var kind_attr := kind.get_type(ATTR);
    if (kind_attr.count() = kind.count()) {
     var frag := kind.get_fragment();
     item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
    } else {
     kind_attr := kind_attr.hmark(0@0);
     var item_attr := kind_attr.leftfetchjoin(item);
     var iter_attr := kind_attr.leftfetchjoin(iter);
     var frag := kind_attr.leftfetchjoin(kind).get_fragment();
     var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
     kind_elem := kind_elem.hmark(0@0);
     iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
     frag := kind_elem.leftfetchjoin(kind).get_fragment();
     item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
     var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
     var t_iter := res_scj.fetch(0);
     var t_item := res_scj.fetch(1);
     var t_frag := res_scj.fetch(2);
     var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
     var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
     t_iter := iter_item.hmark(0@0);
     t_item_str := iter_item.tmark(0@0);
     var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
     t_iter := res_mu.fetch(0);
     t_item_str := res_mu.fetch(1);
     iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
     {
      var item_unq := iter_item.reverse().tunique();
      if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
     }
     t_iter := iter_item.hmark(0@0);
     var t_item_str := iter_item.tmark(0@0);
     var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
     if (c_map.count() > 0) { #process comments 
      var c_iter := c_map.leftfetchjoin(iter);
      var c_item := c_map.leftfetchjoin(item);
      var c_frag := c_map.leftfetchjoin(frag);
      var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
      var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
     } # end of comment processing
     var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
     if (pi_map.count() > 0) { #process processing-instructions 
      var pi_iter := pi_map.leftfetchjoin(iter);
      var pi_item := pi_map.leftfetchjoin(item);
      var pi_frag := pi_map.leftfetchjoin(frag);
      var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
      var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
      t_iter := res_mu.fetch(0);
      t_item_str := res_mu.fetch(1);
     } # end of processing-instruction processing
     iter := t_iter;
     item_str := t_item_str;
    }
   }
   item_str_ := item_str;
   if (iter.count() != input_iter.tunique().count()) {
    var difference := reverse(input_iter.tdiff(iter));
    difference := difference.hmark(0@0);
    var res_mu := merged_union(iter, difference, item_str_, "");
    iter := res_mu.fetch(0);
    item_str_ := res_mu.fetch(1);
   }
   ipik := iter;
   pos := tmark_grp_unique(iter,ipik);
   kind := STR;
  } # end of string-value
  { # saveResult1 () : int
   var iter001 := iter;
   var item_str_001 := item_str_; # end of saveResult1 () : int
   { # translateVar (kind)
    var vid := v_vid001.ord_uselect(1303761094@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter001);
    item := vid.leftfetchjoin(v_item001);
   } # end of translateVar (kind)
   item_str_ := item.leftfetchjoin(str_values);
   { # fn:contains (string?, string?) as boolean
    var strings;
    if (iter001.count() != loop001.count()) {
     var difference := reverse(loop001.tdiff(iter001));
     difference := difference.hmark(0@0);
     var res_mu := merged_union(iter001.chk_order(), difference, item_str_001, "");
     strings := res_mu.fetch(1);
    } else {
     strings := item_str_001;
    }
    var search_strs;
    if (iter.count() != loop001.count()) {
     var difference := reverse(loop001.tdiff(iter));
     difference := difference.hmark(0@0);
     var res_mu := merged_union(iter, difference, item_str_, "");
     search_strs := res_mu.fetch(1);
    } else {
     search_strs := item_str_;
    }
    item := [search](strings,search_strs).[!=](-1).[oid]();
    iter := loop001.tmark(0@0);
    ipik := iter;
    pos := 1@0;
    kind := BOOL;
   } # end of fn:contains (string?, string?) as boolean
  } # end of deleteResult1 ()
  { # saveResult1 () : int
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # ifthenelse-translation
    var selected;
    var skip;
    if (type(item001) = bat) {
     selected := item001.ord_uselect(1@0);
     var cnt := selected.count();
     if (item001.count() = cnt) {
      skip := 2;
     } else {
      skip := int(cnt = 0);
     }
    } else {
     skip := 1 + int(item001); # handle constants efficiently
    }
    { # translateIfThen
     var inner002 := inner001;
     var outer002 := outer001;
     var v_vid002 := v_vid001;
     var v_iter002 := v_iter001;
     var v_pos002 := v_pos001;
     var v_item002 := v_item001;
     var v_kind002 := v_kind001;
     if (skip = 0) {
      iter := selected.mirror().join(iter001);
      iter := iter.tmark(0@0);
      outer002 := iter;
      iter := iter.mark(1@0);
      inner002 := iter;
      var expOid := v_iter002.mirror();
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
      v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     }
     if (skip != 1) {
      { # translateVar (i)
       var vid := v_vid002.ord_uselect(1303761095@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (i)
      { # translateLocsteps (c)
       var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
       iter := res_scj.fetch(0);
       item := res_scj.fetch(1);
       kind := res_scj.fetch(2).set_kind(ELEM);
       ipik := item;
      } # end of translateLocsteps (c)
      { # translateLocsteps (c)
       var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
       iter := res_scj.fetch(0);
       item := res_scj.fetch(1);
       kind := res_scj.fetch(2).set_kind(ELEM);
       ipik := item;
      } # end of translateLocsteps (c)
     } else { # translateEmpty ()
      ipik := empty_bat;
      iter := empty_bat;
      item := empty_bat;
      kind := empty_kind_bat;
     }
     if (skip = 0) {
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
     } # cleanUpLevel ()
    } # end of translateIfThen
   } # end of ifthenelse-translation
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn9447651E_q14_xs_string1_xs_string1
PROC fn67AC1243_q15_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q15
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761096@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "closed_auction");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "annotation");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "description");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "parlist");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "listitem");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "parlist");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "listitem");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "text");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "emph");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "keyword");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  pos := 1@0;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_pos001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761066@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
   v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761097@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb := oid(v_pos001.count());
    pos := pos.materialize(ipik);
    v_pos001 := v_pos001.insert(pos.tmark(seqb));
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # tagname-translation
   var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
   var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
   var itemID;
   if (prop_str.texist("text")) {
    itemID := prop_str.reverse().find("text");
   } else {
    itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
    ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
    ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
    ws.fetch(QN_LOC).fetch(WS).insert(itemID,"text");
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
    ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"text"+str('\1')+"");
   } # translateConst (kind)
   iter := loop001.tmark(0@0);
   ipik := iter;
   pos := 1@0;
   item := itemID;
   kind := QNAME;
  } # end of tagname-translation
  { # saveResult1 () : int
   var ipik001 := ipik;
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # translateVar (a)
    var vid := v_vid001.ord_uselect(1303761097@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter001);
    item := vid.leftfetchjoin(v_item001);
    kind := vid.leftfetchjoin(v_kind001);
    ipik := iter;
   } # end of translateVar (a)
   { # loop_liftedElemConstr (counter)
    var root_level;
    var root_size;
    var root_kind;
    var root_frag;
    var root_prop;
    var preNew_preOld;
    var preNew_frag;
    kind := kind.materialize(ipik);
    var attr := kind.get_type(ATTR).hmark(0@0);
    var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
    var attr_item := attr.leftfetchjoin(item).materialize(attr);
    var attr_frag := attr.leftfetchjoin(kind).get_fragment();
    kind := kind.materialize(ipik);
    var nodes := kind.get_type(ELEM);
    if (nodes.count() != 0) {
     var oid_oid := nodes.hmark(0@0);
     var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
     var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
     var iter_input := oid_oid.mirror();
     var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
     var res_iter := res_scj.fetch(0);
     var res_item := res_scj.fetch(1);
     var res_frag := res_scj.fetch(2);
     var content_iter := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).chk_order();
     var content_size := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
     var content_prop := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
     var content_kind := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
     var content_frag := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
     var content_pre := res_item;
     var content_frag_pre := res_frag;
     var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
     var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
     nodes := res_item.mark(0@0);
     var contentRoot_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
     contentRoot_level := nodes.leftfetchjoin(contentRoot_level);
     temp_ec_item := res_item;
     temp_ec_frag := res_frag;
     var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
     content_level := nodes.leftfetchjoin(content_level);
     content_level := content_level.[-](contentRoot_level);
     content_level := content_level.[+](chr(1));
     content_level := content_level.tmark(0@0);
     {
      var height := int(content_level.max()) + 1;
      ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
     }
     var contentRoot_size := mposjoin(node_items, node_frags, ws.fetch(PRE_SIZE)).[+](1);
     var size_oid := contentRoot_size.reverse();
     size_oid := size_oid.leftfetchjoin(oid_oid);
     var size_iter := size_oid.leftfetchjoin(iter.materialize(ipik));
     var iter_size := size_iter.reverse();
     iter_size := {sum}(iter_size, iter001.tunique());
     root_level := chr(0);
     root_size := iter_size;
     root_kind := ELEMENT;
     root_prop := iter001.materialize(ipik001).reverse();
     root_prop := root_prop.leftfetchjoin(item001).materialize(root_prop);
     root_frag := WS;
     root_size := root_size.tmark(0@0);
     root_prop := root_prop.tmark(0@0);
     var root_iter := iter_size.hmark(0@0).chk_order();
     var root_pre := oid(nil);
     var root_frag_pre := oid(nil);
     {
      var merged_result := merged_union (root_iter, content_iter, root_size, content_size, root_level, content_level, root_kind, content_kind, root_prop, content_prop, root_frag, content_frag, root_pre, content_pre, root_frag_pre, content_frag_pre);
      root_size := merged_result.fetch(1);
      root_level := merged_result.fetch(2);
      root_kind := merged_result.fetch(3);
      root_prop := merged_result.fetch(4);
      root_frag := merged_result.fetch(5);
      root_pre := merged_result.fetch(6);
      root_frag_pre := merged_result.fetch(7);
     }
     preNew_preOld := root_pre;
     preNew_frag := root_frag_pre;
    } else { # if (nodes.count() != 0) ...
     item001 := item001.materialize(ipik001);
     root_level := item001.project(chr(0));
     root_size := item001.project(0);
     root_kind := item001.project(ELEMENT);
     root_prop := item001;
     root_frag := item001.project(WS);
     preNew_preOld := item001.project(nil);
     preNew_preOld := preNew_preOld.tmark(0@0);
     preNew_frag := preNew_preOld.tmark(0@0);
     root_level := root_level.tmark(0@0);
     root_size := root_size.tmark(0@0);
     root_kind := root_kind.tmark(0@0);
     root_prop := root_prop.tmark(0@0);
     root_frag := root_frag.tmark(0@0);
    } # end of else in 'if (nodes.count() != 0)'
    {
     var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
     root_level := root_level.seqbase(seqb);
     root_size := root_size.seqbase(seqb);
     root_kind := root_kind.seqbase(seqb);
     root_prop := root_prop.seqbase(seqb);
     root_frag := root_frag.seqbase(seqb);
     preNew_preOld := preNew_preOld.seqbase(seqb);
     preNew_frag := preNew_frag.seqbase(seqb);
    }
    ws.fetch(PRE_LEVEL).fetch(WS).insert(root_level);
    ws.fetch(PRE_SIZE).fetch(WS).insert(root_size);
    ws.fetch(PRE_KIND).fetch(WS).insert(root_kind);
    ws.fetch(PRE_PROP).fetch(WS).insert(root_prop);
    ws.fetch(PRE_FRAG).fetch(WS).insert(root_frag);
    {
     var knd := ELEMENT;
     while ( knd <= DOCUMENT ) {
      var kind_root := root_kind.ord_uselect(knd).reverse().chk_order();
      ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind_root);
      if ( knd = ELEMENT ) {
       var prop_root := kind_root.reverse().mirror().leftfetchjoin(root_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop_root);
      }
      if ( knd = PI ) {
       var prop_root := kind_root.reverse().mirror().leftfetchjoin(root_prop).reverse().chk_order();
       ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop_root);
      }
      knd :+= chr(1);
     }
    }
    var roots := root_level.ord_uselect(chr(0));
    roots := roots.hmark(0@0);
    { # adding new fragments to the WS_FRAG bat
     var seqb := oid(count(ws.fetch(WS_FRAG)));
     var new_pres := roots.tmark(seqb);
     ws.fetch(WS_FRAG).insert(new_pres);
    }
    iter := iter001;
    item := roots;
    ipik := item;
    kind := ELEM;
    { # create attribute subtree copies
     var content_preNew_preOld := preNew_preOld.ord_select(nil,nil);
     var oid_preOld := content_preNew_preOld.tmark(0@0);
     var oid_preNew := content_preNew_preOld.hmark(0@0);
     var oid_frag := oid_preNew.leftfetchjoin(preNew_frag);
     var temp_attr := mvaljoin(oid_preOld, oid_frag, ws.fetch(ATTR_OWN));
     var oid_attr := temp_attr.tmark(0@0);
     oid_frag := temp_attr.reverse().leftfetchjoin(oid_frag);
     oid_frag := oid_frag.tmark(0@0);
     oid_preNew := temp_attr.reverse().leftfetchjoin(oid_preNew);
     var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
     var attr_qn := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
     var attr_oid := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
     oid_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG));
     attr_qn := attr_qn.seqbase(seqb);
     attr_oid := attr_oid.seqbase(seqb);
     oid_preNew := oid_preNew.tmark(seqb);
     oid_frag := oid_frag.seqbase(seqb);
     ws.fetch(ATTR_QN).fetch(WS).insert(attr_qn);
     ws.fetch(ATTR_PROP).fetch(WS).insert(attr_oid);
     ws.fetch(ATTR_OWN).fetch(WS).insert(oid_preNew);
     ws.fetch(ATTR_FRAG).fetch(WS).insert(oid_frag);
    } # end of create attribute subtree copies
    { # create attribute root entries
     var attr_qn_ := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
     var attr_qn_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
     var sorting := attr_iter.tsort();
     sorting := sorting.CTrefine(mposjoin(attr_qn_,attr_qn_frag,ws.fetch(QN_LOC_URI)));
     var unq_attrs := sorting.tunique();
     if (unq_attrs.count() != attr_iter.count()) {
      if (item001.count() > 0) {
       ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item001.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
      } else {
       ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
      }
     }
     var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
     var attr_qn := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN)).seqbase(seqb);
     var attr_oid := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP)).seqbase(seqb);
     var attr_own := iter001.reverse().leftfetchjoin(roots);
     attr_own := attr_iter.leftjoin(attr_own);
     attr_own := attr_own.tmark(seqb);
     ws.fetch(ATTR_QN).fetch(WS).insert(attr_qn);
     ws.fetch(ATTR_PROP).fetch(WS).insert(attr_oid);
     ws.fetch(ATTR_OWN).fetch(WS).insert(attr_own);
     ws.fetch(ATTR_FRAG).fetch(WS).insert(attr_qn_frag);
    } # end of create attribute root entries
   } # end of loop_liftedElemConstr (counter)
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn67AC1243_q15_xs_string1
PROC fn67B42E4C_q16_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q16
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761098@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "closed_auction");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  var order_001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  pos := 1@0;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_pos001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761067@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
   v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761099@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb := oid(v_pos001.count());
    pos := pos.materialize(ipik);
    v_pos001 := v_pos001.insert(pos.tmark(seqb));
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (a)
   var vid := v_vid001.ord_uselect(1303761099@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (a)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "annotation");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "description");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "parlist");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "listitem");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "parlist");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "listitem");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "text");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "emph");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 3, "", "keyword");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
  } # end of translateLocsteps (c)
  { # translate fn:empty (item*) as boolean
   var iter_count := {count}(iter.reverse(),loop001.reverse(), FALSE);
   var iter_bool := iter_count.[=](0).[oid]();
   item := iter_bool.tmark(0@0);
   iter := loop001.tmark(0@0);
   ipik := iter;
   pos := 1@0;
   kind := BOOL;
  } # end of translate fn:empty (item*) as boolean
  { # saveResult1 () : int
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # ifthenelse-translation
    var selected;
    var skip;
    if (type(item001) = bat) {
     selected := item001.ord_uselect(1@0);
     var cnt := selected.count();
     if (item001.count() = cnt) {
      skip := 2;
     } else {
      skip := int(cnt = 0);
     }
    } else {
     skip := 1 + int(item001); # handle constants efficiently
    }
    { # translateIfThen
     var loop002 := loop001;
     var inner002 := inner001;
     var outer002 := outer001;
     var v_vid002 := v_vid001;
     var v_iter002 := v_iter001;
     var v_pos002 := v_pos001;
     var v_item002 := v_item001;
     var v_kind002 := v_kind001;
     if (skip = 0) {
      selected := item001.ord_uselect(0@0);
      iter := selected.mirror().join(iter001);
      iter := iter.tmark(0@0);
      outer002 := iter;
      iter := iter.mark(1@0);
      inner002 := iter;
      loop002 := inner002;
      var expOid := v_iter002.mirror();
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
      v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     }
     if (skip != 2) {
      { # tagname-translation
       var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
       var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
       var itemID;
       if (prop_str.texist("person")) {
        itemID := prop_str.reverse().find("person");
       } else {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
        ws.fetch(QN_LOC).fetch(WS).insert(itemID,"person");
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"person"+str('\1')+"");
       } # translateConst (kind)
       iter := loop002.tmark(0@0);
       ipik := iter;
       pos := 1@0;
       item := itemID;
       kind := QNAME;
      } # end of tagname-translation
      { # saveResult2 () : int
       var ipik002 := ipik;
       var iter002 := iter;
       var item002 := item; # end of saveResult2 () : int
       { # tagname-translation
        var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
        var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
        var itemID;
        if (prop_str.texist("id")) {
         itemID := prop_str.reverse().find("id");
        } else {
         itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
         ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
         ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
         ws.fetch(QN_LOC).fetch(WS).insert(itemID,"id");
         ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
         ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"id"+str('\1')+"");
        } # translateConst (kind)
        iter := loop002.tmark(0@0);
        ipik := iter;
        pos := 1@0;
        item := itemID;
        kind := QNAME;
       } # end of tagname-translation
       { # saveResult3 () : int
        var ipik003 := ipik;
        var iter003 := iter;
        var item003 := item; # end of saveResult3 () : int
        { # translateVar (a)
         var vid := v_vid002.ord_uselect(1303761099@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter002);
         item := vid.leftfetchjoin(v_item002);
         kind := vid.leftfetchjoin(v_kind002);
         ipik := iter;
        } # end of translateVar (a)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "seller");
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         pos  := tmark_grp_unique(iter,ipik);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        { # loop_liftedSCJ (axis, kind, ns, loc)
         { # attribute axis
          var oid_iter := iter;
          var oid_item := item.materialize(ipik);
          var oid_frag := kind.get_fragment();
          var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
          oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
          var oid_attr := temp1.tmark(0@0);
          oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
          var temp1_str; # only needed for name test
          temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
          temp1 := temp1_str.ord_uselect("");
          temp1 := temp1.hmark(0@0);
          oid_attr := temp1.leftfetchjoin(oid_attr);
          oid_frag := temp1.leftfetchjoin(oid_frag);
          oid_iter := temp1.leftfetchjoin(oid_iter);
          temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
          temp1 := temp1_str.ord_uselect("person");
          temp1 := temp1.hmark(0@0);
          oid_attr := temp1.leftfetchjoin(oid_attr);
          oid_frag := temp1.leftfetchjoin(oid_frag);
          oid_iter := temp1.leftfetchjoin(oid_iter);
          iter := oid_iter.tmark(0@0);
          item := oid_attr.tmark(0@0);
          kind := oid_frag.tmark(0@0);
          if (type(iter) = bat) {
           ipik := iter;
          } else {
           if (type(item) = bat) {
            ipik := item;
           } else {
            ipik := kind;
           }
          }
         } # end of attribute axis
         kind := kind.set_kind(ATTR);
        } # end of translateLocsteps (c)
        if (ipik.count() != 0) 
        { # for-translation
         # project ()
         iter := iter.materialize(ipik);
         var outer003 := iter;
         iter := iter.mark(1@0);
         var inner003 := iter;
         pos := 1@0;
         var v_vid003;
         var v_iter003;
         var v_pos003;
         var v_item003;
         var v_kind003;
         var expOid;
         { # getExpanded (fid)
          var vu_nil := vu_fid.ord_uselect(1303761068@0);
          var vid_vu := vu_vid.reverse();
          var oid_nil := vid_vu.leftjoin(vu_nil);
          expOid := v_vid002.leftjoin(oid_nil);
          expOid := expOid.mirror();
         } # end of getExpanded (fid)
         if (expOid.count() != 0) {
          var oidNew_expOid;
          { # expand ()
           var expOid_iter := expOid.leftfetchjoin(v_iter002);
           var iter_expOid := expOid_iter.reverse();
           var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
           var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
           oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
           var expOid_oidMap := oidMap_expOid.reverse();
           expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
           v_iter003 := expOid_iter;
           oidNew_expOid := expOid_iter.hmark(0@0);
          } # end of expand ()
          # join ()
          var cnt := count(v_iter003)*2;
          v_iter003 := v_iter003.tmark(0@0);
          var new_v_iter := v_iter003;
          v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
          var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
          v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
          var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
          v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
          var new_v_item := oidNew_expOid.leftjoin(v_item002);
          v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
          var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
          v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
         } else { # createNewVarTable ()
          v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_pos003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
         }
         { # insertVar (vid)
          var vid := project(ipik,1303761100@0);
          { # append (vid, level)
           var seqb := oid(v_vid003.count());
           vid := vid.materialize(ipik);
           v_vid003 := v_vid003.insert(vid.tmark(seqb));
          } # append (vid, level)
          { # append (iter, level)
           var seqb := oid(v_iter003.count());
           iter := iter.materialize(ipik);
           v_iter003 := v_iter003.insert(iter.tmark(seqb));
          } # append (iter, level)
          { # append (pos, level)
           var seqb := oid(v_pos003.count());
           pos := pos.materialize(ipik);
           v_pos003 := v_pos003.insert(pos.tmark(seqb));
          } # append (pos, level)
          { # append (item, level)
           var seqb := oid(v_item003.count());
           item := item.materialize(ipik);
           v_item003 := v_item003.insert(item.tmark(seqb));
          } # append (item, level)
          { # append (kind, level)
           var seqb := oid(v_kind003.count());
           kind := kind.materialize(ipik);
           v_kind003 := v_kind003.insert(kind.tmark(seqb));
          } # append (kind, level)
         } # end of insertVar (vid)
         { # translateVar (#pf:v_2133)
          var vid := v_vid003.ord_uselect(1303761100@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter003);
          item := vid.leftfetchjoin(v_item003);
          kind := vid.leftfetchjoin(v_kind003);
          ipik := iter;
         } # end of translateVar (#pf:v_2133)
         { # string-value
          var input_iter := iter;
          kind := kind.materialize(ipik);
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          var kind_elem := kind.get_type(ELEM);
          var item_str;
          if (kind_elem.count() = kind.count()) {
           var frag := kind.get_fragment();
           var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
           var t_iter := res_scj.fetch(0);
           var t_item := res_scj.fetch(1);
           var t_frag := res_scj.fetch(2);
           var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
           var t_iter_unq := t_iter.tunique();
           t_iter := t_iter.materialize(t_item);
           if (t_iter_unq.count() != t_item.count()) {
            var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            iter_item := iter_item.string_join(t_iter_unq.project(""));
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
           }
           var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
           if (c_map.count() > 0) { #process comments 
            var c_iter := c_map.leftfetchjoin(iter);
            var c_item := c_map.leftfetchjoin(item);
            var c_frag := c_map.leftfetchjoin(frag);
            var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
            var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
           } # end of comment processing
           var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
           if (pi_map.count() > 0) { #process processing-instructions 
            var pi_iter := pi_map.leftfetchjoin(iter);
            var pi_item := pi_map.leftfetchjoin(item);
            var pi_frag := pi_map.leftfetchjoin(frag);
            var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
            var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
            t_item_str := res_mu.fetch(1);
           } # end of processing-instruction processing
           iter := t_iter;
           item_str := t_item_str;
          } else {
           var kind_attr := kind.get_type(ATTR);
           if (kind_attr.count() = kind.count()) {
            var frag := kind.get_fragment();
            item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
           } else {
            kind_attr := kind_attr.hmark(0@0);
            var item_attr := kind_attr.leftfetchjoin(item);
            var iter_attr := kind_attr.leftfetchjoin(iter);
            var frag := kind_attr.leftfetchjoin(kind).get_fragment();
            var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
            kind_elem := kind_elem.hmark(0@0);
            iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
            frag := kind_elem.leftfetchjoin(kind).get_fragment();
            item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
            var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
            var t_iter := res_scj.fetch(0);
            var t_item := res_scj.fetch(1);
            var t_frag := res_scj.fetch(2);
            var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
            var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
            var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
            iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            {
             var item_unq := iter_item.reverse().tunique();
             if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
            }
            t_iter := iter_item.hmark(0@0);
            var t_item_str := iter_item.tmark(0@0);
            var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
            if (c_map.count() > 0) { #process comments 
             var c_iter := c_map.leftfetchjoin(iter);
             var c_item := c_map.leftfetchjoin(item);
             var c_frag := c_map.leftfetchjoin(frag);
             var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
             var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of comment processing
            var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
            if (pi_map.count() > 0) { #process processing-instructions 
             var pi_iter := pi_map.leftfetchjoin(iter);
             var pi_item := pi_map.leftfetchjoin(item);
             var pi_frag := pi_map.leftfetchjoin(frag);
             var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
             var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of processing-instruction processing
            iter := t_iter;
            item_str := t_item_str;
           }
          }
          item_str_ := item_str;
          if (iter.count() != input_iter.tunique().count()) {
           var difference := reverse(input_iter.tdiff(iter));
           difference := difference.hmark(0@0);
           var res_mu := merged_union(iter, difference, item_str_, "");
           iter := res_mu.fetch(0);
           item_str_ := res_mu.fetch(1);
          }
          ipik := iter;
          kind := STR;
         } # end of string-value
         { # mapBack ()
          var iter_oidMap := inner003.reverse();
          var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
          iter := oid_oidMap.leftfetchjoin(outer003);
          pos := tmark_grp_unique(iter,ipik); # item := item;
          # kind := kind;
          # ipik := ipik;
         } # end of mapBack ()
         # cleanUpLevel ()
        } # end of for-translation
        { # saveResult4 () : int
         var ipik004 := ipik;
         var iter004 := iter;
         var item_str_004 := item_str_; # end of saveResult4 () : int
         iter := loop002.tmark(0@0);
         ipik := iter;
         item_str_ := " ";
         { # string-join (string*, string)
          var iter_item_str := iter004.materialize(ipik004).reverse();
          iter_item_str := iter_item_str.leftfetchjoin(item_str_004).materialize(iter_item_str).chk_order();
          var iter_sep_str := iter.materialize(ipik).reverse();
          iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
          iter_item_str := string_join(iter_item_str, iter_sep_str);
          iter := iter_item_str.hmark(0@0);
          iter_item_str := iter_item_str.tmark(0@0);
          item_str_ := iter_item_str;
         } # end of string-join (string*, string)
        } # end of deleteResult4 ()
        { # loop_liftedAttrConstr (int i)
         if (iter003.count() != loop002.count()) {
          ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
         }
         if (iter.count() != loop002.count()) {
          var difference := reverse(loop002.tdiff(iter));
          difference := difference.hmark(0@0);
          var res_mu := merged_union(iter, difference, item_str_, "");
          item_str_ := res_mu.fetch(1);
         }
         var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
         var unq := item_str_.tunique().hmark(0@0);
         var unq_str := unq;
         var str_unq := reverse(unq_str.tdiff(ws_prop_val));
         var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
         unq_str := str_unq.hmark(seqb);
         ws_prop_val := ws_prop_val.insert(unq_str);
         var strings := item_str_.materialize(loop002);
         var attr_oid := strings.leftjoin(ws_prop_val.reverse());
         { # translateEmpty_node ()
          _elem_iter  := empty_bat;
          _elem_size  := empty_bat.project(int(nil));
          _elem_level := empty_bat.project(chr(nil));
          _elem_kind  := empty_bat.project(chr(nil));
          _elem_prop  := empty_bat;
          _elem_frag  := empty_bat;
          _attr_iter  := empty_bat;
          _attr_qn    := empty_bat;
          _attr_prop  := empty_bat;
          _attr_frag  := empty_bat;
          _attr_own   := empty_bat;
         } # end of translateEmpty_node ()
         attr_oid := attr_oid.tmark(0@0);
         _r_attr_iter := iter003;
         _r_attr_qn   := item003.materialize(ipik003);
         _r_attr_prop := attr_oid;
         _r_attr_frag := attr_oid.project(WS);
        } # end of loop_liftedAttrConstr (int i)
       } # end of deleteResult3 ()
       { # loop_liftedElemConstr (counter)
        var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
        iter_size := {count}(iter_size, iter002.tunique(), FALSE);
        var root_iter  := iter_size.hmark(0@0).chk_order();
        var root_size  := iter_size.tmark(0@0);
        var root_prop  := iter002.reverse().leftfetchjoin(item002);
        if (not(is_constant(root_prop))) {
         root_prop  := root_prop.tmark(0@0);
        }
        {
         var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
         _elem_iter  := merged_result.fetch(0);
         _elem_size  := merged_result.fetch(1);
         _elem_level := merged_result.fetch(2);
         _elem_kind  := merged_result.fetch(3);
         _elem_prop  := merged_result.fetch(4);
         _elem_frag  := merged_result.fetch(5);
         var preNew_preOld := merged_result.fetch(6);
         _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
         _attr_own := _attr_own.tmark(0@0);
        }
        { # create attribute root entries
         var root_item := _elem_level.ord_uselect(chr(0));
         root_item := root_item.hmark(0@0);
         var iter_item := iter002.reverse().leftfetchjoin(root_item);
         var attr_own := _r_attr_iter.leftjoin(iter_item);
         if (_r_attr_iter.count() != 0) { # test uniqueness
          var sorting := _r_attr_iter.tsort();
          sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
          var unq_attrs := sorting.tunique();
          if (unq_attrs.count() != _r_attr_iter.count()) {
           item002 := materialize(item002,ipik002);
           if (item002.count() > 0) {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item002.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
           } else {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
          }
         } # end of test uniqueness
         if (_attr_iter.count() = 0) {
          _attr_iter := _r_attr_iter;
          _attr_qn   := _r_attr_qn;
          _attr_prop := _r_attr_prop;
          _attr_frag := _r_attr_frag;
          _attr_own  := attr_own.tmark(0@0);
         } else {
          var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
          _r_attr_iter := _r_attr_iter.tmark(seqb);
          _r_attr_qn   := _r_attr_qn  .tmark(seqb);
          _r_attr_prop := _r_attr_prop.tmark(seqb);
          _r_attr_frag := _r_attr_frag.tmark(seqb);
          attr_own := attr_own.tmark(seqb);
          _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
          _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
          _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
          _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
          _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
         }
         _r_attr_iter := empty_bat;
         _r_attr_qn   := empty_bat;
         _r_attr_prop := empty_bat;
         _r_attr_frag := empty_bat;
        } # end of create attribute root entries
        {
         var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
         var preOld_preNew := _elem_size.mark(seqb);
         _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
         _elem_size  := _elem_size.tmark(seqb);
         _elem_level := _elem_level.tmark(seqb);
         _elem_kind  := _elem_kind.tmark(seqb);
         _elem_prop  := _elem_prop.tmark(seqb);
         _elem_frag  := _elem_frag.tmark(seqb);
        }
        ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
        ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
        ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
        ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
        ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
        {
         var knd := ELEMENT;
         while ( knd <= DOCUMENT ) {
          var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
          ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
          if ( knd = ELEMENT ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
          }
          if ( knd = PI ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
          }
          knd :+= chr(1);
         }
        }
        var roots := _elem_level.ord_uselect(chr(0));
        roots := roots.hmark(0@0);
        {
         var height := int(_elem_level.max());
         ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
        }
        { # adding new fragments to the WS_FRAG bat
         var seqb := oid(count(ws.fetch(WS_FRAG)));
         var new_pres := roots.tmark(seqb);
         ws.fetch(WS_FRAG).insert(new_pres);
        }
        iter := iter002;
        item := roots;
        ipik := item;
        kind := ELEM;
        { # add attribute subtree copies to WS
         var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
         _attr_qn   := _attr_qn  .tmark(seqb);
         _attr_prop := _attr_prop.tmark(seqb);
         _attr_own  := _attr_own .tmark(seqb);
         _attr_frag := _attr_frag.tmark(seqb);
         ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
         ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
         ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
         ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
        } # end of add attribute subtree copies to WS
       } # end of loop_liftedElemConstr (counter)
      } # end of deleteResult2 ()
     } else { # translateEmpty ()
      ipik := empty_bat;
      iter := empty_bat;
      item := empty_bat;
      kind := empty_kind_bat;
     }
     if (skip = 0) {
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
     } # cleanUpLevel ()
    } # end of translateIfThen
   } # end of ifthenelse-translation
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn67B42E4C_q16_xs_string1
PROC fn67BC4A58_q17_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q17
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761101@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "person");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  var order_001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  pos := 1@0;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_pos001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761069@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
   v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761102@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb := oid(v_pos001.count());
    pos := pos.materialize(ipik);
    v_pos001 := v_pos001.insert(pos.tmark(seqb));
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # translateVar (p)
   var vid := v_vid001.ord_uselect(1303761102@0);
   vid := vid.hmark(0@0);
   iter := vid.leftfetchjoin(v_iter001);
   item := vid.leftfetchjoin(v_item001);
   kind := vid.leftfetchjoin(v_kind001);
   ipik := iter;
  } # end of translateVar (p)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "homepage");
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
   kind := res_scj.fetch(2).set_kind(ELEM);
   ipik := item;
  } # end of translateLocsteps (c)
  { # translateLocsteps (c)
   var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
   item := item.materialize(ipik);
   iter := iter.materialize(ipik);
   res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
   iter := res_scj.fetch(0);
   item := res_scj.fetch(1);
  } # end of translateLocsteps (c)
  { # translate fn:empty (item*) as boolean
   var iter_count := {count}(iter.reverse(),loop001.reverse(), FALSE);
   var iter_bool := iter_count.[=](0).[oid]();
   item := iter_bool.tmark(0@0);
   iter := loop001.tmark(0@0);
   ipik := iter;
   pos := 1@0;
   kind := BOOL;
  } # end of translate fn:empty (item*) as boolean
  { # saveResult1 () : int
   var iter001 := iter;
   var item001 := item; # end of saveResult1 () : int
   { # ifthenelse-translation
    var selected;
    var skip;
    if (type(item001) = bat) {
     selected := item001.ord_uselect(1@0);
     var cnt := selected.count();
     if (item001.count() = cnt) {
      skip := 2;
     } else {
      skip := int(cnt = 0);
     }
    } else {
     skip := 1 + int(item001); # handle constants efficiently
    }
    { # translateIfThen
     var loop002 := loop001;
     var inner002 := inner001;
     var outer002 := outer001;
     var v_vid002 := v_vid001;
     var v_iter002 := v_iter001;
     var v_pos002 := v_pos001;
     var v_item002 := v_item001;
     var v_kind002 := v_kind001;
     if (skip = 0) {
      iter := selected.mirror().join(iter001);
      iter := iter.tmark(0@0);
      outer002 := iter;
      iter := iter.mark(1@0);
      inner002 := iter;
      loop002 := inner002;
      var expOid := v_iter002.mirror();
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
      v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     }
     if (skip != 1) {
      { # tagname-translation
       var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
       var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
       var itemID;
       if (prop_str.texist("person")) {
        itemID := prop_str.reverse().find("person");
       } else {
        itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
        ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
        ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
        ws.fetch(QN_LOC).fetch(WS).insert(itemID,"person");
        ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
        ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"person"+str('\1')+"");
       } # translateConst (kind)
       iter := loop002.tmark(0@0);
       ipik := iter;
       pos := 1@0;
       item := itemID;
       kind := QNAME;
      } # end of tagname-translation
      { # saveResult2 () : int
       var ipik002 := ipik;
       var iter002 := iter;
       var item002 := item; # end of saveResult2 () : int
       { # tagname-translation
        var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
        var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
        var itemID;
        if (prop_str.texist("name")) {
         itemID := prop_str.reverse().find("name");
        } else {
         itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
         ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
         ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
         ws.fetch(QN_LOC).fetch(WS).insert(itemID,"name");
         ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
         ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"name"+str('\1')+"");
        } # translateConst (kind)
        iter := loop002.tmark(0@0);
        ipik := iter;
        pos := 1@0;
        item := itemID;
        kind := QNAME;
       } # end of tagname-translation
       { # saveResult3 () : int
        var ipik003 := ipik;
        var iter003 := iter;
        var item003 := item; # end of saveResult3 () : int
        { # translateVar (p)
         var vid := v_vid002.ord_uselect(1303761102@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter002);
         item := vid.leftfetchjoin(v_item002);
         kind := vid.leftfetchjoin(v_kind002);
         ipik := iter;
        } # end of translateVar (p)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        { # translateLocsteps (c)
         var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
         iter := res_scj.fetch(0);
         item := res_scj.fetch(1);
         pos  := tmark_grp_unique(iter,ipik);
         kind := res_scj.fetch(2).set_kind(ELEM);
         ipik := item;
        } # end of translateLocsteps (c)
        if (ipik.count() != 0) 
        { # for-translation
         # project ()
         iter := iter.materialize(ipik);
         var outer003 := iter;
         iter := iter.mark(1@0);
         var inner003 := iter;
         pos := 1@0;
         var v_vid003;
         var v_iter003;
         var v_pos003;
         var v_item003;
         var v_kind003;
         var expOid;
         { # getExpanded (fid)
          var vu_nil := vu_fid.ord_uselect(1303761070@0);
          var vid_vu := vu_vid.reverse();
          var oid_nil := vid_vu.leftjoin(vu_nil);
          expOid := v_vid002.leftjoin(oid_nil);
          expOid := expOid.mirror();
         } # end of getExpanded (fid)
         if (expOid.count() != 0) {
          var oidNew_expOid;
          { # expand ()
           var expOid_iter := expOid.leftfetchjoin(v_iter002);
           var iter_expOid := expOid_iter.reverse();
           var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
           var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
           oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
           var expOid_oidMap := oidMap_expOid.reverse();
           expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
           v_iter003 := expOid_iter;
           oidNew_expOid := expOid_iter.hmark(0@0);
          } # end of expand ()
          # join ()
          var cnt := count(v_iter003)*2;
          v_iter003 := v_iter003.tmark(0@0);
          var new_v_iter := v_iter003;
          v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
          var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
          v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
          var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
          v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
          var new_v_item := oidNew_expOid.leftjoin(v_item002);
          v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
          var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
          v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
         } else { # createNewVarTable ()
          v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_pos003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
          v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
         }
         { # insertVar (vid)
          var vid := project(ipik,1303761103@0);
          { # append (vid, level)
           var seqb := oid(v_vid003.count());
           vid := vid.materialize(ipik);
           v_vid003 := v_vid003.insert(vid.tmark(seqb));
          } # append (vid, level)
          { # append (iter, level)
           var seqb := oid(v_iter003.count());
           iter := iter.materialize(ipik);
           v_iter003 := v_iter003.insert(iter.tmark(seqb));
          } # append (iter, level)
          { # append (pos, level)
           var seqb := oid(v_pos003.count());
           pos := pos.materialize(ipik);
           v_pos003 := v_pos003.insert(pos.tmark(seqb));
          } # append (pos, level)
          { # append (item, level)
           var seqb := oid(v_item003.count());
           item := item.materialize(ipik);
           v_item003 := v_item003.insert(item.tmark(seqb));
          } # append (item, level)
          { # append (kind, level)
           var seqb := oid(v_kind003.count());
           kind := kind.materialize(ipik);
           v_kind003 := v_kind003.insert(kind.tmark(seqb));
          } # append (kind, level)
         } # end of insertVar (vid)
         { # translateVar (#pf:v_2189)
          var vid := v_vid003.ord_uselect(1303761103@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter003);
          item := vid.leftfetchjoin(v_item003);
          kind := vid.leftfetchjoin(v_kind003);
          ipik := iter;
         } # end of translateVar (#pf:v_2189)
         { # string-value
          var input_iter := iter;
          kind := kind.materialize(ipik);
          item := item.materialize(ipik);
          iter := iter.materialize(ipik);
          var kind_elem := kind.get_type(ELEM);
          var item_str;
          if (kind_elem.count() = kind.count()) {
           var frag := kind.get_fragment();
           var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
           var t_iter := res_scj.fetch(0);
           var t_item := res_scj.fetch(1);
           var t_frag := res_scj.fetch(2);
           var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
           var t_iter_unq := t_iter.tunique();
           t_iter := t_iter.materialize(t_item);
           if (t_iter_unq.count() != t_item.count()) {
            var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            iter_item := iter_item.string_join(t_iter_unq.project(""));
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
           }
           var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
           if (c_map.count() > 0) { #process comments 
            var c_iter := c_map.leftfetchjoin(iter);
            var c_item := c_map.leftfetchjoin(item);
            var c_frag := c_map.leftfetchjoin(frag);
            var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
            var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
           } # end of comment processing
           var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
           if (pi_map.count() > 0) { #process processing-instructions 
            var pi_iter := pi_map.leftfetchjoin(iter);
            var pi_item := pi_map.leftfetchjoin(item);
            var pi_frag := pi_map.leftfetchjoin(frag);
            var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
            var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
            t_item_str := res_mu.fetch(1);
           } # end of processing-instruction processing
           iter := t_iter;
           item_str := t_item_str;
          } else {
           var kind_attr := kind.get_type(ATTR);
           if (kind_attr.count() = kind.count()) {
            var frag := kind.get_fragment();
            item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
           } else {
            kind_attr := kind_attr.hmark(0@0);
            var item_attr := kind_attr.leftfetchjoin(item);
            var iter_attr := kind_attr.leftfetchjoin(iter);
            var frag := kind_attr.leftfetchjoin(kind).get_fragment();
            var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
            kind_elem := kind_elem.hmark(0@0);
            iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
            frag := kind_elem.leftfetchjoin(kind).get_fragment();
            item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
            var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
            var t_iter := res_scj.fetch(0);
            var t_item := res_scj.fetch(1);
            var t_frag := res_scj.fetch(2);
            var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
            var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
            t_iter := iter_item.hmark(0@0);
            t_item_str := iter_item.tmark(0@0);
            var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
            iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
            {
             var item_unq := iter_item.reverse().tunique();
             if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
            }
            t_iter := iter_item.hmark(0@0);
            var t_item_str := iter_item.tmark(0@0);
            var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
            if (c_map.count() > 0) { #process comments 
             var c_iter := c_map.leftfetchjoin(iter);
             var c_item := c_map.leftfetchjoin(item);
             var c_frag := c_map.leftfetchjoin(frag);
             var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
             var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of comment processing
            var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
            if (pi_map.count() > 0) { #process processing-instructions 
             var pi_iter := pi_map.leftfetchjoin(iter);
             var pi_item := pi_map.leftfetchjoin(item);
             var pi_frag := pi_map.leftfetchjoin(frag);
             var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
             var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
             t_iter := res_mu.fetch(0);
             t_item_str := res_mu.fetch(1);
            } # end of processing-instruction processing
            iter := t_iter;
            item_str := t_item_str;
           }
          }
          item_str_ := item_str;
          if (iter.count() != input_iter.tunique().count()) {
           var difference := reverse(input_iter.tdiff(iter));
           difference := difference.hmark(0@0);
           var res_mu := merged_union(iter, difference, item_str_, "");
           iter := res_mu.fetch(0);
           item_str_ := res_mu.fetch(1);
          }
          ipik := iter;
          kind := STR;
         } # end of string-value
         { # mapBack ()
          var iter_oidMap := inner003.reverse();
          var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
          iter := oid_oidMap.leftfetchjoin(outer003);
          pos := tmark_grp_unique(iter,ipik); # item := item;
          # kind := kind;
          # ipik := ipik;
         } # end of mapBack ()
         # cleanUpLevel ()
        } # end of for-translation
        { # saveResult4 () : int
         var ipik004 := ipik;
         var iter004 := iter;
         var item_str_004 := item_str_; # end of saveResult4 () : int
         iter := loop002.tmark(0@0);
         ipik := iter;
         item_str_ := " ";
         { # string-join (string*, string)
          var iter_item_str := iter004.materialize(ipik004).reverse();
          iter_item_str := iter_item_str.leftfetchjoin(item_str_004).materialize(iter_item_str).chk_order();
          var iter_sep_str := iter.materialize(ipik).reverse();
          iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
          iter_item_str := string_join(iter_item_str, iter_sep_str);
          iter := iter_item_str.hmark(0@0);
          iter_item_str := iter_item_str.tmark(0@0);
          item_str_ := iter_item_str;
         } # end of string-join (string*, string)
        } # end of deleteResult4 ()
        { # loop_liftedAttrConstr (int i)
         if (iter003.count() != loop002.count()) {
          ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
         }
         if (iter.count() != loop002.count()) {
          var difference := reverse(loop002.tdiff(iter));
          difference := difference.hmark(0@0);
          var res_mu := merged_union(iter, difference, item_str_, "");
          item_str_ := res_mu.fetch(1);
         }
         var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
         var unq := item_str_.tunique().hmark(0@0);
         var unq_str := unq;
         var str_unq := reverse(unq_str.tdiff(ws_prop_val));
         var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
         unq_str := str_unq.hmark(seqb);
         ws_prop_val := ws_prop_val.insert(unq_str);
         var strings := item_str_.materialize(loop002);
         var attr_oid := strings.leftjoin(ws_prop_val.reverse());
         { # translateEmpty_node ()
          _elem_iter  := empty_bat;
          _elem_size  := empty_bat.project(int(nil));
          _elem_level := empty_bat.project(chr(nil));
          _elem_kind  := empty_bat.project(chr(nil));
          _elem_prop  := empty_bat;
          _elem_frag  := empty_bat;
          _attr_iter  := empty_bat;
          _attr_qn    := empty_bat;
          _attr_prop  := empty_bat;
          _attr_frag  := empty_bat;
          _attr_own   := empty_bat;
         } # end of translateEmpty_node ()
         attr_oid := attr_oid.tmark(0@0);
         _r_attr_iter := iter003;
         _r_attr_qn   := item003.materialize(ipik003);
         _r_attr_prop := attr_oid;
         _r_attr_frag := attr_oid.project(WS);
        } # end of loop_liftedAttrConstr (int i)
       } # end of deleteResult3 ()
       { # loop_liftedElemConstr (counter)
        var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
        iter_size := {count}(iter_size, iter002.tunique(), FALSE);
        var root_iter  := iter_size.hmark(0@0).chk_order();
        var root_size  := iter_size.tmark(0@0);
        var root_prop  := iter002.reverse().leftfetchjoin(item002);
        if (not(is_constant(root_prop))) {
         root_prop  := root_prop.tmark(0@0);
        }
        {
         var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
         _elem_iter  := merged_result.fetch(0);
         _elem_size  := merged_result.fetch(1);
         _elem_level := merged_result.fetch(2);
         _elem_kind  := merged_result.fetch(3);
         _elem_prop  := merged_result.fetch(4);
         _elem_frag  := merged_result.fetch(5);
         var preNew_preOld := merged_result.fetch(6);
         _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
         _attr_own := _attr_own.tmark(0@0);
        }
        { # create attribute root entries
         var root_item := _elem_level.ord_uselect(chr(0));
         root_item := root_item.hmark(0@0);
         var iter_item := iter002.reverse().leftfetchjoin(root_item);
         var attr_own := _r_attr_iter.leftjoin(iter_item);
         if (_r_attr_iter.count() != 0) { # test uniqueness
          var sorting := _r_attr_iter.tsort();
          sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
          var unq_attrs := sorting.tunique();
          if (unq_attrs.count() != _r_attr_iter.count()) {
           item002 := materialize(item002,ipik002);
           if (item002.count() > 0) {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item002.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
           } else {
            ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
           }
          }
         } # end of test uniqueness
         if (_attr_iter.count() = 0) {
          _attr_iter := _r_attr_iter;
          _attr_qn   := _r_attr_qn;
          _attr_prop := _r_attr_prop;
          _attr_frag := _r_attr_frag;
          _attr_own  := attr_own.tmark(0@0);
         } else {
          var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
          _r_attr_iter := _r_attr_iter.tmark(seqb);
          _r_attr_qn   := _r_attr_qn  .tmark(seqb);
          _r_attr_prop := _r_attr_prop.tmark(seqb);
          _r_attr_frag := _r_attr_frag.tmark(seqb);
          attr_own := attr_own.tmark(seqb);
          _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
          _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
          _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
          _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
          _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
         }
         _r_attr_iter := empty_bat;
         _r_attr_qn   := empty_bat;
         _r_attr_prop := empty_bat;
         _r_attr_frag := empty_bat;
        } # end of create attribute root entries
        {
         var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
         var preOld_preNew := _elem_size.mark(seqb);
         _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
         _elem_size  := _elem_size.tmark(seqb);
         _elem_level := _elem_level.tmark(seqb);
         _elem_kind  := _elem_kind.tmark(seqb);
         _elem_prop  := _elem_prop.tmark(seqb);
         _elem_frag  := _elem_frag.tmark(seqb);
        }
        ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
        ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
        ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
        ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
        ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
        {
         var knd := ELEMENT;
         while ( knd <= DOCUMENT ) {
          var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
          ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
          if ( knd = ELEMENT ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
          }
          if ( knd = PI ) {
           var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
           ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
          }
          knd :+= chr(1);
         }
        }
        var roots := _elem_level.ord_uselect(chr(0));
        roots := roots.hmark(0@0);
        {
         var height := int(_elem_level.max());
         ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
        }
        { # adding new fragments to the WS_FRAG bat
         var seqb := oid(count(ws.fetch(WS_FRAG)));
         var new_pres := roots.tmark(seqb);
         ws.fetch(WS_FRAG).insert(new_pres);
        }
        iter := iter002;
        item := roots;
        ipik := item;
        kind := ELEM;
        { # add attribute subtree copies to WS
         var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
         _attr_qn   := _attr_qn  .tmark(seqb);
         _attr_prop := _attr_prop.tmark(seqb);
         _attr_own  := _attr_own .tmark(seqb);
         _attr_frag := _attr_frag.tmark(seqb);
         ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
         ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
         ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
         ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
        } # end of add attribute subtree copies to WS
       } # end of loop_liftedElemConstr (counter)
      } # end of deleteResult2 ()
     } else { # translateEmpty ()
      ipik := empty_bat;
      iter := empty_bat;
      item := empty_bat;
      kind := empty_kind_bat;
     }
     if (skip = 0) {
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
     } # cleanUpLevel ()
    } # end of translateIfThen
   } # end of ifthenelse-translation
  } # end of deleteResult1 ()
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn67BC4A58_q17_xs_string1
PROC fn67C4666D_q18_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q18
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761104@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "open_auction");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  var order_001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  pos := 1@0;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_pos001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761071@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
   v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761105@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb := oid(v_pos001.count());
    pos := pos.materialize(ipik);
    v_pos001 := v_pos001.insert(pos.tmark(seqb));
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # UDF - function call
   var fun_base001 := proc_vid.find("fnC3889EBC_convert_xs_decimal0");
   var fun_vid001 := bat(void,oid).seqbase(nil);
   var fun_iter001 := bat(void,oid).seqbase(nil);
   var fun_item001 := bat(void,oid).seqbase(nil);
   var fun_kind001 := bat(void,int).seqbase(nil);
   { # translateVar (i)
    var vid := v_vid001.ord_uselect(1303761105@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter001);
    item := vid.leftfetchjoin(v_item001);
    kind := vid.leftfetchjoin(v_kind001);
    ipik := iter;
   } # end of translateVar (i)
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "reserve");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   if (iter.tunique().count() != iter.count()) {
    ERROR ("err:FORG0003: function fn:zero-or-one expects at most one value.");
   }
   if (ipik.count() != 0) 
   { # for-translation
    # project ()
    iter := iter.materialize(ipik);
    var outer002 := iter;
    iter := iter.mark(1@0);
    var inner002 := iter;
    pos := 1@0;
    var loop002 := inner002;
    var v_vid002;
    var v_iter002;
    var v_pos002;
    var v_item002;
    var v_kind002;
    var expOid;
    { # getExpanded (fid)
     var vu_nil := vu_fid.ord_uselect(1303761072@0);
     var vid_vu := vu_vid.reverse();
     var oid_nil := vid_vu.leftjoin(vu_nil);
     expOid := v_vid001.leftjoin(oid_nil);
     expOid := expOid.mirror();
    } # end of getExpanded (fid)
    if (expOid.count() != 0) {
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter001);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
      v_iter002 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter002)*2;
     v_iter002 := v_iter002.tmark(0@0);
     var new_v_iter := v_iter002;
     v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
     v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
     v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
     var new_v_item := oidNew_expOid.leftjoin(v_item001);
     v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
     v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    } else { # createNewVarTable ()
     v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_pos002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
    }
    { # insertVar (vid)
     var vid := project(ipik,1303761106@0);
     { # append (vid, level)
      var seqb := oid(v_vid002.count());
      vid := vid.materialize(ipik);
      v_vid002 := v_vid002.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter002.count());
      iter := iter.materialize(ipik);
      v_iter002 := v_iter002.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb := oid(v_pos002.count());
      pos := pos.materialize(ipik);
      v_pos002 := v_pos002.insert(pos.tmark(seqb));
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item002.count());
      item := item.materialize(ipik);
      v_item002 := v_item002.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind002.count());
      kind := kind.materialize(ipik);
      v_kind002 := v_kind002.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    { # translateVar (#pf:v_2826)
     var vid := v_vid002.ord_uselect(1303761106@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter002);
     item := vid.leftfetchjoin(v_item002);
     kind := vid.leftfetchjoin(v_kind002);
     ipik := iter;
    } # end of translateVar (#pf:v_2826)
    { # string-value
     var input_iter := iter;
     kind := kind.materialize(ipik);
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     var kind_elem := kind.get_type(ELEM);
     var item_str;
     if (kind_elem.count() = kind.count()) {
      var frag := kind.get_fragment();
      var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
      var t_iter := res_scj.fetch(0);
      var t_item := res_scj.fetch(1);
      var t_frag := res_scj.fetch(2);
      var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
      var t_iter_unq := t_iter.tunique();
      t_iter := t_iter.materialize(t_item);
      if (t_iter_unq.count() != t_item.count()) {
       var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       iter_item := iter_item.string_join(t_iter_unq.project(""));
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
      }
      var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
      if (c_map.count() > 0) { #process comments 
       var c_iter := c_map.leftfetchjoin(iter);
       var c_item := c_map.leftfetchjoin(item);
       var c_frag := c_map.leftfetchjoin(frag);
       var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
       var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of comment processing
      var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
      if (pi_map.count() > 0) { #process processing-instructions 
       var pi_iter := pi_map.leftfetchjoin(iter);
       var pi_item := pi_map.leftfetchjoin(item);
       var pi_frag := pi_map.leftfetchjoin(frag);
       var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
       var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
       t_item_str := res_mu.fetch(1);
      } # end of processing-instruction processing
      iter := t_iter;
      item_str := t_item_str;
     } else {
      var kind_attr := kind.get_type(ATTR);
      if (kind_attr.count() = kind.count()) {
       var frag := kind.get_fragment();
       item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
      } else {
       kind_attr := kind_attr.hmark(0@0);
       var item_attr := kind_attr.leftfetchjoin(item);
       var iter_attr := kind_attr.leftfetchjoin(iter);
       var frag := kind_attr.leftfetchjoin(kind).get_fragment();
       var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
       kind_elem := kind_elem.hmark(0@0);
       iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
       frag := kind_elem.leftfetchjoin(kind).get_fragment();
       item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
       var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
       var t_iter := res_scj.fetch(0);
       var t_item := res_scj.fetch(1);
       var t_frag := res_scj.fetch(2);
       var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
       var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
       iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       {
        var item_unq := iter_item.reverse().tunique();
        if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
       }
       t_iter := iter_item.hmark(0@0);
       var t_item_str := iter_item.tmark(0@0);
       var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
       if (c_map.count() > 0) { #process comments 
        var c_iter := c_map.leftfetchjoin(iter);
        var c_item := c_map.leftfetchjoin(item);
        var c_frag := c_map.leftfetchjoin(frag);
        var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
        var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of comment processing
       var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
       if (pi_map.count() > 0) { #process processing-instructions 
        var pi_iter := pi_map.leftfetchjoin(iter);
        var pi_item := pi_map.leftfetchjoin(item);
        var pi_frag := pi_map.leftfetchjoin(frag);
        var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
        var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of processing-instruction processing
       iter := t_iter;
       item_str := t_item_str;
      }
     }
     item_str_ := item_str;
     if (iter.count() != input_iter.tunique().count()) {
      var difference := reverse(input_iter.tdiff(iter));
      difference := difference.hmark(0@0);
      var res_mu := merged_union(iter, difference, item_str_, "");
      iter := res_mu.fetch(0);
      item_str_ := res_mu.fetch(1);
     }
     ipik := iter;
    } # end of string-value
    { # cast from string to untypedAtomic
     if (iter.count() != loop002.count()) {
      ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
     }
    } # end of cast from string to untypedAtomic
    { # cast from untypedAtomic to decimal
     var cast_val := item_str_.[dbl]();
     if (cast_val.texist(dbl(nil))) {
      ERROR ("err:FORG0001: could not cast value from string to decimal.");
     }
     item := dec_values.addValues(cast_val).tmark(0@0);
     kind := DEC;
     if (iter.count() != loop002.count()) {
      ERROR("err:XPTY0004: cast to 'decimal' does not allow empty sequences to be casted.");
     }
    } # end of cast from untypedAtomic to decimal
    { # mapBack ()
     var iter_oidMap := inner002.reverse();
     var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
     iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
     # kind := kind;
     # ipik := ipik;
    } # end of mapBack ()
    # cleanUpLevel ()
   } # end of for-translation
   item := item.materialize(ipik);
   fun_vid001 := fun_vid001.insert(iter.project(oid(fun_base001 + 0LL)));
   fun_iter001 := fun_iter001.insert(iter.tmark(nil));
   fun_item001 := fun_item001.insert(item.tmark(nil));
   kind := kind.materialize(ipik);
   fun_kind001 := fun_kind001.insert(kind.tmark(nil)); # end of add arg in UDF function call
   var expOid;
   { # getExpanded (fid)
    var vu_nil := vu_fid.ord_uselect(1303761073@0);
    var vid_vu := vu_vid.reverse();
    var oid_nil := vid_vu.leftjoin(vu_nil);
    expOid := v_vid001.leftjoin(oid_nil);
    expOid := expOid.mirror();
   } # end of getExpanded (fid)
   var vid := expOid.leftfetchjoin(v_vid001);
   iter    := expOid.leftfetchjoin(v_iter001);
   item    := expOid.leftfetchjoin(v_item001);
   kind    := expOid.leftfetchjoin(v_kind001);
   fun_vid001 := fun_vid001.insert(vid.tmark(nil));
   fun_iter001 := fun_iter001.insert(iter.tmark(nil));
   fun_item001 := fun_item001.insert(item.tmark(nil));
   fun_kind001 := fun_kind001.insert(kind.tmark(nil));
   fun_vid001 := fun_vid001.tmark(0@0);
   fun_iter001 := fun_iter001.tmark(0@0);
   fun_item001 := fun_item001.tmark(0@0);
   fun_kind001 := fun_kind001.tmark(0@0);
   {
    var proc_res := fnC3889EBC_convert_xs_decimal0(loop001, outer001, order_001, inner001, fun_vid001, fun_iter001, fun_item001, fun_kind001); #convert
    iter := proc_res.fetch(0);
    item := proc_res.fetch(1);
    kind := proc_res.fetch(2);
    if (type(iter) = bat) {
     ipik := iter;
    } else {
     if (type(item) = bat) {
      ipik := item;
     } else {
      ipik := kind;
     }
    }
   }
  } # end of UDF - function call
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn67C4666D_q18_xs_string1
PROC fn67CC8286_q19_xs_string1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q19
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761107@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # translateLocsteps (c)
  var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
  item := item.materialize(ipik);
  iter := iter.materialize(ipik);
  res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "item");
  iter := res_scj.fetch(0);
  item := res_scj.fetch(1);
  kind := res_scj.fetch(2).set_kind(ELEM);
  ipik := item;
 } # end of translateLocsteps (c)
 if (ipik.count() != 0) 
 { # for-translation
  # project ()
  iter := iter.materialize(ipik);
  var outer001 := iter;
  var order_001 := iter;
  iter := iter.mark(1@0);
  var inner001 := iter;
  pos := 1@0;
  var loop001 := inner001;
  var v_vid001;
  var v_iter001;
  var v_pos001;
  var v_item001;
  var v_kind001;
  var expOid;
  { # getExpanded (fid)
   var vu_nil := vu_fid.ord_uselect(1303761074@0);
   var vid_vu := vu_vid.reverse();
   var oid_nil := vid_vu.leftjoin(vu_nil);
   expOid := v_vid000.leftjoin(oid_nil);
   expOid := expOid.mirror();
  } # end of getExpanded (fid)
  if (expOid.count() != 0) {
   var oidNew_expOid;
   { # expand ()
    var expOid_iter := expOid.leftfetchjoin(v_iter000);
    var iter_expOid := expOid_iter.reverse();
    var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
    var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
    oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
    var expOid_oidMap := oidMap_expOid.reverse();
    expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
    v_iter001 := expOid_iter;
    oidNew_expOid := expOid_iter.hmark(0@0);
   } # end of expand ()
   # join ()
   var cnt := count(v_iter001)*2;
   v_iter001 := v_iter001.tmark(0@0);
   var new_v_iter := v_iter001;
   v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
   var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
   v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
   var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
   v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
   var new_v_item := oidNew_expOid.leftjoin(v_item000);
   v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
   var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
   v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
  } else { # createNewVarTable ()
   v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
   v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
  }
  { # insertVar (vid)
   var vid := project(ipik,1303761108@0);
   { # append (vid, level)
    var seqb := oid(v_vid001.count());
    vid := vid.materialize(ipik);
    v_vid001 := v_vid001.insert(vid.tmark(seqb));
   } # append (vid, level)
   { # append (iter, level)
    var seqb := oid(v_iter001.count());
    iter := iter.materialize(ipik);
    v_iter001 := v_iter001.insert(iter.tmark(seqb));
   } # append (iter, level)
   { # append (pos, level)
    var seqb := oid(v_pos001.count());
    pos := pos.materialize(ipik);
    v_pos001 := v_pos001.insert(pos.tmark(seqb));
   } # append (pos, level)
   { # append (item, level)
    var seqb := oid(v_item001.count());
    item := item.materialize(ipik);
    v_item001 := v_item001.insert(item.tmark(seqb));
   } # append (item, level)
   { # append (kind, level)
    var seqb := oid(v_kind001.count());
    kind := kind.materialize(ipik);
    v_kind001 := v_kind001.insert(kind.tmark(seqb));
   } # append (kind, level)
  } # end of insertVar (vid)
  { # order_by
   var refined001 := inner001.reverse().leftfetchjoin(order_001);
   { # translateVar (b)
    var vid := v_vid001.ord_uselect(1303761108@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter001);
    item := vid.leftfetchjoin(v_item001);
    kind := vid.leftfetchjoin(v_kind001);
    ipik := iter;
   } # end of translateVar (b)
   { # translateLocsteps (c)
    var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
    item := item.materialize(ipik);
    iter := iter.materialize(ipik);
    res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "location");
    iter := res_scj.fetch(0);
    item := res_scj.fetch(1);
    kind := res_scj.fetch(2).set_kind(ELEM);
    ipik := item;
   } # end of translateLocsteps (c)
   if (ipik.count() != 0) 
   { # for-translation
    # project ()
    iter := iter.materialize(ipik);
    var outer002 := iter;
    iter := iter.mark(1@0);
    var inner002 := iter;
    pos := 1@0;
    var loop002 := inner002;
    var v_vid002;
    var v_iter002;
    var v_pos002;
    var v_item002;
    var v_kind002;
    var expOid;
    { # getExpanded (fid)
     var vu_nil := vu_fid.ord_uselect(1303761075@0);
     var vid_vu := vu_vid.reverse();
     var oid_nil := vid_vu.leftjoin(vu_nil);
     expOid := v_vid001.leftjoin(oid_nil);
     expOid := expOid.mirror();
    } # end of getExpanded (fid)
    if (expOid.count() != 0) {
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter001);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
      v_iter002 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter002)*2;
     v_iter002 := v_iter002.tmark(0@0);
     var new_v_iter := v_iter002;
     v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
     v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
     v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
     var new_v_item := oidNew_expOid.leftjoin(v_item001);
     v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
     v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    } else { # createNewVarTable ()
     v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_pos002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
    }
    { # insertVar (vid)
     var vid := project(ipik,1303761109@0);
     { # append (vid, level)
      var seqb := oid(v_vid002.count());
      vid := vid.materialize(ipik);
      v_vid002 := v_vid002.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter002.count());
      iter := iter.materialize(ipik);
      v_iter002 := v_iter002.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb := oid(v_pos002.count());
      pos := pos.materialize(ipik);
      v_pos002 := v_pos002.insert(pos.tmark(seqb));
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item002.count());
      item := item.materialize(ipik);
      v_item002 := v_item002.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind002.count());
      kind := kind.materialize(ipik);
      v_kind002 := v_kind002.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    { # translateVar (#pf:v_2828)
     var vid := v_vid002.ord_uselect(1303761109@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter002);
     item := vid.leftfetchjoin(v_item002);
     kind := vid.leftfetchjoin(v_kind002);
     ipik := iter;
    } # end of translateVar (#pf:v_2828)
    { # string-value
     var input_iter := iter;
     kind := kind.materialize(ipik);
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     var kind_elem := kind.get_type(ELEM);
     var item_str;
     if (kind_elem.count() = kind.count()) {
      var frag := kind.get_fragment();
      var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
      var t_iter := res_scj.fetch(0);
      var t_item := res_scj.fetch(1);
      var t_frag := res_scj.fetch(2);
      var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
      var t_iter_unq := t_iter.tunique();
      t_iter := t_iter.materialize(t_item);
      if (t_iter_unq.count() != t_item.count()) {
       var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       iter_item := iter_item.string_join(t_iter_unq.project(""));
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
      }
      var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
      if (c_map.count() > 0) { #process comments 
       var c_iter := c_map.leftfetchjoin(iter);
       var c_item := c_map.leftfetchjoin(item);
       var c_frag := c_map.leftfetchjoin(frag);
       var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
       var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
      } # end of comment processing
      var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
      if (pi_map.count() > 0) { #process processing-instructions 
       var pi_iter := pi_map.leftfetchjoin(iter);
       var pi_item := pi_map.leftfetchjoin(item);
       var pi_frag := pi_map.leftfetchjoin(frag);
       var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
       var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
       t_item_str := res_mu.fetch(1);
      } # end of processing-instruction processing
      iter := t_iter;
      item_str := t_item_str;
     } else {
      var kind_attr := kind.get_type(ATTR);
      if (kind_attr.count() = kind.count()) {
       var frag := kind.get_fragment();
       item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
      } else {
       kind_attr := kind_attr.hmark(0@0);
       var item_attr := kind_attr.leftfetchjoin(item);
       var iter_attr := kind_attr.leftfetchjoin(iter);
       var frag := kind_attr.leftfetchjoin(kind).get_fragment();
       var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
       kind_elem := kind_elem.hmark(0@0);
       iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
       frag := kind_elem.leftfetchjoin(kind).get_fragment();
       item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
       var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
       var t_iter := res_scj.fetch(0);
       var t_item := res_scj.fetch(1);
       var t_frag := res_scj.fetch(2);
       var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
       t_iter := iter_item.hmark(0@0);
       t_item_str := iter_item.tmark(0@0);
       var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
       t_iter := res_mu.fetch(0);
       t_item_str := res_mu.fetch(1);
       iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
       {
        var item_unq := iter_item.reverse().tunique();
        if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
       }
       t_iter := iter_item.hmark(0@0);
       var t_item_str := iter_item.tmark(0@0);
       var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
       if (c_map.count() > 0) { #process comments 
        var c_iter := c_map.leftfetchjoin(iter);
        var c_item := c_map.leftfetchjoin(item);
        var c_frag := c_map.leftfetchjoin(frag);
        var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
        var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of comment processing
       var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
       if (pi_map.count() > 0) { #process processing-instructions 
        var pi_iter := pi_map.leftfetchjoin(iter);
        var pi_item := pi_map.leftfetchjoin(item);
        var pi_frag := pi_map.leftfetchjoin(frag);
        var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
        var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
        t_iter := res_mu.fetch(0);
        t_item_str := res_mu.fetch(1);
       } # end of processing-instruction processing
       iter := t_iter;
       item_str := t_item_str;
      }
     }
     item_str_ := item_str;
     if (iter.count() != input_iter.tunique().count()) {
      var difference := reverse(input_iter.tdiff(iter));
      difference := difference.hmark(0@0);
      var res_mu := merged_union(iter, difference, item_str_, "");
      iter := res_mu.fetch(0);
      item_str_ := res_mu.fetch(1);
     }
     ipik := iter;
    } # end of string-value
    { # cast from string to untypedAtomic
     if (iter.count() != loop002.count()) {
      ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
     }
    } # end of cast from string to untypedAtomic
    { # mapBack ()
     var iter_oidMap := inner002.reverse();
     var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
     iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
     # kind := kind;
     # ipik := ipik;
    } # end of mapBack ()
    # cleanUpLevel ()
   } # end of for-translation
   if (iter.tunique().count() != iter.count()) {
    ERROR ("err:XPTY0004: order by expression expects at most one value.");
   }
   { # orderspec
    var order := iter.reverse().leftfetchjoin(item_str_);
    if (iter.count() != loop001.count()) {
     order := order.access(BAT_APPEND);
     order := order.insert(reverse(loop001.tdiff(iter)).project(cast(nil,ttype(order))));
     order := order.access(BAT_READ);
    }
    refined001 := refined001.CTrefine(order);
   } # end of orderspec
   { # tagname-translation
    var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
    var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    var itemID;
    if (prop_str.texist("item")) {
     itemID := prop_str.reverse().find("item");
    } else {
     itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
     ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
     ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
     ws.fetch(QN_LOC).fetch(WS).insert(itemID,"item");
     ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
     ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"item"+str('\1')+"");
    } # translateConst (kind)
    iter := loop001.tmark(0@0);
    ipik := iter;
    pos := 1@0;
    item := itemID;
    kind := QNAME;
   } # end of tagname-translation
   { # saveResult2 () : int
    var ipik002 := ipik;
    var iter002 := iter;
    var item002 := item; # end of saveResult2 () : int
    { # tagname-translation
     var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
     var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
     var itemID;
     if (prop_str.texist("name")) {
      itemID := prop_str.reverse().find("name");
     } else {
      itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
      ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
      ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
      ws.fetch(QN_LOC).fetch(WS).insert(itemID,"name");
      ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
      ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"name"+str('\1')+"");
     } # translateConst (kind)
     iter := loop001.tmark(0@0);
     ipik := iter;
     pos := 1@0;
     item := itemID;
     kind := QNAME;
    } # end of tagname-translation
    { # saveResult3 () : int
     var ipik003 := ipik;
     var iter003 := iter;
     var item003 := item; # end of saveResult3 () : int
     { # translateVar (b)
      var vid := v_vid001.ord_uselect(1303761108@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (b)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "name");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      pos  := tmark_grp_unique(iter,ipik);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     if (ipik.count() != 0) 
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      pos := 1@0;
      var v_vid002;
      var v_iter002;
      var v_pos002;
      var v_item002;
      var v_kind002;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761076@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
       v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_pos002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761110@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb := oid(v_pos002.count());
        pos := pos.materialize(ipik);
        v_pos002 := v_pos002.insert(pos.tmark(seqb));
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (#pf:v_2270)
       var vid := v_vid002.ord_uselect(1303761110@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (#pf:v_2270)
      { # string-value
       var input_iter := iter;
       kind := kind.materialize(ipik);
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       var kind_elem := kind.get_type(ELEM);
       var item_str;
       if (kind_elem.count() = kind.count()) {
        var frag := kind.get_fragment();
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var t_iter_unq := t_iter.tunique();
        t_iter := t_iter.materialize(t_item);
        if (t_iter_unq.count() != t_item.count()) {
         var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         iter_item := iter_item.string_join(t_iter_unq.project(""));
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
        }
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       } else {
        var kind_attr := kind.get_type(ATTR);
        if (kind_attr.count() = kind.count()) {
         var frag := kind.get_fragment();
         item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        } else {
         kind_attr := kind_attr.hmark(0@0);
         var item_attr := kind_attr.leftfetchjoin(item);
         var iter_attr := kind_attr.leftfetchjoin(iter);
         var frag := kind_attr.leftfetchjoin(kind).get_fragment();
         var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         kind_elem := kind_elem.hmark(0@0);
         iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
         frag := kind_elem.leftfetchjoin(kind).get_fragment();
         item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
         var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
         iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         {
          var item_unq := iter_item.reverse().tunique();
          if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
         }
         t_iter := iter_item.hmark(0@0);
         var t_item_str := iter_item.tmark(0@0);
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        }
       }
       item_str_ := item_str;
       if (iter.count() != input_iter.tunique().count()) {
        var difference := reverse(input_iter.tdiff(iter));
        difference := difference.hmark(0@0);
        var res_mu := merged_union(iter, difference, item_str_, "");
        iter := res_mu.fetch(0);
        item_str_ := res_mu.fetch(1);
       }
       ipik := iter;
       kind := STR;
      } # end of string-value
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002);
       pos := tmark_grp_unique(iter,ipik); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
     { # saveResult4 () : int
      var ipik004 := ipik;
      var iter004 := iter;
      var item_str_004 := item_str_; # end of saveResult4 () : int
      iter := loop001.tmark(0@0);
      ipik := iter;
      item_str_ := " ";
      { # string-join (string*, string)
       var iter_item_str := iter004.materialize(ipik004).reverse();
       iter_item_str := iter_item_str.leftfetchjoin(item_str_004).materialize(iter_item_str).chk_order();
       var iter_sep_str := iter.materialize(ipik).reverse();
       iter_sep_str := iter_sep_str.leftfetchjoin(item_str_).materialize(iter_sep_str);
       iter_item_str := string_join(iter_item_str, iter_sep_str);
       iter := iter_item_str.hmark(0@0);
       iter_item_str := iter_item_str.tmark(0@0);
       item_str_ := iter_item_str;
      } # end of string-join (string*, string)
     } # end of deleteResult4 ()
     { # loop_liftedAttrConstr (int i)
      if (iter003.count() != loop001.count()) {
       ERROR ("err:XPTY0004: name expression expects only string, untypedAtomic, or qname value (got empty sequence).");
      }
      if (iter.count() != loop001.count()) {
       var difference := reverse(loop001.tdiff(iter));
       difference := difference.hmark(0@0);
       var res_mu := merged_union(iter, difference, item_str_, "");
       item_str_ := res_mu.fetch(1);
      }
      var ws_prop_val := ws.fetch(PROP_VAL).fetch(WS);
      var unq := item_str_.tunique().hmark(0@0);
      var unq_str := unq;
      var str_unq := reverse(unq_str.tdiff(ws_prop_val));
      var seqb := oid(int(ws_prop_val.seqbase()) + ws_prop_val.count());
      unq_str := str_unq.hmark(seqb);
      ws_prop_val := ws_prop_val.insert(unq_str);
      var strings := item_str_.materialize(loop001);
      var attr_oid := strings.leftjoin(ws_prop_val.reverse());
      { # translateEmpty_node ()
       _elem_iter  := empty_bat;
       _elem_size  := empty_bat.project(int(nil));
       _elem_level := empty_bat.project(chr(nil));
       _elem_kind  := empty_bat.project(chr(nil));
       _elem_prop  := empty_bat;
       _elem_frag  := empty_bat;
       _attr_iter  := empty_bat;
       _attr_qn    := empty_bat;
       _attr_prop  := empty_bat;
       _attr_frag  := empty_bat;
       _attr_own   := empty_bat;
      } # end of translateEmpty_node ()
      attr_oid := attr_oid.tmark(0@0);
      _r_attr_iter := iter003;
      _r_attr_qn   := item003.materialize(ipik003);
      _r_attr_prop := attr_oid;
      _r_attr_frag := attr_oid.project(WS);
     } # end of loop_liftedAttrConstr (int i)
    } # end of deleteResult3 ()
    { # saveResult_node3 () : int
     var _elem_iter003   := _elem_iter  ;
     var _elem_size003   := _elem_size  ;
     var _elem_level003  := _elem_level ;
     var _elem_kind003   := _elem_kind  ;
     var _elem_prop003   := _elem_prop  ;
     var _elem_frag003   := _elem_frag  ;
     var _attr_iter003   := _attr_iter  ;
     var _attr_qn003     := _attr_qn    ;
     var _attr_prop003   := _attr_prop  ;
     var _attr_frag003   := _attr_frag  ;
     var _attr_own003    := _attr_own   ;
     var _r_attr_iter003 := _r_attr_iter;
     var _r_attr_qn003   := _r_attr_qn  ;
     var _r_attr_prop003 := _r_attr_prop;
     var _r_attr_frag003 := _r_attr_frag; # end of saveResult_node3 () : int
     { # translateVar (b)
      var vid := v_vid001.ord_uselect(1303761108@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (b)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 2, "", "location");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_child_step_with_kind_test(iter, item, constant2bat(kind.get_fragment()), ws, 1, TEXT);
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     { # map2NODE_interface (counter)
      kind := kind.materialize(ipik);
      var attr := kind.get_type(ATTR).hmark(0@0);
      var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
      var attr_item := attr.leftfetchjoin(item);
      var attr_frag := attr.leftfetchjoin(kind).get_fragment();
      _r_attr_iter := attr_iter;
      _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
      _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
      _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
      var nodes := kind.get_type(ELEM);
      if (nodes.count() != 0) {
       var oid_oid := nodes.hmark(0@0);
       var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
       var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
       var iter_input := oid_oid.mirror();
       var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
       var res_iter := res_scj.fetch(0);
       var res_item := res_scj.fetch(1);
       var res_frag := res_scj.fetch(2);
       _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
       _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
       _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
       _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
       _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
       var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
       var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
       nodes := res_item.mark(0@0);
       var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
       root_level := nodes.leftfetchjoin(root_level);
       temp_ec_item := res_item;
       temp_ec_frag := res_frag;
       var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
       content_level := nodes.leftfetchjoin(content_level);
       content_level := content_level.[-](root_level);
       content_level := content_level.tmark(0@0);
       _elem_level := content_level;
       { # create attribute subtree copies
        var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
        var oid_attr := temp_attr.tmark(0@0);
        var oid_frag;
        if (is_constant(res_frag)) {
         oid_frag := res_frag;
        } else {
         oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
         oid_frag := oid_frag.tmark(0@0);
        }
        _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
        _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
        _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
        _attr_own  := temp_attr.hmark(0@0);
        _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
       } # end of create attribute subtree copies
      } else { # if (nodes.count() != 0) ...
       _elem_iter  := empty_bat;
       _elem_size  := empty_bat.project(int(nil));
       _elem_level := empty_bat.project(chr(nil));
       _elem_kind  := empty_bat.project(chr(nil));
       _elem_prop  := empty_bat;
       _elem_frag  := empty_bat;
       _attr_iter  := empty_bat;
       _attr_qn    := empty_bat;
       _attr_prop  := empty_bat;
       _attr_frag  := empty_bat;
       _attr_own   := empty_bat;
      } # end of else in 'if (nodes.count() != 0)'
     } # end of map2NODE_interface (counter)
     # translateSeq_node (f, counter)
     if (_r_attr_iter.count() = 0) {
      _r_attr_iter := _r_attr_iter003;
      _r_attr_qn := _r_attr_qn003;
      _r_attr_prop := _r_attr_prop003;
      _r_attr_frag := _r_attr_frag003;
     } else {
      if (_r_attr_iter003.count() != 0) 
      { # combine attribute roots
       var merged_result := merged_union (_r_attr_iter003.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn003, _r_attr_qn, _r_attr_prop003, _r_attr_prop, _r_attr_frag003, _r_attr_frag);
       _r_attr_iter := merged_result.fetch(0);
       _r_attr_qn := merged_result.fetch(1);
       _r_attr_prop := merged_result.fetch(2);
       _r_attr_frag := merged_result.fetch(3);
      }
     } # end of combine attribute roots
     if (_elem_iter.count() = 0) {
      _elem_iter  := _elem_iter003  ;
      _elem_size  := _elem_size003  ;
      _elem_level := _elem_level003 ;
      _elem_kind  := _elem_kind003  ;
      _elem_prop  := _elem_prop003  ;
      _elem_frag  := _elem_frag003  ;
      _attr_iter  := _attr_iter003  ;
      _attr_qn    := _attr_qn003    ;
      _attr_prop  := _attr_prop003  ;
      _attr_frag  := _attr_frag003  ;
      _attr_own   := _attr_own003   ;
     } else {
      if (_elem_iter003.count() != 0) 
      { # combine element nodes
       var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
       var shift_factor := int(seqb) - int(_elem_size003.seqbase());
       var merged_result := merged_union (_elem_iter003.chk_order(), _elem_iter.chk_order(), _elem_size003, _elem_size, _elem_level003, _elem_level, _elem_kind003, _elem_kind, _elem_prop003, _elem_prop, _elem_frag003, _elem_frag, _elem_size003.mark(seqb), _elem_size.mirror());
       _elem_iter := merged_result.fetch(0);
       _elem_size := merged_result.fetch(1);
       _elem_level:= merged_result.fetch(2);
       _elem_kind := merged_result.fetch(3);
       _elem_prop := merged_result.fetch(4);
       _elem_frag := merged_result.fetch(5);
       var preNew_preOld := merged_result.fetch(6);
       _attr_own003 := _attr_own003.[int]().[+](shift_factor).[oid]();
       merged_result := merged_union (_attr_iter003, _attr_iter, _attr_qn003, _attr_qn, _attr_prop003, _attr_prop, _attr_frag003, _attr_frag, _attr_own003, _attr_own);
       _attr_iter := merged_result.fetch(0);
       _attr_qn   := merged_result.fetch(1);
       _attr_prop := merged_result.fetch(2);
       _attr_frag := merged_result.fetch(3);
       _attr_own  := merged_result.fetch(4);
       _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
       _attr_own := _attr_own.tmark(0@0);
      }
     } # combine element nodes
     # end of translateSeq_node (f, counter)
    } # end of deleteResult_node3 ()
    if (_elem_iter.count() != _elem_iter.tunique().count()) { # item-sequence-to-node-sequence
     { # saveResult_node3 () : int
      var _elem_iter003   := _elem_iter  ;
      var _elem_size003   := _elem_size  ;
      var _elem_level003  := _elem_level ;
      var _elem_kind003   := _elem_kind  ;
      var _elem_prop003   := _elem_prop  ;
      var _elem_frag003   := _elem_frag  ;
      var _attr_iter003   := _attr_iter  ;
      var _attr_qn003     := _attr_qn    ;
      var _attr_prop003   := _attr_prop  ;
      var _attr_frag003   := _attr_frag  ;
      var _attr_own003    := _attr_own   ;
      var _r_attr_iter003 := _r_attr_iter;
      var _r_attr_qn003   := _r_attr_qn  ;
      var _r_attr_prop003 := _r_attr_prop;
      var _r_attr_frag003 := _r_attr_frag; # end of saveResult_node3 () : int
      _elem_iter := _elem_iter003;
      _elem_level := _elem_level003;
      _elem_kind := _elem_kind003;
      _elem_prop := _elem_prop003;
      _elem_frag := _elem_frag003;
      var rootnodes := _elem_level.ord_uselect(chr(0)).mirror();
      rootnodes := rootnodes.leftfetchjoin(_elem_kind);
      var textnodes := rootnodes.ord_uselect(TEXT).hmark(0@0);
      var othernodes := _elem_level.kdiff(textnodes.reverse()).hmark(0@0);
      var elem_nodes := rootnodes.[!=](TEXT).ord_uselect(true).hmark(0@0);
      {
       var text_prop := textnodes.leftfetchjoin(_elem_prop);
       var text_frag := textnodes.leftfetchjoin(_elem_frag);
       var text_str := mposjoin (text_prop, text_frag, ws.fetch(PROP_TEXT));
       var res_mu_is2ns := merged_union (elem_nodes, textnodes, "", text_str, 0@0, 1@0);
       var input_order := res_mu_is2ns.fetch(0);
       var input_str := res_mu_is2ns.fetch(1);
       var input_const := res_mu_is2ns.fetch(2);
       var input_iter := input_order.leftfetchjoin(_elem_iter).chk_order();
       var result_size := _elem_iter.tunique().count() + elem_nodes.count() + 1;
       var result_str := combine_text_string (input_iter, input_const, input_str, result_size);
       var result_order := result_str.hmark(0@0);
       result_order := result_order.leftfetchjoin(input_order);
       result_str := result_str.tmark(0@0);
       iter := result_order;
       ipik := iter;
       item_str_ := result_str;
      }
      { # adding new strings to text node content and create new nodes
       var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
       var unq_str := item_str_.tunique().hmark(0@0);
       var str_unq := reverse(unq_str.tdiff(ws_prop_text));
       var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
       unq_str := str_unq.hmark(seqb);
       ws_prop_text := ws_prop_text.insert(unq_str);
       var ws_text_prop := ws_prop_text.reverse().sort();
       item_str_ := item_str_.materialize(ipik);
       var X_item := item_str_.hmark(0@0);
       var X_strings := item_str_.tmark(0@0).tsort();
       var X_prop := X_strings.leftjoin(ws_text_prop);
       var newPre_prop := X_item.reverse().leftjoin(X_prop); # end of translateEmpty_node ()
       newPre_prop := newPre_prop.tmark(0@0);
       _elem_iter  := iter;
       _elem_size  := newPre_prop.project(0);
       _elem_level := newPre_prop.project(chr(0));
       _elem_kind  := newPre_prop.project(TEXT);
       _elem_prop  := newPre_prop;
       _elem_frag  := newPre_prop.project(WS);
      } # end of adding new fragments to the WS_FRAG bat
      var res_mu_is2ns := merged_union (othernodes, _elem_iter, othernodes.leftfetchjoin(_elem_iter003), _elem_iter.leftfetchjoin(_elem_iter003), othernodes.leftfetchjoin(_elem_size003), _elem_size, othernodes.leftfetchjoin(_elem_level003), _elem_level, othernodes.leftfetchjoin(_elem_kind003), _elem_kind, othernodes.leftfetchjoin(_elem_prop003), _elem_prop, othernodes.leftfetchjoin(_elem_frag003), _elem_frag, othernodes.leftfetchjoin(_elem_iter003.mirror()), oid(nil));
      _elem_iter := res_mu_is2ns.fetch(1).chk_order();
      _elem_size := res_mu_is2ns.fetch(2);
      _elem_level:= res_mu_is2ns.fetch(3);
      _elem_kind := res_mu_is2ns.fetch(4);
      _elem_prop := res_mu_is2ns.fetch(5);
      _elem_frag := res_mu_is2ns.fetch(6);
      var preNew_preOld := res_mu_is2ns.fetch(7);
      _attr_own := _attr_own003.leftjoin(preNew_preOld.reverse());
      _attr_iter   := _attr_iter003  ;
      _attr_qn     := _attr_qn003    ;
      _attr_prop   := _attr_prop003  ;
      _attr_frag   := _attr_frag003  ;
      _r_attr_iter := _r_attr_iter003;
      _r_attr_qn   := _r_attr_qn003  ;
      _r_attr_prop := _r_attr_prop003;
      _r_attr_frag := _r_attr_frag003;
     } # end of deleteResult_node3 ()
    } # end of item-sequence-to-node-sequence
    { # loop_liftedElemConstr (counter)
     var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
     iter_size := {count}(iter_size, iter002.tunique(), FALSE);
     var root_iter  := iter_size.hmark(0@0).chk_order();
     var root_size  := iter_size.tmark(0@0);
     var root_prop  := iter002.reverse().leftfetchjoin(item002);
     if (not(is_constant(root_prop))) {
      root_prop  := root_prop.tmark(0@0);
     }
     {
      var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
      _elem_iter  := merged_result.fetch(0);
      _elem_size  := merged_result.fetch(1);
      _elem_level := merged_result.fetch(2);
      _elem_kind  := merged_result.fetch(3);
      _elem_prop  := merged_result.fetch(4);
      _elem_frag  := merged_result.fetch(5);
      var preNew_preOld := merged_result.fetch(6);
      _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
      _attr_own := _attr_own.tmark(0@0);
     }
     { # create attribute root entries
      var root_item := _elem_level.ord_uselect(chr(0));
      root_item := root_item.hmark(0@0);
      var iter_item := iter002.reverse().leftfetchjoin(root_item);
      var attr_own := _r_attr_iter.leftjoin(iter_item);
      if (_r_attr_iter.count() != 0) { # test uniqueness
       var sorting := _r_attr_iter.tsort();
       sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
       var unq_attrs := sorting.tunique();
       if (unq_attrs.count() != _r_attr_iter.count()) {
        item002 := materialize(item002,ipik002);
        if (item002.count() > 0) {
         ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item002.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
        } else {
         ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
        }
       }
      } # end of test uniqueness
      if (_attr_iter.count() = 0) {
       _attr_iter := _r_attr_iter;
       _attr_qn   := _r_attr_qn;
       _attr_prop := _r_attr_prop;
       _attr_frag := _r_attr_frag;
       _attr_own  := attr_own.tmark(0@0);
      } else {
       var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
       _r_attr_iter := _r_attr_iter.tmark(seqb);
       _r_attr_qn   := _r_attr_qn  .tmark(seqb);
       _r_attr_prop := _r_attr_prop.tmark(seqb);
       _r_attr_frag := _r_attr_frag.tmark(seqb);
       attr_own := attr_own.tmark(seqb);
       _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
       _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
       _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
       _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
       _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
      }
      _r_attr_iter := empty_bat;
      _r_attr_qn   := empty_bat;
      _r_attr_prop := empty_bat;
      _r_attr_frag := empty_bat;
     } # end of create attribute root entries
     {
      var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
      var preOld_preNew := _elem_size.mark(seqb);
      _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
      _elem_size  := _elem_size.tmark(seqb);
      _elem_level := _elem_level.tmark(seqb);
      _elem_kind  := _elem_kind.tmark(seqb);
      _elem_prop  := _elem_prop.tmark(seqb);
      _elem_frag  := _elem_frag.tmark(seqb);
     }
     ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
     ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
     ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
     ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
     ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
     {
      var knd := ELEMENT;
      while ( knd <= DOCUMENT ) {
       var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
       ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
       if ( knd = ELEMENT ) {
        var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
        ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
       }
       if ( knd = PI ) {
        var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
        ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
       }
       knd :+= chr(1);
      }
     }
     var roots := _elem_level.ord_uselect(chr(0));
     roots := roots.hmark(0@0);
     {
      var height := int(_elem_level.max());
      ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
     }
     { # adding new fragments to the WS_FRAG bat
      var seqb := oid(count(ws.fetch(WS_FRAG)));
      var new_pres := roots.tmark(seqb);
      ws.fetch(WS_FRAG).insert(new_pres);
     }
     iter := iter002;
     item := roots;
     ipik := item;
     pos := ipik.mark(1@0);
     kind := ELEM;
     { # add attribute subtree copies to WS
      var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
      _attr_qn   := _attr_qn  .tmark(seqb);
      _attr_prop := _attr_prop.tmark(seqb);
      _attr_own  := _attr_own .tmark(seqb);
      _attr_frag := _attr_frag.tmark(seqb);
      ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
      ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
      ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
      ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
     } # end of add attribute subtree copies to WS
    } # end of loop_liftedElemConstr (counter)
   } # end of deleteResult2 ()
   refined001 := refined001.CTrefine(loop001.reverse());
   var sorting := refined001.mirror();
   sorting := sorting.leftjoin(iter.reverse()).reverse();
   sorting := sorting.CTrefine(pos);
   ipik := sorting.hmark(0@0);
   iter := ipik.leftfetchjoin(iter);
   item := ipik.leftfetchjoin(item);
   kind := ipik.leftfetchjoin(kind);
  } # end of order_by
  { # mapBack ()
   var iter_oidMap := inner001.reverse();
   var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
   iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
   # kind := kind;
   # ipik := ipik;
  } # end of mapBack ()
  # cleanUpLevel ()
 } # end of for-translation
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn67CC8286_q19_xs_string1
PROC fn6A56537F_q20_xs_string1_xs_double1_xs_double1 (bat[void,oid] loop000, bat[void,oid] outer000, bat[void,oid] order_000, bat[void,oid] inner000, bat[void,oid] v_vid000, bat[void,oid] v_iter000, bat[void,oid] v_item000, bat[void,int] v_kind000) : bat[void,bat] { # fn:q20
 var iter;
 var pos;
 var item;
 var kind ;
 var ipik;
 var v_pos000 := tmark_grp_unique(v_iter000,v_iter000);
 v_pos000 := [oid](v_pos000).access(BAT_WRITE);
 v_vid000 := [oid](v_vid000).access(BAT_WRITE);
 v_iter000 := [oid](v_iter000).access(BAT_WRITE);
 v_item000 := [oid](v_item000).access(BAT_WRITE);
 v_kind000 := [int](v_kind000).access(BAT_WRITE);
 { # translateVar (doc)
  var vid := v_vid000.ord_uselect(1303761111@0);
  vid := vid.hmark(0@0);
  iter := vid.leftfetchjoin(v_iter000);
  pos := vid.leftfetchjoin(v_pos000);
  item := vid.leftfetchjoin(v_item000);
  ipik := iter;
 } # end of translateVar (doc)
 { # translate fn:doc (string?) as document?
  item.tunique().hmark(0@0).leftfetchjoin(str_values).tdiff(ws.fetch(DOC_LOADED))@batloop () {
   time_shred :+= add_doc(ws, $t);
  }
  kind := set_kind(item.leftfetchjoin(str_values).leftjoin(ws.fetch(DOC_LOADED).reverse()).tmark(0@0), ELEM);
  item := 0@0;
 } # end of translate fn:doc (string?) as document?
 { # insertVar (vid)
  var vid := project(ipik,1303761114@0);
  { # append (vid, level)
   var seqb := oid(v_vid000.count());
   vid := vid.materialize(ipik);
   v_vid000 := v_vid000.insert(vid.tmark(seqb));
  } # append (vid, level)
  { # append (iter, level)
   var seqb := oid(v_iter000.count());
   iter := iter.materialize(ipik);
   v_iter000 := v_iter000.insert(iter.tmark(seqb));
  } # append (iter, level)
  { # append (pos, level)
   var seqb := oid(v_pos000.count());
   pos := pos.materialize(ipik);
   v_pos000 := v_pos000.insert(pos.tmark(seqb));
  } # append (pos, level)
  { # append (item, level)
   var seqb := oid(v_item000.count());
   item := item.materialize(ipik);
   v_item000 := v_item000.insert(item.tmark(seqb));
  } # append (item, level)
  { # append (kind, level)
   var seqb := oid(v_kind000.count());
   kind := kind.materialize(ipik);
   v_kind000 := v_kind000.insert(kind.tmark(seqb));
  } # append (kind, level)
 } # end of insertVar (vid)
 { # tagname-translation
  var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
  var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
  var itemID;
  if (prop_str.texist("result")) {
   itemID := prop_str.reverse().find("result");
  } else {
   itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
   ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
   ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
   ws.fetch(QN_LOC).fetch(WS).insert(itemID,"result");
   ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
   ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"result"+str('\1')+"");
  } # translateConst (kind)
  iter := loop000.tmark(0@0);
  ipik := iter;
  pos := 1@0;
  item := itemID;
  kind := QNAME;
 } # end of tagname-translation
 { # saveResult1 () : int
  var ipik001 := ipik;
  var iter001 := iter;
  var item001 := item; # end of saveResult1 () : int
  { # tagname-translation
   var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
   var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
   var itemID;
   if (prop_str.texist("preferred")) {
    itemID := prop_str.reverse().find("preferred");
   } else {
    itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
    ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
    ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
    ws.fetch(QN_LOC).fetch(WS).insert(itemID,"preferred");
    ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
    ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"preferred"+str('\1')+"");
   } # translateConst (kind)
   iter := loop000.tmark(0@0);
   ipik := iter;
   pos := 1@0;
   item := itemID;
   kind := QNAME;
  } # end of tagname-translation
  { # saveResult2 () : int
   var ipik002 := ipik;
   var iter002 := iter;
   var item002 := item; # end of saveResult2 () : int
   { # translateVar (auction)
    var vid := v_vid000.ord_uselect(1303761114@0);
    vid := vid.hmark(0@0);
    iter := vid.leftfetchjoin(v_iter000);
    item := vid.leftfetchjoin(v_item000);
    kind := vid.leftfetchjoin(v_kind000);
    ipik := iter;
   } # end of translateVar (auction)
   if (ipik.count() != 0) 
   { # for-translation
    # project ()
    iter := iter.materialize(ipik);
    var outer001 := iter;
    iter := iter.mark(1@0);
    var inner001 := iter;
    pos := 1@0;
    var v_vid001;
    var v_iter001;
    var v_pos001;
    var v_item001;
    var v_kind001;
    var expOid;
    { # getExpanded (fid)
     var vu_nil := vu_fid.ord_uselect(1303761077@0);
     var vid_vu := vu_vid.reverse();
     var oid_nil := vid_vu.leftjoin(vu_nil);
     expOid := v_vid000.leftjoin(oid_nil);
     expOid := expOid.mirror();
    } # end of getExpanded (fid)
    if (expOid.count() != 0) {
     var oidNew_expOid;
     { # expand ()
      var expOid_iter := expOid.leftfetchjoin(v_iter000);
      var iter_expOid := expOid_iter.reverse();
      var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
      var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
      oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
      var expOid_oidMap := oidMap_expOid.reverse();
      expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
      v_iter001 := expOid_iter;
      oidNew_expOid := expOid_iter.hmark(0@0);
     } # end of expand ()
     # join ()
     var cnt := count(v_iter001)*2;
     v_iter001 := v_iter001.tmark(0@0);
     var new_v_iter := v_iter001;
     v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
     var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
     v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
     var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
     v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
     var new_v_item := oidNew_expOid.leftjoin(v_item000);
     v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
     var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
     v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
    } else { # createNewVarTable ()
     v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
     v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
    }
    { # insertVar (vid)
     var vid := project(ipik,1303761115@0);
     { # append (vid, level)
      var seqb := oid(v_vid001.count());
      vid := vid.materialize(ipik);
      v_vid001 := v_vid001.insert(vid.tmark(seqb));
     } # append (vid, level)
     { # append (iter, level)
      var seqb := oid(v_iter001.count());
      iter := iter.materialize(ipik);
      v_iter001 := v_iter001.insert(iter.tmark(seqb));
     } # append (iter, level)
     { # append (pos, level)
      var seqb := oid(v_pos001.count());
      pos := pos.materialize(ipik);
      v_pos001 := v_pos001.insert(pos.tmark(seqb));
     } # append (pos, level)
     { # append (item, level)
      var seqb := oid(v_item001.count());
      item := item.materialize(ipik);
      v_item001 := v_item001.insert(item.tmark(seqb));
     } # append (item, level)
     { # append (kind, level)
      var seqb := oid(v_kind001.count());
      kind := kind.materialize(ipik);
      v_kind001 := v_kind001.insert(kind.tmark(seqb));
     } # append (kind, level)
    } # end of insertVar (vid)
    { # translateVar (#pf:dot_2317)
     var vid := v_vid001.ord_uselect(1303761115@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter001);
     item := vid.leftfetchjoin(v_item001);
     kind := vid.leftfetchjoin(v_kind001);
     ipik := iter;
    } # end of translateVar (#pf:dot_2317)
    { # translateLocsteps (c)
     var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
     item := item.materialize(ipik);
     iter := iter.materialize(ipik);
     res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "profile");
     iter := res_scj.fetch(0);
     item := res_scj.fetch(1);
     kind := res_scj.fetch(2).set_kind(ELEM);
     ipik := item;
    } # end of translateLocsteps (c)
    if (ipik.count() != 0) 
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer002 := iter;
     var order_002 := iter;
     iter := iter.mark(1@0);
     var inner002 := iter;
     pos := 1@0;
     var loop002 := inner002;
     var v_vid002;
     var v_iter002;
     var v_pos002;
     var v_item002;
     var v_kind002;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(1303761078@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid001.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter001);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
       v_iter002 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter002)*2;
      v_iter002 := v_iter002.tmark(0@0);
      var new_v_iter := v_iter002;
      v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
      v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
      v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
      var new_v_item := oidNew_expOid.leftjoin(v_item001);
      v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
      v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     } else { # createNewVarTable ()
      v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_pos002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,1303761117@0);
      { # append (vid, level)
       var seqb := oid(v_vid002.count());
       vid := vid.materialize(ipik);
       v_vid002 := v_vid002.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter002.count());
       iter := iter.materialize(ipik);
       v_iter002 := v_iter002.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb := oid(v_pos002.count());
       pos := pos.materialize(ipik);
       v_pos002 := v_pos002.insert(pos.tmark(seqb));
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item002.count());
       item := item.materialize(ipik);
       v_item002 := v_item002.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb := oid(v_kind002.count());
       kind := kind.materialize(ipik);
       v_kind002 := v_kind002.insert(kind.tmark(seqb));
      } # append (kind, level)
     } # end of insertVar (vid)
     { # translateVar (#pf:dot_2331)
      var vid := v_vid002.ord_uselect(1303761117@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter002);
      item := vid.leftfetchjoin(v_item002);
      kind := vid.leftfetchjoin(v_kind002);
      ipik := iter;
     } # end of translateVar (#pf:dot_2331)
     { # loop_liftedSCJ (axis, kind, ns, loc)
      { # attribute axis
       var oid_iter := iter;
       var oid_item := item.materialize(ipik);
       var oid_frag := kind.get_fragment();
       var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
       oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
       var oid_attr := temp1.tmark(0@0);
       oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
       var temp1_str; # only needed for name test
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
       temp1 := temp1_str.ord_uselect("");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
       temp1 := temp1_str.ord_uselect("income");
       temp1 := temp1.hmark(0@0);
       oid_attr := temp1.leftfetchjoin(oid_attr);
       oid_frag := temp1.leftfetchjoin(oid_frag);
       oid_iter := temp1.leftfetchjoin(oid_iter);
       iter := oid_iter.tmark(0@0);
       item := oid_attr.tmark(0@0);
       kind := oid_frag.tmark(0@0);
       if (type(iter) = bat) {
        ipik := iter;
       } else {
        if (type(item) = bat) {
         ipik := item;
        } else {
         ipik := kind;
        }
       }
      } # end of attribute axis
      kind := kind.set_kind(ATTR);
     } # end of translateLocsteps (c)
     if (ipik.count() != 0) 
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer003 := iter;
      var order_003 := iter;
      iter := iter.mark(1@0);
      var inner003 := iter;
      pos := 1@0;
      var loop003 := inner003;
      var v_vid003;
      var v_iter003;
      var v_pos003;
      var v_item003;
      var v_kind003;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761079@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid002.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter002);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
        v_iter003 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter003)*2;
       v_iter003 := v_iter003.tmark(0@0);
       var new_v_iter := v_iter003;
       v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
       v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
       v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
       var new_v_item := oidNew_expOid.leftjoin(v_item002);
       v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
       v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_pos003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761119@0);
       { # append (vid, level)
        var seqb := oid(v_vid003.count());
        vid := vid.materialize(ipik);
        v_vid003 := v_vid003.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter003.count());
        iter := iter.materialize(ipik);
        v_iter003 := v_iter003.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb := oid(v_pos003.count());
        pos := pos.materialize(ipik);
        v_pos003 := v_pos003.insert(pos.tmark(seqb));
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item003.count());
        item := item.materialize(ipik);
        v_item003 := v_item003.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind003.count());
        kind := kind.materialize(ipik);
        v_kind003 := v_kind003.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (#pf:v_2830)
       var vid := v_vid003.ord_uselect(1303761119@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter003);
       item := vid.leftfetchjoin(v_item003);
       kind := vid.leftfetchjoin(v_kind003);
       ipik := iter;
      } # end of translateVar (#pf:v_2830)
      { # string-value
       var input_iter := iter;
       kind := kind.materialize(ipik);
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       var kind_elem := kind.get_type(ELEM);
       var item_str;
       if (kind_elem.count() = kind.count()) {
        var frag := kind.get_fragment();
        var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
        var t_iter := res_scj.fetch(0);
        var t_item := res_scj.fetch(1);
        var t_frag := res_scj.fetch(2);
        var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var t_iter_unq := t_iter.tunique();
        t_iter := t_iter.materialize(t_item);
        if (t_iter_unq.count() != t_item.count()) {
         var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         iter_item := iter_item.string_join(t_iter_unq.project(""));
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
        }
        var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
        if (c_map.count() > 0) { #process comments 
         var c_iter := c_map.leftfetchjoin(iter);
         var c_item := c_map.leftfetchjoin(item);
         var c_frag := c_map.leftfetchjoin(frag);
         var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
         var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
        } # end of comment processing
        var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
        if (pi_map.count() > 0) { #process processing-instructions 
         var pi_iter := pi_map.leftfetchjoin(iter);
         var pi_item := pi_map.leftfetchjoin(item);
         var pi_frag := pi_map.leftfetchjoin(frag);
         var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
         var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
         t_item_str := res_mu.fetch(1);
        } # end of processing-instruction processing
        iter := t_iter;
        item_str := t_item_str;
       } else {
        var kind_attr := kind.get_type(ATTR);
        if (kind_attr.count() = kind.count()) {
         var frag := kind.get_fragment();
         item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
        } else {
         kind_attr := kind_attr.hmark(0@0);
         var item_attr := kind_attr.leftfetchjoin(item);
         var iter_attr := kind_attr.leftfetchjoin(iter);
         var frag := kind_attr.leftfetchjoin(kind).get_fragment();
         var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         kind_elem := kind_elem.hmark(0@0);
         iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
         frag := kind_elem.leftfetchjoin(kind).get_fragment();
         item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
         t_iter := iter_item.hmark(0@0);
         t_item_str := iter_item.tmark(0@0);
         var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
         t_iter := res_mu.fetch(0);
         t_item_str := res_mu.fetch(1);
         iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
         {
          var item_unq := iter_item.reverse().tunique();
          if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
         }
         t_iter := iter_item.hmark(0@0);
         var t_item_str := iter_item.tmark(0@0);
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        }
       }
       item_str_ := item_str;
       if (iter.count() != input_iter.tunique().count()) {
        var difference := reverse(input_iter.tdiff(iter));
        difference := difference.hmark(0@0);
        var res_mu := merged_union(iter, difference, item_str_, "");
        iter := res_mu.fetch(0);
        item_str_ := res_mu.fetch(1);
       }
       ipik := iter;
       pos := tmark_grp_unique(iter,ipik);
      } # end of string-value
      { # cast from string to untypedAtomic
       if (iter.count() != loop003.count()) {
        ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
       }
      } # end of cast from string to untypedAtomic
      { # cast from untypedAtomic to double
       var cast_val := item_str_.[dbl]();
       if (cast_val.texist(dbl(nil))) {
        ERROR ("err:FORG0001: could not cast value from string to double.");
       }
       item_dbl_ := cast_val;
       kind := DBL;
       if (iter.count() != loop003.count()) {
        ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
       }
      } # end of cast from untypedAtomic to double
      { # saveResult3 () : int
       var item_dbl_003 := item_dbl_; # end of saveResult3 () : int
       { # translateVar (hi)
        var vid := v_vid003.ord_uselect(1303761113@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter003);
        pos := vid.leftfetchjoin(v_pos003);
        item := vid.leftfetchjoin(v_item003);
        ipik := iter;
       } # end of translateVar (hi)
       { # '>=' calculation
        var val_snd := item.leftfetchjoin(dbl_values);
        var val_fst := item_dbl_003;
        val_fst := [>=](val_fst,val_snd);
        item := val_fst.[oid]();
        kind := BOOL;
       } # end of '>=' calculation
      } # end of deleteResult3 ()
      { # saveResult3 () : int
       var iter003 := iter;
       var item003 := item; # end of saveResult3 () : int
       { # ifthenelse-translation
        var selected;
        var skip;
        if (type(item003) = bat) {
         selected := item003.ord_uselect(1@0);
         var cnt := selected.count();
         if (item003.count() = cnt) {
          skip := 2;
         } else {
          skip := int(cnt = 0);
         }
        } else {
         skip := 1 + int(item003); # handle constants efficiently
        }
        { # translateIfThen
         var loop004 := loop003;
         var inner004 := inner003;
         var outer004 := outer003;
         var v_iter004 := v_iter003;
         if (skip = 0) {
          iter := selected.mirror().join(iter003);
          iter := iter.tmark(0@0);
          outer004 := iter;
          iter := iter.mark(1@0);
          inner004 := iter;
          loop004 := inner004;
          var expOid := v_iter004.mirror();
          var oidNew_expOid;
          { # expand ()
           var expOid_iter := expOid.leftfetchjoin(v_iter003);
           var iter_expOid := expOid_iter.reverse();
           var oidMap_expOid := outer004.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
           var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
           oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
           var expOid_oidMap := oidMap_expOid.reverse();
           expOid_iter := expOid_oidMap.leftfetchjoin(inner004);
           v_iter004 := expOid_iter;
           oidNew_expOid := expOid_iter.hmark(0@0);
          } # end of expand ()
          # join ()
          var cnt := count(v_iter004)*2;
          v_iter004 := v_iter004.tmark(0@0);
          var new_v_iter := v_iter004;
          var new_v_vid := oidNew_expOid.leftjoin(v_vid003);
          var new_v_pos := oidNew_expOid.leftjoin(v_pos003);
          var new_v_item := oidNew_expOid.leftjoin(v_item003);
          var new_v_kind := oidNew_expOid.leftjoin(v_kind003); # end of join ()
         }
         if (skip != 1) {
          {
           int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
           var itemID := int_values.reverse().find(1LL); # translateConst (kind)
           iter := loop004.tmark(0@0);
           ipik := iter;
          }
         } else { # translateEmpty ()
          ipik := empty_bat;
          iter := empty_bat;
         }
         if (skip = 0) {
          { # mapBack ()
           var iter_oidMap := inner004.reverse();
           var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
           iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
           # kind := kind;
           # ipik := ipik;
          } # end of mapBack ()
         } # cleanUpLevel ()
        } # end of translateIfThen
       } # end of ifthenelse-translation
      } # end of deleteResult3 ()
      { # mapBack ()
       var iter_oidMap := inner003.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
     { # translate fn:empty (item*) as boolean
      var iter_count := {count}(iter.reverse(),loop002.reverse(), FALSE);
      var iter_bool := iter_count.[=](0).[oid]();
      item := iter_bool.tmark(0@0);
      iter := loop002.tmark(0@0);
      ipik := iter;
      pos := 1@0;
      kind := BOOL;
     } # end of translate fn:empty (item*) as boolean
     { # saveResult3 () : int
      var iter003 := iter;
      var item003 := item; # end of saveResult3 () : int
      { # ifthenelse-translation
       var selected;
       var skip;
       if (type(item003) = bat) {
        selected := item003.ord_uselect(1@0);
        var cnt := selected.count();
        if (item003.count() = cnt) {
         skip := 2;
        } else {
         skip := int(cnt = 0);
        }
       } else {
        skip := 1 + int(item003); # handle constants efficiently
       }
       { # translateIfThen
        var inner003 := inner002;
        var outer003 := outer002;
        var v_vid003 := v_vid002;
        var v_iter003 := v_iter002;
        var v_pos003 := v_pos002;
        var v_item003 := v_item002;
        var v_kind003 := v_kind002;
        if (skip = 0) {
         selected := item003.ord_uselect(0@0);
         iter := selected.mirror().join(iter003);
         iter := iter.tmark(0@0);
         outer003 := iter;
         iter := iter.mark(1@0);
         inner003 := iter;
         var expOid := v_iter003.mirror();
         var oidNew_expOid;
         { # expand ()
          var expOid_iter := expOid.leftfetchjoin(v_iter002);
          var iter_expOid := expOid_iter.reverse();
          var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
          var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
          oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
          var expOid_oidMap := oidMap_expOid.reverse();
          expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
          v_iter003 := expOid_iter;
          oidNew_expOid := expOid_iter.hmark(0@0);
         } # end of expand ()
         # join ()
         var cnt := count(v_iter003)*2;
         v_iter003 := v_iter003.tmark(0@0);
         var new_v_iter := v_iter003;
         v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
         var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
         v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
         var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
         v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
         var new_v_item := oidNew_expOid.leftjoin(v_item002);
         v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
         var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
         v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
        }
        if (skip != 2) {
         { # translateVar (#pf:dot_2331)
          var vid := v_vid003.ord_uselect(1303761117@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter003);
          item := vid.leftfetchjoin(v_item003);
          kind := vid.leftfetchjoin(v_kind003);
          ipik := iter;
         } # end of translateVar (#pf:dot_2331)
        } else { # translateEmpty ()
         ipik := empty_bat;
         iter := empty_bat;
         item := empty_bat;
         kind := empty_kind_bat;
        }
        if (skip = 0) {
         { # mapBack ()
          var iter_oidMap := inner003.reverse();
          var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
          iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
          # kind := kind;
          # ipik := ipik;
         } # end of mapBack ()
        } # cleanUpLevel ()
       } # end of translateIfThen
      } # end of ifthenelse-translation
     } # end of deleteResult3 ()
     { # mapBack ()
      var iter_oidMap := inner002.reverse();
      var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
      iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
      # kind := kind;
      # ipik := ipik;
     } # end of mapBack ()
     # cleanUpLevel ()
    } # end of for-translation
    { # mapBack ()
     var iter_oidMap := inner001.reverse();
     var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
     iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
     # kind := kind;
     # ipik := ipik;
    } # end of mapBack ()
    # cleanUpLevel ()
   } # end of for-translation
   { # translate pf:distinct-doc-order (node*) as node*
    var sorting;
    var simple := false;
    if (type(kind) != bat) {
     simple := (kind = ELEM);
    }
    if (not(simple)) {
     kind := kind.materialize(ipik);
     simple := (kind.count() = kind.get_type(ELEM).count());
    }
    if (simple) {
     sorting := iter.tsort();
     sorting := sorting.CTrefine(kind);
     sorting := sorting.CTrefine(item);
    } else { # cope also with attributes and sort them according to their owner
     var elements := kind.get_type(ELEM).mirror();
     var elem_iters := elements.leftfetchjoin(iter);
     var elem_items := elements.leftfetchjoin(item);
     var elem_frags := elements.leftfetchjoin(kind.get_fragment());
     var elem_attrs := elements.mark(nil);
     var attributes := kind.get_type(ATTR).mirror();
     var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
     var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
     var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
     var attr_key := attributes.hmark(0@0);
     var temp_attr := attr_attrs.tmark(0@0);
     var temp_frag := attr_frags.tmark(0@0);
     var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
     sorting := elem_iters.union(attr_iters).tsort();
     sorting := sorting.CTrefine(elem_frags.union(attr_frags));
     sorting := sorting.CTrefine(elem_items.union(attr_items));
     sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
    }
    ipik := sorting.reverse().{min}().tmark(0@0);
    iter := ipik.leftfetchjoin(iter);
   } # end of translate pf:distinct-doc-order (node*) as node*
   { # translate fn:count (item*) as integer
    iter := iter.materialize(ipik);
    var iter_count := [lng]({count}(iter.reverse(),loop000.reverse(), FALSE)).tmark(0@0);
    item := int_values.addValues(iter_count).tmark(0@0);
    iter := loop000.tmark(0@0);
    ipik := iter;
    pos := 1@0;
    kind := INT;
   } # end of translate fn:count (item*) as integer
   { # saveResult3 () : int
    var ipik003 := ipik;
    var iter003 := iter;
    var pos003 := pos;
    var item003 := item;
    var kind003 := kind; # end of saveResult3 () : int
    { # item-sequence-to-node-sequence
     var nodes_order;
     {
      ipik := ipik003;
      pos := pos003;
      item := item003;
      kind := kind003;
      kind := kind.materialize(ipik);
      var elem := kind.get_type(ELEM);
      elem := elem.hmark(0@0);
      var kind_elem := elem.leftfetchjoin(kind);
      var frag_elem := kind_elem.get_fragment();
      var item_elem := elem.leftfetchjoin(item).materialize(elem);
      var kind_node := mposjoin (item_elem, frag_elem, ws.fetch(PRE_KIND));
      var text := kind_node.ord_uselect(TEXT).hmark(0@0);
      var item_text := text.leftfetchjoin(item_elem);
      var frag_text := text.leftfetchjoin(frag_elem);
      var text_str := mposjoin (mposjoin (item_text, frag_text, ws.fetch(PRE_PROP)), mposjoin (item_text, frag_text, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
      var str_text := text_str.reverse().leftfetchjoin(text);
      var texts := str_text.leftfetchjoin(elem).reverse();
      var texts_order := texts.hmark(0@0);
      texts := texts.tmark(0@0);
      var nodes := kind_node.[!=](TEXT).ord_uselect(true).project("");
      nodes := nodes.reverse().leftfetchjoin(elem).reverse();
      nodes_order := nodes.hmark(0@0);
      nodes := nodes.tmark(0@0);
      var res_mu_is2ns := merged_union (nodes_order, texts_order, nodes, texts, 0@0, 1@0);
      var input_order := res_mu_is2ns.fetch(0);
      var input_str := res_mu_is2ns.fetch(1);
      var input_const := res_mu_is2ns.fetch(2);
      kind := kind.materialize(ipik);
      var atomic := kind.get_type_atomic();
      atomic := atomic.hmark(0@0);
      iter := atomic.mirror();
      item := atomic.leftfetchjoin(item);
      var cast_val := item.leftfetchjoin(int_values).[str]();
      if (cast_val.texist(str(nil))) {
       ERROR ("err:FORG0001: could not cast value from integer to string.");
      }
      item_str_ := cast_val;
      res_mu_is2ns := merged_union (input_order, atomic, input_str, item_str_, input_const, 2@0);
      input_order := res_mu_is2ns.fetch(0);
      input_str := res_mu_is2ns.fetch(1);
      input_const := res_mu_is2ns.fetch(2);
      var input_iter := input_order.leftfetchjoin(iter003).chk_order();
      var result_size := iter003.tunique().count() + nodes_order.count() + 1;
      var result_str := combine_text_string (input_iter.materialize(input_str), input_const.materialize(input_str), input_str, result_size);
      var result_order := result_str.hmark(0@0);
      result_order := result_order.leftfetchjoin(input_order);
      result_str := result_str.tmark(0@0);
      iter := result_order;
      ipik := iter;
      item_str_ := result_str;
     }
     { # adding new strings to text node content and create new nodes
      var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
      var unq_str := item_str_.tunique().hmark(0@0);
      var str_unq := reverse(unq_str.tdiff(ws_prop_text));
      var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
      unq_str := str_unq.hmark(seqb);
      ws_prop_text := ws_prop_text.insert(unq_str);
      var ws_text_prop := ws_prop_text.reverse().sort();
      item_str_ := item_str_.materialize(ipik);
      var X_item := item_str_.hmark(0@0);
      var X_strings := item_str_.tmark(0@0).tsort();
      var X_prop := X_strings.leftjoin(ws_text_prop);
      var newPre_prop := X_item.reverse().leftjoin(X_prop);
      seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS))+ int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
      newPre_prop := newPre_prop.tmark(seqb);
      ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
      ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
      ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
      ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
      ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));
      {
       var kind_pre_ := newPre_prop.hmark(nil).chk_order();
       ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
      }
      item := item_str_.mark(seqb);
      kind := ELEM;
     } # end of adding new strings to text node content and create new nodes
     { # adding new fragments to the WS_FRAG bat
      var seqb := ws.fetch(WS_FRAG).count();
      seqb := oid(seqb);
      var new_pres := item.tmark(seqb);
      ws.fetch(WS_FRAG).insert(new_pres);
      ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
     } # end of adding new fragments to the WS_FRAG bat
     var res_mu_is2ns := merged_union (iter, nodes_order, item, nodes_order.leftfetchjoin(item003), kind, nodes_order.leftfetchjoin(kind003));
     kind003 := kind003.materialize(ipik003);
     var attr := kind003.get_type(ATTR).hmark(0@0);
     var item_attr := attr.leftfetchjoin(item003);
     var kind_attr := attr.leftfetchjoin(kind003);
     res_mu_is2ns := merged_union (res_mu_is2ns.fetch(0), attr, res_mu_is2ns.fetch(1), item_attr, res_mu_is2ns.fetch(2), kind_attr);
     iter := res_mu_is2ns.fetch(0).leftfetchjoin(iter003);
     item := res_mu_is2ns.fetch(1);
     kind := res_mu_is2ns.fetch(2);
     ipik := item;
    } # end of item-sequence-to-node-sequence
   } # end of deleteResult3 ()
   { # map2NODE_interface (counter)
    kind := kind.materialize(ipik);
    var attr := kind.get_type(ATTR).hmark(0@0);
    var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
    var attr_item := attr.leftfetchjoin(item);
    var attr_frag := attr.leftfetchjoin(kind).get_fragment();
    _r_attr_iter := attr_iter;
    _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
    _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
    _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
    var nodes := kind.get_type(ELEM);
    if (nodes.count() != 0) {
     var oid_oid := nodes.hmark(0@0);
     var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
     var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
     var iter_input := oid_oid.mirror();
     var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
     var res_iter := res_scj.fetch(0);
     var res_item := res_scj.fetch(1);
     var res_frag := res_scj.fetch(2);
     _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
     _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
     _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
     _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
     _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
     var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
     var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
     nodes := res_item.mark(0@0);
     var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
     root_level := nodes.leftfetchjoin(root_level);
     temp_ec_item := res_item;
     temp_ec_frag := res_frag;
     var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
     content_level := nodes.leftfetchjoin(content_level);
     content_level := content_level.[-](root_level);
     content_level := content_level.tmark(0@0);
     _elem_level := content_level;
     { # create attribute subtree copies
      var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
      var oid_attr := temp_attr.tmark(0@0);
      var oid_frag;
      if (is_constant(res_frag)) {
       oid_frag := res_frag;
      } else {
       oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
       oid_frag := oid_frag.tmark(0@0);
      }
      _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
      _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
      _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
      _attr_own  := temp_attr.hmark(0@0);
      _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
     } # end of create attribute subtree copies
    } else { # if (nodes.count() != 0) ...
     _elem_iter  := empty_bat;
     _elem_size  := empty_bat.project(int(nil));
     _elem_level := empty_bat.project(chr(nil));
     _elem_kind  := empty_bat.project(chr(nil));
     _elem_prop  := empty_bat;
     _elem_frag  := empty_bat;
     _attr_iter  := empty_bat;
     _attr_qn    := empty_bat;
     _attr_prop  := empty_bat;
     _attr_frag  := empty_bat;
     _attr_own   := empty_bat;
    } # end of else in 'if (nodes.count() != 0)'
   } # end of map2NODE_interface (counter)
   { # loop_liftedElemConstr (counter)
    var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
    iter_size := {count}(iter_size, iter002.tunique(), FALSE);
    var root_iter  := iter_size.hmark(0@0).chk_order();
    var root_size  := iter_size.tmark(0@0);
    var root_prop  := iter002.reverse().leftfetchjoin(item002);
    if (not(is_constant(root_prop))) {
     root_prop  := root_prop.tmark(0@0);
    }
    {
     var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
     _elem_iter  := merged_result.fetch(0);
     _elem_size  := merged_result.fetch(1);
     _elem_level := merged_result.fetch(2);
     _elem_kind  := merged_result.fetch(3);
     _elem_prop  := merged_result.fetch(4);
     _elem_frag  := merged_result.fetch(5);
     var preNew_preOld := merged_result.fetch(6);
     _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
     _attr_own := _attr_own.tmark(0@0);
    }
    { # create attribute root entries
     var root_item := _elem_level.ord_uselect(chr(0));
     root_item := root_item.hmark(0@0);
     var iter_item := iter002.reverse().leftfetchjoin(root_item);
     var attr_own := _r_attr_iter.leftjoin(iter_item);
     if (_r_attr_iter.count() != 0) { # test uniqueness
      var sorting := _r_attr_iter.tsort();
      sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
      var unq_attrs := sorting.tunique();
      if (unq_attrs.count() != _r_attr_iter.count()) {
       item002 := materialize(item002,ipik002);
       if (item002.count() > 0) {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item002.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
       } else {
        ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
       }
      }
     } # end of test uniqueness
     if (_attr_iter.count() = 0) {
      _attr_iter := _r_attr_iter;
      _attr_qn   := _r_attr_qn;
      _attr_prop := _r_attr_prop;
      _attr_frag := _r_attr_frag;
      _attr_own  := attr_own.tmark(0@0);
     } else {
      var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
      _r_attr_iter := _r_attr_iter.tmark(seqb);
      _r_attr_qn   := _r_attr_qn  .tmark(seqb);
      _r_attr_prop := _r_attr_prop.tmark(seqb);
      _r_attr_frag := _r_attr_frag.tmark(seqb);
      attr_own := attr_own.tmark(seqb);
      _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
      _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
      _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
      _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
      _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
     }
     _r_attr_iter := empty_bat;
     _r_attr_qn   := empty_bat;
     _r_attr_prop := empty_bat;
     _r_attr_frag := empty_bat;
    } # end of create attribute root entries
   } # end of loop_liftedElemConstr (counter)
  } # end of deleteResult2 ()
  { # saveResult_node2 () : int
   var _elem_iter002   := _elem_iter  ;
   var _elem_size002   := _elem_size  ;
   var _elem_level002  := _elem_level ;
   var _elem_kind002   := _elem_kind  ;
   var _elem_prop002   := _elem_prop  ;
   var _elem_frag002   := _elem_frag  ;
   var _attr_iter002   := _attr_iter  ;
   var _attr_qn002     := _attr_qn    ;
   var _attr_prop002   := _attr_prop  ;
   var _attr_frag002   := _attr_frag  ;
   var _attr_own002    := _attr_own   ;
   var _r_attr_iter002 := _r_attr_iter;
   var _r_attr_qn002   := _r_attr_qn  ;
   var _r_attr_prop002 := _r_attr_prop;
   var _r_attr_frag002 := _r_attr_frag; # end of saveResult_node2 () : int
   { # tagname-translation
    var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
    var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
    var itemID;
    if (prop_str.texist("standard")) {
     itemID := prop_str.reverse().find("standard");
    } else {
     itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
     ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
     ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
     ws.fetch(QN_LOC).fetch(WS).insert(itemID,"standard");
     ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
     ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"standard"+str('\1')+"");
    } # translateConst (kind)
    iter := loop000.tmark(0@0);
    ipik := iter;
    pos := 1@0;
    item := itemID;
    kind := QNAME;
   } # end of tagname-translation
   { # saveResult3 () : int
    var ipik003 := ipik;
    var iter003 := iter;
    var item003 := item; # end of saveResult3 () : int
    { # translateVar (auction)
     var vid := v_vid000.ord_uselect(1303761114@0);
     vid := vid.hmark(0@0);
     iter := vid.leftfetchjoin(v_iter000);
     item := vid.leftfetchjoin(v_item000);
     kind := vid.leftfetchjoin(v_kind000);
     ipik := iter;
    } # end of translateVar (auction)
    if (ipik.count() != 0) 
    { # for-translation
     # project ()
     iter := iter.materialize(ipik);
     var outer001 := iter;
     iter := iter.mark(1@0);
     var inner001 := iter;
     pos := 1@0;
     var v_vid001;
     var v_iter001;
     var v_pos001;
     var v_item001;
     var v_kind001;
     var expOid;
     { # getExpanded (fid)
      var vu_nil := vu_fid.ord_uselect(1303761080@0);
      var vid_vu := vu_vid.reverse();
      var oid_nil := vid_vu.leftjoin(vu_nil);
      expOid := v_vid000.leftjoin(oid_nil);
      expOid := expOid.mirror();
     } # end of getExpanded (fid)
     if (expOid.count() != 0) {
      var oidNew_expOid;
      { # expand ()
       var expOid_iter := expOid.leftfetchjoin(v_iter000);
       var iter_expOid := expOid_iter.reverse();
       var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
       var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
       oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
       var expOid_oidMap := oidMap_expOid.reverse();
       expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
       v_iter001 := expOid_iter;
       oidNew_expOid := expOid_iter.hmark(0@0);
      } # end of expand ()
      # join ()
      var cnt := count(v_iter001)*2;
      v_iter001 := v_iter001.tmark(0@0);
      var new_v_iter := v_iter001;
      v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
      var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
      v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
      var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
      v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
      var new_v_item := oidNew_expOid.leftjoin(v_item000);
      v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
      var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
      v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
     } else { # createNewVarTable ()
      v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
      v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
     }
     { # insertVar (vid)
      var vid := project(ipik,1303761120@0);
      { # append (vid, level)
       var seqb := oid(v_vid001.count());
       vid := vid.materialize(ipik);
       v_vid001 := v_vid001.insert(vid.tmark(seqb));
      } # append (vid, level)
      { # append (iter, level)
       var seqb := oid(v_iter001.count());
       iter := iter.materialize(ipik);
       v_iter001 := v_iter001.insert(iter.tmark(seqb));
      } # append (iter, level)
      { # append (pos, level)
       var seqb := oid(v_pos001.count());
       pos := pos.materialize(ipik);
       v_pos001 := v_pos001.insert(pos.tmark(seqb));
      } # append (pos, level)
      { # append (item, level)
       var seqb := oid(v_item001.count());
       item := item.materialize(ipik);
       v_item001 := v_item001.insert(item.tmark(seqb));
      } # append (item, level)
      { # append (kind, level)
       var seqb := oid(v_kind001.count());
       kind := kind.materialize(ipik);
       v_kind001 := v_kind001.insert(kind.tmark(seqb));
      } # append (kind, level)
     } # end of insertVar (vid)
     { # translateVar (#pf:dot_2410)
      var vid := v_vid001.ord_uselect(1303761120@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter001);
      item := vid.leftfetchjoin(v_item001);
      kind := vid.leftfetchjoin(v_kind001);
      ipik := iter;
     } # end of translateVar (#pf:dot_2410)
     { # translateLocsteps (c)
      var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
      item := item.materialize(ipik);
      iter := iter.materialize(ipik);
      res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "profile");
      iter := res_scj.fetch(0);
      item := res_scj.fetch(1);
      kind := res_scj.fetch(2).set_kind(ELEM);
      ipik := item;
     } # end of translateLocsteps (c)
     if (ipik.count() != 0) 
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer002 := iter;
      var order_002 := iter;
      iter := iter.mark(1@0);
      var inner002 := iter;
      pos := 1@0;
      var loop002 := inner002;
      var v_vid002;
      var v_iter002;
      var v_pos002;
      var v_item002;
      var v_kind002;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761081@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid001.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter001);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
        v_iter002 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter002)*2;
       v_iter002 := v_iter002.tmark(0@0);
       var new_v_iter := v_iter002;
       v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
       v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
       v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
       var new_v_item := oidNew_expOid.leftjoin(v_item001);
       v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
       v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_pos002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761122@0);
       { # append (vid, level)
        var seqb := oid(v_vid002.count());
        vid := vid.materialize(ipik);
        v_vid002 := v_vid002.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter002.count());
        iter := iter.materialize(ipik);
        v_iter002 := v_iter002.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb := oid(v_pos002.count());
        pos := pos.materialize(ipik);
        v_pos002 := v_pos002.insert(pos.tmark(seqb));
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item002.count());
        item := item.materialize(ipik);
        v_item002 := v_item002.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind002.count());
        kind := kind.materialize(ipik);
        v_kind002 := v_kind002.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (#pf:dot_2424)
       var vid := v_vid002.ord_uselect(1303761122@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter002);
       item := vid.leftfetchjoin(v_item002);
       kind := vid.leftfetchjoin(v_kind002);
       ipik := iter;
      } # end of translateVar (#pf:dot_2424)
      { # loop_liftedSCJ (axis, kind, ns, loc)
       { # attribute axis
        var oid_iter := iter;
        var oid_item := item.materialize(ipik);
        var oid_frag := kind.get_fragment();
        var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
        oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
        var oid_attr := temp1.tmark(0@0);
        oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
        var temp1_str; # only needed for name test
        temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
        temp1 := temp1_str.ord_uselect("");
        temp1 := temp1.hmark(0@0);
        oid_attr := temp1.leftfetchjoin(oid_attr);
        oid_frag := temp1.leftfetchjoin(oid_frag);
        oid_iter := temp1.leftfetchjoin(oid_iter);
        temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
        temp1 := temp1_str.ord_uselect("income");
        temp1 := temp1.hmark(0@0);
        oid_attr := temp1.leftfetchjoin(oid_attr);
        oid_frag := temp1.leftfetchjoin(oid_frag);
        oid_iter := temp1.leftfetchjoin(oid_iter);
        iter := oid_iter.tmark(0@0);
        item := oid_attr.tmark(0@0);
        kind := oid_frag.tmark(0@0);
        if (type(iter) = bat) {
         ipik := iter;
        } else {
         if (type(item) = bat) {
          ipik := item;
         } else {
          ipik := kind;
         }
        }
       } # end of attribute axis
       kind := kind.set_kind(ATTR);
      } # end of translateLocsteps (c)
      if (ipik.count() != 0) 
      { # for-translation
       # project ()
       iter := iter.materialize(ipik);
       var outer003 := iter;
       var order_003 := iter;
       iter := iter.mark(1@0);
       var inner003 := iter;
       pos := 1@0;
       var loop003 := inner003;
       var v_vid003;
       var v_iter003;
       var v_pos003;
       var v_item003;
       var v_kind003;
       var expOid;
       { # getExpanded (fid)
        var vu_nil := vu_fid.ord_uselect(1303761082@0);
        var vid_vu := vu_vid.reverse();
        var oid_nil := vid_vu.leftjoin(vu_nil);
        expOid := v_vid002.leftjoin(oid_nil);
        expOid := expOid.mirror();
       } # end of getExpanded (fid)
       if (expOid.count() != 0) {
        var oidNew_expOid;
        { # expand ()
         var expOid_iter := expOid.leftfetchjoin(v_iter002);
         var iter_expOid := expOid_iter.reverse();
         var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
         var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
         oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
         var expOid_oidMap := oidMap_expOid.reverse();
         expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
         v_iter003 := expOid_iter;
         oidNew_expOid := expOid_iter.hmark(0@0);
        } # end of expand ()
        # join ()
        var cnt := count(v_iter003)*2;
        v_iter003 := v_iter003.tmark(0@0);
        var new_v_iter := v_iter003;
        v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
        var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
        v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
        var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
        v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
        var new_v_item := oidNew_expOid.leftjoin(v_item002);
        v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
        var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
        v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
       } else { # createNewVarTable ()
        v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_pos003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
       }
       { # insertVar (vid)
        var vid := project(ipik,1303761124@0);
        { # append (vid, level)
         var seqb := oid(v_vid003.count());
         vid := vid.materialize(ipik);
         v_vid003 := v_vid003.insert(vid.tmark(seqb));
        } # append (vid, level)
        { # append (iter, level)
         var seqb := oid(v_iter003.count());
         iter := iter.materialize(ipik);
         v_iter003 := v_iter003.insert(iter.tmark(seqb));
        } # append (iter, level)
        { # append (pos, level)
         var seqb := oid(v_pos003.count());
         pos := pos.materialize(ipik);
         v_pos003 := v_pos003.insert(pos.tmark(seqb));
        } # append (pos, level)
        { # append (item, level)
         var seqb := oid(v_item003.count());
         item := item.materialize(ipik);
         v_item003 := v_item003.insert(item.tmark(seqb));
        } # append (item, level)
        { # append (kind, level)
         var seqb := oid(v_kind003.count());
         kind := kind.materialize(ipik);
         v_kind003 := v_kind003.insert(kind.tmark(seqb));
        } # append (kind, level)
       } # end of insertVar (vid)
       { # translateVar (#pf:v_2832)
        var vid := v_vid003.ord_uselect(1303761124@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter003);
        item := vid.leftfetchjoin(v_item003);
        kind := vid.leftfetchjoin(v_kind003);
        ipik := iter;
       } # end of translateVar (#pf:v_2832)
       { # string-value
        var input_iter := iter;
        kind := kind.materialize(ipik);
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        var kind_elem := kind.get_type(ELEM);
        var item_str;
        if (kind_elem.count() = kind.count()) {
         var frag := kind.get_fragment();
         var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
         var t_iter := res_scj.fetch(0);
         var t_item := res_scj.fetch(1);
         var t_frag := res_scj.fetch(2);
         var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var t_iter_unq := t_iter.tunique();
         t_iter := t_iter.materialize(t_item);
         if (t_iter_unq.count() != t_item.count()) {
          var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          iter_item := iter_item.string_join(t_iter_unq.project(""));
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
         }
         var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
         if (c_map.count() > 0) { #process comments 
          var c_iter := c_map.leftfetchjoin(iter);
          var c_item := c_map.leftfetchjoin(item);
          var c_frag := c_map.leftfetchjoin(frag);
          var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
          var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
         } # end of comment processing
         var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
         if (pi_map.count() > 0) { #process processing-instructions 
          var pi_iter := pi_map.leftfetchjoin(iter);
          var pi_item := pi_map.leftfetchjoin(item);
          var pi_frag := pi_map.leftfetchjoin(frag);
          var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
          var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
          t_item_str := res_mu.fetch(1);
         } # end of processing-instruction processing
         iter := t_iter;
         item_str := t_item_str;
        } else {
         var kind_attr := kind.get_type(ATTR);
         if (kind_attr.count() = kind.count()) {
          var frag := kind.get_fragment();
          item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
         } else {
          kind_attr := kind_attr.hmark(0@0);
          var item_attr := kind_attr.leftfetchjoin(item);
          var iter_attr := kind_attr.leftfetchjoin(iter);
          var frag := kind_attr.leftfetchjoin(kind).get_fragment();
          var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
          kind_elem := kind_elem.hmark(0@0);
          iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
          frag := kind_elem.leftfetchjoin(kind).get_fragment();
          item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
          var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
          var t_iter := res_scj.fetch(0);
          var t_item := res_scj.fetch(1);
          var t_frag := res_scj.fetch(2);
          var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
          var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
          t_iter := iter_item.hmark(0@0);
          t_item_str := iter_item.tmark(0@0);
          var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
          t_iter := res_mu.fetch(0);
          t_item_str := res_mu.fetch(1);
          iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
          {
           var item_unq := iter_item.reverse().tunique();
           if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
          }
          t_iter := iter_item.hmark(0@0);
          var t_item_str := iter_item.tmark(0@0);
          var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
          if (c_map.count() > 0) { #process comments 
           var c_iter := c_map.leftfetchjoin(iter);
           var c_item := c_map.leftfetchjoin(item);
           var c_frag := c_map.leftfetchjoin(frag);
           var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
           var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of comment processing
          var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
          if (pi_map.count() > 0) { #process processing-instructions 
           var pi_iter := pi_map.leftfetchjoin(iter);
           var pi_item := pi_map.leftfetchjoin(item);
           var pi_frag := pi_map.leftfetchjoin(frag);
           var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
           var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of processing-instruction processing
          iter := t_iter;
          item_str := t_item_str;
         }
        }
        item_str_ := item_str;
        if (iter.count() != input_iter.tunique().count()) {
         var difference := reverse(input_iter.tdiff(iter));
         difference := difference.hmark(0@0);
         var res_mu := merged_union(iter, difference, item_str_, "");
         iter := res_mu.fetch(0);
         item_str_ := res_mu.fetch(1);
        }
        ipik := iter;
        pos := tmark_grp_unique(iter,ipik);
       } # end of string-value
       { # cast from string to untypedAtomic
        if (iter.count() != loop003.count()) {
         ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
        }
       } # end of cast from string to untypedAtomic
       { # cast from untypedAtomic to double
        var cast_val := item_str_.[dbl]();
        if (cast_val.texist(dbl(nil))) {
         ERROR ("err:FORG0001: could not cast value from string to double.");
        }
        item_dbl_ := cast_val;
        kind := DBL;
        if (iter.count() != loop003.count()) {
         ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
        }
       } # end of cast from untypedAtomic to double
       { # saveResult4 () : int
        var item_dbl_004 := item_dbl_; # end of saveResult4 () : int
        { # translateVar (hi)
         var vid := v_vid003.ord_uselect(1303761113@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter003);
         pos := vid.leftfetchjoin(v_pos003);
         item := vid.leftfetchjoin(v_item003);
         ipik := iter;
        } # end of translateVar (hi)
        { # '<' calculation
         var val_snd := item.leftfetchjoin(dbl_values);
         var val_fst := item_dbl_004;
         val_fst := [<](val_fst,val_snd);
         item := val_fst.[oid]();
         kind := BOOL;
        } # end of '<' calculation
       } # end of deleteResult4 ()
       { # saveResult4 () : int
        var iter004 := iter;
        var item004 := item; # end of saveResult4 () : int
        { # ifthenelse-translation
         var selected;
         var skip;
         if (type(item004) = bat) {
          selected := item004.ord_uselect(1@0);
          var cnt := selected.count();
          if (item004.count() = cnt) {
           skip := 2;
          } else {
           skip := int(cnt = 0);
          }
         } else {
          skip := 1 + int(item004); # handle constants efficiently
         }
         { # translateIfThen
          var loop004 := loop003;
          var inner004 := inner003;
          var outer004 := outer003;
          var v_iter004 := v_iter003;
          if (skip = 0) {
           iter := selected.mirror().join(iter004);
           iter := iter.tmark(0@0);
           outer004 := iter;
           iter := iter.mark(1@0);
           inner004 := iter;
           loop004 := inner004;
           var expOid := v_iter004.mirror();
           var oidNew_expOid;
           { # expand ()
            var expOid_iter := expOid.leftfetchjoin(v_iter003);
            var iter_expOid := expOid_iter.reverse();
            var oidMap_expOid := outer004.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
            var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
            oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
            var expOid_oidMap := oidMap_expOid.reverse();
            expOid_iter := expOid_oidMap.leftfetchjoin(inner004);
            v_iter004 := expOid_iter;
            oidNew_expOid := expOid_iter.hmark(0@0);
           } # end of expand ()
           # join ()
           var cnt := count(v_iter004)*2;
           v_iter004 := v_iter004.tmark(0@0);
           var new_v_iter := v_iter004;
           var new_v_vid := oidNew_expOid.leftjoin(v_vid003);
           var new_v_pos := oidNew_expOid.leftjoin(v_pos003);
           var new_v_item := oidNew_expOid.leftjoin(v_item003);
           var new_v_kind := oidNew_expOid.leftjoin(v_kind003); # end of join ()
          }
          if (skip != 1) {
           {
            int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
            var itemID := int_values.reverse().find(1LL); # translateConst (kind)
            iter := loop004.tmark(0@0);
            ipik := iter;
           }
          } else { # translateEmpty ()
           ipik := empty_bat;
           iter := empty_bat;
          }
          if (skip = 0) {
           { # mapBack ()
            var iter_oidMap := inner004.reverse();
            var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
            iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
            # kind := kind;
            # ipik := ipik;
           } # end of mapBack ()
          } # cleanUpLevel ()
         } # end of translateIfThen
        } # end of ifthenelse-translation
       } # end of deleteResult4 ()
       { # mapBack ()
        var iter_oidMap := inner003.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
       # cleanUpLevel ()
      } # end of for-translation
      { # translate fn:empty (item*) as boolean
       var iter_count := {count}(iter.reverse(),loop002.reverse(), FALSE);
       var iter_bool := iter_count.[=](0).[oid]();
       item := iter_bool.tmark(0@0);
       iter := loop002.tmark(0@0);
       ipik := iter;
       pos := 1@0;
       kind := BOOL;
      } # end of translate fn:empty (item*) as boolean
      # translate fn:not (boolean) as boolean
      item := item.leftfetchjoin(bool_not);
      { # saveResult4 () : int
       var item004 := item; # end of saveResult4 () : int
       { # translateVar (#pf:dot_2424)
        var vid := v_vid002.ord_uselect(1303761122@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter002);
        item := vid.leftfetchjoin(v_item002);
        kind := vid.leftfetchjoin(v_kind002);
        ipik := iter;
       } # end of translateVar (#pf:dot_2424)
       { # loop_liftedSCJ (axis, kind, ns, loc)
        { # attribute axis
         var oid_iter := iter;
         var oid_item := item.materialize(ipik);
         var oid_frag := kind.get_fragment();
         var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
         oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
         var oid_attr := temp1.tmark(0@0);
         oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
         var temp1_str; # only needed for name test
         temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
         temp1 := temp1_str.ord_uselect("");
         temp1 := temp1.hmark(0@0);
         oid_attr := temp1.leftfetchjoin(oid_attr);
         oid_frag := temp1.leftfetchjoin(oid_frag);
         oid_iter := temp1.leftfetchjoin(oid_iter);
         temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
         temp1 := temp1_str.ord_uselect("income");
         temp1 := temp1.hmark(0@0);
         oid_attr := temp1.leftfetchjoin(oid_attr);
         oid_frag := temp1.leftfetchjoin(oid_frag);
         oid_iter := temp1.leftfetchjoin(oid_iter);
         iter := oid_iter.tmark(0@0);
         item := oid_attr.tmark(0@0);
         kind := oid_frag.tmark(0@0);
         if (type(iter) = bat) {
          ipik := iter;
         } else {
          if (type(item) = bat) {
           ipik := item;
          } else {
           ipik := kind;
          }
         }
        } # end of attribute axis
        kind := kind.set_kind(ATTR);
       } # end of translateLocsteps (c)
       if (ipik.count() != 0) 
       { # for-translation
        # project ()
        iter := iter.materialize(ipik);
        var outer003 := iter;
        var order_003 := iter;
        iter := iter.mark(1@0);
        var inner003 := iter;
        pos := 1@0;
        var loop003 := inner003;
        var v_vid003;
        var v_iter003;
        var v_pos003;
        var v_item003;
        var v_kind003;
        var expOid;
        { # getExpanded (fid)
         var vu_nil := vu_fid.ord_uselect(1303761083@0);
         var vid_vu := vu_vid.reverse();
         var oid_nil := vid_vu.leftjoin(vu_nil);
         expOid := v_vid002.leftjoin(oid_nil);
         expOid := expOid.mirror();
        } # end of getExpanded (fid)
        if (expOid.count() != 0) {
         var oidNew_expOid;
         { # expand ()
          var expOid_iter := expOid.leftfetchjoin(v_iter002);
          var iter_expOid := expOid_iter.reverse();
          var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
          var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
          oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
          var expOid_oidMap := oidMap_expOid.reverse();
          expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
          v_iter003 := expOid_iter;
          oidNew_expOid := expOid_iter.hmark(0@0);
         } # end of expand ()
         # join ()
         var cnt := count(v_iter003)*2;
         v_iter003 := v_iter003.tmark(0@0);
         var new_v_iter := v_iter003;
         v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
         var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
         v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
         var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
         v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
         var new_v_item := oidNew_expOid.leftjoin(v_item002);
         v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
         var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
         v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
        } else { # createNewVarTable ()
         v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
         v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
         v_pos003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
         v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
         v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
        }
        { # insertVar (vid)
         var vid := project(ipik,1303761125@0);
         { # append (vid, level)
          var seqb := oid(v_vid003.count());
          vid := vid.materialize(ipik);
          v_vid003 := v_vid003.insert(vid.tmark(seqb));
         } # append (vid, level)
         { # append (iter, level)
          var seqb := oid(v_iter003.count());
          iter := iter.materialize(ipik);
          v_iter003 := v_iter003.insert(iter.tmark(seqb));
         } # append (iter, level)
         { # append (pos, level)
          var seqb := oid(v_pos003.count());
          pos := pos.materialize(ipik);
          v_pos003 := v_pos003.insert(pos.tmark(seqb));
         } # append (pos, level)
         { # append (item, level)
          var seqb := oid(v_item003.count());
          item := item.materialize(ipik);
          v_item003 := v_item003.insert(item.tmark(seqb));
         } # append (item, level)
         { # append (kind, level)
          var seqb := oid(v_kind003.count());
          kind := kind.materialize(ipik);
          v_kind003 := v_kind003.insert(kind.tmark(seqb));
         } # append (kind, level)
        } # end of insertVar (vid)
        { # translateVar (#pf:v_2834)
         var vid := v_vid003.ord_uselect(1303761125@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter003);
         item := vid.leftfetchjoin(v_item003);
         kind := vid.leftfetchjoin(v_kind003);
         ipik := iter;
        } # end of translateVar (#pf:v_2834)
        { # string-value
         var input_iter := iter;
         kind := kind.materialize(ipik);
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         var kind_elem := kind.get_type(ELEM);
         var item_str;
         if (kind_elem.count() = kind.count()) {
          var frag := kind.get_fragment();
          var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
          var t_iter := res_scj.fetch(0);
          var t_item := res_scj.fetch(1);
          var t_frag := res_scj.fetch(2);
          var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
          var t_iter_unq := t_iter.tunique();
          t_iter := t_iter.materialize(t_item);
          if (t_iter_unq.count() != t_item.count()) {
           var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
           iter_item := iter_item.string_join(t_iter_unq.project(""));
           t_iter := iter_item.hmark(0@0);
           t_item_str := iter_item.tmark(0@0);
          }
          var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
          if (c_map.count() > 0) { #process comments 
           var c_iter := c_map.leftfetchjoin(iter);
           var c_item := c_map.leftfetchjoin(item);
           var c_frag := c_map.leftfetchjoin(frag);
           var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
           var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of comment processing
          var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
          if (pi_map.count() > 0) { #process processing-instructions 
           var pi_iter := pi_map.leftfetchjoin(iter);
           var pi_item := pi_map.leftfetchjoin(item);
           var pi_frag := pi_map.leftfetchjoin(frag);
           var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
           var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
           t_item_str := res_mu.fetch(1);
          } # end of processing-instruction processing
          iter := t_iter;
          item_str := t_item_str;
         } else {
          var kind_attr := kind.get_type(ATTR);
          if (kind_attr.count() = kind.count()) {
           var frag := kind.get_fragment();
           item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
          } else {
           kind_attr := kind_attr.hmark(0@0);
           var item_attr := kind_attr.leftfetchjoin(item);
           var iter_attr := kind_attr.leftfetchjoin(iter);
           var frag := kind_attr.leftfetchjoin(kind).get_fragment();
           var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
           kind_elem := kind_elem.hmark(0@0);
           iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
           frag := kind_elem.leftfetchjoin(kind).get_fragment();
           item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
           var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
           var t_iter := res_scj.fetch(0);
           var t_item := res_scj.fetch(1);
           var t_frag := res_scj.fetch(2);
           var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
           var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
           t_iter := iter_item.hmark(0@0);
           t_item_str := iter_item.tmark(0@0);
           var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
           iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
           {
            var item_unq := iter_item.reverse().tunique();
            if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
           }
           t_iter := iter_item.hmark(0@0);
           var t_item_str := iter_item.tmark(0@0);
           var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
           if (c_map.count() > 0) { #process comments 
            var c_iter := c_map.leftfetchjoin(iter);
            var c_item := c_map.leftfetchjoin(item);
            var c_frag := c_map.leftfetchjoin(frag);
            var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
            var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
           } # end of comment processing
           var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
           if (pi_map.count() > 0) { #process processing-instructions 
            var pi_iter := pi_map.leftfetchjoin(iter);
            var pi_item := pi_map.leftfetchjoin(item);
            var pi_frag := pi_map.leftfetchjoin(frag);
            var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
            var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
           } # end of processing-instruction processing
           iter := t_iter;
           item_str := t_item_str;
          }
         }
         item_str_ := item_str;
         if (iter.count() != input_iter.tunique().count()) {
          var difference := reverse(input_iter.tdiff(iter));
          difference := difference.hmark(0@0);
          var res_mu := merged_union(iter, difference, item_str_, "");
          iter := res_mu.fetch(0);
          item_str_ := res_mu.fetch(1);
         }
         ipik := iter;
         pos := tmark_grp_unique(iter,ipik);
        } # end of string-value
        { # cast from string to untypedAtomic
         if (iter.count() != loop003.count()) {
          ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
         }
        } # end of cast from string to untypedAtomic
        { # cast from untypedAtomic to double
         var cast_val := item_str_.[dbl]();
         if (cast_val.texist(dbl(nil))) {
          ERROR ("err:FORG0001: could not cast value from string to double.");
         }
         item_dbl_ := cast_val;
         kind := DBL;
         if (iter.count() != loop003.count()) {
          ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
         }
        } # end of cast from untypedAtomic to double
        { # saveResult5 () : int
         var item_dbl_005 := item_dbl_; # end of saveResult5 () : int
         { # translateVar (lo)
          var vid := v_vid003.ord_uselect(1303761112@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter003);
          pos := vid.leftfetchjoin(v_pos003);
          item := vid.leftfetchjoin(v_item003);
          ipik := iter;
         } # end of translateVar (lo)
         { # '>=' calculation
          var val_snd := item.leftfetchjoin(dbl_values);
          var val_fst := item_dbl_005;
          val_fst := [>=](val_fst,val_snd);
          item := val_fst.[oid]();
          kind := BOOL;
         } # end of '>=' calculation
        } # end of deleteResult5 ()
        { # saveResult5 () : int
         var iter005 := iter;
         var item005 := item; # end of saveResult5 () : int
         { # ifthenelse-translation
          var selected;
          var skip;
          if (type(item005) = bat) {
           selected := item005.ord_uselect(1@0);
           var cnt := selected.count();
           if (item005.count() = cnt) {
            skip := 2;
           } else {
            skip := int(cnt = 0);
           }
          } else {
           skip := 1 + int(item005); # handle constants efficiently
          }
          { # translateIfThen
           var loop004 := loop003;
           var inner004 := inner003;
           var outer004 := outer003;
           var v_iter004 := v_iter003;
           if (skip = 0) {
            iter := selected.mirror().join(iter005);
            iter := iter.tmark(0@0);
            outer004 := iter;
            iter := iter.mark(1@0);
            inner004 := iter;
            loop004 := inner004;
            var expOid := v_iter004.mirror();
            var oidNew_expOid;
            { # expand ()
             var expOid_iter := expOid.leftfetchjoin(v_iter003);
             var iter_expOid := expOid_iter.reverse();
             var oidMap_expOid := outer004.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
             var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
             oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
             var expOid_oidMap := oidMap_expOid.reverse();
             expOid_iter := expOid_oidMap.leftfetchjoin(inner004);
             v_iter004 := expOid_iter;
             oidNew_expOid := expOid_iter.hmark(0@0);
            } # end of expand ()
            # join ()
            var cnt := count(v_iter004)*2;
            v_iter004 := v_iter004.tmark(0@0);
            var new_v_iter := v_iter004;
            var new_v_vid := oidNew_expOid.leftjoin(v_vid003);
            var new_v_pos := oidNew_expOid.leftjoin(v_pos003);
            var new_v_item := oidNew_expOid.leftjoin(v_item003);
            var new_v_kind := oidNew_expOid.leftjoin(v_kind003); # end of join ()
           }
           if (skip != 1) {
            {
             int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
             var itemID := int_values.reverse().find(1LL); # translateConst (kind)
             iter := loop004.tmark(0@0);
             ipik := iter;
            }
           } else { # translateEmpty ()
            ipik := empty_bat;
            iter := empty_bat;
           }
           if (skip = 0) {
            { # mapBack ()
             var iter_oidMap := inner004.reverse();
             var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
             iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
             # kind := kind;
             # ipik := ipik;
            } # end of mapBack ()
           } # cleanUpLevel ()
          } # end of translateIfThen
         } # end of ifthenelse-translation
        } # end of deleteResult5 ()
        { # mapBack ()
         var iter_oidMap := inner003.reverse();
         var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
         iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
         # kind := kind;
         # ipik := ipik;
        } # end of mapBack ()
        # cleanUpLevel ()
       } # end of for-translation
       { # translate fn:empty (item*) as boolean
        var iter_count := {count}(iter.reverse(),loop002.reverse(), FALSE);
        var iter_bool := iter_count.[=](0).[oid]();
        item := iter_bool.tmark(0@0);
        iter := loop002.tmark(0@0);
        ipik := iter;
        pos := 1@0;
        kind := BOOL;
       } # end of translate fn:empty (item*) as boolean
       # translate fn:not (boolean) as boolean
       item := item.leftfetchjoin(bool_not);
       item := item.[int]().[and](item004.[int]()).[oid]();
      } # end of deleteResult4 ()
      { # saveResult4 () : int
       var iter004 := iter;
       var item004 := item; # end of saveResult4 () : int
       { # ifthenelse-translation
        var selected;
        var skip;
        if (type(item004) = bat) {
         selected := item004.ord_uselect(1@0);
         var cnt := selected.count();
         if (item004.count() = cnt) {
          skip := 2;
         } else {
          skip := int(cnt = 0);
         }
        } else {
         skip := 1 + int(item004); # handle constants efficiently
        }
        { # translateIfThen
         var inner003 := inner002;
         var outer003 := outer002;
         var v_vid003 := v_vid002;
         var v_iter003 := v_iter002;
         var v_pos003 := v_pos002;
         var v_item003 := v_item002;
         var v_kind003 := v_kind002;
         if (skip = 0) {
          iter := selected.mirror().join(iter004);
          iter := iter.tmark(0@0);
          outer003 := iter;
          iter := iter.mark(1@0);
          inner003 := iter;
          var expOid := v_iter003.mirror();
          var oidNew_expOid;
          { # expand ()
           var expOid_iter := expOid.leftfetchjoin(v_iter002);
           var iter_expOid := expOid_iter.reverse();
           var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
           var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
           oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
           var expOid_oidMap := oidMap_expOid.reverse();
           expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
           v_iter003 := expOid_iter;
           oidNew_expOid := expOid_iter.hmark(0@0);
          } # end of expand ()
          # join ()
          var cnt := count(v_iter003)*2;
          v_iter003 := v_iter003.tmark(0@0);
          var new_v_iter := v_iter003;
          v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
          var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
          v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
          var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
          v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
          var new_v_item := oidNew_expOid.leftjoin(v_item002);
          v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
          var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
          v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
         }
         if (skip != 1) {
          { # translateVar (#pf:dot_2424)
           var vid := v_vid003.ord_uselect(1303761122@0);
           vid := vid.hmark(0@0);
           iter := vid.leftfetchjoin(v_iter003);
           item := vid.leftfetchjoin(v_item003);
           kind := vid.leftfetchjoin(v_kind003);
           ipik := iter;
          } # end of translateVar (#pf:dot_2424)
         } else { # translateEmpty ()
          ipik := empty_bat;
          iter := empty_bat;
          item := empty_bat;
          kind := empty_kind_bat;
         }
         if (skip = 0) {
          { # mapBack ()
           var iter_oidMap := inner003.reverse();
           var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
           iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
           # kind := kind;
           # ipik := ipik;
          } # end of mapBack ()
         } # cleanUpLevel ()
        } # end of translateIfThen
       } # end of ifthenelse-translation
      } # end of deleteResult4 ()
      { # mapBack ()
       var iter_oidMap := inner002.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
     { # mapBack ()
      var iter_oidMap := inner001.reverse();
      var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
      iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
      # kind := kind;
      # ipik := ipik;
     } # end of mapBack ()
     # cleanUpLevel ()
    } # end of for-translation
    { # translate pf:distinct-doc-order (node*) as node*
     var sorting;
     var simple := false;
     if (type(kind) != bat) {
      simple := (kind = ELEM);
     }
     if (not(simple)) {
      kind := kind.materialize(ipik);
      simple := (kind.count() = kind.get_type(ELEM).count());
     }
     if (simple) {
      sorting := iter.tsort();
      sorting := sorting.CTrefine(kind);
      sorting := sorting.CTrefine(item);
     } else { # cope also with attributes and sort them according to their owner
      var elements := kind.get_type(ELEM).mirror();
      var elem_iters := elements.leftfetchjoin(iter);
      var elem_items := elements.leftfetchjoin(item);
      var elem_frags := elements.leftfetchjoin(kind.get_fragment());
      var elem_attrs := elements.mark(nil);
      var attributes := kind.get_type(ATTR).mirror();
      var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
      var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
      var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
      var attr_key := attributes.hmark(0@0);
      var temp_attr := attr_attrs.tmark(0@0);
      var temp_frag := attr_frags.tmark(0@0);
      var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
      sorting := elem_iters.union(attr_iters).tsort();
      sorting := sorting.CTrefine(elem_frags.union(attr_frags));
      sorting := sorting.CTrefine(elem_items.union(attr_items));
      sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
     }
     ipik := sorting.reverse().{min}().tmark(0@0);
     iter := ipik.leftfetchjoin(iter);
    } # end of translate pf:distinct-doc-order (node*) as node*
    { # translate fn:count (item*) as integer
     iter := iter.materialize(ipik);
     var iter_count := [lng]({count}(iter.reverse(),loop000.reverse(), FALSE)).tmark(0@0);
     item := int_values.addValues(iter_count).tmark(0@0);
     iter := loop000.tmark(0@0);
     ipik := iter;
     pos := 1@0;
     kind := INT;
    } # end of translate fn:count (item*) as integer
    { # saveResult4 () : int
     var ipik004 := ipik;
     var iter004 := iter;
     var pos004 := pos;
     var item004 := item;
     var kind004 := kind; # end of saveResult4 () : int
     { # item-sequence-to-node-sequence
      var nodes_order;
      {
       ipik := ipik004;
       pos := pos004;
       item := item004;
       kind := kind004;
       kind := kind.materialize(ipik);
       var elem := kind.get_type(ELEM);
       elem := elem.hmark(0@0);
       var kind_elem := elem.leftfetchjoin(kind);
       var frag_elem := kind_elem.get_fragment();
       var item_elem := elem.leftfetchjoin(item).materialize(elem);
       var kind_node := mposjoin (item_elem, frag_elem, ws.fetch(PRE_KIND));
       var text := kind_node.ord_uselect(TEXT).hmark(0@0);
       var item_text := text.leftfetchjoin(item_elem);
       var frag_text := text.leftfetchjoin(frag_elem);
       var text_str := mposjoin (mposjoin (item_text, frag_text, ws.fetch(PRE_PROP)), mposjoin (item_text, frag_text, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
       var str_text := text_str.reverse().leftfetchjoin(text);
       var texts := str_text.leftfetchjoin(elem).reverse();
       var texts_order := texts.hmark(0@0);
       texts := texts.tmark(0@0);
       var nodes := kind_node.[!=](TEXT).ord_uselect(true).project("");
       nodes := nodes.reverse().leftfetchjoin(elem).reverse();
       nodes_order := nodes.hmark(0@0);
       nodes := nodes.tmark(0@0);
       var res_mu_is2ns := merged_union (nodes_order, texts_order, nodes, texts, 0@0, 1@0);
       var input_order := res_mu_is2ns.fetch(0);
       var input_str := res_mu_is2ns.fetch(1);
       var input_const := res_mu_is2ns.fetch(2);
       kind := kind.materialize(ipik);
       var atomic := kind.get_type_atomic();
       atomic := atomic.hmark(0@0);
       iter := atomic.mirror();
       item := atomic.leftfetchjoin(item);
       var cast_val := item.leftfetchjoin(int_values).[str]();
       if (cast_val.texist(str(nil))) {
        ERROR ("err:FORG0001: could not cast value from integer to string.");
       }
       item_str_ := cast_val;
       res_mu_is2ns := merged_union (input_order, atomic, input_str, item_str_, input_const, 2@0);
       input_order := res_mu_is2ns.fetch(0);
       input_str := res_mu_is2ns.fetch(1);
       input_const := res_mu_is2ns.fetch(2);
       var input_iter := input_order.leftfetchjoin(iter004).chk_order();
       var result_size := iter004.tunique().count() + nodes_order.count() + 1;
       var result_str := combine_text_string (input_iter.materialize(input_str), input_const.materialize(input_str), input_str, result_size);
       var result_order := result_str.hmark(0@0);
       result_order := result_order.leftfetchjoin(input_order);
       result_str := result_str.tmark(0@0);
       iter := result_order;
       ipik := iter;
       item_str_ := result_str;
      }
      { # adding new strings to text node content and create new nodes
       var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
       var unq_str := item_str_.tunique().hmark(0@0);
       var str_unq := reverse(unq_str.tdiff(ws_prop_text));
       var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
       unq_str := str_unq.hmark(seqb);
       ws_prop_text := ws_prop_text.insert(unq_str);
       var ws_text_prop := ws_prop_text.reverse().sort();
       item_str_ := item_str_.materialize(ipik);
       var X_item := item_str_.hmark(0@0);
       var X_strings := item_str_.tmark(0@0).tsort();
       var X_prop := X_strings.leftjoin(ws_text_prop);
       var newPre_prop := X_item.reverse().leftjoin(X_prop);
       seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS))+ int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
       newPre_prop := newPre_prop.tmark(seqb);
       ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
       ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
       ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
       ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
       ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));
       {
        var kind_pre_ := newPre_prop.hmark(nil).chk_order();
        ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
       }
       item := item_str_.mark(seqb);
       kind := ELEM;
      } # end of adding new strings to text node content and create new nodes
      { # adding new fragments to the WS_FRAG bat
       var seqb := ws.fetch(WS_FRAG).count();
       seqb := oid(seqb);
       var new_pres := item.tmark(seqb);
       ws.fetch(WS_FRAG).insert(new_pres);
       ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
      } # end of adding new fragments to the WS_FRAG bat
      var res_mu_is2ns := merged_union (iter, nodes_order, item, nodes_order.leftfetchjoin(item004), kind, nodes_order.leftfetchjoin(kind004));
      kind004 := kind004.materialize(ipik004);
      var attr := kind004.get_type(ATTR).hmark(0@0);
      var item_attr := attr.leftfetchjoin(item004);
      var kind_attr := attr.leftfetchjoin(kind004);
      res_mu_is2ns := merged_union (res_mu_is2ns.fetch(0), attr, res_mu_is2ns.fetch(1), item_attr, res_mu_is2ns.fetch(2), kind_attr);
      iter := res_mu_is2ns.fetch(0).leftfetchjoin(iter004);
      item := res_mu_is2ns.fetch(1);
      kind := res_mu_is2ns.fetch(2);
      ipik := item;
     } # end of item-sequence-to-node-sequence
    } # end of deleteResult4 ()
    { # map2NODE_interface (counter)
     kind := kind.materialize(ipik);
     var attr := kind.get_type(ATTR).hmark(0@0);
     var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
     var attr_item := attr.leftfetchjoin(item);
     var attr_frag := attr.leftfetchjoin(kind).get_fragment();
     _r_attr_iter := attr_iter;
     _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
     _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
     _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
     var nodes := kind.get_type(ELEM);
     if (nodes.count() != 0) {
      var oid_oid := nodes.hmark(0@0);
      var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
      var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
      var iter_input := oid_oid.mirror();
      var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
      var res_iter := res_scj.fetch(0);
      var res_item := res_scj.fetch(1);
      var res_frag := res_scj.fetch(2);
      _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
      _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
      _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
      _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
      _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
      var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
      var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
      nodes := res_item.mark(0@0);
      var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      root_level := nodes.leftfetchjoin(root_level);
      temp_ec_item := res_item;
      temp_ec_frag := res_frag;
      var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
      content_level := nodes.leftfetchjoin(content_level);
      content_level := content_level.[-](root_level);
      content_level := content_level.tmark(0@0);
      _elem_level := content_level;
      { # create attribute subtree copies
       var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
       var oid_attr := temp_attr.tmark(0@0);
       var oid_frag;
       if (is_constant(res_frag)) {
        oid_frag := res_frag;
       } else {
        oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
        oid_frag := oid_frag.tmark(0@0);
       }
       _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
       _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
       _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
       _attr_own  := temp_attr.hmark(0@0);
       _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
      } # end of create attribute subtree copies
     } else { # if (nodes.count() != 0) ...
      _elem_iter  := empty_bat;
      _elem_size  := empty_bat.project(int(nil));
      _elem_level := empty_bat.project(chr(nil));
      _elem_kind  := empty_bat.project(chr(nil));
      _elem_prop  := empty_bat;
      _elem_frag  := empty_bat;
      _attr_iter  := empty_bat;
      _attr_qn    := empty_bat;
      _attr_prop  := empty_bat;
      _attr_frag  := empty_bat;
      _attr_own   := empty_bat;
     } # end of else in 'if (nodes.count() != 0)'
    } # end of map2NODE_interface (counter)
    { # loop_liftedElemConstr (counter)
     var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
     iter_size := {count}(iter_size, iter003.tunique(), FALSE);
     var root_iter  := iter_size.hmark(0@0).chk_order();
     var root_size  := iter_size.tmark(0@0);
     var root_prop  := iter003.reverse().leftfetchjoin(item003);
     if (not(is_constant(root_prop))) {
      root_prop  := root_prop.tmark(0@0);
     }
     {
      var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
      _elem_iter  := merged_result.fetch(0);
      _elem_size  := merged_result.fetch(1);
      _elem_level := merged_result.fetch(2);
      _elem_kind  := merged_result.fetch(3);
      _elem_prop  := merged_result.fetch(4);
      _elem_frag  := merged_result.fetch(5);
      var preNew_preOld := merged_result.fetch(6);
      _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
      _attr_own := _attr_own.tmark(0@0);
     }
     { # create attribute root entries
      var root_item := _elem_level.ord_uselect(chr(0));
      root_item := root_item.hmark(0@0);
      var iter_item := iter003.reverse().leftfetchjoin(root_item);
      var attr_own := _r_attr_iter.leftjoin(iter_item);
      if (_r_attr_iter.count() != 0) { # test uniqueness
       var sorting := _r_attr_iter.tsort();
       sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
       var unq_attrs := sorting.tunique();
       if (unq_attrs.count() != _r_attr_iter.count()) {
        item003 := materialize(item003,ipik003);
        if (item003.count() > 0) {
         ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item003.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
        } else {
         ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
        }
       }
      } # end of test uniqueness
      if (_attr_iter.count() = 0) {
       _attr_iter := _r_attr_iter;
       _attr_qn   := _r_attr_qn;
       _attr_prop := _r_attr_prop;
       _attr_frag := _r_attr_frag;
       _attr_own  := attr_own.tmark(0@0);
      } else {
       var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
       _r_attr_iter := _r_attr_iter.tmark(seqb);
       _r_attr_qn   := _r_attr_qn  .tmark(seqb);
       _r_attr_prop := _r_attr_prop.tmark(seqb);
       _r_attr_frag := _r_attr_frag.tmark(seqb);
       attr_own := attr_own.tmark(seqb);
       _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
       _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
       _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
       _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
       _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
      }
      _r_attr_iter := empty_bat;
      _r_attr_qn   := empty_bat;
      _r_attr_prop := empty_bat;
      _r_attr_frag := empty_bat;
     } # end of create attribute root entries
    } # end of loop_liftedElemConstr (counter)
   } # end of deleteResult3 ()
   { # saveResult_node3 () : int
    var _elem_iter003   := _elem_iter  ;
    var _elem_size003   := _elem_size  ;
    var _elem_level003  := _elem_level ;
    var _elem_kind003   := _elem_kind  ;
    var _elem_prop003   := _elem_prop  ;
    var _elem_frag003   := _elem_frag  ;
    var _attr_iter003   := _attr_iter  ;
    var _attr_qn003     := _attr_qn    ;
    var _attr_prop003   := _attr_prop  ;
    var _attr_frag003   := _attr_frag  ;
    var _attr_own003    := _attr_own   ;
    var _r_attr_iter003 := _r_attr_iter;
    var _r_attr_qn003   := _r_attr_qn  ;
    var _r_attr_prop003 := _r_attr_prop;
    var _r_attr_frag003 := _r_attr_frag; # end of saveResult_node3 () : int
    { # tagname-translation
     var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
     var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
     var itemID;
     if (prop_str.texist("challenge")) {
      itemID := prop_str.reverse().find("challenge");
     } else {
      itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
      ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
      ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
      ws.fetch(QN_LOC).fetch(WS).insert(itemID,"challenge");
      ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
      ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"challenge"+str('\1')+"");
     } # translateConst (kind)
     iter := loop000.tmark(0@0);
     ipik := iter;
     pos := 1@0;
     item := itemID;
     kind := QNAME;
    } # end of tagname-translation
    { # saveResult4 () : int
     var ipik004 := ipik;
     var iter004 := iter;
     var item004 := item; # end of saveResult4 () : int
     { # translateVar (auction)
      var vid := v_vid000.ord_uselect(1303761114@0);
      vid := vid.hmark(0@0);
      iter := vid.leftfetchjoin(v_iter000);
      item := vid.leftfetchjoin(v_item000);
      kind := vid.leftfetchjoin(v_kind000);
      ipik := iter;
     } # end of translateVar (auction)
     if (ipik.count() != 0) 
     { # for-translation
      # project ()
      iter := iter.materialize(ipik);
      var outer001 := iter;
      iter := iter.mark(1@0);
      var inner001 := iter;
      pos := 1@0;
      var v_vid001;
      var v_iter001;
      var v_pos001;
      var v_item001;
      var v_kind001;
      var expOid;
      { # getExpanded (fid)
       var vu_nil := vu_fid.ord_uselect(1303761084@0);
       var vid_vu := vu_vid.reverse();
       var oid_nil := vid_vu.leftjoin(vu_nil);
       expOid := v_vid000.leftjoin(oid_nil);
       expOid := expOid.mirror();
      } # end of getExpanded (fid)
      if (expOid.count() != 0) {
       var oidNew_expOid;
       { # expand ()
        var expOid_iter := expOid.leftfetchjoin(v_iter000);
        var iter_expOid := expOid_iter.reverse();
        var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
        var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
        oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
        var expOid_oidMap := oidMap_expOid.reverse();
        expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
        v_iter001 := expOid_iter;
        oidNew_expOid := expOid_iter.hmark(0@0);
       } # end of expand ()
       # join ()
       var cnt := count(v_iter001)*2;
       v_iter001 := v_iter001.tmark(0@0);
       var new_v_iter := v_iter001;
       v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
       var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
       v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
       var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
       v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
       var new_v_item := oidNew_expOid.leftjoin(v_item000);
       v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
       var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
       v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
      } else { # createNewVarTable ()
       v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
       v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
      }
      { # insertVar (vid)
       var vid := project(ipik,1303761126@0);
       { # append (vid, level)
        var seqb := oid(v_vid001.count());
        vid := vid.materialize(ipik);
        v_vid001 := v_vid001.insert(vid.tmark(seqb));
       } # append (vid, level)
       { # append (iter, level)
        var seqb := oid(v_iter001.count());
        iter := iter.materialize(ipik);
        v_iter001 := v_iter001.insert(iter.tmark(seqb));
       } # append (iter, level)
       { # append (pos, level)
        var seqb := oid(v_pos001.count());
        pos := pos.materialize(ipik);
        v_pos001 := v_pos001.insert(pos.tmark(seqb));
       } # append (pos, level)
       { # append (item, level)
        var seqb := oid(v_item001.count());
        item := item.materialize(ipik);
        v_item001 := v_item001.insert(item.tmark(seqb));
       } # append (item, level)
       { # append (kind, level)
        var seqb := oid(v_kind001.count());
        kind := kind.materialize(ipik);
        v_kind001 := v_kind001.insert(kind.tmark(seqb));
       } # append (kind, level)
      } # end of insertVar (vid)
      { # translateVar (#pf:dot_2553)
       var vid := v_vid001.ord_uselect(1303761126@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter001);
       item := vid.leftfetchjoin(v_item001);
       kind := vid.leftfetchjoin(v_kind001);
       ipik := iter;
      } # end of translateVar (#pf:dot_2553)
      { # translateLocsteps (c)
       var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "profile");
       iter := res_scj.fetch(0);
       item := res_scj.fetch(1);
       kind := res_scj.fetch(2).set_kind(ELEM);
       ipik := item;
      } # end of translateLocsteps (c)
      if (ipik.count() != 0) 
      { # for-translation
       # project ()
       iter := iter.materialize(ipik);
       var outer002 := iter;
       var order_002 := iter;
       iter := iter.mark(1@0);
       var inner002 := iter;
       pos := 1@0;
       var loop002 := inner002;
       var v_vid002;
       var v_iter002;
       var v_pos002;
       var v_item002;
       var v_kind002;
       var expOid;
       { # getExpanded (fid)
        var vu_nil := vu_fid.ord_uselect(1303761085@0);
        var vid_vu := vu_vid.reverse();
        var oid_nil := vid_vu.leftjoin(vu_nil);
        expOid := v_vid001.leftjoin(oid_nil);
        expOid := expOid.mirror();
       } # end of getExpanded (fid)
       if (expOid.count() != 0) {
        var oidNew_expOid;
        { # expand ()
         var expOid_iter := expOid.leftfetchjoin(v_iter001);
         var iter_expOid := expOid_iter.reverse();
         var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
         var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
         oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
         var expOid_oidMap := oidMap_expOid.reverse();
         expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
         v_iter002 := expOid_iter;
         oidNew_expOid := expOid_iter.hmark(0@0);
        } # end of expand ()
        # join ()
        var cnt := count(v_iter002)*2;
        v_iter002 := v_iter002.tmark(0@0);
        var new_v_iter := v_iter002;
        v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
        var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
        v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
        var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
        v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
        var new_v_item := oidNew_expOid.leftjoin(v_item001);
        v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
        var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
        v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
       } else { # createNewVarTable ()
        v_iter002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_vid002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_pos002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_item002 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_kind002 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
       }
       { # insertVar (vid)
        var vid := project(ipik,1303761128@0);
        { # append (vid, level)
         var seqb := oid(v_vid002.count());
         vid := vid.materialize(ipik);
         v_vid002 := v_vid002.insert(vid.tmark(seqb));
        } # append (vid, level)
        { # append (iter, level)
         var seqb := oid(v_iter002.count());
         iter := iter.materialize(ipik);
         v_iter002 := v_iter002.insert(iter.tmark(seqb));
        } # append (iter, level)
        { # append (pos, level)
         var seqb := oid(v_pos002.count());
         pos := pos.materialize(ipik);
         v_pos002 := v_pos002.insert(pos.tmark(seqb));
        } # append (pos, level)
        { # append (item, level)
         var seqb := oid(v_item002.count());
         item := item.materialize(ipik);
         v_item002 := v_item002.insert(item.tmark(seqb));
        } # append (item, level)
        { # append (kind, level)
         var seqb := oid(v_kind002.count());
         kind := kind.materialize(ipik);
         v_kind002 := v_kind002.insert(kind.tmark(seqb));
        } # append (kind, level)
       } # end of insertVar (vid)
       { # translateVar (#pf:dot_2567)
        var vid := v_vid002.ord_uselect(1303761128@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter002);
        item := vid.leftfetchjoin(v_item002);
        kind := vid.leftfetchjoin(v_kind002);
        ipik := iter;
       } # end of translateVar (#pf:dot_2567)
       { # loop_liftedSCJ (axis, kind, ns, loc)
        { # attribute axis
         var oid_iter := iter;
         var oid_item := item.materialize(ipik);
         var oid_frag := kind.get_fragment();
         var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
         oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
         var oid_attr := temp1.tmark(0@0);
         oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
         var temp1_str; # only needed for name test
         temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
         temp1 := temp1_str.ord_uselect("");
         temp1 := temp1.hmark(0@0);
         oid_attr := temp1.leftfetchjoin(oid_attr);
         oid_frag := temp1.leftfetchjoin(oid_frag);
         oid_iter := temp1.leftfetchjoin(oid_iter);
         temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
         temp1 := temp1_str.ord_uselect("income");
         temp1 := temp1.hmark(0@0);
         oid_attr := temp1.leftfetchjoin(oid_attr);
         oid_frag := temp1.leftfetchjoin(oid_frag);
         oid_iter := temp1.leftfetchjoin(oid_iter);
         iter := oid_iter.tmark(0@0);
         item := oid_attr.tmark(0@0);
         kind := oid_frag.tmark(0@0);
         if (type(iter) = bat) {
          ipik := iter;
         } else {
          if (type(item) = bat) {
           ipik := item;
          } else {
           ipik := kind;
          }
         }
        } # end of attribute axis
        kind := kind.set_kind(ATTR);
       } # end of translateLocsteps (c)
       if (ipik.count() != 0) 
       { # for-translation
        # project ()
        iter := iter.materialize(ipik);
        var outer003 := iter;
        var order_003 := iter;
        iter := iter.mark(1@0);
        var inner003 := iter;
        pos := 1@0;
        var loop003 := inner003;
        var v_vid003;
        var v_iter003;
        var v_pos003;
        var v_item003;
        var v_kind003;
        var expOid;
        { # getExpanded (fid)
         var vu_nil := vu_fid.ord_uselect(1303761086@0);
         var vid_vu := vu_vid.reverse();
         var oid_nil := vid_vu.leftjoin(vu_nil);
         expOid := v_vid002.leftjoin(oid_nil);
         expOid := expOid.mirror();
        } # end of getExpanded (fid)
        if (expOid.count() != 0) {
         var oidNew_expOid;
         { # expand ()
          var expOid_iter := expOid.leftfetchjoin(v_iter002);
          var iter_expOid := expOid_iter.reverse();
          var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
          var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
          oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
          var expOid_oidMap := oidMap_expOid.reverse();
          expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
          v_iter003 := expOid_iter;
          oidNew_expOid := expOid_iter.hmark(0@0);
         } # end of expand ()
         # join ()
         var cnt := count(v_iter003)*2;
         v_iter003 := v_iter003.tmark(0@0);
         var new_v_iter := v_iter003;
         v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
         var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
         v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
         var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
         v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
         var new_v_item := oidNew_expOid.leftjoin(v_item002);
         v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
         var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
         v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
        } else { # createNewVarTable ()
         v_iter003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
         v_vid003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
         v_pos003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
         v_item003 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
         v_kind003 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
        }
        { # insertVar (vid)
         var vid := project(ipik,1303761130@0);
         { # append (vid, level)
          var seqb := oid(v_vid003.count());
          vid := vid.materialize(ipik);
          v_vid003 := v_vid003.insert(vid.tmark(seqb));
         } # append (vid, level)
         { # append (iter, level)
          var seqb := oid(v_iter003.count());
          iter := iter.materialize(ipik);
          v_iter003 := v_iter003.insert(iter.tmark(seqb));
         } # append (iter, level)
         { # append (pos, level)
          var seqb := oid(v_pos003.count());
          pos := pos.materialize(ipik);
          v_pos003 := v_pos003.insert(pos.tmark(seqb));
         } # append (pos, level)
         { # append (item, level)
          var seqb := oid(v_item003.count());
          item := item.materialize(ipik);
          v_item003 := v_item003.insert(item.tmark(seqb));
         } # append (item, level)
         { # append (kind, level)
          var seqb := oid(v_kind003.count());
          kind := kind.materialize(ipik);
          v_kind003 := v_kind003.insert(kind.tmark(seqb));
         } # append (kind, level)
        } # end of insertVar (vid)
        { # translateVar (#pf:v_2836)
         var vid := v_vid003.ord_uselect(1303761130@0);
         vid := vid.hmark(0@0);
         iter := vid.leftfetchjoin(v_iter003);
         item := vid.leftfetchjoin(v_item003);
         kind := vid.leftfetchjoin(v_kind003);
         ipik := iter;
        } # end of translateVar (#pf:v_2836)
        { # string-value
         var input_iter := iter;
         kind := kind.materialize(ipik);
         item := item.materialize(ipik);
         iter := iter.materialize(ipik);
         var kind_elem := kind.get_type(ELEM);
         var item_str;
         if (kind_elem.count() = kind.count()) {
          var frag := kind.get_fragment();
          var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
          var t_iter := res_scj.fetch(0);
          var t_item := res_scj.fetch(1);
          var t_frag := res_scj.fetch(2);
          var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
          var t_iter_unq := t_iter.tunique();
          t_iter := t_iter.materialize(t_item);
          if (t_iter_unq.count() != t_item.count()) {
           var iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
           iter_item := iter_item.string_join(t_iter_unq.project(""));
           t_iter := iter_item.hmark(0@0);
           t_item_str := iter_item.tmark(0@0);
          }
          var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
          if (c_map.count() > 0) { #process comments 
           var c_iter := c_map.leftfetchjoin(iter);
           var c_item := c_map.leftfetchjoin(item);
           var c_frag := c_map.leftfetchjoin(frag);
           var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
           var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
          } # end of comment processing
          var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
          if (pi_map.count() > 0) { #process processing-instructions 
           var pi_iter := pi_map.leftfetchjoin(iter);
           var pi_item := pi_map.leftfetchjoin(item);
           var pi_frag := pi_map.leftfetchjoin(frag);
           var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
           var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
           t_item_str := res_mu.fetch(1);
          } # end of processing-instruction processing
          iter := t_iter;
          item_str := t_item_str;
         } else {
          var kind_attr := kind.get_type(ATTR);
          if (kind_attr.count() = kind.count()) {
           var frag := kind.get_fragment();
           item_str := mposjoin(mposjoin(item, frag, ws.fetch(ATTR_PROP)), mposjoin(item, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
          } else {
           kind_attr := kind_attr.hmark(0@0);
           var item_attr := kind_attr.leftfetchjoin(item);
           var iter_attr := kind_attr.leftfetchjoin(iter);
           var frag := kind_attr.leftfetchjoin(kind).get_fragment();
           var item_attr_str := mposjoin(mposjoin(item_attr, frag, ws.fetch(ATTR_PROP)), mposjoin(item_attr, frag, ws.fetch(ATTR_FRAG)), ws.fetch(PROP_VAL));
           kind_elem := kind_elem.hmark(0@0);
           iter := kind_elem.leftfetchjoin(iter).materialize(kind_elem);
           frag := kind_elem.leftfetchjoin(kind).get_fragment();
           item := kind_elem.leftfetchjoin(item).materialize(kind_elem);
           var res_scj := loop_lifted_descendant_or_self_step_with_kind_test(iter, item, constant2bat(frag), ws, 0, TEXT);
           var t_iter := res_scj.fetch(0);
           var t_item := res_scj.fetch(1);
           var t_frag := res_scj.fetch(2);
           var t_item_str := mposjoin(mposjoin(t_item, t_frag, ws.fetch(PRE_PROP)), mposjoin(t_item, t_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
           var iter_item := t_iter.materialize(t_item).reverse().leftfetchjoin(t_item_str);
           t_iter := iter_item.hmark(0@0);
           t_item_str := iter_item.tmark(0@0);
           var res_mu := merged_union (t_iter, iter_attr, t_item_str, item_attr_str);
           t_iter := res_mu.fetch(0);
           t_item_str := res_mu.fetch(1);
           iter_item := t_iter.reverse().leftfetchjoin(t_item_str).chk_order();
           {
            var item_unq := iter_item.reverse().tunique();
            if (item_unq.count() != iter_item.count()) iter_item := iter_item.string_join(item_unq.project(""));
           }
           t_iter := iter_item.hmark(0@0);
           var t_item_str := iter_item.tmark(0@0);
           var c_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(COMMENT).hmark(0@0);
           if (c_map.count() > 0) { #process comments 
            var c_iter := c_map.leftfetchjoin(iter);
            var c_item := c_map.leftfetchjoin(item);
            var c_frag := c_map.leftfetchjoin(frag);
            var c_item_str := mposjoin(mposjoin(c_item, c_frag, ws.fetch(PRE_PROP)), mposjoin(c_item, c_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_COM));
            var res_mu := merged_union (t_iter, c_iter, t_item_str, c_item_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
           } # end of comment processing
           var pi_map := mposjoin (item, frag, ws.fetch (PRE_KIND)).select(PI).hmark(0@0);
           if (pi_map.count() > 0) { #process processing-instructions 
            var pi_iter := pi_map.leftfetchjoin(iter);
            var pi_item := pi_map.leftfetchjoin(item);
            var pi_frag := pi_map.leftfetchjoin(frag);
            var pi_item_str := mposjoin(mposjoin(pi_item, pi_frag, ws.fetch(PRE_PROP)), mposjoin(pi_item, pi_frag, ws.fetch(PRE_FRAG)), ws.fetch(PROP_INS));
            var res_mu := merged_union (t_iter, pi_iter, t_item_str, pi_item_str);
            t_iter := res_mu.fetch(0);
            t_item_str := res_mu.fetch(1);
           } # end of processing-instruction processing
           iter := t_iter;
           item_str := t_item_str;
          }
         }
         item_str_ := item_str;
         if (iter.count() != input_iter.tunique().count()) {
          var difference := reverse(input_iter.tdiff(iter));
          difference := difference.hmark(0@0);
          var res_mu := merged_union(iter, difference, item_str_, "");
          iter := res_mu.fetch(0);
          item_str_ := res_mu.fetch(1);
         }
         ipik := iter;
         pos := tmark_grp_unique(iter,ipik);
        } # end of string-value
        { # cast from string to untypedAtomic
         if (iter.count() != loop003.count()) {
          ERROR("err:XPTY0004: cast to 'untypedAtomic' does not allow empty sequences to be casted.");
         }
        } # end of cast from string to untypedAtomic
        { # cast from untypedAtomic to double
         var cast_val := item_str_.[dbl]();
         if (cast_val.texist(dbl(nil))) {
          ERROR ("err:FORG0001: could not cast value from string to double.");
         }
         item_dbl_ := cast_val;
         kind := DBL;
         if (iter.count() != loop003.count()) {
          ERROR("err:XPTY0004: cast to 'double' does not allow empty sequences to be casted.");
         }
        } # end of cast from untypedAtomic to double
        { # saveResult5 () : int
         var item_dbl_005 := item_dbl_; # end of saveResult5 () : int
         { # translateVar (lo)
          var vid := v_vid003.ord_uselect(1303761112@0);
          vid := vid.hmark(0@0);
          iter := vid.leftfetchjoin(v_iter003);
          pos := vid.leftfetchjoin(v_pos003);
          item := vid.leftfetchjoin(v_item003);
          ipik := iter;
         } # end of translateVar (lo)
         { # '<' calculation
          var val_snd := item.leftfetchjoin(dbl_values);
          var val_fst := item_dbl_005;
          val_fst := [<](val_fst,val_snd);
          item := val_fst.[oid]();
          kind := BOOL;
         } # end of '<' calculation
        } # end of deleteResult5 ()
        { # saveResult5 () : int
         var iter005 := iter;
         var item005 := item; # end of saveResult5 () : int
         { # ifthenelse-translation
          var selected;
          var skip;
          if (type(item005) = bat) {
           selected := item005.ord_uselect(1@0);
           var cnt := selected.count();
           if (item005.count() = cnt) {
            skip := 2;
           } else {
            skip := int(cnt = 0);
           }
          } else {
           skip := 1 + int(item005); # handle constants efficiently
          }
          { # translateIfThen
           var loop004 := loop003;
           var inner004 := inner003;
           var outer004 := outer003;
           var v_iter004 := v_iter003;
           if (skip = 0) {
            iter := selected.mirror().join(iter005);
            iter := iter.tmark(0@0);
            outer004 := iter;
            iter := iter.mark(1@0);
            inner004 := iter;
            loop004 := inner004;
            var expOid := v_iter004.mirror();
            var oidNew_expOid;
            { # expand ()
             var expOid_iter := expOid.leftfetchjoin(v_iter003);
             var iter_expOid := expOid_iter.reverse();
             var oidMap_expOid := outer004.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer004.leftjoin(iter_expOid)' a stable join
             var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
             oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
             var expOid_oidMap := oidMap_expOid.reverse();
             expOid_iter := expOid_oidMap.leftfetchjoin(inner004);
             v_iter004 := expOid_iter;
             oidNew_expOid := expOid_iter.hmark(0@0);
            } # end of expand ()
            # join ()
            var cnt := count(v_iter004)*2;
            v_iter004 := v_iter004.tmark(0@0);
            var new_v_iter := v_iter004;
            var new_v_vid := oidNew_expOid.leftjoin(v_vid003);
            var new_v_pos := oidNew_expOid.leftjoin(v_pos003);
            var new_v_item := oidNew_expOid.leftjoin(v_item003);
            var new_v_kind := oidNew_expOid.leftjoin(v_kind003); # end of join ()
           }
           if (skip != 1) {
            {
             int_values := int_values.seqbase(nil).insert(nil,1LL).seqbase(0@0);
             var itemID := int_values.reverse().find(1LL); # translateConst (kind)
             iter := loop004.tmark(0@0);
             ipik := iter;
            }
           } else { # translateEmpty ()
            ipik := empty_bat;
            iter := empty_bat;
           }
           if (skip = 0) {
            { # mapBack ()
             var iter_oidMap := inner004.reverse();
             var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
             iter := oid_oidMap.leftfetchjoin(outer004); # item := item;
             # kind := kind;
             # ipik := ipik;
            } # end of mapBack ()
           } # cleanUpLevel ()
          } # end of translateIfThen
         } # end of ifthenelse-translation
        } # end of deleteResult5 ()
        { # mapBack ()
         var iter_oidMap := inner003.reverse();
         var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
         iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
         # kind := kind;
         # ipik := ipik;
        } # end of mapBack ()
        # cleanUpLevel ()
       } # end of for-translation
       { # translate fn:empty (item*) as boolean
        var iter_count := {count}(iter.reverse(),loop002.reverse(), FALSE);
        var iter_bool := iter_count.[=](0).[oid]();
        item := iter_bool.tmark(0@0);
        iter := loop002.tmark(0@0);
        ipik := iter;
        pos := 1@0;
        kind := BOOL;
       } # end of translate fn:empty (item*) as boolean
       { # saveResult5 () : int
        var iter005 := iter;
        var item005 := item; # end of saveResult5 () : int
        { # ifthenelse-translation
         var selected;
         var skip;
         if (type(item005) = bat) {
          selected := item005.ord_uselect(1@0);
          var cnt := selected.count();
          if (item005.count() = cnt) {
           skip := 2;
          } else {
           skip := int(cnt = 0);
          }
         } else {
          skip := 1 + int(item005); # handle constants efficiently
         }
         { # translateIfThen
          var inner003 := inner002;
          var outer003 := outer002;
          var v_vid003 := v_vid002;
          var v_iter003 := v_iter002;
          var v_pos003 := v_pos002;
          var v_item003 := v_item002;
          var v_kind003 := v_kind002;
          if (skip = 0) {
           selected := item005.ord_uselect(0@0);
           iter := selected.mirror().join(iter005);
           iter := iter.tmark(0@0);
           outer003 := iter;
           iter := iter.mark(1@0);
           inner003 := iter;
           var expOid := v_iter003.mirror();
           var oidNew_expOid;
           { # expand ()
            var expOid_iter := expOid.leftfetchjoin(v_iter002);
            var iter_expOid := expOid_iter.reverse();
            var oidMap_expOid := outer003.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer003.leftjoin(iter_expOid)' a stable join
            var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
            oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
            var expOid_oidMap := oidMap_expOid.reverse();
            expOid_iter := expOid_oidMap.leftfetchjoin(inner003);
            v_iter003 := expOid_iter;
            oidNew_expOid := expOid_iter.hmark(0@0);
           } # end of expand ()
           # join ()
           var cnt := count(v_iter003)*2;
           v_iter003 := v_iter003.tmark(0@0);
           var new_v_iter := v_iter003;
           v_iter003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
           var new_v_vid := oidNew_expOid.leftjoin(v_vid002);
           v_vid003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
           var new_v_pos := oidNew_expOid.leftjoin(v_pos002);
           v_pos003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
           var new_v_item := oidNew_expOid.leftjoin(v_item002);
           v_item003 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
           var new_v_kind := oidNew_expOid.leftjoin(v_kind002);
           v_kind003 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
          }
          if (skip != 2) {
           { # translateVar (#pf:dot_2567)
            var vid := v_vid003.ord_uselect(1303761128@0);
            vid := vid.hmark(0@0);
            iter := vid.leftfetchjoin(v_iter003);
            item := vid.leftfetchjoin(v_item003);
            kind := vid.leftfetchjoin(v_kind003);
            ipik := iter;
           } # end of translateVar (#pf:dot_2567)
          } else { # translateEmpty ()
           ipik := empty_bat;
           iter := empty_bat;
           item := empty_bat;
           kind := empty_kind_bat;
          }
          if (skip = 0) {
           { # mapBack ()
            var iter_oidMap := inner003.reverse();
            var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
            iter := oid_oidMap.leftfetchjoin(outer003); # item := item;
            # kind := kind;
            # ipik := ipik;
           } # end of mapBack ()
          } # cleanUpLevel ()
         } # end of translateIfThen
        } # end of ifthenelse-translation
       } # end of deleteResult5 ()
       { # mapBack ()
        var iter_oidMap := inner002.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
       # cleanUpLevel ()
      } # end of for-translation
      { # mapBack ()
       var iter_oidMap := inner001.reverse();
       var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
       iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
       # kind := kind;
       # ipik := ipik;
      } # end of mapBack ()
      # cleanUpLevel ()
     } # end of for-translation
     { # translate pf:distinct-doc-order (node*) as node*
      var sorting;
      var simple := false;
      if (type(kind) != bat) {
       simple := (kind = ELEM);
      }
      if (not(simple)) {
       kind := kind.materialize(ipik);
       simple := (kind.count() = kind.get_type(ELEM).count());
      }
      if (simple) {
       sorting := iter.tsort();
       sorting := sorting.CTrefine(kind);
       sorting := sorting.CTrefine(item);
      } else { # cope also with attributes and sort them according to their owner
       var elements := kind.get_type(ELEM).mirror();
       var elem_iters := elements.leftfetchjoin(iter);
       var elem_items := elements.leftfetchjoin(item);
       var elem_frags := elements.leftfetchjoin(kind.get_fragment());
       var elem_attrs := elements.mark(nil);
       var attributes := kind.get_type(ATTR).mirror();
       var attr_iters := attributes.leftfetchjoin(iter).materialize(attributes);
       var attr_attrs := attributes.leftfetchjoin(item).materialize(attributes);
       var attr_frags := attributes.leftfetchjoin(kind.get_fragment());
       var attr_key := attributes.hmark(0@0);
       var temp_attr := attr_attrs.tmark(0@0);
       var temp_frag := attr_frags.tmark(0@0);
       var attr_items := attr_key.reverse().leftfetchjoin(mposjoin(temp_attr, temp_frag, ws.fetch(ATTR_OWN)));
       sorting := elem_iters.union(attr_iters).tsort();
       sorting := sorting.CTrefine(elem_frags.union(attr_frags));
       sorting := sorting.CTrefine(elem_items.union(attr_items));
       sorting := sorting.CTrefine(elem_attrs.union(attr_attrs));
      }
      ipik := sorting.reverse().{min}().tmark(0@0);
      iter := ipik.leftfetchjoin(iter);
     } # end of translate pf:distinct-doc-order (node*) as node*
     { # translate fn:count (item*) as integer
      iter := iter.materialize(ipik);
      var iter_count := [lng]({count}(iter.reverse(),loop000.reverse(), FALSE)).tmark(0@0);
      item := int_values.addValues(iter_count).tmark(0@0);
      iter := loop000.tmark(0@0);
      ipik := iter;
      pos := 1@0;
      kind := INT;
     } # end of translate fn:count (item*) as integer
     { # saveResult5 () : int
      var ipik005 := ipik;
      var iter005 := iter;
      var pos005 := pos;
      var item005 := item;
      var kind005 := kind; # end of saveResult5 () : int
      { # item-sequence-to-node-sequence
       var nodes_order;
       {
        ipik := ipik005;
        pos := pos005;
        item := item005;
        kind := kind005;
        kind := kind.materialize(ipik);
        var elem := kind.get_type(ELEM);
        elem := elem.hmark(0@0);
        var kind_elem := elem.leftfetchjoin(kind);
        var frag_elem := kind_elem.get_fragment();
        var item_elem := elem.leftfetchjoin(item).materialize(elem);
        var kind_node := mposjoin (item_elem, frag_elem, ws.fetch(PRE_KIND));
        var text := kind_node.ord_uselect(TEXT).hmark(0@0);
        var item_text := text.leftfetchjoin(item_elem);
        var frag_text := text.leftfetchjoin(frag_elem);
        var text_str := mposjoin (mposjoin (item_text, frag_text, ws.fetch(PRE_PROP)), mposjoin (item_text, frag_text, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
        var str_text := text_str.reverse().leftfetchjoin(text);
        var texts := str_text.leftfetchjoin(elem).reverse();
        var texts_order := texts.hmark(0@0);
        texts := texts.tmark(0@0);
        var nodes := kind_node.[!=](TEXT).ord_uselect(true).project("");
        nodes := nodes.reverse().leftfetchjoin(elem).reverse();
        nodes_order := nodes.hmark(0@0);
        nodes := nodes.tmark(0@0);
        var res_mu_is2ns := merged_union (nodes_order, texts_order, nodes, texts, 0@0, 1@0);
        var input_order := res_mu_is2ns.fetch(0);
        var input_str := res_mu_is2ns.fetch(1);
        var input_const := res_mu_is2ns.fetch(2);
        kind := kind.materialize(ipik);
        var atomic := kind.get_type_atomic();
        atomic := atomic.hmark(0@0);
        iter := atomic.mirror();
        item := atomic.leftfetchjoin(item);
        var cast_val := item.leftfetchjoin(int_values).[str]();
        if (cast_val.texist(str(nil))) {
         ERROR ("err:FORG0001: could not cast value from integer to string.");
        }
        item_str_ := cast_val;
        res_mu_is2ns := merged_union (input_order, atomic, input_str, item_str_, input_const, 2@0);
        input_order := res_mu_is2ns.fetch(0);
        input_str := res_mu_is2ns.fetch(1);
        input_const := res_mu_is2ns.fetch(2);
        var input_iter := input_order.leftfetchjoin(iter005).chk_order();
        var result_size := iter005.tunique().count() + nodes_order.count() + 1;
        var result_str := combine_text_string (input_iter.materialize(input_str), input_const.materialize(input_str), input_str, result_size);
        var result_order := result_str.hmark(0@0);
        result_order := result_order.leftfetchjoin(input_order);
        result_str := result_str.tmark(0@0);
        iter := result_order;
        ipik := iter;
        item_str_ := result_str;
       }
       { # adding new strings to text node content and create new nodes
        var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
        var unq_str := item_str_.tunique().hmark(0@0);
        var str_unq := reverse(unq_str.tdiff(ws_prop_text));
        var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
        unq_str := str_unq.hmark(seqb);
        ws_prop_text := ws_prop_text.insert(unq_str);
        var ws_text_prop := ws_prop_text.reverse().sort();
        item_str_ := item_str_.materialize(ipik);
        var X_item := item_str_.hmark(0@0);
        var X_strings := item_str_.tmark(0@0).tsort();
        var X_prop := X_strings.leftjoin(ws_text_prop);
        var newPre_prop := X_item.reverse().leftjoin(X_prop);
        seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS))+ int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
        newPre_prop := newPre_prop.tmark(seqb);
        ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
        ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
        ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
        ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
        ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));
        {
         var kind_pre_ := newPre_prop.hmark(nil).chk_order();
         ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
        }
        item := item_str_.mark(seqb);
        kind := ELEM;
       } # end of adding new strings to text node content and create new nodes
       { # adding new fragments to the WS_FRAG bat
        var seqb := ws.fetch(WS_FRAG).count();
        seqb := oid(seqb);
        var new_pres := item.tmark(seqb);
        ws.fetch(WS_FRAG).insert(new_pres);
        ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
       } # end of adding new fragments to the WS_FRAG bat
       var res_mu_is2ns := merged_union (iter, nodes_order, item, nodes_order.leftfetchjoin(item005), kind, nodes_order.leftfetchjoin(kind005));
       kind005 := kind005.materialize(ipik005);
       var attr := kind005.get_type(ATTR).hmark(0@0);
       var item_attr := attr.leftfetchjoin(item005);
       var kind_attr := attr.leftfetchjoin(kind005);
       res_mu_is2ns := merged_union (res_mu_is2ns.fetch(0), attr, res_mu_is2ns.fetch(1), item_attr, res_mu_is2ns.fetch(2), kind_attr);
       iter := res_mu_is2ns.fetch(0).leftfetchjoin(iter005);
       item := res_mu_is2ns.fetch(1);
       kind := res_mu_is2ns.fetch(2);
       ipik := item;
      } # end of item-sequence-to-node-sequence
     } # end of deleteResult5 ()
     { # map2NODE_interface (counter)
      kind := kind.materialize(ipik);
      var attr := kind.get_type(ATTR).hmark(0@0);
      var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
      var attr_item := attr.leftfetchjoin(item);
      var attr_frag := attr.leftfetchjoin(kind).get_fragment();
      _r_attr_iter := attr_iter;
      _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
      _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
      _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
      var nodes := kind.get_type(ELEM);
      if (nodes.count() != 0) {
       var oid_oid := nodes.hmark(0@0);
       var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
       var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
       var iter_input := oid_oid.mirror();
       var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
       var res_iter := res_scj.fetch(0);
       var res_item := res_scj.fetch(1);
       var res_frag := res_scj.fetch(2);
       _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
       _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
       _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
       _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
       _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
       var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
       var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
       nodes := res_item.mark(0@0);
       var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
       root_level := nodes.leftfetchjoin(root_level);
       temp_ec_item := res_item;
       temp_ec_frag := res_frag;
       var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
       content_level := nodes.leftfetchjoin(content_level);
       content_level := content_level.[-](root_level);
       content_level := content_level.tmark(0@0);
       _elem_level := content_level;
       { # create attribute subtree copies
        var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
        var oid_attr := temp_attr.tmark(0@0);
        var oid_frag;
        if (is_constant(res_frag)) {
         oid_frag := res_frag;
        } else {
         oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
         oid_frag := oid_frag.tmark(0@0);
        }
        _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
        _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
        _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
        _attr_own  := temp_attr.hmark(0@0);
        _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
       } # end of create attribute subtree copies
      } else { # if (nodes.count() != 0) ...
       _elem_iter  := empty_bat;
       _elem_size  := empty_bat.project(int(nil));
       _elem_level := empty_bat.project(chr(nil));
       _elem_kind  := empty_bat.project(chr(nil));
       _elem_prop  := empty_bat;
       _elem_frag  := empty_bat;
       _attr_iter  := empty_bat;
       _attr_qn    := empty_bat;
       _attr_prop  := empty_bat;
       _attr_frag  := empty_bat;
       _attr_own   := empty_bat;
      } # end of else in 'if (nodes.count() != 0)'
     } # end of map2NODE_interface (counter)
     { # loop_liftedElemConstr (counter)
      var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
      iter_size := {count}(iter_size, iter004.tunique(), FALSE);
      var root_iter  := iter_size.hmark(0@0).chk_order();
      var root_size  := iter_size.tmark(0@0);
      var root_prop  := iter004.reverse().leftfetchjoin(item004);
      if (not(is_constant(root_prop))) {
       root_prop  := root_prop.tmark(0@0);
      }
      {
       var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
       _elem_iter  := merged_result.fetch(0);
       _elem_size  := merged_result.fetch(1);
       _elem_level := merged_result.fetch(2);
       _elem_kind  := merged_result.fetch(3);
       _elem_prop  := merged_result.fetch(4);
       _elem_frag  := merged_result.fetch(5);
       var preNew_preOld := merged_result.fetch(6);
       _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
       _attr_own := _attr_own.tmark(0@0);
      }
      { # create attribute root entries
       var root_item := _elem_level.ord_uselect(chr(0));
       root_item := root_item.hmark(0@0);
       var iter_item := iter004.reverse().leftfetchjoin(root_item);
       var attr_own := _r_attr_iter.leftjoin(iter_item);
       if (_r_attr_iter.count() != 0) { # test uniqueness
        var sorting := _r_attr_iter.tsort();
        sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
        var unq_attrs := sorting.tunique();
        if (unq_attrs.count() != _r_attr_iter.count()) {
         item004 := materialize(item004,ipik004);
         if (item004.count() > 0) {
          ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item004.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
         } else {
          ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
         }
        }
       } # end of test uniqueness
       if (_attr_iter.count() = 0) {
        _attr_iter := _r_attr_iter;
        _attr_qn   := _r_attr_qn;
        _attr_prop := _r_attr_prop;
        _attr_frag := _r_attr_frag;
        _attr_own  := attr_own.tmark(0@0);
       } else {
        var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
        _r_attr_iter := _r_attr_iter.tmark(seqb);
        _r_attr_qn   := _r_attr_qn  .tmark(seqb);
        _r_attr_prop := _r_attr_prop.tmark(seqb);
        _r_attr_frag := _r_attr_frag.tmark(seqb);
        attr_own := attr_own.tmark(seqb);
        _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
        _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
        _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
        _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
        _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
       }
       _r_attr_iter := empty_bat;
       _r_attr_qn   := empty_bat;
       _r_attr_prop := empty_bat;
       _r_attr_frag := empty_bat;
      } # end of create attribute root entries
     } # end of loop_liftedElemConstr (counter)
    } # end of deleteResult4 ()
    { # saveResult_node4 () : int
     var _elem_iter004   := _elem_iter  ;
     var _elem_size004   := _elem_size  ;
     var _elem_level004  := _elem_level ;
     var _elem_kind004   := _elem_kind  ;
     var _elem_prop004   := _elem_prop  ;
     var _elem_frag004   := _elem_frag  ;
     var _attr_iter004   := _attr_iter  ;
     var _attr_qn004     := _attr_qn    ;
     var _attr_prop004   := _attr_prop  ;
     var _attr_frag004   := _attr_frag  ;
     var _attr_own004    := _attr_own   ;
     var _r_attr_iter004 := _r_attr_iter;
     var _r_attr_qn004   := _r_attr_qn  ;
     var _r_attr_prop004 := _r_attr_prop;
     var _r_attr_frag004 := _r_attr_frag; # end of saveResult_node4 () : int
     { # tagname-translation
      var propID := ws.fetch(QN_PREFIX_URI).fetch(WS).ord_uselect(""+str('\1')+"").mirror();
      var prop_str := propID.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS));
      var itemID;
      if (prop_str.texist("na")) {
       itemID := prop_str.reverse().find("na");
      } else {
       itemID := oid(ws.fetch(QN_LOC).fetch(WS).count());
       ws.fetch(QN_URI).fetch(WS).insert(itemID,"");
       ws.fetch(QN_PREFIX).fetch(WS).insert(itemID,"");
       ws.fetch(QN_LOC).fetch(WS).insert(itemID,"na");
       ws.fetch(QN_PREFIX_URI).fetch(WS).insert(itemID,""+str('\1')+"");
       ws.fetch(QN_LOC_URI).fetch(WS).insert(itemID,"na"+str('\1')+"");
      } # translateConst (kind)
      iter := loop000.tmark(0@0);
      ipik := iter;
      pos := 1@0;
      item := itemID;
      kind := QNAME;
     } # end of tagname-translation
     { # saveResult5 () : int
      var ipik005 := ipik;
      var iter005 := iter;
      var item005 := item; # end of saveResult5 () : int
      { # translateVar (auction)
       var vid := v_vid000.ord_uselect(1303761114@0);
       vid := vid.hmark(0@0);
       iter := vid.leftfetchjoin(v_iter000);
       item := vid.leftfetchjoin(v_item000);
       kind := vid.leftfetchjoin(v_kind000);
       ipik := iter;
      } # end of translateVar (auction)
      { # translateLocsteps (c)
       var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
       item := item.materialize(ipik);
       iter := iter.materialize(ipik);
       res_scj := loop_lifted_descendant_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "person");
       iter := res_scj.fetch(0);
       item := res_scj.fetch(1);
       kind := res_scj.fetch(2).set_kind(ELEM);
       ipik := item;
      } # end of translateLocsteps (c)
      if (ipik.count() != 0) 
      { # for-translation
       # project ()
       iter := iter.materialize(ipik);
       var outer001 := iter;
       var order_001 := iter;
       iter := iter.mark(1@0);
       var inner001 := iter;
       pos := 1@0;
       var loop001 := inner001;
       var v_vid001;
       var v_iter001;
       var v_pos001;
       var v_item001;
       var v_kind001;
       var expOid;
       { # getExpanded (fid)
        var vu_nil := vu_fid.ord_uselect(1303761087@0);
        var vid_vu := vu_vid.reverse();
        var oid_nil := vid_vu.leftjoin(vu_nil);
        expOid := v_vid000.leftjoin(oid_nil);
        expOid := expOid.mirror();
       } # end of getExpanded (fid)
       if (expOid.count() != 0) {
        var oidNew_expOid;
        { # expand ()
         var expOid_iter := expOid.leftfetchjoin(v_iter000);
         var iter_expOid := expOid_iter.reverse();
         var oidMap_expOid := outer001.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer001.leftjoin(iter_expOid)' a stable join
         var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
         oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
         var expOid_oidMap := oidMap_expOid.reverse();
         expOid_iter := expOid_oidMap.leftfetchjoin(inner001);
         v_iter001 := expOid_iter;
         oidNew_expOid := expOid_iter.hmark(0@0);
        } # end of expand ()
        # join ()
        var cnt := count(v_iter001)*2;
        v_iter001 := v_iter001.tmark(0@0);
        var new_v_iter := v_iter001;
        v_iter001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
        var new_v_vid := oidNew_expOid.leftjoin(v_vid000);
        v_vid001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
        var new_v_pos := oidNew_expOid.leftjoin(v_pos000);
        v_pos001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
        var new_v_item := oidNew_expOid.leftjoin(v_item000);
        v_item001 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
        var new_v_kind := oidNew_expOid.leftjoin(v_kind000);
        v_kind001 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
       } else { # createNewVarTable ()
        v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
        v_kind001 := bat(void,int).seqbase(0@0).access(BAT_APPEND);
       }
       { # insertVar (vid)
        var vid := project(ipik,1303761131@0);
        { # append (vid, level)
         var seqb := oid(v_vid001.count());
         vid := vid.materialize(ipik);
         v_vid001 := v_vid001.insert(vid.tmark(seqb));
        } # append (vid, level)
        { # append (iter, level)
         var seqb := oid(v_iter001.count());
         iter := iter.materialize(ipik);
         v_iter001 := v_iter001.insert(iter.tmark(seqb));
        } # append (iter, level)
        { # append (pos, level)
         var seqb := oid(v_pos001.count());
         pos := pos.materialize(ipik);
         v_pos001 := v_pos001.insert(pos.tmark(seqb));
        } # append (pos, level)
        { # append (item, level)
         var seqb := oid(v_item001.count());
         item := item.materialize(ipik);
         v_item001 := v_item001.insert(item.tmark(seqb));
        } # append (item, level)
        { # append (kind, level)
         var seqb := oid(v_kind001.count());
         kind := kind.materialize(ipik);
         v_kind001 := v_kind001.insert(kind.tmark(seqb));
        } # append (kind, level)
       } # end of insertVar (vid)
       { # translateVar (p)
        var vid := v_vid001.ord_uselect(1303761131@0);
        vid := vid.hmark(0@0);
        iter := vid.leftfetchjoin(v_iter001);
        item := vid.leftfetchjoin(v_item001);
        kind := vid.leftfetchjoin(v_kind001);
        ipik := iter;
       } # end of translateVar (p)
       { # translateLocsteps (c)
        var res_scj; # loop_liftedSCJ (axis, kind, ns, loc)
        item := item.materialize(ipik);
        iter := iter.materialize(ipik);
        res_scj := loop_lifted_child_step_with_nsloc_test(iter, item, constant2bat(kind.get_fragment()), ws, 0, "", "profile");
        iter := res_scj.fetch(0);
        item := res_scj.fetch(1);
        kind := res_scj.fetch(2).set_kind(ELEM);
        ipik := item;
       } # end of translateLocsteps (c)
       { # loop_liftedSCJ (axis, kind, ns, loc)
        { # attribute axis
         var oid_iter := iter;
         var oid_item := item.materialize(ipik);
         var oid_frag := kind.get_fragment();
         var temp1 := mvaljoin (oid_item, oid_frag, ws.fetch(ATTR_OWN));
         oid_frag := temp1.hmark(0@0).leftfetchjoin(oid_frag);
         var oid_attr := temp1.tmark(0@0);
         oid_iter := temp1.hmark(0@0).leftfetchjoin(oid_iter);
         var temp1_str; # only needed for name test
         temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_URI));
         temp1 := temp1_str.ord_uselect("");
         temp1 := temp1.hmark(0@0);
         oid_attr := temp1.leftfetchjoin(oid_attr);
         oid_frag := temp1.leftfetchjoin(oid_frag);
         oid_iter := temp1.leftfetchjoin(oid_iter);
         temp1_str := mposjoin(mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN)), mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)), ws.fetch(QN_LOC));
         temp1 := temp1_str.ord_uselect("income");
         temp1 := temp1.hmark(0@0);
         oid_attr := temp1.leftfetchjoin(oid_attr);
         oid_frag := temp1.leftfetchjoin(oid_frag);
         oid_iter := temp1.leftfetchjoin(oid_iter);
         iter := oid_iter.tmark(0@0);
         item := oid_attr.tmark(0@0);
         kind := oid_frag.tmark(0@0);
         if (type(iter) = bat) {
         } else {
         }
        } # end of attribute axis
       } # end of translateLocsteps (c)
       { # translate fn:empty (item*) as boolean
        var iter_count := {count}(iter.reverse(),loop001.reverse(), FALSE);
        var iter_bool := iter_count.[=](0).[oid]();
        item := iter_bool.tmark(0@0);
        iter := loop001.tmark(0@0);
        ipik := iter;
        pos := 1@0;
        kind := BOOL;
       } # end of translate fn:empty (item*) as boolean
       { # saveResult6 () : int
        var iter006 := iter;
        var item006 := item; # end of saveResult6 () : int
        { # ifthenelse-translation
         var selected;
         var skip;
         if (type(item006) = bat) {
          selected := item006.ord_uselect(1@0);
          var cnt := selected.count();
          if (item006.count() = cnt) {
           skip := 2;
          } else {
           skip := int(cnt = 0);
          }
         } else {
          skip := 1 + int(item006); # handle constants efficiently
         }
         { # translateIfThen
          var inner002 := inner001;
          var outer002 := outer001;
          var v_vid002 := v_vid001;
          var v_iter002 := v_iter001;
          var v_pos002 := v_pos001;
          var v_item002 := v_item001;
          var v_kind002 := v_kind001;
          if (skip = 0) {
           iter := selected.mirror().join(iter006);
           iter := iter.tmark(0@0);
           outer002 := iter;
           iter := iter.mark(1@0);
           inner002 := iter;
           var expOid := v_iter002.mirror();
           var oidNew_expOid;
           { # expand ()
            var expOid_iter := expOid.leftfetchjoin(v_iter001);
            var iter_expOid := expOid_iter.reverse();
            var oidMap_expOid := outer002.leftjoin(iter_expOid); # FIXME: refine needed to make 'outer002.leftjoin(iter_expOid)' a stable join
            var temp_sort := oidMap_expOid.hmark(0@0).CTrefine(oidMap_expOid.tmark(0@0)).mirror();
            oidMap_expOid := temp_sort.leftfetchjoin(oidMap_expOid.hmark(0@0)).reverse().leftfetchjoin(oidMap_expOid.tmark(0@0)) ;
            var expOid_oidMap := oidMap_expOid.reverse();
            expOid_iter := expOid_oidMap.leftfetchjoin(inner002);
            v_iter002 := expOid_iter;
            oidNew_expOid := expOid_iter.hmark(0@0);
           } # end of expand ()
           # join ()
           var cnt := count(v_iter002)*2;
           v_iter002 := v_iter002.tmark(0@0);
           var new_v_iter := v_iter002;
           v_iter002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_iter);
           var new_v_vid := oidNew_expOid.leftjoin(v_vid001);
           v_vid002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_vid);
           var new_v_pos := oidNew_expOid.leftjoin(v_pos001);
           v_pos002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_pos);
           var new_v_item := oidNew_expOid.leftjoin(v_item001);
           v_item002 := bat(void,oid,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_item);
           var new_v_kind := oidNew_expOid.leftjoin(v_kind001);
           v_kind002 := bat(void,int,cnt).seqbase(0@0).access(BAT_APPEND).insert(new_v_kind); # end of join ()
          }
          if (skip != 1) {
           { # translateVar (p)
            var vid := v_vid002.ord_uselect(1303761131@0);
            vid := vid.hmark(0@0);
            iter := vid.leftfetchjoin(v_iter002);
            ipik := iter;
           } # end of translateVar (p)
          } else { # translateEmpty ()
           ipik := empty_bat;
           iter := empty_bat;
          }
          if (skip = 0) {
           { # mapBack ()
            var iter_oidMap := inner002.reverse();
            var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
            iter := oid_oidMap.leftfetchjoin(outer002); # item := item;
            # kind := kind;
            # ipik := ipik;
           } # end of mapBack ()
          } # cleanUpLevel ()
         } # end of translateIfThen
        } # end of ifthenelse-translation
       } # end of deleteResult6 ()
       { # mapBack ()
        var iter_oidMap := inner001.reverse();
        var oid_oidMap := iter.leftfetchjoin(iter_oidMap);
        iter := oid_oidMap.leftfetchjoin(outer001); # item := item;
        # kind := kind;
        # ipik := ipik;
       } # end of mapBack ()
       # cleanUpLevel ()
      } # end of for-translation
      { # translate fn:count (item*) as integer
       iter := iter.materialize(ipik);
       var iter_count := [lng]({count}(iter.reverse(),loop000.reverse(), FALSE)).tmark(0@0);
       item := int_values.addValues(iter_count).tmark(0@0);
       iter := loop000.tmark(0@0);
       ipik := iter;
       pos := 1@0;
       kind := INT;
      } # end of translate fn:count (item*) as integer
      { # saveResult6 () : int
       var ipik006 := ipik;
       var iter006 := iter;
       var pos006 := pos;
       var item006 := item;
       var kind006 := kind; # end of saveResult6 () : int
       { # item-sequence-to-node-sequence
        var nodes_order;
        {
         ipik := ipik006;
         pos := pos006;
         item := item006;
         kind := kind006;
         kind := kind.materialize(ipik);
         var elem := kind.get_type(ELEM);
         elem := elem.hmark(0@0);
         var kind_elem := elem.leftfetchjoin(kind);
         var frag_elem := kind_elem.get_fragment();
         var item_elem := elem.leftfetchjoin(item).materialize(elem);
         var kind_node := mposjoin (item_elem, frag_elem, ws.fetch(PRE_KIND));
         var text := kind_node.ord_uselect(TEXT).hmark(0@0);
         var item_text := text.leftfetchjoin(item_elem);
         var frag_text := text.leftfetchjoin(frag_elem);
         var text_str := mposjoin (mposjoin (item_text, frag_text, ws.fetch(PRE_PROP)), mposjoin (item_text, frag_text, ws.fetch(PRE_FRAG)), ws.fetch(PROP_TEXT));
         var str_text := text_str.reverse().leftfetchjoin(text);
         var texts := str_text.leftfetchjoin(elem).reverse();
         var texts_order := texts.hmark(0@0);
         texts := texts.tmark(0@0);
         var nodes := kind_node.[!=](TEXT).ord_uselect(true).project("");
         nodes := nodes.reverse().leftfetchjoin(elem).reverse();
         nodes_order := nodes.hmark(0@0);
         nodes := nodes.tmark(0@0);
         var res_mu_is2ns := merged_union (nodes_order, texts_order, nodes, texts, 0@0, 1@0);
         var input_order := res_mu_is2ns.fetch(0);
         var input_str := res_mu_is2ns.fetch(1);
         var input_const := res_mu_is2ns.fetch(2);
         kind := kind.materialize(ipik);
         var atomic := kind.get_type_atomic();
         atomic := atomic.hmark(0@0);
         iter := atomic.mirror();
         item := atomic.leftfetchjoin(item);
         var cast_val := item.leftfetchjoin(int_values).[str]();
         if (cast_val.texist(str(nil))) {
          ERROR ("err:FORG0001: could not cast value from integer to string.");
         }
         item_str_ := cast_val;
         res_mu_is2ns := merged_union (input_order, atomic, input_str, item_str_, input_const, 2@0);
         input_order := res_mu_is2ns.fetch(0);
         input_str := res_mu_is2ns.fetch(1);
         input_const := res_mu_is2ns.fetch(2);
         var input_iter := input_order.leftfetchjoin(iter006).chk_order();
         var result_size := iter006.tunique().count() + nodes_order.count() + 1;
         var result_str := combine_text_string (input_iter.materialize(input_str), input_const.materialize(input_str), input_str, result_size);
         var result_order := result_str.hmark(0@0);
         result_order := result_order.leftfetchjoin(input_order);
         result_str := result_str.tmark(0@0);
         iter := result_order;
         ipik := iter;
         item_str_ := result_str;
        }
        { # adding new strings to text node content and create new nodes
         var ws_prop_text := ws.fetch(PROP_TEXT).fetch(WS);
         var unq_str := item_str_.tunique().hmark(0@0);
         var str_unq := reverse(unq_str.tdiff(ws_prop_text));
         var seqb := oid(int(ws_prop_text.seqbase()) + ws_prop_text.count());
         unq_str := str_unq.hmark(seqb);
         ws_prop_text := ws_prop_text.insert(unq_str);
         var ws_text_prop := ws_prop_text.reverse().sort();
         item_str_ := item_str_.materialize(ipik);
         var X_item := item_str_.hmark(0@0);
         var X_strings := item_str_.tmark(0@0).tsort();
         var X_prop := X_strings.leftjoin(ws_text_prop);
         var newPre_prop := X_item.reverse().leftjoin(X_prop);
         seqb := oid(count(ws.fetch(PRE_KIND).fetch(WS))+ int(ws.fetch(PRE_KIND).fetch(WS).seqbase()));
         newPre_prop := newPre_prop.tmark(seqb);
         ws.fetch(PRE_PROP).fetch(WS).insert(newPre_prop);
         ws.fetch(PRE_SIZE).fetch(WS).insert(newPre_prop.project(0));
         ws.fetch(PRE_LEVEL).fetch(WS).insert(newPre_prop.project(chr(0)));
         ws.fetch(PRE_KIND).fetch(WS).insert(newPre_prop.project(TEXT));
         ws.fetch(PRE_FRAG).fetch(WS).insert(newPre_prop.project(WS));
         {
          var kind_pre_ := newPre_prop.hmark(nil).chk_order();
          ws.fetch(KIND_PRE + int(TEXT)).fetch(WS).insert(kind_pre_);
         }
         item := item_str_.mark(seqb);
         kind := ELEM;
        } # end of adding new strings to text node content and create new nodes
        { # adding new fragments to the WS_FRAG bat
         var seqb := ws.fetch(WS_FRAG).count();
         seqb := oid(seqb);
         var new_pres := item.tmark(seqb);
         ws.fetch(WS_FRAG).insert(new_pres);
         ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), 1));
        } # end of adding new fragments to the WS_FRAG bat
        var res_mu_is2ns := merged_union (iter, nodes_order, item, nodes_order.leftfetchjoin(item006), kind, nodes_order.leftfetchjoin(kind006));
        kind006 := kind006.materialize(ipik006);
        var attr := kind006.get_type(ATTR).hmark(0@0);
        var item_attr := attr.leftfetchjoin(item006);
        var kind_attr := attr.leftfetchjoin(kind006);
        res_mu_is2ns := merged_union (res_mu_is2ns.fetch(0), attr, res_mu_is2ns.fetch(1), item_attr, res_mu_is2ns.fetch(2), kind_attr);
        iter := res_mu_is2ns.fetch(0).leftfetchjoin(iter006);
        item := res_mu_is2ns.fetch(1);
        kind := res_mu_is2ns.fetch(2);
        ipik := item;
       } # end of item-sequence-to-node-sequence
      } # end of deleteResult6 ()
      { # map2NODE_interface (counter)
       kind := kind.materialize(ipik);
       var attr := kind.get_type(ATTR).hmark(0@0);
       var attr_iter := attr.leftfetchjoin(iter).materialize(attr);
       var attr_item := attr.leftfetchjoin(item);
       var attr_frag := attr.leftfetchjoin(kind).get_fragment();
       _r_attr_iter := attr_iter;
       _r_attr_qn   := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_QN));
       _r_attr_prop := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_PROP));
       _r_attr_frag := mposjoin(attr_item, attr_frag, ws.fetch(ATTR_FRAG));
       var nodes := kind.get_type(ELEM);
       if (nodes.count() != 0) {
        var oid_oid := nodes.hmark(0@0);
        var node_items := oid_oid.leftfetchjoin(item).materialize(oid_oid);
        var node_frags := oid_oid.leftfetchjoin(kind).get_fragment();
        var iter_input := oid_oid.mirror();
        var res_scj := loop_lifted_descendant_or_self_step(iter_input, node_items, constant2bat(node_frags), ws, 0);
        var res_iter := res_scj.fetch(0);
        var res_item := res_scj.fetch(1);
        var res_frag := res_scj.fetch(2);
        _elem_iter  := res_iter.leftfetchjoin(oid_oid).leftfetchjoin(iter).materialize(res_item).chk_order();
        _elem_size  := mposjoin(res_item, res_frag, ws.fetch(PRE_SIZE));
        _elem_kind  := mposjoin(res_item, res_frag, ws.fetch(PRE_KIND));
        _elem_prop  := mposjoin(res_item, res_frag, ws.fetch(PRE_PROP));
        _elem_frag  := mposjoin(res_item, res_frag, ws.fetch(PRE_FRAG));
        var temp_ec_item := res_iter.leftfetchjoin(node_items).materialize(res_item);
        var temp_ec_frag := res_iter.leftfetchjoin(node_frags);
        nodes := res_item.mark(0@0);
        var root_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
        root_level := nodes.leftfetchjoin(root_level);
        temp_ec_item := res_item;
        temp_ec_frag := res_frag;
        var content_level := mposjoin(temp_ec_item, temp_ec_frag, ws.fetch(PRE_LEVEL));
        content_level := nodes.leftfetchjoin(content_level);
        content_level := content_level.[-](root_level);
        content_level := content_level.tmark(0@0);
        _elem_level := content_level;
        { # create attribute subtree copies
         var temp_attr := mvaljoin(res_item, res_frag, ws.fetch(ATTR_OWN));
         var oid_attr := temp_attr.tmark(0@0);
         var oid_frag;
         if (is_constant(res_frag)) {
          oid_frag := res_frag;
         } else {
          oid_frag := temp_attr.reverse().leftfetchjoin(res_frag);
          oid_frag := oid_frag.tmark(0@0);
         }
         _attr_qn   := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_QN));
         _attr_prop := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_PROP));
         _attr_frag := mposjoin(oid_attr, oid_frag, ws.fetch(ATTR_FRAG)).materialize(_attr_prop);
         _attr_own  := temp_attr.hmark(0@0);
         _attr_iter := _attr_own.leftfetchjoin(_elem_iter);
        } # end of create attribute subtree copies
       } else { # if (nodes.count() != 0) ...
        _elem_iter  := empty_bat;
        _elem_size  := empty_bat.project(int(nil));
        _elem_level := empty_bat.project(chr(nil));
        _elem_kind  := empty_bat.project(chr(nil));
        _elem_prop  := empty_bat;
        _elem_frag  := empty_bat;
        _attr_iter  := empty_bat;
        _attr_qn    := empty_bat;
        _attr_prop  := empty_bat;
        _attr_frag  := empty_bat;
        _attr_own   := empty_bat;
       } # end of else in 'if (nodes.count() != 0)'
      } # end of map2NODE_interface (counter)
      { # loop_liftedElemConstr (counter)
       var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
       iter_size := {count}(iter_size, iter005.tunique(), FALSE);
       var root_iter  := iter_size.hmark(0@0).chk_order();
       var root_size  := iter_size.tmark(0@0);
       var root_prop  := iter005.reverse().leftfetchjoin(item005);
       if (not(is_constant(root_prop))) {
        root_prop  := root_prop.tmark(0@0);
       }
       {
        var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
        _elem_iter  := merged_result.fetch(0);
        _elem_size  := merged_result.fetch(1);
        _elem_level := merged_result.fetch(2);
        _elem_kind  := merged_result.fetch(3);
        _elem_prop  := merged_result.fetch(4);
        _elem_frag  := merged_result.fetch(5);
        var preNew_preOld := merged_result.fetch(6);
        _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
        _attr_own := _attr_own.tmark(0@0);
       }
       { # create attribute root entries
        var root_item := _elem_level.ord_uselect(chr(0));
        root_item := root_item.hmark(0@0);
        var iter_item := iter005.reverse().leftfetchjoin(root_item);
        var attr_own := _r_attr_iter.leftjoin(iter_item);
        if (_r_attr_iter.count() != 0) { # test uniqueness
         var sorting := _r_attr_iter.tsort();
         sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
         var unq_attrs := sorting.tunique();
         if (unq_attrs.count() != _r_attr_iter.count()) {
          item005 := materialize(item005,ipik005);
          if (item005.count() > 0) {
           ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item005.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
          } else {
           ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
          }
         }
        } # end of test uniqueness
        if (_attr_iter.count() = 0) {
         _attr_iter := _r_attr_iter;
         _attr_qn   := _r_attr_qn;
         _attr_prop := _r_attr_prop;
         _attr_frag := _r_attr_frag;
         _attr_own  := attr_own.tmark(0@0);
        } else {
         var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
         _r_attr_iter := _r_attr_iter.tmark(seqb);
         _r_attr_qn   := _r_attr_qn  .tmark(seqb);
         _r_attr_prop := _r_attr_prop.tmark(seqb);
         _r_attr_frag := _r_attr_frag.tmark(seqb);
         attr_own := attr_own.tmark(seqb);
         _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
         _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
         _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
         _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
         _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
        }
        _r_attr_iter := empty_bat;
        _r_attr_qn   := empty_bat;
        _r_attr_prop := empty_bat;
        _r_attr_frag := empty_bat;
       } # end of create attribute root entries
      } # end of loop_liftedElemConstr (counter)
     } # end of deleteResult5 ()
     # translateSeq_node (f, counter)
     if (_r_attr_iter.count() = 0) {
      _r_attr_iter := _r_attr_iter004;
      _r_attr_qn := _r_attr_qn004;
      _r_attr_prop := _r_attr_prop004;
      _r_attr_frag := _r_attr_frag004;
     } else {
      if (_r_attr_iter004.count() != 0) 
      { # combine attribute roots
       var merged_result := merged_union (_r_attr_iter004.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn004, _r_attr_qn, _r_attr_prop004, _r_attr_prop, _r_attr_frag004, _r_attr_frag);
       _r_attr_iter := merged_result.fetch(0);
       _r_attr_qn := merged_result.fetch(1);
       _r_attr_prop := merged_result.fetch(2);
       _r_attr_frag := merged_result.fetch(3);
      }
     } # end of combine attribute roots
     if (_elem_iter.count() = 0) {
      _elem_iter  := _elem_iter004  ;
      _elem_size  := _elem_size004  ;
      _elem_level := _elem_level004 ;
      _elem_kind  := _elem_kind004  ;
      _elem_prop  := _elem_prop004  ;
      _elem_frag  := _elem_frag004  ;
      _attr_iter  := _attr_iter004  ;
      _attr_qn    := _attr_qn004    ;
      _attr_prop  := _attr_prop004  ;
      _attr_frag  := _attr_frag004  ;
      _attr_own   := _attr_own004   ;
     } else {
      if (_elem_iter004.count() != 0) 
      { # combine element nodes
       var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
       var shift_factor := int(seqb) - int(_elem_size004.seqbase());
       var merged_result := merged_union (_elem_iter004.chk_order(), _elem_iter.chk_order(), _elem_size004, _elem_size, _elem_level004, _elem_level, _elem_kind004, _elem_kind, _elem_prop004, _elem_prop, _elem_frag004, _elem_frag, _elem_size004.mark(seqb), _elem_size.mirror());
       _elem_iter := merged_result.fetch(0);
       _elem_size := merged_result.fetch(1);
       _elem_level:= merged_result.fetch(2);
       _elem_kind := merged_result.fetch(3);
       _elem_prop := merged_result.fetch(4);
       _elem_frag := merged_result.fetch(5);
       var preNew_preOld := merged_result.fetch(6);
       _attr_own004 := _attr_own004.[int]().[+](shift_factor).[oid]();
       merged_result := merged_union (_attr_iter004, _attr_iter, _attr_qn004, _attr_qn, _attr_prop004, _attr_prop, _attr_frag004, _attr_frag, _attr_own004, _attr_own);
       _attr_iter := merged_result.fetch(0);
       _attr_qn   := merged_result.fetch(1);
       _attr_prop := merged_result.fetch(2);
       _attr_frag := merged_result.fetch(3);
       _attr_own  := merged_result.fetch(4);
       _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
       _attr_own := _attr_own.tmark(0@0);
      }
     } # combine element nodes
     # end of translateSeq_node (f, counter)
    } # end of deleteResult_node4 ()
    # translateSeq_node (f, counter)
    if (_r_attr_iter.count() = 0) {
     _r_attr_iter := _r_attr_iter003;
     _r_attr_qn := _r_attr_qn003;
     _r_attr_prop := _r_attr_prop003;
     _r_attr_frag := _r_attr_frag003;
    } else {
     if (_r_attr_iter003.count() != 0) 
     { # combine attribute roots
      var merged_result := merged_union (_r_attr_iter003.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn003, _r_attr_qn, _r_attr_prop003, _r_attr_prop, _r_attr_frag003, _r_attr_frag);
      _r_attr_iter := merged_result.fetch(0);
      _r_attr_qn := merged_result.fetch(1);
      _r_attr_prop := merged_result.fetch(2);
      _r_attr_frag := merged_result.fetch(3);
     }
    } # end of combine attribute roots
    if (_elem_iter.count() = 0) {
     _elem_iter  := _elem_iter003  ;
     _elem_size  := _elem_size003  ;
     _elem_level := _elem_level003 ;
     _elem_kind  := _elem_kind003  ;
     _elem_prop  := _elem_prop003  ;
     _elem_frag  := _elem_frag003  ;
     _attr_iter  := _attr_iter003  ;
     _attr_qn    := _attr_qn003    ;
     _attr_prop  := _attr_prop003  ;
     _attr_frag  := _attr_frag003  ;
     _attr_own   := _attr_own003   ;
    } else {
     if (_elem_iter003.count() != 0) 
     { # combine element nodes
      var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
      var shift_factor := int(seqb) - int(_elem_size003.seqbase());
      var merged_result := merged_union (_elem_iter003.chk_order(), _elem_iter.chk_order(), _elem_size003, _elem_size, _elem_level003, _elem_level, _elem_kind003, _elem_kind, _elem_prop003, _elem_prop, _elem_frag003, _elem_frag, _elem_size003.mark(seqb), _elem_size.mirror());
      _elem_iter := merged_result.fetch(0);
      _elem_size := merged_result.fetch(1);
      _elem_level:= merged_result.fetch(2);
      _elem_kind := merged_result.fetch(3);
      _elem_prop := merged_result.fetch(4);
      _elem_frag := merged_result.fetch(5);
      var preNew_preOld := merged_result.fetch(6);
      _attr_own003 := _attr_own003.[int]().[+](shift_factor).[oid]();
      merged_result := merged_union (_attr_iter003, _attr_iter, _attr_qn003, _attr_qn, _attr_prop003, _attr_prop, _attr_frag003, _attr_frag, _attr_own003, _attr_own);
      _attr_iter := merged_result.fetch(0);
      _attr_qn   := merged_result.fetch(1);
      _attr_prop := merged_result.fetch(2);
      _attr_frag := merged_result.fetch(3);
      _attr_own  := merged_result.fetch(4);
      _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
      _attr_own := _attr_own.tmark(0@0);
     }
    } # combine element nodes
    # end of translateSeq_node (f, counter)
   } # end of deleteResult_node3 ()
   # translateSeq_node (f, counter)
   if (_r_attr_iter.count() = 0) {
    _r_attr_iter := _r_attr_iter002;
    _r_attr_qn := _r_attr_qn002;
    _r_attr_prop := _r_attr_prop002;
    _r_attr_frag := _r_attr_frag002;
   } else {
    if (_r_attr_iter002.count() != 0) 
    { # combine attribute roots
     var merged_result := merged_union (_r_attr_iter002.chk_order(), _r_attr_iter.chk_order(), _r_attr_qn002, _r_attr_qn, _r_attr_prop002, _r_attr_prop, _r_attr_frag002, _r_attr_frag);
     _r_attr_iter := merged_result.fetch(0);
     _r_attr_qn := merged_result.fetch(1);
     _r_attr_prop := merged_result.fetch(2);
     _r_attr_frag := merged_result.fetch(3);
    }
   } # end of combine attribute roots
   if (_elem_iter.count() = 0) {
    _elem_iter  := _elem_iter002  ;
    _elem_size  := _elem_size002  ;
    _elem_level := _elem_level002 ;
    _elem_kind  := _elem_kind002  ;
    _elem_prop  := _elem_prop002  ;
    _elem_frag  := _elem_frag002  ;
    _attr_iter  := _attr_iter002  ;
    _attr_qn    := _attr_qn002    ;
    _attr_prop  := _attr_prop002  ;
    _attr_frag  := _attr_frag002  ;
    _attr_own   := _attr_own002   ;
   } else {
    if (_elem_iter002.count() != 0) 
    { # combine element nodes
     var seqb := oid(count(_elem_size) + int(_elem_size.seqbase()));
     var shift_factor := int(seqb) - int(_elem_size002.seqbase());
     var merged_result := merged_union (_elem_iter002.chk_order(), _elem_iter.chk_order(), _elem_size002, _elem_size, _elem_level002, _elem_level, _elem_kind002, _elem_kind, _elem_prop002, _elem_prop, _elem_frag002, _elem_frag, _elem_size002.mark(seqb), _elem_size.mirror());
     _elem_iter := merged_result.fetch(0);
     _elem_size := merged_result.fetch(1);
     _elem_level:= merged_result.fetch(2);
     _elem_kind := merged_result.fetch(3);
     _elem_prop := merged_result.fetch(4);
     _elem_frag := merged_result.fetch(5);
     var preNew_preOld := merged_result.fetch(6);
     _attr_own002 := _attr_own002.[int]().[+](shift_factor).[oid]();
     merged_result := merged_union (_attr_iter002, _attr_iter, _attr_qn002, _attr_qn, _attr_prop002, _attr_prop, _attr_frag002, _attr_frag, _attr_own002, _attr_own);
     _attr_iter := merged_result.fetch(0);
     _attr_qn   := merged_result.fetch(1);
     _attr_prop := merged_result.fetch(2);
     _attr_frag := merged_result.fetch(3);
     _attr_own  := merged_result.fetch(4);
     _attr_own := _attr_own.leftjoin(preNew_preOld.reverse()).tmark(seqbase(_attr_own));
     _attr_own := _attr_own.tmark(0@0);
    }
   } # combine element nodes
   # end of translateSeq_node (f, counter)
  } # end of deleteResult_node2 ()
  { # loop_liftedElemConstr (counter)
   var iter_size := _elem_iter.reverse().leftfetchjoin(_elem_size);
   iter_size := {count}(iter_size, iter001.tunique(), FALSE);
   var root_iter  := iter_size.hmark(0@0).chk_order();
   var root_size  := iter_size.tmark(0@0);
   var root_prop  := iter001.reverse().leftfetchjoin(item001);
   if (not(is_constant(root_prop))) {
    root_prop  := root_prop.tmark(0@0);
   }
   {
    var merged_result := merged_union (root_iter,  _elem_iter.chk_order(), root_size,  _elem_size, chr(0), _elem_level.[+](chr(1)), ELEMENT,  _elem_kind, root_prop,  _elem_prop, WS,  _elem_frag, root_iter.mark(nil),  _elem_iter.mirror());
    _elem_iter  := merged_result.fetch(0);
    _elem_size  := merged_result.fetch(1);
    _elem_level := merged_result.fetch(2);
    _elem_kind  := merged_result.fetch(3);
    _elem_prop  := merged_result.fetch(4);
    _elem_frag  := merged_result.fetch(5);
    var preNew_preOld := merged_result.fetch(6);
    _attr_own := _attr_own.leftjoin(preNew_preOld.reverse());
    _attr_own := _attr_own.tmark(0@0);
   }
   { # create attribute root entries
    var root_item := _elem_level.ord_uselect(chr(0));
    root_item := root_item.hmark(0@0);
    var iter_item := iter001.reverse().leftfetchjoin(root_item);
    var attr_own := _r_attr_iter.leftjoin(iter_item);
    if (_r_attr_iter.count() != 0) { # test uniqueness
     var sorting := _r_attr_iter.tsort();
     sorting := sorting.CTrefine(mposjoin(_r_attr_qn,_r_attr_frag,ws.fetch(QN_LOC_URI)));
     var unq_attrs := sorting.tunique();
     if (unq_attrs.count() != _r_attr_iter.count()) {
      item001 := materialize(item001,ipik001);
      if (item001.count() > 0) {
       ERROR ("err:XQDY0025: attribute names are not unique in constructed element '%s'.", item001.leftfetchjoin(ws.fetch(QN_LOC).fetch(WS)).fetch(0));
      } else {
       ERROR ("err:XQDY0025: attribute names are not unique in constructed element.");
      }
     }
    } # end of test uniqueness
    if (_attr_iter.count() = 0) {
     _attr_iter := _r_attr_iter;
     _attr_qn   := _r_attr_qn;
     _attr_prop := _r_attr_prop;
     _attr_frag := _r_attr_frag;
     _attr_own  := attr_own.tmark(0@0);
    } else {
     var seqb := oid(_attr_iter.count() + int(_attr_iter.seqbase()));
     _r_attr_iter := _r_attr_iter.tmark(seqb);
     _r_attr_qn   := _r_attr_qn  .tmark(seqb);
     _r_attr_prop := _r_attr_prop.tmark(seqb);
     _r_attr_frag := _r_attr_frag.tmark(seqb);
     attr_own := attr_own.tmark(seqb);
     _attr_iter := _attr_iter.access(BAT_WRITE).insert(_r_attr_iter);
     _attr_qn   := _attr_qn  .access(BAT_WRITE).insert(_r_attr_qn);
     _attr_prop := _attr_prop.access(BAT_WRITE).insert(_r_attr_prop);
     _attr_frag := _attr_frag.access(BAT_WRITE).insert(_r_attr_frag);
     _attr_own  := _attr_own .access(BAT_WRITE).insert(attr_own);
    }
    _r_attr_iter := empty_bat;
    _r_attr_qn   := empty_bat;
    _r_attr_prop := empty_bat;
    _r_attr_frag := empty_bat;
   } # end of create attribute root entries
   {
    var seqb := oid(count(ws.fetch(PRE_SIZE).fetch(WS))+ int(ws.fetch(PRE_SIZE).fetch(WS).seqbase()));
    var preOld_preNew := _elem_size.mark(seqb);
    _attr_own := _attr_own.leftfetchjoin(preOld_preNew);
    _elem_size  := _elem_size.tmark(seqb);
    _elem_level := _elem_level.tmark(seqb);
    _elem_kind  := _elem_kind.tmark(seqb);
    _elem_prop  := _elem_prop.tmark(seqb);
    _elem_frag  := _elem_frag.tmark(seqb);
   }
   ws.fetch(PRE_SIZE).fetch(WS).insert(_elem_size);
   ws.fetch(PRE_LEVEL).fetch(WS).insert(_elem_level);
   ws.fetch(PRE_KIND).fetch(WS).insert(_elem_kind);
   ws.fetch(PRE_PROP).fetch(WS).insert(_elem_prop);
   ws.fetch(PRE_FRAG).fetch(WS).insert(_elem_frag);
   {
    var knd := ELEMENT;
    while ( knd <= DOCUMENT ) {
     var kind__elem := _elem_kind.ord_uselect(knd).reverse().chk_order();
     ws.fetch(KIND_PRE + int(knd)).fetch(WS).insert(kind__elem);
     if ( knd = ELEMENT ) {
      var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
      ws.fetch(PROP_PRE + int(knd)).fetch(WS).insert(prop__elem);
     }
     if ( knd = PI ) {
      var prop__elem := kind__elem.reverse().mirror().leftfetchjoin(_elem_prop).reverse().chk_order();
      ws.fetch(PROP_PRE + 1).fetch(WS).insert(prop__elem);
     }
     knd :+= chr(1);
    }
   }
   var roots := _elem_level.ord_uselect(chr(0));
   roots := roots.hmark(0@0);
   {
    var height := int(_elem_level.max());
    ws.fetch(HEIGHT).replace(WS, max(ws.fetch(HEIGHT).fetch(WS), height));
   }
   { # adding new fragments to the WS_FRAG bat
    var seqb := oid(count(ws.fetch(WS_FRAG)));
    var new_pres := roots.tmark(seqb);
    ws.fetch(WS_FRAG).insert(new_pres);
   }
   iter := iter001;
   item := roots;
   ipik := item;
   kind := ELEM;
   { # add attribute subtree copies to WS
    var seqb := oid(ws.fetch(ATTR_QN).fetch(WS).count());
    _attr_qn   := _attr_qn  .tmark(seqb);
    _attr_prop := _attr_prop.tmark(seqb);
    _attr_own  := _attr_own .tmark(seqb);
    _attr_frag := _attr_frag.tmark(seqb);
    ws.fetch(ATTR_QN).fetch(WS).insert(_attr_qn);
    ws.fetch(ATTR_PROP).fetch(WS).insert(_attr_prop);
    ws.fetch(ATTR_OWN).fetch(WS).insert(_attr_own);
    ws.fetch(ATTR_FRAG).fetch(WS).insert(_attr_frag);
   } # end of add attribute subtree copies to WS
  } # end of loop_liftedElemConstr (counter)
 } # end of deleteResult1 ()
 return bat(void,bat,4).insert(nil,iter).insert(nil,item).insert(nil,kind).access(BAT_READ);
} # end of PROC fn6A56537F_q20_xs_string1_xs_double1_xs_double1

