stdout of test 'ID.978814` in directory 'tests/BugsViaSourgeforce` itself:


# 19:26:19 >  
# 19:26:19 >  Mtimeout -timeout 60 Mserver "--config=/var/tmp/_PREFIX__GNU_32_d__/etc/monet.conf" --debug=10 --set "monet_mod_path=/var/tmp/_PREFIX__GNU_32_d__/lib/MonetDB" --set "gdk_dbfarm=/var/tmp/_PREFIX__GNU_32_d__/var/MonetDB/dbfarm" --set "sql_logdir=/var/tmp/_PREFIX__GNU_32_d__/var/MonetDB/log" --set mapi_port=40786 --set sql_port=55429 --set monet_prompt= --trace --dbname=mTests_tests_BugsViaSourgeforce ID.978814.prelude < ID.978814.milS
# 19:26:19 >  

# Monet Database Server V4.3.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for i686-pc-linux-gnu/32bit; dynamically linked.
# Visit http://monetdb.cwi.nl for further information.
module(xtables);
#query: for $a in (1,2) return (1,2)
print("query: for $a in (1,2) return (1,2)");
[ "query: for $a in (1,2) return (1,2)" ]
print("uses newest version of module pathfinder - summer branch");
[ "uses newest version of module pathfinder - summer branch" ]
print("uses MonetDB V4.3.17 with module(xtables)");
[ "uses MonetDB V4.3.17 with module(xtables)" ]

var var_usage := bat(oid,oid);
var_usage := var_usage.unique().reverse().sort();
var_usage.access(BAT_READ);
var vu_fid := var_usage.mark(1000@0).reverse();
var vu_vid := var_usage.reverse().mark(1000@0).reverse();
# init ()
var loop000 := bat(void,oid).seqbase(0@0);
loop000.insert(0@0, 1@0);
var v_vid000 := bat(void,oid).access(BAT_APPEND).seqbase(0@0);
var v_iter000 := bat(void,oid).access(BAT_APPEND).seqbase(0@0);
var v_pos000 := bat(void,oid).access(BAT_APPEND).seqbase(0@0);
var v_item000 := bat(void,oid).access(BAT_APPEND).seqbase(0@0);
var v_kind000 := bat(void,chr).access(BAT_APPEND).seqbase(0@0);
var str_values := bat(void,str).seqbase(0@0).access(BAT_WRITE);
str_values.reverse().key(true);
var int_values := bat(void,int).seqbase(0@0).access(BAT_WRITE);
int_values.reverse().key(true);
var dbl_values := bat(void,dbl).seqbase(0@0).access(BAT_WRITE);
dbl_values.reverse().key(true);
var dec_values := bat(void,dbl).seqbase(0@0).access(BAT_WRITE);
dec_values.reverse().key(true);
var iter;
var pos;
var item;
var kind;
{
int_values.append (1);
var itemID := int_values.uselect(1);
itemID := itemID.reverse().fetch(0);
# translateConst (kind)
iter := loop000;
iter := iter.reverse().mark(0@0).reverse();
pos := iter.project(1@0);
item := iter.project(itemID);
kind := iter.project('i');
itemID := nil;
}
{ # saveResult () : int
var iter001 := iter;
var pos001 := pos;
var item001 := item;
var kind001 := kind;
iter := nil;
pos := nil;
item := nil;
kind := nil;
# saveResult () : int
{
int_values.append (2);
var itemID := int_values.uselect(2);
itemID := itemID.reverse().fetch(0);
# translateConst (kind)
iter := loop000;
iter := iter.reverse().mark(0@0).reverse();
pos := iter.project(1@0);
item := iter.project(itemID);
kind := iter.project('i');
itemID := nil;
}
if (iter.count() = 0) {
        iter := iter001;
        pos := pos001;
        item := item001;
        kind := kind001;
} else if (iter001.count() != 0)
{ # translateSeq (counter)
var merged_result := merged_union (iter001, iter, pos001, pos, item001, item, kind001, kind);
merged_result.count().print();
print (merged_result.fetch(0), merged_result.fetch(1), merged_result.fetch(2), merged_result.fetch(3));
merged_result := nil;
var iter2 := iter; var pos2 := pos; var item2 := item; var kind2 := kind;
var iter1 := iter001; var pos1 := pos001; var item1 := item001; var kind1 := kind001;
var ord1 := iter1.project(1@0); var ord2 := iter2.project(2@0); var temp1 := count(iter1); temp1 := oid(temp1);
iter1 := iter1.reverse().mark(0@0).reverse(); iter2 := iter2.reverse().mark(0@0).reverse();iter2 := iter2.seqbase(temp1); iter1.access(BAT_APPEND); iter1.insert(iter2); iter1.access(BAT_READ);
ord1 := ord1.reverse().mark(0@0).reverse(); ord2 := ord2.reverse().mark(0@0).reverse();ord2 := ord2.seqbase(temp1); ord1.access(BAT_APPEND); ord1.insert(ord2); ord1.access(BAT_READ);
pos1 := pos1.reverse().mark(0@0).reverse(); pos2 := pos2.reverse().mark(0@0).reverse();pos2 := pos2.seqbase(temp1); pos1.access(BAT_APPEND); pos1.insert(pos2); pos1.access(BAT_READ);
item1 := item1.reverse().mark(0@0).reverse(); item2 := item2.reverse().mark(0@0).reverse();item2 := item2.seqbase(temp1); item1.access(BAT_APPEND); item1.insert(item2); item1.access(BAT_READ);
kind1 := kind1.reverse().mark(0@0).reverse(); kind2 := kind2.reverse().mark(0@0).reverse();kind2 := kind2.seqbase(temp1); kind1.access(BAT_APPEND); kind1.insert(kind2); kind1.access(BAT_READ);
temp1 := iter1.reverse(); temp1 := temp1.sort(); temp1 := temp1.reverse();temp1 := temp1.CTrefine(ord1); temp1 := temp1.CTrefine(pos1);temp1 := temp1.mark(0@0); temp1 := temp1.reverse();
iter := temp1.join(iter1);pos := temp1.mark(1@0);item := temp1.join(item1);kind := temp1.join(kind1);
iter1 := nil; pos1 := nil; item1 := nil; ord1 := nil; kind1 := nil;iter2 := nil; pos2 := nil; item2 := nil; ord2 := nil; kind2 := nil;temp1 := nil;
} # end of translateSeq (counter)
# deleteResult ()
iter001 := nil;
pos001 := nil;
item001 := nil;
kind001 := nil;
} # deleteResult ()
[ 4 ]
#-----------------------------------------#
# t	tmp_67	tmp_70	tmp_69	tmp_71	  # name
# void	oid	oid	oid	chr	  # type
#-----------------------------------------#
[ 0@0,	  1@0,	  1@0,	  0@0,	  'i'	  ]
[ 1@0,	  1@0,	  1@0,	  1@0,	  'i'	  ]
{
# project ()
var outer001 := iter;
iter := iter.mark(1@0);
var inner001 := iter;
pos := iter.project(1@0);
var loop001 := inner001;
var v_vid001;
var v_iter001;
var v_pos001;
var v_item001;
var v_kind001;
var expOid;
{ # getExpanded (fid)
var vu_nil := vu_fid.uselect(1@0);
vu_nil := vu_nil.mark(10@0);
var vid_vu := vu_vid.reverse();
var oid_nil := vid_vu.join(vu_nil);
vid_vu := nil;
expOid := v_vid000.join(oid_nil);
oid_nil := nil;
expOid := expOid.mirror();
} # end of getExpanded (fid)
if (expOid.count() != 0) {
var oidNew_expOid;
{ # expand ()
var expOid_iter := expOid.join(v_iter000);
var iter_expOid := expOid_iter.reverse();
expOid_iter := nil;
var oidMap_expOid := outer001.join(iter_expOid);
iter_expOid := nil;
var expOid_oidMap := oidMap_expOid.reverse();
oidMap_expOid := nil;
expOid_iter := expOid_oidMap.join(inner001);
expOid_oidMap := nil;
v_iter001 := expOid_iter;
oidNew_expOid := expOid_iter.mark(0@0).reverse();
expOid_iter := nil;
} # end of expand ()
# join ()
v_iter001 := v_iter001.reverse().mark(0@0).reverse();
var new_v_iter := v_iter001;
v_iter001 := bat(void,oid,count(new_v_iter)*2);
v_iter001.seqbase(0@0);
v_iter001.access(BAT_APPEND);
v_iter001.insert(new_v_iter);
new_v_iter := nil;
var new_v_vid := oidNew_expOid.join(v_vid000);
v_vid001 := bat(void,oid,count(new_v_vid)*2);
v_vid001.seqbase(0@0);
v_vid001.access(BAT_APPEND);
v_vid001.insert(new_v_vid);
new_v_vid := nil;
var new_v_pos := oidNew_expOid.join(v_pos000);
v_pos001 := bat(void,oid,count(new_v_pos)*2);
v_pos001.seqbase(0@0);
v_pos001.access(BAT_APPEND);
v_pos001.insert(new_v_pos);
new_v_pos := nil;
var new_v_item := oidNew_expOid.join(v_item000);
v_item001 := bat(void,oid,count(new_v_item)*2);
v_item001.seqbase(0@0);
v_item001.access(BAT_APPEND);
v_item001.insert(new_v_item);
new_v_item := nil;
var new_v_kind := oidNew_expOid.join(v_kind000);
v_kind001 := bat(void,chr,count(new_v_kind)*2);
v_kind001.seqbase(0@0);
v_kind001.access(BAT_APPEND);
v_kind001.insert(new_v_kind);
new_v_kind := nil;
# sort() inside join ()
var temp1 := v_iter001.reverse();
temp1 := temp1.sort();
temp1 := temp1.reverse();
temp1 := temp1.CTrefine(v_pos001);
temp1 := temp1.mark(0@0);
temp1 := temp1.reverse();
v_vid001 := temp1.join(v_vid001).access(BAT_APPEND);
v_iter001 := temp1.join(v_iter001).access(BAT_APPEND);
v_pos001 := temp1.join(v_pos001).access(BAT_APPEND);
v_item001 := temp1.join(v_item001).access(BAT_APPEND);
v_kind001 := temp1.join(v_kind001).access(BAT_APPEND);
} else {
# createNewVarTable ()
v_iter001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
v_vid001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
v_pos001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
v_item001 := bat(void,oid).seqbase(0@0).access(BAT_APPEND);
v_kind001 := bat(void,chr).seqbase(0@0).access(BAT_APPEND);
} # end if
expOid := nil;
# deleteTemp ()
var temp1 := nil;
var temp2 := nil;
var temp3 := nil;
{
int_values.append (1);
var itemID := int_values.uselect(1);
itemID := itemID.reverse().fetch(0);
# translateConst (kind)
iter := loop001;
iter := iter.reverse().mark(0@0).reverse();
pos := iter.project(1@0);
item := iter.project(itemID);
kind := iter.project('i');
itemID := nil;
}
{ # saveResult () : int
var iter001 := iter;
var pos001 := pos;
var item001 := item;
var kind001 := kind;
iter := nil;
pos := nil;
item := nil;
kind := nil;
# saveResult () : int
{
int_values.append (2);
var itemID := int_values.uselect(2);
itemID := itemID.reverse().fetch(0);
# translateConst (kind)
iter := loop001;
iter := iter.reverse().mark(0@0).reverse();
pos := iter.project(1@0);
item := iter.project(itemID);
kind := iter.project('i');
itemID := nil;
}
if (iter.count() = 0) {
        iter := iter001;
        pos := pos001;
        item := item001;
        kind := kind001;
} else if (iter001.count() != 0)
{ # translateSeq (counter)
"print first result".print();
print(iter001,pos001,item001,kind001);
"print second result".print();
print(iter,pos,item,kind);
print("the call of 'merged_union' triggers the error");
var merged_result := merged_union (iter001, iter, pos001, pos, item001, item, kind001, kind);
merged_result.count().print();
print (merged_result.fetch(0), merged_result.fetch(1), merged_result.fetch(2), merged_result.fetch(3));
merged_result := nil;

var iter2 := iter; var pos2 := pos; var item2 := item; var kind2 := kind;
var iter1 := iter001; var pos1 := pos001; var item1 := item001; var kind1 := kind001;
var ord1 := iter1.project(1@0); var ord2 := iter2.project(2@0); var temp1 := count(iter1); temp1 := oid(temp1);
print("the next line produces the error");
iter1 := iter1.reverse().mark(0@0).reverse();
1.print();
 iter2 := iter2.reverse().mark(0@0).reverse();
2.print();
  iter2 := iter2.seqbase(temp1);
3.print();
   iter1.access(BAT_APPEND);
4.print();
    iter1.insert(iter2);
5.print();
     iter1.access(BAT_READ);
6.print();
ord1 := ord1.reverse().mark(0@0).reverse(); ord2 := ord2.reverse().mark(0@0).reverse();ord2 := ord2.seqbase(temp1); ord1.access(BAT_APPEND); ord1.insert(ord2); ord1.access(BAT_READ);
pos1 := pos1.reverse().mark(0@0).reverse(); pos2 := pos2.reverse().mark(0@0).reverse();pos2 := pos2.seqbase(temp1); pos1.access(BAT_APPEND); pos1.insert(pos2); pos1.access(BAT_READ);
item1 := item1.reverse().mark(0@0).reverse(); item2 := item2.reverse().mark(0@0).reverse();item2 := item2.seqbase(temp1); item1.access(BAT_APPEND); item1.insert(item2); item1.access(BAT_READ);
kind1 := kind1.reverse().mark(0@0).reverse(); kind2 := kind2.reverse().mark(0@0).reverse();kind2 := kind2.seqbase(temp1); kind1.access(BAT_APPEND); kind1.insert(kind2); kind1.access(BAT_READ);
temp1 := iter1.reverse(); temp1 := temp1.sort(); temp1 := temp1.reverse();temp1 := temp1.CTrefine(ord1); temp1 := temp1.CTrefine(pos1);temp1 := temp1.mark(0@0); temp1 := temp1.reverse();
iter := temp1.join(iter1);pos := temp1.mark(1@0);item := temp1.join(item1);kind := temp1.join(kind1);
iter1 := nil; pos1 := nil; item1 := nil; ord1 := nil; kind1 := nil;iter2 := nil; pos2 := nil; item2 := nil; ord2 := nil; kind2 := nil;temp1 := nil;
} # end of translateSeq (counter)
# deleteResult ()
iter001 := nil;
pos001 := nil;
item001 := nil;
kind001 := nil;
} # deleteResult ()
{ # mapBack ()
var iter_oidMap := inner001.reverse();
var oid_oidMap := iter.join(iter_oidMap);
iter_oidMap := nil;
iter := oid_oidMap.join(outer001);
oid_oidMap := nil;
pos := pos.mark(1@0);
item := item;
kind := kind;
} # end of mapBack ()
# cleanUpLevel ()
v_vid001 := nil;
v_iter001 := nil;
v_pos001 := nil;
v_item001 := nil;
v_kind001 := nil;
}
[ "print first result" ]
#-----------------------------------------#
# t	tmp_77	tmp_65	tmp_59	tmp_79	  # name
# void	void	oid	oid	chr	  # type
#-----------------------------------------#
[ 0@0,	  1@0,	  1@0,	  0@0,	  'i'	  ]
[ 1@0,	  2@0,	  1@0,	  0@0,	  'i'	  ]
[ "print second result" ]
#-----------------------------------------#
# t	tmp_84	tmp_76	tmp_83	tmp_71	  # name
# void	void	oid	oid	chr	  # type
#-----------------------------------------#
[ 0@0,	  1@0,	  1@0,	  1@0,	  'i'	  ]
[ 1@0,	  2@0,	  1@0,	  1@0,	  'i'	  ]
[ "the call of 'merged_union' triggers the error" ]
[ 4 ]
#-----------------------------------------#
# t	tmp_75	tmp_62	tmp_73	tmp_66	  # name
# void	oid	oid	oid	chr	  # type
#-----------------------------------------#
[ 0@0,	  1@0,	  1@0,	  0@0,	  'i'	  ]
[ 1@0,	  1@0,	  1@0,	  1@0,	  'i'	  ]
[ 2@0,	  2@0,	  1@0,	  0@0,	  'i'	  ]
[ 3@0,	  2@0,	  1@0,	  1@0,	  'i'	  ]
[ "the next line produces the error" ]
[ 1 ]
[ 2 ]
[ 3 ]
[ 4 ]
[ 5 ]
[ 6 ]
quit();

# 19:26:20 >  
# 19:26:20 >  Done.
# 19:26:20 >  

