@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f xquery
@t XQuery implemenation
@a N J Nes
@v 0
@* 
This module contains the MAL wrappers for interaction
with the XQuery parser and runtime system.
@mal
module xquery;

command start():void 
address XQUERYsession
comment "Switch to processing XQUERY statements";

command start2():void 
address XQUERYsession2
comment "Switch to processing pre-cooked XQUERY statements";

command bind( rootid:oid, tname:str, cname:str ):bat[:oid,:any_1]
address xquery_bind
comment "Bind to the xquery column";

command doc( iter:bat[:oid,:oid], name:bat[:oid,:str] ) 
		(resiter:bat[:oid,:oid], root:bat[:oid,:oid])
address xquery_doc
comment "Find the document roots";

command ll_child( iter:bat[:oid,:oid], ctx:bat[:oid,:oid], preSize:bat[:oid,:oid], preKind:bat[:oid,:oid], oneIter:bit, oneCtx:bit, minIter:oid, maxIter:oid, noIterOrder:bit, kindTest:chr):bat[:oid,:oid]
address ll_child
comment "Loop Lifted child step";

command print(mode:str, ws:bat[:oid,:bat],
	item:bat[:oid,:oid], kind:bat[:oid,:int],
        int_values:bat[:oid,:lng], dbl_values:bat[:oid,:dbl],
        dec_values:bat[:oid,:dbl], str_values:bat[:oid,:str]) :void
address xquery_print_result_main_wrap
comment "C interface to Workset result print routine";

command prelude()
address XQUERYprelude;

command epilogue()
address XQUERYepilogue;

xquery.prelude();

@h
#ifndef _XQUERY_H
#define _XQUERY_H

#include <mal.h>
#include <opt_prelude.h>
#include <mal_session.h>

#ifdef _MSC_VER
#ifndef LIBXQUERY
#define xquery_export extern __declspec(dllimport)
#else
#define xquery_export extern __declspec(dllexport)
#endif
#else
#define xquery_export extern
#endif

typedef enum modes_xquery {
    xquery_normal = 0,
    xquery_prepare = 1,
    xquery_execute = 2,
    xquery_explain = 3,
    xquery_profile = 4,
    xquery_debug = 5,
    xquery_trace = 6,
    xquery_inplace = 7
} modes_xquery;

xquery_export str xquery_doc( bat *resiter, bat *root, bat *iter, bat *name );
xquery_export str xquery_bind( bat *res, oid *rootid, str *tname, str *cname /*, int access */ );
xquery_export str ll_child( bat *res, bat *iter, bat *ctx, bat *preSize, bat *preKind, bit *oneIter, bit *oneCtx, oid *minIter, oid *maxIter, bit *noIterOrder, chr *kindTest);
xquery_export str xquery_print_result_main_wrap(int *res /*dummy*/, str *mode, bat *ws, bat *item, bat *kind, bat *int_values, bat *dbl_values, bat *dec_values, bat *str_values); 

#endif /* _XQUERY_H */

@c
#include "pf_config.h"
#include "xquery.h"
#include "serialize.h"

static BAT *
BATfinddescriptor( str name ) 
{
	int bid = BBPindex(name);

	if (bid != 0)
		return BATdescriptor(bid);
	return NULL;
}

/* loop lifted doc function, per iter find the rootid (if it exists) */
str
xquery_doc( bat *resiter, bat *root, bat *iter, bat *name )
{
	BAT *iterb, *nameb, *resiterb, *rootb;
	BAT *doc_name, *doc_collection, *docids, *colids;

	if( (iterb = BATdescriptor(*iter)) == NULL )
		throw(MAL, "xquery.doc", "Cannot access (iter) descriptor");
	if( (nameb = BATdescriptor(*name)) == NULL )
		throw(MAL, "xquery.doc", "Cannot access (name) descriptor");
	if ((doc_name = BATfinddescriptor("doc_name")) == NULL) 
		throw(MAL, "xquery.doc", "Cannot access (doc_name) descriptor");
	if ((doc_collection = BATfinddescriptor("doc_collection")) == NULL) 
		throw(MAL, "xquery.doc", "Cannot access (doc_collection) descriptor");
	(void) iterb; /* pacify compilers */
	docids = BATjoin( nameb, BATmirror(doc_name), BATcount(nameb));
	colids = BATjoin( docids, doc_collection, BATcount(docids));
	BBPunfix(docids->batCacheid);
	
	resiterb = BATmirror(BATmark(colids, 0));
	rootb = BATmirror(BATmark(BATmirror(colids), 0));

	BBPkeepref(*resiter = resiterb->batCacheid);
	BBPkeepref(*root = rootb->batCacheid);
	BBPunfix(doc_collection->batCacheid);
	BBPunfix(doc_name->batCacheid);
	BBPunfix(*iter);
	BBPunfix(*name);
	return MAL_SUCCEED;
}

str
xquery_bind( bat *res, oid *rootid, str *Tname, str *cname /*, int access */ )
{
	char name[BUFSIZ+1];
	char *tname = *Tname;

	/* for readonly tables pre==rid (and currently we only have readonly) */
	if (strcmp(tname, "pre") == 0)
		tname = "rid";

	snprintf(name, BUFSIZ, OIDFMT "_%s_%s", *rootid, tname, *cname);

	*res = BBPindex(name);
	if (!*res) {
		*res = bat_nil;
		throw(MAL, "xquery.bind", "xquery column (%s,%s) for document (" OIDFMT ") not found\n", tname, *cname, *rootid);
	}
	BBPincref(*res, TRUE);
	return MAL_SUCCEED;
}

extern int PFll_child(BAT** res, BAT* iter, BAT* ctx, BAT* pre_size, BAT* cands, bit* one_iter, bit* one_ctx, oid* min_iter, oid* max_iter, bit* no_iter_order, chr* kind_test);

str
ll_child( bat *res, bat *iter, bat *ctx, bat *preSize, bat *preKind, bit *oneIter, bit *oneCtx, oid *minIter, oid *maxIter, bit *noIterOrder, chr *kindTest)
{
	BAT *resb, *iterb, *ctxb, *preSizeB, *preKindB; 

	if( (iterb = BATdescriptor(*iter)) == NULL )
		throw(MAL, "xquery.ll_child", "Cannot access (iter) descriptor");
	if( (ctxb = BATdescriptor(*ctx)) == NULL )
		throw(MAL, "xquery.ll_child", "Cannot access (ctx) descriptor");
	if( (preSizeB = BATdescriptor(*preSize)) == NULL )
		throw(MAL, "xquery.ll_child", "Cannot access (preSize) descriptor");
	if( (preKindB = BATdescriptor(*preKind)) == NULL )
		throw(MAL, "xquery.ll_child", "Cannot access (preKind) descriptor");
	if (PFll_child(&resb, iterb, ctxb, preSizeB, preKindB, oneIter, oneCtx, minIter, maxIter, noIterOrder, kindTest) == GDK_FAIL) 
		throw(MAL, "xquery.ll_child", "failed");
	BBPunfix(*iter);
	BBPunfix(*ctx);
	BBPunfix(*preSize);
	BBPunfix(*preKind);
	BBPkeepref(*res = resb->batCacheid);
	return MAL_SUCCEED;
}

str
xquery_print_result_main_wrap(int *res /*dummy*/, str *mode, bat *ws, bat *item, bat *kind,  bat *int_values, bat *dbl_values, bat *dec_values, bat *str_values)
{
	BAT *wsb, *itemb, *kindb, *intb, *dblb, *decb, *strb;

	
	if( (wsb = BATdescriptor(*ws)) == NULL )
		throw(MAL, "xquery.print", "Cannot access (ws) descriptor");
	if( (itemb = BATdescriptor(*item)) == NULL )
		throw(MAL, "xquery.print", "Cannot access (item) descriptor");
	if( (kindb = BATdescriptor(*kind)) == NULL )
		throw(MAL, "xquery.print", "Cannot access (kind) descriptor");
	if( (intb = BATdescriptor(*int_values)) == NULL )
		throw(MAL, "xquery.print", "Cannot access (int_values) descriptor");
	if( (dblb = BATdescriptor(*dbl_values)) == NULL )
		throw(MAL, "xquery.print", "Cannot access (dbl_values) descriptor");
	if( (decb = BATdescriptor(*dec_values)) == NULL )
		throw(MAL, "xquery.print", "Cannot access (dec_values) descriptor");
	if( (strb = BATdescriptor(*str_values)) == NULL )
		throw(MAL, "xquery.print", "Cannot access (str_values) descriptor");
	
	(void) decb; /* pacify compilers */
	if (xquery_print_result_DRIVER(*mode, NULL, NULL, wsb, 1, itemb, itemb, itemb, kindb, intb, dblb, strb, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == GDK_FAIL) {
		throw(MAL, "xquery.print", "print failed");
	}
	BBPunfix(*ws);
	BBPunfix(*item);
	BBPunfix(*kind);
	BBPunfix(*int_values);
	BBPunfix(*dbl_values);
	BBPunfix(*dec_values);
	BBPunfix(*str_values);
	(void)res;
	return MAL_SUCCEED;
}
