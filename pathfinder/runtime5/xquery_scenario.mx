@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f xquery_scenario
@t XQUERY scenario 
@a N. Nes
@+ XQUERY scenario
The XQUERY scenario implementation is a derivative of the MAL session scenario.

@h
#ifndef _XQUERY_SCENARIO_H_
#define _XQUERY_SCENARIO_H_
#include "xquery.h"

#define _XQUERY_SCENARIO_DEBUG 
#define _XQUERY_READER_DEBUG 
/* #define _XQUERY_PARSER_DEBUG */

xquery_export str XQUERYsession(str *ret);
xquery_export str XQUERYsession2(str *ret);
xquery_export str XQUERYprelude(void);
xquery_export str XQUERYepilogue(void);

xquery_export str XQUERYexit(Client c);
xquery_export str XQUERYinit(Client c);
xquery_export str XQUERYexitClient(Client c);
xquery_export str XQUERYinitClient(Client c);
xquery_export str XQUERYreader(Client c);
xquery_export str XQUERYparser(Client c);
xquery_export str XQUERYengine(Client c);

#endif /* _XQUERY_SCENARIO_H_ */

@c
#include "pf_config.h"
#include "xquery_scenario.h"
#include "xquery_backend.h"
#include <mal_instruction.h>
#include <mal_interpreter.h>
#include <mal_namespace.h>
#include <mal_parser.h>

str
XQUERYsession(str *ret)
{
	str msg = MAL_SUCCEED;

	msg = setScenario(MCgetClient(), "xquery");
	*ret = 0;
	return msg;
}

str
XQUERYsession2(str *ret)
{
	str msg = MAL_SUCCEED;

	msg = setScenario(MCgetClient(), "mxquery");
	*ret = 0;
	return msg;
}

str
XQUERYprelude(void)
{
	Scenario s = getFreeScenario();
	if (!s)
		throw(MAL, "xquery.start", "out of scenario slots");
	s->name = "xquery";
	s->language = "xq";
	s->initSystem = "XQUERYinit";
	s->exitSystem = "XQUERYexit";
	s->initClient = "XQUERYinitClient";
	s->exitClient = "XQUERYexitClient";
	s->reader = "XQUERYreader";
	s->parser = "XQUERYparser";
	s->optimizer = "XQUERYoptimizer";
	/* s->tactics = .. */
	s->engine = "XQUERYengine";

	s = getFreeScenario();
	if (!s)
		throw(MAL, "xquery.start", "out of scenario slots");

	s->name = "mxquery";
	s->language = "xq";
	s->initSystem = "XQUERYinit";
	s->exitSystem = "XQUERYexit";
	s->initClient = "XQUERYinitClient";
	s->exitClient = "XQUERYexitClient";
	s->reader = "MALreader";
	s->parser = "MALparser";
	s->optimizer = "MALoptimizer";
	/* s->tactics = .. */
	s->engine = "MALengine";
	return MAL_SUCCEED;
}
str
XQUERYepilogue(void)
{
	return MAL_SUCCEED;
}

str
XQUERYinit(Client c)
{
	(void) c;		/* not used */
	optimizerInit();
	return MAL_SUCCEED;
}

str
XQUERYexit(Client c)
{
	(void) c;		/* not used */
	return MAL_SUCCEED;
}

str
XQUERYinitClient(Client c)
{
	if (c->state[MAL_SCENARIO_PARSER] == NULL) {
		Xbackend  xb = newXbackend(c);
		c->state[MAL_SCENARIO_PARSER] = (void*)xb;
	}

	c->yycur = 0;		/* make sure we don't reuse the used input */
	c->fdin->eof = 1;	/* force prompt on first iteration */
	return MAL_SUCCEED;
}

str
XQUERYexitClient(Client c)
{
	if (c->state[MAL_SCENARIO_PARSER]) {
		GDKfree(c->state[MAL_SCENARIO_PARSER]); /* TODO destroyXbackend */
		c->state[MAL_SCENARIO_PARSER] = NULL;
	}
	return MAL_SUCCEED;
}

str
XQUERYreader(Client c)
{
	int go = TRUE;
	int more = TRUE;
	Xbackend be = ((Xbackend) c->state[MAL_SCENARIO_PARSER]);
	bstream *in = c->fdin;
	int language = -1;
	int blocked = isa_block_stream(in->s);

	if (c->mode <= FINISHING) {
		c->mode = FINISHING;
		return NULL;
	}

	language = be->language;	

@-
Distinguish between console reading and mclient connections.
The former comes with readline functionality.
@c
	while(more) {
	    more = FALSE;
	    if (go && in->pos >= in->len) {
		ssize_t rd;

		if (c->bak) {
			MCpopClientInput(c);
			in = c->fdin;
			c->fdin->pos += c->yycur;
			c->yycur = 0;
		}
		if (in->eof || !blocked) {
			language = (be->console) ? 'S' : 0;

			if (go && ((!blocked && stream_write(c->fdout, c->prompt, c->promptlength, 1) != 1) || stream_flush(c->fdout))) {
				go = FALSE;
				break;
			}
			in->eof = 0;
		}
		if (go && (rd = bstream_next(in)) <= 0) {
#ifdef _XQUERY_READER_DEBUG
			stream_printf(GDKout, "#rd %d  language %d eof %d\n", rd, language, in->eof);
#endif
			if (rd == 0 && language != 0 && in->eof && !be->console) {
				/* we hadn't seen the EOF before, so just try again
				   (this time with prompt) */
				more = TRUE;
				continue;
			}
			go = FALSE;
			break;
		} else if (go && !be->console && language == 0) {
			be->language = in->buf[in->pos++];
		}
	    }
	}
	if (!go || (strncmp(in->buf+in->pos, "\\q", 2) == 0)) {
		in->pos = in->len;	/* skip rest of the input */
		c->mode = FINISHING;
		return NULL;
	}
#ifdef _XQUERY_READER_DEBUG
	stream_printf(c->fdout, "#xquery: '%s'\n", in->buf+in->pos);
#endif
	return MAL_SUCCEED;
}

str
XQUERYparser(Client c)
{
	Xbackend xb;
	int err = 0, oldstop;

#ifdef _XQUERY_SCENARIO_DEBUG
	stream_printf(c->fdout,"#start the xquery parser\n");
#endif

	xb = (Xbackend) c->state[MAL_SCENARIO_PARSER];
	if(xb == NULL || c->curprg->def== NULL) 
		return createException(MAL, "xquery.parser","No context available\n");

	oldstop = c->curprg->def->stop;

	/* Here the current query should be parsed and converted into mal */ 

	/* parsed query, jump to the end for now (HACK) */
	c->fdin->pos = c->fdin->len;

	if( err == 0){
		pushEndInstruction(c->curprg->def);
		chkProgram(c->nspace, c->curprg->def);
	}
	if( c->curprg->def->errors || err){
		showErrors();
		if( xb->mode == xquery_explain)
			printFunction(c->fdout, c->curprg->def,LIST_MAL_ALL);
		/* restore the state */
		resetMalBlk(c->curprg->def, oldstop);
		c->curprg->def->errors = 0;
		return createException(MAL, "xquery.parser","Parsing errors\n");
	} 
	return MAL_SUCCEED;
}

str
XQUERYoptimizer(Client c)
{	
#ifdef _XQUERY_SCENARIO_DEBUG
	stream_printf(c->fdout,"#start the xquery optimizer\n");
#endif
	(void)c;
	return MAL_SUCCEED;
}
	
str
XQUERYengine(Client c)
{
	Xbackend xb;

#ifdef _XQUERY_SCENARIO_DEBUG
	stream_printf(c->fdout,"#start the xquery engine\n");
#endif
	xb= (Xbackend) c->state[MAL_SCENARIO_PARSER];
	if (xb == NULL || c->curprg->def== NULL|| c->curprg->def->errors)
		return MAL_SUCCEED;

	if( xb->mode == xquery_explain)
		printFunction(c->fdout, c->curprg->def,0);
	/* restore the initial state */
	resetMalBlk(c->curprg->def, 1);
	return MAL_SUCCEED;
}
